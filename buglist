=========================================================================

bug 7236: 
todo 330:
wish 1011:
meh 5:
errors 10016:
warnings 20572:
macros 30234:
typos 40363:
dup 50006:
nonextend 60077:

=========================================================================
warnings 20571:

>compiling INBFF.spad to INBFF.nrlib
 
   Warnings: 
      [1] dAndcExp:  erg has no value

=========================================================================
warnings 20570:

>compiling DFLOAT.spad to DFLOAT.nrlib
 
   Warnings: 
      [1] mantissa:  MANTISSA has no value
      [2] exponent:  EXPONENT has no value
      [3] hash: signature of lhs not unique: (Integer)$ chosen

=========================================================================
warnings 20569:

>compiling LIST.spad to LIST.nrlib
 
   Warnings: 
      [1] setIntersection:  u has no value
      [2] setDifference:  lu has no value
 
=========================================================================
warnings 20568:

>compiling MFLOAT.spad to MFLOAT.nrlib
 
   Warnings: 
      [1] normalise:  man has no value
      [2] changeBase:  newMan has no value
      [3] changeBase:  newExp has no value
      [4] changeBase:  f has no value
 
=========================================================================
warnings 20567:

>compiling SMTS.spad to SMTS.nrlib
 
   Warnings: 
      [1] evalstream:  z1 has no value
      [2] addvariable:  c2 has no value
      [3] addvariable:  n1 has no value
      [4] coefficient: signature of lhs not unique: SMP$(NonNegativeInteger) chosen
      [5] coefficient:  z1 has no value
      [6] *: pretendRep -- should replace by @
      [7] *: pretend$ -- should replace by @
      [8] sortmfirst:  v2 has no value
      [9] sortmfirst:  v1 has no value
      [10] csubst:  p1 has no value
      [11] eval: pretend$ -- should replace by @
      [12] subststream: pretend$ -- should replace by @
      [13] comp1:  p1 has no value
      [14] differentiate:  z1 has no value
      [15] stream: pretendRep -- should replace by @
      [16] *:  z1 has no value
      [17] fintegrate:  z1 has no value
      [18] integrate:  z1 has no value
      [19] coerce:  l has no value
      [20] /:  z1 has no value
      [21] /: pretend$ -- should replace by @
 
=========================================================================
nonextend 60076:

>compiling AFFSP.spad to AFFSP.nrlib

--------------non extending category----------------------
.. AffineSpace(#1,#2) of cat 
(|AffineSpaceCategory| |#2|)   has no 
(|ListAggregate| |#2|)    finalizing nrlib AFFSP 


=========================================================================
todo 329:

>compiling OUT.spad to OUT.nrlib
      [1] output: :(OutputForm) -- should replace by pretend

=========================================================================
bug 7234: 

>compiling EFULS.spad to EFULS.nrlib

   Illegal nrlib 
   EFULS.nrlib claims that its constructor name is the package 
      ElementaryFunctionsUnivariateLaurentSeries but 
      ElementaryFunctionsUnivariateLaurentSeries is already known to be
      the for domain EFULS .
   EFULS abbreviates package ElementaryFunctionsUnivariateLaurentSeries

=========================================================================
nonextend 60075:

>compiling BSTREE.spad to BSTREE.nrlib
--------------non extending category----------------------
.. BinarySearchTree(#1) of cat 
(|Join| (|BinaryTreeCategory| |#1|) (CATEGORY |domain| (ATTRIBUTE |shallowlyMutable|) (ATTRIBUTE |finiteAggregate|) (SIGNATURE |binarySearchTree| ($ (|List| |#1|))) (SIGNATURE |insert!| ($ |#1| $)) (SIGNATURE |insertRoot!| ($ |#1| $)) (SIGNATURE |split| ((|Record| (|:| |less| $) (|:| |greater| $)) |#1| $))))    has no  binaryTree : #1 -> % 

=========================================================================
nonextend 60074:

>compiling BTOURN.spad to BTOURN.nrlib
 
--------------non extending category----------------------
.. BinaryTournament(#1) of cat 
(|Join| (|BinaryTreeCategory| |#1|) (CATEGORY |domain| (ATTRIBUTE |shallowlyMutable|) (SIGNATURE |binaryTournament| ($ (|List| |#1|))) (SIGNATURE |insert!| ($ |#1| $))))    has no  binaryTree : #1 -> % 

=========================================================================
nonextend 60073:

>compiling BBTREE.spad to BBTREE.nrlib
 
--------------non extending category----------------------
.. BalancedBinaryTree(#1) of cat 
(|Join| (|BinaryTreeCategory| |#1|) (CATEGORY |domain| (ATTRIBUTE |finiteAggregate|) (ATTRIBUTE |shallowlyMutable|) (SIGNATURE |balancedBinaryTree| ($ (|NonNegativeInteger|) |#1|)) (SIGNATURE |setleaves!| ($ $ (|List| |#1|))) (SIGNATURE |mapUp!| (|#1| $ (|Mapping| |#1| |#1| |#1|))) (SIGNATURE |mapUp!| ($ $ $ (|Mapping| |#1| |#1| |#1| |#1| |#1|))) (SIGNATURE |mapDown!| ($ $ |#1| (|Mapping| |#1| |#1| |#1|))) (SIGNATURE |mapDown!| ($ $ |#1| (|Mapping| (|List| |#1|) |#1| |#1| |#1|)))))    has no  binaryTree : #1 -> % 

=========================================================================
nonextend 60072:

>compiling D01GBFA.spad to D01GBFA.nrlib

--------------non extending category----------------------
.. d01gbfAnnaType of cat 
(|NumericalIntegrationCategory|)   has no 
(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib D01GBFA 

=========================================================================
nonextend 60071:

>compiling D02EJFA.spad to D02EJFA.nrlib
--------------non extending category----------------------
.. d02ejfAnnaType of cat 
(|OrdinaryDifferentialEquationsSolverCategory|)   has no 
(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib D02EJFA 

=========================================================================
nonextend 60070:

>compiling D03FAFA.spad to D03FAFA.nrlib
--------------non extending category----------------------
.. d03fafAnnaType of cat 
(|PartialDifferentialEquationsSolverCategory|)   has no 
(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib D03FAFA 

=========================================================================
nonextend 60069:

>compiling D01FCFA.spad to D01FCFA.nrlib
 
--------------non extending category----------------------
.. d01fcfAnnaType of cat 
(|NumericalIntegrationCategory|)   has no 
(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib D01FCFA 

=========================================================================
nonextend 60068:

>compiling LPOLY.spad to LPOLY.nrlib
--------------non extending category----------------------
.. LiePolynomial(#1,#2) of cat 
(|Join| (|FreeLieAlgebra| |#1| |#2|) (|FreeModuleCat| |#2| (|LyndonWord| |#1|)) (CATEGORY |domain| (SIGNATURE |LiePolyIfCan| ((|Union| $ "failed") (|XDistributedPolynomial| |#1| |#2|))) (SIGNATURE |construct| ($ (|LyndonWord| |#1|) (|LyndonWord| |#1|))) (SIGNATURE |construct| ($ (|LyndonWord| |#1|) $)) (SIGNATURE |construct| ($ $ (|LyndonWord| |#1|)))))    has no  ?*? : (LyndonWord(#1),#2) -> % 

=========================================================================
nonextend 60067:

>compiling DBASE.spad to DBASE.nrlib
--------------non extending category----------------------
.. Database(#1) of cat 
(|Join| (|SetCategory|) (CATEGORY |domain| (SIGNATURE |elt| ($ $ (|QueryEquation|))) (SIGNATURE |elt| ((|DataList| (|String|)) $ (|Symbol|))) (SIGNATURE + ($ $ $)) (SIGNATURE - ($ $ $)) (SIGNATURE |coerce| ($ (|List| |#1|))) (SIGNATURE |display| ((|Void|) $)) (SIGNATURE |fullDisplay| ((|Void|) $)) (SIGNATURE |fullDisplay| ((|Void|) $ (|PositiveInteger|) (|PositiveInteger|)))))   has no 
(|ListAggregate| |#1|)    finalizing nrlib DBASE 

=========================================================================
nonextend 60066:

>compiling DHMATRIX.spad to DHMATRIX.nrlib
 
--------------non extending category----------------------
.. DenavitHartenbergMatrix(#1) of cat 
(|Join| (|MatrixCategory| |#1| (|Vector| |#1|) (|Vector| |#1|)) (CATEGORY |domain| (SIGNATURE * ((|Point| |#1|) $ (|Point| |#1|))) (SIGNATURE |identity| ($)) (SIGNATURE |rotatex| ($ |#1|)) (SIGNATURE |rotatey| ($ |#1|)) (SIGNATURE |rotatez| ($ |#1|)) (SIGNATURE |scale| ($ |#1| |#1| |#1|)) (SIGNATURE |translate| ($ |#1| |#1| |#1|))))    has no  diagonalMatrix : Vector(#1) -> % 

=========================================================================
nonextend 60065:

>compiling D02BBFA.spad to D02BBFA.nrlib
--------------non extending category----------------------
.. d02bbfAnnaType of cat 
(|OrdinaryDifferentialEquationsSolverCategory|)   has no 
(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib D02BBFA 

=========================================================================
nonextend 60064:

>compiling D02BHFA.spad to D02BHFA.nrlib
 
--------------non extending category----------------------
.. d02bhfAnnaType of cat 
(|OrdinaryDifferentialEquationsSolverCategory|)   has no 
(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib D02BHFA 

=========================================================================
nonextend 60063:

>compiling D02CJFA.spad to D02CJFA.nrlib
 
--------------non extending category----------------------
.. d02cjfAnnaType of cat 
(|OrdinaryDifferentialEquationsSolverCategory|)   has no 
(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib D02CJFA 

=========================================================================
nonextend 60062:

>compiling FNLA.spad to FNLA.nrlib
 
--------------non extending category----------------------
.. FreeNilpotentLie(#1,#2,#3) of cat 
(|Join| (|NonAssociativeAlgebra| |#3|) (CATEGORY |domain| (SIGNATURE |dimension| ((|NonNegativeInteger|))) (SIGNATURE |deepExpand| ((|OutputForm|) $)) (SIGNATURE |shallowExpand| ((|OutputForm|) $)) (SIGNATURE |generator| ($ (|NonNegativeInteger|)))))   has no 
(|IndexedDirectProductCategory| |#3| (|OrdSetInts|))    finalizing nrlib FNLA 
   Processing FreeNilpotentLie for Browser database:

=========================================================================
nonextend 60061:

>compiling POINT.spad to POINT.nrlib
--------------non extending category----------------------
.. Point(#1) of cat 
(|PointCategory| |#1|)    has no  vector : List(#1) -> % 

=========================================================================
nonextend 60060:

>compiling STRING.spad to STRING.nrlib
 
--------------non extending category----------------------
.. String of cat 
(|StringCategory|)    has no  hash : % -> Integer 

=========================================================================
nonextend 60059:

>compiling BINARY.spad to BINARY.nrlib
--------------non extending category----------------------
.. BinaryExpansion of cat 
(|Join| (|QuotientFieldCategory| (|Integer|)) (CATEGORY |domain| (SIGNATURE |coerce| ((|Fraction| (|Integer|)) $)) (SIGNATURE |coerce| ((|RadixExpansion| 2) $)) (SIGNATURE |fractionPart| ((|Fraction| (|Integer|)) $)) (SIGNATURE |binary| ($ (|Fraction| (|Integer|))))))    has no  wholeRagits : % -> List(Integer) 

=========================================================================
nonextend 60058:

>compiling DECIMAL.spad to DECIMAL.nrlib
--------------non extending category----------------------
.. DecimalExpansion of cat 
(|Join| (|QuotientFieldCategory| (|Integer|)) (CATEGORY |domain| (SIGNATURE |coerce| ((|Fraction| (|Integer|)) $)) (SIGNATURE |coerce| ((|RadixExpansion| 10) $)) (SIGNATURE |fractionPart| ((|Fraction| (|Integer|)) $)) (SIGNATURE |decimal| ($ (|Fraction| (|Integer|))))))    has no  wholeRagits : % -> List(Integer) 
   finalizing nrlib DECIMAL 

=========================================================================
nonextend 60057:

>compiling E04DGFA.spad to E04DGFA.nrlib
--------------non extending category----------------------
.. e04dgfAnnaType of cat 
(|NumericalOptimizationCategory|)   has no 
(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib E04DGFA 
   Processing e04dgfAnnaType for Browser database:

=========================================================================
nonextend 60056:

>compiling E04FDFA.spad to E04FDFA.nrlib
--------------non extending category----------------------
.. e04fdfAnnaType of cat 
(|NumericalOptimizationCategory|)   has no 
(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib E04FDFA 

=========================================================================
nonextend 60055:

>compiling E04GCFA.spad to E04GCFA.nrlib
--------------non extending category----------------------
.. e04gcfAnnaType of cat 
(|NumericalOptimizationCategory|)   has no 
(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib E04GCFA 

=========================================================================
nonextend 60054:

>compiling E04JAFA.spad to E04JAFA.nrlib
--------------non extending category----------------------
.. e04jafAnnaType of cat 
(|NumericalOptimizationCategory|)   has no 
(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib E04JAFA 
   Processing e04jafAnnaType for Browser database:

=========================================================================
nonextend 60053:

>compiling E04UCFA.spad to E04UCFA.nrlib
--------------non extending category----------------------
.. e04ucfAnnaType of cat 
(|NumericalOptimizationCategory|)   has no 
(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib E04UCFA 

=========================================================================
nonextend 60052:

>compiling FRAC.spad to FRAC.nrlib
 
--------------non extending category----------------------
.. Fraction(#1) of cat 
(|Join| (|QuotientFieldCategory| |#1|) (CATEGORY |package| (IF (|has| |#1| (|IntegerNumberSystem|)) (IF (|has| |#1| (|OpenMath|)) (ATTRIBUTE (|OpenMath|)) |noBranch|) |noBranch|) (IF (|has| |#1| (ATTRIBUTE |canonical|)) (IF (|has| |#1| (|GcdDomain|)) (IF (|has| |#1| (ATTRIBUTE |canonicalUnitNormal|)) (ATTRIBUTE |canonical|) |noBranch|) |noBranch|) |noBranch|)))   has no 
(IF (|has| |#1| (|OrderedRing|)) (ATTRIBUTE (|OrderedRing|)) |noBranch|)    finalizing nrlib FRAC 

=========================================================================
nonextend 60051:

>compiling FTEM.spad to FTEM.nrlib
 
--------------non extending category----------------------
.. FortranTemplate of cat 
(|Join| (|FileCategory| (|FileName|) (|String|)) (CATEGORY |package| (SIGNATURE |processTemplate| ((|FileName|) (|FileName|) (|FileName|))) (SIGNATURE |processTemplate| ((|FileName|) (|FileName|))) (SIGNATURE |fortranLiteralLine| ((|Void|) (|String|))) (SIGNATURE |fortranLiteral| ((|Void|) (|String|))) (SIGNATURE |fortranCarriageReturn| ((|Void|)))))    has no  writeLine! : (%,String) -> String 


=========================================================================
nonextend 60050:

>compiling GMODPOL.spad to GMODPOL.nrlib

(|Module| |#6|)    extends 
(|BiModule| |#6| |#6|)    but not 
(|BiModule| |#2| |#2|) --------------non extending category----------------------
.. GeneralModulePolynomial(#1,#2,#3,#4,#5,#6) of cat 
(|Join| (|Module| |#6|) (|Module| |#2|) (CATEGORY |domain| (SIGNATURE |leadingCoefficient| (|#2| $)) (SIGNATURE |leadingMonomial| ((|ModuleMonomial| |#3| |#4| |#5|) $)) (SIGNATURE |leadingExponent| (|#4| $)) (SIGNATURE |leadingIndex| (|#3| $)) (SIGNATURE |reductum| ($ $)) (SIGNATURE |monomial| ($ |#2| (|ModuleMonomial| |#3| |#4| |#5|))) (SIGNATURE |unitVector| ($ |#3|)) (SIGNATURE |build| ($ |#2| |#3| |#4|)) (SIGNATURE |multMonom| ($ |#2| |#4| $)) (SIGNATURE * ($ |#6| $))))   has no 
(|IndexedDirectProductCategory| |#2| (|ModuleMonomial| |#3| |#4| |#5|))    finalizing nrlib GMODPOL 

=========================================================================
nonextend 60049:

>compiling HEXADEC.spad to HEXADEC.nrlib
 
--------------non extending category----------------------
.. HexadecimalExpansion of cat 
(|Join| (|QuotientFieldCategory| (|Integer|)) (CATEGORY |domain| (SIGNATURE |coerce| ((|Fraction| (|Integer|)) $)) (SIGNATURE |coerce| ((|RadixExpansion| 16) $)) (SIGNATURE |fractionPart| ((|Fraction| (|Integer|)) $)) (SIGNATURE |hex| ($ (|Fraction| (|Integer|))))))    has no  wholeRagits : % -> List(Integer) 

=========================================================================
nonextend 60048:

>compiling MINT.spad to MINT.nrlib

(|RealConstant|)    extends 
(|ConvertibleTo| (|DoubleFloat|))    but not 
(|ConvertibleTo| (|String|)) --------------non extending category----------------------
.. MachineInteger of cat 
(|Join| (|FortranMachineTypeCategory|) (|IntegerNumberSystem|) (CATEGORY |domain| (SIGNATURE |maxint| ((|PositiveInteger|) (|PositiveInteger|))) (SIGNATURE |maxint| ((|PositiveInteger|))) (SIGNATURE |coerce| ((|Expression| $) (|Expression| (|Integer|))))))   has no 
(|ConvertibleTo| (|String|))    finalizing nrlib MINT 

=========================================================================
nonextend 60047:

>compiling NSUP.spad to NSUP.nrlib
 
--------------non extending category----------------------
.. NewSparseUnivariatePolynomial(#1) of cat 
(|Join| (|UnivariatePolynomialCategory| |#1|) (|CoercibleTo| (|SparseUnivariatePolynomial| |#1|)) (|RetractableTo| (|SparseUnivariatePolynomial| |#1|)) (CATEGORY |domain| (SIGNATURE |fmecg| ($ $ (|NonNegativeInteger|) |#1| $)) (SIGNATURE |monicModulo| ($ $ $)) (SIGNATURE |lazyResidueClass| ((|Record| (|:| |polnum| $) (|:| |polden| |#1|) (|:| |power| (|NonNegativeInteger|))) $ $)) (SIGNATURE |lazyPseudoRemainder| ($ $ $)) (SIGNATURE |lazyPseudoDivide| ((|Record| (|:| |coef| |#1|) (|:| |gap| (|NonNegativeInteger|)) (|:| |quotient| $) (|:| |remainder| $)) $ $)) (SIGNATURE |lazyPseudoQuotient| ($ $ $)) (IF (|has| |#1| (|IntegralDomain|)) (PROGN (SIGNATURE |subResultantsChain| ((|List| $) $ $)) (SIGNATURE |lastSubResultant| ($ $ $)) (SIGNATURE |extendedSubResultantGcd| ((|Record| (|:| |gcd| $) (|:| |coef1| $) (|:| |coef2| $)) $ $)) (SIGNATURE |halfExtendedSubResultantGcd1| ((|Record| (|:| |gcd| $) (|:| |coef1| $)) $ $)) (SIGNATURE |halfExtendedSubResultantGcd2| ((|Record| (|:| |gcd| $) (|:| |coef2| $)) $ $)) (SIGNATURE |extendedResultant| ((|Record| (|:| |resultant| |#1|) (|:| |coef1| $) (|:| |coef2| $)) $ $)) (SIGNATURE |halfExtendedResultant1| ((|Record| (|:| |resultant| |#1|) (|:| |coef1| $)) $ $)) (SIGNATURE |halfExtendedResultant2| ((|Record| (|:| |resultant| |#1|) (|:| |coef2| $)) $ $))) |noBranch|)))    has no  outputForm : (%,OutputForm) -> OutputForm 

=========================================================================
nonextend 60046:

>compiling SMTS.spad to SMTS.nrlib
 
--------------non extending category----------------------
.. SparseMultivariateTaylorSeries(#1,#2,#3) of cat 
(|Join| (|MultivariateTaylorSeriesCategory| |#1| |#2|) (CATEGORY |domain| (SIGNATURE |coefficient| (|#3| $ (|NonNegativeInteger|))) (SIGNATURE |coerce| ($ |#2|)) (SIGNATURE |coerce| ($ |#3|)) (SIGNATURE * ($ |#3| $)) (SIGNATURE |csubst| ((|Mapping| (|Stream| |#3|) |#3|) (|List| |#2|) (|List| (|Stream| |#3|)))) (IF (|has| |#1| (|Algebra| (|Fraction| (|Integer|)))) (PROGN (SIGNATURE |integrate| ($ $ |#2| |#1|)) (SIGNATURE |fintegrate| ($ (|Mapping| $) |#2| |#1|))) |noBranch|)))    has no  coefficients : % -> Stream(#3) 

=========================================================================
nonextend 60045:

>compiling SUP.spad to SUP.nrlib
 
--------------non extending category----------------------
.. SparseUnivariatePolynomial(#1) of cat 
(|Join| (|UnivariatePolynomialCategory| |#1|) (CATEGORY |domain| (SIGNATURE |outputForm| ((|OutputForm|) $ (|OutputForm|))) (SIGNATURE |fmecg| ($ $ (|NonNegativeInteger|) |#1| $))))   has no 
(IF (|has| |#1| (|IntegralDomain|)) (IF (|has| (|NonNegativeInteger|) (|CancellationAbelianMonoid|)) (SIGNATURE |fmecg| ($ $ (|NonNegativeInteger|) |#1| $)) |noBranch|) |noBranch|)    finalizing nrlib SUP 

=========================================================================
nonextend 60044:

>compiling SUPEXPR.spad to SUPEXPR.nrlib
--------------non extending category----------------------
.. SparseUnivariatePolynomialExpressions(#1) of cat 
(|Join| (|UnivariatePolynomialCategory| |#1|) (CATEGORY |package| (IF (|has| |#1| (|TranscendentalFunctionCategory|)) (ATTRIBUTE (|TranscendentalFunctionCategory|)) |noBranch|)))    has no  outputForm : (%,OutputForm) -> OutputForm 

=========================================================================
nonextend 60043:

>compiling UP.spad to UP.nrlib
 
--------------non extending category----------------------
.. UnivariatePolynomial(#1,#2) of cat 
(|Join| (|UnivariatePolynomialCategory| |#2|) (CATEGORY |domain| (SIGNATURE |coerce| ($ (|Variable| |#1|))) (SIGNATURE |fmecg| ($ $ (|NonNegativeInteger|) |#2| $))))    has no  outputForm : (%,OutputForm) -> OutputForm 

=========================================================================
nonextend 60042:

>compiling EXPUPXS.spad to EXPUPXS.nrlib

--------------non extending category----------------------
.. ExponentialOfUnivariatePuiseuxSeries(#1,#2,#3) of cat 
(|Join| (|UnivariatePuiseuxSeriesCategory| |#1|) (|OrderedAbelianMonoid|) (CATEGORY |domain| (SIGNATURE |exponential| ($ (|UnivariatePuiseuxSeries| |#1| |#2| |#3|))) (SIGNATURE |exponent| ((|UnivariatePuiseuxSeries| |#1| |#2| |#3|) $)) (SIGNATURE |exponentialOrder| ((|Fraction| (|Integer|)) $))))   has no 
(|UnivariatePuiseuxSeriesConstructorCategory| |#1| (|UnivariateLaurentSeries| |#1| |#2| |#3|))    finalizing nrlib EXPUPXS 

=========================================================================
nonextend 60041:

>compiling BSD.spad to BSD.nrlib
--------------non extending category----------------------
.. BasicStochasticDifferential of cat 
(|Join| (|OrderedSet|) (CATEGORY |domain| (ATTRIBUTE (|ConvertibleTo| (|Symbol|))) (SIGNATURE |convertIfCan| ((|Union| $ "failed") (|Symbol|))) (SIGNATURE |convert| ($ (|Symbol|))) (SIGNATURE |introduce!| ((|Union| $ "failed") (|Symbol|) (|Symbol|))) (SIGNATURE |d| ((|Union| $ (|Integer|)) (|Symbol|))) (SIGNATURE |copyBSD| ((|List| $))) (SIGNATURE |copyIto| ((|Table| (|Symbol|) $))) (SIGNATURE |getSmgl| ((|Union| (|Symbol|) "failed") $))))   has no 
(|ConvertibleTo| (|InputForm|))    finalizing nrlib BSD 

=========================================================================
nonextend 60040:

>compiling ANTISYM.spad to ANTISYM.nrlib

--------------non extending category----------------------
.. AntiSymm(#1,#2) of cat 
(|Join| (|LeftAlgebra| |#1|) (|RetractableTo| |#1|) (CATEGORY |domain| (SIGNATURE |leadingCoefficient| (|#1| $)) (SIGNATURE |leadingBasisTerm| ($ $)) (SIGNATURE |reductum| ($ $)) (SIGNATURE |coefficient| (|#1| $ $)) (SIGNATURE |generator| ($ (|NonNegativeInteger|))) (SIGNATURE |exp| ($ (|List| (|Integer|)))) (SIGNATURE |homogeneous?| ((|Boolean|) $)) (SIGNATURE |retractable?| ((|Boolean|) $)) (SIGNATURE |degree| ((|NonNegativeInteger|) $)) (SIGNATURE |map| ($ (|Mapping| |#1| |#1|) $))))   has no 
(|BiModule| |#1| |#1|)    finalizing nrlib ANTISYM 

=========================================================================
nonextend 60039:

>compiling FEXPR.spad to FEXPR.nrlib
 
--------------non extending category----------------------
.. FortranExpression(#1,#2,#3) of cat 
(|Join| (|ExpressionSpace|) (|Algebra| |#3|) (|RetractableTo| |#3|) (|PartialDifferentialRing| (|Symbol|)) (CATEGORY |domain| (SIGNATURE |retract| ($ (|Expression| |#3|))) (SIGNATURE |retractIfCan| ((|Union| $ "failed") (|Expression| |#3|))) (SIGNATURE |retract| ($ (|Symbol|))) (SIGNATURE |retractIfCan| ((|Union| $ "failed") (|Symbol|))) (SIGNATURE |coerce| ((|Expression| |#3|) $)) (IF (|has| |#3| (|RetractableTo| (|Integer|))) (PROGN (SIGNATURE |retract| ($ (|Expression| (|Integer|)))) (SIGNATURE |retractIfCan| ((|Union| $ "failed") (|Expression| (|Integer|)))) (SIGNATURE |retract| ($ (|Fraction| (|Polynomial| (|Integer|))))) (SIGNATURE |retractIfCan| ((|Union| $ "failed") (|Fraction| (|Polynomial| (|Integer|))))) (SIGNATURE |retract| ($ (|Polynomial| (|Integer|)))) (SIGNATURE |retractIfCan| ((|Union| $ "failed") (|Polynomial| (|Integer|))))) |noBranch|) (IF (|has| |#3| (|RetractableTo| (|Float|))) (PROGN (SIGNATURE |retract| ($ (|Expression| (|Float|)))) (SIGNATURE |retractIfCan| ((|Union| $ "failed") (|Expression| (|Float|)))) (SIGNATURE |retract| ($ (|Fraction| (|Polynomial| (|Float|))))) (SIGNATURE |retractIfCan| ((|Union| $ "failed") (|Fraction| (|Polynomial| (|Float|))))) (SIGNATURE |retract| ($ (|Polynomial| (|Float|)))) (SIGNATURE |retractIfCan| ((|Union| $ "failed") (|Polynomial| (|Float|))))) |noBranch|) (SIGNATURE |abs| ($ $)) (SIGNATURE |sqrt| ($ $)) (SIGNATURE |exp| ($ $)) (SIGNATURE |log| ($ $)) (SIGNATURE |log10| ($ $)) (SIGNATURE |sin| ($ $)) (SIGNATURE |cos| ($ $)) (SIGNATURE |tan| ($ $)) (SIGNATURE |asin| ($ $)) (SIGNATURE |acos| ($ $)) (SIGNATURE |atan| ($ $)) (SIGNATURE |sinh| ($ $)) (SIGNATURE |cosh| ($ $)) (SIGNATURE |tanh| ($ $)) (SIGNATURE |pi| ($)) (SIGNATURE |variables| ((|List| (|Symbol|)) $)) (SIGNATURE |useNagFunctions| ((|Boolean|))) (SIGNATURE |useNagFunctions| ((|Boolean|) (|Boolean|)))))   has no 
(|FunctionSpace| |#3|)    finalizing nrlib FEXPR 


=========================================================================
nonextend 60038:

>compiling GDMP.spad to GDMP.nrlib
 
--------------non extending category----------------------
.. GeneralDistributedMultivariatePolynomial(#1,#2,#3) of cat 
(|Join| (|PolynomialCategory| |#2| |#3| (|OrderedVariableList| |#1|)) (CATEGORY |domain| (SIGNATURE |reorder| ($ $ (|List| (|Integer|))))))   has no 
(IF (|has| |#2| (|IntegralDomain|)) (IF (|has| |#3| (|CancellationAbelianMonoid|)) (SIGNATURE |fmecg| ($ $ |#3| |#2| $)) |noBranch|) |noBranch|)    finalizing nrlib GDMP 

=========================================================================
nonextend 60037:

>compiling HACKPI.spad to HACKPI.nrlib
 
--------------non extending category----------------------
.. Pi of cat 
(|Join| (|Field|) (|CharacteristicZero|) (|RetractableTo| (|Integer|)) (|RetractableTo| (|Fraction| (|Integer|))) (|RealConstant|) (|CoercibleTo| (|DoubleFloat|)) (|CoercibleTo| (|Float|)) (|ConvertibleTo| (|Fraction| (|SparseUnivariatePolynomial| (|Integer|)))) (|ConvertibleTo| (|InputForm|)) (CATEGORY |domain| (SIGNATURE |pi| ($))))   has no 
(|QuotientFieldCategory| (|SparseUnivariatePolynomial| (|Integer|)))    finalizing nrlib HACKPI 

=========================================================================
nonextend 60036:

>compiling LIB.spad to LIB.nrlib
 
--------------non extending category----------------------
.. Library of cat 
(|Join| (|TableAggregate| (|String|) (|Any|)) (CATEGORY |domain| (SIGNATURE |library| ($ (|FileName|))) (SIGNATURE |pack!| ($ $)) (SIGNATURE |elt| ((|Any|) $ (|Symbol|))) (SIGNATURE |setelt| ((|Any|) $ (|Symbol|) (|Any|))) (SIGNATURE |close!| ($ $))))   has no 
(|FileCategory| (|FileName|) (|Record| (|:| |key| (|String|)) (|:| |entry| (|Any|))))    finalizing nrlib LIB 


=========================================================================
nonextend 60035:

>compiling LODO.spad to LODO.nrlib
 
--------------non extending category----------------------
.. LinearOrdinaryDifferentialOperator(#1,#2) of cat 
(|LinearOrdinaryDifferentialOperatorCategory| |#1|)    has no  outputForm : (%,OutputForm) -> OutputForm 

=========================================================================
nonextend 60034:

>compiling M3D.spad to M3D.nrlib
 
--------------non extending category----------------------
.. ThreeDimensionalMatrix(#1) of cat 
(|Join| (|HomogeneousAggregate| |#1|) (CATEGORY |domain| (IF (|has| |#1| (|Ring|)) (PROGN (SIGNATURE |zeroMatrix| ($ (|NonNegativeInteger|) (|NonNegativeInteger|) (|NonNegativeInteger|))) (SIGNATURE |identityMatrix| ($ (|NonNegativeInteger|))) (SIGNATURE |plus| ($ $ $))) |noBranch|) (SIGNATURE |construct| ($ (|List| (|List| (|List| |#1|))))) (SIGNATURE |elt| (|#1| $ (|NonNegativeInteger|) (|NonNegativeInteger|) (|NonNegativeInteger|))) (SIGNATURE |setelt!| (|#1| $ (|NonNegativeInteger|) (|NonNegativeInteger|) (|NonNegativeInteger|) |#1|)) (SIGNATURE |coerce| ($ (|PrimitiveArray| (|PrimitiveArray| (|PrimitiveArray| |#1|))))) (SIGNATURE |coerce| ((|PrimitiveArray| (|PrimitiveArray| (|PrimitiveArray| |#1|))) $)) (SIGNATURE |matrixConcat3D| ($ (|Symbol|) $ $)) (SIGNATURE |matrixDimensions| ((|Vector| (|NonNegativeInteger|)) $))))   has no 
(|OneDimensionalArrayAggregate| (|PrimitiveArray| (|PrimitiveArray| |#1|)))    finalizing nrlib M3D 

=========================================================================
nonextend 60033:

>compiling NSDPS.spad to NSDPS.nrlib
 
--------------non extending category----------------------
.. NeitherSparseOrDensePowerSeries(#1) of cat 
(|Join| (|LocalPowerSeriesCategory| |#1|) (|LazyStreamAggregate| (|Record| (|:| |k| (|Integer|)) (|:| |c| |#1|))) (CATEGORY |domain| (SIGNATURE |findTerm| ((|Record| (|:| |k| (|Integer|)) (|:| |c| |#1|)) $ (|Integer|)))))   has no 
(ATTRIBUTE |shallowlyMutable|)    finalizing nrlib NSDPS 

=========================================================================
nonextend 60032:

>compiling RESULT.spad to RESULT.nrlib
 
--------------non extending category----------------------
.. Result of cat 
(|Join| (|TableAggregate| (|Symbol|) (|Any|)) (CATEGORY |package| (SIGNATURE |showScalarValues| ((|Boolean|) (|Boolean|))) (SIGNATURE |showArrayValues| ((|Boolean|) (|Boolean|))) (ATTRIBUTE |finiteAggregate|)))   has no 
(ATTRIBUTE |finiteAggregate|)    finalizing nrlib RESULT 

=========================================================================
nonextend 60031:

>compiling RMATRIX.spad to RMATRIX.nrlib
 
--------------non extending category----------------------
.. RectangularMatrix(#1,#2,#3) of cat 
(|Join| (|RectangularMatrixCategory| |#1| |#2| |#3| (|DirectProduct| |#2| |#3|) (|DirectProduct| |#1| |#3|)) (|CoercibleTo| (|Matrix| |#3|)) (CATEGORY |domain| (IF (|has| |#3| (|Field|)) (ATTRIBUTE (|VectorSpace| |#3|)) |noBranch|) (IF (|has| |#3| (|ConvertibleTo| (|InputForm|))) (ATTRIBUTE (|ConvertibleTo| (|InputForm|))) |noBranch|) (SIGNATURE |rectangularMatrix| ($ (|Matrix| |#3|))) (SIGNATURE |coerce| ((|Matrix| |#3|) $))))   has no 
(|MatrixCategory| |#3| (|Vector| |#3|) (|Vector| |#3|))    finalizing nrlib RMATRIX 

=========================================================================
nonextend 60030:

>compiling ROMAN.spad to ROMAN.nrlib

(|RealConstant|)    extends 
(|ConvertibleTo| (|DoubleFloat|))    but not 
(|ConvertibleTo| (|String|)) --------------non extending category----------------------
.. RomanNumeral of cat 
(|Join| (|IntegerNumberSystem|) (CATEGORY |domain| (ATTRIBUTE |canonical|) (ATTRIBUTE |canonicalsClosed|) (ATTRIBUTE |noetherian|) (SIGNATURE |convert| ($ (|Symbol|))) (SIGNATURE |roman| ($ (|Symbol|))) (SIGNATURE |roman| ($ (|Integer|)))))   has no 
(|ConvertibleTo| (|String|))    finalizing nrlib ROMAN 

=========================================================================
nonextend 60029:

>compiling ROUTINE.spad to ROUTINE.nrlib
 
--------------non extending category----------------------
.. RoutinesTable of cat 
(|Join| (|TableAggregate| (|Symbol|) (|Any|)) (CATEGORY |domain| (SIGNATURE |concat| ($ $ $)) (SIGNATURE |routines| ($)) (SIGNATURE |selectIntegrationRoutines| ($ $)) (SIGNATURE |selectOptimizationRoutines| ($ $)) (SIGNATURE |selectPDERoutines| ($ $)) (SIGNATURE |selectODEIVPRoutines| ($ $)) (SIGNATURE |selectFiniteRoutines| ($ $)) (SIGNATURE |selectSumOfSquaresRoutines| ($ $)) (SIGNATURE |selectNonFiniteRoutines| ($ $)) (SIGNATURE |selectMultiDimensionalRoutines| ($ $)) (SIGNATURE |changeThreshhold| ($ $ (|Symbol|) (|Float|))) (SIGNATURE |changeMeasure| ($ $ (|Symbol|) (|Float|))) (SIGNATURE |getMeasure| ((|Float|) $ (|Symbol|))) (SIGNATURE |getExplanations| ((|List| (|String|)) $ (|String|))) (SIGNATURE |deleteRoutine!| ($ $ (|Symbol|))) (SIGNATURE |showTheRoutinesTable| ($)) (SIGNATURE |recoverAfterFail| ((|Union| (|String|) "failed") $ (|String|) (|Integer|))) (ATTRIBUTE |finiteAggregate|)))    has no  showScalarValues : Boolean -> Boolean 

=========================================================================
nonextend 60028:

>compiling SQMATRIX.spad to SQMATRIX.nrlib
--------------non extending category----------------------
.. SquareMatrix(#1,#2) of cat 
(|Join| (|SquareMatrixCategory| |#1| |#2| (|DirectProduct| |#1| |#2|) (|DirectProduct| |#1| |#2|)) (|CoercibleTo| (|Matrix| |#2|)) (CATEGORY |domain| (SIGNATURE |transpose| ($ $)) (SIGNATURE |squareMatrix| ($ (|Matrix| |#2|))) (SIGNATURE |coerce| ((|Matrix| |#2|) $)) (IF (|has| |#2| (ATTRIBUTE (|commutative| "*"))) (ATTRIBUTE |central|) |noBranch|) (IF (|has| |#2| (ATTRIBUTE (|commutative| "*"))) (IF (|has| |#2| (ATTRIBUTE |unitsKnown|)) (ATTRIBUTE |unitsKnown|) |noBranch|) |noBranch|) (IF (|has| |#2| (|ConvertibleTo| (|InputForm|))) (ATTRIBUTE (|ConvertibleTo| (|InputForm|))) |noBranch|)))   has no 
(|MatrixCategory| |#2| (|Vector| |#2|) (|Vector| |#2|))    finalizing nrlib SQMATRIX 

=========================================================================
nonextend 60027:

>compiling ALGSC.spad to ALGSC.nrlib
 
--------------non extending category----------------------
.. AlgebraGivenByStructuralConstants(#1,#2,#3,#4) of cat 
(|Join| (|FramedNonAssociativeAlgebra| |#1|) (|LeftModule| (|SquareMatrix| |#2| |#1|)) (CATEGORY |domain| (SIGNATURE |coerce| ($ (|Vector| |#1|)))))   has no 
(|DirectProductCategory| |#2| |#1|)    finalizing nrlib ALGSC 
   Processing AlgebraGivenByStructuralConstants for Browser database:

=========================================================================
nonextend 60026:

>compiling AN.spad to AN.nrlib

(|RealConstant|)    extends 
(|ConvertibleTo| (|DoubleFloat|))    but not 
(|ConvertibleTo| (|Complex| (|Float|))) --------------non extending category----------------------
.. AlgebraicNumber of cat 
(|Join| (|ExpressionSpace|) (|AlgebraicallyClosedField|) (|RetractableTo| (|Integer|)) (|RetractableTo| (|Fraction| (|Integer|))) (|LinearlyExplicitRingOver| (|Integer|)) (|RealConstant|) (|LinearlyExplicitRingOver| (|Fraction| (|Integer|))) (|CharacteristicZero|) (|ConvertibleTo| (|Complex| (|Float|))) (|DifferentialRing|) (CATEGORY |domain| (SIGNATURE |coerce| ($ (|SparseMultivariatePolynomial| (|Integer|) (|Kernel| $)))) (SIGNATURE |numer| ((|SparseMultivariatePolynomial| (|Integer|) (|Kernel| $)) $)) (SIGNATURE |denom| ((|SparseMultivariatePolynomial| (|Integer|) (|Kernel| $)) $)) (SIGNATURE |reduce| ($ $)) (SIGNATURE |norm| ((|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $) (|Kernel| $))) (SIGNATURE |norm| ((|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $) (|List| (|Kernel| $)))) (SIGNATURE |norm| ($ $ (|Kernel| $))) (SIGNATURE |norm| ($ $ (|List| (|Kernel| $))))))    has no  trueEqual : (%,%) -> Boolean 

=========================================================================
nonextend 60025:

>compiling D03EEFA.spad to D03EEFA.nrlib
 
--------------non extending category----------------------
.. d03eefAnnaType of cat 
(|PartialDifferentialEquationsSolverCategory|)   has no 
(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib D03EEFA 
   Processing d03eefAnnaType for Browser database:
--------constructor---------

=========================================================================
nonextend 60024:

>compiling D01AGNT.spad to D01AGNT.nrlib
 
--------------non extending category----------------------
.. d01AgentsPackage of cat 
(CATEGORY |package| (SIGNATURE |rangeIsFinite| ((|Union| (|:| |finite| "The range is finite") (|:| |lowerInfinite| "The bottom of range is infinite") (|:| |upperInfinite| "The top of range is infinite") (|:| |bothInfinite| "Both top and bottom points are infinite") (|:| |notEvaluated| "Range not yet evaluated")) (|Record| (|:| |var| (|Symbol|)) (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|))))) (SIGNATURE |functionIsContinuousAtEndPoints| ((|Union| (|:| |continuous| "Continuous at the end points") (|:| |lowerSingular| "There is a singularity at the lower end point") (|:| |upperSingular| "There is a singularity at the upper end point") (|:| |bothSingular| "There are singularities at both end points") (|:| |notEvaluated| "End point continuity not yet evaluated")) (|Record| (|:| |var| (|Symbol|)) (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|))))) (SIGNATURE |getlo| ((|DoubleFloat|) (|Segment| (|OrderedCompletion| (|DoubleFloat|))))) (SIGNATURE |gethi| ((|DoubleFloat|) (|Segment| (|OrderedCompletion| (|DoubleFloat|))))) (SIGNATURE |functionIsOscillatory| ((|Float|) (|Record| (|:| |var| (|Symbol|)) (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|))))) (SIGNATURE |problemPoints| ((|List| (|DoubleFloat|)) (|Expression| (|DoubleFloat|)) (|Symbol|) (|Segment| (|OrderedCompletion| (|DoubleFloat|))))) (SIGNATURE |singularitiesOf| ((|Stream| (|DoubleFloat|)) (|Record| (|:| |var| (|Symbol|)) (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|))))) (SIGNATURE |df2st| ((|String|) (|DoubleFloat|))) (SIGNATURE |ldf2lst| ((|List| (|String|)) (|List| (|DoubleFloat|)))) (SIGNATURE |sdf2lst| ((|List| (|String|)) (|Stream| (|DoubleFloat|)))) (SIGNATURE |commaSeparate| ((|String|) (|List| (|String|)))) (SIGNATURE |changeName| ((|Result|) (|Symbol|) (|Symbol|) (|Result|))))    has no  functionIsFracPolynomial? : Record(var: Symbol,fn: Expression(DoubleFloat),range: Segment(OrderedCompletion(DoubleFloat)),abserr: DoubleFloat,relerr: DoubleFloat) -> Boolean 

=========================================================================
nonextend 60023:

>compiling DERHAM.spad to DERHAM.nrlib
 
--------------non extending category----------------------
.. DeRhamComplex(#1,#2) of cat 
(|Join| (|LeftAlgebra| (|Expression| |#1|)) (|RetractableTo| (|Expression| |#1|)) (CATEGORY |domain| (SIGNATURE |leadingCoefficient| ((|Expression| |#1|) $)) (SIGNATURE |leadingBasisTerm| ($ $)) (SIGNATURE |reductum| ($ $)) (SIGNATURE |coefficient| ((|Expression| |#1|) $ $)) (SIGNATURE |generator| ($ (|NonNegativeInteger|))) (SIGNATURE |homogeneous?| ((|Boolean|) $)) (SIGNATURE |retractable?| ((|Boolean|) $)) (SIGNATURE |degree| ((|Integer|) $)) (SIGNATURE |map| ($ (|Mapping| (|Expression| |#1|) (|Expression| |#1|)) $)) (SIGNATURE |totalDifferential| ($ (|Expression| |#1|))) (SIGNATURE |exteriorDifferential| ($ $))))    has no  exp : List(Integer) -> % 

=========================================================================
nonextend 60022:

>compiling D01TRNS.spad to D01TRNS.nrlib

--------------non extending category----------------------
.. d01TransformFunctionType of cat 
(|NumericalIntegrationCategory|)   has no 
(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib D01TRNS 

=========================================================================
nonextend 60021:

>compiling E04NAFA.spad to E04NAFA.nrlib
--------------non extending category----------------------
.. e04nafAnnaType of cat 
(|NumericalOptimizationCategory|)   has no 
(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib E04NAFA 
   Processing e04nafAnnaType for Browser database:

=========================================================================
nonextend 60020:

>compiling EXPEXPAN.spad to EXPEXPAN.nrlib
 
--------------non extending category----------------------
.. ExponentialExpansion(#1,#2,#3,#4) of cat 
(|Join| (|QuotientFieldCategory| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)) (|RetractableTo| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|)) (CATEGORY |domain| (SIGNATURE |limitPlus| ((|Union| (|OrderedCompletion| |#2|) "failed") $)) (SIGNATURE |coerce| ($ (|UnivariatePuiseuxSeries| |#2| |#3| |#4|)))))   has no 
(IF (|has| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (|IntegerNumberSystem|)) (IF (|has| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (|OpenMath|)) (ATTRIBUTE (|OpenMath|)) |noBranch|) |noBranch|)    finalizing nrlib EXPEXPAN 

=========================================================================
nonextend 60019:

>compiling GCNAALG.spad to GCNAALG.nrlib

(|Module| (|Fraction| (|Polynomial| |#1|)))    extends 
(|LeftModule| (|Fraction| (|Polynomial| |#1|)))    but not 
(|LeftModule| (|SquareMatrix| |#2| (|Fraction| (|Polynomial| |#1|))))    finalizing nrlib GCNAALG 

=========================================================================
nonextend 60018:

>compiling IAN.spad to IAN.nrlib
 
--------------non extending category----------------------
.. InnerAlgebraicNumber of cat 
(|Join| (|ExpressionSpace|) (|AlgebraicallyClosedField|) (|RetractableTo| (|Integer|)) (|RetractableTo| (|Fraction| (|Integer|))) (|LinearlyExplicitRingOver| (|Integer|)) (|RealConstant|) (|LinearlyExplicitRingOver| (|Fraction| (|Integer|))) (|CharacteristicZero|) (|ConvertibleTo| (|Complex| (|Float|))) (|DifferentialRing|) (CATEGORY |domain| (SIGNATURE |coerce| ($ (|SparseMultivariatePolynomial| (|Integer|) (|Kernel| $)))) (SIGNATURE |numer| ((|SparseMultivariatePolynomial| (|Integer|) (|Kernel| $)) $)) (SIGNATURE |denom| ((|SparseMultivariatePolynomial| (|Integer|) (|Kernel| $)) $)) (SIGNATURE |reduce| ($ $)) (SIGNATURE |trueEqual| ((|Boolean|) $ $)) (SIGNATURE |norm| ((|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $) (|Kernel| $))) (SIGNATURE |norm| ((|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $) (|List| (|Kernel| $)))) (SIGNATURE |norm| ($ $ (|Kernel| $))) (SIGNATURE |norm| ($ $ (|List| (|Kernel| $))))))   has no 
(|FunctionSpace| (|Integer|))    finalizing nrlib IAN 

=========================================================================
nonextend 60017:

>compiling LSQM.spad to LSQM.nrlib
 
--------------non extending category----------------------
.. LieSquareMatrix(#1,#2) of cat 
(|Join| (|SquareMatrixCategory| |#1| |#2| (|DirectProduct| |#1| |#2|) (|DirectProduct| |#1| |#2|)) (|CoercibleTo| (|Matrix| |#2|)) (|FramedNonAssociativeAlgebra| |#2|))   has no 
(|CoercibleTo| (|SquareMatrix| |#1| |#2|))    finalizing nrlib LSQM 

=========================================================================
nonextend 60016:

>compiling MCMPLX.spad to MCMPLX.nrlib
 
--------------non extending category----------------------
.. MachineComplex of cat 
(|Join| (|FortranMachineTypeCategory|) (|ComplexCategory| (|MachineFloat|)) (CATEGORY |domain| (SIGNATURE |coerce| ($ (|Complex| (|Float|)))) (SIGNATURE |coerce| ($ (|Complex| (|Integer|)))) (SIGNATURE |coerce| ($ (|Complex| (|MachineFloat|)))) (SIGNATURE |coerce| ($ (|Complex| (|MachineInteger|)))) (SIGNATURE |coerce| ((|Complex| (|Float|)) $))))   has no 

=========================================================================
nonextend 60015:

>compiling MYUP.spad to MYUP.nrlib
 
--------------non extending category----------------------
.. MyUnivariatePolynomial(#1,#2) of cat 
(|Join| (|UnivariatePolynomialCategory| |#2|) (CATEGORY |domain| (ATTRIBUTE (|RetractableTo| (|Symbol|))) (SIGNATURE |coerce| ($ (|Variable| |#1|))) (SIGNATURE |fmecg| ($ $ (|NonNegativeInteger|) |#2| $)) (IF (|has| |#2| (SIGNATURE |univariate| ((|SparseUnivariatePolynomial| |#2|) |#2| (|Symbol|)))) (SIGNATURE |coerce| ($ |#2|)) |noBranch|) (SIGNATURE |coerce| ($ (|Polynomial| |#2|)))))    has no  outputForm : (%,OutputForm) -> OutputForm 

=========================================================================
nonextend 60014:

>compiling MYEXPR.spad to MYEXPR.nrlib
 
--------------non extending category----------------------
.. MyExpression(#1,#2) of cat 
(|Join| (|FunctionSpace| |#2|) (|IntegralDomain|) (|RetractableTo| (|MyUnivariatePolynomial| |#1| |#2|)) (|RetractableTo| (|Symbol|)) (|RetractableTo| (|Integer|)) (|CombinatorialOpsCategory|) (|PartialDifferentialRing| (|Symbol|)) (CATEGORY |domain| (SIGNATURE * ($ $ $)) (SIGNATURE / ($ $ $)) (SIGNATURE ** ($ $ $)) (SIGNATURE |numerator| ($ $)) (SIGNATURE |denominator| ($ $)) (SIGNATURE |ground?| ((|Boolean|) $)) (SIGNATURE |coerce| ($ (|Fraction| (|MyUnivariatePolynomial| |#1| |#2|)))) (SIGNATURE |retract| ((|Fraction| (|MyUnivariatePolynomial| |#1| |#2|)) $))))   has no 
(IF (|has| |#2| (|IntegralDomain|)) (PROGN (ATTRIBUTE (|AlgebraicallyClosedFunctionSpace| |#2|)) (ATTRIBUTE (|TranscendentalFunctionCategory|)) (ATTRIBUTE (|CombinatorialOpsCategory|)) (ATTRIBUTE (|LiouvillianFunctionCategory|)) (ATTRIBUTE (|SpecialFunctionCategory|)) (SIGNATURE |reduce| ($ $)) (SIGNATURE |number?| ((|Boolean|) $)) (SIGNATURE |simplifyPower| ($ $ (|Integer|))) (IF (|has| |#2| (|GcdDomain|)) (PROGN (SIGNATURE |factorPolynomial| ((|Factored| (|SparseUnivariatePolynomial| $)) (|SparseUnivariatePolynomial| $))) (SIGNATURE |squareFreePolynomial| ((|Factored| (|SparseUnivariatePolynomial| $)) (|SparseUnivariatePolynomial| $)))) |noBranch|) (IF (|has| |#2| (|RetractableTo| (|Integer|))) (ATTRIBUTE (|RetractableTo| (|AlgebraicNumber|))) |noBranch|)) |noBranch|)    finalizing nrlib MYEXPR 

=========================================================================
nonextend 60013:

>compiling MYEXPR.spad to MYEXPR.nrlib
 
--------------non extending category----------------------
.. MyUnivariatePolynomial(#1,#2) of cat 
(|Join| (|UnivariatePolynomialCategory| |#2|) (CATEGORY |domain| (ATTRIBUTE (|RetractableTo| (|Symbol|))) (SIGNATURE |coerce| ($ (|Variable| |#1|))) (SIGNATURE |fmecg| ($ $ (|NonNegativeInteger|) |#2| $)) (IF (|has| |#2| (SIGNATURE |univariate| ((|SparseUnivariatePolynomial| |#2|) |#2| (|Symbol|)))) (SIGNATURE |coerce| ($ |#2|)) |noBranch|) (SIGNATURE |coerce| ($ (|Polynomial| |#2|)))))    has no  outputForm : (%,OutputForm) -> OutputForm 
 
--------------non extending category----------------------
.. MyExpression(#1,#2) of cat 
(|Join| (|FunctionSpace| |#2|) (|IntegralDomain|) (|RetractableTo| (|MyUnivariatePolynomial| |#1| |#2|)) (|RetractableTo| (|Symbol|)) (|RetractableTo| (|Integer|)) (|CombinatorialOpsCategory|) (|PartialDifferentialRing| (|Symbol|)) (CATEGORY |domain| (SIGNATURE * ($ $ $)) (SIGNATURE / ($ $ $)) (SIGNATURE ** ($ $ $)) (SIGNATURE |numerator| ($ $)) (SIGNATURE |denominator| ($ $)) (SIGNATURE |ground?| ((|Boolean|) $)) (SIGNATURE |coerce| ($ (|Fraction| (|MyUnivariatePolynomial| |#1| |#2|)))) (SIGNATURE |retract| ((|Fraction| (|MyUnivariatePolynomial| |#1| |#2|)) $))))   has no 
(IF (|has| |#2| (|IntegralDomain|)) (PROGN (ATTRIBUTE (|AlgebraicallyClosedFunctionSpace| |#2|)) (ATTRIBUTE (|TranscendentalFunctionCategory|)) (ATTRIBUTE (|CombinatorialOpsCategory|)) (ATTRIBUTE (|LiouvillianFunctionCategory|)) (ATTRIBUTE (|SpecialFunctionCategory|)) (SIGNATURE |reduce| ($ $)) (SIGNATURE |number?| ((|Boolean|) $)) (SIGNATURE |simplifyPower| ($ $ (|Integer|))) (IF (|has| |#2| (|GcdDomain|)) (PROGN (SIGNATURE |factorPolynomial| ((|Factored| (|SparseUnivariatePolynomial| $)) (|SparseUnivariatePolynomial| $))) (SIGNATURE |squareFreePolynomial| ((|Factored| (|SparseUnivariatePolynomial| $)) (|SparseUnivariatePolynomial| $)))) |noBranch|) (IF (|has| |#2| (|RetractableTo| (|Integer|))) (ATTRIBUTE (|RetractableTo| (|AlgebraicNumber|))) |noBranch|)) |noBranch|)    finalizing nrlib MYEXPR 

=========================================================================
nonextend 60012:

>compiling SD.spad to SD.nrlib
 
--------------non extending category----------------------
.. StochasticDifferential(#1) of cat 
(|Join| (|Rng|) (|Module| (|Expression| |#1|)) (CATEGORY |domain| (ATTRIBUTE (|RetractableTo| (|BasicStochasticDifferential|))) (SIGNATURE |alterQuadVar!| ((|Union| $ "failed") (|BasicStochasticDifferential|) (|BasicStochasticDifferential|) $)) (SIGNATURE |alterDrift!| ((|Union| $ "failed") (|BasicStochasticDifferential|) $)) (SIGNATURE |drift| ($ $)) (SIGNATURE |freeOf?| ((|Boolean|) $ (|BasicStochasticDifferential|))) (SIGNATURE |coefficient| ((|Expression| |#1|) $ (|BasicStochasticDifferential|))) (SIGNATURE |listSD| ((|List| (|BasicStochasticDifferential|)) $)) (SIGNATURE |equation| ((|Union| (|Equation| $) "failed") $ |#1|)) (SIGNATURE |equation| ((|Union| (|Equation| $) "failed") |#1| $)) (SIGNATURE |copyDrift| ((|Table| $ $))) (SIGNATURE |copyQuadVar| ((|Table| $ $))) (SIGNATURE / ($ $ (|Expression| |#1|))) (SIGNATURE ** ($ $ (|PositiveInteger|))) (SIGNATURE ^ ($ $ (|PositiveInteger|))) (SIGNATURE |statusIto| ((|OutputForm|))) (SIGNATURE |uncorrelated?| ((|Boolean|) $ $)) (SIGNATURE |uncorrelated?| ((|Boolean|) (|List| $) (|List| $))) (SIGNATURE |uncorrelated?| ((|Boolean|) (|List| (|List| $))))))   has no 
(|PolynomialCategory| (|Expression| |#1|) (|IndexedExponents| (|BasicStochasticDifferential|)) (|BasicStochasticDifferential|))    finalizing nrlib SD 

=========================================================================
nonextend 60011:

>compiling SUTS.spad to SUTS.nrlib

(|UnivariateTaylorSeriesCategory| |#1|)    extends 
(|UnivariatePowerSeriesCategory| |#1| (|NonNegativeInteger|))    but not 
(|UnivariatePowerSeriesCategory| |#1| (|Integer|)) --------------non extending category----------------------
.. SparseUnivariateTaylorSeries(#1,#2,#3) of cat 
(|Join| (|UnivariateTaylorSeriesCategory| |#1|) (CATEGORY |domain| (SIGNATURE |coerce| ($ (|UnivariatePolynomial| |#2| |#1|))) (SIGNATURE |univariatePolynomial| ((|UnivariatePolynomial| |#2| |#1|) $ (|NonNegativeInteger|))) (SIGNATURE |coerce| ($ (|Variable| |#2|))) (SIGNATURE |differentiate| ($ $ (|Variable| |#2|))) (IF (|has| |#1| (|Algebra| (|Fraction| (|Integer|)))) (SIGNATURE |integrate| ($ $ (|Variable| |#2|))) |noBranch|)))   has no 
(|UnivariatePowerSeriesCategory| |#1| (|Integer|))    finalizing nrlib SUTS 

=========================================================================
nonextend 60010:

>compiling UPXSSING.spad to UPXSSING.nrlib
 
--------------non extending category----------------------
.. UnivariatePuiseuxSeriesWithExponentialSingularity(#1,#2,#3,#4) of cat 
(|Join| (|FiniteAbelianMonoidRing| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|) (|ExponentialOfUnivariatePuiseuxSeries| |#2| |#3| |#4|)) (|IntegralDomain|) (CATEGORY |domain| (SIGNATURE |limitPlus| ((|Union| (|OrderedCompletion| |#2|) "failed") $)) (SIGNATURE |dominantTerm| ((|Union| (|Record| (|:| |%term| (|Record| (|:| |%coef| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|)) (|:| |%expon| (|ExponentialOfUnivariatePuiseuxSeries| |#2| |#3| |#4|)) (|:| |%expTerms| (|List| (|Record| (|:| |k| (|Fraction| (|Integer|))) (|:| |c| |#2|)))))) (|:| |%type| (|String|))) "failed") $))))   has no 
(IF (|has| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|) (|IntegralDomain|)) (IF (|has| (|ExponentialOfUnivariatePuiseuxSeries| |#2| |#3| |#4|) (|CancellationAbelianMonoid|)) (SIGNATURE |fmecg| ($ $ (|ExponentialOfUnivariatePuiseuxSeries| |#2| |#3| |#4|) (|UnivariatePuiseuxSeries| |#2| |#3| |#4|) $)) |noBranch|) |noBranch|)    finalizing nrlib UPXSSING 

=========================================================================
nonextend 60009:

>compiling ESCONT.spad to ESCONT.nrlib
 
--------------non extending category----------------------
.. ExpertSystemContinuityPackage of cat 
(CATEGORY |package| (SIGNATURE |getlo| ((|DoubleFloat|) (|Segment| (|OrderedCompletion| (|DoubleFloat|))))) (SIGNATURE |gethi| ((|DoubleFloat|) (|Segment| (|OrderedCompletion| (|DoubleFloat|))))) (SIGNATURE |functionIsFracPolynomial?| ((|Boolean|) (|Record| (|:| |var| (|Symbol|)) (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|))))) (SIGNATURE |problemPoints| ((|List| (|DoubleFloat|)) (|Expression| (|DoubleFloat|)) (|Symbol|) (|Segment| (|OrderedCompletion| (|DoubleFloat|))))) (SIGNATURE |zerosOf| ((|Stream| (|DoubleFloat|)) (|Expression| (|DoubleFloat|)) (|List| (|Symbol|)) (|Segment| (|OrderedCompletion| (|DoubleFloat|))))) (SIGNATURE |singularitiesOf| ((|Stream| (|DoubleFloat|)) (|Expression| (|DoubleFloat|)) (|List| (|Symbol|)) (|Segment| (|OrderedCompletion| (|DoubleFloat|))))) (SIGNATURE |singularitiesOf| ((|Stream| (|DoubleFloat|)) (|Vector| (|Expression| (|DoubleFloat|))) (|List| (|Symbol|)) (|Segment| (|OrderedCompletion| (|DoubleFloat|))))) (SIGNATURE |polynomialZeros| ((|List| (|DoubleFloat|)) (|Polynomial| (|Fraction| (|Integer|))) (|Symbol|) (|Segment| (|OrderedCompletion| (|DoubleFloat|))))) (SIGNATURE |df2st| ((|String|) (|DoubleFloat|))) (SIGNATURE |ldf2lst| ((|List| (|String|)) (|List| (|DoubleFloat|)))) (SIGNATURE |sdf2lst| ((|List| (|String|)) (|Stream| (|DoubleFloat|)))))    has no  f2df : Float -> DoubleFloat 

=========================================================================
nonextend 60008:

>compiling GSERIES.spad to GSERIES.nrlib

--------------non extending category----------------------
.. GeneralUnivariatePowerSeries(#1,#2,#3) of cat 
(|Join| (|UnivariatePuiseuxSeriesCategory| |#1|) (CATEGORY |domain| (SIGNATURE |coerce| ($ (|Variable| |#2|))) (SIGNATURE |coerce| ($ (|UnivariatePuiseuxSeries| |#1| |#2| |#3|))) (SIGNATURE |differentiate| ($ $ (|Variable| |#2|))) (IF (|has| |#1| (|Algebra| (|Fraction| (|Integer|)))) (SIGNATURE |integrate| ($ $ (|Variable| |#2|))) |noBranch|)))   has no 
(|UnivariatePuiseuxSeriesConstructorCategory| |#1| (|UnivariateLaurentSeries| |#1| |#2| |#3|))    finalizing nrlib GSERIES 

=========================================================================
nonextend 60007:

>compiling RGCHAIN.spad to RGCHAIN.nrlib

--------------non extending category----------------------
.. RegularChain(#1,#2) of cat 
(|Join| (|RegularTriangularSetCategory| |#1| (|IndexedExponents| (|OrderedVariableList| |#2|)) (|OrderedVariableList| |#2|) (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|))) (CATEGORY |domain| (SIGNATURE |zeroSetSplit| ((|List| $) (|List| (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|))) (|Boolean|) (|Boolean|)))))    has no  internalAugment : (NewSparseMultivariatePolynomial(#1,OrderedVariableList(#2)),%,Boolean,Boolean,Boolean,Boolean,Boolean) -> List(%) 

=========================================================================
nonextend 60006:

>compiling SULS.spad to SULS.nrlib
 
--------------non extending category----------------------
.. SparseUnivariateLaurentSeries(#1,#2,#3) of cat 
(|Join| (|UnivariateLaurentSeriesConstructorCategory| |#1| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)) (CATEGORY |domain| (SIGNATURE |coerce| ($ (|Variable| |#2|))) (SIGNATURE |differentiate| ($ $ (|Variable| |#2|))) (IF (|has| |#1| (|Algebra| (|Fraction| (|Integer|)))) (SIGNATURE |integrate| ($ $ (|Variable| |#2|))) |noBranch|)))    has no  makeSeries : (Reference(OrderedCompletion(Integer)),Stream(Record(k: Integer,c: #1))) -> % 

=========================================================================
nonextend 60005:

>compiling UTS.spad to UTS.nrlib
 
--------------non extending category----------------------
.. UnivariateTaylorSeries(#1,#2,#3) of cat 
(|Join| (|UnivariateTaylorSeriesCategory| |#1|) (CATEGORY |domain| (SIGNATURE |coerce| ($ (|UnivariatePolynomial| |#2| |#1|))) (SIGNATURE |univariatePolynomial| ((|UnivariatePolynomial| |#2| |#1|) $ (|NonNegativeInteger|))) (SIGNATURE |coerce| ($ (|Variable| |#2|))) (SIGNATURE |differentiate| ($ $ (|Variable| |#2|))) (SIGNATURE |lagrange| ($ $)) (SIGNATURE |lambert| ($ $)) (SIGNATURE |oddlambert| ($ $)) (SIGNATURE |evenlambert| ($ $)) (SIGNATURE |generalLambert| ($ $ (|Integer|) (|Integer|))) (SIGNATURE |revert| ($ $)) (SIGNATURE |multisect| ($ (|Integer|) (|Integer|) $)) (SIGNATURE |invmultisect| ($ (|Integer|) (|Integer|) $)) (IF (|has| |#1| (|Algebra| (|Fraction| (|Integer|)))) (SIGNATURE |integrate| ($ $ (|Variable| |#2|))) |noBranch|)))    has no  ?*? : (%,Integer) -> % 

=========================================================================
nonextend 60004:

>compiling UTSZ.spad to UTSZ.nrlib
 
--------------non extending category----------------------
.. UnivariateTaylorSeriesCZero(#1,#2) of cat 
(|Join| (|UnivariateTaylorSeriesCategory| |#1|) (CATEGORY |domain| (SIGNATURE |coerce| ($ (|UnivariatePolynomial| |#2| |#1|))) (SIGNATURE |univariatePolynomial| ((|UnivariatePolynomial| |#2| |#1|) $ (|NonNegativeInteger|))) (SIGNATURE |coerce| ($ (|Variable| |#2|))) (SIGNATURE |differentiate| ($ $ (|Variable| |#2|))) (SIGNATURE |lagrange| ($ $)) (SIGNATURE |lambert| ($ $)) (SIGNATURE |oddlambert| ($ $)) (SIGNATURE |evenlambert| ($ $)) (SIGNATURE |generalLambert| ($ $ (|Integer|) (|Integer|))) (SIGNATURE |revert| ($ $)) (SIGNATURE |multisect| ($ (|Integer|) (|Integer|) $)) (SIGNATURE |invmultisect| ($ (|Integer|) (|Integer|) $)) (IF (|has| |#1| (|Algebra| (|Fraction| (|Integer|)))) (SIGNATURE |integrate| ($ $ (|Variable| |#2|))) |noBranch|)))    has no  ?*? : (%,Integer) -> % 

=========================================================================
nonextend 60003:

>compiling INFCLSPT.spad to INFCLSPT.nrlib
 
--------------non extending category----------------------
.. InfinitlyClosePoint(#1,#2,#3,#4,#5,#6,#7,#8,#9) of cat 
(|Join| (|InfinitlyClosePointCategory| |#1| |#2| |#3| |#4| |#5| |#6| |#7| |#8| |#9|) (CATEGORY |domain| (SIGNATURE |fullOut| ((|OutputForm|) $)) (SIGNATURE |fullOutput| ((|Boolean|) (|Boolean|))) (SIGNATURE |fullOutput| ((|Boolean|)))))   has no 
(|RecordCategory| (|:| |point| |#5|) (|:| |curve| (|DistributedMultivariatePolynomial| (|construct| X Y) |#1|)) (|:| |localPoint| (|AffinePlane| |#1|)) (|:| |mult| (|NonNegativeInteger|)) (|:| |chrt| |#9|) (|:| |subMultiplicity| (|NonNegativeInteger|)) (|:| |excpDiv| |#8|) (|:| |localParam| (|List| |#6|)) (|:| |actualExtension| |#1|) (|:| |symbName| (|Symbol|)))    finalizing nrlib INFCLSPT 

=========================================================================
nonextend 60002:

>compiling GUESSUP.spad to GUESSUP.nrlib
 
--------------non extending category----------------------
.. GuessUnivariatePolynomial(#1) of cat 
(CATEGORY |package| (SIGNATURE |guess| ((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))))) (SIGNATURE |guess| ((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|)))) (SIGNATURE |guess| ((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|Mapping| (|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|)))) (|List| (|Symbol|)))) (SIGNATURE |guess| ((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|Mapping| (|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|)))) (|List| (|Symbol|)) (|List| (|GuessOption|)))) (SIGNATURE |guessExpRat| ((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))))) (SIGNATURE |guessExpRat| ((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|)))) (SIGNATURE |guessBinRat| ((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))))) (SIGNATURE |guessBinRat| ((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|)))) (SIGNATURE |guessExpRat| ((|Mapping| (|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|))) (|Symbol|))) (SIGNATURE |guessBinRat| ((|Mapping| (|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|))) (|Symbol|))) (SIGNATURE |guessHP| ((|Mapping| (|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|))) (|Mapping| HPSPEC (|List| (|GuessOption|))))) (SIGNATURE |guessADE| ((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))))) (SIGNATURE |guessADE| ((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|)))) (SIGNATURE |guessAlg| ((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))))) (SIGNATURE |guessAlg| ((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|)))) (SIGNATURE |guessHolo| ((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))))) (SIGNATURE |guessHolo| ((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|)))) (SIGNATURE |guessPade| ((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|)))) (SIGNATURE |guessPade| ((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))))) (SIGNATURE |guessRec| ((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))))) (SIGNATURE |guessRec| ((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|)))) (SIGNATURE |guessPRec| ((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|)))) (SIGNATURE |guessPRec| ((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))))) (SIGNATURE |guessRat| ((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|)))) (SIGNATURE |guessRat| ((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))))) (SIGNATURE |diffHP| (HPSPEC (|List| (|GuessOption|)))) (SIGNATURE |shiftHP| (HPSPEC (|List| (|GuessOption|)))) (SIGNATURE |shiftHP| ((|Mapping| HPSPEC (|List| (|GuessOption|))) (|Symbol|))) (SIGNATURE |diffHP| ((|Mapping| HPSPEC (|List| (|GuessOption|))) (|Symbol|))) (SIGNATURE |guessRec| ((|Mapping| (|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|))) (|Symbol|))) (SIGNATURE |guessPRec| ((|Mapping| (|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|))) (|Symbol|))) (SIGNATURE |guessRat| ((|Mapping| (|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|))) (|Symbol|))) (SIGNATURE |guessADE| ((|Mapping| (|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|))) (|Symbol|))))   has no 
(IF (|has| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|))) (|RetractableTo| (|Symbol|))) (IF (|has| (|MyUnivariatePolynomial| |#1| (|Integer|)) (|RetractableTo| (|Symbol|))) (PROGN (SIGNATURE |guessExpRat| ((|Mapping| (|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|))) (|Symbol|))) (SIGNATURE |guessBinRat| ((|Mapping| (|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|))) (|Symbol|)))) |noBranch|) |noBranch|)    finalizing nrlib GUESSUP 

=========================================================================
nonextend 60001:

>compiling NNI.spad to NNI.nrlib
 
--------------non extending category----------------------
.. NonNegativeInteger of cat 
(|Join| (|OrderedAbelianMonoidSup|) (|Monoid|) (CATEGORY |domain| (SIGNATURE |quo| ($ $ $)) (SIGNATURE |rem| ($ $ $)) (SIGNATURE |gcd| ($ $ $)) (SIGNATURE |divide| ((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $)) (SIGNATURE |exquo| ((|Union| $ "failed") $ $)) (SIGNATURE |shift| ($ $ (|Integer|))) (SIGNATURE |random| ($ $)) (ATTRIBUTE (|commutative| "*"))))   has no 
(|IntegerNumberSystem|)    finalizing nrlib NNI 

=========================================================================
nonextend 60000:

>compiling PI.spad to PI.nrlib
 
--------------non extending category----------------------
.. PositiveInteger of cat 
(|Join| (|AbelianSemiGroup|) (|OrderedSet|) (|Monoid|) (CATEGORY |domain| (SIGNATURE |gcd| ($ $ $)) (ATTRIBUTE (|commutative| "*"))))   has no 
(|OrderedAbelianMonoidSup|)    finalizing nrlib PI 

=========================================================================
dup 50004:

Warning: RPOLCAT-;exactQuo has a duplicate definition in this file
Warning: RPOLCAT-;ZToR has a duplicate definition in this file
Warning: RPOLCAT-;PZToPR has a duplicate definition in this file

=========================================================================
dup 50003:

Warning: PFO;cmult has a duplicate definition in this file

=========================================================================
dup 50002:

Warning: REGSET;decompose has a duplicate definition in this file

=========================================================================
dup 50001:

Warning: SREGSET;decompose has a duplicate definition in this file

=========================================================================
dup 50000:

Warning: PSETCAT-;exactQuo has a duplicate definition in this file

=========================================================================
typos 40362:

>compiling ATTREG.spad to ATTREG.nrlib

--->bookvol10.2.pamphlet-->AttributeRegistry((central (attribute))): Missing left brace
"\\spad{central} is \\spad{true} if, given an algebra over a ring \\spad{R,} the image of \\spad{R} is the center of the algebra, \\spadignore{i.e.} the set of members of the algebra which commute with all others is precisely the image of \\spad{R} in the algebra."


=========================================================================
typos 40361:

>compiling CFCAT.spad to CFCAT.nrlib

--->bookvol10.2.pamphlet-->CombinatorialFunctionCategory((binomial ($ $ $))): Improper first word in comments: 
"\\indented{1}{binomial(n,r) returns the \\spad{(n,r)} binomial coefficient} \\indented{1}{(often denoted in the literature by \\spad{C(n,r)}).} \\indented{1}{Note that \\spad{C(n,r) = n!/(r!(n-r)!)} where \\spad{n \\spad{>=} \\spad{r} \\spad{>=} 0}.} \\blankline \\spad{X} [binomial(5,i) for \\spad{i} in 0..5]"


=========================================================================
typos 40360:

>compiling ELTAB.spad to ELTAB.nrlib

--->bookvol10.2.pamphlet-->Eltable(constructor): Missing left brace
"An eltable over domains \\spad{D} and \\spad{I} is a structure which can be viewed as a function from \\spad{D} to I. Examples of eltable structures range from data structures, \\spadignore{e.g.} those of type List, to algebraic structures like Polynomial."


=========================================================================
typos 40359:

>compiling MSYSCMD.spad to MSYSCMD.nrlib

--->bookvol10.4.pamphlet-->MoreSystemCommands(constructor): Missing left brace
"\\spadtype{MoreSystemCommands} implements an interface with the system command facility. These are the commands that are issued from source files or the system interpreter and they start with a close parenthesis, \\spadignore{e.g.} the \"what\" commands."


=========================================================================
typos 40357:

>compiling PTRANFN.spad to PTRANFN.nrlib

--->bookvol10.2.pamphlet-->PartialTranscendentalFunctions(constructor): Missing left brace
"A package which provides partial transcendental functions, \\spadignore{i.e.} functions which return an answer or \"failed\" This is the description of any package which provides partial functions on a domain belonging to TranscendentalFunctionCategory."


=========================================================================
typos 40356:

>compiling RFDIST.spad to RFDIST.nrlib

--->bookvol10.4.pamphlet-->RandomFloatDistributions(constructor): Not documented!!!!
--->bookvol10.4.pamphlet-->RandomFloatDistributions(): Missing Description
------------------------------------------------------------------------


=========================================================================
typos 40355:

>compiling AGG.spad to AGG.nrlib


--->-->Aggregate&((empty (%))): Missing left brace
"\\spad{empty()}$D creates an aggregate of type \\spad{D} with 0 elements. Note that The \\spad{$D} can be dropped if understood by context, \\spadignore{e.g.} \\axiom{u: \\spad{D} \\spad{:=} empty()}."

--->bookvol10.2.pamphlet-->Aggregate((empty (%))): Missing left brace
"\\spad{empty()}$D creates an aggregate of type \\spad{D} with 0 elements. Note that The \\spad{$D} can be dropped if understood by context, \\spadignore{e.g.} \\axiom{u: \\spad{D} \\spad{:=} empty()}."


=========================================================================
typos 40354:

>compiling BLMETCT.spad to BLMETCT.nrlib

--->bookvol10.2.pamphlet-->BlowUpMethodCategory((coerce (% (List (Integer))))): Not documented!!!!
--->bookvol10.2.pamphlet-->BlowUpMethodCategory((excepCoord ((Integer) %))): Not documented!!!!
--->bookvol10.2.pamphlet-->BlowUpMethodCategory((chartCoord ((Integer) %))): Not documented!!!!
--->bookvol10.2.pamphlet-->BlowUpMethodCategory((transCoord ((Integer) %))): Not documented!!!!
--->bookvol10.2.pamphlet-->BlowUpMethodCategory((createHN (% (Integer) (Integer) (Integer) (Integer) (Integer) (Boolean) (Union left center right vertical horizontal)))): Not documented!!!!
--->bookvol10.2.pamphlet-->BlowUpMethodCategory((ramifMult ((Integer) %))): Not documented!!!!
--->bookvol10.2.pamphlet-->BlowUpMethodCategory((infClsPt? ((Boolean) %))): Not documented!!!!
--->bookvol10.2.pamphlet-->BlowUpMethodCategory((quotValuation ((Integer) %))): Not documented!!!!
--->bookvol10.2.pamphlet-->BlowUpMethodCategory((type ((Union left center right vertical horizontal) %))): Not documented!!!!
--->bookvol10.2.pamphlet-->BlowUpMethodCategory(constructor): Not documented!!!!
--->bookvol10.2.pamphlet-->BlowUpMethodCategory(): Missing Description



=========================================================================
typos 40353:

>compiling LMODULE.spad to LMODULE.nrlib

--->bookvol10.2.pamphlet-->LeftModule(constructor): Missing left brace
"The category of left modules over an \\spad{rng} (ring not necessarily with unit). This is an abelian group which supports left multiplation by elements of the rng. \\blankline Axioms\\br \\tab{5}\\spad{ (a*b)*x = a*(b*x) }\\br \\tab{5}\\spad{ (a+b)*x = (a*x)+(b*x) }\\br \\tab{5}\\spad{ a*(x+y) = (a*x)+(a*y) }"


=========================================================================
typos 40352:

>compiling LOGIC.spad to LOGIC.nrlib
--->-->Logic&((/\ (% % %))): Missing right brace for \spadignore

--->-->Logic&((\/ (% % %))): Missing left brace
--->-->Logic&((\/ (% % %))): Missing left brace
"\\spadignore{ \\spad{\\/} } returns the logical `join', \\spadignore{e.g.} `or'."

--->-->Logic&(constructor): Missing left brace
"`Logic' provides the basic operations for lattices, \\spadignore{e.g.} boolean algebra."

--->bookvol10.2.pamphlet-->Logic((/\ (% % %))): Missing right brace for \spadignore

--->bookvol10.2.pamphlet-->Logic((\/ (% % %))): Missing left brace
--->bookvol10.2.pamphlet-->Logic((\/ (% % %))): Missing left brace
"\\spadignore{ \\spad{\\/} } returns the logical `join', \\spadignore{e.g.} `or'."

--->bookvol10.2.pamphlet-->Logic(constructor): Missing left brace
"`Logic' provides the basic operations for lattices, \\spadignore{e.g.} boolean algebra."


=========================================================================
typos 40351:

>compiling MAPPKG1.spad to MAPPKG1.nrlib

--->bookvol10.4.pamphlet-->MappingPackage1((fixedPoint (A (Mapping A A)))): Missing left brace
"\\spad{fixedPoint \\spad{f}} is the fixed point of function \\spad{f}. \\indented{1}{\\spadignore{i.e.} such that \\spad{fixedPoint \\spad{f} = f(fixedPoint f)}.}"


=========================================================================
typos 40350:

>compiling MONAD.spad to MONAD.nrlib

--->-->Monad&((rightPower (% % (PositiveInteger)))): Missing left brace
"\\spad{rightPower(a,n)} returns the \\spad{n}-th right power of \\spad{a}, \\spadignore{i.e.} \\spad{rightPower(a,n) \\spad{:=} rightPower(a,n-1) * a} and \\spad{rightPower(a,1) \\spad{:=} a}."

--->-->Monad&((leftPower (% % (PositiveInteger)))): Missing left brace
"\\spad{leftPower(a,n)} returns the \\spad{n}-th left power of \\spad{a}, \\spadignore{i.e.} \\spad{leftPower(a,n) \\spad{:=} a * leftPower(a,n-1)} and \\spad{leftPower(a,1) \\spad{:=} a}."

--->-->Monad&(constructor): Missing left brace
"Monad is the class of all multiplicative monads, \\spadignore{i.e.} sets with a binary operation."

--->bookvol10.2.pamphlet-->Monad((rightPower (% % (PositiveInteger)))): Missing left brace
"\\spad{rightPower(a,n)} returns the \\spad{n}-th right power of \\spad{a}, \\spadignore{i.e.} \\spad{rightPower(a,n) \\spad{:=} rightPower(a,n-1) * a} and \\spad{rightPower(a,1) \\spad{:=} a}."

--->bookvol10.2.pamphlet-->Monad((leftPower (% % (PositiveInteger)))): Missing left brace
"\\spad{leftPower(a,n)} returns the \\spad{n}-th left power of \\spad{a}, \\spadignore{i.e.} \\spad{leftPower(a,n) \\spad{:=} a * leftPower(a,n-1)} and \\spad{leftPower(a,1) \\spad{:=} a}."

--------constructor---------
--->bookvol10.2.pamphlet-->Monad(constructor): Missing left brace
"Monad is the class of all multiplicative monads, \\spadignore{i.e.} sets with a binary operation."


=========================================================================
typos 40349:

>compiling NONE.spad to NONE.nrlib

--->bookvol10.3.pamphlet-->None(constructor): Mismatch: left pren matches right brace
"\\spadtype{None} implements a type with no objects. It is mainly used in technical situations where such a thing is needed (\\spadignore{e.g.} the interpreter and some of the internal \\spadtype{Expression} code)."


=========================================================================
typos 40348:

>compiling NUMINT.spad to NUMINT.nrlib

--------(measure ((Record (: measure (Float)) (: explanations (String)) (: extra (Result))) (RoutinesTable) NIAE))---------

--------(measure ((Record (: measure (Float)) (: explanations (String)) (: extra (Result))) (RoutinesTable) MDNIAE))---------


=========================================================================
typos 40347:

>compiling OPTPROB.spad to OPTPROB.nrlib
 
--->bookvol10.3.pamphlet-->NumericalOptimizationProblem(constructor): Missing left brace
"\\axiomType{NumericalOptimizationProblem} is a \\axiom{domain} for the representation of Numerical Optimization problems for use by ANNA. \\blankline The representation is a Union of two record types - one for otimization of a single function of one or more variables: \\blankline \\axiomType{Record}(\\br fn:\\axiomType{Expression DoubleFloat},\\br init:\\axiomType{List DoubleFloat},\\br lb:\\axiomType{List OrderedCompletion DoubleFloat},\\br cf:\\axiomType{List Expression DoubleFloat},\\br ub:\\axiomType{List OrderedCompletion DoubleFloat}) \\blankline and one for least-squares problems \\spadignore{i.e.} optimization of a set of observations of a data set: \\blankline \\axiomType{Record}(lfn:\\axiomType{List Expression DoubleFloat},\\br init:\\axiomType{List DoubleFloat})."


=========================================================================
typos 40346:

>compiling ORDSET.spad to ORDSET.nrlib

--->-->OrderedSet&(constructor): Missing left brace
"The class of totally ordered sets, that is, sets such that for each pair of elements \\spad{(a,b)} exactly one of the following relations holds \\spad{a<b or a=b or b<a} and the relation is transitive, \\spadignore{i.e.} \\spad{a<b and \\spad{b<c} \\spad{=>} a<c}."

--->bookvol10.2.pamphlet-->OrderedSet(constructor): Missing left brace
"The class of totally ordered sets, that is, sets such that for each pair of elements \\spad{(a,b)} exactly one of the following relations holds \\spad{a<b or a=b or b<a} and the relation is transitive, \\spadignore{i.e.} \\spad{a<b and \\spad{b<c} \\spad{=>} a<c}."


=========================================================================
typos 40345:

>compiling REAL.spad to REAL.nrlib

--->bookvol10.2.pamphlet-->RealConstant(constructor): Missing left brace
"The category of real numeric domains, \\spadignore{i.e.} convertible to floats."


=========================================================================
typos 40344:

>compiling RMODULE.spad to RMODULE.nrlib

--->bookvol10.2.pamphlet-->RightModule(constructor): Missing left brace
"The category of right modules over an \\spad{rng} (ring not necessarily with unit). This is an abelian group which supports right multiplication by elements of the rng. \\blankline Axioms\\br \\tab{5}\\spad{ x*(a*b) = (x*a)*b }\\br \\tab{5}\\spad{ x*(a+b) = (x*a)+(x*b) }\\br \\tab{5}\\spad{ (x+y)*x = (x*a)+(y*a) }"

=========================================================================
typos 40343:

>compiling SETCATD.spad to SETCATD.nrlib

--->bookvol10.2.pamphlet-->SetCategoryWithDegree((degree ((PositiveInteger) %))): Not documented!!!!


=========================================================================
typos 40342:

>compiling SGROUP.spad to SGROUP.nrlib

--->-->SemiGroup&((** (% % (PositiveInteger)))): Missing left brace
"\\spad{x**n} returns the repeated product of \\spad{x} \\spad{n} times, \\spadignore{i.e.} exponentiation."

--->-->SemiGroup&((^ (% % (PositiveInteger)))): Missing left brace
"\\spad{x^n} returns the repeated product of \\spad{x} \\spad{n} times, \\spadignore{i.e.} exponentiation."

--->-->SemiGroup&(constructor): Missing left brace
--->-->SemiGroup&(constructor): Missing left brace
"the class of all multiplicative semigroups, \\spadignore{i.e.} a set with an associative operation \\spadop{*}. \\blankline Axioms\\br \\tab{5}\\spad{associative(\"*\":(\\%,\\%)->\\%)}\\tab{5}\\spad{ (x*y)*z = x*(y*z)} \\blankline Conditional attributes\\br \\tab{5}\\spad{commutative(\"*\":(\\%,\\%)->\\%)}\\tab{5}\\spad{ x*y = \\spad{y*x} }"

--->bookvol10.2.pamphlet-->SemiGroup((** (% % (PositiveInteger)))): Missing left brace
"\\spad{x**n} returns the repeated product of \\spad{x} \\spad{n} times, \\spadignore{i.e.} exponentiation."

--->bookvol10.2.pamphlet-->SemiGroup((^ (% % (PositiveInteger)))): Missing left brace
"\\spad{x^n} returns the repeated product of \\spad{x} \\spad{n} times, \\spadignore{i.e.} exponentiation."

--->bookvol10.2.pamphlet-->SemiGroup(constructor): Missing left brace
--->bookvol10.2.pamphlet-->SemiGroup(constructor): Missing left brace
"the class of all multiplicative semigroups, \\spadignore{i.e.} a set with an associative operation \\spadop{*}. \\blankline Axioms\\br \\tab{5}\\spad{associative(\"*\":(\\%,\\%)->\\%)}\\tab{5}\\spad{ (x*y)*z = x*(y*z)} \\blankline Conditional attributes\\br \\tab{5}\\spad{commutative(\"*\":(\\%,\\%)->\\%)}\\tab{5}\\spad{ x*y = \\spad{y*x} }"


=========================================================================
typos 40341:

>compiling SPACEC.spad to SPACEC.nrlib

--->bookvol10.2.pamphlet-->ThreeSpaceCategory((curve ((L POINT) %))): Missing left brace
"\\spad{curve(s)} checks to see if the \\spadtype{ThreeSpace}, \\spad{s,} is composed of a single curve defined by a list of points and if so, returns the curve, \\spadignore{i.e.} list of points. An error is signaled otherwise."

--->bookvol10.2.pamphlet-->ThreeSpaceCategory((curve? (B %))): Missing left brace
"\\spad{curve?(s)} queries whether the \\spadtype{ThreeSpace}, \\spad{s,} is a curve, \\spadignore{i.e.} has one component, a list of list of points, and returns \\spad{true} if it is, or \\spad{false} otherwise."

--->bookvol10.2.pamphlet-->ThreeSpaceCategory((closedCurve? (B %))): Missing left brace
"\\spad{closedCurve?(s)} returns \\spad{true} if the \\spadtype{ThreeSpace} \\spad{s} contains a single closed curve component, \\spadignore{i.e.} the first element of the curve is also the last element, or \\spad{false} otherwise."

--->bookvol10.2.pamphlet-->ThreeSpaceCategory((mesh (% % (L (L (L R))) (L PROP) PROP))): Missing close parenthesis on first line: mesh(s,[ [[r10]...,[r1m]],[[r20]...,[r2m]],...,[[rn0]...,[rnm]] ],
"mesh(s,[ [[r10]...,[r1m]],[[r20]...,[r2m]],...,[[rn0]...,[rnm]] \\spad{],} \\indented{7}{[props], prop)} adds a surface component to the \\spadtype{ThreeSpace} \\spad{s,} which is defined over a rectangular domain of size \\spad{WxH} where \\spad{W} is the number of lists of points from the domain \\spad{PointDomain(R)} and \\spad{H} is the number of elements in each of those lists; lprops is the list of the subspace component properties for each curve list, and prop is the subspace component property by which the points are defined."

--->bookvol10.2.pamphlet-->ThreeSpaceCategory((mesh (% % (L (L POINT)) B B))): Missing left brace
--->bookvol10.2.pamphlet-->ThreeSpaceCategory((mesh (% % (L (L POINT)) B B))): Missing left brace
"\\spad{mesh(s,[[p0],[p1],...,[pn]], close1, close2)} adds a surface component to the \\spadtype{ThreeSpace}, which is defined over a list of curves, in which each of these curves is a list of points. The boolean arguments \\spad{close1} and \\spad{close2} indicate how the surface is to be closed. Argument \\spad{close1} equal \\spad{true} means that each individual list (a curve) is to be closed, \\spadignore{i.e.} the last point of the list is to be connected to the first point. Argument \\spad{close2} equal \\spad{true} means that the boundary at one end of the surface is to be connected to the boundary at the other end, \\spadignore{i.e.} the boundaries are defined as the first list of points (curve) and the last list of points (curve)."

--->bookvol10.2.pamphlet-->ThreeSpaceCategory((mesh (% % (L (L (L R))) B B))): Missing close parenthesis on first line: mesh(s,[ [[r10]...,[r1m]],[[r20]...,[r2m]],...,[[rn0]...,[rnm]] ],
--->bookvol10.2.pamphlet-->ThreeSpaceCategory((mesh (% % (L (L (L R))) B B))): Mismatch: left pren matches right brace
"mesh(s,[ [[r10]...,[r1m]],[[r20]...,[r2m]],...,[[rn0]...,[rnm]] \\spad{],} \\indented{5}{close1, close2)} adds a surface component to the \\spadtype{ThreeSpace} \\spad{s,} which is defined over a rectangular domain of size \\spad{WxH} where \\spad{W} is the number of lists of points from the domain \\spad{PointDomain(R)} and \\spad{H} is the number of elements in each of those lists; the booleans \\spad{close1} and \\spad{close2} indicate how the surface is to be closed: if \\spad{close1} is \\spad{true} this means that each individual list (a curve) is to be closed (\\spadignore{i.e.} the last point of the list is to be connected to the first point); if \\spad{close2} is true, this means that the boundary at one end of the surface is to be connected to the boundary at the other end (the boundaries are defined as the first list of points (curve) and the last list of points (curve))."

--->bookvol10.2.pamphlet-->ThreeSpaceCategory((lp ((L POINT) %))): Missing left brace
"\\spad{lp(s)} returns the list of points component which the \\spadtype{ThreeSpace}, \\spad{s,} contains; these points are used by reference, \\spadignore{i.e.} the component holds indices referring to the points rather than the points themselves. This allows for sharing of the points."


=========================================================================
typos 40340:


--->bookvol10.4.pamphlet-->StreamFunctions1((concat ((ST S) (ST (ST S))))): Improper first word in comments: 
"\\indented{1}{concat(u) returns the left-to-right concatentation of the} \\indented{1}{streams in u. Note that \\spad{concat(u) = reduce(concat,u)}.} \\blankline \\spad{X} m:=[i for \\spad{i} in 10..] \\spad{X} n:=[j for \\spad{j} in 1.. | prime? \\spad{j]} \\spad{X} p:=[m,n]::Stream(Stream(PositiveInteger)) \\spad{X} concat(p)"
--------constructor---------


=========================================================================
typos 40339:

--->bookvol10.4.pamphlet-->StreamFunctions2((map ((ST B) (Mapping B A) (ST A)))): Improper first word in comments: 
"\\indented{1}{map(f,s) returns a stream whose elements are the function \\spad{f} applied} \\indented{1}{to the corresponding elements of \\spad{s.}} \\indented{1}{Note that \\spad{map(f,[x0,x1,x2,...]) = [f(x0),f(x1),f(x2),..]}.} \\blankline \\spad{X} m:=[i for \\spad{i} in 1..] \\spad{X} \\spad{f(i:PositiveInteger):PositiveInteger==i**2} \\spad{X} map(f,m)"

--->bookvol10.4.pamphlet-->StreamFunctions2((scan ((ST B) B (Mapping B A B) (ST A)))): Improper first word in comments: 
"\\indented{1}{scan(b,h,[x0,x1,x2,...]) returns \\spad{[y0,y1,y2,...]}, where} \\indented{1}{\\spad{y0 = h(x0,b)},} \\indented{1}{\\spad{y1 = h(x1,y0)},\\spad{...}} \\indented{1}{\\spad{yn = h(xn,y(n-1))}.} \\blankline \\spad{X} m:=[i for \\spad{i} in 1..]::Stream(Integer) \\spad{X} f(i:Integer,j:Integer):Integer==i+j \\spad{X} scan(1,f,m)"

--->bookvol10.4.pamphlet-->StreamFunctions2((reduce (B B (Mapping B A B) (ST A)))): Improper first word in comments: 
"\\indented{1}{reduce(b,f,u), where \\spad{u} is a finite stream \\spad{[x0,x1,...,xn]},} \\indented{1}{returns the value \\spad{r(n)} computed as follows:} \\indented{1}{\\spad{r0 = f(x0,b),} \\indented{1}{r1 = f(x1,r0),...,} \\indented{1}{r(n) = f(xn,r(n-1))}.} \\blankline \\spad{X} m:=[i for \\spad{i} in 1..300]::Stream(Integer) \\spad{X} f(i:Integer,j:Integer):Integer==i+j \\spad{X} reduce(1,f,m)"


=========================================================================
typos 40338:

>compiling STREAM3.spad to STREAM3.nrlib

--->bookvol10.4.pamphlet-->StreamFunctions3((map ((ST C) (Mapping C A B) (ST A) (ST B)))): Improper first word in comments: 
"\\indented{1}{map(f,st1,st2) returns the stream whose elements are the} \\indented{1}{function \\spad{f} applied to the corresponding elements of \\spad{st1} and st2.} \\indented{1}{\\spad{map(f,[x0,x1,x2,..],[y0,y1,y2,..]) = [f(x0,y0),f(x1,y1),..]}.} \\blankline \\spad{S} \\spad{X} m:=[i for \\spad{i} in 1..]::Stream(Integer) \\spad{X} n:=[i for \\spad{i} in 1..]::Stream(Integer) \\spad{X} f(i:Integer,j:Integer):Integer \\spad{==} i+j \\spad{X} map(f,m,n)"


=========================================================================
typos 40337:

>compiling AFSPCAT.spad to AFSPCAT.nrlib

--->bookvol10.2.pamphlet-->AffineSpaceCategory((origin (%))): Not documented!!!!

--->bookvol10.2.pamphlet-->AffineSpaceCategory((definingField (K %))): Not documented!!!!
--->bookvol10.2.pamphlet-->AffineSpaceCategory((coerce ((List K) %))): Not documented!!!!


=========================================================================
typos 40336:

>compiling API.spad to API.nrlib

--->bookvol10.4.pamphlet-->ApplicationProgramInterface((getDomains ((Set (Symbol)) (Symbol)))): Improper first word in comments: 
"\\indented{1}{The getDomains(s) takes a category and returns the list of domains} \\indented{1}{that have that category} \\blankline \\spad{X} getDomains 'IndexedAggregate"

--->bookvol10.4.pamphlet-->ApplicationProgramInterface((getAncestors ((Set (Symbol)) (Symbol)))): Improper first word in comments: 
"\\indented{1}{The getAncestor(s) takes a category and returns the list of domains} \\indented{1}{that have that category as ancestors} \\blankline \\spad{X} getAncestors 'IndexedAggregate"

--->bookvol10.4.pamphlet-->ApplicationProgramInterface((credits ((Void)))): Improper first word in comments: 
"\\indented{1}{credits() prints a list of people who contributed to Axiom} \\blankline \\spad{X} credits()"

--->bookvol10.4.pamphlet-->ApplicationProgramInterface((summary ((Void)))): Improper first word in comments: 
"\\indented{1}{summary() prints a short list of useful console commands} \\blankline \\spad{X} summary()"


=========================================================================
typos 40335:

>compiling BEZIER.spad to BEZIER.nrlib

--->bookvol10.4.pamphlet-->Bezier((linearBezier ((Mapping (List R) R) (List R) (List R)))): Improper first word in comments: 
"\\indented{1}{A linear Bezier curve is a simple interpolation between the} \\indented{1}{starting point and the ending point based on a parameter \\spad{t.}} \\indented{1}{Given a start point a=[x1,y1] and an endpoint b=[x2,y2]} \\indented{1}{f(t) \\spad{==} \\spad{[(1-t)*x1} + t*x2, \\spad{(1-t)*y1} + t*y2]} \\blankline \\spad{X} n:=linearBezier([2.0,2.0],[4.0,4.0]) \\spad{X} [n(t/10.0) for \\spad{t} in 0..10 by 1]"

--->bookvol10.4.pamphlet-->Bezier((quadraticBezier ((Mapping (List R) R) (List R) (List R) (List R)))): Improper first word in comments: 
"\\indented{1}{A quadratic Bezier curve is a simple interpolation between the} \\indented{1}{starting point, a middle point, and the ending point based on} \\indented{1}{a parameter \\spad{t.}} \\indented{1}{Given a start point a=[x1,y1], a middle point b=[x2,y2],} \\indented{1}{and an endpoint c=[x3,y3]} \\indented{1}{f(t) \\spad{==} \\spad{[(1-t)^2} \\spad{x1} + 2t(1-t) \\spad{x2} + \\spad{t^2} x3,} \\indented{10}{(1-t)^2 \\spad{y1} + 2t(1-t) \\spad{y2} + \\spad{t^2} y3]} \\blankline \\spad{X} n:=quadraticBezier([2.0,2.0],[4.0,4.0],[6.0,2.0]) \\spad{X} [n(t/10.0) for \\spad{t} in 0..10 by 1]"

--->bookvol10.4.pamphlet-->Bezier((cubicBezier ((Mapping (List R) R) (List R) (List R) (List R) (List R)))): Improper first word in comments: 
"\\indented{1}{A cubic Bezier curve is a simple interpolation between the} \\indented{1}{starting point, a left-middle point,, a right-middle point,} \\indented{1}{and the ending point based on a parameter \\spad{t.}} \\indented{1}{Given a start point a=[x1,y1], the left-middle point b=[x2,y2],} \\indented{1}{the right-middle point c=[x3,y3] and an endpoint d=[x4,y4]} \\indented{1}{f(t) \\spad{==} \\spad{[(1-t)^3} \\spad{x1} + 3t(1-t)^2 \\spad{x2} + 3t^2 (1-t) \\spad{x3} + \\spad{t^3} x4,} \\indented{10}{(1-t)^3 \\spad{y1} + 3t(1-t)^2 \\spad{y2} + 3t^2 (1-t) \\spad{y3} + \\spad{t^3} y4]} \\blankline \\spad{X} n:=cubicBezier([2.0,2.0],[2.0,4.0],[6.0,4.0],[6.0,2.0]) \\spad{X} [n(t/10.0) for \\spad{t} in 0..10 by 1]"

=========================================================================
typos 40334:

>compiling BMODULE.spad to BMODULE.nrlib

--->bookvol10.2.pamphlet-->BiModule(constructor): Missing left brace
"A \\spadtype{BiModule} is both a left and right module with respect to potentially different rings. \\blankline Axiom\\br \\tab{5}\\spad{ r*(x*s) = (r*x)*s }"

=========================================================================
typos 40333:

>compiling FAMONC.spad to FAMONC.nrlib

--->bookvol10.2.pamphlet-->FreeAbelianMonoidCategory((size ((NonNegativeInteger) $))): Improper first word in comments: 
"\\indented{1}{size(x) returns the number of terms in \\spad{x.}} \\indented{1}{mapGen(f, \\spad{a1\\^e1} \\spad{...} an\\^en) returns} \\spad{f(a1)\\^e1 \\spad{...} f(an)\\^en}."

=========================================================================
typos 40332:

>compiling GROUP.spad to GROUP.nrlib

--->-->Group&(constructor): Missing left brace
--->-->Group&(constructor): Missing left brace
"The class of multiplicative groups, \\spadignore{i.e.} monoids with multiplicative inverses. \\blankline Axioms\\br \\tab{5}\\spad{leftInverse(\"*\":(\\%,\\%)->\\%,inv)}\\tab{5}\\spad{ inv(x)*x = 1 }\\br \\tab{5}\\spad{rightInverse(\"*\":(\\%,\\%)->\\%,inv)}\\tab{4}\\spad{ x*inv(x) = 1 }"

--->bookvol10.2.pamphlet-->Group(constructor): Missing left brace
--->bookvol10.2.pamphlet-->Group(constructor): Missing left brace
"The class of multiplicative groups, \\spadignore{i.e.} monoids with multiplicative inverses. \\blankline Axioms\\br \\tab{5}\\spad{leftInverse(\"*\":(\\%,\\%)->\\%,inv)}\\tab{5}\\spad{ inv(x)*x = 1 }\\br \\tab{5}\\spad{rightInverse(\"*\":(\\%,\\%)->\\%,inv)}\\tab{4}\\spad{ x*inv(x) = 1 }"

=========================================================================
typos 40331:

>compiling MONADWU.spad to MONADWU.nrlib

--->-->MonadWithUnit&(((One) (%) constant)): Improper first word in comments: 
"1 returns the unit element, denoted by 1."

--->-->MonadWithUnit&((rightPower (% % (NonNegativeInteger)))): Missing left brace
"\\spad{rightPower(a,n)} returns the \\spad{n}-th right power of \\spad{a}, \\spadignore{i.e.} \\spad{rightPower(a,n) \\spad{:=} rightPower(a,n-1) * a} and \\spad{rightPower(a,0) \\spad{:=} 1}."

--->-->MonadWithUnit&((leftPower (% % (NonNegativeInteger)))): Missing left brace
"\\spad{leftPower(a,n)} returns the \\spad{n}-th left power of \\spad{a}, \\spadignore{i.e.} \\spad{leftPower(a,n) \\spad{:=} a * leftPower(a,n-1)} and \\spad{leftPower(a,0) \\spad{:=} 1}."

--->-->MonadWithUnit&(constructor): Missing left brace
--->-->MonadWithUnit&(constructor): Missing left brace
"MonadWithUnit is the class of multiplicative monads with unit, \\spadignore{i.e.} sets with a binary operation and a unit element. \\blankline Axioms\\br \\tab{5}leftIdentity(\"*\":(\\%,\\%)->\\%,1) \\spadignore{e.g.} 1*x=x\\br \\tab{5}rightIdentity(\"*\":(\\%,\\%)->\\%,1) e.g x*1=x \\blankline Common Additional Axioms\\br \\tab{5}unitsKnown - if \"recip\" says \"failed\", it PROVES input wasn't a unit"

--->bookvol10.2.pamphlet-->MonadWithUnit(((One) (%) constant)): Improper first word in comments: 
"1 returns the unit element, denoted by 1."

--->bookvol10.2.pamphlet-->MonadWithUnit((rightPower (% % (NonNegativeInteger)))): Missing left brace
"\\spad{rightPower(a,n)} returns the \\spad{n}-th right power of \\spad{a}, \\spadignore{i.e.} \\spad{rightPower(a,n) \\spad{:=} rightPower(a,n-1) * a} and \\spad{rightPower(a,0) \\spad{:=} 1}."

--->bookvol10.2.pamphlet-->MonadWithUnit((leftPower (% % (NonNegativeInteger)))): Missing left brace
"\\spad{leftPower(a,n)} returns the \\spad{n}-th left power of \\spad{a}, \\spadignore{i.e.} \\spad{leftPower(a,n) \\spad{:=} a * leftPower(a,n-1)} and \\spad{leftPower(a,0) \\spad{:=} 1}."

--->bookvol10.2.pamphlet-->MonadWithUnit(constructor): Missing left brace
--->bookvol10.2.pamphlet-->MonadWithUnit(constructor): Missing left brace
"MonadWithUnit is the class of multiplicative monads with unit, \\spadignore{i.e.} sets with a binary operation and a unit element. \\blankline Axioms\\br \\tab{5}leftIdentity(\"*\":(\\%,\\%)->\\%,1) \\spadignore{e.g.} 1*x=x\\br \\tab{5}rightIdentity(\"*\":(\\%,\\%)->\\%,1) e.g x*1=x \\blankline Common Additional Axioms\\br \\tab{5}unitsKnown - if \"recip\" says \"failed\", it PROVES input wasn't a unit"

=========================================================================
typos 40330:

>compiling PERMCAT.spad to PERMCAT.nrlib

--->bookvol10.2.pamphlet-->PermutationCategory((cycle (% (List S)))): Missing left brace
"\\spad{cycle(ls)} coerces a cycle \\spad{ls,} \\spadignore{i.e.} a list with not repetitions to a permutation, which maps ls.i to ls.i+1, indices modulo the length of the list. Error: if repetitions occur."

--->bookvol10.2.pamphlet-->PermutationCategory((orbit ((Set S) % S))): Missing left brace
"\\spad{orbit(p, el)} returns the orbit of el under the permutation \\spad{p,} \\spadignore{i.e.} the set which is given by applications of the powers of \\spad{p} to el."

--->bookvol10.2.pamphlet-->PermutationCategory(constructor): Mismatch: left pren matches right brace
"PermutationCategory provides a categorial environment for subgroups of bijections of a set (\\spadignore{i.e.} permutations)"

=========================================================================
typos 40329:

>compiling PDRING.spad to PDRING.nrlib

--->-->PartialDifferentialRing&((differentiate (% % (List S)))): Missing left brace
"\\spad{differentiate(x,[s1,...sn])} computes successive partial derivatives, \\spadignore{i.e.} \\spad{differentiate(...differentiate(x, s1)..., sn)}."

--->-->PartialDifferentialRing&((differentiate (% % S (NonNegativeInteger)))): Missing left brace
"\\spad{differentiate(x, \\spad{s,} \\spad{n)}} computes multiple partial derivatives, \\spadignore{i.e.} \\spad{n}-th derivative of \\spad{x} with respect to \\spad{s.}"

--->-->PartialDifferentialRing&((differentiate (% % (List S) (List (NonNegativeInteger))))): Missing left brace
"\\spad{differentiate(x, [s1,...,sn], [n1,...,nn])} computes multiple partial derivatives, \\spadignore{i.e.}"

--->-->PartialDifferentialRing&((D (% % (List S)))): Missing left brace
"\\spad{D(x,[s1,...sn])} computes successive partial derivatives, \\spadignore{i.e.} \\spad{D(...D(x, s1)..., sn)}."

--->-->PartialDifferentialRing&((D (% % S (NonNegativeInteger)))): Missing left brace
"\\spad{D(x, \\spad{s,} \\spad{n)}} computes multiple partial derivatives, \\spadignore{i.e.} \\spad{n}-th derivative of \\spad{x} with respect to \\spad{s.}"

--->-->PartialDifferentialRing&((D (% % (List S) (List (NonNegativeInteger))))): Missing left brace
"\\spad{D(x, [s1,...,sn], [n1,...,nn])} computes multiple partial derivatives, \\spadignore{i.e.} \\spad{D(...D(x, \\spad{s1,} n1)..., \\spad{sn,} nn)}."

--->bookvol10.2.pamphlet-->PartialDifferentialRing((differentiate (% % (List S)))): Missing left brace
"\\spad{differentiate(x,[s1,...sn])} computes successive partial derivatives, \\spadignore{i.e.} \\spad{differentiate(...differentiate(x, s1)..., sn)}."

--->bookvol10.2.pamphlet-->PartialDifferentialRing((differentiate (% % S (NonNegativeInteger)))): Missing left brace
"\\spad{differentiate(x, \\spad{s,} \\spad{n)}} computes multiple partial derivatives, \\spadignore{i.e.} \\spad{n}-th derivative of \\spad{x} with respect to \\spad{s.}"

--->bookvol10.2.pamphlet-->PartialDifferentialRing((differentiate (% % (List S) (List (NonNegativeInteger))))): Missing left brace
"\\spad{differentiate(x, [s1,...,sn], [n1,...,nn])} computes multiple partial derivatives, \\spadignore{i.e.}"

--->bookvol10.2.pamphlet-->PartialDifferentialRing((D (% % (List S)))): Missing left brace
"\\spad{D(x,[s1,...sn])} computes successive partial derivatives, \\spadignore{i.e.} \\spad{D(...D(x, s1)..., sn)}."

--->bookvol10.2.pamphlet-->PartialDifferentialRing((D (% % S (NonNegativeInteger)))): Missing left brace
"\\spad{D(x, \\spad{s,} \\spad{n)}} computes multiple partial derivatives, \\spadignore{i.e.} \\spad{n}-th derivative of \\spad{x} with respect to \\spad{s.}"

--->bookvol10.2.pamphlet-->PartialDifferentialRing((D (% % (List S) (List (NonNegativeInteger))))): Missing left brace
"\\spad{D(x, [s1,...,sn], [n1,...,nn])} computes multiple partial derivatives, \\spadignore{i.e.} \\spad{D(...D(x, \\spad{s1,} n1)..., \\spad{sn,} nn)}."

=========================================================================
typos 40328:

--->bookvol10.2.pamphlet-->PlacesCategory((+ ((Divisor %) % %))): Not documented!!!!
--->bookvol10.2.pamphlet-->PlacesCategory((+ ((Divisor %) (Divisor %) %))): Not documented!!!!
--->bookvol10.2.pamphlet-->PlacesCategory((+ ((Divisor %) % (Divisor %)))): Not documented!!!!
--->bookvol10.2.pamphlet-->PlacesCategory((- ((Divisor %) % %))): Not documented!!!!
--->bookvol10.2.pamphlet-->PlacesCategory((- ((Divisor %) (Divisor %) %))): Not documented!!!!
--->bookvol10.2.pamphlet-->PlacesCategory((- ((Divisor %) % (Divisor %)))): Not documented!!!!
--->bookvol10.2.pamphlet-->PlacesCategory((- ((Divisor %) %))): Not documented!!!!
--->bookvol10.2.pamphlet-->PlacesCategory((* ((Divisor %) (Integer) %))): Not documented!!!!
--->bookvol10.2.pamphlet-->PlacesCategory((reduce ((Divisor %) (List %)))): Not documented!!!!
--->bookvol10.2.pamphlet-->PlacesCategory((create (% (List K)))): Not documented!!!!
--->bookvol10.2.pamphlet-->PlacesCategory((create (% (Symbol)))): Not documented!!!!

=========================================================================
typos 40327:

>compiling PRSPCAT.spad to PRSPCAT.nrlib

--->bookvol10.2.pamphlet-->ProjectiveSpaceCategory((lastNonNul (INT %))): Not documented!!!!

--->bookvol10.2.pamphlet-->ProjectiveSpaceCategory((definingField (K %))): Not documented!!!!


=========================================================================
typos 40326:

>compiling ELAGG.spad to ELAGG.nrlib
 
--->-->ExtensibleLinearAggregate&((delete! (% % (Integer)))): Improper first word in comments: 
"\\indented{1}{delete!(u,i) destructively deletes the \\axiom{i}th element of u.} \\blankline \\spad{E} Data:=Record(age:Integer,gender:String) \\spad{E} a1:AssociationList(String,Data):=table() \\spad{E} a1.\"tim\":=[55,\"male\"]$Data \\spad{E} delete!(a1,1)"

--->bookvol10.2.pamphlet-->ExtensibleLinearAggregate((delete! (% % (Integer)))): Improper first word in comments: 
"\\indented{1}{delete!(u,i) destructively deletes the \\axiom{i}th element of u.} \\blankline \\spad{E} Data:=Record(age:Integer,gender:String) \\spad{E} a1:AssociationList(String,Data):=table() \\spad{E} a1.\"tim\":=[55,\"male\"]$Data \\spad{E} delete!(a1,1)"

=========================================================================
typos 40325:

>compiling GRMOD.spad to GRMOD.nrlib

--->-->GradedModule&(((Zero) (%) constant)): Improper first word in comments: 
"0 denotes the zero of degree 0."

--->-->GradedModule&(constructor): Missing left brace
"GradedModule(R,E) denotes ``E-graded R-module'', \\spadignore{i.e.} collection of R-modules indexed by an abelian monoid E. An element \\spad{g} of \\spad{G[s]} for some specific \\spad{s} in \\spad{E} is said to be an element of \\spad{G} with degree \\spad{s}. Sums are defined in each module \\spad{G[s]} so two elements of \\spad{G} have a sum if they have the same degree. \\blankline Morphisms can be defined and composed by degree to give the mathematical category of graded modules."

--->bookvol10.2.pamphlet-->GradedModule(((Zero) (%) constant)): Improper first word in comments: 
"0 denotes the zero of degree 0."

--->bookvol10.2.pamphlet-->GradedModule(constructor): Missing left brace
"GradedModule(R,E) denotes ``E-graded R-module'', \\spadignore{i.e.} collection of R-modules indexed by an abelian monoid E. An element \\spad{g} of \\spad{G[s]} for some specific \\spad{s} in \\spad{E} is said to be an element of \\spad{G} with degree \\spad{s}. Sums are defined in each module \\spad{G[s]} so two elements of \\spad{G} have a sum if they have the same degree. \\blankline Morphisms can be defined and composed by degree to give the mathematical category of graded modules."

=========================================================================
typos 40324:

>compiling IFAMON.spad to IFAMON.nrlib
 
.. InnerFreeAbelianMonoid(#1,#2,#3) of cat 
(|FreeAbelianMonoidCategory| |#1| |#2|)    has no  outputForm : (%,((OutputForm,OutputForm) -> OutputForm),((OutputForm,OutputForm) -> OutputForm),Integer) -> OutputForm 

=========================================================================
typos 40323:

>compiling GRALG.spad to GRALG.nrlib

--->-->GradedAlgebra&(((One) (%) constant)): Improper first word in comments: 
"1 is the identity for \\spad{product}."

--->bookvol10.2.pamphlet-->GradedAlgebra(((One) (%) constant)): Improper first word in comments: 
"1 is the identity for \\spad{product}."

=========================================================================
typos 40322:

>compiling SKAGG.spad to SKAGG.nrlib

--->bookvol10.2.pamphlet-->StackAggregate((push! (S S %))): Improper first word in comments: 
--->bookvol10.2.pamphlet-->StackAggregate((push! (S S %))): Missing left brace
"\\indented{1}{push!(x,s) pushes \\spad{x} onto stack \\spad{s,} \\spadignore{i.e.} destructively changing \\spad{s}} \\indented{1}{so as to have a new first (top) element \\spad{x.}} \\indented{1}{Afterwards, pop!(s) produces \\spad{x} and pop!(s) produces the original \\spad{s.}} \\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} push! a \\spad{X} a"

--->bookvol10.2.pamphlet-->StackAggregate((pop! (S %))): Improper first word in comments: 
"\\indented{1}{pop!(s) returns the top element \\spad{x,} destructively removing \\spad{x} from \\spad{s.}} \\indented{1}{Note that Use \\axiom{top(s)} to obtain \\spad{x} without removing it from \\spad{s.}} \\indented{1}{Error: if \\spad{s} is empty.} \\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} pop! a \\spad{X} a"

--->bookvol10.2.pamphlet-->StackAggregate((top (S %))): Improper first word in comments: 
"\\indented{1}{top(s) returns the top element \\spad{x} from \\spad{s;} \\spad{s} remains unchanged.} \\indented{1}{Note that Use \\axiom{pop!(s)} to obtain \\spad{x} and remove it from \\spad{s.}} \\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} top a"

--->bookvol10.2.pamphlet-->StackAggregate((depth ((NonNegativeInteger) %))): Improper first word in comments: 
"\\indented{1}{depth(s) returns the number of elements of stack \\spad{s.}} \\indented{1}{Note that \\axiom{depth(s) = \\#s}.} \\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} depth a"

=========================================================================
typos 40321:

>compiling BSTREE.spad to BSTREE.nrlib
--------------non extending category----------------------
.. BinarySearchTree(#1) of cat 
(|Join| (|BinaryTreeCategory| |#1|) (CATEGORY |domain| (ATTRIBUTE |shallowlyMutable|) (ATTRIBUTE |finiteAggregate|) (SIGNATURE |binarySearchTree| ($ (|List| |#1|))) (SIGNATURE |insert!| ($ |#1| $)) (SIGNATURE |insertRoot!| ($ |#1| $)) (SIGNATURE |split| ((|Record| (|:| |less| $) (|:| |greater| $)) |#1| $))))    has no  binaryTree : #1 -> % 

--->bookvol10.3.pamphlet-->BinarySearchTree((binarySearchTree (% (List S)))): Improper first word in comments: 
"\\indented{1}{binarySearchTree(l) is not documented} \\blankline \\spad{X} binarySearchTree [1,2,3,4]"

--->bookvol10.3.pamphlet-->BinarySearchTree((insert! (% S %))): Improper first word in comments: 
"\\indented{1}{insert!(x,b) inserts element \\spad{x} as leaves into binary search tree \\spad{b.}} \\blankline \\spad{X} t1:=binarySearchTree [1,2,3,4] \\spad{X} insert!(5,t1)"

--->bookvol10.3.pamphlet-->BinarySearchTree((insertRoot! (% S %))): Improper first word in comments: 
"\\indented{1}{insertRoot!(x,b) inserts element \\spad{x} as a root of binary search tree \\spad{b.}} \\blankline \\spad{X} t1:=binarySearchTree [1,2,3,4] \\spad{X} insertRoot!(5,t1)"

--->bookvol10.3.pamphlet-->BinarySearchTree((split ((Record (: less %) (: greater %)) S %))): Improper first word in comments: 
"\\indented{1}{split(x,b) splits binary tree \\spad{b} into two trees, one with elements} \\indented{1}{greater than \\spad{x,} the other with elements less than \\spad{x.}} \\blankline \\spad{X} t1:=binarySearchTree [1,2,3,4] \\spad{X} split(3,t1)"

=========================================================================
typos 40320:

>compiling BTOURN.spad to BTOURN.nrlib

--->bookvol10.3.pamphlet-->BinaryTournament((binaryTournament (% (List S)))): Improper first word in comments: 
"\\indented{1}{binaryTournament(ls) creates a binary tournament with the} \\indented{1}{elements of \\spad{ls} as values at the nodes.} \\blankline \\spad{X} binaryTournament [1,2,3,4]"

--->bookvol10.3.pamphlet-->BinaryTournament((insert! (% S %))): Improper first word in comments: 
"\\indented{1}{insert!(x,b) inserts element \\spad{x} as leaves into binary tournament \\spad{b.}} \\blankline \\spad{X} t1:=binaryTournament [1,2,3,4] \\spad{X} insert!(5,t1) \\spad{X} \\spad{t1}"

=========================================================================
typos 40319:

>compiling CARD.spad to CARD.nrlib

--->bookvol10.3.pamphlet-->CardinalNumber((commutative (attribute *))): Improper first word in comments: a
"a domain \\spad{D} has \\spad{commutative(\"*\")} if it has an operation \\spad{\"*\": (D,D) \\spad{->} \\spad{D}} which is commutative."

--->bookvol10.3.pamphlet-->CardinalNumber((- ((Union % failed) % %))): Improper first word in comments: 
"\\indented{1}{\\spad{x - \\spad{y}} returns an element \\spad{z} such that} \\indented{1}{\\spad{z+y=x} or \"failed\" if no such element exists.} \\blankline \\spad{X} c2:=2::CardinalNumber \\spad{X} \\spad{c2-c2} \\spad{X} A1:=Aleph 1 \\spad{X} \\spad{A1-c2}"

--->bookvol10.3.pamphlet-->CardinalNumber((** (% % %))): Improper first word in comments: 
"\\indented{1}{\\spad{x**y} returns \\spad{\\#(X**Y)} where \\spad{X**Y} is defined} \\indented{2}{as \\spad{\\{g| g:Y->X\\}}.} \\blankline \\spad{X} c2:=2::CardinalNumber \\spad{X} \\spad{c2**c2} \\spad{X} A1:=Aleph 1 \\spad{X} \\spad{A1**c2} \\spad{X} generalizedContinuumHypothesisAssumed \\spad{true} \\spad{X} \\spad{A1**A1}"

--->bookvol10.3.pamphlet-->CardinalNumber((Aleph (% (NonNegativeInteger)))): Improper first word in comments: 
"\\indented{1}{Aleph(n) provides the named (infinite) cardinal number.} \\blankline \\spad{X} A0:=Aleph 0"

--->bookvol10.3.pamphlet-->CardinalNumber((finite? ((Boolean) %))): Improper first word in comments: 
--->bookvol10.3.pamphlet-->CardinalNumber((finite? ((Boolean) %))): Missing left brace
"\\indented{1}{finite?(\\spad{a}) determines whether} \\indented{1}{\\spad{a} is a finite cardinal, \\spadignore{i.e.} an integer.} \\blankline \\spad{X} c2:=2::CardinalNumber \\spad{X} finite? \\spad{c2} \\spad{X} A0:=Aleph 0 \\spad{X} finite? \\spad{A0}"

--->bookvol10.3.pamphlet-->CardinalNumber((countable? ((Boolean) %))): Improper first word in comments: 
--->bookvol10.3.pamphlet-->CardinalNumber((countable? ((Boolean) %))): Missing left brace
"\\indented{1}{countable?(\\spad{a}) determines} \\indented{1}{whether \\spad{a} is a countable cardinal,} \\indented{1}{\\spadignore{i.e.} an integer or \\spad{Aleph 0}.} \\blankline \\spad{X} c2:=2::CardinalNumber \\spad{X} countable? \\spad{c2} \\spad{X} A0:=Aleph 0 \\spad{X} countable? \\spad{A0} \\spad{X} A1:=Aleph 1 \\spad{X} countable? \\spad{A1}"

--->bookvol10.3.pamphlet-->CardinalNumber((generalizedContinuumHypothesisAssumed? ((Boolean)))): Improper first word in comments: 
"\\indented{1}{generalizedContinuumHypothesisAssumed?()} \\indented{1}{tests if the hypothesis is currently assumed.} \\blankline \\spad{X} generalizedContinuumHypothesisAssumed?"

--->bookvol10.3.pamphlet-->CardinalNumber((generalizedContinuumHypothesisAssumed ((Boolean) (Boolean)))): Improper first word in comments: 
"\\indented{1}{generalizedContinuumHypothesisAssumed(bool)} \\indented{1}{is used to dictate whether the hypothesis is to be assumed.} \\blankline \\spad{X} generalizedContinuumHypothesisAssumed \\spad{true} \\spad{X} a:=Aleph 0 \\spad{X} c:=2**a \\spad{X} f:=2**c"

=========================================================================
typos 40318:

>compiling DQAGG.spad to DQAGG.nrlib

--->bookvol10.2.pamphlet-->DequeueAggregate((reverse! (% %))): Missing left brace
"\\spad{reverse!(d)} destructively replaces \\spad{d} by its reverse dequeue, \\spadignore{i.e.} the top (front) element is now the bottom (back) element, and so on."
--------constructor---------

=========================================================================
typos 40317:

>compiling FACTFUNC.spad to FACTFUNC.nrlib

--------(nthRoot ((Record (: exponent N) (: coef M) (: radicand (List M))) (Factored M) N))---------
--------(log ((List (Record (: coef N) (: logand M))) (Factored M)))---------

=========================================================================
typos 40316:

>compiling FRUTIL.spad to FRUTIL.nrlib

--->bookvol10.4.pamphlet-->FactoredFunctionUtilities((mergeFactors (FR FR FR))): Missing left brace
"\\spad{mergeFactors(u,v)} is used when the factorizations of \\spadvar{u} and \\spadvar{v} are known to be disjoint, \\spadignore{e.g.} resulting from a content/primitive part split. Essentially, it creates a new factored object by multiplying the units together and appending the lists of factors."
--------constructor---------

=========================================================================
typos 40315:

>compiling ITAYLOR.spad to ITAYLOR.nrlib

--->bookvol10.3.pamphlet-->InnerTaylorSeries((order (NNI %))): Missing left brace
"\\spad{order(x)} returns the order of a power series \\spad{x,} \\indented{1}{\\spadignore{i.e.} the degree of the first non-zero term of the series.}"

=========================================================================
typos 40314:

>compiling PID.spad to PID.nrlib

--->bookvol10.2.pamphlet-->PrincipalIdealDomain(constructor): Missing left brace
"The category of constructive principal ideal domains, \\spadignore{i.e.} where a single generator can be constructively found for any ideal given by a finite set of generators. Note that this constructive definition only implies that finitely generated ideals are principal. It is not clear what we would mean by an infinitely generated ideal."

=========================================================================
typos 40313:

>compiling DIVCAT.spad to DIVCAT.nrlib

--->bookvol10.2.pamphlet-->DivisorCategory((split ((List %) %))): Missing left pren
--->bookvol10.2.pamphlet-->DivisorCategory((split ((List %) %))): Missing right bracket
"\\spad{split(d)} splits the divisor \\spad{d.} For example, split( 2 \\spad{p1} + 3p2 ) returns the list [ 2 \\spad{p1,} 3 \\spad{p2} \\spad{].}"
--->bookvol10.2.pamphlet-->DivisorCategory((<= (BOOLEAN % %))): Not documented!!!!

--->bookvol10.2.pamphlet-->DivisorCategory((suppOfPole ((LIST S) %))): Improper first word in comments: suppOfZero
"suppOfZero(d) returns the elements of the support of \\spad{d} that have a negative coefficient."

--->bookvol10.2.pamphlet-->DivisorCategory((incr (% %))): Not documented!!!!

=========================================================================
typos 40312:

>compiling EAB.spad to EAB.nrlib

--->bookvol10.3.pamphlet-->ExtAlgBasis((degree (NNI %))): Missing left brace
"\\spad{degree(x)} gives the numbers of 1's in \\spad{x,} \\spadignore{i.e.} the number of non-zero exponents in the basis element that \\spad{x} represents."

=========================================================================
typos 40311:

>compiling FIELD.spad to FIELD.nrlib
 
--->-->Field&(constructor): Missing left brace
"The category of commutative fields, \\spadignore{i.e.} commutative rings where all non-zero elements have multiplicative inverses. The \\spadfun{factor} operation while trivial is useful to have defined. \\blankline Axioms\\br \\tab{5}\\spad{a*(b/a) = b}\\br \\tab{5}\\spad{inv(a) = 1/a}"

--->bookvol10.2.pamphlet-->Field(constructor): Missing left brace
"The category of commutative fields, \\spadignore{i.e.} commutative rings where all non-zero elements have multiplicative inverses. The \\spadfun{factor} operation while trivial is useful to have defined. \\blankline Axioms\\br \\tab{5}\\spad{a*(b/a) = b}\\br \\tab{5}\\spad{inv(a) = 1/a}"

=========================================================================
typos 40310:

>compiling FSERIES.spad to FSERIES.nrlib

--->bookvol10.3.pamphlet-->FourierSeries((makeCos ($ E R))): Improper first word in comments: 
"\\indented{1}{makeCos(e,r) makes a sin expression with given} argument and coefficient"

=========================================================================
typos 40309:

>compiling LA.spad to LA.nrlib

--->bookvol10.3.pamphlet-->LocalAlgebra(constructor): Missing left brace
"LocalAlgebra produces the localization of an algebra, \\spadignore{i.e.} fractions whose numerators come from some \\spad{R} algebra."

=========================================================================
typos 40308:

>compiling MAPPKG4.spad to MAPPKG4.nrlib

--->bookvol10.4.pamphlet-->MappingPackage4((+ ((Mapping B A) (Mapping B A) (Mapping B A)))): Improper first word in comments: 
"\\indented{1}{\\spad(+) does functional addition} \\blankline \\spad{X} f:=(x:INT):INT \\spad{+->} 3*x \\spad{X} g:=(x:INT):INT \\spad{+->} 2*x+3 \\spad{X} (f+g)(4)"

--->bookvol10.4.pamphlet-->MappingPackage4((- ((Mapping B A) (Mapping B A) (Mapping B A)))): Improper first word in comments: 
"\\indented{1}{\\spad(+) does functional addition} \\blankline \\spad{X} f:=(x:INT):INT \\spad{+->} 3*x \\spad{X} g:=(x:INT):INT \\spad{+->} 2*x+3 \\spad{X} (f-g)(4)"

--->bookvol10.4.pamphlet-->MappingPackage4((* ((Mapping B A) (Mapping B A) (Mapping B A)))): Improper first word in comments: 
"\\indented{1}{\\spad(+) does functional addition} \\blankline \\spad{X} f:=(x:INT):INT \\spad{+->} 3*x \\spad{X} g:=(x:INT):INT \\spad{+->} 2*x+3 \\spad{X} (f*g)(4)"

--->bookvol10.4.pamphlet-->MappingPackage4((/ ((Mapping (Expression (Integer)) A) (Mapping (Expression (Integer)) A) (Mapping (Expression (Integer)) A)))): Improper first word in comments: 
"\\indented{1}{\\spad(+) does functional addition} \\blankline \\spad{X} p:=(x:EXPR(INT)):EXPR(INT)+->3*x \\spad{X} \\spad{q:=(x:EXPR(INT)):EXPR(INT)+->2*x+3} \\spad{X} (p/q)(4) \\spad{X} (p/q)(x)"

=========================================================================
typos 40307:

>compiling PRODUCT.spad to PRODUCT.nrlib

--->bookvol10.3.pamphlet-->Product((makeprod (% A B))): Improper first word in comments: 
"\\indented{1}{makeprod(a,b) computes the product of two functions} \\blankline \\spad{X} f:=(x:INT):INT \\spad{+->} 3*x \\spad{X} g:=(x:INT):INT \\spad{+->} \\spad{x^3} \\spad{X} h(x:INT):Product(INT,INT) \\spad{==} makeprod(f \\spad{x,} \\spad{g} \\spad{x)} \\spad{X} h(3)"

=========================================================================
typos 40306:

>compiling ARR2CAT.spad to ARR2CAT.nrlib

--->-->TwoDimensionalArrayCategory&((new (% (NonNegativeInteger) (NonNegativeInteger) R))): Improper first word in comments: 
"\\indented{1}{new(m,n,r) is an m-by-n array all of whose entries are \\spad{r}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,0)"

--->-->TwoDimensionalArrayCategory&((fill! (% % R))): Improper first word in comments: 
"\\indented{1}{fill!(m,r) fills \\spad{m} with r's} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,0) \\spad{X} fill!(arr,10)"

--->-->TwoDimensionalArrayCategory&((minRowIndex ((Integer) %))): Improper first word in comments: 
"\\indented{1}{minRowIndex(m) returns the index of the 'first' row of the array \\spad{m}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} minRowIndex(arr)"

--->-->TwoDimensionalArrayCategory&((maxRowIndex ((Integer) %))): Improper first word in comments: 
"\\indented{1}{maxRowIndex(m) returns the index of the 'last' row of the array \\spad{m}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} maxRowIndex(arr)"

--->-->TwoDimensionalArrayCategory&((minColIndex ((Integer) %))): Improper first word in comments: 
"\\indented{1}{minColIndex(m) returns the index of the 'first' column of the array \\spad{m}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} minColIndex(arr)"

--->-->TwoDimensionalArrayCategory&((maxColIndex ((Integer) %))): Improper first word in comments: 
"\\indented{1}{maxColIndex(m) returns the index of the 'last' column of the array \\spad{m}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} maxColIndex(arr)"

--->-->TwoDimensionalArrayCategory&((nrows ((NonNegativeInteger) %))): Improper first word in comments: 
"\\indented{1}{nrows(m) returns the number of rows in the array \\spad{m}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} nrows(arr)"

--->-->TwoDimensionalArrayCategory&((ncols ((NonNegativeInteger) %))): Improper first word in comments: 
"\\indented{1}{ncols(m) returns the number of columns in the array \\spad{m}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} ncols(arr)"

--->-->TwoDimensionalArrayCategory&((elt (R % (Integer) (Integer)))): Improper first word in comments: 
"\\indented{1}{elt(m,i,j) returns the element in the \\spad{i}th row and jth} \\indented{1}{column of the array \\spad{m}} \\indented{1}{error check to determine if indices are in proper ranges} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} elt(arr,1,1)"

--->-->TwoDimensionalArrayCategory&((qelt (R % (Integer) (Integer)))): Improper first word in comments: 
"\\indented{1}{qelt(m,i,j) returns the element in the \\spad{i}th row and jth} \\indented{1}{column of the array \\spad{m}} \\indented{1}{NO error check to determine if indices are in proper ranges} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} qelt(arr,1,1)"

--->-->TwoDimensionalArrayCategory&((elt (R % (Integer) (Integer) R))): Improper first word in comments: 
"\\indented{1}{elt(m,i,j,r) returns the element in the \\spad{i}th row and jth} \\indented{1}{column of the array \\spad{m,} if \\spad{m} has an \\spad{i}th row and a \\spad{j}th column,} \\indented{1}{and returns \\spad{r} otherwise} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} elt(arr,1,1,6) \\spad{X} elt(arr,1,10,6)"

--->-->TwoDimensionalArrayCategory&((row (Row % (Integer)))): Improper first word in comments: 
"\\indented{1}{row(m,i) returns the \\spad{i}th row of \\spad{m}} \\indented{1}{error check to determine if index is in proper ranges} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} row(arr,1)"

--->-->TwoDimensionalArrayCategory&((column (Col % (Integer)))): Improper first word in comments: 
"\\indented{1}{column(m,j) returns the \\spad{j}th column of \\spad{m}} \\indented{1}{error check to determine if index is in proper ranges} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} column(arr,1)"

--->-->TwoDimensionalArrayCategory&((parts ((List R) %))): Improper first word in comments: 
"\\indented{1}{parts(m) returns a list of the elements of \\spad{m} in row major order} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} parts(arr)"

--->-->TwoDimensionalArrayCategory&((setelt (R % (Integer) (Integer) R))): Improper first word in comments: 
"\\indented{1}{setelt(m,i,j,r) sets the element in the \\spad{i}th row and jth} \\indented{1}{column of \\spad{m} to \\spad{r}} \\indented{1}{error check to determine if indices are in proper ranges} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,0) \\spad{X} setelt(arr,1,1,17)"

--->-->TwoDimensionalArrayCategory&((qsetelt! (R % (Integer) (Integer) R))): Improper first word in comments: 
"\\indented{1}{qsetelt!(m,i,j,r) sets the element in the \\spad{i}th row and jth} \\indented{1}{column of \\spad{m} to \\spad{r}} \\indented{1}{NO error check to determine if indices are in proper ranges} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,0) \\spad{X} qsetelt!(arr,1,1,17)"

--->-->TwoDimensionalArrayCategory&((setRow! (% % (Integer) Row))): Improper first word in comments: 
"\\indented{1}{setRow!(m,i,v) sets to \\spad{i}th row of \\spad{m} to \\spad{v}} \\blankline \\spad{X} T1:=TwoDimensionalArray Integer \\spad{X} arr:T1:= new(5,4,0) \\spad{X} T2:=OneDimensionalArray Integer \\spad{X} \\spad{arow:=construct([1,2,3,4]::List(INT))$T2} \\spad{X} \\spad{setRow!(arr,1,arow)$T1}"

--->-->TwoDimensionalArrayCategory&((setColumn! (% % (Integer) Col))): Improper first word in comments: 
"\\indented{1}{setColumn!(m,j,v) sets to \\spad{j}th column of \\spad{m} to \\spad{v}} \\blankline \\spad{X} T1:=TwoDimensionalArray Integer \\spad{X} arr:T1:= new(5,4,0) \\spad{X} T2:=OneDimensionalArray Integer \\spad{X} \\spad{acol:=construct([1,2,3,4,5]::List(INT))$T2} \\spad{X} \\spad{setColumn!(arr,1,acol)$T1}"

--->-->TwoDimensionalArrayCategory&((map (% (Mapping R R) %))): Improper first word in comments: 
"\\indented{1}{map(f,a) returns \\spad{b}, where \\spad{b(i,j) = f(a(i,j))}} \\indented{1}{for all \\spad{i, \\spad{j}}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} map(-,arr) \\spad{X} map((x \\spad{+->} \\spad{x} + x),arr)"

--->-->TwoDimensionalArrayCategory&((map! (% (Mapping R R) %))): Improper first word in comments: 
"\\indented{1}{map!(f,a)\\space{2}assign \\spad{a(i,j)} to \\spad{f(a(i,j))}} \\indented{1}{for all \\spad{i, \\spad{j}}} \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} map!(-,arr)"

--->-->TwoDimensionalArrayCategory&((map (% (Mapping R R R) % %))): Improper first word in comments: 
"\\indented{1}{map(f,a,b) returns \\spad{c}, where \\spad{c(i,j) = f(a(i,j),b(i,j))}} \\indented{1}{for all \\spad{i, \\spad{j}}} \\blankline \\spad{X} adder(a:Integer,b:Integer):Integer \\spad{==} a+b \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} map(adder,arr,arr)"

--->-->TwoDimensionalArrayCategory&((map (% (Mapping R R R) % % R))): Improper first word in comments: 
"\\indented{1}{map(f,a,b,r) returns \\spad{c}, where \\spad{c(i,j) = f(a(i,j),b(i,j))}} \\indented{1}{when both \\spad{a(i,j)} and \\spad{b(i,j)} exist;} \\indented{1}{else \\spad{c(i,j) = f(r, b(i,j))} when \\spad{a(i,j)} does not exist;} \\indented{1}{else \\spad{c(i,j) = f(a(i,j),r)} when \\spad{b(i,j)} does not exist;} \\indented{1}{otherwise \\spad{c(i,j) = f(r,r)}.} \\blankline \\spad{X} adder(a:Integer,b:Integer):Integer \\spad{==} a+b \\spad{X} \\spad{arr1} : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} \\spad{arr2} : \\spad{ARRAY2} INT \\spad{:=} new(3,3,10) \\spad{X} map(adder,arr1,arr2,17)"

--->bookvol10.2.pamphlet-->TwoDimensionalArrayCategory((new (% (NonNegativeInteger) (NonNegativeInteger) R))): Improper first word in comments: 
"\\indented{1}{new(m,n,r) is an m-by-n array all of whose entries are \\spad{r}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,0)"

--->bookvol10.2.pamphlet-->TwoDimensionalArrayCategory((fill! (% % R))): Improper first word in comments: 
"\\indented{1}{fill!(m,r) fills \\spad{m} with r's} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,0) \\spad{X} fill!(arr,10)"

--->bookvol10.2.pamphlet-->TwoDimensionalArrayCategory((minRowIndex ((Integer) %))): Improper first word in comments: 
"\\indented{1}{minRowIndex(m) returns the index of the 'first' row of the array \\spad{m}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} minRowIndex(arr)"

--->bookvol10.2.pamphlet-->TwoDimensionalArrayCategory((maxRowIndex ((Integer) %))): Improper first word in comments: 
"\\indented{1}{maxRowIndex(m) returns the index of the 'last' row of the array \\spad{m}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} maxRowIndex(arr)"

--->bookvol10.2.pamphlet-->TwoDimensionalArrayCategory((minColIndex ((Integer) %))): Improper first word in comments: 
"\\indented{1}{minColIndex(m) returns the index of the 'first' column of the array \\spad{m}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} minColIndex(arr)"

--->bookvol10.2.pamphlet-->TwoDimensionalArrayCategory((maxColIndex ((Integer) %))): Improper first word in comments: 
"\\indented{1}{maxColIndex(m) returns the index of the 'last' column of the array \\spad{m}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} maxColIndex(arr)"

--->bookvol10.2.pamphlet-->TwoDimensionalArrayCategory((nrows ((NonNegativeInteger) %))): Improper first word in comments: 
"\\indented{1}{nrows(m) returns the number of rows in the array \\spad{m}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} nrows(arr)"

--->bookvol10.2.pamphlet-->TwoDimensionalArrayCategory((ncols ((NonNegativeInteger) %))): Improper first word in comments: 
"\\indented{1}{ncols(m) returns the number of columns in the array \\spad{m}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} ncols(arr)"

--->bookvol10.2.pamphlet-->TwoDimensionalArrayCategory((elt (R % (Integer) (Integer)))): Improper first word in comments: 
"\\indented{1}{elt(m,i,j) returns the element in the \\spad{i}th row and jth} \\indented{1}{column of the array \\spad{m}} \\indented{1}{error check to determine if indices are in proper ranges} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} elt(arr,1,1)"

--->bookvol10.2.pamphlet-->TwoDimensionalArrayCategory((qelt (R % (Integer) (Integer)))): Improper first word in comments: 
"\\indented{1}{qelt(m,i,j) returns the element in the \\spad{i}th row and jth} \\indented{1}{column of the array \\spad{m}} \\indented{1}{NO error check to determine if indices are in proper ranges} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} qelt(arr,1,1)"

--->bookvol10.2.pamphlet-->TwoDimensionalArrayCategory((elt (R % (Integer) (Integer) R))): Improper first word in comments: 
"\\indented{1}{elt(m,i,j,r) returns the element in the \\spad{i}th row and jth} \\indented{1}{column of the array \\spad{m,} if \\spad{m} has an \\spad{i}th row and a \\spad{j}th column,} \\indented{1}{and returns \\spad{r} otherwise} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} elt(arr,1,1,6) \\spad{X} elt(arr,1,10,6)"

--->bookvol10.2.pamphlet-->TwoDimensionalArrayCategory((row (Row % (Integer)))): Improper first word in comments: 
"\\indented{1}{row(m,i) returns the \\spad{i}th row of \\spad{m}} \\indented{1}{error check to determine if index is in proper ranges} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} row(arr,1)"

--->bookvol10.2.pamphlet-->TwoDimensionalArrayCategory((column (Col % (Integer)))): Improper first word in comments: 
"\\indented{1}{column(m,j) returns the \\spad{j}th column of \\spad{m}} \\indented{1}{error check to determine if index is in proper ranges} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} column(arr,1)"

--->bookvol10.2.pamphlet-->TwoDimensionalArrayCategory((parts ((List R) %))): Improper first word in comments: 
"\\indented{1}{parts(m) returns a list of the elements of \\spad{m} in row major order} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} parts(arr)"

--->bookvol10.2.pamphlet-->TwoDimensionalArrayCategory((setelt (R % (Integer) (Integer) R))): Improper first word in comments: 
"\\indented{1}{setelt(m,i,j,r) sets the element in the \\spad{i}th row and jth} \\indented{1}{column of \\spad{m} to \\spad{r}} \\indented{1}{error check to determine if indices are in proper ranges} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,0) \\spad{X} setelt(arr,1,1,17)"

--->bookvol10.2.pamphlet-->TwoDimensionalArrayCategory((qsetelt! (R % (Integer) (Integer) R))): Improper first word in comments: 
"\\indented{1}{qsetelt!(m,i,j,r) sets the element in the \\spad{i}th row and jth} \\indented{1}{column of \\spad{m} to \\spad{r}} \\indented{1}{NO error check to determine if indices are in proper ranges} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,0) \\spad{X} qsetelt!(arr,1,1,17)"

--->bookvol10.2.pamphlet-->TwoDimensionalArrayCategory((setRow! (% % (Integer) Row))): Improper first word in comments: 
"\\indented{1}{setRow!(m,i,v) sets to \\spad{i}th row of \\spad{m} to \\spad{v}} \\blankline \\spad{X} T1:=TwoDimensionalArray Integer \\spad{X} arr:T1:= new(5,4,0) \\spad{X} T2:=OneDimensionalArray Integer \\spad{X} \\spad{arow:=construct([1,2,3,4]::List(INT))$T2} \\spad{X} \\spad{setRow!(arr,1,arow)$T1}"

--->bookvol10.2.pamphlet-->TwoDimensionalArrayCategory((setColumn! (% % (Integer) Col))): Improper first word in comments: 
"\\indented{1}{setColumn!(m,j,v) sets to \\spad{j}th column of \\spad{m} to \\spad{v}} \\blankline \\spad{X} T1:=TwoDimensionalArray Integer \\spad{X} arr:T1:= new(5,4,0) \\spad{X} T2:=OneDimensionalArray Integer \\spad{X} \\spad{acol:=construct([1,2,3,4,5]::List(INT))$T2} \\spad{X} \\spad{setColumn!(arr,1,acol)$T1}"

--->bookvol10.2.pamphlet-->TwoDimensionalArrayCategory((map (% (Mapping R R) %))): Improper first word in comments: 
"\\indented{1}{map(f,a) returns \\spad{b}, where \\spad{b(i,j) = f(a(i,j))}} \\indented{1}{for all \\spad{i, \\spad{j}}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} map(-,arr) \\spad{X} map((x \\spad{+->} \\spad{x} + x),arr)"

--->bookvol10.2.pamphlet-->TwoDimensionalArrayCategory((map! (% (Mapping R R) %))): Improper first word in comments: 
"\\indented{1}{map!(f,a)\\space{2}assign \\spad{a(i,j)} to \\spad{f(a(i,j))}} \\indented{1}{for all \\spad{i, \\spad{j}}} \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} map!(-,arr)"

--->bookvol10.2.pamphlet-->TwoDimensionalArrayCategory((map (% (Mapping R R R) % %))): Improper first word in comments: 
"\\indented{1}{map(f,a,b) returns \\spad{c}, where \\spad{c(i,j) = f(a(i,j),b(i,j))}} \\indented{1}{for all \\spad{i, \\spad{j}}} \\blankline \\spad{X} adder(a:Integer,b:Integer):Integer \\spad{==} a+b \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} map(adder,arr,arr)"

--->bookvol10.2.pamphlet-->TwoDimensionalArrayCategory((map (% (Mapping R R R) % % R))): Improper first word in comments: 
"\\indented{1}{map(f,a,b,r) returns \\spad{c}, where \\spad{c(i,j) = f(a(i,j),b(i,j))}} \\indented{1}{when both \\spad{a(i,j)} and \\spad{b(i,j)} exist;} \\indented{1}{else \\spad{c(i,j) = f(r, b(i,j))} when \\spad{a(i,j)} does not exist;} \\indented{1}{else \\spad{c(i,j) = f(a(i,j),r)} when \\spad{b(i,j)} does not exist;} \\indented{1}{otherwise \\spad{c(i,j) = f(r,r)}.} \\blankline \\spad{X} adder(a:Integer,b:Integer):Integer \\spad{==} a+b \\spad{X} \\spad{arr1} : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} \\spad{arr2} : \\spad{ARRAY2} INT \\spad{:=} new(3,3,10) \\spad{X} map(adder,arr1,arr2,17)"

=========================================================================
typos 40305:

>compiling BBTREE.spad to BBTREE.nrlib
 
--->bookvol10.3.pamphlet-->BalancedBinaryTree((balancedBinaryTree (% (NonNegativeInteger) S))): Improper first word in comments: 
"\\indented{1}{balancedBinaryTree(n, \\spad{s)} creates a balanced binary tree with} \\indented{1}{n nodes each with value \\spad{s.}} \\blankline \\spad{X} balancedBinaryTree(4, 0)"

--->bookvol10.3.pamphlet-->BalancedBinaryTree((setleaves! (% % (List S)))): Improper first word in comments: 
"\\indented{1}{setleaves!(t, \\spad{ls)} sets the leaves of \\spad{t} in left-to-right order} \\indented{1}{to the elements of ls.} \\blankline \\spad{X} t1:=balancedBinaryTree(4, 0) \\spad{X} setleaves!(t1,[1,2,3,4])"

--->bookvol10.3.pamphlet-->BalancedBinaryTree((mapUp! (S % (Mapping S S S)))): Improper first word in comments: 
"\\indented{1}{mapUp!(t,f) traverses balanced binary tree \\spad{t} in an \"endorder\"} \\indented{1}{(left then right then node) fashion returning \\spad{t} with the value} \\indented{1}{at each successive interior node of \\spad{t} replaced \\spad{by}} \\indented{1}{f(l,r) where \\spad{l} and \\spad{r} are the values at the immediate} \\indented{1}{left and right nodes.} \\blankline \\spad{X} T1:=BalancedBinaryTree Integer \\spad{X} t2:=balancedBinaryTree(4, 0)$T1 \\spad{X} setleaves!(t2,[1,2,3,4]::List(Integer)) \\spad{X} adder(a:Integer,b:Integer):Integer \\spad{==} a+b \\spad{X} mapUp!(t2,adder) \\spad{X} \\spad{t2}"

--->bookvol10.3.pamphlet-->BalancedBinaryTree((mapUp! (% % % (Mapping S S S S S)))): Improper first word in comments: 
"\\indented{1}{mapUp!(t,t1,f) traverses balanced binary tree \\spad{t} in an \"endorder\"} \\indented{1}{(left then right then node) fashion returning \\spad{t} with the value} \\indented{1}{at each successive interior node of \\spad{t} replaced \\spad{by}} \\indented{1}{f(l,r,l1,r1) where \\spad{l} and \\spad{r} are the values at the immediate} \\indented{1}{left and right nodes. Values \\spad{l1} and \\spad{r1} are values at the} \\indented{1}{corresponding nodes of a balanced binary tree \\spad{t1,} of identical} \\indented{1}{shape at \\spad{t.}} \\blankline \\spad{X} T1:=BalancedBinaryTree Integer \\spad{X} t2:=balancedBinaryTree(4, 0)$T1 \\spad{X} setleaves!(t2,[1,2,3,4]::List(Integer)) \\spad{X} adder4(i:INT,j:INT,k:INT,l:INT):INT \\spad{==} i+j+k+l \\spad{X} mapUp!(t2,t2,adder4) \\spad{X} \\spad{t2}"

--->bookvol10.3.pamphlet-->BalancedBinaryTree((mapDown! (% % S (Mapping S S S)))): Improper first word in comments: 
"\\indented{1}{mapDown!(t,p,f) returns \\spad{t} after traversing \\spad{t} in \"preorder\"} \\indented{1}{(node then left then right) fashion replacing the successive} \\indented{1}{interior nodes as follows. The root value \\spad{x} is} \\indented{1}{replaced by \\spad{q} \\spad{:=} f(p,x). The mapDown!(l,q,f) and} \\indented{1}{mapDown!(r,q,f) are evaluated for the left and right subtrees} \\indented{1}{l and \\spad{r} of \\spad{t.}} \\blankline \\spad{X} T1:=BalancedBinaryTree Integer \\spad{X} t2:=balancedBinaryTree(4, 0)$T1 \\spad{X} setleaves!(t2,[1,2,3,4]::List(Integer)) \\spad{X} adder(i:Integer,j:Integer):Integer \\spad{==} i+j \\spad{X} mapDown!(t2,4::INT,adder) \\spad{X} \\spad{t2}"

--->bookvol10.3.pamphlet-->BalancedBinaryTree((mapDown! (% % S (Mapping (List S) S S S)))): Improper first word in comments: 
"\\indented{1}{mapDown!(t,p,f) returns \\spad{t} after traversing \\spad{t} in \"preorder\"} \\indented{1}{(node then left then right) fashion replacing the successive} \\indented{1}{interior nodes as follows. Let \\spad{l} and \\spad{r} denote the left and} \\indented{1}{right subtrees of \\spad{t.} The root value \\spad{x} of \\spad{t} is replaced by \\spad{p.}} \\indented{1}{Then f(value \\spad{l,} value \\spad{r,} \\spad{p),} where \\spad{l} and \\spad{r} denote the left} \\indented{1}{and right subtrees of \\spad{t,} is evaluated producing two values} \\indented{1}{pl and \\spad{pr.} Then \\spad{mapDown!(l,pl,f)} and \\spad{mapDown!(l,pr,f)}} \\indented{1}{are evaluated.} \\blankline \\spad{X} T1:=BalancedBinaryTree Integer \\spad{X} t2:=balancedBinaryTree(4, 0)$T1 \\spad{X} setleaves!(t2,[1,2,3,4]::List(Integer)) \\spad{X} adder3(i:Integer,j:Integer,k:Integer):List Integer \\spad{==} [i+j,j+k] \\spad{X} mapDown!(t2,4::INT,adder3) \\spad{X} \\spad{t2}"

=========================================================================
typos 40303:

>compiling BTREE.spad to BTREE.nrlib

--->bookvol10.3.pamphlet-->BinaryTree((binaryTree (% S))): Improper first word in comments: 
"\\indented{1}{binaryTree(v) is an non-empty binary tree} \\indented{1}{with value \\spad{v,} and left and right empty.} \\blankline \\spad{X} t1:=binaryTree([1,2,3])"

--->bookvol10.3.pamphlet-->BinaryTree((binaryTree (% % S %))): Improper first word in comments: 
"\\indented{1}{binaryTree(l,v,r) creates a binary tree with} \\indented{1}{value \\spad{v} with left subtree \\spad{l} and right subtree \\spad{r.}} \\blankline \\spad{X} t1:=binaryTree([1,2,3]) \\spad{X} t2:=binaryTree([4,5,6]) \\spad{X} binaryTree(t1,[7,8,9],t2)"

=========================================================================
typos 40302:

>compiling DEQUEUE.spad to DEQUEUE.nrlib

--->bookvol10.3.pamphlet-->Dequeue((dequeue (% (List S)))): Improper first word in comments: 
"\\indented{1}{dequeue([x,y,...,z]) creates a dequeue with first (top or front)} \\indented{1}{element \\spad{x,} second element y,...,and last (bottom or back) element \\spad{z.}} \\blankline \\spad{E} g:Dequeue INT:= dequeue [1,2,3,4,5]"

=========================================================================
typos 40301:

>compiling DIRRING.spad to DIRRING.nrlib

--->bookvol10.3.pamphlet-->DirichletRing((coerce (% FUN))): Not documented!!!!
--->bookvol10.3.pamphlet-->DirichletRing((coerce (FUN %))): Not documented!!!!
--->bookvol10.3.pamphlet-->DirichletRing((coerce (% (Stream Coef)))): Not documented!!!!
--->bookvol10.3.pamphlet-->DirichletRing((coerce ((Stream Coef) %))): Not documented!!!!

=========================================================================
typos 40300:

>compiling DIV.spad to DIV.nrlib
--->bookvol10.3.pamphlet-->Divisor((head (PT %))): Not documented!!!!
--->bookvol10.3.pamphlet-->Divisor((reductum (% %))): Not documented!!!!

=========================================================================
typos 40299:

>compiling D01GBFA.spad to D01GBFA.nrlib

--------------non extending category----------------------
.. d01gbfAnnaType of cat 
(|NumericalIntegrationCategory|)   has no 
(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib D01GBFA 
   Processing d01gbfAnnaType for Browser database:


=========================================================================
typos 40296:

>compiling FPC.spad to FPC.nrlib

--->-->FieldOfPrimeCharacteristic&(constructor): Missing left brace
"FieldOfPrimeCharacteristic is the category of fields of prime characteristic, \\spadignore{e.g.} finite fields, algebraic closures of fields of prime characteristic, transcendental extensions of of fields of prime characteristic."

--->bookvol10.2.pamphlet-->FieldOfPrimeCharacteristic(constructor): Missing left brace
"FieldOfPrimeCharacteristic is the category of fields of prime characteristic, \\spadignore{e.g.} finite fields, algebraic closures of fields of prime characteristic, transcendental extensions of of fields of prime characteristic."

=========================================================================
typos 40295:

>compiling FMONOID.spad to FMONOID.nrlib

--->bookvol10.3.pamphlet-->FreeMonoid((hclf ($ $ $))): Missing left brace
"\\spad{hclf(x, \\spad{y)}} returns the highest common left factor of \\spad{x} and \\spad{y,} \\spadignore{i.e.} the largest \\spad{d} such that \\spad{x = \\spad{d} a} and \\spad{y = \\spad{d} \\spad{b}.}"

--->bookvol10.3.pamphlet-->FreeMonoid((hcrf ($ $ $))): Missing left brace
"\\spad{hcrf(x, \\spad{y)}} returns the highest common right factor of \\spad{x} and \\spad{y,} \\spadignore{i.e.} the largest \\spad{d} such that \\spad{x = a \\spad{d}} and \\spad{y = \\spad{b} \\spad{d}.}"

--->bookvol10.3.pamphlet-->FreeMonoid((lquo ((Union $ failed) $ $))): Missing left brace
"\\spad{lquo(x, \\spad{y)}} returns the exact left quotient of \\spad{x} by \\spad{y} \\spadignore{i.e.} \\spad{q} such that \\spad{x = \\spad{y} * \\spad{q},} \"failed\" if \\spad{x} is not of the form \\spad{y * \\spad{q}.}"

--->bookvol10.3.pamphlet-->FreeMonoid((rquo ((Union $ failed) $ $))): Missing left brace
"\\spad{rquo(x, \\spad{y)}} returns the exact right quotient of \\spad{x} by \\spad{y} \\spadignore{i.e.} \\spad{q} such that \\spad{x = \\spad{q} * \\spad{y},} \"failed\" if \\spad{x} is not of the form \\spad{q * \\spad{y}.}"

--->bookvol10.3.pamphlet-->FreeMonoid((divide ((Union (Record (: lm $) (: rm $)) failed) $ $))): Missing left brace
"\\spad{divide(x, \\spad{y)}} returns the left and right exact quotients of \\spad{x} by \\spad{y,} \\spadignore{i.e.} \\spad{[l, \\spad{r]}} such that \\spad{x = \\spad{l} * \\spad{y} * \\spad{r},} \"failed\" if \\spad{x} is not of the form \\spad{l * \\spad{y} * \\spad{r}.}"

--->bookvol10.3.pamphlet-->FreeMonoid((overlap ((Record (: lm $) (: mm $) (: rm $)) $ $))): Missing left brace
"\\spad{overlap(x, \\spad{y)}} returns \\spad{[l, \\spad{m,} \\spad{r]}} such that \\spad{x = \\spad{l} * \\spad{m},} \\spad{y = \\spad{m} * \\spad{r}} and \\spad{l} and \\spad{r} have no overlap, \\spadignore{i.e.} \\spad{overlap(l, \\spad{r)} = \\spad{[l,} 1, r]}."

=========================================================================
typos 40294:

>compiling LIECAT.spad to LIECAT.nrlib

--->-->LieAlgebra&(): Spurious comments: \indented{1}{\axiom{JacobiIdentity} means that} \axiom{[x,[y,z]]+[y,[z,x]]+[z,[x,y]] = 0} holds.

--------constructor---------
--->bookvol10.2.pamphlet-->LieAlgebra(): Spurious comments: \indented{1}{\axiom{JacobiIdentity} means that} \axiom{[x,[y,z]]+[y,[z,x]]+[z,[x,y]] = 0} holds.

=========================================================================
typos 40293:

>compiling LMOPS.spad to LMOPS.nrlib

--------(outputForm (O $ (Mapping O O O) (Mapping O O O) (Integer)))---------
--->bookvol10.3.pamphlet-->ListMonoidOps((outputForm (O $ (Mapping O O O) (Mapping O O O) (Integer)))): Mismatch: left pren matches right brace
--->bookvol10.3.pamphlet-->ListMonoidOps((outputForm (O $ (Mapping O O O) (Mapping O O O) (Integer)))): Mismatch: left pren matches right brace
--->bookvol10.3.pamphlet-->ListMonoidOps((outputForm (O $ (Mapping O O O) (Mapping O O O) (Integer)))): Mismatch: left pren matches right brace
"\\spad{outputForm(l, fop, fexp, unit)} converts the monoid element represented by \\spad{l} to an \\spadtype{OutputForm}. Argument unit is the output form for the \\spadignore{unit} of the monoid (\\spadignore{e.g.} 0 or 1), \\spad{fop(a, \\spad{b)}} is the output form for the monoid operation applied to \\spad{a} and \\spad{b} (\\spadignore{e.g.} \\spad{a + \\spad{b},} \\spad{a * \\spad{b},} \\spad{ab}), and \\spad{fexp(a, \\spad{n)}} is the output form for the exponentiation operation applied to \\spad{a} and \\spad{n} (\\spadignore{e.g.} \\spad{n a}, \\spad{n * a}, \\spad{a \\spad{**} \\spad{n},} \\spad{a\\^n})."

--->bookvol10.3.pamphlet-->ListMonoidOps((makeTerm ($ S E))): Mismatch: left pren matches right brace
"\\spad{makeTerm(s, e)} returns the monomial \\spad{s} exponentiated by \\spad{e} (\\spadignore{e.g.} s^e or \\spad{e} * \\spad{s).}"

--->bookvol10.3.pamphlet-->ListMonoidOps((reverse ($ $))): Missing left brace
"\\spad{reverse(l)} reverses the list of monomials forming \\spad{l.} This has some effect if the monoid is non-abelian, \\spadignore{i.e.} \\spad{reverse(a1\\^e1 \\spad{...} an\\^en) = an\\^en \\spad{...} a1\\^e1} which is different."

=========================================================================
typos 40292:

>compiling LZSTAGG.spad to LZSTAGG.nrlib

--->-->LazyStreamAggregate&((remove (% (Mapping (Boolean) S) %))): Improper first word in comments: 
"\\indented{1}{remove(f,st) returns a stream consisting of those elements of stream} \\indented{1}{st which do not satisfy the predicate \\spad{f.}} \\indented{1}{Note that \\spad{remove(f,st) = \\spad{[x} for \\spad{x} in st | not f(x)]}.} \\blankline \\spad{X} m:=[i for \\spad{i} in 1..] \\spad{X} f(i:PositiveInteger):Boolean \\spad{==} even? \\spad{i} \\spad{X} remove(f,m)"

--->-->LazyStreamAggregate&((select (% (Mapping (Boolean) S) %))): Improper first word in comments: 
"\\indented{1}{select(f,st) returns a stream consisting of those elements of stream} \\indented{1}{st satisfying the predicate \\spad{f.}} \\indented{1}{Note that \\spad{select(f,st) = \\spad{[x} for \\spad{x} in st | f(x)]}.} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} select(x+->prime? x,m)"

--->-->LazyStreamAggregate&((explicitEntries? ((Boolean) %))): Improper first word in comments: 
"\\indented{1}{explicitEntries?(s) returns \\spad{true} if the stream \\spad{s} has} \\indented{1}{explicitly computed entries, and \\spad{false} otherwise.} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} explicitEntries? \\spad{m}"

--->-->LazyStreamAggregate&((explicitlyEmpty? ((Boolean) %))): Improper first word in comments: 
"\\indented{1}{explicitlyEmpty?(s) returns \\spad{true} if the stream is an} \\indented{1}{(explicitly) empty stream.} \\indented{1}{Note that this is a null test which will not cause lazy evaluation.} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} explicitlyEmpty? \\spad{m}"

--->-->LazyStreamAggregate&((lazy? ((Boolean) %))): Improper first word in comments: 
"\\indented{1}{lazy?(s) returns \\spad{true} if the first node of the stream \\spad{s}} \\indented{1}{is a lazy evaluation mechanism which could produce an} \\indented{1}{additional entry to \\spad{s.}} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} lazy? \\spad{m}"

--->-->LazyStreamAggregate&((frst (S %))): Improper first word in comments: 
"\\indented{1}{frst(s) returns the first element of stream \\spad{s.}} \\indented{1}{Caution: this function should only be called after a \\spad{empty?}} \\indented{1}{test has been made since there no error check.} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} frst \\spad{m}"

--->-->LazyStreamAggregate&((rst (% %))): Improper first word in comments: 
"\\indented{1}{rst(s) returns a pointer to the next node of stream \\spad{s.}} \\indented{1}{Caution: this function should only be called after a \\spad{empty?}} \\indented{1}{test has been made since there no error check.} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} \\spad{rst} \\spad{m}"

--->-->LazyStreamAggregate&((numberOfComputedEntries ((NonNegativeInteger) %))): Improper first word in comments: 
"\\indented{1}{numberOfComputedEntries(st) returns the number of explicitly} \\indented{1}{computed entries of stream st which exist immediately prior to the} \\indented{1}{time this function is called.} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} numberOfComputedEntries \\spad{m}"

--->-->LazyStreamAggregate&((extend (% % (Integer)))): Improper first word in comments: 
"\\indented{1}{extend(st,n) causes entries to be computed, if necessary,} \\indented{1}{so that 'st' will have at least \\spad{'n'} explicit entries or so} \\indented{1}{that all entries of 'st' will be computed if 'st' is finite} \\indented{1}{with length \\spad{<=} \\spad{n.}} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} numberOfComputedEntries \\spad{m} \\spad{X} extend(m,20) \\spad{X} numberOfComputedEntries \\spad{m}"

--->-->LazyStreamAggregate&((complete (% %))): Improper first word in comments: 
"\\indented{1}{complete(st) causes all entries of 'st' to be computed.} \\indented{1}{this function should only be called on streams which are} \\indented{1}{known to be finite.} \\blankline \\spad{X} m:=[i for \\spad{i} in 1..] \\spad{X} n:=filterUntil(i+->i>100,m) \\spad{X} numberOfComputedEntries \\spad{n} \\spad{X} complete \\spad{n} \\spad{X} numberOfComputedEntries \\spad{n}"

--->-->LazyStreamAggregate&(constructor): Missing left brace
"LazyStreamAggregate is the category of streams with lazy evaluation. It is understood that the function 'empty?' will cause lazy evaluation if necessary to determine if there are entries. Functions which call 'empty?', \\spadignore{e.g.} 'first' and 'rest', will also cause lazy evaluation if necessary."

--->bookvol10.2.pamphlet-->LazyStreamAggregate((remove (% (Mapping (Boolean) S) %))): Improper first word in comments: 
"\\indented{1}{remove(f,st) returns a stream consisting of those elements of stream} \\indented{1}{st which do not satisfy the predicate \\spad{f.}} \\indented{1}{Note that \\spad{remove(f,st) = \\spad{[x} for \\spad{x} in st | not f(x)]}.} \\blankline \\spad{X} m:=[i for \\spad{i} in 1..] \\spad{X} f(i:PositiveInteger):Boolean \\spad{==} even? \\spad{i} \\spad{X} remove(f,m)"

--->bookvol10.2.pamphlet-->LazyStreamAggregate((select (% (Mapping (Boolean) S) %))): Improper first word in comments: 
"\\indented{1}{select(f,st) returns a stream consisting of those elements of stream} \\indented{1}{st satisfying the predicate \\spad{f.}} \\indented{1}{Note that \\spad{select(f,st) = \\spad{[x} for \\spad{x} in st | f(x)]}.} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} select(x+->prime? x,m)"

--->bookvol10.2.pamphlet-->LazyStreamAggregate((explicitEntries? ((Boolean) %))): Improper first word in comments: 
"\\indented{1}{explicitEntries?(s) returns \\spad{true} if the stream \\spad{s} has} \\indented{1}{explicitly computed entries, and \\spad{false} otherwise.} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} explicitEntries? \\spad{m}"

--->bookvol10.2.pamphlet-->LazyStreamAggregate((explicitlyEmpty? ((Boolean) %))): Improper first word in comments: 
"\\indented{1}{explicitlyEmpty?(s) returns \\spad{true} if the stream is an} \\indented{1}{(explicitly) empty stream.} \\indented{1}{Note that this is a null test which will not cause lazy evaluation.} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} explicitlyEmpty? \\spad{m}"

--->bookvol10.2.pamphlet-->LazyStreamAggregate((lazy? ((Boolean) %))): Improper first word in comments: 
"\\indented{1}{lazy?(s) returns \\spad{true} if the first node of the stream \\spad{s}} \\indented{1}{is a lazy evaluation mechanism which could produce an} \\indented{1}{additional entry to \\spad{s.}} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} lazy? \\spad{m}"

--->bookvol10.2.pamphlet-->LazyStreamAggregate((frst (S %))): Improper first word in comments: 
"\\indented{1}{frst(s) returns the first element of stream \\spad{s.}} \\indented{1}{Caution: this function should only be called after a \\spad{empty?}} \\indented{1}{test has been made since there no error check.} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} frst \\spad{m}"

--->bookvol10.2.pamphlet-->LazyStreamAggregate((rst (% %))): Improper first word in comments: 
"\\indented{1}{rst(s) returns a pointer to the next node of stream \\spad{s.}} \\indented{1}{Caution: this function should only be called after a \\spad{empty?}} \\indented{1}{test has been made since there no error check.} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} \\spad{rst} \\spad{m}"

--->bookvol10.2.pamphlet-->LazyStreamAggregate((numberOfComputedEntries ((NonNegativeInteger) %))): Improper first word in comments: 
"\\indented{1}{numberOfComputedEntries(st) returns the number of explicitly} \\indented{1}{computed entries of stream st which exist immediately prior to the} \\indented{1}{time this function is called.} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} numberOfComputedEntries \\spad{m}"

--->bookvol10.2.pamphlet-->LazyStreamAggregate((extend (% % (Integer)))): Improper first word in comments: 
"\\indented{1}{extend(st,n) causes entries to be computed, if necessary,} \\indented{1}{so that 'st' will have at least \\spad{'n'} explicit entries or so} \\indented{1}{that all entries of 'st' will be computed if 'st' is finite} \\indented{1}{with length \\spad{<=} \\spad{n.}} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} numberOfComputedEntries \\spad{m} \\spad{X} extend(m,20) \\spad{X} numberOfComputedEntries \\spad{m}"

--->bookvol10.2.pamphlet-->LazyStreamAggregate((complete (% %))): Improper first word in comments: 
"\\indented{1}{complete(st) causes all entries of 'st' to be computed.} \\indented{1}{this function should only be called on streams which are} \\indented{1}{known to be finite.} \\blankline \\spad{X} m:=[i for \\spad{i} in 1..] \\spad{X} n:=filterUntil(i+->i>100,m) \\spad{X} numberOfComputedEntries \\spad{n} \\spad{X} complete \\spad{n} \\spad{X} numberOfComputedEntries \\spad{n}"

--->bookvol10.2.pamphlet-->LazyStreamAggregate(constructor): Missing left brace
"LazyStreamAggregate is the category of streams with lazy evaluation. It is understood that the function 'empty?' will cause lazy evaluation if necessary to determine if there are entries. Functions which call 'empty?', \\spadignore{e.g.} 'first' and 'rest', will also cause lazy evaluation if necessary."

=========================================================================
typos 40291:

>compiling MAGMA.spad to MAGMA.nrlib

--->bookvol10.3.pamphlet-->Magma((coerce (WORD $))): Improper first word in comments: 
"\\indented{1}{\\axiom{coerce(x)} returns the element of} \\axiomType{OrderedFreeMonoid}(VarSet) \\indented{1}{corresponding to \\axiom{x} by removing parentheses.}"

=========================================================================
typos 40290:

>compiling MODOP.spad to MODOP.nrlib

--->bookvol10.3.pamphlet-->ModuleOperator((evaluate ($ $ (Mapping M M)))): Missing left brace
"\\spad{evaluate(f, \\spad{u} \\spad{+->} \\spad{g} u)} attaches the map \\spad{g} to \\spad{f.} \\spad{f} must be a basic operator \\spad{g} MUST be additive, \\spadignore{i.e.} \\spad{g(a + \\spad{b)} = g(a) + g(b)} for any \\spad{a}, \\spad{b} in \\spad{M.} This implies that \\spad{g(n a) = \\spad{n} g(a)} for any \\spad{a} in \\spad{M} and integer \\spad{n > 0}."

=========================================================================
typos 40289:

>compiling OFMONOID.spad to OFMONOID.nrlib

--->bookvol10.3.pamphlet-->OrderedFreeMonoid((* (% S %))): Improper first word in comments: 
"\\indented{1}{\\spad{s*x} returns the product of \\spad{x} by \\spad{s} on the left.} \\blankline \\spad{X} m1:=(x*y*y*z)$OFMONOID(Symbol) \\spad{X} \\spad{x*m1}"

--->bookvol10.3.pamphlet-->OrderedFreeMonoid((* (% % S))): Improper first word in comments: 
"\\indented{1}{\\spad{x*s} returns the product of \\spad{x} by \\spad{s} on the right.} \\blankline \\spad{X} m1:=(y**3)$OFMONOID(Symbol) \\spad{X} m1*x"

--->bookvol10.3.pamphlet-->OrderedFreeMonoid((** (% S NNI))): Improper first word in comments: 
"\\indented{1}{\\spad{s**n} returns the product of \\spad{s} by itself \\spad{n} times.} \\blankline \\spad{X} m1:=(y**3)$OFMONOID(Symbol)"

--->bookvol10.3.pamphlet-->OrderedFreeMonoid((first (S %))): Improper first word in comments: 
"\\indented{1}{\\spad{first(x)} returns the first letter of \\spad{x}.} \\blankline \\spad{X} m1:=(x*y*y*z)$OFMONOID(Symbol) \\spad{X} first \\spad{m1}"

--->bookvol10.3.pamphlet-->OrderedFreeMonoid((rest (% %))): Improper first word in comments: 
"\\indented{1}{\\spad{rest(x)} returns \\spad{x} except the first letter.} \\blankline \\spad{X} m1:=(x*y*y*z)$OFMONOID(Symbol) \\spad{X} rest \\spad{m1}"

--->bookvol10.3.pamphlet-->OrderedFreeMonoid((mirror (% %))): Improper first word in comments: 
"\\indented{1}{\\spad{mirror(x)} returns the reversed word of \\spad{x}.} \\blankline \\spad{X} m1:=(x*y*y*z)$OFMONOID(Symbol) \\spad{X} mirror \\spad{m1}"

--->bookvol10.3.pamphlet-->OrderedFreeMonoid((lexico ((Boolean) % %))): Improper first word in comments: 
"\\indented{1}{\\spad{lexico(x,y)} returns \\spad{true}} \\indented{1}{iff \\spad{x} is smaller than \\spad{y}} \\indented{1}{w.r.t. the pure lexicographical ordering induced by \\spad{S}.} \\blankline \\spad{X} m1:=(x*y*y*z)$OFMONOID(Symbol) \\spad{X} m2:=(x*y)$OFMONOID(Symbol) \\spad{X} lexico(m1,m2) \\spad{X} lexico(m2,m1)"

--->bookvol10.3.pamphlet-->OrderedFreeMonoid((hclf (% % %))): Improper first word in comments: 
"\\indented{1}{\\spad{hclf(x, \\spad{y)}} returns the highest common left factor} \\indented{1}{of \\spad{x} and \\spad{y},} \\indented{1}{that is the largest \\spad{d} such that \\spad{x = \\spad{d} a}} \\indented{1}{and \\spad{y = \\spad{d} b}.} \\blankline \\spad{X} m1:=(x*y*z)$OFMONOID(Symbol) \\spad{X} m2:=(x*y)$OFMONOID(Symbol) \\spad{X} hclf(m1,m2)"

--->bookvol10.3.pamphlet-->OrderedFreeMonoid((hcrf (% % %))): Improper first word in comments: 
"\\indented{1}{\\spad{hcrf(x, \\spad{y)}} returns the highest common right} \\indented{1}{factor of \\spad{x} and \\spad{y},} \\indented{1}{that is the largest \\spad{d} such that \\spad{x = a \\spad{d}}} \\indented{1}{and \\spad{y = \\spad{b} d}.} \\blankline \\spad{X} m1:=(x*y*z)$OFMONOID(Symbol) \\spad{X} m2:=(y*z)$OFMONOID(Symbol) \\spad{X} hcrf(m1,m2)"

--->bookvol10.3.pamphlet-->OrderedFreeMonoid((lquo ((Union % failed) % %))): Improper first word in comments: 
"\\indented{1}{\\spad{lquo(x, \\spad{y)}} returns the exact left quotient of \\spad{x}} \\indented{2}{by \\spad{y} that is \\spad{q} such that \\spad{x = \\spad{y} * q},} \\indented{1}{\"failed\" if \\spad{x} is not of the form \\spad{y * q}.} \\blankline \\spad{X} m1:=(x*y*y*z)$OFMONOID(Symbol) \\spad{X} m2:=(x*y)$OFMONOID(Symbol) \\spad{X} lquo(m1,m2)"

--->bookvol10.3.pamphlet-->OrderedFreeMonoid((rquo ((Union % failed) % %))): Improper first word in comments: 
"\\indented{1}{\\spad{rquo(x, \\spad{y)}} returns the exact right quotient of \\spad{x}} \\indented{1}{by \\spad{y} that is \\spad{q} such that \\spad{x = \\spad{q} * y},} \\indented{1}{\"failed\" if \\spad{x} is not of the form \\spad{q * y}.} \\blankline \\spad{X} m1:=(q*y^3)$OFMONOID(Symbol) \\spad{X} m2:=(y^2)$OFMONOID(Symbol) \\spad{X} lquo(m1,m2)"

--->bookvol10.3.pamphlet-->OrderedFreeMonoid((lquo ((Union % failed) % S))): Improper first word in comments: 
"\\indented{1}{\\spad{lquo(x, \\spad{s)}} returns the exact left quotient of \\spad{x}} \\indented{1}{by \\spad{s}.} \\blankline \\spad{X} m1:=(x*y*y*z)$OFMONOID(Symbol) \\spad{X} lquo(m1,x)"

--->bookvol10.3.pamphlet-->OrderedFreeMonoid((rquo ((Union % failed) % S))): Improper first word in comments: 
"\\indented{1}{\\spad{rquo(x, \\spad{s)}} returns the exact right quotient} \\indented{1}{of \\spad{x} by \\spad{s}.} \\blankline \\spad{X} m1:=(x*y)$OFMONOID(Symbol) \\spad{X} div(m1,y)"

--->bookvol10.3.pamphlet-->OrderedFreeMonoid((divide (RESULT % %))): Improper first word in comments: 
"\\indented{1}{\\spad{divide(x,y)} returns the left and right exact quotients of} \\indented{1}{\\spad{x} by \\spad{y}, that is \\spad{[l,r]} such that \\spad{x = l*y*r}.} \\indented{1}{\"failed\" is returned iff \\spad{x} is not of the form \\spad{l * \\spad{y} * r}.} \\blankline \\spad{X} m1:=(x*y*y*z)$OFMONOID(Symbol) \\spad{X} m2:=(x*y)$OFMONOID(Symbol) \\spad{X} divide(m1,m2)"

--->bookvol10.3.pamphlet-->OrderedFreeMonoid((overlap ((Record (: lm %) (: mm %) (: rm %)) % %))): Improper first word in comments: 
"\\indented{1}{\\spad{overlap(x, \\spad{y)}} returns \\spad{[l, \\spad{m,} \\spad{r]}} such that} \\indented{1}{\\spad{x = \\spad{l} * \\spad{m}} and \\spad{y = \\spad{m} * \\spad{r}} hold and such that} \\indented{1}{\\spad{l} and \\spad{r} have no overlap,} \\indented{1}{that is \\spad{overlap(l, \\spad{r)} = \\spad{[l,} 1, r]}.} \\blankline \\spad{X} m1:=(x*y*y*z)$OFMONOID(Symbol) \\spad{X} m2:=(x*y)$OFMONOID(Symbol) \\spad{X} overlap(m1,m2)"

--->bookvol10.3.pamphlet-->OrderedFreeMonoid((size (NNI %))): Improper first word in comments: 
"\\indented{1}{\\spad{size(x)} returns the number of monomials in \\spad{x}.} \\blankline \\spad{X} m1:=(x*y*y*z)$OFMONOID(Symbol) \\spad{X} size(m1,2)"

--->bookvol10.3.pamphlet-->OrderedFreeMonoid((nthExpon (NNI % (Integer)))): Improper first word in comments: 
"\\indented{1}{\\spad{nthExpon(x, \\spad{n)}} returns the exponent of the} \\indented{1}{\\spad{n-th} monomial of \\spad{x}.} \\blankline \\spad{X} m1:=(x*y*y*z)$OFMONOID(Symbol) \\spad{X} nthExpon(m1,2)"

--->bookvol10.3.pamphlet-->OrderedFreeMonoid((nthFactor (S % (Integer)))): Improper first word in comments: 
"\\indented{1}{\\spad{nthFactor(x, \\spad{n)}} returns the factor of the \\spad{n-th}} \\indented{1}{monomial of \\spad{x}.} \\blankline \\spad{X} m1:=(x*y*y*z)$OFMONOID(Symbol) \\spad{X} nthFactor(m1,2)"

--->bookvol10.3.pamphlet-->OrderedFreeMonoid((factors ((List REC) %))): Improper first word in comments: 
"\\indented{1}{\\spad{factors(a1\\^e1,...,an\\^en)} returns} \\indented{1}{\\spad{[[a1, e1],...,[an, en]]}.} \\blankline \\spad{X} m1:=(x*y*y*z)$OFMONOID(Symbol) \\spad{X} factors \\spad{m1}"

--->bookvol10.3.pamphlet-->OrderedFreeMonoid((length (NNI %))): Improper first word in comments: 
"\\indented{1}{\\spad{length(x)} returns the length of \\spad{x}.} \\blankline \\spad{X} m1:=(x*y*y*z)$OFMONOID(Symbol) \\spad{X} length \\spad{m1}"

--->bookvol10.3.pamphlet-->OrderedFreeMonoid((varList ((List S) %))): Improper first word in comments: 
"\\indented{1}{\\spad{varList(x)} returns the list of variables of \\spad{x}.} \\blankline \\spad{X} m1:=(x*y*y*z)$OFMONOID(Symbol) \\spad{X} varList \\spad{m1}"

=========================================================================
typos 40288:

>compiling PACPERC.spad to PACPERC.nrlib

--->bookvol10.2.pamphlet-->PseudoAlgebraicClosureOfPerfectFieldCategory((definingPolynomial ((SUP %)))): Not documented!!!!
--->bookvol10.2.pamphlet-->PseudoAlgebraicClosureOfPerfectFieldCategory((definingPolynomial ((SUP %) %))): Not documented!!!!
--->bookvol10.2.pamphlet-->PseudoAlgebraicClosureOfPerfectFieldCategory((lift ((SUP %) %))): Not documented!!!!
--->bookvol10.2.pamphlet-->PseudoAlgebraicClosureOfPerfectFieldCategory((lift ((SUP %) % %))): Not documented!!!!
--->bookvol10.2.pamphlet-->PseudoAlgebraicClosureOfPerfectFieldCategory((reduce (% (SUP %)))): Not documented!!!!
--------(distinguishedRootsOf ((List %) (SparseUnivariatePolynomial %) %))---------
--->bookvol10.2.pamphlet-->PseudoAlgebraicClosureOfPerfectFieldCategory((ground? ((Boolean) %))): Not documented!!!!

--->bookvol10.2.pamphlet-->PseudoAlgebraicClosureOfPerfectFieldCategory((vectorise ((Vector %) % %))): Not documented!!!!
--->bookvol10.2.pamphlet-->PseudoAlgebraicClosureOfPerfectFieldCategory((conjugate (% %))): Not documented!!!!
--->bookvol10.2.pamphlet-->PseudoAlgebraicClosureOfPerfectFieldCategory((newElement (% (SUP %) % (Symbol)))): Not documented!!!!
--->bookvol10.2.pamphlet-->PseudoAlgebraicClosureOfPerfectFieldCategory((newElement (% (SUP %) (Symbol)))): Not documented!!!!
--->bookvol10.2.pamphlet-->PseudoAlgebraicClosureOfPerfectFieldCategory((setTower! ((Void) %))): Not documented!!!!
--->bookvol10.2.pamphlet-->PseudoAlgebraicClosureOfPerfectFieldCategory((fullOutput ((OutputForm) %))): Not documented!!!!

=========================================================================
typos 40287:

>compiling PARTPERM.spad to PARTPERM.nrlib

--->bookvol10.4.pamphlet-->PartitionsAndPermutations((shuffle ((ST (L I)) (L I) (L I)))): Missing left brace
"\\spad{shuffle(l1,l2)} forms the stream of all shuffles of \\spad{l1} \\indented{1}{and \\spad{l2,} \\spadignore{i.e.} all sequences that can be formed from} \\indented{1}{merging \\spad{l1} and l2.}"

=========================================================================
typos 40286:

>compiling PENDTREE.spad to PENDTREE.nrlib

--->bookvol10.3.pamphlet-->PendantTree((ptree (% S))): Improper first word in comments: 
"\\indented{1}{ptree(s) is a leaf? pendant tree} \\blankline \\spad{X} t1:=ptree([1,2,3])"

--->bookvol10.3.pamphlet-->PendantTree((ptree (% % %))): Improper first word in comments: 
"\\indented{1}{ptree(x,y) is not documented} \\blankline \\spad{X} t1:=ptree([1,2,3]) \\spad{X} ptree(t1,ptree([1,2,3]))"

--->bookvol10.3.pamphlet-->PendantTree((coerce ((Tree S) %))): Improper first word in comments: 
"\\indented{1}{coerce(x) is not documented} \\blankline \\spad{X} t1:=ptree([1,2,3]) \\spad{X} t2:=ptree(t1,ptree([1,2,3])) \\spad{X} t2::Tree List PositiveInteger"

=========================================================================
typos 40285:

>compiling PFR.spad to PFR.nrlib

--->bookvol10.3.pamphlet-->PartialFraction((coerce ((Fraction R) %))): Improper first word in comments: 
"\\indented{1}{coerce(p) sums up the components of the partial fraction and} \\indented{1}{returns a single fraction.} \\blankline \\spad{X} a:=(13/74)::PFR(INT) \\spad{X} a::FRAC(INT)"

--->bookvol10.3.pamphlet-->PartialFraction((coerce (% (Fraction FRR)))): Improper first word in comments: 
"\\indented{1}{coerce(f) takes a fraction with numerator and denominator in} \\indented{1}{factored form and creates a partial fraction.\\space{2}It is} \\indented{1}{necessary for the parts to be factored because it is not} \\indented{1}{known in general how to factor elements of \\spad{R} and} \\indented{1}{this is needed to decompose into partial fractions.} \\blankline \\spad{X} (13/74)::PFR(INT)"

--->bookvol10.3.pamphlet-->PartialFraction((compactFraction (% %))): Improper first word in comments: 
"\\indented{1}{compactFraction(p) normalizes the partial fraction \\spad{p}} \\indented{1}{to the compact representation. In this form, the partial} \\indented{1}{fraction has only one fractional term per prime in the} \\indented{1}{denominator.} \\blankline \\spad{X} a:=partialFraction(1,factorial 10) \\spad{X} b:=padicFraction(a) \\spad{X} compactFraction(b)"

--->bookvol10.3.pamphlet-->PartialFraction((firstDenom (FRR %))): Improper first word in comments: 
"\\indented{1}{firstDenom(p) extracts the denominator of the first fractional} \\indented{1}{term. This returns 1 if there is no fractional part (use} \\indented{1}{wholePart from PartialFraction to get the whole part).} \\blankline \\spad{X} a:=partialFraction(1,factorial 10) \\spad{X} firstDenom(a)"

--->bookvol10.3.pamphlet-->PartialFraction((firstNumer (R %))): Improper first word in comments: 
"\\indented{1}{firstNumer(p) extracts the numerator of the first fractional} \\indented{1}{term. This returns 0 if there is no fractional part (use} \\indented{1}{wholePart from PartialFraction to get the whole part).} \\blankline \\spad{X} a:=partialFraction(1,factorial 10) \\spad{X} firstNumer(a)"

--->bookvol10.3.pamphlet-->PartialFraction((nthFractionalTerm (% % (Integer)))): Improper first word in comments: 
"\\indented{1}{nthFractionalTerm(p,n) extracts the \\spad{n}th fractional term from} \\indented{1}{the partial fraction \\spad{p}.\\space{2}This returns 0 if the index} \\indented{1}{\\spad{n} is out of range.} \\blankline \\spad{X} a:=partialFraction(1,factorial 10) \\spad{X} b:=padicFraction(a) \\spad{X} nthFractionalTerm(b,3)"

--->bookvol10.3.pamphlet-->PartialFraction((numberOfFractionalTerms ((Integer) %))): Improper first word in comments: 
"\\indented{1}{numberOfFractionalTerms(p) computes the number of fractional} \\indented{1}{terms in \\spad{p}. This returns 0 if there is no fractional} \\indented{1}{part.} \\blankline \\spad{X} a:=partialFraction(1,factorial 10) \\spad{X} b:=padicFraction(a) \\spad{X} numberOfFractionalTerms(b)"

--->bookvol10.3.pamphlet-->PartialFraction((padicFraction (% %))): Improper first word in comments: 
"\\indented{1}{padicFraction(q) expands the fraction p-adically in the primes} \\indented{1}{\\spad{p} in the denominator of \\spad{q}. For example,} \\indented{1}{\\spad{padicFraction(3/(2**2)) = 1/2 + 1/(2**2)}.} \\indented{1}{Use compactFraction from PartialFraction to} \\indented{1}{return to compact form.} \\blankline \\spad{X} a:=partialFraction(1,factorial 10) \\spad{X} padicFraction(a)"

--->bookvol10.3.pamphlet-->PartialFraction((partialFraction (% R FRR))): Improper first word in comments: 
"\\indented{1}{partialFraction(numer,denom) is the main function for} \\indented{1}{constructing partial fractions. The second argument is the} \\indented{1}{denominator and should be factored.} \\blankline \\spad{X} partialFraction(1,factorial 10)"

--->bookvol10.3.pamphlet-->PartialFraction((wholePart (R %))): Improper first word in comments: 
"\\indented{1}{wholePart(p) extracts the whole part of the partial fraction} \\indented{1}{\\spad{p}.} \\blankline \\spad{X} a:=(74/13)::PFR(INT) \\spad{X} wholePart(a)"

=========================================================================
typos 40284:

>compiling QUEUE.spad to QUEUE.nrlib

--->bookvol10.3.pamphlet-->Queue((queue (% (List S)))): Improper first word in comments: 
"\\indented{1}{queue([x,y,...,z]) creates a queue with first (top)} \\indented{1}{element \\spad{x,} second element y,...,and last (bottom) element \\spad{z.}} \\blankline \\spad{E} e:Queue INT:= queue [1,2,3,4,5]"

=========================================================================
typos 40283:

>compiling STACK.spad to STACK.nrlib

--->bookvol10.3.pamphlet-->Stack((stack (% (List S)))): Improper first word in comments: 
"\\indented{1}{stack([x,y,...,z]) creates a stack with first (top)} \\indented{1}{element \\spad{x,} second element y,...,and last element \\spad{z.}} \\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5]"

=========================================================================
typos 40282:

>compiling ARRAY1.spad to ARRAY1.nrlib

--->bookvol10.3.pamphlet-->OneDimensionalArray((oneDimensionalArray (% (List S)))): Improper first word in comments: 
"\\indented{1}{oneDimensionalArray(l) creates an array from a list of elements \\spad{l}} \\blankline \\spad{X} oneDimensionalArray \\spad{[i**2} for \\spad{i} in 1..10]"

--->bookvol10.3.pamphlet-->OneDimensionalArray((oneDimensionalArray (% (NonNegativeInteger) S))): Improper first word in comments: 
"\\indented{1}{oneDimensionalArray(n,s) creates an array from \\spad{n} copies of element \\spad{s}} \\blankline \\spad{X} oneDimensionalArray(10,0.0)"
--------constructor---------

=========================================================================
typos 40281:

>compiling ARRAY12.spad to ARRAY12.nrlib

--->bookvol10.4.pamphlet-->OneDimensionalArrayFunctions2((scan (VB (Mapping B A B) VA B))): Improper first word in comments: 
"\\indented{1}{scan(f,a,r) successively applies} \\indented{1}{\\spad{reduce(f,x,r)} to more and more leading sub-arrays} \\indented{1}{x of one-dimensional array \\spad{a}.} \\indented{1}{More precisely, if \\spad{a} is \\spad{[a1,a2,...]}, then} \\indented{1}{\\spad{scan(f,a,r)} returns} \\indented{1}{\\spad{[reduce(f,[a1],r),reduce(f,[a1,a2],r),...]}.} \\blankline \\spad{X} T1:=OneDimensionalArrayFunctions2(Integer,Integer) \\spad{X} adder(a:Integer,b:Integer):Integer \\spad{==} a+b \\spad{X} scan(adder,[i for \\spad{i} in 1..10],0)$T1"

--->bookvol10.4.pamphlet-->OneDimensionalArrayFunctions2((reduce (B (Mapping B A B) VA B))): Improper first word in comments: 
"\\indented{1}{reduce(f,a,r) applies function \\spad{f} to each} \\indented{1}{successive element of the} \\indented{1}{one-dimensional array \\spad{a} and an accumulant initialized to \\spad{r.}} \\indented{1}{For example, \\spad{reduce(_+$Integer,[1,2,3],0)}} \\indented{1}{does \\spad{3+(2+(1+0))}. Note that third argument \\spad{r}} \\indented{1}{may be regarded as the identity element for the function \\spad{f.}} \\blankline \\spad{X} T1:=OneDimensionalArrayFunctions2(Integer,Integer) \\spad{X} adder(a:Integer,b:Integer):Integer \\spad{==} a+b \\spad{X} reduce(adder,[i for \\spad{i} in 1..10],0)$T1"

--->bookvol10.4.pamphlet-->OneDimensionalArrayFunctions2((map (VB (Mapping B A) VA))): Improper first word in comments: 
"\\indented{1}{map(f,a) applies function \\spad{f} to each member of one-dimensional array} \\indented{1}{\\spad{a} resulting in a new one-dimensional array over a} \\indented{1}{possibly different underlying domain.} \\blankline \\spad{X} T1:=OneDimensionalArrayFunctions2(Integer,Integer) \\spad{X} map(x+->x+2,[i for \\spad{i} in 1..10])$T1"

=========================================================================
typos 40280:

>compiling ASTACK.spad to ASTACK.nrlib

--->bookvol10.3.pamphlet-->ArrayStack((arrayStack (% (List S)))): Improper first word in comments: 
"\\indented{1}{arrayStack([x,y,...,z]) creates an array stack with first (top)} \\indented{1}{element \\spad{x,} second element y,...,and last element \\spad{z.}} \\blankline \\spad{E} c:ArrayStack INT:= arrayStack [1,2,3,4,5]"

=========================================================================
typos 40279:

>compiling COMBINAT.spad to COMBINAT.nrlib

--->bookvol10.4.pamphlet-->IntegerCombinatoricFunctions((binomial (I I I))): Improper first word in comments: 
"\\indented{1}{\\spad{binomial(n,r)} returns the binomial coefficient} \\indented{1}{\\spad{C(n,r) = n!/(r! (n-r)!)}, where \\spad{n \\spad{>=} \\spad{r} \\spad{>=} 0}.} \\indented{1}{This is the number of combinations of \\spad{n} objects taken \\spad{r} at a time.} \\blankline \\spad{X} [binomial(5,i) for \\spad{i} in 0..5]"

=========================================================================
typos 40278:

>compiling CSTTOOLS.spad to CSTTOOLS.nrlib

--->bookvol10.4.pamphlet-->CyclicStreamTools((cycleElt ((Union ST failed) ST))): Improper first word in comments: 
"\\indented{1}{cycleElt(s) returns a pointer to a node in the cycle if the stream} \\indented{1}{s is cyclic and returns \"failed\" if \\spad{s} is not cyclic} \\blankline \\spad{X} p:=repeating([1,2,3]) \\spad{X} q:=cons(4,p) \\spad{X} cycleElt \\spad{q} \\spad{X} r:=[1,2,3]::Stream(Integer) \\spad{X} cycleElt \\spad{r}"

--->bookvol10.4.pamphlet-->CyclicStreamTools((computeCycleLength ((NonNegativeInteger) ST))): Improper first word in comments: 
"\\indented{1}{computeCycleLength(s) returns the length of the cycle of a} \\indented{1}{cyclic stream \\spad{t,} where \\spad{s} is a pointer to a node in the} \\indented{1}{cyclic part of \\spad{t.}} \\blankline \\spad{X} p:=repeating([1,2,3]) \\spad{X} q:=cons(4,p) \\spad{X} computeCycleLength(cycleElt(q))"

--->bookvol10.4.pamphlet-->CyclicStreamTools((computeCycleEntry (ST ST ST))): Improper first word in comments: 
"\\indented{1}{computeCycleEntry(x,cycElt), where cycElt is a pointer to a} \\indented{1}{node in the cyclic part of the cyclic stream \\spad{x,} returns a} \\indented{1}{pointer to the first node in the cycle} \\blankline \\spad{X} p:=repeating([1,2,3]) \\spad{X} q:=cons(4,p) \\spad{X} computeCycleEntry(q,cycleElt(q))"

=========================================================================
typos 40276:

>compiling HEAP.spad to HEAP.nrlib

--->bookvol10.3.pamphlet-->Heap((heap (% (List S)))): Improper first word in comments: 
"\\indented{1}{heap(ls) creates a heap of elements consisting of the} \\indented{1}{elements of ls.} \\blankline \\spad{E} i:Heap INT \\spad{:=} heap [1,6,3,7,5,2,4]"

=========================================================================
typos 40275:

>compiling IFARRAY.spad to IFARRAY.nrlib

--->bookvol10.3.pamphlet-->IndexedFlexibleArray((flexibleArray (% (List S)))): Improper first word in comments: 
"\\indented{1}{flexibleArray(l) creates a flexible array from the list of elements \\spad{l}} \\blankline \\spad{X} T1:=IndexedFlexibleArray(Integer,20) \\spad{X} flexibleArray([i for \\spad{i} in 1..10])$T1"

--->bookvol10.3.pamphlet-->IndexedFlexibleArray((physicalLength ((NonNegativeInteger) %))): Improper first word in comments: 
"\\indented{1}{physicalLength(x) returns the number of elements \\spad{x} can} \\indented{1}{accomodate before growing} \\blankline \\spad{X} T1:=IndexedFlexibleArray(Integer,20) \\spad{X} t2:=flexibleArray([i for \\spad{i} in 1..10])$T1 \\spad{X} physicalLength \\spad{t2}"

--->bookvol10.3.pamphlet-->IndexedFlexibleArray((physicalLength! (% % I))): Improper first word in comments: 
"\\indented{1}{physicalLength!(x,n) changes the physical length of \\spad{x} to be \\spad{n} and} \\indented{1}{returns the new array.} \\blankline \\spad{X} T1:=IndexedFlexibleArray(Integer,20) \\spad{X} t2:=flexibleArray([i for \\spad{i} in 1..10])$T1 \\spad{X} physicalLength!(t2,15)"

--->bookvol10.3.pamphlet-->IndexedFlexibleArray((shrinkable ((Boolean) (Boolean)))): Improper first word in comments: 
"\\indented{1}{shrinkable(b) sets the shrinkable attribute of flexible arrays to \\spad{b}} \\indented{1}{and returns the previous value} \\blankline \\spad{X} T1:=IndexedFlexibleArray(Integer,20) \\spad{X} \\spad{shrinkable(false)$T1}"

=========================================================================
typos 40274:

>compiling LFCAT.spad to LFCAT.nrlib

--->bookvol10.2.pamphlet-->LiouvillianFunctionCategory((Ei ($ $))): Missing left brace
"\\spad{Ei(x)} returns the exponential integral of \\spad{x,} \\spadignore{i.e.} the integral of \\spad{exp(x)/x dx}."

--->bookvol10.2.pamphlet-->LiouvillianFunctionCategory((Si ($ $))): Missing left brace
"\\spad{Si(x)} returns the sine integral of \\spad{x,} \\spadignore{i.e.} the integral of \\spad{sin(x) / \\spad{x} dx}."

--->bookvol10.2.pamphlet-->LiouvillianFunctionCategory((Ci ($ $))): Missing left brace
"\\spad{Ci(x)} returns the cosine integral of \\spad{x,} \\spadignore{i.e.} the integral of \\spad{cos(x) / \\spad{x} dx}."

--->bookvol10.2.pamphlet-->LiouvillianFunctionCategory((li ($ $))): Missing left brace
"\\spad{li(x)} returns the logarithmic integral of \\spad{x,} \\spadignore{i.e.} the integral of \\spad{dx / log(x)}."

--->bookvol10.2.pamphlet-->LiouvillianFunctionCategory((dilog ($ $))): Missing left brace
"\\spad{dilog(x)} returns the dilogarithm of \\spad{x,} \\spadignore{i.e.} the integral of \\spad{log(x) / \\spad{(1} - \\spad{x)} dx}."

--->bookvol10.2.pamphlet-->LiouvillianFunctionCategory((erf ($ $))): Missing left brace
"\\spad{erf(x)} returns the error function of \\spad{x,} \\spadignore{i.e.} \\spad{2 / sqrt(\\%pi)} times the integral of \\spad{exp(-x**2) dx}."

--->bookvol10.2.pamphlet-->LiouvillianFunctionCategory((fresnelS ($ $))): Improper initial operator in comments: is
"fresnelS is the Fresnel integral \\spad{S,} defined by S(x) = integrate(sin(t^2),t=0..x)"

--->bookvol10.2.pamphlet-->LiouvillianFunctionCategory((fresnelC ($ $))): Improper initial operator in comments: is
"fresnelC is the Fresnel integral \\spad{C,} defined by C(x) = integrate(cos(t^2),t=0..x)"

=========================================================================
typos 40273:

>compiling MATCAT.spad to MATCAT.nrlib

--->-->MatrixCategory&((square? ((Boolean) %))): Improper first word in comments: 
"\\indented{1}{\\spad{square?(m)} returns \\spad{true} if \\spad{m} is a square matrix} \\indented{1}{(if \\spad{m} has the same number of rows as columns) and \\spad{false} otherwise.} \\blankline \\spad{X} square matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]"

--->-->MatrixCategory&((diagonal? ((Boolean) %))): Improper first word in comments: 
--->-->MatrixCategory&((diagonal? ((Boolean) %))): Mismatch: left pren matches right brace
"\\indented{1}{\\spad{diagonal?(m)} returns \\spad{true} if the matrix \\spad{m} is square and} \\indented{1}{diagonal (\\spadignore{i.e.} all entries of \\spad{m} not on the diagonal are zero) and} \\indented{1}{false otherwise.} \\blankline \\spad{X} diagonal? matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]"

--->-->MatrixCategory&((symmetric? ((Boolean) %))): Improper first word in comments: 
--->-->MatrixCategory&((symmetric? ((Boolean) %))): Mismatch: left pren matches right brace
"\\indented{1}{\\spad{symmetric?(m)} returns \\spad{true} if the matrix \\spad{m} is square and} \\indented{1}{symmetric (\\spadignore{i.e.} \\spad{m[i,j] = m[j,i]} for all \\spad{i} and \\spad{j)} and false} \\indented{1}{otherwise.} \\blankline \\spad{X} symmetric? matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]"

--->-->MatrixCategory&((antisymmetric? ((Boolean) %))): Improper first word in comments: 
--->-->MatrixCategory&((antisymmetric? ((Boolean) %))): Mismatch: left pren matches right brace
"\\indented{1}{\\spad{antisymmetric?(m)} returns \\spad{true} if the matrix \\spad{m} is square and} \\indented{1}{antisymmetric (\\spadignore{i.e.} \\spad{m[i,j] = -m[j,i]} for all \\spad{i} and \\spad{j)}} \\indented{1}{and \\spad{false} otherwise.} \\blankline \\spad{X} antisymmetric? matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]"

--->-->MatrixCategory&((zero (% (NonNegativeInteger) (NonNegativeInteger)))): Improper first word in comments: 
"\\indented{1}{\\spad{zero(m,n)} returns an m-by-n zero matrix.} \\blankline \\spad{X} z:Matrix(INT):=zero(3,3)"

--->-->MatrixCategory&((matrix (% (List (List R))))): Improper first word in comments: 
"\\indented{1}{\\spad{matrix(l)} converts the list of lists \\spad{l} to a matrix, where the} \\indented{1}{list of lists is viewed as a list of the rows of the matrix.} \\blankline \\spad{X} matrix [[1,2,3],[4,5,6],[7,8,9],[1,1,1]]"
--------(matrix (% (NonNegativeInteger) (NonNegativeInteger) (Mapping R (Integer) (Integer))))---------
--->-->MatrixCategory&((matrix (% (NonNegativeInteger) (NonNegativeInteger) (Mapping R (Integer) (Integer))))): Improper first word in comments: 
"\\indented{1}{\\spad{matrix(n,m,f)} constructs an \\spad{n * \\spad{m}} matrix with} \\indented{1}{the \\spad{(i,j)} entry equal to \\spad{f(i,j)}} \\blankline \\spad{X} f(i:INT,j:INT):INT \\spad{==} i+j \\spad{X} matrix(3,4,f)"

--->-->MatrixCategory&((scalarMatrix (% (NonNegativeInteger) R))): Improper first word in comments: 
"\\indented{1}{\\spad{scalarMatrix(n,r)} returns an n-by-n matrix with \\spad{r's} on the} \\indented{1}{diagonal and zeroes elsewhere.} \\blankline \\spad{X} z:Matrix(INT):=scalarMatrix(3,5)"

--->-->MatrixCategory&((diagonalMatrix (% (List R)))): Improper first word in comments: 
"\\indented{1}{\\spad{diagonalMatrix(l)} returns a diagonal matrix with the elements} \\indented{1}{of \\spad{l} on the diagonal.} \\blankline \\spad{X} diagonalMatrix [1,2,3]"

--->-->MatrixCategory&((diagonalMatrix (% (List %)))): Improper first word in comments: 
"\\indented{1}{\\spad{diagonalMatrix([m1,...,mk])} creates a block diagonal matrix} \\indented{1}{M with block matrices m1,...,mk down the diagonal,} \\indented{1}{with 0 block matrices elsewhere.} \\indented{1}{More precisly: if \\spad{ri \\spad{:=} nrows mi}, \\spad{ci \\spad{:=} ncols mi},} \\indented{1}{then \\spad{m} is an (r1+..+rk) by (c1+..+ck) - matrix\\space{2}with entries} \\indented{1}{\\spad{m.i.j = ml.(i-r1-..-r(l-1)).(j-n1-..-n(l-1))}, if} \\indented{1}{\\spad{(r1+..+r(l-1)) < \\spad{i} \\spad{<=} r1+..+rl} and} \\indented{1}{\\spad{(c1+..+c(l-1)) < \\spad{i} \\spad{<=} c1+..+cl},} \\indented{1}{\\spad{m.i.j} = 0\\space{2}otherwise.} \\blankline \\spad{X} diagonalMatrix [matrix [[1,2],[3,4]], matrix [[4,5],[6,7]]]"

--->-->MatrixCategory&((coerce (% Col))): Improper first word in comments: 
"\\indented{1}{\\spad{coerce(col)} converts the column col to a column matrix.} \\blankline \\spad{X} coerce([1,2,3])@Matrix(INT)"

--->-->MatrixCategory&((transpose (% Row))): Improper first word in comments: 
"\\indented{1}{\\spad{transpose(r)} converts the row \\spad{r} to a row matrix.} \\blankline \\spad{X} transpose([1,2,3])@Matrix(INT)"

--->-->MatrixCategory&((transpose (% %))): Improper first word in comments: 
"\\indented{1}{\\spad{transpose(m)} returns the transpose of the matrix \\spad{m.}} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} transpose \\spad{m}"

--->-->MatrixCategory&((squareTop (% %))): Improper first word in comments: 
"\\indented{1}{\\spad{squareTop(m)} returns an n-by-n matrix consisting of the first} \\indented{1}{n rows of the m-by-n matrix \\spad{m.} Error: if} \\indented{1}{\\spad{m < n}.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..2] for \\spad{j} in 1..5] \\spad{X} squareTop \\spad{m}"

--->-->MatrixCategory&((horizConcat (% % %))): Improper first word in comments: 
"\\indented{1}{\\spad{horizConcat(x,y)} horizontally concatenates two matrices with} \\indented{1}{an equal number of rows. The entries of \\spad{y} appear to the right} \\indented{1}{of the entries of x.\\space{2}Error: if the matrices} \\indented{1}{do not have the same number of rows.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} horizConcat(m,m)"

--->-->MatrixCategory&((vertConcat (% % %))): Improper first word in comments: 
"\\indented{1}{\\spad{vertConcat(x,y)} vertically concatenates two matrices with an} \\indented{1}{equal number of columns. The entries of \\spad{y} appear below} \\indented{1}{of the entries of x.\\space{2}Error: if the matrices} \\indented{1}{do not have the same number of columns.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} vertConcat(m,m)"

--->-->MatrixCategory&((listOfLists ((List (List R)) %))): Improper first word in comments: 
"\\indented{1}{\\spad{listOfLists(m)} returns the rows of the matrix \\spad{m} as a list} \\indented{1}{of lists.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} listOfLists \\spad{m}"

--->-->MatrixCategory&((elt (% % (List (Integer)) (List (Integer))))): Improper first word in comments: 
"\\indented{1}{\\spad{elt(x,rowList,colList)} returns an m-by-n matrix consisting} \\indented{1}{of elements of \\spad{x,} where \\spad{m = \\# rowList} and \\spad{n = \\# colList}} \\indented{1}{If \\spad{rowList = [i<1>,i<2>,...,i<m>]} and \\spad{colList \\spad{=}} \\indented{1}{[j<1>,j<2>,...,j<n>]}, then the \\spad{(k,l)}th entry of} \\indented{1}{\\spad{elt(x,rowList,colList)} is \\spad{x(i<k>,j<l>)}.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} elt(m,3,3)"

--->-->MatrixCategory&((setelt (% % (List (Integer)) (List (Integer)) %))): Improper first word in comments: 
"\\indented{1}{\\spad{setelt(x,rowList,colList,y)} destructively alters the matrix \\spad{x.}} \\indented{1}{If \\spad{y} is \\spad{m}-by-\\spad{n}, \\spad{rowList = [i<1>,i<2>,...,i<m>]}} \\indented{1}{and \\spad{colList = [j<1>,j<2>,...,j<n>]}, then \\spad{x(i<k>,j<l>)}} \\indented{1}{is set to \\spad{y(k,l)} for \\spad{k = 1,...,m} and \\spad{l = 1,...,n}} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} setelt(m,3,3,10)"

--->-->MatrixCategory&((swapRows! (% % (Integer) (Integer)))): Improper first word in comments: 
"\\indented{1}{\\spad{swapRows!(m,i,j)} interchanges the \\spad{i}th and \\spad{j}th} \\indented{1}{rows of \\spad{m.} This destructively alters the matrix.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} swapRows!(m,2,4)"

--->-->MatrixCategory&((swapColumns! (% % (Integer) (Integer)))): Improper first word in comments: 
"\\indented{1}{\\spad{swapColumns!(m,i,j)} interchanges the \\spad{i}th and \\spad{j}th} \\indented{1}{columns of \\spad{m.} This destructively alters the matrix.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} swapColumns!(m,2,4)"

--->-->MatrixCategory&((subMatrix (% % (Integer) (Integer) (Integer) (Integer)))): Improper first word in comments: 
"\\indented{1}{\\spad{subMatrix(x,i1,i2,j1,j2)} extracts the submatrix} \\indented{1}{\\spad{[x(i,j)]} where the index \\spad{i} ranges from \\spad{i1} to \\spad{i2}} \\indented{1}{and the index \\spad{j} ranges from \\spad{j1} to \\spad{j2}.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} subMatrix(m,1,3,2,4)"

--->-->MatrixCategory&((setsubMatrix! (% % (Integer) (Integer) %))): Improper first word in comments: 
"\\indented{1}{\\spad{setsubMatrix(x,i1,j1,y)} destructively alters the} \\indented{1}{matrix \\spad{x.} Here \\spad{x(i,j)} is set to \\spad{y(i-i1+1,j-j1+1)} for} \\indented{1}{\\spad{i = i1,...,i1-1+nrows \\spad{y}} and \\spad{j = j1,...,j1-1+ncols y}.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} setsubMatrix!(m,2,2,matrix [[3,3],[3,3]])"

--->-->MatrixCategory&((+ (% % %))): Improper first word in comments: 
"\\indented{1}{\\spad{x + \\spad{y}} is the sum of the matrices \\spad{x} and \\spad{y.}} \\indented{1}{Error: if the dimensions are incompatible.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} \\spad{m+m}"

--->-->MatrixCategory&((- (% % %))): Improper first word in comments: 
"\\indented{1}{\\spad{x - \\spad{y}} is the difference of the matrices \\spad{x} and \\spad{y.}} \\indented{1}{Error: if the dimensions are incompatible.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} \\spad{m-m}"

--->-->MatrixCategory&((- (% %))): Improper first word in comments: 
"\\indented{1}{\\spad{-x} returns the negative of the matrix \\spad{x.}} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} \\spad{-m}"

--->-->MatrixCategory&((* (% % %))): Improper first word in comments: 
"\\indented{1}{\\spad{x * \\spad{y}} is the product of the matrices \\spad{x} and \\spad{y.}} \\indented{1}{Error: if the dimensions are incompatible.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} \\spad{m*m}"

--->-->MatrixCategory&((* (% R %))): Improper first word in comments: 
"\\indented{1}{\\spad{r*x} is the left scalar multiple of the scalar \\spad{r} and the} \\indented{1}{matrix \\spad{x.}} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} 1/3*m"

--->-->MatrixCategory&((* (% % R))): Improper first word in comments: 
"\\indented{1}{\\spad{x * \\spad{r}} is the right scalar multiple of the scalar \\spad{r} and the} \\indented{1}{matrix \\spad{x.}} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} \\spad{m*1/3}"

--->-->MatrixCategory&((* (% (Integer) %))): Improper first word in comments: 
"\\indented{1}{\\spad{n * \\spad{x}} is an integer multiple.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} 3*m"

--->-->MatrixCategory&((* (Col % Col))): Improper first word in comments: 
"\\indented{1}{\\spad{x * \\spad{c}} is the product of the matrix \\spad{x} and the column vector \\spad{c.}} \\indented{1}{Error: if the dimensions are incompatible.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} c:=coerce([1,2,3,4,5])@Matrix(INT) \\spad{X} \\spad{m*c}"

--->-->MatrixCategory&((* (Row Row %))): Improper first word in comments: 
"\\indented{1}{\\spad{r * \\spad{x}} is the product of the row vector \\spad{r} and the matrix \\spad{x.}} \\indented{1}{Error: if the dimensions are incompatible.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} r:=transpose([1,2,3,4,5])@Matrix(INT) \\spad{X} \\spad{r*m}"

--->-->MatrixCategory&((** (% % (NonNegativeInteger)))): Improper first word in comments: 
"\\indented{1}{\\spad{x \\spad{**} \\spad{n}} computes a non-negative integral power of the matrix \\spad{x.}} \\indented{1}{Error: if the matrix is not square.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} \\spad{m**3}"

--->-->MatrixCategory&((exquo ((Union % failed) % R))): Improper first word in comments: 
"\\indented{1}{\\spad{exquo(m,r)} computes the exact quotient of the elements} \\indented{1}{of \\spad{m} by \\spad{r,} returning \\axiom{\"failed\"} if this is not possible.} \\blankline \\spad{X} m:=matrix [[2**i for \\spad{i} in 2..4] for \\spad{j} in 1..5] \\spad{X} exquo(m,2)"

--->-->MatrixCategory&((/ (% % R))): Improper first word in comments: 
"\\indented{1}{\\spad{m/r} divides the elements of \\spad{m} by \\spad{r.} Error: if \\spad{r = 0}.} \\blankline \\spad{X} m:=matrix [[2**i for \\spad{i} in 2..4] for \\spad{j} in 1..5] \\spad{X} \\spad{m/4}"

--->-->MatrixCategory&((rowEchelon (% %))): Improper first word in comments: 
"\\indented{1}{\\spad{rowEchelon(m)} returns the row echelon form of the matrix \\spad{m.}} \\blankline \\spad{X} rowEchelon matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]"

--->-->MatrixCategory&((columnSpace ((List Col) %))): Improper first word in comments: 
"\\indented{1}{\\spad{columnSpace(m)} returns a sublist of columns of the matrix \\spad{m}} \\indented{1}{forming a basis of its column space} \\blankline \\spad{X} columnSpace matrix [[1,2,3],[4,5,6],[7,8,9],[1,1,1]]"

--->-->MatrixCategory&((rank ((NonNegativeInteger) %))): Improper first word in comments: 
"\\indented{1}{\\spad{rank(m)} returns the rank of the matrix \\spad{m.}} \\blankline \\spad{X} rank matrix [[1,2,3],[4,5,6],[7,8,9]]"

--->-->MatrixCategory&((nullity ((NonNegativeInteger) %))): Improper first word in comments: 
"\\indented{1}{\\spad{nullity(m)} returns the nullity of the matrix \\spad{m.} This is} \\indented{1}{the dimension of the null space of the matrix \\spad{m.}} \\blankline \\spad{X} nullity matrix [[1,2,3],[4,5,6],[7,8,9]]"

--->-->MatrixCategory&((nullSpace ((List Col) %))): Improper first word in comments: 
"\\indented{1}{\\spad{nullSpace(m)} returns a basis for the null space of} \\indented{1}{the matrix \\spad{m.}} \\blankline \\spad{X} nullSpace matrix [[1,2,3],[4,5,6],[7,8,9]]"

--->-->MatrixCategory&((determinant (R %))): Improper first word in comments: 
"\\indented{1}{\\spad{determinant(m)} returns the determinant of the matrix \\spad{m.}} \\indented{1}{Error: if the matrix is not square.} \\blankline \\spad{X} determinant matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]"

--->-->MatrixCategory&((minordet (R %))): Improper first word in comments: 
"\\indented{1}{\\spad{minordet(m)} computes the determinant of the matrix \\spad{m} using} \\indented{1}{minors. Error: if the matrix is not square.} \\blankline \\spad{X} minordet matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]"

--->-->MatrixCategory&((pfaffian (R %))): Improper first word in comments: 
"\\indented{1}{\\spad{pfaffian(m)} returns the Pfaffian of the matrix \\spad{m.}} \\indented{1}{Error if the matrix is not antisymmetric} \\blankline \\spad{X} pfaffian [[0,1,0,0],[-1,0,0,0],[0,0,0,1],[0,0,-1,0]]"

--->-->MatrixCategory&((inverse ((Union % failed) %))): Improper first word in comments: 
"\\indented{1}{\\spad{inverse(m)} returns the inverse of the matrix \\spad{m.}} \\indented{1}{If the matrix is not invertible, \"failed\" is returned.} \\indented{1}{Error: if the matrix is not square.} \\blankline \\spad{X} inverse matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]"

--->-->MatrixCategory&((** (% % (Integer)))): Improper first word in comments: 
"\\indented{1}{\\spad{m**n} computes an integral power of the matrix \\spad{m.}} \\indented{1}{Error: if matrix is not square or if the matrix} \\indented{1}{is square but not invertible.} \\blankline \\spad{X} (matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]) \\spad{**} 2"

--->bookvol10.2.pamphlet-->MatrixCategory((square? ((Boolean) %))): Improper first word in comments: 
"\\indented{1}{\\spad{square?(m)} returns \\spad{true} if \\spad{m} is a square matrix} \\indented{1}{(if \\spad{m} has the same number of rows as columns) and \\spad{false} otherwise.} \\blankline \\spad{X} square matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]"

--->bookvol10.2.pamphlet-->MatrixCategory((diagonal? ((Boolean) %))): Improper first word in comments: 
--->bookvol10.2.pamphlet-->MatrixCategory((diagonal? ((Boolean) %))): Mismatch: left pren matches right brace
"\\indented{1}{\\spad{diagonal?(m)} returns \\spad{true} if the matrix \\spad{m} is square and} \\indented{1}{diagonal (\\spadignore{i.e.} all entries of \\spad{m} not on the diagonal are zero) and} \\indented{1}{false otherwise.} \\blankline \\spad{X} diagonal? matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]"

--->bookvol10.2.pamphlet-->MatrixCategory((symmetric? ((Boolean) %))): Improper first word in comments: 
--->bookvol10.2.pamphlet-->MatrixCategory((symmetric? ((Boolean) %))): Mismatch: left pren matches right brace
"\\indented{1}{\\spad{symmetric?(m)} returns \\spad{true} if the matrix \\spad{m} is square and} \\indented{1}{symmetric (\\spadignore{i.e.} \\spad{m[i,j] = m[j,i]} for all \\spad{i} and \\spad{j)} and false} \\indented{1}{otherwise.} \\blankline \\spad{X} symmetric? matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]"

--->bookvol10.2.pamphlet-->MatrixCategory((antisymmetric? ((Boolean) %))): Improper first word in comments: 
--->bookvol10.2.pamphlet-->MatrixCategory((antisymmetric? ((Boolean) %))): Mismatch: left pren matches right brace
"\\indented{1}{\\spad{antisymmetric?(m)} returns \\spad{true} if the matrix \\spad{m} is square and} \\indented{1}{antisymmetric (\\spadignore{i.e.} \\spad{m[i,j] = -m[j,i]} for all \\spad{i} and \\spad{j)}} \\indented{1}{and \\spad{false} otherwise.} \\blankline \\spad{X} antisymmetric? matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]"

--->bookvol10.2.pamphlet-->MatrixCategory((zero (% (NonNegativeInteger) (NonNegativeInteger)))): Improper first word in comments: 
"\\indented{1}{\\spad{zero(m,n)} returns an m-by-n zero matrix.} \\blankline \\spad{X} z:Matrix(INT):=zero(3,3)"

--->bookvol10.2.pamphlet-->MatrixCategory((matrix (% (List (List R))))): Improper first word in comments: 
"\\indented{1}{\\spad{matrix(l)} converts the list of lists \\spad{l} to a matrix, where the} \\indented{1}{list of lists is viewed as a list of the rows of the matrix.} \\blankline \\spad{X} matrix [[1,2,3],[4,5,6],[7,8,9],[1,1,1]]"

--->bookvol10.2.pamphlet-->MatrixCategory((matrix (% (NonNegativeInteger) (NonNegativeInteger) (Mapping R (Integer) (Integer))))): Improper first word in comments: 
"\\indented{1}{\\spad{matrix(n,m,f)} constructs an \\spad{n * \\spad{m}} matrix with} \\indented{1}{the \\spad{(i,j)} entry equal to \\spad{f(i,j)}} \\blankline \\spad{X} f(i:INT,j:INT):INT \\spad{==} i+j \\spad{X} matrix(3,4,f)"

--->bookvol10.2.pamphlet-->MatrixCategory((scalarMatrix (% (NonNegativeInteger) R))): Improper first word in comments: 
"\\indented{1}{\\spad{scalarMatrix(n,r)} returns an n-by-n matrix with \\spad{r's} on the} \\indented{1}{diagonal and zeroes elsewhere.} \\blankline \\spad{X} z:Matrix(INT):=scalarMatrix(3,5)"

--->bookvol10.2.pamphlet-->MatrixCategory((diagonalMatrix (% (List R)))): Improper first word in comments: 
"\\indented{1}{\\spad{diagonalMatrix(l)} returns a diagonal matrix with the elements} \\indented{1}{of \\spad{l} on the diagonal.} \\blankline \\spad{X} diagonalMatrix [1,2,3]"

--->bookvol10.2.pamphlet-->MatrixCategory((diagonalMatrix (% (List %)))): Improper first word in comments: 
"\\indented{1}{\\spad{diagonalMatrix([m1,...,mk])} creates a block diagonal matrix} \\indented{1}{M with block matrices m1,...,mk down the diagonal,} \\indented{1}{with 0 block matrices elsewhere.} \\indented{1}{More precisly: if \\spad{ri \\spad{:=} nrows mi}, \\spad{ci \\spad{:=} ncols mi},} \\indented{1}{then \\spad{m} is an (r1+..+rk) by (c1+..+ck) - matrix\\space{2}with entries} \\indented{1}{\\spad{m.i.j = ml.(i-r1-..-r(l-1)).(j-n1-..-n(l-1))}, if} \\indented{1}{\\spad{(r1+..+r(l-1)) < \\spad{i} \\spad{<=} r1+..+rl} and} \\indented{1}{\\spad{(c1+..+c(l-1)) < \\spad{i} \\spad{<=} c1+..+cl},} \\indented{1}{\\spad{m.i.j} = 0\\space{2}otherwise.} \\blankline \\spad{X} diagonalMatrix [matrix [[1,2],[3,4]], matrix [[4,5],[6,7]]]"

--->bookvol10.2.pamphlet-->MatrixCategory((coerce (% Col))): Improper first word in comments: 
"\\indented{1}{\\spad{coerce(col)} converts the column col to a column matrix.} \\blankline \\spad{X} coerce([1,2,3])@Matrix(INT)"

--->bookvol10.2.pamphlet-->MatrixCategory((transpose (% Row))): Improper first word in comments: 
"\\indented{1}{\\spad{transpose(r)} converts the row \\spad{r} to a row matrix.} \\blankline \\spad{X} transpose([1,2,3])@Matrix(INT)"

--->bookvol10.2.pamphlet-->MatrixCategory((transpose (% %))): Improper first word in comments: 
"\\indented{1}{\\spad{transpose(m)} returns the transpose of the matrix \\spad{m.}} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} transpose \\spad{m}"

--->bookvol10.2.pamphlet-->MatrixCategory((squareTop (% %))): Improper first word in comments: 
"\\indented{1}{\\spad{squareTop(m)} returns an n-by-n matrix consisting of the first} \\indented{1}{n rows of the m-by-n matrix \\spad{m.} Error: if} \\indented{1}{\\spad{m < n}.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..2] for \\spad{j} in 1..5] \\spad{X} squareTop \\spad{m}"

--->bookvol10.2.pamphlet-->MatrixCategory((horizConcat (% % %))): Improper first word in comments: 
"\\indented{1}{\\spad{horizConcat(x,y)} horizontally concatenates two matrices with} \\indented{1}{an equal number of rows. The entries of \\spad{y} appear to the right} \\indented{1}{of the entries of x.\\space{2}Error: if the matrices} \\indented{1}{do not have the same number of rows.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} horizConcat(m,m)"

--->bookvol10.2.pamphlet-->MatrixCategory((vertConcat (% % %))): Improper first word in comments: 
"\\indented{1}{\\spad{vertConcat(x,y)} vertically concatenates two matrices with an} \\indented{1}{equal number of columns. The entries of \\spad{y} appear below} \\indented{1}{of the entries of x.\\space{2}Error: if the matrices} \\indented{1}{do not have the same number of columns.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} vertConcat(m,m)"

--->bookvol10.2.pamphlet-->MatrixCategory((listOfLists ((List (List R)) %))): Improper first word in comments: 
"\\indented{1}{\\spad{listOfLists(m)} returns the rows of the matrix \\spad{m} as a list} \\indented{1}{of lists.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} listOfLists \\spad{m}"

--->bookvol10.2.pamphlet-->MatrixCategory((elt (% % (List (Integer)) (List (Integer))))): Improper first word in comments: 
"\\indented{1}{\\spad{elt(x,rowList,colList)} returns an m-by-n matrix consisting} \\indented{1}{of elements of \\spad{x,} where \\spad{m = \\# rowList} and \\spad{n = \\# colList}} \\indented{1}{If \\spad{rowList = [i<1>,i<2>,...,i<m>]} and \\spad{colList \\spad{=}} \\indented{1}{[j<1>,j<2>,...,j<n>]}, then the \\spad{(k,l)}th entry of} \\indented{1}{\\spad{elt(x,rowList,colList)} is \\spad{x(i<k>,j<l>)}.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} elt(m,3,3)"

--->bookvol10.2.pamphlet-->MatrixCategory((setelt (% % (List (Integer)) (List (Integer)) %))): Improper first word in comments: 
"\\indented{1}{\\spad{setelt(x,rowList,colList,y)} destructively alters the matrix \\spad{x.}} \\indented{1}{If \\spad{y} is \\spad{m}-by-\\spad{n}, \\spad{rowList = [i<1>,i<2>,...,i<m>]}} \\indented{1}{and \\spad{colList = [j<1>,j<2>,...,j<n>]}, then \\spad{x(i<k>,j<l>)}} \\indented{1}{is set to \\spad{y(k,l)} for \\spad{k = 1,...,m} and \\spad{l = 1,...,n}} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} setelt(m,3,3,10)"

--->bookvol10.2.pamphlet-->MatrixCategory((swapRows! (% % (Integer) (Integer)))): Improper first word in comments: 
"\\indented{1}{\\spad{swapRows!(m,i,j)} interchanges the \\spad{i}th and \\spad{j}th} \\indented{1}{rows of \\spad{m.} This destructively alters the matrix.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} swapRows!(m,2,4)"

--->bookvol10.2.pamphlet-->MatrixCategory((swapColumns! (% % (Integer) (Integer)))): Improper first word in comments: 
"\\indented{1}{\\spad{swapColumns!(m,i,j)} interchanges the \\spad{i}th and \\spad{j}th} \\indented{1}{columns of \\spad{m.} This destructively alters the matrix.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} swapColumns!(m,2,4)"

--->bookvol10.2.pamphlet-->MatrixCategory((subMatrix (% % (Integer) (Integer) (Integer) (Integer)))): Improper first word in comments: 
"\\indented{1}{\\spad{subMatrix(x,i1,i2,j1,j2)} extracts the submatrix} \\indented{1}{\\spad{[x(i,j)]} where the index \\spad{i} ranges from \\spad{i1} to \\spad{i2}} \\indented{1}{and the index \\spad{j} ranges from \\spad{j1} to \\spad{j2}.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} subMatrix(m,1,3,2,4)"

--->bookvol10.2.pamphlet-->MatrixCategory((setsubMatrix! (% % (Integer) (Integer) %))): Improper first word in comments: 
"\\indented{1}{\\spad{setsubMatrix(x,i1,j1,y)} destructively alters the} \\indented{1}{matrix \\spad{x.} Here \\spad{x(i,j)} is set to \\spad{y(i-i1+1,j-j1+1)} for} \\indented{1}{\\spad{i = i1,...,i1-1+nrows \\spad{y}} and \\spad{j = j1,...,j1-1+ncols y}.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} setsubMatrix!(m,2,2,matrix [[3,3],[3,3]])"

--->bookvol10.2.pamphlet-->MatrixCategory((+ (% % %))): Improper first word in comments: 
"\\indented{1}{\\spad{x + \\spad{y}} is the sum of the matrices \\spad{x} and \\spad{y.}} \\indented{1}{Error: if the dimensions are incompatible.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} \\spad{m+m}"

--->bookvol10.2.pamphlet-->MatrixCategory((- (% % %))): Improper first word in comments: 
"\\indented{1}{\\spad{x - \\spad{y}} is the difference of the matrices \\spad{x} and \\spad{y.}} \\indented{1}{Error: if the dimensions are incompatible.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} \\spad{m-m}"

--->bookvol10.2.pamphlet-->MatrixCategory((- (% %))): Improper first word in comments: 
"\\indented{1}{\\spad{-x} returns the negative of the matrix \\spad{x.}} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} \\spad{-m}"

--->bookvol10.2.pamphlet-->MatrixCategory((* (% % %))): Improper first word in comments: 
"\\indented{1}{\\spad{x * \\spad{y}} is the product of the matrices \\spad{x} and \\spad{y.}} \\indented{1}{Error: if the dimensions are incompatible.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} \\spad{m*m}"

--->bookvol10.2.pamphlet-->MatrixCategory((* (% R %))): Improper first word in comments: 
"\\indented{1}{\\spad{r*x} is the left scalar multiple of the scalar \\spad{r} and the} \\indented{1}{matrix \\spad{x.}} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} 1/3*m"

--->bookvol10.2.pamphlet-->MatrixCategory((* (% % R))): Improper first word in comments: 
"\\indented{1}{\\spad{x * \\spad{r}} is the right scalar multiple of the scalar \\spad{r} and the} \\indented{1}{matrix \\spad{x.}} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} \\spad{m*1/3}"

--->bookvol10.2.pamphlet-->MatrixCategory((* (% (Integer) %))): Improper first word in comments: 
"\\indented{1}{\\spad{n * \\spad{x}} is an integer multiple.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} 3*m"

--->bookvol10.2.pamphlet-->MatrixCategory((* (Col % Col))): Improper first word in comments: 
"\\indented{1}{\\spad{x * \\spad{c}} is the product of the matrix \\spad{x} and the column vector \\spad{c.}} \\indented{1}{Error: if the dimensions are incompatible.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} c:=coerce([1,2,3,4,5])@Matrix(INT) \\spad{X} \\spad{m*c}"

--->bookvol10.2.pamphlet-->MatrixCategory((* (Row Row %))): Improper first word in comments: 
"\\indented{1}{\\spad{r * \\spad{x}} is the product of the row vector \\spad{r} and the matrix \\spad{x.}} \\indented{1}{Error: if the dimensions are incompatible.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} r:=transpose([1,2,3,4,5])@Matrix(INT) \\spad{X} \\spad{r*m}"

--->bookvol10.2.pamphlet-->MatrixCategory((** (% % (NonNegativeInteger)))): Improper first word in comments: 
"\\indented{1}{\\spad{x \\spad{**} \\spad{n}} computes a non-negative integral power of the matrix \\spad{x.}} \\indented{1}{Error: if the matrix is not square.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} \\spad{m**3}"

--->bookvol10.2.pamphlet-->MatrixCategory((exquo ((Union % failed) % R))): Improper first word in comments: 
"\\indented{1}{\\spad{exquo(m,r)} computes the exact quotient of the elements} \\indented{1}{of \\spad{m} by \\spad{r,} returning \\axiom{\"failed\"} if this is not possible.} \\blankline \\spad{X} m:=matrix [[2**i for \\spad{i} in 2..4] for \\spad{j} in 1..5] \\spad{X} exquo(m,2)"

--->bookvol10.2.pamphlet-->MatrixCategory((/ (% % R))): Improper first word in comments: 
"\\indented{1}{\\spad{m/r} divides the elements of \\spad{m} by \\spad{r.} Error: if \\spad{r = 0}.} \\blankline \\spad{X} m:=matrix [[2**i for \\spad{i} in 2..4] for \\spad{j} in 1..5] \\spad{X} \\spad{m/4}"

--->bookvol10.2.pamphlet-->MatrixCategory((rowEchelon (% %))): Improper first word in comments: 
"\\indented{1}{\\spad{rowEchelon(m)} returns the row echelon form of the matrix \\spad{m.}} \\blankline \\spad{X} rowEchelon matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]"

--->bookvol10.2.pamphlet-->MatrixCategory((columnSpace ((List Col) %))): Improper first word in comments: 
"\\indented{1}{\\spad{columnSpace(m)} returns a sublist of columns of the matrix \\spad{m}} \\indented{1}{forming a basis of its column space} \\blankline \\spad{X} columnSpace matrix [[1,2,3],[4,5,6],[7,8,9],[1,1,1]]"

--->bookvol10.2.pamphlet-->MatrixCategory((rank ((NonNegativeInteger) %))): Improper first word in comments: 
"\\indented{1}{\\spad{rank(m)} returns the rank of the matrix \\spad{m.}} \\blankline \\spad{X} rank matrix [[1,2,3],[4,5,6],[7,8,9]]"

--->bookvol10.2.pamphlet-->MatrixCategory((nullity ((NonNegativeInteger) %))): Improper first word in comments: 
"\\indented{1}{\\spad{nullity(m)} returns the nullity of the matrix \\spad{m.} This is} \\indented{1}{the dimension of the null space of the matrix \\spad{m.}} \\blankline \\spad{X} nullity matrix [[1,2,3],[4,5,6],[7,8,9]]"

--->bookvol10.2.pamphlet-->MatrixCategory((nullSpace ((List Col) %))): Improper first word in comments: 
"\\indented{1}{\\spad{nullSpace(m)} returns a basis for the null space of} \\indented{1}{the matrix \\spad{m.}} \\blankline \\spad{X} nullSpace matrix [[1,2,3],[4,5,6],[7,8,9]]"

--->bookvol10.2.pamphlet-->MatrixCategory((determinant (R %))): Improper first word in comments: 
"\\indented{1}{\\spad{determinant(m)} returns the determinant of the matrix \\spad{m.}} \\indented{1}{Error: if the matrix is not square.} \\blankline \\spad{X} determinant matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]"

--->bookvol10.2.pamphlet-->MatrixCategory((minordet (R %))): Improper first word in comments: 
"\\indented{1}{\\spad{minordet(m)} computes the determinant of the matrix \\spad{m} using} \\indented{1}{minors. Error: if the matrix is not square.} \\blankline \\spad{X} minordet matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]"

--->bookvol10.2.pamphlet-->MatrixCategory((pfaffian (R %))): Improper first word in comments: 
"\\indented{1}{\\spad{pfaffian(m)} returns the Pfaffian of the matrix \\spad{m.}} \\indented{1}{Error if the matrix is not antisymmetric} \\blankline \\spad{X} pfaffian [[0,1,0,0],[-1,0,0,0],[0,0,0,1],[0,0,-1,0]]"

--->bookvol10.2.pamphlet-->MatrixCategory((inverse ((Union % failed) %))): Improper first word in comments: 
"\\indented{1}{\\spad{inverse(m)} returns the inverse of the matrix \\spad{m.}} \\indented{1}{If the matrix is not invertible, \"failed\" is returned.} \\indented{1}{Error: if the matrix is not square.} \\blankline \\spad{X} inverse matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]"

--->bookvol10.2.pamphlet-->MatrixCategory((** (% % (Integer)))): Improper first word in comments: 
"\\indented{1}{\\spad{m**n} computes an integral power of the matrix \\spad{m.}} \\indented{1}{Error: if matrix is not square or if the matrix} \\indented{1}{is square but not invertible.} \\blankline \\spad{X} (matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]) \\spad{**} 2"

=========================================================================
typos 40272:

>compiling POLYVEC.spad to POLYVEC.nrlib

--->-->U32VectorPolynomialOperations((copyfirst ((Void) PA PA (Integer)))): Improper first word in comments: copy_first
"copy_first(v1, \\spad{v2,} \\spad{n)} copies first \\spad{n} elements of \\spad{v2} into \\spad{n} first positions in \\spad{v1.}"

--->-->U32VectorPolynomialOperations((copyslice ((Void) PA PA (Integer) (Integer)))): Improper first word in comments: copy_first
"copy_first(v1, \\spad{v2,} \\spad{m,} \\spad{n)} copies the slice of \\spad{v2} starting at \\spad{m} elements and having \\spad{n} elements into corresponding positions in \\spad{v1.}"

--->-->U32VectorPolynomialOperations((evalat ((Integer) PA (Integer) (Integer) (Integer)))): Improper first word in comments: 
"\\indented{1}{eval_at(v, deg, \\spad{pt,} \\spad{p)} treats \\spad{v} as coefficients of} \\indented{1}{polynomial of degree deg and evaluates the} \\indented{1}{polynomial at point \\spad{pt} modulo \\spad{p}} \\blankline \\spad{X} a:=new(3,1)$U32VEC \\spad{X} \\spad{a.1:=2} \\spad{X} eval_at(a,2,3,1024) \\spad{X} eval_at(a,2,2,8) \\spad{X} eval_at(a,2,3,10)"

--->-->U32VectorPolynomialOperations((vectoraddmul ((Void) PA PA (Integer) (Integer) (Integer) (Integer)))): Improper first word in comments: vector_add_mul
"vector_add_mul(v1, \\spad{v2,} \\spad{m,} \\spad{n,} \\spad{c,} \\spad{p)} sets v1(m), ..., v1(n) to corresponding extries in \\spad{v1} + \\spad{c*v2} modulo \\spad{p.}"

--->-->U32VectorPolynomialOperations((mulbybinomial ((Void) PA (Integer) (Integer)))): Improper first word in comments: mul_by_binomial
"mul_by_binomial(v, \\spad{pt,} \\spad{p)} treats \\spad{v} a polynomial and multiplies in place this polynomial by binomial \\spad{(x} + pt). Highest coefficient of product is ignored."

--->-->U32VectorPolynomialOperations((mulbybinomial ((Void) PA (Integer) (Integer) (Integer)))): Improper first word in comments: mul_by_binomial
"mul_by_binomial(v, deg, \\spad{pt,} \\spad{p)} treats \\spad{v} as coefficients of polynomial of degree deg and multiplies in place this polynomial by binomial \\spad{(x} + pt). Highest coefficient of product is ignored."

--->-->U32VectorPolynomialOperations((mulbyscalar ((Void) PA (Integer) (Integer) (Integer)))): Improper first word in comments: mul_by_scalar
"mul_by_scalar(v, deg, \\spad{c,} \\spad{p)} treats \\spad{v} as coefficients of polynomial of degree deg and multiplies in place this polynomial by scalar \\spad{c}"

--->-->U32VectorPolynomialOperations((truncatedmultiplication (PA PA PA (Integer) (Integer)))): Improper first word in comments: truncated_multiplication
"truncated_multiplication(x, \\spad{y,} \\spad{d,} \\spad{p)} computes x*y truncated after degree \\spad{d}"

--->-->U32VectorPolynomialOperations((truncatedmuladd ((Void) PA PA PA (Integer) (Integer)))): Improper first word in comments: truncated_mul_add
"truncated_mul_add(x, \\spad{y,} \\spad{z,} \\spad{d,} \\spad{p)} adds to \\spad{z} the produce x*y truncated after degree \\spad{d}"

--->-->U32VectorPolynomialOperations((vectorcombination ((Void) PA (Integer) PA (Integer) (Integer) (Integer) (Integer)))): Improper first word in comments: vector_combination
"vector_combination(v1, \\spad{c1,} \\spad{v2,} \\spad{c2,} \\spad{n,} delta, \\spad{p)} replaces first \\spad{n} + 1 entires of \\spad{v1} by corresponding entries of \\spad{c1*v1+c2*x^delta*v2} mod \\spad{p.}"

--->-->U32VectorPolynomialOperations((tomodpa (PA (SparseUnivariatePolynomial (Integer)) (Integer)))): Improper first word in comments: to_mod_pa
"to_mod_pa(s, \\spad{p)} reduces coefficients of polynomial \\spad{s} modulo prime \\spad{p} and converts the result to vector"

--->-->U32VectorPolynomialOperations((extendedgcd ((List PA) PA PA (Integer)))): Improper first word in comments: extended_gcd
"extended_gcd(v1, \\spad{v2,} \\spad{p)} gives \\spad{[g,} \\spad{c1,} \\spad{c2]} such that \\spad{g} is \\spad{gcd(v1, \\spad{v2,} p)}, \\spad{g = \\spad{c1*v1} + c2*v2} and degree(c1) < max(degree(v2) - degree(g), 0) and degree(c2) < max(degree(v1) - degree(g), 1)"

=========================================================================
typos 40271:

>compiling PRIMARR2.spad to PRIMARR2.nrlib

--->bookvol10.4.pamphlet-->PrimitiveArrayFunctions2((scan (VB (Mapping B A B) VA B))): Improper first word in comments: 
"\\indented{1}{scan(f,a,r) successively applies} \\indented{1}{\\spad{reduce(f,x,r)} to more and more leading sub-arrays} \\indented{1}{x of primitive array \\spad{a}.} \\indented{1}{More precisely, if \\spad{a} is \\spad{[a1,a2,...]}, then} \\indented{1}{\\spad{scan(f,a,r)} returns} \\indented{1}{\\spad{[reduce(f,[a1],r),reduce(f,[a1,a2],r),...]}.} \\blankline \\spad{X} T1:=PrimitiveArrayFunctions2(Integer,Integer) \\spad{X} adder(a:Integer,b:Integer):Integer \\spad{==} a+b \\spad{X} scan(adder,[i for \\spad{i} in 1..10],0)$T1"

--->bookvol10.4.pamphlet-->PrimitiveArrayFunctions2((reduce (B (Mapping B A B) VA B))): Improper first word in comments: 
"\\indented{1}{reduce(f,a,r) applies function \\spad{f} to each} \\indented{1}{successive element of the} \\indented{1}{primitive array \\spad{a} and an accumulant initialized to \\spad{r.}} \\indented{1}{For example, \\spad{reduce(_+$Integer,[1,2,3],0)}} \\indented{1}{does \\spad{3+(2+(1+0))}. Note that third argument \\spad{r}} \\indented{1}{may be regarded as the identity element for the function \\spad{f.}} \\blankline \\spad{X} T1:=PrimitiveArrayFunctions2(Integer,Integer) \\spad{X} adder(a:Integer,b:Integer):Integer \\spad{==} a+b \\spad{X} reduce(adder,[i for \\spad{i} in 1..10],0)$T1"

--->bookvol10.4.pamphlet-->PrimitiveArrayFunctions2((map (VB (Mapping B A) VA))): Improper first word in comments: 
"\\indented{1}{map(f,a) applies function \\spad{f} to each member of primitive array} \\indented{1}{\\spad{a} resulting in a new primitive array over a} \\indented{1}{possibly different underlying domain.} \\blankline \\spad{X} T1:=PrimitiveArrayFunctions2(Integer,Integer) \\spad{X} map(x+->x+2,[i for \\spad{i} in 1..10])$T1"

=========================================================================
typos 40270:

>compiling STREAM.spad to STREAM.nrlib

--->bookvol10.3.pamphlet-->Stream((coerce (% (L S)))): Improper first word in comments: 
"\\indented{1}{coerce(l) converts a list \\spad{l} to a stream.} \\blankline \\spad{X} m:=[1,2,3,4,5,6,7,8,9,10,11,12] \\spad{X} coerce(m)@Stream(Integer) \\spad{X} m::Stream(Integer)"

--->bookvol10.3.pamphlet-->Stream((repeating (% (L S)))): Improper first word in comments: 
"\\indented{1}{repeating(l) is a repeating stream whose period is the list \\spad{l.}} \\blankline \\spad{X} m:=repeating([-1,0,1,2,3])"

--->bookvol10.3.pamphlet-->Stream((repeating? (B (L S) %))): Improper first word in comments: 
"\\indented{1}{repeating?(l,s) returns \\spad{true} if a stream \\spad{s} is periodic} \\indented{1}{with period \\spad{l,} and \\spad{false} otherwise.} \\blankline \\spad{X} m:=[1,2,3] \\spad{X} n:=repeating(m) \\spad{X} repeating?(m,n)"

--->bookvol10.3.pamphlet-->Stream((findCycle ((Record (: cycle? B) (: prefix NNI) (: period NNI)) NNI %))): Improper first word in comments: 
"\\indented{1}{findCycle(n,st) determines if st is periodic within \\spad{n.}} \\blankline \\spad{X} m:=[1,2,3] \\spad{X} n:=repeating(m) \\spad{X} findCycle(3,n) \\spad{X} findCycle(2,n)"

--->bookvol10.3.pamphlet-->Stream((cons (% S %))): Improper first word in comments: 
"\\indented{1}{cons(a,s) returns a stream whose \\spad{first} is \\spad{a}} \\indented{1}{and whose \\spad{rest} is \\spad{s.}} \\indented{1}{Note: \\spad{cons(a,s) = concat(a,s)}.} \\blankline \\spad{X} m:=[1,2,3] \\spad{X} n:=repeating(m) \\spad{X} cons(4,n)"

--->bookvol10.3.pamphlet-->Stream((output ((Void) I %))): Improper first word in comments: 
"\\indented{1}{output(n,st) computes and displays the first \\spad{n} entries} \\indented{1}{of st.} \\blankline \\spad{X} m:=[1,2,3] \\spad{X} n:=repeating(m) \\spad{X} output(5,n)"

--->bookvol10.3.pamphlet-->Stream((showAllElements (OUT %))): Improper first word in comments: 
"\\indented{1}{showAllElements(s) creates an output form which displays all} \\indented{1}{computed elements.} \\blankline \\spad{X} m:=[1,2,3,4,5,6,7,8,9,10,11,12] \\spad{X} n:=m::Stream(PositiveInteger) \\spad{X} showAllElements \\spad{n}"

--->bookvol10.3.pamphlet-->Stream((setrest! (% % I %))): Improper first word in comments: 
"\\indented{1}{setrest!(x,n,y) sets rest(x,n) to \\spad{y.} The function will expand} \\indented{1}{cycles if necessary.} \\blankline \\spad{X} p:=[i for \\spad{i} in 1..] \\spad{X} q:=[i for \\spad{i} in 9..] \\spad{X} setrest!(p,4,q) \\spad{X} \\spad{p}"

--->bookvol10.3.pamphlet-->Stream((generate (% (Mapping S)))): Improper first word in comments: 
"\\indented{1}{generate(f) creates an infinite stream all of whose elements are} \\indented{1}{equal to \\spad{f()}.} \\indented{1}{Note: \\spad{generate(f) = [f(),f(),f(),...]}.} \\blankline \\spad{X} f():Integer \\spad{==} 1 \\spad{X} generate(f)"

--->bookvol10.3.pamphlet-->Stream((generate (% (Mapping S S) S))): Improper first word in comments: 
"\\indented{1}{generate(f,x) creates an infinite stream whose first element is} \\indented{1}{x and whose \\spad{n}th element (\\spad{n > 1}) is \\spad{f} applied to the previous} \\indented{1}{element. Note: \\spad{generate(f,x) = [x,f(x),f(f(x)),...]}.} \\blankline \\spad{X} f(x:Integer):Integer \\spad{==} \\spad{x+10} \\spad{X} generate(f,10)"

--->bookvol10.3.pamphlet-->Stream((filterWhile (% (Mapping (Boolean) S) %))): Improper first word in comments: 
"\\indented{1}{filterWhile(p,s) returns \\spad{[x0,x1,...,x(n-1)]} where} \\indented{1}{\\spad{s = [x0,x1,x2,..]} and} \\indented{1}{n is the smallest index such that \\spad{p(xn) = false}.} \\blankline \\spad{X} m:=[i for \\spad{i} in 1..] \\spad{X} f(x:PositiveInteger):Boolean \\spad{==} \\spad{x} < 5 \\spad{X} filterWhile(f,m)"

--->bookvol10.3.pamphlet-->Stream((filterUntil (% (Mapping (Boolean) S) %))): Improper first word in comments: 
"\\indented{1}{filterUntil(p,s) returns \\spad{[x0,x1,...,x(n)]} where} \\indented{1}{\\spad{s = [x0,x1,x2,..]} and} \\indented{1}{n is the smallest index such that \\spad{p(xn) = true}.} \\blankline \\spad{X} m:=[i for \\spad{i} in 1..] \\spad{X} f(x:PositiveInteger):Boolean \\spad{==} \\spad{x} < 5 \\spad{X} filterUntil(f,m)"

=========================================================================
typos 40269:

>compiling TUPLE.spad to TUPLE.nrlib

--->bookvol10.3.pamphlet-->Tuple((coerce (% (PrimitiveArray S)))): Improper first word in comments: 
"\\indented{1}{coerce(a) makes a tuple from primitive array a} \\blankline \\spad{X} t1:PrimitiveArray(Integer):= \\spad{[i} for \\spad{i} in 1..10] \\spad{X} t2:=coerce(t1)$Tuple(Integer)"

--->bookvol10.3.pamphlet-->Tuple((select (S % (NonNegativeInteger)))): Improper first word in comments: 
"\\indented{1}{select(x,n) returns the \\spad{n}-th element of tuple \\spad{x.}} \\indented{1}{tuples are 0-based} \\blankline \\spad{X} t1:PrimitiveArray(Integer):= \\spad{[i} for \\spad{i} in 1..10] \\spad{X} t2:=coerce(t1)$Tuple(Integer) \\spad{X} select(t2,3)"

--->bookvol10.3.pamphlet-->Tuple((length ((NonNegativeInteger) %))): Improper first word in comments: 
"\\indented{1}{length(x) returns the number of elements in tuple \\spad{x}} \\blankline \\spad{X} t1:PrimitiveArray(Integer):= \\spad{[i} for \\spad{i} in 1..10] \\spad{X} t2:=coerce(t1)$Tuple(Integer) \\spad{X} length(t2)"

=========================================================================
typos 40268:

>compiling VECTCAT.spad to VECTCAT.nrlib

--->-->VectorCategory&((cross (% % %))): Improper first word in comments: vectorProduct
"vectorProduct(u,v) constructs the cross product of \\spad{u} and \\spad{v.} Error: if \\spad{u} and \\spad{v} are not of length 3."

--->-->VectorCategory&((length (R %))): Missing left brace
"\\spad{length(v)} computes the sqrt(dot(v,v)), \\spadignore{i.e.} the magnitude"

--->-->VectorCategory&((magnitude (R %))): Missing left brace
"\\spad{magnitude(v)} computes the sqrt(dot(v,v)), \\spadignore{i.e.} the length"

--->-->VectorCategory&(constructor): Missing left brace
"\\spadtype{VectorCategory} represents the type of vector like objects, \\spadignore{i.e.} finite sequences indexed by some finite segment of the integers. The operations available on vectors depend on the structure of the underlying components. Many operations from the component domain are defined for vectors componentwise. It can by assumed that extraction or updating components can be done in constant time."

--->bookvol10.2.pamphlet-->VectorCategory((cross (% % %))): Improper first word in comments: vectorProduct
"vectorProduct(u,v) constructs the cross product of \\spad{u} and \\spad{v.} Error: if \\spad{u} and \\spad{v} are not of length 3."

--->bookvol10.2.pamphlet-->VectorCategory((length (R %))): Missing left brace
"\\spad{length(v)} computes the sqrt(dot(v,v)), \\spadignore{i.e.} the magnitude"

--->bookvol10.2.pamphlet-->VectorCategory((magnitude (R %))): Missing left brace
"\\spad{magnitude(v)} computes the sqrt(dot(v,v)), \\spadignore{i.e.} the length"

--->bookvol10.2.pamphlet-->VectorCategory(constructor): Missing left brace

=========================================================================
typos 40267:

>compiling DFMAT.spad to DFMAT.nrlib

--->bookvol10.3.pamphlet-->DoubleFloatMatrix((qnew (% (Integer) (Integer)))): Improper first word in comments: 
"\\indented{1}{qnew(n, \\spad{m)} creates a new uninitialized \\spad{n} by \\spad{m} matrix.} \\blankline \\spad{X} t1:DFMAT:=qnew(3,4)"

=========================================================================
typos 40266:

>compiling DFVEC.spad to DFVEC.nrlib

--->bookvol10.3.pamphlet-->DoubleFloatVector((qnew (% (Integer)))): Improper first word in comments: 
"\\indented{1}{qnew(n) creates a new uninitialized vector of length \\spad{n.}} \\blankline \\spad{X} t1:DFVEC:=qnew(7)"

=========================================================================
typos 40265:

>compiling LOCPOWC.spad to LOCPOWC.nrlib

--->bookvol10.2.pamphlet-->LocalPowerSeriesCategory((findCoef (K % (Integer)))): Not documented!!!!
--->bookvol10.2.pamphlet-->LocalPowerSeriesCategory((coerce (% SER))): Not documented!!!!
--->bookvol10.2.pamphlet-->LocalPowerSeriesCategory((coerce (SER %))): Not documented!!!!

--->bookvol10.2.pamphlet-->LocalPowerSeriesCategory((orderIfNegative ((Union (Integer) failed) %))): Not documented!!!!
--->bookvol10.2.pamphlet-->LocalPowerSeriesCategory((removeFirstZeroes (% %))): Not documented!!!!
--->bookvol10.2.pamphlet-->LocalPowerSeriesCategory((sbt (% % %))): Not documented!!!!

--->bookvol10.2.pamphlet-->LocalPowerSeriesCategory((printInfo ((Boolean)))): Improper first word in comments: returns
"returns the value of the \\spad{printInfo} flag."
--->bookvol10.2.pamphlet-->LocalPowerSeriesCategory(constructor): Not documented!!!!
--->bookvol10.2.pamphlet-->LocalPowerSeriesCategory(): Missing Description

=========================================================================
typos 40263:

>compiling U8MAT.spad to U8MAT.nrlib

--->-->U8Matrix((qnew (% (Integer) (Integer)))): Improper first word in comments: 
"\\indented{1}{qnew(n, \\spad{m)} creates a new \\spad{n} by \\spad{m} matrix of zeros.} \\blankline \\spad{X} qnew(3,4)$U8Matrix()"

=========================================================================
typos 40262:

>compiling U16MAT.spad to U16MAT.nrlib

--->bookvol10.3.pamphlet-->U16Matrix((qnew (% (Integer) (Integer)))): Improper first word in comments: 
"\\indented{1}{qnew(n, \\spad{m)} creates a new \\spad{n} by \\spad{m} matrix of zeros.} \\blankline \\spad{X} qnew(3,4)$U16Matrix()"

=========================================================================
typos 40261:

>compiling U32MAT.spad to U32MAT.nrlib

--->bookvol10.3.pamphlet-->U32Matrix((qnew (% (Integer) (Integer)))): Improper first word in comments: 
"\\indented{1}{qnew(n, \\spad{m)} creates a new \\spad{n} by \\spad{m} matrix of zeros.} \\blankline \\spad{X} qnew(3,4)$U32Matrix()"

=========================================================================
typos 40260:

>compiling CARTEN.spad to CARTEN.nrlib

--->bookvol10.3.pamphlet-->CartesianTensor((coerce (% (DP dim R)))): Improper first word in comments: 
"\\indented{1}{coerce(v) views a vector as a rank 1 tensor.} \\blankline \\spad{X} v:DirectProduct(2,Integer):=directProduct [3,4] \\spad{X} tv:CartesianTensor(1,2,Integer):=v"

--->bookvol10.3.pamphlet-->CartesianTensor((coerce (% (SM dim R)))): Improper first word in comments: 
"\\indented{1}{coerce(m) views a matrix as a rank 2 tensor.} \\blankline \\spad{X} v:SquareMatrix(2,Integer):=[[1,2],[3,4]] \\spad{X} tv:CartesianTensor(1,2,Integer):=v"

--->bookvol10.3.pamphlet-->CartesianTensor((coerce (% (List R)))): Improper first word in comments: 
"\\indented{1}{coerce([r_1,...,r_dim]) allows tensors to be constructed} \\indented{1}{using lists.} \\blankline \\spad{X} v:=[2,3] \\spad{X} tv:CartesianTensor(1,2,Integer):=v"

--->bookvol10.3.pamphlet-->CartesianTensor((coerce (% (List %)))): Improper first word in comments: 
"\\indented{1}{coerce([t_1,...,t_dim]) allows tensors to be constructed} \\indented{1}{using lists.} \\blankline \\spad{X} v:=[2,3] \\spad{X} tv:CartesianTensor(1,2,Integer):=v \\spad{X} tm:CartesianTensor(1,2,Integer):=[tv,tv]"

--->bookvol10.3.pamphlet-->CartesianTensor((rank (NNI %))): Improper first word in comments: 
"\\indented{1}{rank(t) returns the tensorial rank of \\spad{t} (that is, the} \\indented{1}{number of indices).\\space{2}This is the same as the graded module} \\indented{1}{degree.} \\blankline \\spad{X} CT:=CARTEN(1,2,Integer) \\spad{X} \\spad{t0:CT:=8} \\spad{X} rank \\spad{t0}"

--->bookvol10.3.pamphlet-->CartesianTensor((elt (R %))): Improper first word in comments: 
"\\indented{1}{elt(t) gives the component of a rank 0 tensor.} \\blankline \\spad{X} \\spad{tv:CartesianTensor(1,2,Integer):=8} \\spad{X} elt(tv) \\spad{X} tv[]"

--->bookvol10.3.pamphlet-->CartesianTensor((elt (R % I))): Improper first word in comments: 
"\\indented{1}{elt(t,i) gives a component of a rank 1 tensor.} \\blankline \\spad{X} v:=[2,3] \\spad{X} tv:CartesianTensor(1,2,Integer):=v \\spad{X} elt(tv,2) \\spad{X} tv[2]"

--->bookvol10.3.pamphlet-->CartesianTensor((elt (R % I I))): Improper first word in comments: 
"\\indented{1}{elt(t,i,j) gives a component of a rank 2 tensor.} \\blankline \\spad{X} v:=[2,3] \\spad{X} tv:CartesianTensor(1,2,Integer):=v \\spad{X} tm:CartesianTensor(1,2,Integer):=[tv,tv] \\spad{X} elt(tm,2,2) \\spad{X} tm[2,2]"

--->bookvol10.3.pamphlet-->CartesianTensor((elt (R % I I I))): Improper first word in comments: 
"\\indented{1}{elt(t,i,j,k) gives a component of a rank 3 tensor.} \\blankline \\spad{X} v:=[2,3] \\spad{X} tv:CartesianTensor(1,2,Integer):=v \\spad{X} tm:CartesianTensor(1,2,Integer):=[tv,tv] \\spad{X} tn:CartesianTensor(1,2,Integer):=[tm,tm] \\spad{X} elt(tn,2,2,2) \\spad{X} tn[2,2,2]"

--->bookvol10.3.pamphlet-->CartesianTensor((elt (R % I I I I))): Improper first word in comments: 
"\\indented{1}{elt(t,i,j,k,l) gives a component of a rank 4 tensor.} \\blankline \\spad{X} v:=[2,3] \\spad{X} tv:CartesianTensor(1,2,Integer):=v \\spad{X} tm:CartesianTensor(1,2,Integer):=[tv,tv] \\spad{X} tn:CartesianTensor(1,2,Integer):=[tm,tm] \\spad{X} tp:CartesianTensor(1,2,Integer):=[tn,tn] \\spad{X} elt(tp,2,2,2,2) \\spad{X} tp[2,2,2,2]"

--->bookvol10.3.pamphlet-->CartesianTensor((elt (R % (List I)))): Improper first word in comments: 
"\\indented{1}{elt(t,[i1,...,iN]) gives a component of a rank \\spad{N} tensor.} \\blankline \\spad{X} v:=[2,3] \\spad{X} tv:CartesianTensor(1,2,Integer):=v \\spad{X} tm:CartesianTensor(1,2,Integer):=[tv,tv] \\spad{X} tn:CartesianTensor(1,2,Integer):=[tm,tm] \\spad{X} tp:CartesianTensor(1,2,Integer):=[tn,tn] \\spad{X} tq:CartesianTensor(1,2,Integer):=[tp,tp] \\spad{X} elt(tq,[2,2,2,2,2])"

--->bookvol10.3.pamphlet-->CartesianTensor((product (% % %))): Improper first word in comments: 
"\\indented{1}{product(s,t) is the outer product of the tensors \\spad{s} and \\spad{t.}} \\indented{1}{For example, if \\spad{r = product(s,t)} for rank 2 tensors} \\indented{1}{s and \\spad{t,} then \\spad{r} is a rank 4 tensor given \\spad{by}} \\indented{5}{\\spad{r(i,j,k,l) = s(i,j)*t(k,l)}.} \\blankline \\spad{X} m:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]] \\spad{X} Tm:CartesianTensor(1,2,Integer):=m \\spad{X} n:SquareMatrix(2,Integer):=matrix [[2,3],[0,1]] \\spad{X} Tn:CartesianTensor(1,2,Integer):=n \\spad{X} Tmn:=product(Tm,Tn)"

--->bookvol10.3.pamphlet-->CartesianTensor((* (% % %))): Improper first word in comments: 
"\\indented{1}{s*t is the inner product of the tensors \\spad{s} and \\spad{t} which contracts} \\indented{1}{the last index of \\spad{s} with the first index of \\spad{t,} that is,} \\indented{5}{\\spad{t*s = contract(t,rank \\spad{t,} \\spad{s,} 1)}} \\indented{5}{\\spad{t*s = sum(k=1..N, t[i1,..,iN,k]*s[k,j1,..,jM])}} \\indented{1}{This is compatible with the use of \\spad{M*v} to denote} \\indented{1}{the matrix-vector inner product.} \\blankline \\spad{X} m:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]] \\spad{X} Tm:CartesianTensor(1,2,Integer):=m \\spad{X} v:DirectProduct(2,Integer):=directProduct [3,4] \\spad{X} Tv:CartesianTensor(1,2,Integer):=v \\spad{X} Tm*Tv"

--->bookvol10.3.pamphlet-->CartesianTensor((contract (% % (Integer) % (Integer)))): Improper first word in comments: 
"\\indented{1}{contract(t,i,s,j) is the inner product of tenors \\spad{s} and \\spad{t}} \\indented{1}{which sums along the \\spad{k1}-th index of} \\indented{1}{t and the \\spad{k2}-th index of \\spad{s.}} \\indented{1}{For example, if \\spad{r = contract(s,2,t,1)} for rank 3 tensors} \\indented{1}{rank 3 tensors \\spad{s} and \\spad{t}, then \\spad{r} is} \\indented{1}{the rank 4 \\spad{(= 3 + 3 - 2)} tensor\\space{2}given \\spad{by}} \\indented{5}{\\spad{r(i,j,k,l) = sum(h=1..dim,s(i,h,j)*t(h,k,l))}.} \\blankline \\spad{X} m:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]] \\spad{X} Tm:CartesianTensor(1,2,Integer):=m \\spad{X} v:DirectProduct(2,Integer):=directProduct [3,4] \\spad{X} Tv:CartesianTensor(1,2,Integer):=v \\spad{X} Tmv:=contract(Tm,2,Tv,1)"

--->bookvol10.3.pamphlet-->CartesianTensor((contract (% % (Integer) (Integer)))): Improper first word in comments: 
"\\indented{1}{contract(t,i,j) is the contraction of tensor \\spad{t} which} \\indented{1}{sums along the \\spad{i}-th and \\spad{j}-th indices.} \\indented{1}{For example,\\space{2}if} \\indented{1}{\\spad{r = contract(t,1,3)} for a rank 4 tensor \\spad{t,} then} \\indented{1}{\\spad{r} is the rank 2 \\spad{(= 4 - 2)} tensor given \\spad{by}} \\indented{5}{\\spad{r(i,j) = sum(h=1..dim,t(h,i,h,j))}.} \\blankline \\spad{X} m:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]] \\spad{X} Tm:CartesianTensor(1,2,Integer):=m \\spad{X} v:DirectProduct(2,Integer):=directProduct [3,4] \\spad{X} Tv:CartesianTensor(1,2,Integer):=v \\spad{X} Tmv:=contract(Tm,2,1)"

--->bookvol10.3.pamphlet-->CartesianTensor((transpose (% %))): Improper first word in comments: 
"\\indented{1}{transpose(t) exchanges the first and last indices of \\spad{t.}} \\indented{1}{For example, if \\spad{r = transpose(t)} for a rank 4} \\indented{1}{tensor \\spad{t,} then \\spad{r} is the rank 4 tensor given \\spad{by}} \\indented{5}{\\spad{r(i,j,k,l) = t(l,j,k,i)}.} \\blankline \\spad{X} m:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]] \\spad{X} Tm:CartesianTensor(1,2,Integer):=m \\spad{X} transpose(Tm)"

--->bookvol10.3.pamphlet-->CartesianTensor((transpose (% % (Integer) (Integer)))): Improper first word in comments: 
"\\indented{1}{transpose(t,i,j) exchanges the \\spad{i}-th and \\spad{j}-th} \\indented{1}{indices of \\spad{t.} For example, if \\spad{r = transpose(t,2,3)}} \\indented{1}{for a rank 4 tensor \\spad{t,} then \\spad{r} is the rank 4 tensor} \\indented{1}{given \\spad{by}} \\indented{5}{\\spad{r(i,j,k,l) = t(i,k,j,l)}.} \\blankline \\spad{X} m:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]] \\spad{X} tm:CartesianTensor(1,2,Integer):=m \\spad{X} tn:CartesianTensor(1,2,Integer):=[tm,tm] \\spad{X} transpose(tn,1,2)"

--->bookvol10.3.pamphlet-->CartesianTensor((reindex (% % (List (Integer))))): Improper first word in comments: 
"\\indented{1}{reindex(t,[i1,...,idim]) permutes the indices of \\spad{t.}} \\indented{1}{For example, if \\spad{r = reindex(t, [4,1,2,3])}} \\indented{1}{for a rank 4 tensor \\spad{t,}} \\indented{1}{then \\spad{r} is the rank for tensor given \\spad{by}} \\indented{5}{\\spad{r(i,j,k,l) = t(l,i,j,k)}.} \\blankline \\spad{X} n:SquareMatrix(2,Integer):=matrix [[2,3],[0,1]] \\spad{X} tn:CartesianTensor(1,2,Integer):=n \\spad{X} p:=product(tn,tn) \\spad{X} reindex(p,[4,3,2,1])"

--->bookvol10.3.pamphlet-->CartesianTensor((kroneckerDelta (%))): Improper first word in comments: 
"\\indented{1}{kroneckerDelta() is the rank 2 tensor defined \\spad{by}} \\indented{4}{\\spad{kroneckerDelta()(i,j)}} \\indented{7}{\\spad{= 1\\space{2}if \\spad{i} = \\spad{j}}} \\indented{7}{\\spad{= 0 if\\space{2}i \\spad{\\^=} \\spad{j}}} \\blankline \\spad{X} delta:CartesianTensor(1,2,Integer):=kroneckerDelta()"

--->bookvol10.3.pamphlet-->CartesianTensor((leviCivitaSymbol (%))): Improper first word in comments: 
"\\indented{1}{leviCivitaSymbol() is the rank \\spad{dim} tensor defined \\spad{by}} \\indented{1}{\\spad{leviCivitaSymbol()(i1,...idim) = +1/0/-1}} \\indented{1}{if \\spad{i1,...,idim} is an even/is nota /is an odd permutation} \\indented{1}{of \\spad{minix,...,minix+dim-1}.} \\blankline \\spad{X} lcs:CartesianTensor(1,2,Integer):=leviCivitaSymbol()"

--->bookvol10.3.pamphlet-->CartesianTensor((ravel ((List R) %))): Improper first word in comments: 
"\\indented{1}{ravel(t) produces a list of components from a tensor such that} \\indented{3}{\\spad{unravel(ravel(t)) = t}.} \\blankline \\spad{X} n:SquareMatrix(2,Integer):=matrix [[2,3],[0,1]] \\spad{X} tn:CartesianTensor(1,2,Integer):=n \\spad{X} ravel \\spad{tn}"

=========================================================================
typos 40259:

>compiling DBASE.spad to DBASE.nrlib

--->bookvol10.3.pamphlet-->Database((- (% % %))): Missing left brace
"\\spad{db1-db2} returns the difference of databases \\spad{db1} and \\spad{db2} \\spadignore{i.e.} consisting of elements in \\spad{db1} but not in \\spad{db2}"


=========================================================================
typos 40257:

>compiling DIRPCAT.spad to DIRPCAT.nrlib
 
--->-->DirectProductCategory&(): Spurious comments: \spad{y*r} multiplies each component of the vector \spad{y} by the element \spad{r.}

--------constructor---------
--->bookvol10.2.pamphlet-->DirectProductCategory(): Spurious comments: \spad{y*r} multiplies each component of the vector \spad{y} by the element \spad{r.}

=========================================================================
typos 40253:

>compiling FAXF.spad to FAXF.nrlib

--->-->FiniteAlgebraicExtensionField&((normalElement ($))): Missing left brace
"\\spad{normalElement()} returns a element, normal over the ground field \\spad{F,} \\spadignore{i.e.} \\spad{a**(q**i), 0 \\spad{<=} \\spad{i} < extensionDegree()} is an F-basis, where \\spad{q = size()\\$F}. At the first call, the element is computed by \\spadfunFrom{createNormalElement}{FiniteAlgebraicExtensionField} then cached in a global variable. On subsequent calls, the element is retrieved by referencing the global variable."

--->-->FiniteAlgebraicExtensionField&((normal? ((Boolean) $))): Missing left brace
"\\spad{normal?(a)} tests whether the element \\spad{a} is normal over the ground field \\spad{F,} \\spadignore{i.e.} \\spad{a**(q**i), 0 \\spad{<=} \\spad{i} \\spad{<=} extensionDegree()-1} is an F-basis, where \\spad{q = size()\\$F}. Implementation according to Lidl/Niederreiter: Theorem 2.39."

--->-->FiniteAlgebraicExtensionField&((linearAssociatedExp ($ $ (SparseUnivariatePolynomial F)))): Missing left brace
"\\spad{linearAssociatedExp(a,f)} is linear over \\spad{F,} \\spadignore{i.e.} for elements a from \\spad{\\$,} \\spad{c,d} form \\spad{F} and \\spad{f,g} univariate polynomials over \\spad{F} we have \\spadfun{linearAssociatedExp}(a,cf+dg) equals \\spad{c} times \\spadfun{linearAssociatedExp}(a,f) plus \\spad{d} times \\spadfun{linearAssociatedExp}(a,g). Therefore \\spadfun{linearAssociatedExp} is defined completely by its action on monomials from F[X]: \\spadfun{linearAssociatedExp}(a,monomial(1,k)\\$SUP(F)) is defined to be \\spadfun{Frobenius}(a,k) which is a**(q**k), where q=size()\\$F."

--->-->FiniteAlgebraicExtensionField&(constructor): Missing left brace
"FiniteAlgebraicExtensionField \\spad{F} is the category of fields which are finite algebraic extensions of the field \\spad{F.} If \\spad{F} is finite then any finite algebraic extension of \\spad{F} is finite, too. Let \\spad{K} be a finite algebraic extension of the finite field \\spad{F.} The exponentiation of elements of \\spad{K} defines a Z-module structure on the multiplicative group of \\spad{K.} The additive group of \\spad{K} becomes a module over the ring of polynomials over \\spad{F} via the operation \\spadfun{linearAssociatedExp}(a:K,f:SparseUnivariatePolynomial \\spad{F)} which is linear over \\spad{F,} \\spadignore{i.e.} for elements a from \\spad{K,} \\spad{c,d} from \\spad{F} and \\spad{f,g} univariate polynomials over \\spad{F} we have \\spadfun{linearAssociatedExp}(a,cf+dg) equals \\spad{c} times \\spadfun{linearAssociatedExp}(a,f) plus \\spad{d} times \\spadfun{linearAssociatedExp}(a,g). Therefore \\spadfun{linearAssociatedExp} is defined completely by its action on monomials from F[X]: \\spadfun{linearAssociatedExp}(a,monomial(1,k)\\$SUP(F)) is defined to be \\spadfun{Frobenius}(a,k) which is a**(q**k) where q=size()\\$F. The operations order and discreteLog associated with the multiplicative exponentiation have additive analogues associated to the operation \\spadfun{linearAssociatedExp}. These are the functions \\spadfun{linearAssociatedOrder} and \\spadfun{linearAssociatedLog}, respectively."

--->bookvol10.2.pamphlet-->FiniteAlgebraicExtensionField((normalElement ($))): Missing left brace
"\\spad{normalElement()} returns a element, normal over the ground field \\spad{F,} \\spadignore{i.e.} \\spad{a**(q**i), 0 \\spad{<=} \\spad{i} < extensionDegree()} is an F-basis, where \\spad{q = size()\\$F}. At the first call, the element is computed by \\spadfunFrom{createNormalElement}{FiniteAlgebraicExtensionField} then cached in a global variable. On subsequent calls, the element is retrieved by referencing the global variable."

--->bookvol10.2.pamphlet-->FiniteAlgebraicExtensionField((normal? ((Boolean) $))): Missing left brace
"\\spad{normal?(a)} tests whether the element \\spad{a} is normal over the ground field \\spad{F,} \\spadignore{i.e.} \\spad{a**(q**i), 0 \\spad{<=} \\spad{i} \\spad{<=} extensionDegree()-1} is an F-basis, where \\spad{q = size()\\$F}. Implementation according to Lidl/Niederreiter: Theorem 2.39."

--->bookvol10.2.pamphlet-->FiniteAlgebraicExtensionField((linearAssociatedExp ($ $ (SparseUnivariatePolynomial F)))): Missing left brace
"\\spad{linearAssociatedExp(a,f)} is linear over \\spad{F,} \\spadignore{i.e.} for elements a from \\spad{\\$,} \\spad{c,d} form \\spad{F} and \\spad{f,g} univariate polynomials over \\spad{F} we have \\spadfun{linearAssociatedExp}(a,cf+dg) equals \\spad{c} times \\spadfun{linearAssociatedExp}(a,f) plus \\spad{d} times \\spadfun{linearAssociatedExp}(a,g). Therefore \\spadfun{linearAssociatedExp} is defined completely by its action on monomials from F[X]: \\spadfun{linearAssociatedExp}(a,monomial(1,k)\\$SUP(F)) is defined to be \\spadfun{Frobenius}(a,k) which is a**(q**k), where q=size()\\$F."

--->bookvol10.2.pamphlet-->FiniteAlgebraicExtensionField(constructor): Missing left brace
"FiniteAlgebraicExtensionField \\spad{F} is the category of fields which are finite algebraic extensions of the field \\spad{F.} If \\spad{F} is finite then any finite algebraic extension of \\spad{F} is finite, too. Let \\spad{K} be a finite algebraic extension of the finite field \\spad{F.} The exponentiation of elements of \\spad{K} defines a Z-module structure on the multiplicative group of \\spad{K.} The additive group of \\spad{K} becomes a module over the ring of polynomials over \\spad{F} via the operation \\spadfun{linearAssociatedExp}(a:K,f:SparseUnivariatePolynomial \\spad{F)} which is linear over \\spad{F,} \\spadignore{i.e.} for elements a from \\spad{K,} \\spad{c,d} from \\spad{F} and \\spad{f,g} univariate polynomials over \\spad{F} we have \\spadfun{linearAssociatedExp}(a,cf+dg) equals \\spad{c} times \\spadfun{linearAssociatedExp}(a,f) plus \\spad{d} times \\spadfun{linearAssociatedExp}(a,g). Therefore \\spadfun{linearAssociatedExp} is defined completely by its action on monomials from F[X]: \\spadfun{linearAssociatedExp}(a,monomial(1,k)\\$SUP(F)) is defined to be \\spadfun{Frobenius}(a,k) which is a**(q**k) where q=size()\\$F. The operations order and discreteLog associated with the multiplicative exponentiation have additive analogues associated to the operation \\spadfun{linearAssociatedExp}. These are the functions \\spadfun{linearAssociatedOrder} and \\spadfun{linearAssociatedLog}, respectively."

=========================================================================
typos 40252:

>compiling FFPOLY2.spad to FFPOLY2.nrlib

--->bookvol10.4.pamphlet-->FiniteFieldPolynomialPackage2((rootOfIrreduciblePoly (F (SUP GF)))): Missing left brace
"\\spad{rootOfIrreduciblePoly(f)} computes one root of the monic, irreducible polynomial \\spad{f,} which degree must divide the extension degree of \\spad{F} over \\spad{GF,} \\spadignore{i.e.} \\spad{f} splits into linear factors over \\spad{F.}"

--->bookvol10.4.pamphlet-->FiniteFieldPolynomialPackage2(constructor): Missing left brace
"FiniteFieldPolynomialPackage2(F,GF) exports some functions concerning finite fields, which depend on a finite field \\spad{GF} and an algebraic extension \\spad{F} of \\spad{GF,} \\spadignore{e.g.} a zero of a polynomial over \\spad{GF} in \\spad{F.}"

=========================================================================
typos 40250:

>compiling GRAY.spad to GRAY.nrlib

--->bookvol10.4.pamphlet-->GrayCode((nextSubsetGray ((V (V I)) (V (V I)) PI))): Missing left brace
"\\spad{nextSubsetGray(ww,n)} returns a vector \\spad{vv} whose components have the following meanings:\\br vv.1: a vector of length \\spad{n} whose entries are 0 or 1. This can be interpreted as a code for a subset of the set 1,...,n; \\spad{vv.1} differs from \\spad{ww.1} by exactly one entry;\\br \\spad{vv.2.1} is the number of the entry of \\spad{vv.1} which will be changed next time;\\br \\spad{vv.2.1} = \\spad{n+1} means that \\spad{vv.1} is the last subset; trying to compute nextSubsetGray(vv) if \\spad{vv.2.1} = \\spad{n+1} will produce an error!\\br \\blankline The other components of \\spad{vv.2} are needed to compute nextSubsetGray efficiently. Note that this is an implementation of [Williamson, Topic II, 3.54, \\spad{p.} 112] for the special case \\spad{r1} = \\spad{r2} = \\spad{...} = \\spad{rn} = 2; Note that nextSubsetGray produces a side-effect, \\spadignore{i.e.} nextSubsetGray(vv) and \\spad{vv} \\spad{:=} nextSubsetGray(vv) will have the same effect."

=========================================================================
typos 40249:

>compiling IRSN.spad to IRSN.nrlib

--->bookvol10.4.pamphlet-->IrrRepSymNatPackage(constructor): Missing left brace
--->bookvol10.4.pamphlet-->IrrRepSymNatPackage(constructor): Missing left brace
"IrrRepSymNatPackage contains functions for computing the ordinary irreducible representations of symmetric groups on \\spad{n} letters {1,2,...,n} in Young's natural form and their dimensions. These representations can be labelled by number partitions of \\spad{n,} \\spadignore{i.e.} a weakly decreasing sequence of integers summing up to \\spad{n,} \\spadignore{e.g.} [3,3,3,1] labels an irreducible representation for \\spad{n} equals 10. Note that whenever a \\spadtype{List Integer} appears in a signature, a partition required."

=========================================================================
typos 40248:

>compiling LOP.spad to LOP.nrlib

--->bookvol10.4.pamphlet-->LinesOpPack((rowEchWoZeroLinesWOVectorise ((Matrix K) (Matrix K)))): Not documented!!!!
--->bookvol10.4.pamphlet-->LinesOpPack((rowEchWoZeroLines ((Matrix K) (Matrix K)))): Not documented!!!!

--->bookvol10.4.pamphlet-->LinesOpPack((reduceRow ((List (List K)) (List (List K))))): Improper initial operator in comments: :
"reduceRow: if the input is considered as a matrix, the output would be the row reduction matrix. It's almost the rowEchelon form except that no permution of lines is performed."

=========================================================================
typos 40247:

>compiling MHROWRED.spad to MHROWRED.nrlib
 
--->bookvol10.4.pamphlet-->ModularHermitianRowReduction((normalizedDivide ((Record (: quotient R) (: remainder R)) R R))): Missing left brace
"\\spad{normalizedDivide(n,d)} returns a normalized quotient and remainder such that consistently unique representatives for the residue class are chosen, \\spadignore{e.g.} positive remainders"

=========================================================================
typos 40246:

>compiling PERMAN.spad to PERMAN.nrlib
 
--->bookvol10.4.pamphlet-->Permanent((commutative (attribute *))): Not documented!!!!

=========================================================================
typos 40244:

>compiling REP2.spad to REP2.nrlib
 
--->bookvol10.4.pamphlet-->RepresentationPackage2((areEquivalent? ((M R) (L (M R)) (L (M R)) B I))): Mismatch: left pren matches right brace
"\\spad{areEquivalent?(aG0,aG1,randomelements,numberOfTries)} tests whether the two lists of matrices, all assumed of same square shape, can be simultaneously conjugated by a non-singular matrix. If these matrices represent the same group generators, the representations are equivalent. The algorithm tries \\spad{numberOfTries} times to create elements in the generated algebras in the same fashion. If their ranks differ, they are not equivalent. If an isomorphism is assumed, then the kernel of an element of the first algebra is mapped to the kernel of the corresponding element in the second algebra. Now consider the one-dimensional ones. If they generate the whole space (\\spadignore{e.g.} irreducibility \\spad{!)} we use standardBasisOfCyclicSubmodule to create the only possible transition matrix. The method checks whether the matrix conjugates all corresponding matrices from aGi. The way to choose the singular matrices is as in meatAxe. If the two representations are equivalent, this routine returns the transformation matrix \\spad{TM} with aG0.i * \\spad{TM} = \\spad{TM} * aG1.i for all i. If the representations are not equivalent, a small 0-matrix is returned. Note that the case with different sets of group generators cannot be handled."

--->bookvol10.4.pamphlet-->RepresentationPackage2(constructor): Missing left brace
--->bookvol10.4.pamphlet-->RepresentationPackage2(constructor): Missing left brace
"\\spad{RepresentationPackage2} provides functions for working with modular representations of finite groups and algebra. The routines in this package are created, using ideas of \\spad{R.} Parker, (the meat-Axe) to get smaller representations from bigger ones, \\spadignore{i.e.} finding sub- and factormodules, or to show, that such the representations are irreducible. Note that most functions are randomized functions of Las Vegas type \\spadignore{i.e.} every answer is correct, but with small probability the algorithm fails to get an answer."

=========================================================================
typos 40242:

>compiling ASP24.spad to ASP24.nrlib
 
--->bookvol10.3.pamphlet-->Asp24((coerce ($ FEXPR))): (coerce ($ FEXPR)) has varying indentation levels


=========================================================================
typos 40241:

>compiling AXSERV.spad to AXSERV.nrlib
 
--->bookvol10.4.pamphlet-->AxiomServer((axServer ((Void) (Integer) (Mapping (Void) (SExpression))))): Not documented!!!!
--->bookvol10.4.pamphlet-->AxiomServer((multiServ ((Void) (SExpression)))): Not documented!!!!
--->bookvol10.4.pamphlet-->AxiomServer((getDatabase ((String) (String) (String)))): Not documented!!!!

=========================================================================
typos 40240:

>compiling BINARY.spad to BINARY.nrlib

--->bookvol10.3.pamphlet-->BinaryExpansion((binary (% (Fraction (Integer))))): Improper first word in comments: 
"\\indented{1}{binary(r) converts a rational number to a binary expansion.} \\blankline \\spad{X} binary(22/7)"

=========================================================================
typos 40239:

>compiling CONTFRAC.spad to CONTFRAC.nrlib
 
--->bookvol10.3.pamphlet-->ContinuedFraction((reducedForm (% %))): Missing left brace
"\\spad{reducedForm(x)} puts the continued fraction \\spadvar{x} in reduced form, \\spadignore{i.e.} the function returns an equivalent continued fraction of the form \\spad{continuedFraction(b0,[1,1,1,...],[b1,b2,b3,...])}."

--->bookvol10.3.pamphlet-->ContinuedFraction(constructor): Mismatch: left pren matches right brace
"\\spadtype{ContinuedFraction} implements general continued fractions. This version is not restricted to simple, finite fractions and uses the \\spadtype{Stream} as a representation. The arithmetic functions assume that the approximants alternate below/above the convergence point. This is enforced by ensuring the partial numerators and partial denominators are greater than 0 in the Euclidean domain view of \\spad{R} (\\spadignore{i.e.} \\spad{sizeLess?(0, x)})."

=========================================================================
typos 40237:

>compiling EQ.spad to EQ.nrlib

--->bookvol10.3.pamphlet-->Equation(constructor): Missing left brace
"Equations as mathematical objects. All properties of the basis domain, \\spadignore{e.g.} being an abelian group are carried over the equation domain, by performing the structural operations on the left and on the right hand side."

=========================================================================
typos 40236:

>compiling EXP3D.spad to EXP3D.nrlib

--->bookvol10.4.pamphlet-->Export3D((writeObj ((Void) (SubSpace 3 (DoubleFloat)) (String)))): Improper first word in comments: writes
"writes 3D SubSpace to a file in Wavefront (.OBJ) format"
--->bookvol10.4.pamphlet-->Export3D(constructor): Not documented!!!!
--->bookvol10.4.pamphlet-->Export3D(): Missing Description

=========================================================================
typos 40230:

>compiling FFCG.spad to FFCG.nrlib

--->bookvol10.3.pamphlet-->FiniteFieldCyclicGroup(constructor): Missing left brace
"FiniteFieldCyclicGroup(p,n) implements a finite field extension of degee \\spad{n} over the prime field with \\spad{p} elements. Its elements are represented by powers of a primitive element, \\spadignore{i.e.} a generator of the multiplicative (cyclic) group. As primitive element we choose the root of the extension polynomial, which is created by createPrimitivePoly from \\spadtype{FiniteFieldPolynomialPackage}. The Zech logarithms are stored in a table of size half of the field size, and use \\spadtype{SingleInteger} for representing field elements, hence, there are restrictions on the size of the field."

=========================================================================
typos 40229:

>compiling FFCGX.spad to FFCGX.nrlib

--->bookvol10.3.pamphlet-->FiniteFieldCyclicGroupExtension(constructor): Missing left brace
"FiniteFieldCyclicGroupExtension(GF,n) implements a extension of degree \\spad{n} over the ground field \\spad{GF.} Its elements are represented by powers of a primitive element, \\spadignore{i.e.} a generator of the multiplicative (cyclic) group. As primitive element we choose the root of the extension polynomial, which is created by createPrimitivePoly from \\spadtype{FiniteFieldPolynomialPackage}. Zech logarithms are stored in a table of size half of the field size, and use \\spadtype{SingleInteger} for representing field elements, hence, there are restrictions on the size of the field."

=========================================================================
typos 40228:

>compiling FFFG.spad to FFFG.nrlib

--->bookvol10.4.pamphlet-->FractionFreeFastGaussian((fffg ((Matrix (SUP D)) (List D) cFunction (List (NonNegativeInteger))))): Missing left brace
"\\spad{fffg} is the general algorithm as proposed by Beckermann and Labahn. \\blankline The first argument is the list of c_{i,i}. These are the only values of \\spad{C} explicitely needed in \\spad{fffg}. \\blankline The second argument \\spad{c,} computes c_k(M), \\spadignore{i.e.} c_k(.) is the dual basis of the vector space \\spad{V,} but also knows about the special multiplication rule as descibed in Equation (2). Note that the information about \\spad{f} is therefore encoded in \\spad{c.} \\blankline The third argument is the vector of degree bounds \\spad{n,} as introduced in Definition 2.1. In particular, the sum of the entries is the order of the Mahler system computed."

--->bookvol10.4.pamphlet-->FractionFreeFastGaussian((generalCoefficient (D CoeffAction (Vector V) (NonNegativeInteger) (Vector (SUP D))))): Missing left brace
"\\spad{generalCoefficient(action, \\spad{f,} \\spad{k,} \\spad{p)}} gives the coefficient of \\spad{x^k} in p(z)\\dot f(x), where the \\spad{action} of \\spad{z^l} on a polynomial in \\spad{x} is given by action, \\spadignore{i.e.} action(k, \\spad{l,} \\spad{f)} should return the coefficient of \\spad{x^k} in \\spad{z^l} f(x)."

--->bookvol10.4.pamphlet-->FractionFreeFastGaussian((DiffAction (D (NonNegativeInteger) (NonNegativeInteger) V))): Missing left brace
"\\spad{DiffAction(k, \\spad{l,} \\spad{g)}} gives the coefficient of \\spad{x^k} in \\spad{z^l} g(x), where z*(a+b*x+c*x^2+d*x^3+...) = (a*x+b*x^2+c*x^3+...), \\spadignore{i.e.} multiplication with \\spad{x.}"

=========================================================================
typos 40227:

>compiling FFNB.spad to FFNB.nrlib

--->bookvol10.3.pamphlet-->FiniteFieldNormalBasis(constructor): Missing left brace
"FiniteFieldNormalBasis(p,n) implements a finite extension field of degree \\spad{n} over the prime field with \\spad{p} elements. The elements are represented by coordinate vectors with respect to a normal basis, \\spadignore{i.e.} a basis consisting of the conjugates (q-powers) of an element, in this case called normal element. This is chosen as a root of the extension polynomial created by createNormalPoly"

=========================================================================
typos 40226:

>compiling FFNBX.spad to FFNBX.nrlib

--->bookvol10.3.pamphlet-->FiniteFieldNormalBasisExtension(constructor): Missing left brace
"FiniteFieldNormalBasisExtensionByPolynomial(GF,n) implements a finite extension field of degree \\spad{n} over the ground field \\spad{GF.} The elements are represented by coordinate vectors with respect to a normal basis, \\spadignore{i.e.} a basis consisting of the conjugates (q-powers) of an element, in this case called normal element. This is chosen as a root of the extension polynomial, created by createNormalPoly from \\spadtype{FiniteFieldPolynomialPackage}"

=========================================================================
typos 40225:

>compiling FFPOLY.spad to FFPOLY.nrlib

--->bookvol10.4.pamphlet-->FiniteFieldPolynomialPackage((primitive? ((Boolean) SUP))): Missing left brace
"\\spad{primitive?(f)} tests whether the polynomial \\spad{f} over a finite field is primitive, \\spadignore{i.e.} all its roots are primitive."

--->bookvol10.4.pamphlet-->FiniteFieldPolynomialPackage((normal? ((Boolean) SUP))): Missing left brace
"\\spad{normal?(f)} tests whether the polynomial \\spad{f} over a finite field is normal, \\spadignore{i.e.} its roots are linearly independent over the field."

--->bookvol10.4.pamphlet-->FiniteFieldPolynomialPackage((leastAffineMultiple (SUP SUP))): Missing left brace
"\\spad{leastAffineMultiple(f)} computes the least affine polynomial which is divisible by the polynomial \\spad{f} over the finite field \\spad{GF,} \\spadignore{i.e.} a polynomial whose exponents are 0 or a power of \\spad{q,} the size of \\spad{GF.}"

=========================================================================
typos 40224:

>compiling FFSQFR.spad to FFSQFR.nrlib

--->bookvol10.4.pamphlet-->FiniteFieldSquareFreeDecomposition((Musser ((Factored PolK) PolK))): Not documented!!!!
--->bookvol10.4.pamphlet-->FiniteFieldSquareFreeDecomposition((Yun ((Factored PolK) PolK))): Not documented!!!!

=========================================================================
typos 40223:

>compiling FGLMICPK.spad to FGLMICPK.nrlib

--->bookvol10.4.pamphlet-->FGLMIfCanPackage(constructor): Mismatch: left pren matches right brace
"This is just an interface between several packages and domains. The goal is to compute lexicographical Groebner bases of sets of polynomial with type \\spadtype{Polynomial \\spad{R}} by the FGLM algorithm if this is possible (\\spadignore{i.e.} if the input system generates a zero-dimensional ideal)."

=========================================================================
typos 40222:

>compiling FINAALG.spad to FINAALG.nrlib

--->-->FiniteRankNonAssociativeAlgebra&((antiAssociative? ((Boolean)))): Missing left brace
"\\spad{antiAssociative?()} tests if multiplication in algebra is anti-associative, \\spadignore{i.e.} \\spad{(a*b)*c + a*(b*c) = 0} for all \\spad{a},b,c in the algebra."

--->-->FiniteRankNonAssociativeAlgebra&((lieAdmissible? ((Boolean)))): Missing left brace
"\\spad{lieAdmissible?()} tests if the algebra defined by the commutators is a Lie algebra, \\spadignore{i.e.} satisfies the Jacobi identity. The property of anticommutativity follows from definition."

--->-->FiniteRankNonAssociativeAlgebra&((jordanAdmissible? ((Boolean)))): Missing left brace
"\\spad{jordanAdmissible?()} tests if 2 is invertible in the coefficient domain and the multiplication defined by \\spad{(1/2)(a*b+b*a)} determines a Jordan algebra, \\spadignore{i.e.} satisfies the Jordan identity. The property of \\spadatt{commutative(\"*\")} follows from by definition."

--->-->FiniteRankNonAssociativeAlgebra&((associatorDependence ((List (Vector R))))): Missing left brace
"\\spad{associatorDependence()} looks for the associator identities, \\spadignore{i.e.} finds a basis of the solutions of the linear combinations of the six permutations of \\spad{associator(a,b,c)} which yield 0, for all \\spad{a},b,c in the algebra. The order of the permutations is \\spad{123 231 312 132 321 213}."

--->bookvol10.2.pamphlet-->FiniteRankNonAssociativeAlgebra((antiAssociative? ((Boolean)))): Missing left brace
"\\spad{antiAssociative?()} tests if multiplication in algebra is anti-associative, \\spadignore{i.e.} \\spad{(a*b)*c + a*(b*c) = 0} for all \\spad{a},b,c in the algebra."

--->bookvol10.2.pamphlet-->FiniteRankNonAssociativeAlgebra((lieAdmissible? ((Boolean)))): Missing left brace
"\\spad{lieAdmissible?()} tests if the algebra defined by the commutators is a Lie algebra, \\spadignore{i.e.} satisfies the Jacobi identity. The property of anticommutativity follows from definition."

--->bookvol10.2.pamphlet-->FiniteRankNonAssociativeAlgebra((jordanAdmissible? ((Boolean)))): Missing left brace
"\\spad{jordanAdmissible?()} tests if 2 is invertible in the coefficient domain and the multiplication defined by \\spad{(1/2)(a*b+b*a)} determines a Jordan algebra, \\spadignore{i.e.} satisfies the Jordan identity. The property of \\spadatt{commutative(\"*\")} follows from by definition."

--->bookvol10.2.pamphlet-->FiniteRankNonAssociativeAlgebra((associatorDependence ((List (Vector R))))): Missing left brace
"\\spad{associatorDependence()} looks for the associator identities, \\spadignore{i.e.} finds a basis of the solutions of the linear combinations of the six permutations of \\spad{associator(a,b,c)} which yield 0, for all \\spad{a},b,c in the algebra. The order of the permutations is \\spad{123 231 312 132 321 213}."

=========================================================================
typos 40221:

>compiling FFF.spad to FFF.nrlib

--->bookvol10.4.pamphlet-->FiniteFieldFunctions((createZechTable (ARR SUP))): Missing left brace
"\\spad{createZechTable(f)} generates a Zech logarithm table for the cyclic group representation of a extension of the ground field by the primitive polynomial f(x), \\spadignore{i.e.} \\spad{Z(i)}, defined by x**Z(i) = 1+x**i is stored at index i. This is needed in particular to perform addition of field elements in finite fields represented in this way. See \\spadtype{FFCGP}, \\spadtype{FFCGX}."

--->bookvol10.4.pamphlet-->FiniteFieldFunctions(constructor): Missing left brace
"FiniteFieldFunctions(GF) is a package with functions concerning finite extension fields of the finite ground field \\spad{GF,} \\spadignore{e.g.} Zech logarithms."

=========================================================================
nonextend 40218:

>compiling GENEEZ.spad to GENEEZ.nrlib
 
--------(testModulus ((Boolean) R (L BP)))---------
--->bookvol10.4.pamphlet-->GenExEuclid((testModulus ((Boolean) R (L BP)))): Missing left brace
"\\spad{testModulus(p,lp)} returns \\spad{true} if the the prime \\spad{p} is valid for the list of polynomials \\spad{lp,} \\spadignore{i.e.} preserves the degree and they remain relatively prime."

=========================================================================
typos 40217:

>compiling GALPOLYU.spad to GALPOLYU.nrlib

--->bookvol10.4.pamphlet-->GaloisGroupPolynomialUtilities((monic? ((Boolean) UP))): Mismatch: left pren matches right brace
"\\spad{monic?(p)} tests if \\spad{p} is monic (\\spadignore{i.e.} leading coefficient equal to 1)."

--->bookvol10.4.pamphlet-->GaloisGroupPolynomialUtilities((degreePartition ((Multiset N) (Factored UP)))): Mismatch: left pren matches right brace
"\\spad{degreePartition(f)} returns the degree partition (\\spadignore{i.e.} the multiset of the degrees of the irreducible factors) of the polynomial \\spad{f.}"

=========================================================================
typos 40216:

>compiling GB.spad to GB.nrlib

--->bookvol10.4.pamphlet-->GroebnerPackage((groebner ((List Dpol) (List Dpol)))): Improper first word in comments: 
"\\indented{1}{groebner(lp) computes a groebner basis for a polynomial ideal} \\indented{1}{generated by the list of polynomials lp.} \\blankline \\spad{X} s1:DMP([w,p,z,t,s,b],FRAC(INT)):= 45*p + 35*s - 165*b - 36 \\spad{X} s2:DMP([w,p,z,t,s,b],FRAC(INT)):= 35*p + 40*z + 25*t - 27*s \\spad{X} s3:DMP([w,p,z,t,s,b],FRAC(INT)):= 15*w + 25*p*s + 30*z - 18*t - 165*b**2 \\spad{X} s4:DMP([w,p,z,t,s,b],FRAC(INT)):= -9*w + 15*p*t + 20*z*s \\spad{X} s5:DMP([w,p,z,t,s,b],FRAC(INT)):= \\spad{w*p} + 2*z*t - 11*b**3 \\spad{X} s6:DMP([w,p,z,t,s,b],FRAC(INT)):= 99*w - 11*b*s + 3*b**2 \\spad{X} s7:DMP([w,p,z,t,s,b],FRAC(INT)):= \\spad{b**2} + 33/50*b + 2673/10000 \\spad{X} sn7:=[s1,s2,s3,s4,s5,s6,s7] \\spad{X} groebner(sn7)"

--->bookvol10.4.pamphlet-->GroebnerPackage((groebner ((List Dpol) (List Dpol) (String)))): Improper first word in comments: 
"\\indented{1}{groebner(lp, infoflag) computes a groebner basis} \\indented{1}{for a polynomial ideal} \\indented{1}{generated by the list of polynomials lp.} \\indented{1}{Argument infoflag is used to get information on the computation.} \\indented{1}{If infoflag is \"info\", then summary information} \\indented{1}{is displayed for each s-polynomial generated.} \\indented{1}{If infoflag is \"redcrit\", the reduced critical pairs are displayed.} \\indented{1}{If infoflag is any other string,} \\indented{1}{no information is printed during computation.} \\blankline \\spad{X} s1:DMP([w,p,z,t,s,b],FRAC(INT)):= 45*p + 35*s - 165*b - 36 \\spad{X} s2:DMP([w,p,z,t,s,b],FRAC(INT)):= 35*p + 40*z + 25*t - 27*s \\spad{X} s3:DMP([w,p,z,t,s,b],FRAC(INT)):= 15*w + 25*p*s + 30*z - 18*t - 165*b**2 \\spad{X} s4:DMP([w,p,z,t,s,b],FRAC(INT)):= -9*w + 15*p*t + 20*z*s \\spad{X} s5:DMP([w,p,z,t,s,b],FRAC(INT)):= \\spad{w*p} + 2*z*t - 11*b**3 \\spad{X} s6:DMP([w,p,z,t,s,b],FRAC(INT)):= 99*w - 11*b*s + 3*b**2 \\spad{X} s7:DMP([w,p,z,t,s,b],FRAC(INT)):= \\spad{b**2} + 33/50*b + 2673/10000 \\spad{X} sn7:=[s1,s2,s3,s4,s5,s6,s7] \\spad{X} groebner(sn7,\"info\") \\spad{X} groebner(sn7,\"redcrit\")"

--->bookvol10.4.pamphlet-->GroebnerPackage((groebner ((List Dpol) (List Dpol) (String) (String)))): Improper first word in comments: 
"\\indented{1}{groebner(lp, \"info\", \"redcrit\") computes a groebner basis} \\indented{1}{for a polynomial ideal generated by the list of polynomials lp,} \\indented{1}{displaying both a summary of the critical pairs considered (\"info\")} \\indented{1}{and the result of reducing each critical pair (\"redcrit\").} \\indented{1}{If the second or third arguments have any other string value,} \\indented{1}{the indicated information is suppressed.} \\blankline \\spad{X} s1:DMP([w,p,z,t,s,b],FRAC(INT)):= 45*p + 35*s - 165*b - 36 \\spad{X} s2:DMP([w,p,z,t,s,b],FRAC(INT)):= 35*p + 40*z + 25*t - 27*s \\spad{X} s3:DMP([w,p,z,t,s,b],FRAC(INT)):= 15*w + 25*p*s + 30*z - 18*t - 165*b**2 \\spad{X} s4:DMP([w,p,z,t,s,b],FRAC(INT)):= -9*w + 15*p*t + 20*z*s \\spad{X} s5:DMP([w,p,z,t,s,b],FRAC(INT)):= \\spad{w*p} + 2*z*t - 11*b**3 \\spad{X} s6:DMP([w,p,z,t,s,b],FRAC(INT)):= 99*w - 11*b*s + 3*b**2 \\spad{X} s7:DMP([w,p,z,t,s,b],FRAC(INT)):= \\spad{b**2} + 33/50*b + 2673/10000 \\spad{X} sn7:=[s1,s2,s3,s4,s5,s6,s7] \\spad{X} groebner(sn7,\"info\",\"redcrit\")"

=========================================================================
typos 40215:

>compiling GBEUCLID.spad to GBEUCLID.nrlib

--->bookvol10.4.pamphlet-->EuclideanGroebnerBasisPackage((euclideanGroebner ((List Dpol) (List Dpol)))): Improper first word in comments: 
"\\indented{1}{euclideanGroebner(lp) computes a groebner basis for a polynomial} \\indented{1}{ideal over a euclidean domain generated by the list of polys lp.} \\blankline \\spad{X} a1:DMP([y,x],INT):= \\spad{(9*x**2} + 5*x - 3)+ \\spad{y*(3*x**2} + 2*x + 1) \\spad{X} a2:DMP([y,x],INT):= \\spad{(6*x**3} - 2*x**2 - 3*x \\spad{+3)} + \\spad{y*(2*x**3} - \\spad{x} - 1) \\spad{X} a3:DMP([y,x],INT):= \\spad{(3*x**3} + 2*x**2) + \\spad{y*(x**3} + x**2) \\spad{X} an:=[a1,a2,a3] \\spad{X} euclideanGroebner(an)"

--->bookvol10.4.pamphlet-->EuclideanGroebnerBasisPackage((euclideanGroebner ((List Dpol) (List Dpol) (String)))): Improper first word in comments: 
"\\indented{1}{euclideanGroebner(lp, infoflag) computes a groebner basis} \\indented{1}{for a polynomial ideal over a euclidean domain} \\indented{1}{generated by the list of polynomials lp.} \\indented{1}{During computation, additional information is printed out} \\indented{1}{if infoflag is given as} \\indented{1}{either \"info\" (for summary information) or} \\indented{1}{\"redcrit\" (for reduced critical pairs)} \\blankline \\spad{X} a1:DMP([y,x],INT):= \\spad{(9*x**2} + 5*x - 3)+ \\spad{y*(3*x**2} + 2*x + 1) \\spad{X} a2:DMP([y,x],INT):= \\spad{(6*x**3} - 2*x**2 - 3*x \\spad{+3)} + \\spad{y*(2*x**3} - \\spad{x} - 1) \\spad{X} a3:DMP([y,x],INT):= \\spad{(3*x**3} + 2*x**2) + \\spad{y*(x**3} + x**2) \\spad{X} an:=[a1,a2,a3] \\spad{X} euclideanGroebner(an,\"redcrit\") \\spad{X} euclideanGroebner(an,\"info\")"

--->bookvol10.4.pamphlet-->EuclideanGroebnerBasisPackage((euclideanGroebner ((List Dpol) (List Dpol) (String) (String)))): Improper first word in comments: 
"\\indented{1}{euclideanGroebner(lp, \"info\", \"redcrit\") computes a groebner basis} \\indented{1}{for a polynomial ideal generated by the list of polynomials lp.} \\indented{1}{If the second argument is \"info\",} \\indented{1}{a summary is given of the critical pairs.} \\indented{1}{If the third argument is \"redcrit\", critical pairs are printed.} \\blankline \\spad{X} a1:DMP([y,x],INT):= \\spad{(9*x**2} + 5*x - 3)+ \\spad{y*(3*x**2} + 2*x + 1) \\spad{X} a2:DMP([y,x],INT):= \\spad{(6*x**3} - 2*x**2 - 3*x \\spad{+3)} + \\spad{y*(2*x**3} - \\spad{x} - 1) \\spad{X} a3:DMP([y,x],INT):= \\spad{(3*x**3} + 2*x**2) + \\spad{y*(x**3} + x**2) \\spad{X} an:=[a1,a2,a3] \\spad{X} euclideanGroebner(an,\"info\",\"redcrit\")"

=========================================================================
typos 40214:

>compiling GBF.spad to GBF.nrlib

--->bookvol10.4.pamphlet-->GroebnerFactorizationPackage((groebnerFactorize ((L (L Dpol)) (L Dpol)))): Improper first word in comments: 
"\\indented{1}{groebnerFactorize(listOfPolys) returns} \\indented{1}{a list of groebner bases. The union of their solutions} \\indented{1}{is the solution of the system of equations given by listOfPolys.} \\indented{1}{At each stage the polynomial \\spad{p} under consideration (either from} \\indented{1}{the given basis or obtained from a reduction of the next S-polynomial)} \\indented{1}{is factorized. For each irreducible factors of \\spad{p,} a} \\indented{1}{new createGroebnerBasis is started} \\indented{1}{doing the usual updates with the factor} \\indented{1}{in place of \\spad{p.}} \\blankline \\spad{X} mfzn : SQMATRIX(6,DMP([x,y,z],Fraction INT)) \\spad{:=} \\spad{++X} [ [0,1,1,1,1,1], [1,0,1,8/3,x,8/3], [1,1,0,1,8/3,y], \\spad{++X} [1,8/3,1,0,1,8/3], [1,x,8/3,1,0,1], [1,8/3,y,8/3,1,0] ] \\spad{X} eq \\spad{:=} determinant mfzn \\spad{X} groebnerFactorize \\spad{++X} [eq,eval(eq, [x,y,z],[y,z,x]), eval(eq,[x,y,z],[z,x,y])]"

--->bookvol10.4.pamphlet-->GroebnerFactorizationPackage(): Spurious comments: factor reduced critpair polynomial

=========================================================================
typos 40212:

>compiling GOSPER.spad to GOSPER.nrlib

--->bookvol10.4.pamphlet-->GosperSummationMethod((coerce (% P))): Not documented!!!!
--->bookvol10.4.pamphlet-->GosperSummationMethod((numer (P %))): Not documented!!!!
--->bookvol10.4.pamphlet-->GosperSummationMethod((denom (P %))): Not documented!!!!

--->bookvol10.4.pamphlet-->GosperSummationMethod((GospersMethod ((Union Q failed) Q V (Mapping V)))): Missing left brace
"\\spad{GospersMethod(b, \\spad{n,} new)} returns a rational function \\spad{rf(n)} such that \\spad{a(n) * rf(n)} is the indefinite sum of \\spad{a(n)} with respect to upward difference on \\spad{n}, \\spadignore{i.e.} \\spad{a(n+1) * rf(n+1) - a(n) * rf(n) = a(n)}, where \\spad{b(n) = a(n)/a(n-1)} is a rational function. Returns \"failed\" if no such rational function \\spad{rf(n)} exists. Note that \\spad{new} is a nullary function returning a new \\spad{V} every time. The condition on \\spad{a(n)} is that \\spad{a(n)/a(n-1)} is a rational function of \\spad{n}."

=========================================================================
typos 40211:

>compiling GRIMAGE.spad to GRIMAGE.nrlib

--->bookvol10.3.pamphlet-->GraphImage((figureUnits (UNITSF (L (L P))))): Not documented!!!!

=========================================================================
typos 40209:

>compiling HEUGCD.spad to HEUGCD.nrlib

--->bookvol10.4.pamphlet-->HeuGcd((gcd (BP (List BP)))): Improper first word in comments: 
"\\indented{1}{gcd([f1,..,fk]) = \\spad{gcd} of the polynomials fi.} \\blankline \\spad{X} gcd([671*671*x^2-1,671*671*x^2+2*671*x+1]) \\spad{X} gcd([7*x^2+1,(7*x^2+1)^2])"

=========================================================================
typos 40208:

>compiling HTMLFORM.spad to HTMLFORM.nrlib

--->bookvol10.3.pamphlet-->HTMLFormat((coerce (S E))): Improper first word in comments: 
"\\indented{1}{coerce(o) changes \\spad{o} in the standard output format to html format.} \\blankline \\spad{X} coerce(sqrt(3+x)::OutputForm)$HTMLFORM"

--->bookvol10.3.pamphlet-->HTMLFormat((coerceS (S E))): Improper first word in comments: 
"\\indented{1}{coerceS(o) changes \\spad{o} in the standard output format to html} \\indented{1}{format and displays formatted result.} \\blankline \\spad{X} coerceS(sqrt(3+x)::OutputForm)$HTMLFORM"

--->bookvol10.3.pamphlet-->HTMLFormat((coerceL (S E))): Improper first word in comments: 
"\\indented{1}{coerceL(o) changes \\spad{o} in the standard output format to html} \\indented{1}{format and displays result as one long string.} \\blankline \\spad{X} coerceL(sqrt(3+x)::OutputForm)$HTMLFORM"

--->bookvol10.3.pamphlet-->HTMLFormat((exprex (S E))): Improper first word in comments: 
"\\indented{1}{exprex(o) coverts \\spadtype{OutputForm} to \\spadtype{String}} \\blankline \\spad{X} exprex(sqrt(3+x)::OutputForm)$HTMLFORM"

--->bookvol10.3.pamphlet-->HTMLFormat((display ((Void) S))): Improper first word in comments: 
"\\indented{1}{display(o) prints the string returned by coerce.} \\blankline \\spad{X} display(coerce(sqrt(3+x)::OutputForm)$HTMLFORM)$HTMLFORM"

=========================================================================
typos 40207:

>compiling IMATLIN.spad to IMATLIN.nrlib

--->bookvol10.4.pamphlet-->InnerMatrixLinearAlgebraFunctions((generalizedInverse (M M))): Missing left brace
"\\spad{generalizedInverse(m)} returns the generalized (Moore--Penrose) inverse of the matrix \\spad{m,} \\spadignore{i.e.} the matrix \\spad{h} such that m*h*m=h, h*m*h=m, \\spad{m*h} and \\spad{h*m} are both symmetric matrices."

=========================================================================
typos 40206:

>compiling INMODGCD.spad to INMODGCD.nrlib

--->bookvol10.4.pamphlet-->InnerModularGcd(constructor): Mismatch: left pren matches right brace
"This file contains the functions for modular \\spad{gcd} algorithm for univariate polynomials with coefficients in a non-trivial euclidean domain (\\spadignore{i.e.} not a field). The package parametrised by the coefficient domain, the polynomial domain, a prime, and a function for choosing the next prime"

=========================================================================
typos 40205:

>compiling INTERGB.spad to INTERGB.nrlib

--->bookvol10.4.pamphlet-->InterfaceGroebnerPackage((groebner ((List R) (List R)))): Not documented!!!!

=========================================================================
typos 40204:

>compiling ISUMP.spad to ISUMP.nrlib

--->bookvol10.4.pamphlet-->InnerPolySum((sum ((Record (: num P) (: den Z)) P V))): Missing left brace
"\\spad{sum(p(n), \\spad{n)}} returns \\spad{P(n)}, the indefinite sum of \\spad{p(n)} with respect to upward difference on \\spad{n,} \\spadignore{i.e.} \\spad{P(n+1) - P(n) = a(n)}."

=========================================================================
typos 40203:

>compiling LAUPOL.spad to LAUPOL.nrlib

--->bookvol10.3.pamphlet-->LaurentPolynomial((leadingCoefficient (R %))): Improper initial operator in comments: is
"leadingCoefficient is not documented"

--->bookvol10.3.pamphlet-->LaurentPolynomial((trailingCoefficient (R %))): Improper initial operator in comments: is
"trailingCoefficient is not documented"

=========================================================================
typos 40202:

>compiling LISYSER.spad to LISYSER.nrlib

--->bookvol10.4.pamphlet-->LinearSystemFromPowerSeriesPackage((finiteSeries2LinSysWOVectorise ((Matrix K) (List PCS) INT))): Not documented!!!!

--->bookvol10.4.pamphlet-->LinearSystemFromPowerSeriesPackage((finiteSeries2Vector ((List K) PCS INT))): Not documented!!!!

=========================================================================
typos 40201:

>compiling MATLIN.spad to MATLIN.nrlib

--->bookvol10.4.pamphlet-->MatrixLinearAlgebraFunctions((adjoint ((Record (: adjMat M) (: detMat R)) M))): Mismatch: left pren matches right brace
"\\spad{adjoint(m)} returns the ajoint matrix of \\spad{m} (\\spadignore{i.e.} the matrix \\spad{n} such that \\spad{m*n} = determinant(m)*id) and the detrminant of \\spad{m.}"

--->bookvol10.4.pamphlet-->MatrixLinearAlgebraFunctions((normalizedDivide ((Record (: quotient R) (: remainder R)) R R))): Missing left brace
"\\spad{normalizedDivide(n,d)} returns a normalized quotient and remainder such that consistently unique representatives for the residue class are chosen, \\spadignore{e.g.} positive remainders"

=========================================================================
typos 40200:

>compiling MDDFACT.spad to MDDFACT.nrlib

--->bookvol10.4.pamphlet-->ModularDistinctDegreeFactorizer((ddFact (UDDList U I))): Missing left brace
"\\spad{ddFact(f,p)} computes a distinct degree factorization of the polynomial \\spad{f} modulo the prime \\spad{p,} \\spadignore{i.e.} such that each factor is a product of irreducibles of the same degrees. The input polynomial \\spad{f} is assumed to be square-free modulo \\spad{p.}"

=========================================================================
typos 40198:

>compiling MLIFT.spad to MLIFT.nrlib

--->bookvol10.4.pamphlet-->MultivariateLifting(constructor): Missing left brace
"This package provides the functions for the multivariate \"lifting\", using an algorithm of Paul Wang. This package will work for every euclidean domain \\spad{R} which has property \\spad{F,} \\spadignore{i.e.} there exists a factor operation in \\spad{R[x]}."

=========================================================================
typos 40197:

>compiling MPRFF.spad to MPRFF.nrlib

--->bookvol10.4.pamphlet-->MPolyCatRationalFunctionFactorizer(constructor): Missing left brace
"This package exports a factor operation for multivariate polynomials with coefficients which are rational functions over some ring \\spad{R} over which we can factor. It is used internally by packages such as primary decomposition which need to work with polynomials with rational function coefficients, \\spadignore{i.e.} themselves fractions of polynomials."

=========================================================================
typos 40196:

>compiling NPCOEF.spad to NPCOEF.nrlib

--->bookvol10.4.pamphlet-->NPCoef(constructor): Missing left brace
"Package for the determination of the coefficients in the lifting process. Used by \\spadtype{MultivariateLifting}. This package will work for every euclidean domain \\spad{R} which has property \\spad{F,} \\spadignore{i.e.} there exists a factor operation in \\spad{R[x]}."

=========================================================================
typos 40194:

>compiling OMSERVER.spad to OMSERVER.nrlib

--->bookvol10.4.pamphlet-->OpenMathServerPackage(constructor): Missing left brace
"\\spadtype{OpenMathServerPackage} provides the necessary operations to run AXIOM as an OpenMath server, reading/writing objects to/from a port. Please note the facilities available here are very basic. The idea is that a user calls \\spadignore{e.g.} \\axiom{Omserve(4000,60)} and then another process sends OpenMath objects to port 4000 and reads the result."

=========================================================================
typos 40193:

>compiling PARAMP.spad to PARAMP.nrlib

--->bookvol10.4.pamphlet-->ParametrizationPackage((parametrize (PCS PolyRing (List PCS)))): Not documented!!!!
--------(parametrize (PCS PolyRing Plc))---------
--------(parametrize (PCS PolyRing PolyRing Plc))---------
--------(parametrize (PCS PolyRing Plc (Integer)))---------

=========================================================================
typos 40192:

>compiling PFORP.spad to PFORP.nrlib

--->bookvol10.4.pamphlet-->PackageForPoly((mapExponents (PolyRing (Mapping E E) PolyRing))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForPoly((degree (NNI PolyRing (Integer)))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForPoly((univariate ((SparseUnivariatePolynomial R) PolyRing))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForPoly((totalDegree (NNI PolyRing))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForPoly((subs1stVar (PolyRing PolyRing PolyRing))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForPoly((subs2ndVar (PolyRing PolyRing PolyRing))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForPoly((subsInVar (PolyRing PolyRing PolyRing (Integer)))): Not documented!!!!

--->bookvol10.4.pamphlet-->PackageForPoly((listVariable ((List PolyRing)))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForPoly((monomials ((List PolyRing) PolyRing))): Not documented!!!!

=========================================================================
typos 40191:

>compiling PFRPAC.spad to PFRPAC.nrlib

--->bookvol10.4.pamphlet-->PartialFractionPackage((partialFraction ((Any) FPR (Symbol)))): Improper first word in comments: 
"\\indented{1}{partialFraction(rf, var) returns the partial fraction decomposition} \\indented{1}{of the rational function \\spad{rf} with respect to the variable var.} \\blankline \\spad{X} a:=x+1/(y+1) \\spad{X} partialFraction(a,y)$PFRPAC(INT)"

=========================================================================
typos 40190:

>compiling PLEQN.spad to PLEQN.nrlib

--->bookvol10.4.pamphlet-->ParametricLinearEquations((inconsistent? ((Boolean) (L GR)))): Improper first word in comments: inconsistant?
"inconsistant?(pl) returns \\spad{true} if the system of equations \\spad{p} = 0 for \\spad{p} in \\spad{pl} is inconsistent. It is assumed that \\spad{pl} is a groebner basis."

--->bookvol10.4.pamphlet-->ParametricLinearEquations((inconsistent? ((Boolean) (L PR)))): Improper first word in comments: inconsistant?
"inconsistant?(pl) returns \\spad{true} if the system of equations \\spad{p} = 0 for \\spad{p} in \\spad{pl} is inconsistent. It is assumed that \\spad{pl} is a groebner basis."

=========================================================================
typos 40189:

>compiling POLYCATQ.spad to POLYCATQ.nrlib

--->bookvol10.4.pamphlet-->PolynomialCategoryQuotientFunctions((coerce (% P))): Not documented!!!!
--->bookvol10.4.pamphlet-->PolynomialCategoryQuotientFunctions((numer (P %))): Not documented!!!!
--->bookvol10.4.pamphlet-->PolynomialCategoryQuotientFunctions((denom (P %))): Not documented!!!!

=========================================================================
typos 40188:

>compiling POLYLIFT.spad to POLYLIFT.nrlib

--->bookvol10.4.pamphlet-->PolynomialCategoryLifting((+ (% % %))): Not documented!!!!
--->bookvol10.4.pamphlet-->PolynomialCategoryLifting((* (% % %))): Not documented!!!!
--->bookvol10.4.pamphlet-->PolynomialCategoryLifting((** (% % (NonNegativeInteger)))): Not documented!!!!

=========================================================================
typos 40187:

>compiling RADIX.spad to RADIX.nrlib

--->bookvol10.3.pamphlet-->RadixExpansion((fractRadix (% (List (Integer)) (List (Integer))))): Missing left brace
"\\spad{fractRadix(pre,cyc)} creates a fractional radix expansion from a list of prefix ragits and a list of cyclic ragits. \\spadignore{e.g.} \\spad{fractRadix([1],[6])} will return \\spad{0.16666666...}."

=========================================================================
typos 40186:

>compiling REALSOLV.spad to REALSOLV.nrlib

--->bookvol10.4.pamphlet-->RealSolvePackage((solve ((L NF) (P RN) NF))): Improper first word in comments: 
"\\indented{1}{solve(p,eps) finds the real zeroes of a} \\indented{1}{univariate rational polynomial \\spad{p} with precision eps.} \\blankline \\spad{X} \\spad{p} \\spad{:=} 4*x^3 - 3*x^2 + 2*x - 4 \\spad{X} solve(p::POLY(FRAC(INT)),0.01)$REALSOLV"

--->bookvol10.4.pamphlet-->RealSolvePackage((solve ((L NF) (P I) NF))): Improper first word in comments: 
"\\indented{1}{solve(p,eps) finds the real zeroes of a univariate} \\indented{1}{integer polynomial \\spad{p} with precision eps.} \\blankline \\spad{X} \\spad{p} \\spad{:=} 4*x^3 - 3*x^2 + 2*x - 4 \\spad{X} solve(p,0.01)$REALSOLV"

--->bookvol10.4.pamphlet-->RealSolvePackage((realSolve ((L (L NF)) (L (P I)) (L SE) NF))): Improper first word in comments: 
"\\indented{1}{realSolve(lp,lv,eps) = compute the list of the real} \\indented{1}{solutions of the list \\spad{lp} of polynomials with integer} \\indented{1}{coefficients with respect to the variables in lv,} \\indented{1}{with precision eps.} \\blankline \\spad{X} \\spad{p1} \\spad{:=} x**2*y*z + \\spad{y*z} \\spad{X} \\spad{p2} \\spad{:=} x**2*y**2*z + \\spad{x} + \\spad{z} \\spad{X} \\spad{p3} \\spad{:=} \\spad{x**2*y**2*z**2} + \\spad{z} + 1 \\spad{X} \\spad{lp} \\spad{:=} [p1, \\spad{p2,} \\spad{p3]} \\spad{X} realSolve(lp,[x,y,z],0.01)"

=========================================================================
typos 40185:

>compiling RF.spad to RF.nrlib

--->bookvol10.4.pamphlet-->RationalFunction((eval (Q Q (List V) (List Q)))): Missing left brace
"\\spad{eval(f, [v1,...,vn], [g1,...,gn])} returns \\spad{f} with each \\spad{vi} replaced by \\spad{gi} in parallel, \\spadignore{i.e.} vi's appearing inside the gi's are not replaced."

--->bookvol10.4.pamphlet-->RationalFunction((eval (Q Q (List (Equation Q))))): Missing left brace
"\\spad{eval(f, \\spad{[v1} = g1,...,vn = gn])} returns \\spad{f} with each \\spad{vi} replaced by \\spad{gi} in parallel, \\spadignore{i.e.} vi's appearing inside the gi's are not replaced. Error: if any \\spad{vi} is not a symbol."

=========================================================================
typos 40184:

>compiling RINTERP.spad to RINTERP.nrlib

--->bookvol10.4.pamphlet-->RationalInterpolation((interpolate ((Fraction (Polynomial F)) (List F) (List F) (NonNegativeInteger) (NonNegativeInteger)))): Not documented!!!!

=========================================================================
typos 40183:

>compiling RMATCAT.spad to RMATCAT.nrlib

--->-->RectangularMatrixCategory&((square? ((Boolean) %))): Mismatch: left pren matches right brace
"\\spad{square?(m)} returns \\spad{true} if \\spad{m} is a square matrix (\\spadignore{i.e.} if \\spad{m} has the same number of rows as columns) and \\spad{false} otherwise."

--->-->RectangularMatrixCategory&((diagonal? ((Boolean) %))): Mismatch: left pren matches right brace
"\\spad{diagonal?(m)} returns \\spad{true} if the matrix \\spad{m} is square and diagonal (\\spadignore{i.e.} all entries of \\spad{m} not on the diagonal are zero) and \\spad{false} otherwise."

--->-->RectangularMatrixCategory&((symmetric? ((Boolean) %))): Mismatch: left pren matches right brace
"\\spad{symmetric?(m)} returns \\spad{true} if the matrix \\spad{m} is square and symmetric (\\spadignore{i.e.} \\spad{m[i,j] = m[j,i]} for all \\spad{i} and \\spad{j)} and \\spad{false} otherwise."

--->-->RectangularMatrixCategory&((antisymmetric? ((Boolean) %))): Mismatch: left pren matches right brace
"\\spad{antisymmetric?(m)} returns \\spad{true} if the matrix \\spad{m} is square and antisymmetric (\\spadignore{i.e.} \\spad{m[i,j] = -m[j,i]} for all \\spad{i} and \\spad{j)} and \\spad{false} otherwise."

--->bookvol10.2.pamphlet-->RectangularMatrixCategory((square? ((Boolean) %))): Mismatch: left pren matches right brace
"\\spad{square?(m)} returns \\spad{true} if \\spad{m} is a square matrix (\\spadignore{i.e.} if \\spad{m} has the same number of rows as columns) and \\spad{false} otherwise."

--->bookvol10.2.pamphlet-->RectangularMatrixCategory((diagonal? ((Boolean) %))): Mismatch: left pren matches right brace
"\\spad{diagonal?(m)} returns \\spad{true} if the matrix \\spad{m} is square and diagonal (\\spadignore{i.e.} all entries of \\spad{m} not on the diagonal are zero) and \\spad{false} otherwise."

--->bookvol10.2.pamphlet-->RectangularMatrixCategory((symmetric? ((Boolean) %))): Mismatch: left pren matches right brace
"\\spad{symmetric?(m)} returns \\spad{true} if the matrix \\spad{m} is square and symmetric (\\spadignore{i.e.} \\spad{m[i,j] = m[j,i]} for all \\spad{i} and \\spad{j)} and \\spad{false} otherwise."

--->bookvol10.2.pamphlet-->RectangularMatrixCategory((antisymmetric? ((Boolean) %))): Mismatch: left pren matches right brace
"\\spad{antisymmetric?(m)} returns \\spad{true} if the matrix \\spad{m} is square and antisymmetric (\\spadignore{i.e.} \\spad{m[i,j] = -m[j,i]} for all \\spad{i} and \\spad{j)} and \\spad{false} otherwise."

=========================================================================
typos 40182:

>compiling SCPKG.spad to SCPKG.nrlib

--->bookvol10.4.pamphlet-->StructuralConstantsPackage((structuralConstants ((V (M R)) (L (M R))))): Missing left brace
"\\spad{structuralConstants(basis)} takes the \\spad{basis} of a matrix algebra, \\spadignore{e.g.} the result of \\spadfun{basisOfCentroid} and calculates the structural constants. Note, that the it is not checked, whether \\spad{basis} really is a \\spad{basis} of a matrix algebra."

=========================================================================
typos 40181:

>compiling SMTS.spad to SMTS.nrlib
 
--->bookvol10.3.pamphlet-->SparseMultivariateTaylorSeries((coefficient (SMP % NNI))): Improper first word in comments: 
"\\indented{1}{\\spad{coefficient(s, \\spad{n)}} gives the terms of total degree \\spad{n.}} \\blankline \\spad{X} xts:=x::TaylorSeries Fraction Integer \\spad{X} t1:=sin(xts) \\spad{X} coefficient(t1,3)"

=========================================================================
typos 40180:

>compiling SOLVEFOR.spad to SOLVEFOR.nrlib
 
--->bookvol10.4.pamphlet-->PolynomialSolveByFormulas((** (% % (Fraction (Integer))))): Not documented!!!!


=========================================================================
typos 40179:

>compiling SPLTREE.spad to SPLTREE.nrlib

--->bookvol10.3.pamphlet-->SplittingTree((construct (% S))): Mismatch: left pren matches right brace
"\\axiom{construct(s)} creates a splitting tree with value (\\spadignore{i.e.} root vertex) given by \\axiom{s} and no children. Thus, if the status of \\axiom{s} is false, \\axiom{[s]} represents the starting point of the evaluation \\axiom{value(s)} under the hypothesis \\axiom{condition(s)}."

--->bookvol10.3.pamphlet-->SplittingTree((construct (% V C (List %)))): Mismatch: left pren matches right brace
"\\axiom{construct(v,t,la)} creates a splitting tree with value (\\spadignore{i.e.} root vertex) given by \\axiom{[v,t]$S} and with \\axiom{la} as children list."

--->bookvol10.3.pamphlet-->SplittingTree((construct (% V C (List S)))): Mismatch: left pren matches right brace
"\\axiom{construct(v,t,ls)} creates a splitting tree with value (\\spadignore{i.e.} root vertex) given by \\axiom{[v,t]$S} and with children list given by \\axiom{[[s]$% for \\spad{s} in ls]}."

--->bookvol10.3.pamphlet-->SplittingTree((construct (% V C V (List C)))): Mismatch: left pren matches right brace
"\\axiom{construct(v1,t,v2,lt)} creates a splitting tree with value (\\spadignore{i.e.} root vertex) given by \\axiom{[v,t]$S} and with children list given by \\axiom{[[[v,t]$S]$% for \\spad{s} in ls]}."

=========================================================================
typos 40178:

>compiling SUMRF.spad to SUMRF.nrlib

--->bookvol10.4.pamphlet-->RationalFunctionSum((sum (RF P SE))): Improper first word in comments: 
--->bookvol10.4.pamphlet-->RationalFunctionSum((sum (RF P SE))): Missing left brace
"\\indented{1}{sum(a(n), \\spad{n)} returns \\spad{A} which} \\indented{1}{is the indefinite sum of \\spad{a} with respect to} \\indented{1}{upward difference on \\spad{n}, \\spadignore{i.e.} \\spad{A(n+1) - A(n) = a(n)}.} \\blankline \\spad{X} sum(i::Polynomial(Integer),variable(i=1..n))"

--->bookvol10.4.pamphlet-->RationalFunctionSum((sum ((Union RF FE) RF SE))): Improper first word in comments: 
--->bookvol10.4.pamphlet-->RationalFunctionSum((sum ((Union RF FE) RF SE))): Missing left brace
"\\indented{1}{sum(a(n), \\spad{n)} returns \\spad{A} which} \\indented{1}{is the indefinite sum of \\spad{a} with respect to} \\indented{1}{upward difference on \\spad{n}, \\spadignore{i.e.} \\spad{A(n+1) - A(n) = a(n)}.} \\blankline \\spad{X} sum(i::Fraction(Polynomial(Integer)),i::Symbol)"

--->bookvol10.4.pamphlet-->RationalFunctionSum((sum (RF P (SegmentBinding P)))): Improper first word in comments: 
"\\indented{1}{sum(f(n), \\spad{n} = a..b) returns \\spad{f(a) + f(a+1) + \\spad{...} f(b)}.} \\blankline \\spad{X} sum(i,i=1..n)"

--->bookvol10.4.pamphlet-->RationalFunctionSum((sum ((Union RF FE) RF (SegmentBinding RF)))): Improper first word in comments: 
"\\indented{1}{sum(f(n), \\spad{n} = a..b) returns \\spad{f(a) + f(a+1) + \\spad{...} f(b)}.} \\blankline \\spad{X} sum(i::Fraction(Polynomial(Integer)),i=1..n)"

=========================================================================
typos 40175:

>compiling TREE.spad to TREE.nrlib

--->bookvol10.3.pamphlet-->Tree((tree (% S (List %)))): Improper first word in comments: 
"\\indented{1}{tree(nd,ls) creates a tree with value \\spad{nd,} and children ls.} \\blankline \\spad{X} t1:=tree [1,2,3,4] \\spad{X} tree(5,[t1])"

--->bookvol10.3.pamphlet-->Tree((tree (% (List S)))): Improper first word in comments: 
"\\indented{1}{tree(ls) creates a tree from a list of elements of \\spad{s.}} \\blankline \\spad{X} tree [1,2,3,4]"

--->bookvol10.3.pamphlet-->Tree((tree (% S))): Improper first word in comments: 
"\\indented{1}{tree(nd) creates a tree with value \\spad{nd,} and no children} \\blankline \\spad{X} tree 6"

--->bookvol10.3.pamphlet-->Tree((cyclic? ((Boolean) %))): Improper first word in comments: 
"\\indented{1}{cyclic?(t) tests if \\spad{t} is a cyclic tree.} \\blankline \\spad{X} t1:=tree [1,2,3,4] \\spad{X} cyclic? \\spad{t1}"

--->bookvol10.3.pamphlet-->Tree((cyclicCopy (% %))): Improper first word in comments: 
"\\indented{1}{cyclicCopy(l) makes a copy of a (possibly) cyclic tree \\spad{l.}} \\blankline \\spad{X} t1:=tree [1,2,3,4] \\spad{X} cyclicCopy \\spad{t1}"

--->bookvol10.3.pamphlet-->Tree((cyclicEntries ((List %) %))): Improper first word in comments: 
"\\indented{1}{cyclicEntries(t) returns a list of top-level cycles in tree \\spad{t.}} \\blankline \\spad{X} t1:=tree [1,2,3,4] \\spad{X} cyclicEntries \\spad{t1}"

--->bookvol10.3.pamphlet-->Tree((cyclicEqual? ((Boolean) % %))): Improper first word in comments: 
"\\indented{1}{cyclicEqual?(t1, \\spad{t2)} tests of two cyclic trees have} \\indented{1}{the same structure.} \\blankline \\spad{X} t1:=tree [1,2,3,4] \\spad{X} t2:=tree [1,2,3,4] \\spad{X} cyclicEqual?(t1,t2)"

--->bookvol10.3.pamphlet-->Tree((cyclicParents ((List %) %))): Improper first word in comments: 
"\\indented{1}{cyclicParents(t) returns a list of cycles that are parents of \\spad{t.}} \\blankline \\spad{X} t1:=tree [1,2,3,4] \\spad{X} cyclicParents \\spad{t1}"

=========================================================================
typos 40173:

>compiling UPDECOMP.spad to UPDECOMP.nrlib

--->bookvol10.4.pamphlet-->UnivariatePolynomialDecompositionPackage((monicCompleteDecompose ((List UP) UP))): Missing left bracket
"\\spad{monicCompleteDecompose(f)} returns a list of factors of \\spad{f} for the functional decomposition \\spad{([} \\spad{f1,} ..., \\spad{fn} ] means \\spad{f} = \\spad{f1} \\spad{o} \\spad{...} \\spad{o} fn)."

=========================================================================
typos 40172:

>compiling UPSQFREE.spad to UPSQFREE.nrlib

--->bookvol10.4.pamphlet-->UnivariatePolynomialSquareFree(constructor): Missing left brace
"This package provides for square-free decomposition of univariate polynomials over arbitrary rings, \\spadignore{i.e.} a partial factorization such that each factor is a product of irreducibles with multiplicity one and the factors are pairwise relatively prime. If the ring has characteristic zero, the result is guaranteed to satisfy this condition. If the ring is an infinite ring of finite characteristic, then it may not be possible to decide when polynomials contain factors which are \\spad{p}th powers. In this case, the flag associated with that polynomial is set to \"nil\" (meaning that that polynomials are not guaranteed to be square-free)."

=========================================================================
typos 40171:

>compiling VIEWDEF.spad to VIEWDEF.nrlib

--->bookvol10.4.pamphlet-->ViewDefaultsPackage((var1StepsDefault (PI))): Mismatch: left pren matches right brace
"\\spad{var1StepsDefault()} is the current setting for the number of steps to take when creating a 3D mesh in the direction of the first defined free variable (a free variable is considered defined when its range is specified (\\spadignore{e.g.} x=0..10))."

--->bookvol10.4.pamphlet-->ViewDefaultsPackage((var2StepsDefault (PI))): Mismatch: left pren matches right brace
"\\spad{var2StepsDefault()} is the current setting for the number of steps to take when creating a 3D mesh in the direction of the first defined free variable (a free variable is considered defined when its range is specified (\\spadignore{e.g.} x=0..10))."

--->bookvol10.4.pamphlet-->ViewDefaultsPackage((var1StepsDefault (PI PI))): Mismatch: left pren matches right brace
"\\spad{var1StepsDefault(i)} sets the number of steps to take when creating a 3D mesh in the direction of the first defined free variable to \\spad{i} (a free variable is considered defined when its range is specified (\\spadignore{e.g.} x=0..10))."

--->bookvol10.4.pamphlet-->ViewDefaultsPackage((var2StepsDefault (PI PI))): Mismatch: left pren matches right brace
"\\spad{var2StepsDefault(i)} sets the number of steps to take when creating a 3D mesh in the direction of the first defined free variable to \\spad{i} (a free variable is considered defined when its range is specified (\\spadignore{e.g.} x=0..10))."

=========================================================================
typos 40170:

>compiling VIEW2D.spad to VIEW2D.nrlib

--->bookvol10.3.pamphlet-->TwoDimensionalViewport((getPickedPoints ((L POINT) $))): Missing left brace
"\\spad{getPickedPoints(x)} returns a list of small floats for the points the user interactively picked on the viewport for full integration into the system, some design issues need to be addressed: \\spadignore{e.g.} how to go through the GraphImage interface, how to default to graphs, etc."

=========================================================================
typos 40169:

>compiling VOID.spad to VOID.nrlib

--->bookvol10.3.pamphlet-->Void(constructor): Missing left brace
"This type is used when no value is needed, \\spadignore{e.g.} in the \\spad{then} part of a one armed \\spad{if}. All values can be coerced to type Void. Once a value has been coerced to Void, it cannot be recovered."

=========================================================================
typos 40168:

>compiling WP.spad to WP.nrlib

--->bookvol10.3.pamphlet-->WeightedPolynomials((coerce (P $))): Improper first word in comments: convert
"convert back into a \"P\", ignoring weights"

=========================================================================
typos 40167:

>compiling EXPUPXS.spad to EXPUPXS.nrlib

--->bookvol10.3.pamphlet-->ExponentialOfUnivariatePuiseuxSeries(constructor): Missing left brace
"ExponentialOfUnivariatePuiseuxSeries is a domain used to represent essential singularities of functions. An object in this domain is a function of the form \\spad{exp(f(x))}, where \\spad{f(x)} is a Puiseux series with no terms of non-negative degree. Objects are ordered according to order of singularity, with functions which tend more rapidly to zero or infinity considered to be larger. Thus, if \\spad{order(f(x)) < order(g(x))}, \\spadignore{i.e.} the first non-zero term of \\spad{f(x)} has lower degree than the first non-zero term of \\spad{g(x)}, then \\spad{exp(f(x)) > exp(g(x))}. If \\spad{order(f(x)) = order(g(x))}, then the ordering is essentially random. This domain is used in computing limits involving functions with essential singularities."

=========================================================================
typos 40166:

>compiling FACTRN.spad to FACTRN.nrlib

--->bookvol10.4.pamphlet-->FactorisationOverPseudoAlgebraicClosureOfRationalNumber((factor ((Factored UP) UP K))): Not documented!!!!
--->bookvol10.4.pamphlet-->FactorisationOverPseudoAlgebraicClosureOfRationalNumber((factorSqFree ((Factored UP) UP K))): Not documented!!!!

=========================================================================
typos 40165:

>compiling FFFACTSE.spad to FFFACTSE.nrlib

--->bookvol10.4.pamphlet-->FiniteFieldFactorizationWithSizeParseBySideEffect((factorSquareFree ((List PolK) PolK))): Not documented!!!!
--->bookvol10.4.pamphlet-->FiniteFieldFactorizationWithSizeParseBySideEffect((factorCantorZassenhaus ((List PolK) PolK (NonNegativeInteger)))): Not documented!!!!
--->bookvol10.4.pamphlet-->FiniteFieldFactorizationWithSizeParseBySideEffect((factor ((Factored PolK) PolK))): Not documented!!!!
--->bookvol10.4.pamphlet-->FiniteFieldFactorizationWithSizeParseBySideEffect((factorUsingYun ((Factored PolK) PolK))): Not documented!!!!
--->bookvol10.4.pamphlet-->FiniteFieldFactorizationWithSizeParseBySideEffect((factorUsingMusser ((Factored PolK) PolK))): Not documented!!!!
--->bookvol10.4.pamphlet-->FiniteFieldFactorizationWithSizeParseBySideEffect((irreducible? ((Boolean) PolK))): Not documented!!!!

=========================================================================
typos 40164:

>compiling FRAMALG.spad to FRAMALG.nrlib

--->-->FramedAlgebra&((traceMatrix ((Matrix R)))): Missing right pren
"\\spad{traceMatrix()} is the n-by-n matrix ( \\spad{Tr(vi * vj)} \\spad{),} where \\spad{v1,} ..., \\spad{vn} are the elements of the fixed basis."

--->bookvol10.2.pamphlet-->FramedAlgebra((traceMatrix ((Matrix R)))): Missing right pren
"\\spad{traceMatrix()} is the n-by-n matrix ( \\spad{Tr(vi * vj)} \\spad{),} where \\spad{v1,} ..., \\spad{vn} are the elements of the fixed basis."

=========================================================================
typos 40163:

>compiling INTFRSP.spad to INTFRSP.nrlib

--->bookvol10.4.pamphlet-->InterpolateFormsPackage((basisOfInterpolateForms ((List (Vector K)) DIVISOR (List PolyRing)))): Not documented!!!!
--->bookvol10.4.pamphlet-->InterpolateFormsPackage((basisOfInterpolateFormsForFact ((List (Vector K)) DIVISOR (List PolyRing)))): Not documented!!!!
--->bookvol10.4.pamphlet-->InterpolateFormsPackage((interpolateFormsForFact ((List PolyRing) DIVISOR (List PolyRing)))): Not documented!!!!

=========================================================================
typos 40162:

>compiling LPARSPT.spad to LPARSPT.nrlib

--->bookvol10.4.pamphlet-->LocalParametrizationOfSimplePointPackage((printInfo ((Boolean)))): Improper first word in comments: returns
"returns the value of the \\spad{printInfo} flag."

=========================================================================
typos 40161:

>compiling NPOLYGON.spad to NPOLYGON.nrlib

--->bookvol10.4.pamphlet-->NewtonPolygon((newtonPolygon ((List (List PolyRing)) PolyRing (Integer) (Integer) (Union left center right vertical horizontal)))): Not documented!!!!
--->bookvol10.4.pamphlet-->NewtonPolygon((multiplicity ((NonNegativeInteger) (List (List PolyRing))))): Not documented!!!!
--->bookvol10.4.pamphlet-->NewtonPolygon((negAndPosEdge ((List (List PolyRing)) PolyRing (List (List PolyRing))))): Not documented!!!!
--->bookvol10.4.pamphlet-->NewtonPolygon((slope (recSlope PolyRing PolyRing))): Not documented!!!!
--->bookvol10.4.pamphlet-->NewtonPolygon((slope (recSlope (List PolyRing)))): Not documented!!!!

=========================================================================
typos 40160:

>compiling PLOT.spad to PLOT.nrlib

--->bookvol10.3.pamphlet-->Plot((plot (% (Mapping F F) R))): Improper first word in comments: 
"\\indented{1}{plot(f,a..b) plots the function \\spad{f(x)}} \\indented{1}{on the interval \\spad{[a,b]}.} \\blankline \\spad{X} fp:=(t:DFLOAT):DFLOAT \\spad{+->} sin(t) \\spad{X} plot(fp,-1.0..1.0)$PLOT"

=========================================================================
typos 40159:

>compiling ROIRC.spad to ROIRC.nrlib

--->-->RightOpenIntervalRootCharacterization((size (TheField $))): Improper first word in comments: The
"The size of the isolating interval"

=========================================================================
typos 40158:

>compiling AFALGGRO.spad to AFALGGRO.nrlib

--->bookvol10.4.pamphlet-->AffineAlgebraicSetComputeWithGroebnerBasis((affineAlgSet ((Union (List ProjPt) failed Infinite (Integer)) (List PolyRing)))): Not documented!!!!
--->bookvol10.4.pamphlet-->AffineAlgebraicSetComputeWithGroebnerBasis((affineSingularPoints ((Union (List ProjPt) failed Infinite (Integer)) PolyRing))): Not documented!!!!

=========================================================================
typos 40157:

>compiling AFALGRES.spad to AFALGRES.nrlib

--->bookvol10.4.pamphlet-->AffineAlgebraicSetComputeWithResultant((affineSingularPoints ((Union (List ProjPt) failed Infinite (Integer)) PolyRing))): Not documented!!!!
--->bookvol10.4.pamphlet-->AffineAlgebraicSetComputeWithResultant((affineSingularPoints ((Union (List ProjPt) failed Infinite (Integer)) UPUP))): Not documented!!!!
--->bookvol10.4.pamphlet-->AffineAlgebraicSetComputeWithResultant((affineAlgSetLocal ((Union (List ProjPt) failed Infinite (Integer)) (List UPUP)))): Not documented!!!!
--->bookvol10.4.pamphlet-->AffineAlgebraicSetComputeWithResultant((affineAlgSet ((Union (List ProjPt) failed Infinite (Integer)) (List PolyRing)))): Not documented!!!!
--->bookvol10.4.pamphlet-->AffineAlgebraicSetComputeWithResultant((polyRing2UPUP (UPUP PolyRing))): Not documented!!!!
--->bookvol10.4.pamphlet-->AffineAlgebraicSetComputeWithResultant((allPairsAmong ((List (List UPUP)) (List UPUP)))): Not documented!!!!
--->bookvol10.4.pamphlet-->AffineAlgebraicSetComputeWithResultant((affineRationalPoints ((Union (List ProjPt) failed Infinite (Integer)) PolyRing (PositiveInteger)))): Not documented!!!!

=========================================================================
typos 40156:

>compiling FFINTBAS.spad to FFINTBAS.nrlib

--->bookvol10.4.pamphlet-->FunctionFieldIntegralBasis((integralBasis ((Record (: basis Mat) (: basisDen R) (: basisInv Mat))))): Missing left brace
"\\spad{integralBasis()} returns a record \\spad{[basis,basisDen,basisInv]} containing information regarding the integral closure of \\spad{R} in the quotient field of \\spad{F,} where \\spad{F} is a framed algebra with R-module basis \\spad{w1,w2,...,wn}. If \\spad{basis} is the matrix \\spad{(aij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then the \\spad{i}th element of the integral basis is \\spad{vi = (1/basisDen) * sum(aij * \\spad{wj,} \\spad{j} = 1..n)}, \\spadignore{i.e.} the \\spad{i}th row of \\spad{basis} contains the coordinates of the \\spad{i}th basis vector. Similarly, the \\spad{i}th row of the matrix \\spad{basisInv} contains the coordinates of \\spad{wi} with respect to the basis \\spad{v1,...,vn}: if \\spad{basisInv} is the matrix \\spad{(bij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then \\spad{wi = sum(bij * \\spad{vj,} \\spad{j} = 1..n)}."

--->bookvol10.4.pamphlet-->FunctionFieldIntegralBasis((localIntegralBasis ((Record (: basis Mat) (: basisDen R) (: basisInv Mat)) R))): Missing left brace
"\\spad{integralBasis(p)} returns a record \\spad{[basis,basisDen,basisInv]} containing information regarding the local integral closure of \\spad{R} at the prime \\spad{p} in the quotient field of \\spad{F,} where \\spad{F} is a framed algebra with R-module basis \\spad{w1,w2,...,wn}. If \\spad{basis} is the matrix \\spad{(aij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then the \\spad{i}th element of the local integral basis is \\spad{vi = (1/basisDen) * sum(aij * \\spad{wj,} \\spad{j} = 1..n)}, \\spadignore{i.e.} the \\spad{i}th row of \\spad{basis} contains the coordinates of the \\spad{i}th basis vector. Similarly, the \\spad{i}th row of the matrix \\spad{basisInv} contains the coordinates of \\spad{wi} with respect to the basis \\spad{v1,...,vn}: if \\spad{basisInv} is the matrix \\spad{(bij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then \\spad{wi = sum(bij * \\spad{vj,} \\spad{j} = 1..n)}."

=========================================================================
typos 40155:

>compiling FSAGG.spad to FSAGG.nrlib

--->-->FiniteSetAggregate&((complement (% %))): Missing left brace
"\\spad{complement(u)} returns the complement of the set u, \\spadignore{i.e.} the set of all values not in u."

--->bookvol10.2.pamphlet-->FiniteSetAggregate((complement (% %))): Missing left brace
"\\spad{complement(u)} returns the complement of the set u, \\spadignore{i.e.} the set of all values not in u."

=========================================================================
typos 40154:

>compiling IBATOOL.spad to IBATOOL.nrlib

--->bookvol10.4.pamphlet-->IntegralBasisTools((moduleSum (Ans Ans Ans))): Missing left brace
"\\spad{moduleSum(m1,m2)} returns the sum of two modules in the framed algebra \\spad{F}. Each module \\spad{mi} is represented as follows: \\spad{F} is a framed algebra with R-module basis \\spad{w1,w2,...,wn} and \\spad{mi} is a record \\spad{[basis,basisDen,basisInv]}. If \\spad{basis} is the matrix \\spad{(aij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then a basis \\spad{v1,...,vn} for \\spad{mi} is given by \\spad{vi = (1/basisDen) * sum(aij * \\spad{wj,} \\spad{j} = 1..n)}, \\spadignore{i.e.} the \\spad{i}th row of 'basis' contains the coordinates of the \\spad{i}th basis vector. Similarly, the \\spad{i}th row of the matrix \\spad{basisInv} contains the coordinates of \\spad{wi} with respect to the basis \\spad{v1,...,vn}: if \\spad{basisInv} is the matrix \\spad{(bij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then \\spad{wi = sum(bij * \\spad{vj,} \\spad{j} = 1..n)}."

=========================================================================
typos 40153:

>compiling NFINTBAS.spad to NFINTBAS.nrlib

--->bookvol10.4.pamphlet-->NumberFieldIntegralBasis((integralBasis ((Record (: basis Mat) (: basisDen I) (: basisInv Mat))))): Missing left brace
"\\spad{integralBasis()} returns a record \\spad{[basis,basisDen,basisInv]} containing information regarding the integral closure of \\spad{Z} in the quotient field of \\spad{F,} where \\spad{F} is a framed algebra with Z-module basis \\spad{w1,w2,...,wn}. If \\spad{basis} is the matrix \\spad{(aij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then the \\spad{i}th element of the integral basis is \\spad{vi = (1/basisDen) * sum(aij * \\spad{wj,} \\spad{j} = 1..n)}, \\spadignore{i.e.} the \\spad{i}th row of \\spad{basis} contains the coordinates of the \\spad{i}th basis vector. Similarly, the \\spad{i}th row of the matrix \\spad{basisInv} contains the coordinates of \\spad{wi} with respect to the basis \\spad{v1,...,vn}: if \\spad{basisInv} is the matrix \\spad{(bij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then \\spad{wi = sum(bij * \\spad{vj,} \\spad{j} = 1..n)}."

--->bookvol10.4.pamphlet-->NumberFieldIntegralBasis((localIntegralBasis ((Record (: basis Mat) (: basisDen I) (: basisInv Mat)) I))): Missing left brace
"\\spad{integralBasis(p)} returns a record \\spad{[basis,basisDen,basisInv]} containing information regarding the local integral closure of \\spad{Z} at the prime \\spad{p} in the quotient field of \\spad{F,} where \\spad{F} is a framed algebra with Z-module basis \\spad{w1,w2,...,wn}. If \\spad{basis} is the matrix \\spad{(aij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then the \\spad{i}th element of the integral basis is \\spad{vi = (1/basisDen) * sum(aij * \\spad{wj,} \\spad{j} = 1..n)}, \\spadignore{i.e.} the \\spad{i}th row of \\spad{basis} contains the coordinates of the \\spad{i}th basis vector. Similarly, the \\spad{i}th row of the matrix \\spad{basisInv} contains the coordinates of \\spad{wi} with respect to the basis \\spad{v1,...,vn}: if \\spad{basisInv} is the matrix \\spad{(bij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then \\spad{wi = sum(bij * \\spad{vj,} \\spad{j} = 1..n)}."

=========================================================================
typos 40152:

>compiling BSD.spad to BSD.nrlib

--->Makefile.pamphlet-->BasicStochasticDifferential((introduce! ((Union % failed) (Symbol) (Symbol)))): Improper first word in comments: 
"\\indented{1}{introduce!(X,dX) returns \\axiom{dX} as \\axiom{BSD} if it} \\indented{1}{isn't already in \\axiom{BSD}} \\blankline \\spad{X} introduce!(t,dt) \\spad{--} \\spad{dt} is a new stochastic differential \\spad{X} copyBSD()"

--->Makefile.pamphlet-->BasicStochasticDifferential((copyBSD ((List %)))): Improper first word in comments: 
"\\indented{1}{copyBSD() returns \\axiom{setBSD} as a list of \\axiom{BSD}.} \\blankline \\spad{X} introduce!(t,dt) \\spad{--} \\spad{dt} is a new stochastic differential \\spad{X} copyBSD()"

--->Makefile.pamphlet-->BasicStochasticDifferential((copyIto ((Table (Symbol) %)))): Improper first word in comments: 
"\\indented{1}{copyIto() returns the table relating semimartingales} \\indented{1}{to basic stochastic differentials.} \\blankline \\spad{X} introduce!(t,dt) \\spad{--} \\spad{dt} is a new stochastic differential \\spad{X} copyIto()"

--->Makefile.pamphlet-->BasicStochasticDifferential((getSmgl ((Union (Symbol) failed) %))): Improper first word in comments: 
"\\indented{1}{getSmgl(bsd) returns the semimartingale \\axiom{S} related} \\indented{1}{to the basic stochastic differential \\axiom{bsd} \\spad{by}} \\indented{1}{\\axiom{introduce!}} \\blankline \\spad{X} introduce!(t,dt) \\spad{--} \\spad{dt} is a new stochastic differential \\spad{X} getSmgl(dt::BSD)"

=========================================================================
typos 40151:

>compiling FSAGG2.spad to FSAGG2.nrlib

--->bookvol10.4.pamphlet-->FiniteSetAggregateFunctions2((scan (B (Mapping R S R) A R))): Missing right brace for \spad
"\\spad{scan(f,a,r)} successively applies \\spad{reduce(f,x,r)} to more and more leading sub-aggregates \\spad{x} of aggregate \\spad{a}. More precisely, if \\spad{a} is \\spad{[a1,a2,...]}, then \\spad{scan(f,a,r)} returns \\spad {[reduce(f,[a1],r),reduce(f,[a1,a2],r),...]}."
--->bookvol10.4.pamphlet-->FiniteSetAggregateFunctions2((scan (B (Mapping R S R) A R))): Missing right brace for \spad

=========================================================================
typos 40150:

>compiling GALFACT.spad to GALFACT.nrlib

--->bookvol10.4.pamphlet-->GaloisGroupFactorizer((modularFactor (MFact UP))): Mismatch: left pren matches right brace
--->bookvol10.4.pamphlet-->GaloisGroupFactorizer((modularFactor (MFact UP))): Mismatch: left pren matches right brace
--->bookvol10.4.pamphlet-->GaloisGroupFactorizer((modularFactor (MFact UP))): Mismatch: left pren matches right brace
"\\spad{modularFactor(f)} chooses a \"good\" prime and returns the factorization of \\spad{f} modulo this prime in a form that may be used by completeHensel. If prime is zero it means that \\spad{f} has been proved to be irreducible over the integers or that \\spad{f} is a unit (\\spadignore{i.e.} 1 or -1). \\spad{f} shall be primitive (\\spadignore{i.e.} content(p)=1) and square free (\\spadignore{i.e.} without repeated factors)."

--->bookvol10.4.pamphlet-->GaloisGroupFactorizer((factorOfDegree ((Union UP failed) P UP (List N) N (Boolean)))): Mismatch: left pren matches right brace
"\\spad{factorOfDegree(d,p,listOfDegrees,r,sqf)} returns a factor of \\spad{p} of degree \\spad{d} knowing that \\spad{p} has for possible splitting of its degree listOfDegrees, and that \\spad{p} has at least \\spad{r} factors. If \\spad{sqf=true} the polynomial is assumed to be square free (\\spadignore{i.e.} without repeated factors)."

--->bookvol10.4.pamphlet-->GaloisGroupFactorizer((henselFact (FinalFact UP (Boolean)))): Mismatch: left pren matches right brace
"\\spad{henselFact(p,sqf)} returns the factorization of \\spad{p,} the result is a Record such that \\spad{contp=}content \\spad{p,} \\spad{factors=}List of irreducible factors of \\spad{p} with exponent. If \\spad{sqf=true} the polynomial is assumed to be square free (\\spadignore{i.e.} without repeated factors)."

--->bookvol10.4.pamphlet-->GaloisGroupFactorizer((btwFact (FinalFact UP (Boolean) (Set N) N))): Mismatch: left pren matches right brace
"\\spad{btwFact(p,sqf,pd,r)} returns the factorization of \\spad{p,} the result is a Record such that \\spad{contp=}content \\spad{p,} \\spad{factors=}List of irreducible factors of \\spad{p} with exponent. If \\spad{sqf=true} the polynomial is assumed to be square free (\\spadignore{i.e.} without repeated factors). \\spad{pd} is the \\spadtype{Set} of possible degrees. \\spad{r} is a lower bound for the number of factors of \\spad{p.} Please do not use this function in your code because its design may change."

=========================================================================
typos 40149:

>compiling MMLFORM.spad to MMLFORM.nrlib

--->bookvol10.3.pamphlet-->MathMLFormat((coerce (S E))): Improper first word in comments: coerceS
"coerceS(o) changes \\spad{o} in the standard output format to MathML format."

--->bookvol10.3.pamphlet-->MathMLFormat((coerceL (S E))): Improper first word in comments: coerceS
"coerceS(o) changes \\spad{o} in the standard output format to MathML format and displays result as one long string."

--->bookvol10.3.pamphlet-->MathMLFormat((exprex (S E))): Improper first word in comments: coverts
"coverts \\spadtype{OutputForm} to \\spadtype{String} with the structure preserved with braces. Actually this is not quite accurate. The function \\spadfun{precondition} is first applied to the \\spadtype{OutputForm} expression before \\spadfun{exprex}. The raw \\spadtype{OutputForm} and the nature of the \\spadfun{precondition} function is still obscure to me at the time of this writing (2007-02-14)."

--->bookvol10.3.pamphlet-->MathMLFormat((display ((Void) S))): Improper first word in comments: prints
"prints the string returned by coerce, adding <math ...> tags."

--->bookvol10.3.pamphlet-->MathMLFormat(): Spurious comments: finds closing \spad{">"} of start or end tag for mathML element

=========================================================================
typos 40148:

>compiling NORMMA.spad to NORMMA.nrlib

--->bookvol10.4.pamphlet-->NormInMonogenicAlgebra((norm (PolR PolE))): Missing left brace
"\\spad{norm \\spad{q}} returns the norm of \\spad{q,} \\spadignore{i.e.} the product of all the conjugates of \\spad{q.}"

=========================================================================
typos 40147:

>compiling PERM.spad to PERM.nrlib

--->bookvol10.3.pamphlet-->Permutation((coercePreimagesImages (% (List (List S))))): Improper first word in comments: 
"\\indented{1}{coercePreimagesImages(lls) coerces the representation lls} \\indented{1}{of a permutation as a list of preimages and images to a permutation.} \\indented{1}{We assume that both preimage and image do not contain repetitions.} \\blankline \\spad{X} \\spad{p} \\spad{:=} coercePreimagesImages([[1,2,3],[1,2,3]]) \\spad{X} \\spad{q} \\spad{:=} coercePreimagesImages([[0,1,2,3],[3,0,2,1]])$PERM ZMOD 4"

--->bookvol10.3.pamphlet-->Permutation((coerce (% (List S)))): Missing left brace
"\\spad{coerce(ls)} coerces a cycle \\spad{ls,} \\spadignore{i.e.} a list with not repetitions to a permutation, which maps ls.i to ls.i+1, indices modulo the length of the list. Error: if repetitions occur."

--->bookvol10.3.pamphlet-->Permutation((coerceListOfPairs (% (List (List S))))): Missing left brace
"\\spad{coerceListOfPairs(lls)} coerces a list of pairs \\spad{lls} to a permutation. Error: if not consistent, \\spadignore{i.e.} the set of the first elements coincides with the set of second elements. coerce(p) generates output of the permutation \\spad{p} with domain OutputForm."

--->bookvol10.3.pamphlet-->Permutation((movedPoints ((Set S) %))): Improper first word in comments: 
"\\indented{1}{movedPoints(p) returns the set of points moved by the permutation \\spad{p.}} \\blankline \\spad{X} \\spad{p} \\spad{:=} coercePreimagesImages([[1,2,3],[1,2,3]]) \\spad{X} movedPoints \\spad{p}"

--->bookvol10.3.pamphlet-->Permutation((even? ((Boolean) %))): Improper first word in comments: 
--->bookvol10.3.pamphlet-->Permutation((even? ((Boolean) %))): Missing left brace
"\\indented{1}{even?(p) returns \\spad{true} if and only if \\spad{p} is an even permutation,} \\indented{1}{\\spadignore{i.e.} sign(p) is 1.} \\blankline \\spad{X} \\spad{p} \\spad{:=} coercePreimagesImages([[1,2,3],[1,2,3]]) \\spad{X} even? \\spad{p}"

--->bookvol10.3.pamphlet-->Permutation((odd? ((Boolean) %))): Missing left brace
"\\spad{odd?(p)} returns \\spad{true} if and only if \\spad{p} is an odd permutation \\spadignore{i.e.} sign(p) is \\spad{-1.}"

--->bookvol10.3.pamphlet-->Permutation((fixedPoints ((Set S) %))): Improper first word in comments: 
"\\indented{1}{fixedPoints(p) returns the points fixed by the permutation \\spad{p.}} \\spad{X} \\spad{p} \\spad{:=} coercePreimagesImages([[0,1,2,3],[3,0,2,1]])$PERM ZMOD 4 \\spad{X} fixedPoints \\spad{p}"

=========================================================================
typos 40146:

>compiling PERMGRP.spad to PERMGRP.nrlib

--->bookvol10.3.pamphlet-->PermutationGroup((orbit ((FSET S) % S))): Missing left brace
"\\spad{orbit(gp,el)} returns the orbit of the element \\spad{el} under the group \\spad{gp,} \\spadignore{i.e.} the set of all points gained by applying each group element to el."

--->bookvol10.3.pamphlet-->PermutationGroup((orbits ((FSET (FSET S)) %))): Missing left brace
"\\spad{orbits(gp)} returns the orbits of the group \\spad{gp,} \\spadignore{i.e.} it partitions the (finite) of all moved points."

--->bookvol10.3.pamphlet-->PermutationGroup(constructor): Missing left brace
"PermutationGroup implements permutation groups acting on a set \\spad{S,} \\spadignore{i.e.} all subgroups of the symmetric group of \\spad{S,} represented as a list of permutations (generators). Note that therefore the objects are not members of the Axiom category \\spadtype{Group}. Using the idea of base and strong generators by Sims, basic routines and algorithms are implemented so that the word problem for permutation groups can be solved."

=========================================================================
typos 40145:

>compiling PRJALGPK.spad to PRJALGPK.nrlib

--->bookvol10.4.pamphlet-->ProjectiveAlgebraicSetPackage((singularPointsWithRestriction ((List ProjPt) PolyRing (List PolyRing)))): Improper first word in comments: return
"return the singular points that anhilate"

=========================================================================
typos 40144:

>compiling PWFFINTB.spad to PWFFINTB.nrlib

--->bookvol10.4.pamphlet-->PAdicWildFunctionFieldIntegralBasis((integralBasis ((Result)))): Missing left brace
--->bookvol10.4.pamphlet-->PAdicWildFunctionFieldIntegralBasis((integralBasis ((Result)))): Missing left brace
"\\spad{integralBasis()} returns a record \\spad{[basis,basisDen,basisInv] } containing information regarding the integral closure of \\spad{R} in the quotient field of the framed algebra \\spad{F.} \\spad{F} is a framed algebra with R-module basis \\spad{w1,w2,...,wn}. If 'basis' is the matrix \\spad{(aij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then the \\spad{i}th element of the integral basis is \\spad{vi = (1/basisDen) * sum(aij * \\spad{wj,} \\spad{j} = 1..n)}, \\spadignore{i.e.} the \\spad{i}th row of 'basis' contains the coordinates of the \\spad{i}th basis vector. Similarly, the \\spad{i}th row of the matrix 'basisInv' contains the coordinates of \\spad{wi} with respect to the basis \\spad{v1,...,vn}: if 'basisInv' is the matrix \\spad{(bij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then \\spad{wi = sum(bij * \\spad{vj,} \\spad{j} = 1..n)}."

--->bookvol10.4.pamphlet-->PAdicWildFunctionFieldIntegralBasis((localIntegralBasis ((Result) R))): Missing left brace
--->bookvol10.4.pamphlet-->PAdicWildFunctionFieldIntegralBasis((localIntegralBasis ((Result) R))): Missing left brace
"\\spad{integralBasis(p)} returns a record \\spad{[basis,basisDen,basisInv] } containing information regarding the local integral closure of \\spad{R} at the prime \\spad{p} in the quotient field of the framed algebra \\spad{F.} \\spad{F} is a framed algebra with R-module basis \\spad{w1,w2,...,wn}. If 'basis' is the matrix \\spad{(aij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then the \\spad{i}th element of the local integral basis is \\spad{vi = (1/basisDen) * sum(aij * \\spad{wj,} \\spad{j} = 1..n)}, \\spadignore{i.e.} the \\spad{i}th row of 'basis' contains the coordinates of the \\spad{i}th basis vector. Similarly, the \\spad{i}th row of the matrix 'basisInv' contains the coordinates of \\spad{wi} with respect to the basis \\spad{v1,...,vn}: if 'basisInv' is the matrix \\spad{(bij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then \\spad{wi = sum(bij * \\spad{vj,} \\spad{j} = 1..n)}."

--->bookvol10.4.pamphlet-->PAdicWildFunctionFieldIntegralBasis(constructor): Missing left brace
"In this package \\spad{K} is a finite field, \\spad{R} is a ring of univariate polynomials over \\spad{K,} and \\spad{F} is a monogenic algebra over \\spad{R.} We require that \\spad{F} is monogenic, \\spadignore{i.e.} that \\spad{F = K[x,y]/(f(x,y))}, because the integral basis algorithm used will factor the polynomial \\spad{f(x,y)}. The package provides a function to compute the integral closure of \\spad{R} in the quotient field of \\spad{F} as well as a function to compute a \"local integral basis\" at a specific prime."

=========================================================================
typos 40143:

>compiling SGCF.spad to SGCF.nrlib

--->bookvol10.4.pamphlet-->SymmetricGroupCombinatoricFunctions((unrankImproperPartitions1 ((L I) I I I))): Mismatch: left pren matches right brace
"\\spad{unrankImproperPartitions1(n,m,k)} computes the \\spad{k}-th improper partition of nonnegative \\spad{n} in at most \\spad{m} nonnegative parts ordered as follows: first, in reverse lexicographically according to their non-zero parts, then according to their positions (\\spadignore{i.e.} lexicographical order using subSet: [3,0,0] < [0,3,0] < [0,0,3] < [2,1,0] < [2,0,1] < [0,2,1] < [1,2,0] < [1,0,2] < [0,1,2] < [1,1,1]. Note that counting of subtrees is done by numberOfImproperPartitionsInternal."

=========================================================================
typos 40142:

>compiling TBAGG.spad to TBAGG.nrlib

--->-->TableAggregate&((table (%))): Improper first word in comments: 
"\\indented{1}{table()$T creates an empty table of type \\spad{T.}} \\blankline \\spad{E} Data:=Record(age:Integer,gender:String) \\spad{E} a1:AssociationList(String,Data):=table() \\spad{E} a1.\"tim\":=[55,\"male\"]$Data"

--->-->TableAggregate&(constructor): Missing left brace
"A table aggregate is a model of a table, \\spadignore{i.e.} a discrete many-to-one mapping from keys to entries."

--->bookvol10.2.pamphlet-->TableAggregate((table (%))): Improper first word in comments: 
"\\indented{1}{table()$T creates an empty table of type \\spad{T.}} \\blankline \\spad{E} Data:=Record(age:Integer,gender:String) \\spad{E} a1:AssociationList(String,Data):=table() \\spad{E} a1.\"tim\":=[55,\"male\"]$Data"

--->bookvol10.2.pamphlet-->TableAggregate(constructor): Missing left brace
"A table aggregate is a model of a table, \\spadignore{i.e.} a discrete many-to-one mapping from keys to entries."

=========================================================================
typos 40141:

>compiling WFFINTBS.spad to WFFINTBS.nrlib

--->bookvol10.4.pamphlet-->WildFunctionFieldIntegralBasis((integralBasis (RResult))): Missing left brace
"\\spad{integralBasis()} returns a record \\spad{[basis,basisDen,basisInv]} containing information regarding the integral closure of \\spad{R} in the quotient field of \\spad{F,} where \\spad{F} is a framed algebra with R-module basis \\spad{w1,w2,...,wn}. If \\spad{basis} is the matrix \\spad{(aij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then the \\spad{i}th element of the integral basis is \\spad{vi = (1/basisDen) * sum(aij * \\spad{wj,} \\spad{j} = 1..n)}, \\spadignore{i.e.} the \\spad{i}th row of \\spad{basis} contains the coordinates of the \\spad{i}th basis vector. Similarly, the \\spad{i}th row of the matrix \\spad{basisInv} contains the coordinates of \\spad{wi} with respect to the basis \\spad{v1,...,vn}: if \\spad{basisInv} is the matrix \\spad{(bij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then \\spad{wi = sum(bij * \\spad{vj,} \\spad{j} = 1..n)}."

--->bookvol10.4.pamphlet-->WildFunctionFieldIntegralBasis((localIntegralBasis (RResult R))): Missing left brace
"\\spad{integralBasis(p)} returns a record \\spad{[basis,basisDen,basisInv]} containing information regarding the local integral closure of \\spad{R} at the prime \\spad{p} in the quotient field of \\spad{F,} where \\spad{F} is a framed algebra with R-module basis \\spad{w1,w2,...,wn}. If \\spad{basis} is the matrix \\spad{(aij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then the \\spad{i}th element of the local integral basis is \\spad{vi = (1/basisDen) * sum(aij * \\spad{wj,} \\spad{j} = 1..n)}, \\spadignore{i.e.} the \\spad{i}th row of \\spad{basis} contains the coordinates of the \\spad{i}th basis vector. Similarly, the \\spad{i}th row of the matrix \\spad{basisInv} contains the coordinates of \\spad{wi} with respect to the basis \\spad{v1,...,vn}: if \\spad{basisInv} is the matrix \\spad{(bij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then \\spad{wi = sum(bij * \\spad{vj,} \\spad{j} = 1..n)}."

=========================================================================
typos 40140:

>compiling INTPACK.spad to INTPACK.nrlib

--->bookvol10.4.pamphlet-->AnnaNumericalIntegrationPackage((integrate ((Result) EF SOCF F F RT))): Missing left brace
"\\spad{integrate(exp, a..b, epsrel, routines)} is a top level ANNA function to integrate an expression, {\\tt exp}, over a given range {\\tt a} to {\\tt \\spad{b}} to the required absolute and relative accuracy using the routines available in the RoutinesTable provided. \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline It then performs the integration of the given expression on that \\axiom{domain}."

--->bookvol10.4.pamphlet-->AnnaNumericalIntegrationPackage((integrate ((Result) (NumericalIntegrationProblem)))): Missing left brace
"\\spad{integrate(IntegrationProblem)} is a top level ANNA function to integrate an expression over a given range or ranges to the required absolute and relative accuracy. \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline It then performs the integration of the given expression on that \\axiom{domain}."

--->bookvol10.4.pamphlet-->AnnaNumericalIntegrationPackage((integrate ((Result) EF SOCF F F))): Missing left brace
"\\spad{integrate(exp, a..b, epsabs, epsrel)} is a top level ANNA function to integrate an expression, {\\tt exp}, over a given range {\\tt a} to {\\tt \\spad{b}} to the required absolute and relative accuracy. \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline It then performs the integration of the given expression on that \\axiom{domain}."

--->bookvol10.4.pamphlet-->AnnaNumericalIntegrationPackage((integrate ((Result) EF SOCF F))): Missing left brace
"\\spad{integrate(exp, a..b, epsrel)} is a top level ANNA function to integrate an expression, {\\tt exp}, over a given range {\\tt a} to {\\tt \\spad{b}} to the required relative accuracy. \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline It then performs the integration of the given expression on that \\axiom{domain}. \\blankline If epsrel = 0, a default absolute accuracy is used."

--->bookvol10.4.pamphlet-->AnnaNumericalIntegrationPackage((integrate ((Result) EF SOCF))): Missing left brace
"\\spad{integrate(exp, a..b)} is a top level ANNA function to integrate an expression, {\\tt exp}, over a given range {\\tt a} to {\\tt \\spad{b}.} \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline It then performs the integration of the given expression on that \\axiom{domain}. \\blankline Default values for the absolute and relative error are used."

--->bookvol10.4.pamphlet-->AnnaNumericalIntegrationPackage((integrate ((Result) EF LSOCF))): Missing left brace
"\\spad{integrate(exp, [a..b,c..d,...])} is a top level ANNA function to integrate a multivariate expression, {\\tt exp}, over a given set of ranges. \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline It then performs the integration of the given expression on that \\axiom{domain}. \\blankline Default values for the absolute and relative error are used."

--->bookvol10.4.pamphlet-->AnnaNumericalIntegrationPackage((integrate ((Result) EF LSOCF F))): Missing left brace
"\\spad{integrate(exp, [a..b,c..d,...], epsrel)} is a top level ANNA function to integrate a multivariate expression, {\\tt exp}, over a given set of ranges to the required relative accuracy. \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline It then performs the integration of the given expression on that \\axiom{domain}. \\blankline If epsrel = 0, a default absolute accuracy is used."

--->bookvol10.4.pamphlet-->AnnaNumericalIntegrationPackage((integrate ((Result) EF LSOCF F F))): Missing left brace
"\\spad{integrate(exp, [a..b,c..d,...], epsabs, epsrel)} is a top level ANNA function to integrate a multivariate expression, {\\tt exp}, over a given set of ranges to the required absolute and relative accuracy. \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline It then performs the integration of the given expression on that \\axiom{domain}."

--->bookvol10.4.pamphlet-->AnnaNumericalIntegrationPackage((integrate ((Result) EF LSOCF F F RT))): Missing left brace
"\\spad{integrate(exp, [a..b,c..d,...], epsabs, epsrel, routines)} is a top level ANNA function to integrate a multivariate expression, {\\tt exp}, over a given set of ranges to the required absolute and relative accuracy, using the routines available in the RoutinesTable provided. \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline It then performs the integration of the given expression on that \\axiom{domain}."

--->bookvol10.4.pamphlet-->AnnaNumericalIntegrationPackage((measure (Measure (NumericalIntegrationProblem)))): Missing left brace
"\\spad{measure(prob)} is a top level ANNA function for identifying the most appropriate numerical routine for solving the numerical integration problem defined by \\axiom{prob}. \\blankline It calls each \\axiom{domain} of \\axiom{category} \\axiomType{NumericalIntegrationCategory} in turn to calculate all measures and returns the best \\spadignore{i.e.} the name of the most appropriate domain and any other relevant information."

--->bookvol10.4.pamphlet-->AnnaNumericalIntegrationPackage((measure (Measure (NumericalIntegrationProblem) RT))): Missing left brace
"\\spad{measure(prob,R)} is a top level ANNA function for identifying the most appropriate numerical routine from those in the routines table provided for solving the numerical integration problem defined by \\axiom{prob}. \\blankline It calls each \\axiom{domain} listed in \\axiom{R} of \\axiom{category} \\axiomType{NumericalIntegrationCategory} in turn to calculate all measures and returns the best \\spadignore{i.e.} the name of the most appropriate domain and any other relevant information."

--->bookvol10.4.pamphlet-->AnnaNumericalIntegrationPackage((integrate ((Union (Result) failed) EF SBOCF ST))): Missing left brace
"\\spad{integrate(exp, \\spad{x} = a..b, \"numerical\")} is a top level ANNA function to integrate an expression, {\\tt exp}, over a given range, {\\tt a} to {\\tt \\spad{b}.} \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline It then performs the integration of the given expression on that \\axiom{domain}. \\blankline Default values for the absolute and relative error are used. \\blankline It is an error of the last argument is not {\\tt \"numerical\"}."

--->bookvol10.4.pamphlet-->AnnaNumericalIntegrationPackage((integrate ((Union (Result) failed) EF SBOCF S))): Missing left brace
"\\spad{integrate(exp, \\spad{x} = a..b, numerical)} is a top level ANNA function to integrate an expression, {\\tt exp}, over a given range, {\\tt a} to {\\tt \\spad{b}.} \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline It then performs the integration of the given expression on that \\axiom{domain}. \\blankline Default values for the absolute and relative error are used. \\blankline It is an error if the last argument is not {\\tt numerical}."

=========================================================================
typos 40139:

>compiling PDEPACK.spad to PDEPACK.nrlib

--->bookvol10.4.pamphlet-->AnnaPartialDifferentialEquationPackage((measure (Measure (NumericalPDEProblem)))): Missing left brace
"\\spad{measure(prob)} is a top level ANNA function for identifying the most appropriate numerical routine from those in the routines table provided for solving the numerical PDE problem defined by \\axiom{prob}. \\blankline It calls each \\axiom{domain} of \\axiom{category} \\axiomType{PartialDifferentialEquationsSolverCategory} in turn to calculate all measures and returns the best \\spadignore{i.e.} the name of the most appropriate domain and any other relevant information. It predicts the likely most effective NAG numerical Library routine to solve the input set of PDEs by checking various attributes of the system of PDEs and calculating a measure of compatibility of each routine to these attributes."

--->bookvol10.4.pamphlet-->AnnaPartialDifferentialEquationPackage((measure (Measure (NumericalPDEProblem) RT))): Missing left brace
"\\spad{measure(prob,R)} is a top level ANNA function for identifying the most appropriate numerical routine from those in the routines table provided for solving the numerical PDE problem defined by \\axiom{prob}. \\blankline It calls each \\axiom{domain} listed in \\axiom{R} of \\axiom{category} \\axiomType{PartialDifferentialEquationsSolverCategory} in turn to calculate all measures and returns the best \\spadignore{i.e.} the name of the most appropriate domain and any other relevant information. It predicts the likely most effective NAG numerical Library routine to solve the input set of PDEs by checking various attributes of the system of PDEs and calculating a measure of compatibility of each routine to these attributes."

=========================================================================
typos 40138:

>compiling ACF.spad to ACF.nrlib

--->-->AlgebraicallyClosedField&((rootOf ($ (Polynomial $)))): Improper first word in comments: 
"\\indented{1}{rootOf(p) returns \\spad{y} such that \\spad{p(y) = 0}.} \\indented{1}{Error: if \\spad{p} has more than one variable \\spad{y.}} \\blankline \\spad{X} \\spad{a:Polynomial(Integer):=-3*x^3+2*x+13} \\spad{X} rootOf(a)"

--->-->AlgebraicallyClosedField&((rootOf ($ (SparseUnivariatePolynomial $)))): Improper first word in comments: 
"\\indented{1}{rootOf(p) returns \\spad{y} such that \\spad{p(y) = 0}.} \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} rootOf(a)"

--->-->AlgebraicallyClosedField&((rootOf ($ (SparseUnivariatePolynomial $) (Symbol)))): Improper first word in comments: 
"\\indented{1}{rootOf(p, \\spad{y)} returns \\spad{y} such that \\spad{p(y) = 0}.} \\indented{1}{The object returned displays as \\spad{'y}.} \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} rootOf(a,x)"

--->-->AlgebraicallyClosedField&((rootsOf ((List $) (Polynomial $)))): Improper first word in comments: 
"\\indented{1}{rootsOf(p) returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0}.} \\indented{1}{Note that the returned symbols y1,...,yn are bound in the} \\indented{1}{interpreter to respective root values.} \\indented{1}{Error: if \\spad{p} has more than one variable \\spad{y.}} \\blankline \\spad{X} \\spad{a:Polynomial(Integer):=-3*x^3+2*x+13} \\spad{X} rootsOf(a)"

--->-->AlgebraicallyClosedField&((rootsOf ((List $) (SparseUnivariatePolynomial $)))): Improper first word in comments: 
"\\indented{1}{rootsOf(p) returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0}.} \\indented{1}{Note that the returned symbols y1,...,yn are bound in the interpreter} \\indented{1}{to respective root values.} \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} rootsOf(a)"

--->-->AlgebraicallyClosedField&((rootsOf ((List $) (SparseUnivariatePolynomial $) (Symbol)))): Improper first word in comments: 
"\\indented{1}{rootsOf(p, \\spad{y)} returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0};} \\indented{1}{The returned roots display as \\spad{'y1},...,\\spad{'yn}.} \\indented{1}{Note that the returned symbols y1,...,yn are bound in the interpreter} \\indented{1}{to respective root values.} \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} rootsOf(a,x)"

--->-->AlgebraicallyClosedField&((zeroOf ($ (Polynomial $)))): Improper first word in comments: 
"\\indented{1}{zeroOf(p) returns \\spad{y} such that \\spad{p(y) = 0}.} \\indented{1}{If possible, \\spad{y} is expressed in terms of radicals.} \\indented{1}{Otherwise it is an implicit algebraic quantity.} \\indented{1}{Error: if \\spad{p} has more than one variable \\spad{y.}} \\blankline \\spad{X} \\spad{a:Polynomial(Integer):=-3*x^2+2*x-13} \\spad{X} zeroOf(a)"

--->-->AlgebraicallyClosedField&((zeroOf ($ (SparseUnivariatePolynomial $)))): Improper first word in comments: 
"\\indented{1}{zeroOf(p) returns \\spad{y} such that \\spad{p(y) = 0};} \\indented{1}{if possible, \\spad{y} is expressed in terms of radicals.} \\indented{1}{Otherwise it is an implicit algebraic quantity.} \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} zeroOf(a)"

--->-->AlgebraicallyClosedField&((zeroOf ($ (SparseUnivariatePolynomial $) (Symbol)))): Improper first word in comments: 
"\\indented{1}{zeroOf(p, \\spad{y)} returns \\spad{y} such that \\spad{p(y) = 0};} \\indented{1}{if possible, \\spad{y} is expressed in terms of radicals.} \\indented{1}{Otherwise it is an implicit algebraic quantity which} \\indented{1}{displays as \\spad{'y}.} \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} zeroOf(a,x)"

--->-->AlgebraicallyClosedField&((zerosOf ((List $) (Polynomial $)))): Improper first word in comments: 
"\\indented{1}{zerosOf(p) returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0}.} \\indented{1}{The yi's are expressed in radicals if possible.} \\indented{1}{Otherwise they are implicit algebraic quantities.} \\indented{1}{The returned symbols y1,...,yn are bound in the interpreter} \\indented{1}{to respective root values.} \\indented{1}{Error: if \\spad{p} has more than one variable \\spad{y.}} \\blankline \\spad{X} \\spad{a:Polynomial(Integer):=-3*x^2+2*x-13} \\spad{X} zerosOf(a)"

--->-->AlgebraicallyClosedField&((zerosOf ((List $) (SparseUnivariatePolynomial $)))): Improper first word in comments: 
"\\indented{1}{zerosOf(p) returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0}.} \\indented{1}{The yi's are expressed in radicals if possible, and otherwise} \\indented{1}{as implicit algebraic quantities.} \\indented{1}{The returned symbols y1,...,yn are bound in the interpreter} \\indented{1}{to respective root values.} \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} zerosOf(a)"

--->-->AlgebraicallyClosedField&((zerosOf ((List $) (SparseUnivariatePolynomial $) (Symbol)))): Improper first word in comments: 
"\\indented{1}{zerosOf(p, \\spad{y)} returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0}.} \\indented{1}{The yi's are expressed in radicals if possible, and otherwise} \\indented{1}{as implicit algebraic quantities} \\indented{1}{which display as \\spad{'yi}.} \\indented{1}{The returned symbols y1,...,yn are bound in the interpreter} \\indented{1}{to respective root values.} \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} zerosOf(a,x)"

--->bookvol10.2.pamphlet-->AlgebraicallyClosedField((rootOf ($ (Polynomial $)))): Improper first word in comments: 
"\\indented{1}{rootOf(p) returns \\spad{y} such that \\spad{p(y) = 0}.} \\indented{1}{Error: if \\spad{p} has more than one variable \\spad{y.}} \\blankline \\spad{X} \\spad{a:Polynomial(Integer):=-3*x^3+2*x+13} \\spad{X} rootOf(a)"

--->bookvol10.2.pamphlet-->AlgebraicallyClosedField((rootOf ($ (SparseUnivariatePolynomial $)))): Improper first word in comments: 
"\\indented{1}{rootOf(p) returns \\spad{y} such that \\spad{p(y) = 0}.} \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} rootOf(a)"

--->bookvol10.2.pamphlet-->AlgebraicallyClosedField((rootOf ($ (SparseUnivariatePolynomial $) (Symbol)))): Improper first word in comments: 
"\\indented{1}{rootOf(p, \\spad{y)} returns \\spad{y} such that \\spad{p(y) = 0}.} \\indented{1}{The object returned displays as \\spad{'y}.} \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} rootOf(a,x)"

--->bookvol10.2.pamphlet-->AlgebraicallyClosedField((rootsOf ((List $) (Polynomial $)))): Improper first word in comments: 
"\\indented{1}{rootsOf(p) returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0}.} \\indented{1}{Note that the returned symbols y1,...,yn are bound in the} \\indented{1}{interpreter to respective root values.} \\indented{1}{Error: if \\spad{p} has more than one variable \\spad{y.}} \\blankline \\spad{X} \\spad{a:Polynomial(Integer):=-3*x^3+2*x+13} \\spad{X} rootsOf(a)"

--->bookvol10.2.pamphlet-->AlgebraicallyClosedField((rootsOf ((List $) (SparseUnivariatePolynomial $)))): Improper first word in comments: 
"\\indented{1}{rootsOf(p) returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0}.} \\indented{1}{Note that the returned symbols y1,...,yn are bound in the interpreter} \\indented{1}{to respective root values.} \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} rootsOf(a)"

--->bookvol10.2.pamphlet-->AlgebraicallyClosedField((rootsOf ((List $) (SparseUnivariatePolynomial $) (Symbol)))): Improper first word in comments: 
"\\indented{1}{rootsOf(p, \\spad{y)} returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0};} \\indented{1}{The returned roots display as \\spad{'y1},...,\\spad{'yn}.} \\indented{1}{Note that the returned symbols y1,...,yn are bound in the interpreter} \\indented{1}{to respective root values.} \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} rootsOf(a,x)"

--->bookvol10.2.pamphlet-->AlgebraicallyClosedField((zeroOf ($ (Polynomial $)))): Improper first word in comments: 
"\\indented{1}{zeroOf(p) returns \\spad{y} such that \\spad{p(y) = 0}.} \\indented{1}{If possible, \\spad{y} is expressed in terms of radicals.} \\indented{1}{Otherwise it is an implicit algebraic quantity.} \\indented{1}{Error: if \\spad{p} has more than one variable \\spad{y.}} \\blankline \\spad{X} \\spad{a:Polynomial(Integer):=-3*x^2+2*x-13} \\spad{X} zeroOf(a)"

--->bookvol10.2.pamphlet-->AlgebraicallyClosedField((zeroOf ($ (SparseUnivariatePolynomial $)))): Improper first word in comments: 
"\\indented{1}{zeroOf(p) returns \\spad{y} such that \\spad{p(y) = 0};} \\indented{1}{if possible, \\spad{y} is expressed in terms of radicals.} \\indented{1}{Otherwise it is an implicit algebraic quantity.} \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} zeroOf(a)"

--->bookvol10.2.pamphlet-->AlgebraicallyClosedField((zeroOf ($ (SparseUnivariatePolynomial $) (Symbol)))): Improper first word in comments: 
"\\indented{1}{zeroOf(p, \\spad{y)} returns \\spad{y} such that \\spad{p(y) = 0};} \\indented{1}{if possible, \\spad{y} is expressed in terms of radicals.} \\indented{1}{Otherwise it is an implicit algebraic quantity which} \\indented{1}{displays as \\spad{'y}.} \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} zeroOf(a,x)"

--->bookvol10.2.pamphlet-->AlgebraicallyClosedField((zerosOf ((List $) (Polynomial $)))): Improper first word in comments: 
"\\indented{1}{zerosOf(p) returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0}.} \\indented{1}{The yi's are expressed in radicals if possible.} \\indented{1}{Otherwise they are implicit algebraic quantities.} \\indented{1}{The returned symbols y1,...,yn are bound in the interpreter} \\indented{1}{to respective root values.} \\indented{1}{Error: if \\spad{p} has more than one variable \\spad{y.}} \\blankline \\spad{X} \\spad{a:Polynomial(Integer):=-3*x^2+2*x-13} \\spad{X} zerosOf(a)"

--->bookvol10.2.pamphlet-->AlgebraicallyClosedField((zerosOf ((List $) (SparseUnivariatePolynomial $)))): Improper first word in comments: 
"\\indented{1}{zerosOf(p) returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0}.} \\indented{1}{The yi's are expressed in radicals if possible, and otherwise} \\indented{1}{as implicit algebraic quantities.} \\indented{1}{The returned symbols y1,...,yn are bound in the interpreter} \\indented{1}{to respective root values.} \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} zerosOf(a)"

--->bookvol10.2.pamphlet-->AlgebraicallyClosedField((zerosOf ((List $) (SparseUnivariatePolynomial $) (Symbol)))): Improper first word in comments: 
"\\indented{1}{zerosOf(p, \\spad{y)} returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0}.} \\indented{1}{The yi's are expressed in radicals if possible, and otherwise} \\indented{1}{as implicit algebraic quantities} \\indented{1}{which display as \\spad{'yi}.} \\indented{1}{The returned symbols y1,...,yn are bound in the interpreter} \\indented{1}{to respective root values.} \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} zerosOf(a,x)"

=========================================================================
typos 40137:

>compiling ACPLOT.spad to ACPLOT.nrlib

--->bookvol10.3.pamphlet-->PlaneAlgebraicCurvePlot((makeSketch (% (Polynomial (Integer)) (Symbol) (Symbol) (Segment (Fraction (Integer))) (Segment (Fraction (Integer)))))): Improper first word in comments: 
"\\indented{1}{makeSketch(p,x,y,a..b,c..d) creates an ACPLOT of the} \\indented{1}{curve \\spad{p = 0} in the region a \\spad{<=} \\spad{x} \\spad{<=} \\spad{b,} \\spad{c} \\spad{<=} \\spad{y} \\spad{<=} \\spad{d.}} \\indented{1}{More specifically, 'makeSketch' plots a non-singular algebraic curve} \\indented{1}{\\spad{p = 0} in an rectangular region xMin \\spad{<=} \\spad{x} \\spad{<=} xMax,} \\indented{1}{yMin \\spad{<=} \\spad{y} \\spad{<=} yMax. The user inputs} \\indented{1}{\\spad{makeSketch(p,x,y,xMin..xMax,yMin..yMax)}.} \\indented{1}{Here \\spad{p} is a polynomial in the variables \\spad{x} and \\spad{y} with} \\indented{1}{integer coefficients \\spad{(p} belongs to the domain} \\indented{1}{\\spad{Polynomial Integer}). The case} \\indented{1}{where \\spad{p} is a polynomial in only one of the variables is} \\indented{1}{allowed.\\space{2}The variables \\spad{x} and \\spad{y} are input to specify the} \\indented{1}{the coordinate axes.\\space{2}The horizontal axis is the x-axis and} \\indented{1}{the vertical axis is the y-axis.\\space{2}The rational numbers} \\indented{1}{xMin,...,yMax specify the boundaries of the region in} \\indented{1}{which the curve is to be plotted.} \\blankline \\spad{X} makeSketch(x+y,x,y,-1/2..1/2,-1/2..1/2)$ACPLOT"

--->bookvol10.3.pamphlet-->PlaneAlgebraicCurvePlot((refine (% % (DoubleFloat)))): Improper first word in comments: 
"\\indented{1}{refine(p,x) is not documented} \\blankline \\spad{X} sketch:=makeSketch(x+y,x,y,-1/2..1/2,-1/2..1/2)$ACPLOT \\spad{X} refined:=refine(sketch,0.1)"

=========================================================================
typos 40136:

>compiling ANTISYM.spad to ANTISYM.nrlib

--->bookvol10.3.pamphlet-->AntiSymm((retractable? ((Boolean) %))): Missing left brace
"\\spad{retractable?(p)} tests if \\spad{p} is a 0-form, \\spadignore{i.e.} if degree(p) = 0."

=========================================================================
typos 40135:

>compiling ATTRBUT.spad to ATTRBUT.nrlib

--->bookvol10.3.pamphlet-->AttributeButtons(constructor): Mismatch: left pren matches right brace
--->bookvol10.3.pamphlet-->AttributeButtons(constructor): Mismatch: left pren matches right brace
"\\axiomType{AttributeButtons} implements a database and associated adjustment mechanisms for a set of attributes. \\blankline For ODEs these attributes are \"stiffness\", \"stability\" (\\spadignore{i.e.} how much affect the cosine or sine component of the solution has on the stability of the result), \"accuracy\" and \"expense\" (\\spadignore{i.e.} how expensive is the evaluation of the ODE). All these have bearing on the cost of calculating the solution given that reducing the step-length to achieve greater accuracy requires considerable number of evaluations and calculations. \\blankline The effect of each of these attributes can be altered by increasing or decreasing the button value. \\blankline For Integration there is a button for increasing and decreasing the preset number of function evaluations for each method. This is automatically used by ANNA when a method fails due to insufficient workspace or where the limit of function evaluations has been reached before the required accuracy is achieved."

=========================================================================
typos 40134:

>compiling BLUPPACK.spad to BLUPPACK.nrlib

--->bookvol10.4.pamphlet-->BlowUpPackage((applyTransform (PolyRing PolyRing BLMET))): Improper first word in comments: quadTransform
"quadTransform(pol,chart) apply the quadratique transformation to pol specified by chart which consist of 3 integers. The last one indicates which varibles is set to 1, the first on indicates which variable remains unchange, and the second one indicates which variable oon which the transformation is applied. For example, [2,3,1] correspond to the following: \\spad{x} \\spad{->} 1, \\spad{y} \\spad{->} \\spad{y,} \\spad{z} \\spad{->} \\spad{yz} (here the variable are [x,y,z] in BlUpRing)."

--->bookvol10.4.pamphlet-->BlowUpPackage((newtonPolySlope ((List (List NNI)) BlUpRing))): Not documented!!!!
--->bookvol10.4.pamphlet-->BlowUpPackage((polyRingToBlUpRing (BlUpRing PolyRing BLMET))): Not documented!!!!
--->bookvol10.4.pamphlet-->BlowUpPackage((biringToPolyRing (PolyRing BlUpRing BLMET))): Not documented!!!!

=========================================================================
typos 40133:

>compiling BOP.spad to BOP.nrlib

--->bookvol10.3.pamphlet-->BasicOperator((assert ($ $ (String)))): Missing left brace
"\\spad{assert(op, \\spad{s)}} attaches property \\spad{s} to op. Argument \\spad{op} is modified \"in place\", \\spadignore{i.e.} no copy is made."

--->bookvol10.3.pamphlet-->BasicOperator((deleteProperty! ($ $ (String)))): Missing left brace
"\\spad{deleteProperty!(op, \\spad{s)}} unattaches property \\spad{s} from op. Argument \\spad{op} is modified \"in place\", \\spadignore{i.e.} no copy is made."

--->bookvol10.3.pamphlet-->BasicOperator((setProperty ($ $ (String) (None)))): Missing left brace
"\\spad{setProperty(op, \\spad{s,} \\spad{v)}} attaches property \\spad{s} to op, and sets its value to \\spad{v.} Argument \\spad{op} is modified \"in place\", \\spadignore{i.e.} no copy is made."

--->bookvol10.3.pamphlet-->BasicOperator((setProperties ($ $ P))): Missing left brace
"\\spad{setProperties(op, \\spad{l)}} sets the property list of \\spad{op} to \\spad{l.} Argument \\spad{op} is modified \"in place\", \\spadignore{i.e.} no copy is made."

=========================================================================
typos 40130:

>compiling FFCAT.spad to FFCAT.nrlib

--->-->FunctionFieldCategory&((numberOfComponents ((NonNegativeInteger)))): Improper first word in comments: 
"\\indented{1}{numberOfComponents() returns the number of absolutely irreducible} \\indented{1}{components.} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} numberOfComponents()$R"

--->-->FunctionFieldCategory&((genus ((NonNegativeInteger)))): Improper first word in comments: 
"\\indented{1}{genus() returns the genus of one absolutely irreducible component} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} genus()$R"

--->-->FunctionFieldCategory&((absolutelyIrreducible? ((Boolean)))): Improper first word in comments: 
"\\indented{1}{absolutelyIrreducible?() tests if the curve absolutely irreducible?} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R2} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 2 * x**2, 4) \\spad{X} \\spad{absolutelyIrreducible?()$R2}"

--->-->FunctionFieldCategory&((rationalPoint? ((Boolean) F F))): Improper first word in comments: 
"\\indented{1}{rationalPoint?(a, \\spad{b)} tests if \\spad{(x=a,y=b)} is on the curve.} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} rationalPoint?(0,0)$R \\spad{X} \\spad{R2} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 2 * x**2, 4) \\spad{X} \\spad{rationalPoint?(0,0)$R2}"

--->-->FunctionFieldCategory&((branchPointAtInfinity? ((Boolean)))): Improper first word in comments: 
"\\indented{1}{branchPointAtInfinity?() tests if there is a branch point} \\indented{1}{at infinity.} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} branchPointAtInfinity?()$R \\spad{X} \\spad{R2} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 2 * x**2, 4) \\spad{X} branchPointAtInfinity?()$R"

--->-->FunctionFieldCategory&((integralBasis ((Vector $)))): Improper first word in comments: 
"\\indented{1}{integralBasis() returns the integral basis for the curve.} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} integralBasis()$R"

--->-->FunctionFieldCategory&((integralBasisAtInfinity ((Vector $)))): Improper first word in comments: 
"\\indented{1}{integralBasisAtInfinity() returns the local integral basis} \\indented{1}{at infinity} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} integralBasisAtInfinity()$R"

--->-->FunctionFieldCategory&((integralMatrix ((Matrix RF)))): Improper first word in comments: 
"\\indented{1}{integralMatrix() returns \\spad{M} such that} \\indented{1}{\\spad{(w1,...,wn) = \\spad{M} \\spad{(1,} \\spad{y,} ..., y**(n-1))},} \\indented{1}{where \\spad{(w1,...,wn)} is the integral basis of} \\indented{1}{\\spadfunFrom{integralBasis}{FunctionFieldCategory}.} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} integralMatrix()$R"

--->-->FunctionFieldCategory&((inverseIntegralMatrix ((Matrix RF)))): Improper first word in comments: 
"\\indented{1}{inverseIntegralMatrix() returns \\spad{M} such that} \\indented{1}{\\spad{M (w1,...,wn) = \\spad{(1,} \\spad{y,} ..., y**(n-1))}} \\indented{1}{where \\spad{(w1,...,wn)} is the integral basis of} \\indented{1}{\\spadfunFrom{integralBasis}{FunctionFieldCategory}.} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} inverseIntegralMatrix()$R"

--->-->FunctionFieldCategory&((integralMatrixAtInfinity ((Matrix RF)))): Improper first word in comments: 
"\\indented{1}{integralMatrixAtInfinity() returns \\spad{M} such that} \\indented{1}{\\spad{(v1,...,vn) = \\spad{M} \\spad{(1,} \\spad{y,} ..., y**(n-1))}} \\indented{1}{where \\spad{(v1,...,vn)} is the local integral basis at infinity} \\indented{1}{returned by \\spad{infIntBasis()}.} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} integralMatrixAtInfinity()$R"

--->-->FunctionFieldCategory&((inverseIntegralMatrixAtInfinity ((Matrix RF)))): Improper first word in comments: 
"\\indented{1}{inverseIntegralMatrixAtInfinity() returns \\spad{M} such} \\indented{1}{that \\spad{M (v1,...,vn) = \\spad{(1,} \\spad{y,} ..., y**(n-1))}} \\indented{1}{where \\spad{(v1,...,vn)} is the local integral basis at infinity} \\indented{1}{returned by \\spad{infIntBasis()}.} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} inverseIntegralMatrixAtInfinity()$R"

--->-->FunctionFieldCategory&((rationalPoints ((List (List F))))): Improper first word in comments: 
"\\indented{1}{rationalPoints() returns the list of all the affine} rational points."

--->bookvol10.2.pamphlet-->FunctionFieldCategory((numberOfComponents ((NonNegativeInteger)))): Improper first word in comments: 
"\\indented{1}{numberOfComponents() returns the number of absolutely irreducible} \\indented{1}{components.} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} numberOfComponents()$R"

--->bookvol10.2.pamphlet-->FunctionFieldCategory((genus ((NonNegativeInteger)))): Improper first word in comments: 
"\\indented{1}{genus() returns the genus of one absolutely irreducible component} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} genus()$R"

--->bookvol10.2.pamphlet-->FunctionFieldCategory((absolutelyIrreducible? ((Boolean)))): Improper first word in comments: 
"\\indented{1}{absolutelyIrreducible?() tests if the curve absolutely irreducible?} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R2} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 2 * x**2, 4) \\spad{X} \\spad{absolutelyIrreducible?()$R2}"

--->bookvol10.2.pamphlet-->FunctionFieldCategory((rationalPoint? ((Boolean) F F))): Improper first word in comments: 
"\\indented{1}{rationalPoint?(a, \\spad{b)} tests if \\spad{(x=a,y=b)} is on the curve.} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} rationalPoint?(0,0)$R \\spad{X} \\spad{R2} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 2 * x**2, 4) \\spad{X} \\spad{rationalPoint?(0,0)$R2}"

--->bookvol10.2.pamphlet-->FunctionFieldCategory((branchPointAtInfinity? ((Boolean)))): Improper first word in comments: 
"\\indented{1}{branchPointAtInfinity?() tests if there is a branch point} \\indented{1}{at infinity.} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} branchPointAtInfinity?()$R \\spad{X} \\spad{R2} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 2 * x**2, 4) \\spad{X} branchPointAtInfinity?()$R"

--->bookvol10.2.pamphlet-->FunctionFieldCategory((integralBasis ((Vector $)))): Improper first word in comments: 
"\\indented{1}{integralBasis() returns the integral basis for the curve.} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} integralBasis()$R"

--->bookvol10.2.pamphlet-->FunctionFieldCategory((integralBasisAtInfinity ((Vector $)))): Improper first word in comments: 
"\\indented{1}{integralBasisAtInfinity() returns the local integral basis} \\indented{1}{at infinity} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} integralBasisAtInfinity()$R"

--->bookvol10.2.pamphlet-->FunctionFieldCategory((integralMatrix ((Matrix RF)))): Improper first word in comments: 
"\\indented{1}{integralMatrix() returns \\spad{M} such that} \\indented{1}{\\spad{(w1,...,wn) = \\spad{M} \\spad{(1,} \\spad{y,} ..., y**(n-1))},} \\indented{1}{where \\spad{(w1,...,wn)} is the integral basis of} \\indented{1}{\\spadfunFrom{integralBasis}{FunctionFieldCategory}.} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} integralMatrix()$R"

--->bookvol10.2.pamphlet-->FunctionFieldCategory((inverseIntegralMatrix ((Matrix RF)))): Improper first word in comments: 
"\\indented{1}{inverseIntegralMatrix() returns \\spad{M} such that} \\indented{1}{\\spad{M (w1,...,wn) = \\spad{(1,} \\spad{y,} ..., y**(n-1))}} \\indented{1}{where \\spad{(w1,...,wn)} is the integral basis of} \\indented{1}{\\spadfunFrom{integralBasis}{FunctionFieldCategory}.} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} inverseIntegralMatrix()$R"

--->bookvol10.2.pamphlet-->FunctionFieldCategory((integralMatrixAtInfinity ((Matrix RF)))): Improper first word in comments: 
"\\indented{1}{integralMatrixAtInfinity() returns \\spad{M} such that} \\indented{1}{\\spad{(v1,...,vn) = \\spad{M} \\spad{(1,} \\spad{y,} ..., y**(n-1))}} \\indented{1}{where \\spad{(v1,...,vn)} is the local integral basis at infinity} \\indented{1}{returned by \\spad{infIntBasis()}.} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} integralMatrixAtInfinity()$R"

--->bookvol10.2.pamphlet-->FunctionFieldCategory((inverseIntegralMatrixAtInfinity ((Matrix RF)))): Improper first word in comments: 
"\\indented{1}{inverseIntegralMatrixAtInfinity() returns \\spad{M} such} \\indented{1}{that \\spad{M (v1,...,vn) = \\spad{(1,} \\spad{y,} ..., y**(n-1))}} \\indented{1}{where \\spad{(v1,...,vn)} is the local integral basis at infinity} \\indented{1}{returned by \\spad{infIntBasis()}.} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} inverseIntegralMatrixAtInfinity()$R"

--->bookvol10.2.pamphlet-->FunctionFieldCategory((rationalPoints ((List (List F))))): Improper first word in comments: 
"\\indented{1}{rationalPoints() returns the list of all the affine} rational points."

=========================================================================
typos 40129:

>compiling FFCGP.spad to FFCGP.nrlib

--->bookvol10.3.pamphlet-->FiniteFieldCyclicGroupExtensionByPolynomial(constructor): Missing left brace
"FiniteFieldCyclicGroupExtensionByPolynomial(GF,defpol) implements a finite extension field of the ground field \\spad{GF.} Its elements are represented by powers of a primitive element, \\spadignore{i.e.} a generator of the multiplicative (cyclic) group. As primitive element we choose the root of the extension polynomial defpol, which MUST be primitive (user responsibility). Zech logarithms are stored in a table of size half of the field size, and use \\spadtype{SingleInteger} for representing field elements, hence, there are restrictions on the size of the field."

=========================================================================
typos 40128:

>compiling FFNBP.spad to FFNBP.nrlib
 
--->bookvol10.3.pamphlet-->FiniteFieldNormalBasisExtensionByPolynomial(constructor): Missing left brace
"FiniteFieldNormalBasisExtensionByPolynomial(GF,uni) implements a finite extension of the ground field \\spad{GF.} The elements are represented by coordinate vectors with respect to. a normal basis, \\spadignore{i.e.} a basis consisting of the conjugates (q-powers) of an element, in this case called normal element, where \\spad{q} is the size of \\spad{GF.} The normal element is chosen as a root of the extension polynomial, which MUST be normal over \\spad{GF} (user responsibility)"

=========================================================================
typos 40126:

>compiling FLOAT.spad to FLOAT.nrlib

--------(log2 (%))---------
--->bookvol10.3.pamphlet-->Float((log2 (%))): Missing left brace
"\\spad{log2()} returns \\spad{ln 2}, \\spadignore{i.e.} \\spad{0.6931471805...}."

--->bookvol10.3.pamphlet-->Float((outputFloating ((Void)))): Missing left brace
"\\spad{outputFloating()} sets the output mode to floating (scientific) notation, \\spadignore{i.e.} \\spad{mantissa * 10 exponent} is displayed as \\spad{0.mantissa \\spad{E} exponent}."

--->bookvol10.3.pamphlet-->Float(constructor): Not documented!!!!
--->bookvol10.3.pamphlet-->Float(): Missing Description


=========================================================================
typos 40125:

>compiling FR.spad to FR.nrlib

--->bookvol10.3.pamphlet-->Factored((expand (R %))): Improper first word in comments: 
"\\indented{1}{expand(f) multiplies the unit and factors together, yielding an} \\indented{1}{\"unfactored\" object. Note: this is purposely not called} \\indented{1}{\\spadfun{coerce} which would cause the interpreter to do this} \\indented{1}{automatically.} \\blankline \\spad{X} f:=nilFactor(y-x,3) \\spad{X} expand(f)"

--->bookvol10.3.pamphlet-->Factored((exponent ((Integer) %))): Improper first word in comments: 
"\\indented{1}{exponent(u) returns the exponent of the first factor of} \\indented{1}{\\spadvar{u}, or 0 if the factored form consists solely of a unit.} \\blankline \\spad{X} f:=nilFactor(y-x,3) \\spad{X} exponent(f)"

--->bookvol10.3.pamphlet-->Factored((makeFR (% R (List FF)))): Improper first word in comments: 
"\\indented{1}{makeFR(unit,listOfFactors) creates a factored object (for} \\indented{1}{use by factoring code).} \\blankline \\spad{X} f:=nilFactor(x-y,3) \\spad{X} g:=factorList \\spad{f} \\spad{X} makeFR(z,g)"

--->bookvol10.3.pamphlet-->Factored((factorList ((List FF) %))): Improper first word in comments: 
"\\indented{1}{factorList(u) returns the list of factors with flags (for} \\indented{1}{use by factoring code).} \\blankline \\spad{X} f:=nilFactor(x-y,3) \\spad{X} factorList \\spad{f}"

--->bookvol10.3.pamphlet-->Factored((nilFactor (% R (Integer)))): Improper first word in comments: 
"\\indented{1}{nilFactor(base,exponent) creates a factored object with} \\indented{1}{a single factor with no information about the kind of} \\indented{1}{base (flag = \"nil\").} \\blankline \\spad{X} nilFactor(24,2) \\spad{X} nilFactor(x-y,3)"

--->bookvol10.3.pamphlet-->Factored((factors ((List (Record (: factor R) (: exponent (Integer)))) %))): Improper first word in comments: 
"\\indented{1}{factors(u) returns a list of the factors in a form suitable} \\indented{1}{for iteration. That is, it returns a list where each element} \\indented{1}{is a record containing a base and exponent.\\space{2}The original} \\indented{1}{object is the product of all the factors and the unit (which} \\indented{1}{can be extracted by \\axiom{unit(u)}).} \\blankline \\spad{X} \\spad{f:=x*y^3-3*x^2*y^2+3*x^3*y-x^4} \\spad{X} factors \\spad{f} \\spad{X} g:=makeFR(z,factorList \\spad{f)} \\spad{X} factors \\spad{g}"

--->bookvol10.3.pamphlet-->Factored((irreducibleFactor (% R (Integer)))): Improper first word in comments: 
"\\indented{1}{irreducibleFactor(base,exponent) creates a factored object with} \\indented{1}{a single factor whose base is asserted to be irreducible} \\indented{1}{(flag = \"irred\").} \\blankline \\spad{X} a:=irreducibleFactor(3,1) \\spad{X} nthFlag(a,1)"

--->bookvol10.3.pamphlet-->Factored((nthExponent ((Integer) % (Integer)))): Improper first word in comments: 
"\\indented{1}{nthExponent(u,n) returns the exponent of the \\spad{n}th factor of} \\indented{1}{\\spadvar{u}.\\space{2}If \\spadvar{n} is not a valid index for a factor} \\indented{1}{(for example, less than 1 or too big), 0 is returned.} \\blankline \\spad{X} a:=factor 9720000 \\spad{X} nthExponent(a,2)"

--->bookvol10.3.pamphlet-->Factored((nthFactor (R % (Integer)))): Improper first word in comments: 
"\\indented{1}{nthFactor(u,n) returns the base of the \\spad{n}th factor of} \\indented{1}{\\spadvar{u}.\\space{2}If \\spadvar{n} is not a valid index for a factor} \\indented{1}{(for example, less than 1 or too big), 1 is returned.\\space{2}If} \\indented{1}{\\spadvar{u} consists only of a unit, the unit is returned.} \\blankline \\spad{X} a:=factor 9720000 \\spad{X} nthFactor(a,2)"

--->bookvol10.3.pamphlet-->Factored((nthFlag (fUnion % (Integer)))): Improper first word in comments: 
"\\indented{1}{nthFlag(u,n) returns the information flag of the \\spad{n}th factor of} \\indented{1}{\\spadvar{u}.\\space{2}If \\spadvar{n} is not a valid index for a factor} \\indented{1}{(for example, less than 1 or too big), \"nil\" is returned.} \\blankline \\spad{X} a:=factor 9720000 \\spad{X} nthFlag(a,2)"

--->bookvol10.3.pamphlet-->Factored((numberOfFactors ((NonNegativeInteger) %))): Improper first word in comments: 
"\\indented{1}{numberOfFactors(u) returns the number of factors in \\spadvar{u}.} \\blankline \\spad{X} a:=factor 9720000 \\spad{X} numberOfFactors a"

--->bookvol10.3.pamphlet-->Factored((primeFactor (% R (Integer)))): Improper first word in comments: 
"\\indented{1}{primeFactor(base,exponent) creates a factored object with} \\indented{1}{a single factor whose base is asserted to be prime} \\indented{1}{(flag = \"prime\").} \\blankline \\spad{X} a:=primeFactor(3,4) \\spad{X} nthFlag(a,1)"

--->bookvol10.3.pamphlet-->Factored((sqfrFactor (% R (Integer)))): Improper first word in comments: 
"\\indented{1}{sqfrFactor(base,exponent) creates a factored object with} \\indented{1}{a single factor whose base is asserted to be square-free} \\indented{1}{(flag = \"sqfr\").} \\blankline \\spad{X} a:=sqfrFactor(3,5) \\spad{X} nthFlag(a,1)"

--->bookvol10.3.pamphlet-->Factored((unit (R %))): Improper first word in comments: 
"\\indented{1}{unit(u) extracts the unit part of the factorization.} \\blankline \\spad{X} \\spad{f:=x*y^3-3*x^2*y^2+3*x^3*y-x^4} \\spad{X} unit \\spad{f} \\spad{X} g:=makeFR(z,factorList \\spad{f)} \\spad{X} unit \\spad{g}"

--->bookvol10.3.pamphlet-->Factored((map (% (Mapping R R) %))): Improper first word in comments: 
"\\indented{1}{map(fn,u) maps the function \\userfun{fn} across the factors of} \\indented{1}{\\spadvar{u} and creates a new factored object. Note: this clears} \\indented{1}{the information flags (sets them to \"nil\") because the effect of} \\indented{1}{\\userfun{fn} is clearly not known in general.} \\blankline \\spad{X} m(a:Factored Polynomial Integer):Factored Polynomial Integer \\spad{==} \\spad{a^2} \\spad{X} \\spad{f:=x*y^3-3*x^2*y^2+3*x^3*y-x^4} \\spad{X} map(m,f) \\spad{X} g:=makeFR(z,factorList \\spad{f)} \\spad{X} map(m,g)"

=========================================================================
typos 40124:

>compiling FRNAALG.spad to FRNAALG.nrlib

--->-->FramedNonAssociativeAlgebra&(constructor): Mismatch: left pren matches right brace
"FramedNonAssociativeAlgebra(R) is a \\spadtype{FiniteRankNonAssociativeAlgebra} (\\spadignore{i.e.} a non associative algebra over \\spad{R} which is a free \\spad{R}-module of finite rank) over a commutative ring \\spad{R} together with a fixed \\spad{R}-module basis."

--->bookvol10.2.pamphlet-->FramedNonAssociativeAlgebra(constructor): Mismatch: left pren matches right brace
"FramedNonAssociativeAlgebra(R) is a \\spadtype{FiniteRankNonAssociativeAlgebra} (\\spadignore{i.e.} a non associative algebra over \\spad{R} which is a free \\spad{R}-module of finite rank) over a commutative ring \\spad{R} together with a fixed \\spad{R}-module basis."

=========================================================================
typos 40121:

>compiling IDEAL.spad to IDEAL.nrlib

--->bookvol10.3.pamphlet-->PolynomialIdeals((one? ((Boolean) Ideal))): Missing left brace
"\\spad{one?(I)} tests whether the ideal \\spad{I} is the unit ideal, \\spadignore{i.e.} contains 1."

--->bookvol10.3.pamphlet-->PolynomialIdeals((zeroDim? ((Boolean) Ideal (List VarSet)))): Missing left brace
"\\spad{zeroDim?(I,lvar)} tests if the ideal \\spad{I} is zero dimensional, \\spadignore{i.e.} all its associated primes are maximal, in the ring \\spad{F[lvar]}"

--->bookvol10.3.pamphlet-->PolynomialIdeals((zeroDim? ((Boolean) Ideal))): Missing left brace
"\\spad{zeroDim?(I)} tests if the ideal \\spad{I} is zero dimensional, \\spadignore{i.e.} all its associated primes are maximal, in the ring \\spad{F[lvar]}, where lvar are the variables appearing in \\spad{I}"

=========================================================================
typos 40120:

>compiling INFCLCT.spad to INFCLCT.nrlib

--->bookvol10.2.pamphlet-->InfinitlyClosePointCategory((create (% ProjPt PolyRing))): Not documented!!!!
--->bookvol10.2.pamphlet-->InfinitlyClosePointCategory((setpoint! (ProjPt % ProjPt))): Not documented!!!!
--->bookvol10.2.pamphlet-->InfinitlyClosePointCategory((setcurve! (BlUpRing % BlUpRing))): Not documented!!!!
--->bookvol10.2.pamphlet-->InfinitlyClosePointCategory((setlocalPoint! (AFP % AFP))): Not documented!!!!
--->bookvol10.2.pamphlet-->InfinitlyClosePointCategory((setsubmult! ((NonNegativeInteger) % (NonNegativeInteger)))): Not documented!!!!
--->bookvol10.2.pamphlet-->InfinitlyClosePointCategory((setmult! ((NonNegativeInteger) % (NonNegativeInteger)))): Not documented!!!!
--->bookvol10.2.pamphlet-->InfinitlyClosePointCategory((setchart! (BLMET % BLMET))): Not documented!!!!
--->bookvol10.2.pamphlet-->InfinitlyClosePointCategory((setexcpDiv! (DIVISOR % DIVISOR))): Not documented!!!!
--->bookvol10.2.pamphlet-->InfinitlyClosePointCategory((setlocalParam! ((List PCS) % (List PCS)))): Not documented!!!!
--->bookvol10.2.pamphlet-->InfinitlyClosePointCategory((setsymbName! ((Symbol) % (Symbol)))): Not documented!!!!
--->bookvol10.2.pamphlet-->InfinitlyClosePointCategory((subMultV ((NonNegativeInteger) %))): Not documented!!!!
--->bookvol10.2.pamphlet-->InfinitlyClosePointCategory((localParamV ((List PCS) %))): Not documented!!!!
--->bookvol10.2.pamphlet-->InfinitlyClosePointCategory((symbNameV ((Symbol) %))): Not documented!!!!

--->bookvol10.2.pamphlet-->InfinitlyClosePointCategory((chartV (BLMET %))): Improper initial operator in comments: is
"chartV is the chart of the infinitly close point. The first integer correspond to variable defining the exceptional line, the last one the affine neighboorhood and the second one is the remaining integer. For example [1,2,3] means that Z=1, \\spad{X=X} and Y=XY. [2,3,1] means that X=1, \\spad{Y=Y} and Z=YZ."

--->bookvol10.2.pamphlet-->InfinitlyClosePointCategory((actualExtensionV (K %))): Not documented!!!!

=========================================================================
typos 40119:

>compiling INFORM.spad to INFORM.nrlib

--->bookvol10.3.pamphlet-->InputForm((binary (% % (List %)))): Improper first word in comments: 
"\\indented{1}{\\spad{binary(op, [a1,...,an])} returns the input form} \\indented{1}{corresponding \\spad{to\\space{2}\\spad{a1} op \\spad{a2} op \\spad{...} op an}.} \\blankline \\spad{X} a:=[1,2,3]::List(InputForm) \\spad{X} binary(_+::InputForm,a)"

=========================================================================
typos 40115:

>compiling NAGD02.spad to NAGD02.nrlib
 
--->bookvol10.4.pamphlet-->NagOrdinaryDifferentialEquationsPackage((d02kef ((Result) (Matrix (DoubleFloat)) (Integer) (Integer) (DoubleFloat) (Integer) (Integer) (DoubleFloat) (DoubleFloat) (Matrix (DoubleFloat)) (Integer) (Integer) (Union (: fn (FileName)) (: fp (Asp10 COEFFN))) (Union (: fn (FileName)) (: fp (Asp80 BDYVAL)))))): Missing close parenthesis on first line: d02kef(xpoint,m,k,tol,maxfun,match,elam,delam,
"d02kef(xpoint,m,k,tol,maxfun,match,elam,delam, \\indented{7}{hmax,maxit,ifail,coeffn,bdyval)} finds a specified eigenvalue of a regular singular second- order Sturm-Liouville system on a finite or infinite range, using a Pruefer transformation and a shooting method. It also reports values of the eigenfunction and its derivatives. Provision is made for discontinuities in the coefficient functions or their derivatives. See \\downlink{Manual Page}{manpageXXd02kef}. ASP domains \\spad{Asp12} and \\spad{Asp33} are used to supply default subroutines for the MONIT and REPORT arguments via their \\axiomOp{outputAsFortran} operation."

--->bookvol10.4.pamphlet-->NagOrdinaryDifferentialEquationsPackage((d02kef ((Result) (Matrix (DoubleFloat)) (Integer) (Integer) (DoubleFloat) (Integer) (Integer) (DoubleFloat) (DoubleFloat) (Matrix (DoubleFloat)) (Integer) (Integer) (Union (: fn (FileName)) (: fp (Asp10 COEFFN))) (Union (: fn (FileName)) (: fp (Asp80 BDYVAL))) (FileName) (FileName)))): Missing close parenthesis on first line: d02kef(xpoint,m,k,tol,maxfun,match,elam,delam,
"d02kef(xpoint,m,k,tol,maxfun,match,elam,delam, \\indented{7}{hmax,maxit,ifail,coeffn,bdyval,monit,report)} finds a specified eigenvalue of a regular singular second- order Sturm-Liouville system on a finite or infinite range, using a Pruefer transformation and a shooting method. It also reports values of the eigenfunction and its derivatives. Provision is made for discontinuities in the coefficient functions or their derivatives. See \\downlink{Manual Page}{manpageXXd02kef}. Files \\spad{monit} and \\spad{report} will be used to define the subroutines for the MONIT and REPORT arguments. See \\downlink{Manual Page}{manpageXXd02gbf}."

--->bookvol10.4.pamphlet-->NagOrdinaryDifferentialEquationsPackage((d02raf ((Result) (Integer) (Integer) (Integer) (Integer) (DoubleFloat) (Integer) (Integer) (Integer) (Integer) (Integer) (Integer) (Matrix (DoubleFloat)) (Matrix (DoubleFloat)) (DoubleFloat) (Integer) (Union (: fn (FileName)) (: fp (Asp41 FCN JACOBF JACEPS))) (Union (: fn (FileName)) (: fp (Asp42 G JACOBG JACGEP)))))): Missing close parenthesis on first line: d02raf(n,mnp,numbeg,nummix,tol,init,iy,ijac,lwork,
"d02raf(n,mnp,numbeg,nummix,tol,init,iy,ijac,lwork, \\indented{7}{liwork,np,x,y,deleps,ifail,fcn,g)} solves the two-point boundary-value problem with general boundary conditions for a system of ordinary differential equations, using a deferred correction technique and Newton iteration. See \\downlink{Manual Page}{manpageXXd02raf}."

=========================================================================
typos 40114:

>compiling NAGD03.spad to NAGD03.nrlib
 
--->bookvol10.4.pamphlet-->NagPartialDifferentialEquationsPackage((d03faf ((Result) (DoubleFloat) (DoubleFloat) (Integer) (Integer) (Matrix (DoubleFloat)) (Matrix (DoubleFloat)) (DoubleFloat) (DoubleFloat) (Integer) (Integer) (Matrix (DoubleFloat)) (Matrix (DoubleFloat)) (DoubleFloat) (DoubleFloat) (Integer) (Integer) (Matrix (DoubleFloat)) (Matrix (DoubleFloat)) (DoubleFloat) (Integer) (Integer) (Integer) (ThreeDimensionalMatrix (DoubleFloat)) (Integer)))): Missing close parenthesis on first line: d03faf(xs,xf,l,lbdcnd,bdxs,bdxf,ys,yf,m,mbdcnd,bdys,bdyf,zs,
"d03faf(xs,xf,l,lbdcnd,bdxs,bdxf,ys,yf,m,mbdcnd,bdys,bdyf,zs, \\indented{7}{zf,n,nbdcnd,bdzs,bdzf,lambda,ldimf,mdimf,lwrk,f,ifail)} solves the Helmholtz equation in Cartesian co-ordinates in three dimensions using the standard seven-point finite difference approximation. This routine is designed to be particularly efficient on vector processors. See \\downlink{Manual Page}{manpageXXd03faf}."

=========================================================================
typos 40113:

>compiling NAGE02.spad to NAGE02.nrlib

--->bookvol10.4.pamphlet-->NagFittingPackage(constructor): Mismatch: left pren matches right brace
"This package uses the NAG Library to find a function which approximates a set of data points. Typically the data contain random errors, as of experimental measurement, which need to be smoothed out. To seek an approximation to the data, it is first necessary to specify for the approximating function a mathematical form (a polynomial, for example) which contains a number of unspecified coefficients: the appropriate fitting routine then derives for the coefficients the values which provide the best fit of that particular form. The package deals mainly with curve and surface fitting (\\spadignore{i.e.} fitting with functions of one and of two variables) when a polynomial or a cubic spline is used as the fitting function, since these cover the most common needs. However, fitting with other functions and/or more variables can be undertaken by means of general linear or nonlinear routines (some of which are contained in other packages) depending on whether the coefficients in the function occur linearly or nonlinearly. Cases where a graph rather than a set of data points is given can be treated simply by first reading a suitable set of points from the graph. The package also contains routines for evaluating, differentiating and integrating polynomial and spline curves and surfaces, once the numerical values of their coefficients have been determined."

=========================================================================
typos 40112:

>compiling NAGE04.spad to NAGE04.nrlib
 
--->bookvol10.4.pamphlet-->NagOptimisationPackage((e04mbf ((Result) (Integer) (Integer) (Integer) (Integer) (Integer) (Integer) (Matrix (DoubleFloat)) (Matrix (DoubleFloat)) (Matrix (DoubleFloat)) (Matrix (DoubleFloat)) (Boolean) (Integer) (Integer) (Matrix (DoubleFloat)) (Integer)))): Missing close parenthesis on first line: e04mbf(itmax,msglvl,n,nclin,nctotl,nrowa,a,bl,bu,
"e04mbf(itmax,msglvl,n,nclin,nctotl,nrowa,a,bl,bu, \\indented{7}{cvec,linobj,liwork,lwork,x,ifail)} is an easy-to-use routine for solving linear programming problems, or for finding a feasible point for such problems. It is not intended for large sparse problems. See \\downlink{Manual Page}{manpageXXe04mbf}."

--->bookvol10.4.pamphlet-->NagOptimisationPackage((e04naf ((Result) (Integer) (Integer) (Integer) (Integer) (Integer) (Integer) (Integer) (Integer) (DoubleFloat) (Matrix (DoubleFloat)) (Matrix (DoubleFloat)) (Matrix (DoubleFloat)) (Matrix (DoubleFloat)) (Matrix (DoubleFloat)) (Matrix (DoubleFloat)) (Boolean) (Boolean) (Boolean) (Integer) (Integer) (Matrix (DoubleFloat)) (Matrix (Integer)) (Integer) (Union (: fn (FileName)) (: fp (Asp20 QPHESS)))))): Missing close parenthesis on first line: e04naf(itmax,msglvl,n,nclin,nctotl,nrowa,nrowh,ncolh,bigbnd,a,bl,
"e04naf(itmax,msglvl,n,nclin,nctotl,nrowa,nrowh,ncolh,bigbnd,a,bl, bu,cvec,featol,hess,cold,lpp,orthog,liwork,lwork,x,istate,ifail,qphess) is a comprehensive programming (QP) or linear programming (LP) problems. It is not intended for large sparse problems. See \\downlink{Manual Page}{manpageXXe04naf}."

--->bookvol10.4.pamphlet-->NagOptimisationPackage((e04ucf ((Result) (Integer) (Integer) (Integer) (Integer) (Integer) (Integer) (Matrix (DoubleFloat)) (Matrix (DoubleFloat)) (Matrix (DoubleFloat)) (Integer) (Integer) (Boolean) (DoubleFloat) (Integer) (DoubleFloat) (DoubleFloat) (Boolean) (DoubleFloat) (DoubleFloat) (DoubleFloat) (DoubleFloat) (Boolean) (Integer) (Integer) (Integer) (Integer) (Integer) (DoubleFloat) (DoubleFloat) (DoubleFloat) (Integer) (Integer) (Integer) (Integer) (Integer) (Matrix (Integer)) (Matrix (DoubleFloat)) (Matrix (DoubleFloat)) (Matrix (DoubleFloat)) (Matrix (DoubleFloat)) (Integer) (Union (: fn (FileName)) (: fp (Asp55 CONFUN))) (Union (: fn (FileName)) (: fp (Asp49 OBJFUN)))))): Missing close parenthesis on first line: e04ucf(n,nclin,ncnln,nrowa,nrowj,nrowr,a,bl,bu,liwork,lwork,sta,
"e04ucf(n,nclin,ncnln,nrowa,nrowj,nrowr,a,bl,bu,liwork,lwork,sta, \\indented{7}{cra,der,fea,fun,hes,infb,infs,linf,lint,list,maji,majp,mini,} \\indented{7}{minp,mon,nonf,opt,ste,stao,stac,stoo,stoc,ve,istate,cjac,} \\indented{7}{clamda,r,x,ifail,confun,objfun)} is designed to minimize an arbitrary smooth function subject to constraints on the variables, linear constraints. (E04UCF may be used for unconstrained, bound-constrained and linearly constrained optimization.) The user must provide subroutines that define the objective and constraint functions and as many of their first partial derivatives as possible. Unspecified derivatives are approximated by finite differences. All matrices are treated as dense, and hence E04UCF is not intended for large sparse problems. See \\downlink{Manual Page}{manpageXXe04ucf}."

=========================================================================
typos 70111:

>compiling NSDPS.spad to NSDPS.nrlib
 
--->bookvol10.3.pamphlet-->NeitherSparseOrDensePowerSeries((findTerm (TERM % (Integer)))): Not documented!!!!
--------constructor---------

=========================================================================
typos 40110:

>compiling OC.spad to OC.nrlib

--->-->OctonionCategory&((rational? ((Boolean) %))): Missing left brace
"\\spad{rational?(o)} tests if \\spad{o} is rational, \\spadignore{i.e.} that all seven imaginary parts are 0."

--->bookvol10.2.pamphlet-->OctonionCategory((rational? ((Boolean) %))): Missing left brace
"\\spad{rational?(o)} tests if \\spad{o} is rational, \\spadignore{i.e.} that all seven imaginary parts are 0."

=========================================================================
typos 40109:

>compiling ODEPACK.spad to ODEPACK.nrlib

--->bookvol10.4.pamphlet-->AnnaOrdinaryDifferentialEquationPackage((solve ((Result) (NumericalODEProblem)))): Missing left brace
--->bookvol10.4.pamphlet-->AnnaOrdinaryDifferentialEquationPackage((solve ((Result) (NumericalODEProblem)))): Missing left brace
"\\spad{solve(odeProblem)} is a top level ANNA function to solve numerically a system of ordinary differential equations \\spadignore{i.e.} equations for the derivatives y[1]'..y[n]' defined in terms of x,y[1]..y[n], together with starting values for \\spad{x} and y[1]..y[n] (called the initial conditions), a final value of \\spad{x,} an accuracy requirement and any intermediate points at which the result is required. \\blankline It iterates over the \\axiom{domains} of \\axiomType{OrdinaryDifferentialEquationsSolverCategory} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline The method used to perform the numerical process will be one of the routines contained in the NAG numerical Library. The function predicts the likely most effective routine by checking various attributes of the system of ODE's and calculating a measure of compatibility of each routine to these attributes. \\blankline It then calls the resulting `best' routine."

--->bookvol10.4.pamphlet-->AnnaOrdinaryDifferentialEquationPackage((solve ((Result) (NumericalODEProblem) RT))): Missing left brace
--->bookvol10.4.pamphlet-->AnnaOrdinaryDifferentialEquationPackage((solve ((Result) (NumericalODEProblem) RT))): Missing left brace
"\\spad{solve(odeProblem,R)} is a top level ANNA function to solve numerically a system of ordinary differential equations \\spadignore{i.e.} equations for the derivatives y[1]'..y[n]' defined in terms of x,y[1]..y[n], together with starting values for \\spad{x} and y[1]..y[n] (called the initial conditions), a final value of \\spad{x,} an accuracy requirement and any intermediate points at which the result is required. \\blankline It iterates over the \\axiom{domains} of \\axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in the table of routines \\axiom{R} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline The method used to perform the numerical process will be one of the routines contained in the NAG numerical Library. The function predicts the likely most effective routine by checking various attributes of the system of ODE's and calculating a measure of compatibility of each routine to these attributes. \\blankline It then calls the resulting `best' routine."

--->bookvol10.4.pamphlet-->AnnaOrdinaryDifferentialEquationPackage((solve ((Result) VEF F F LF))): Missing left brace
--->bookvol10.4.pamphlet-->AnnaOrdinaryDifferentialEquationPackage((solve ((Result) VEF F F LF))): Missing left brace
"\\spad{solve(f,xStart,xEnd,yInitial)} is a top level ANNA function to solve numerically a system of ordinary differential equations \\spadignore{i.e.} equations for the derivatives y[1]'..y[n]' defined in terms of x,y[1]..y[n], together with a starting value for \\spad{x} and y[1]..y[n] (called the initial conditions) and a final value of \\spad{x.} A default value is used for the accuracy requirement. \\blankline It iterates over the \\axiom{domains} of \\axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in the table of routines \\axiom{R} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline The method used to perform the numerical process will be one of the routines contained in the NAG numerical Library. The function predicts the likely most effective routine by checking various attributes of the system of ODE's and calculating a measure of compatibility of each routine to these attributes. \\blankline It then calls the resulting `best' routine."

--->bookvol10.4.pamphlet-->AnnaOrdinaryDifferentialEquationPackage((solve ((Result) VEF F F LF F))): Missing left brace
--->bookvol10.4.pamphlet-->AnnaOrdinaryDifferentialEquationPackage((solve ((Result) VEF F F LF F))): Missing left brace
"\\spad{solve(f,xStart,xEnd,yInitial,tol)} is a top level ANNA function to solve numerically a system of ordinary differential equations, \\axiom{f}, \\spadignore{i.e.} equations for the derivatives y[1]'..y[n]' defined in terms of x,y[1]..y[n] from \\axiom{xStart} to \\axiom{xEnd} with the initial values for y[1]..y[n] (\\axiom{yInitial}) to a tolerance \\axiom{tol}. \\blankline It iterates over the \\axiom{domains} of \\axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in the table of routines \\axiom{R} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline The method used to perform the numerical process will be one of the routines contained in the NAG numerical Library. The function predicts the likely most effective routine by checking various attributes of the system of ODE's and calculating a measure of compatibility of each routine to these attributes. \\blankline It then calls the resulting `best' routine."

--->bookvol10.4.pamphlet-->AnnaOrdinaryDifferentialEquationPackage((solve ((Result) VEF F F LF EF F))): Missing left brace
--->bookvol10.4.pamphlet-->AnnaOrdinaryDifferentialEquationPackage((solve ((Result) VEF F F LF EF F))): Missing left brace
"\\spad{solve(f,xStart,xEnd,yInitial,G,tol)} is a top level ANNA function to solve numerically a system of ordinary differential equations, \\axiom{f}, \\spadignore{i.e.} equations for the derivatives y[1]'..y[n]' defined in terms of x,y[1]..y[n] from \\axiom{xStart} to \\axiom{xEnd} with the initial values for y[1]..y[n] (\\axiom{yInitial}) to a tolerance \\axiom{tol}. The calculation will stop if the function G(x,y[1],..,y[n]) evaluates to zero before \\spad{x} = xEnd. \\blankline It iterates over the \\axiom{domains} of \\axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in the table of routines \\axiom{R} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline The method used to perform the numerical process will be one of the routines contained in the NAG numerical Library. The function predicts the likely most effective routine by checking various attributes of the system of ODE's and calculating a measure of compatibility of each routine to these attributes. \\blankline It then calls the resulting `best' routine."

--->bookvol10.4.pamphlet-->AnnaOrdinaryDifferentialEquationPackage((solve ((Result) VEF F F LF LF F))): Missing left brace
--->bookvol10.4.pamphlet-->AnnaOrdinaryDifferentialEquationPackage((solve ((Result) VEF F F LF LF F))): Missing left brace
"\\spad{solve(f,xStart,xEnd,yInitial,intVals,tol)} is a top level ANNA function to solve numerically a system of ordinary differential equations, \\axiom{f}, \\spadignore{i.e.} equations for the derivatives y[1]'..y[n]' defined in terms of x,y[1]..y[n] from \\axiom{xStart} to \\axiom{xEnd} with the initial values for y[1]..y[n] (\\axiom{yInitial}) to a tolerance \\axiom{tol}. The values of y[1]..y[n] will be output for the values of \\spad{x} in \\axiom{intVals}. \\blankline It iterates over the \\axiom{domains} of \\axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in the table of routines \\axiom{R} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline The method used to perform the numerical process will be one of the routines contained in the NAG numerical Library. The function predicts the likely most effective routine by checking various attributes of the system of ODE's and calculating a measure of compatibility of each routine to these attributes. \\blankline It then calls the resulting `best' routine."

--->bookvol10.4.pamphlet-->AnnaOrdinaryDifferentialEquationPackage((solve ((Result) VEF F F LF EF LF F))): Missing left brace
--->bookvol10.4.pamphlet-->AnnaOrdinaryDifferentialEquationPackage((solve ((Result) VEF F F LF EF LF F))): Missing left brace
"\\spad{solve(f,xStart,xEnd,yInitial,G,intVals,tol)} is a top level ANNA function to solve numerically a system of ordinary differential equations, \\axiom{f}, \\spadignore{i.e.} equations for the derivatives y[1]'..y[n]' defined in terms of x,y[1]..y[n] from \\axiom{xStart} to \\axiom{xEnd} with the initial values for y[1]..y[n] (\\axiom{yInitial}) to a tolerance \\axiom{tol}. The values of y[1]..y[n] will be output for the values of \\spad{x} in \\axiom{intVals}. The calculation will stop if the function G(x,y[1],..,y[n]) evaluates to zero before \\spad{x} = xEnd. \\blankline It iterates over the \\axiom{domains} of \\axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in the table of routines \\axiom{R} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline The method used to perform the numerical process will be one of the routines contained in the NAG numerical Library. The function predicts the likely most effective routine by checking various attributes of the system of ODE's and calculating a measure of compatibility of each routine to these attributes. \\blankline It then calls the resulting `best' routine."

--->bookvol10.4.pamphlet-->AnnaOrdinaryDifferentialEquationPackage((solve ((Result) VEF F F LF EF LF F F))): Missing left brace
--->bookvol10.4.pamphlet-->AnnaOrdinaryDifferentialEquationPackage((solve ((Result) VEF F F LF EF LF F F))): Missing left brace
"\\spad{solve(f,xStart,xEnd,yInitial,G,intVals,epsabs,epsrel)} is a top level ANNA function to solve numerically a system of ordinary differential equations, \\axiom{f}, \\spadignore{i.e.} equations for the derivatives y[1]'..y[n]' defined in terms of x,y[1]..y[n] from \\axiom{xStart} to \\axiom{xEnd} with the initial values for y[1]..y[n] (\\axiom{yInitial}) to an absolute error requirement \\axiom{epsabs} and relative error \\axiom{epsrel}. The values of y[1]..y[n] will be output for the values of \\spad{x} in \\axiom{intVals}. The calculation will stop if the function G(x,y[1],..,y[n]) evaluates to zero before \\spad{x} = xEnd. \\blankline It iterates over the \\axiom{domains} of \\axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in the table of routines \\axiom{R} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline The method used to perform the numerical process will be one of the routines contained in the NAG numerical Library. The function predicts the likely most effective routine by checking various attributes of the system of ODE's and calculating a measure of compatibility of each routine to these attributes. \\blankline It then calls the resulting `best' routine."

--->bookvol10.4.pamphlet-->AnnaOrdinaryDifferentialEquationPackage((measure (Measure (NumericalODEProblem)))): Missing left brace
"\\spad{measure(prob)} is a top level ANNA function for identifying the most appropriate numerical routine from those in the routines table provided for solving the numerical ODE problem defined by \\axiom{prob}. \\blankline It calls each \\axiom{domain} of \\axiom{category} \\axiomType{OrdinaryDifferentialEquationsSolverCategory} in turn to calculate all measures and returns the best \\spadignore{i.e.} the name of the most appropriate domain and any other relevant information. It predicts the likely most effective NAG numerical Library routine to solve the input set of ODEs by checking various attributes of the system of ODEs and calculating a measure of compatibility of each routine to these attributes."

--->bookvol10.4.pamphlet-->AnnaOrdinaryDifferentialEquationPackage((measure (Measure (NumericalODEProblem) RT))): Missing left brace
"\\spad{measure(prob,R)} is a top level ANNA function for identifying the most appropriate numerical routine from those in the routines table provided for solving the numerical ODE problem defined by \\axiom{prob}. \\blankline It calls each \\axiom{domain} listed in \\axiom{R} of \\axiom{category} \\axiomType{OrdinaryDifferentialEquationsSolverCategory} in turn to calculate all measures and returns the best \\spadignore{i.e.} the name of the most appropriate domain and any other relevant information. It predicts the likely most effective NAG numerical Library routine to solve the input set of ODEs by checking various attributes of the system of ODEs and calculating a measure of compatibility of each routine to these attributes."

=========================================================================
typos 40108:

>compiling OPTPACK.spad to OPTPACK.nrlib
 
--->bookvol10.4.pamphlet-->AnnaNumericalOptimizationPackage((measure (Measure (NumericalOptimizationProblem)))): Missing left brace
"\\spad{measure(prob)} is a top level ANNA function for identifying the most appropriate numerical routine from those in the routines table provided for solving the numerical optimization problem defined by \\axiom{prob} by checking various attributes of the functions and calculating a measure of compatibility of each routine to these attributes. \\blankline It calls each \\axiom{domain} of \\axiom{category} \\axiomType{NumericalOptimizationCategory} in turn to calculate all measures and returns the best \\spadignore{i.e.} the name of the most appropriate domain and any other relevant information."

--->bookvol10.4.pamphlet-->AnnaNumericalOptimizationPackage((measure (Measure (NumericalOptimizationProblem) RT))): Missing left brace
"\\spad{measure(prob,R)} is a top level ANNA function for identifying the most appropriate numerical routine from those in the routines table provided for solving the numerical optimization problem defined by \\axiom{prob} by checking various attributes of the functions and calculating a measure of compatibility of each routine to these attributes. \\blankline It calls each \\axiom{domain} listed in \\axiom{R} of \\axiom{category} \\axiomType{NumericalOptimizationCategory} in turn to calculate all measures and returns the best \\spadignore{i.e.} the name of the most appropriate domain and any other relevant information."

--->bookvol10.4.pamphlet-->AnnaNumericalOptimizationPackage((optimize ((Result) LEF LF))): Missing left brace
"\\spad{optimize(lf,start)} is a top level ANNA function to minimize a set of functions, \\axiom{lf}, of one or more variables without constraints \\spadignore{i.e.} a least-squares problem. \\blankline The parameter \\axiom{start} is a list of the initial guesses of the values of the variables. \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalOptimizationCategory} to get the name and other relevant information of the best \\axiom{measure} and then optimize the function on that \\axiom{domain}."

--->bookvol10.4.pamphlet-->AnnaNumericalOptimizationPackage((goodnessOfFit ((Result) LEF LF))): Missing left brace
"\\spad{goodnessOfFit(lf,start)} is a top level ANNA function to check to goodness of fit of a least squares model \\spadignore{i.e.} the minimization of a set of functions, \\axiom{lf}, of one or more variables without constraints. \\blankline The parameter \\axiom{start} is a list of the initial guesses of the values of the variables. \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalOptimizationCategory} to get the name and other relevant information of the best \\axiom{measure} and then optimize the function on that \\axiom{domain}. It then calls the numerical routine \\axiomType{E04YCF} to get estimates of the variance-covariance matrix of the regression coefficients of the least-squares problem. \\blankline It thus returns both the results of the optimization and the variance-covariance calculation. goodnessOfFit(lf,start) is a top level function to iterate over the \\axiom{domains} of \\axiomType{NumericalOptimizationCategory} to get the name and other relevant information of the best \\axiom{measure} and then optimize the function on that \\axiom{domain}. It then checks the goodness of fit of the least squares model."

=========================================================================
typos 40107:

>compiling PACOFF.spad to PACOFF.nrlib
 
--->bookvol10.3.pamphlet-->PseudoAlgebraicClosureOfFiniteField((fullOutput ((OutputForm) %))): Not documented!!!!


=========================================================================
typos 40106:

>compiling PACRAT.spad to PACRAT.nrlib

--->bookvol10.3.pamphlet-->PseudoAlgebraicClosureOfRationalNumber((fullOutput ((OutputForm) %))): Not documented!!!!
--->bookvol10.3.pamphlet-->PseudoAlgebraicClosureOfRationalNumber((newElement (% (SUP %) (SUP %) PI % (Symbol)))): Not documented!!!!

=========================================================================
typos 40105:

>compiling PATTERN.spad to PATTERN.nrlib
 
--->bookvol10.3.pamphlet-->Pattern((inR? (B %))): Mismatch: left pren matches right brace
"\\spad{inR?(p)} tests if \\spad{p} is an atom (\\spadignore{i.e.} an element of \\spad{R).}"

=========================================================================
typos 40104:

>compiling POLY.spad to POLY.nrlib

--->bookvol10.3.pamphlet-->Polynomial((integrate (% % (Symbol)))): Missing left brace
"\\spad{integrate(p,x)} computes the integral of \\spad{p*dx}, \\spadignore{i.e.} integrates the polynomial \\spad{p} with respect to the variable \\spad{x.}"

=========================================================================
typos 40103:

>compiling QEQUAT.spad to QEQUAT.nrlib

--->bookvol10.3.pamphlet-->QueryEquation((variable ((Symbol) %))): Mismatch: left pren matches right brace
"\\spad{variable(q)} returns the variable (\\spadignore{i.e.} left hand side) of \\axiom{q}."

--->bookvol10.3.pamphlet-->QueryEquation((value ((String) %))): Mismatch: left pren matches right brace
"\\spad{value(q)} returns the value (\\spadignore{i.e.} right hand side) of \\axiom{q}."

=========================================================================
typos 40102:

>compiling REP1.spad to REP1.nrlib
 
--->bookvol10.4.pamphlet-->RepresentationPackage1(constructor): Missing left brace
"\\spad{RepresentationPackage1} provides functions for representation theory for finite groups and algebras. The package creates permutation representations and uses tensor products and its symmetric and antisymmetric components to create new representations of larger degree from given ones. Note that instead of having parameters from \\spadtype{Permutation} this package allows list notation of permutations as well: \\spadignore{e.g.} \\spad{[1,4,3,2]} denotes permutes 2 and 4 and fixes 1 and 3."

=========================================================================
typos 40096:

>compiling SAOS.spad to SAOS.nrlib

--->bookvol10.3.pamphlet-->SingletonAsOrderedSet((create (%))): Not documented!!!!
--->bookvol10.3.pamphlet-->SingletonAsOrderedSet((convert ((Symbol) %))): Not documented!!!!

=========================================================================
typos 40094:

>compiling ALGPKG.spad to ALGPKG.nrlib

--->bookvol10.4.pamphlet-->AlgebraPackage((basisOfCentroid ((List (Matrix R))))): Missing left brace
"\\spad{basisOfCentroid()} returns a basis of the centroid, \\spadignore{i.e.} the endomorphism ring of \\spad{A} considered as \\spad{(A,A)}-bimodule."

=========================================================================
typos 40091:

>compiling APPRULE.spad to APPRULE.nrlib
 
--->bookvol10.4.pamphlet-->ApplyRules((applyRules (F (List RR) F))): Missing left brace
"\\spad{applyRules([r1,...,rn], expr)} applies the rules r1,...,rn to \\spad{f} an unlimited number of times, \\spadignore{i.e.} until none of r1,...,rn is applicable to the expression."

=========================================================================
typos 40090:

>compiling CDFMAT.spad to CDFMAT.nrlib

--->bookvol10.3.pamphlet-->ComplexDoubleFloatMatrix((qnew (% (Integer) (Integer)))): Improper first word in comments: 
"\\indented{1}{qnew(n, \\spad{m)} creates a new uninitialized \\spad{n} by \\spad{m} matrix.} \\blankline \\spad{X} t1:CDFMAT:=qnew(3,4)"

=========================================================================
typos 40089:

>compiling CDFVEC.spad to CDFVEC.nrlib

--->bookvol10.3.pamphlet-->ComplexDoubleFloatVector((qnew (% (Integer)))): Improper first word in comments: 
"\\indented{1}{qnew(n) creates a new uninitialized vector of length \\spad{n.}} \\blankline \\spad{X} t1:CDFVEC:=qnew 7"

--->bookvol10.3.pamphlet-->ComplexDoubleFloatVector((vector (% (List (Complex (DoubleFloat)))))): Improper first word in comments: 
"\\indented{1}{vector(l) converts the list \\spad{l} to a vector.} \\blankline \\spad{X} t1:List(Complex(DoubleFloat)):=[1+2*\\%i,3+4*\\%i,-5-6*\\%i] \\spad{X} t2:CDFVEC:=vector(t1)"

=========================================================================
typos 40088:

>compiling COMBF.spad to COMBF.nrlib

--->bookvol10.4.pamphlet-->CombinatorialFunction((binomial (F F F))): Improper first word in comments: 
--->bookvol10.4.pamphlet-->CombinatorialFunction((binomial (F F F))): Missing left brace
"\\indented{1}{binomial(n, \\spad{r)} returns the number of subsets of \\spad{r} objects} \\indented{1}{taken among \\spad{n} objects, \\spadignore{i.e.} n!/(r! * (n-r)!);} \\blankline \\spad{X} [binomial(5,i) for \\spad{i} in 0..5]"

--->bookvol10.4.pamphlet-->CombinatorialFunction((permutation (F F F))): Missing left brace
"\\spad{permutation(n, \\spad{r)}} returns the number of permutations of \\spad{n} objects taken \\spad{r} at a time, \\spadignore{i.e.} n!/(n-r)!."

--->bookvol10.4.pamphlet-->CombinatorialFunction((factorial (F F))): Missing left brace
"\\spad{factorial(n)} returns the factorial of \\spad{n,} \\spadignore{i.e.} \\spad{n!;}"

=========================================================================
typos 40087:

>compiling CRFP.spad to CRFP.nrlib

--->bookvol10.4.pamphlet-->ComplexRootFindingPackage((divisorCascade ((L FAE) UP UP (Boolean)))): Missing left brace
"\\spad{divisorCascade(p,tp)} assumes that degree of polynomial \\spad{tp} is smaller than degree of polynomial \\spad{p,} both monic. A sequence of divisions are calculated using the remainder, made monic, as divisor for the the next division. The result contains also the error of the factorizations, \\spadignore{i.e.} the norm of the remainder polynomial. If info is true, then information messages are issued."

--->bookvol10.4.pamphlet-->ComplexRootFindingPackage((divisorCascade ((L FAE) UP UP))): Missing left brace
"\\spad{divisorCascade(p,tp)} assumes that degree of polynomial \\spad{tp} is smaller than degree of polynomial \\spad{p,} both monic. A sequence of divisions is calculated using the remainder, made monic, as divisor for the the next division. The result contains also the error of the factorizations, \\spadignore{i.e.} the norm of the remainder polynomial."

--->bookvol10.4.pamphlet-->ComplexRootFindingPackage((schwerpunkt (C UP))): Missing left brace
"\\spad{schwerpunkt(p)} determines the 'Schwerpunkt' of the roots of the polynomial \\spad{p} of degree \\spad{n,} \\spadignore{i.e.} the center of gravity, which is coeffient of \\spad{x**(n-1)} divided by \\spad{n} times coefficient of \\spad{x**n}."

--->bookvol10.4.pamphlet-->ComplexRootFindingPackage((setErrorBound (R R))): \em must be enclosed in braces
"\\spad{setErrorBound(eps)} changes the internal error bound, by default being 10 \\spad{**} (-3) to eps, if \\spad{R} is a member in the category \\spadtype{QuotientFieldCategory Integer}. The internal globalDigits is set to \\em \\spad{ceiling(1/r)**2*10} being 10**7 by default."
--->bookvol10.4.pamphlet-->ComplexRootFindingPackage((setErrorBound (R R))): \em must be enclosed in braces

--->bookvol10.4.pamphlet-->ComplexRootFindingPackage((startPolynomial ((Record (: start UP) (: factors (FR UP))) UP))): Missing left brace
"\\spad{startPolynomial(p)} uses the ideas of Schoenhage's variant of Graeffe's method to construct circles which separate roots to get a good start polynomial, \\spadignore{i.e.} one whose image under the Chinese Remainder Isomorphism has both entries of norm smaller and greater or equal to 1. In case the roots are found during internal calculations. The corresponding factors are in factors which are otherwise 1."

--->bookvol10.4.pamphlet-->ComplexRootFindingPackage(constructor): Missing left brace
"\\spadtype{ComplexRootFindingPackage} provides functions to find all roots of a polynomial \\spad{p} over the complex number by using Plesken's idea to calculate in the polynomial ring modulo \\spad{f} and employing the Chinese Remainder Theorem. In this first version, the precision (see digits) is not increased when this is necessary to avoid rounding errors. Hence it is the user's responsibility to increase the precision if necessary. Note also, if this package is called with \\spadignore{e.g.} \\spadtype{Fraction Integer}, the precise calculations could require a lot of time. Also note that evaluating the zeros is not necessarily a good check whether the result is correct: already evaluation can cause rounding errors."

=========================================================================
typos 40084:

>compiling DERHAM.spad to DERHAM.nrlib

--->bookvol10.3.pamphlet-->DeRhamComplex((retractable? ((Boolean) %))): Missing left brace
"\\spad{retractable?(df)} tests if differential form \\spad{df} is a 0-form, \\spadignore{i.e.} if degree(df) = 0."

=========================================================================
typos 40083:

>compiling DFSFUN.spad to DFSFUN.nrlib
 
--->bookvol10.4.pamphlet-->DoubleFloatSpecialFunctions((Ei (OPR OPR))): Improper initial operator in comments: is
"\\spad{Ei} is the Exponential Integral function This is computed using a 6 part piecewise approximation. DoubleFloat can only preserve about 16 digits but the Chebyshev approximation used can give 30 digits."

--->bookvol10.4.pamphlet-->DoubleFloatSpecialFunctions((Ei1 (OPR OPR))): Improper initial operator in comments: is
"\\spad{Ei1} is the first approximation of \\spad{Ei} where the result is x*\\%e^-x*Ei(x) from -infinity to \\spad{-10} (preserves digits)"

--->bookvol10.4.pamphlet-->DoubleFloatSpecialFunctions((Ei2 (OPR OPR))): Improper initial operator in comments: is
"\\spad{Ei2} is the first approximation of \\spad{Ei} where the result is x*\\%e^-x*Ei(x) from \\spad{-10} to \\spad{-4} (preserves digits)"

--->bookvol10.4.pamphlet-->DoubleFloatSpecialFunctions((Ei3 (OPR OPR))): Improper initial operator in comments: is
"\\spad{Ei3} is the first approximation of \\spad{Ei} where the result is (Ei(x)-log \\spad{|x|} - gamma)/x from \\spad{-4} to 4 (preserves digits)"

--->bookvol10.4.pamphlet-->DoubleFloatSpecialFunctions((Ei4 (OPR OPR))): Improper initial operator in comments: is
"\\spad{Ei4} is the first approximation of \\spad{Ei} where the result is x*\\%e^-x*Ei(x) from 4 to 12 (preserves digits)"

--->bookvol10.4.pamphlet-->DoubleFloatSpecialFunctions((Ei5 (OPR OPR))): Improper initial operator in comments: is
"\\spad{Ei5} is the first approximation of \\spad{Ei} where the result is x*\\%e^-x*Ei(x) from 12 to 32 (preserves digits)"

--->bookvol10.4.pamphlet-->DoubleFloatSpecialFunctions((Ei6 (OPR OPR))): Improper initial operator in comments: is
"\\spad{Ei6} is the first approximation of \\spad{Ei} where the result is x*\\%e^-x*Ei(x) from 32 to infinity (preserves digits)"

--->bookvol10.4.pamphlet-->DoubleFloatSpecialFunctions((fresnelS (F F))): Improper first word in comments: 
"\\indented{1}{fresnelS(f) denotes the Fresnel integral \\spad{S}} \\blankline \\spad{X} fresnelS(1.5)"

--->bookvol10.4.pamphlet-->DoubleFloatSpecialFunctions((fresnelC (F F))): Improper first word in comments: 
"\\indented{1}{fresnelC(f) denotes the Fresnel integral \\spad{C}} \\blankline \\spad{X} fresnelC(1.5)"

=========================================================================
typos 40082:

>compiling DTP.spad to DTP.nrlib
 
--->bookvol10.4.pamphlet-->DesingTreePackage((blowUp ((List InfClsPoint) InfClsPoint))): Not documented!!!!

--->bookvol10.4.pamphlet-->DesingTreePackage((blowUpWithExcpDiv ((Void) DesTree))): Not documented!!!!

--->bookvol10.4.pamphlet-->DesingTreePackage((initializeParamOfPlaces ((Void) DesTree))): Improper first word in comments: initParLocLeaves
"initParLocLeaves(tr) initialize the local parametrization at places corresponding to the leaves of \\spad{tr.}"

--->bookvol10.4.pamphlet-->DesingTreePackage((initializeParamOfPlaces ((Void) DesTree (List PolyRing)))): Improper first word in comments: initParLocLeaves
"initParLocLeaves(tr,listOfFnc) initialize the local parametrization at places corresponding to the leaves of \\spad{tr} according to the given list of functions in listOfFnc."

--->bookvol10.4.pamphlet-->DesingTreePackage((inBetweenExcpDiv (DIVISOR DesTree))): Not documented!!!!

=========================================================================
nonextend 40081:

>compiling D01TRNS.spad to D01TRNS.nrlib

--->bookvol10.3.pamphlet-->d01TransformFunctionType(): Missing Description

=========================================================================
typos 40078:

>compiling EXPRODE.spad to EXPRODE.nrlib
 
--->bookvol10.4.pamphlet-->ExpressionSpaceODESolver((seriesSolve ((Any) (List F) (List OP) EQ (List EQ)))): Missing close parenthesis on first line: seriesSolve([eq1,...,eqn], [y1,...,yn],
"seriesSolve([eq1,...,eqn], [y1,...,yn], \\spad{x} = \\spad{a,[y1} a = b1,..., \\spad{yn} a = bn]) is equivalent to \\spad{seriesSolve([eq1=0,...,eqn=0], [y1,...,yn], \\spad{x} = a, \\spad{[y1} a = b1,..., \\spad{yn} a = bn])}."

=========================================================================
typos 40076:

>compiling GCNAALG.spad to GCNAALG.nrlib

--->bookvol10.3.pamphlet-->GenericNonAssociativeAlgebra((generic (%))): Missing left brace
"\\spad{generic()} returns a generic element, \\spadignore{i.e.} the linear combination of the fixed basis with the symbolic coefficients \\spad{\\%x1,\\%x2,..}"

--->bookvol10.3.pamphlet-->GenericNonAssociativeAlgebra((generic (% (Symbol)))): Missing left brace
"\\spad{generic(s)} returns a generic element, \\spadignore{i.e.} the linear combination of the fixed basis with the symbolic coefficients \\spad{s1,s2,..}"

--->bookvol10.3.pamphlet-->GenericNonAssociativeAlgebra((generic (% (Vector (Symbol))))): Missing left brace
"\\spad{generic(vs)} returns a generic element, \\spadignore{i.e.} the linear combination of the fixed basis with the symbolic coefficients \\spad{vs}; error, if the vector of symbols is too short"

--->bookvol10.3.pamphlet-->GenericNonAssociativeAlgebra((generic (% (Vector %)))): Missing left brace
"\\spad{generic(ve)} returns a generic element, \\spadignore{i.e.} the linear combination of \\spad{ve} basis with the symbolic coefficients \\spad{\\%x1,\\%x2,..}"

--->bookvol10.3.pamphlet-->GenericNonAssociativeAlgebra((generic (% (Symbol) (Vector %)))): Missing left brace
"\\spad{generic(s,v)} returns a generic element, \\spadignore{i.e.} the linear combination of \\spad{v} with the symbolic coefficients \\spad{s1,s2,..}"

--->bookvol10.3.pamphlet-->GenericNonAssociativeAlgebra((generic (% (Vector (Symbol)) (Vector %)))): Missing left brace
"\\spad{generic(vs,ve)} returns a generic element, \\spadignore{i.e.} the linear combination of \\spad{ve} with the symbolic coefficients \\spad{vs} error, if the vector of symbols is shorter than the vector of elements"

--->bookvol10.3.pamphlet-->GenericNonAssociativeAlgebra(constructor): Missing left brace
"AlgebraGenericElementPackage allows you to create generic elements of an algebra, \\spadignore{i.e.} the scalars are extended to include symbolic coefficients"

=========================================================================
typos 40075:

>compiling GDRAW.spad to GDRAW.nrlib

--->bookvol10.4.pamphlet-->GnuDraw((gnuDraw ((Void) EF SBF STR (List DROP)))): Improper first word in comments: 
"\\indented{1}{\\spad{gnuDraw} provides 2d plotting with options} \\blankline \\spad{X} gnuDraw(D(cos(exp(z))/exp(z^2),z),z=-5..5,\"out2d.dat\",title==\"out2d\") \\spad{X} )sys gnuplot -persist out2d.dat"

--->bookvol10.4.pamphlet-->GnuDraw((gnuDraw ((Void) EF SBF STR))): Improper first word in comments: 
"\\indented{1}{\\spad{gnuDraw} provides 2d plotting, default options} \\blankline \\spad{X} gnuDraw(D(cos(exp(z))/exp(z^2),z),z=-5..5,\"out2d.dat\") \\spad{X} )sys gnuplot -persist out2d.dat"

--->bookvol10.4.pamphlet-->GnuDraw((gnuDraw ((Void) EF SBF SBF STR (List DROP)))): Improper first word in comments: 
"\\indented{1}{\\spad{gnuDraw} provides 3d surface plotting with options} \\blankline \\spad{X} gnuDraw(sin(x)*cos(y),x=-6..4,y=-4..6,\"out3d.dat\",title==\"out3d\") \\spad{X} )sys gnuplot -persist out3d.dat"

--->bookvol10.4.pamphlet-->GnuDraw((gnuDraw ((Void) EF SBF SBF STR))): Improper first word in comments: 
"\\indented{1}{\\spad{gnuDraw} provides 3d surface plotting, default options} \\blankline \\spad{X} gnuDraw(sin(x)*cos(y),x=-6..4,y=-4..6,\"out3d.dat\") \\spad{X} )sys gnuplot -persist out3d.dat"

=========================================================================
typos 40073:

>compiling JORDAN.spad to JORDAN.nrlib

--->bookvol10.3.pamphlet-->AssociatedJordanAlgebra(constructor): Mismatch: left pren matches right brace
--->bookvol10.3.pamphlet-->AssociatedJordanAlgebra(constructor): Mismatch: left pren matches right brace
"AssociatedJordanAlgebra takes an algebra \\spad{A} and uses \\spadfun{*$A} to define the new multiplications \\spad{a*b \\spad{:=} (a *$A \\spad{b} + \\spad{b} *$A a)/2} (anticommutator). The usual notation \\spad{{a,b}_+} cannot be used due to restrictions in the current language. This domain only gives a Jordan algebra if the Jordan-identity \\spad{(a*b)*c + (b*c)*a + (c*a)*b = 0} holds for all \\spad{a},\\spad{b},\\spad{c} in \\spad{A}. This relation can be checked by \\spadfun{jordanAdmissible?()$A}. \\blankline If the underlying algebra is of type \\spadtype{FramedNonAssociativeAlgebra(R)} (\\spadignore{i.e.} a non associative algebra over \\spad{R} which is a free R-module of finite rank, together with a fixed R-module basis), then the same is \\spad{true} for the associated Jordan algebra. Moreover, if the underlying algebra is of type \\spadtype{FiniteRankNonAssociativeAlgebra(R)} (\\spadignore{i.e.} a non associative algebra over \\spad{R} which is a free R-module of finite rank), then the same \\spad{true} for the associated Jordan algebra."

=========================================================================
typos 40072:

>compiling LIE.spad to LIE.nrlib
--->bookvol10.3.pamphlet-->AssociatedLieAlgebra(constructor): Mismatch: left pren matches right brace
--->bookvol10.3.pamphlet-->AssociatedLieAlgebra(constructor): Mismatch: left pren matches right brace
"AssociatedLieAlgebra takes an algebra \\spad{A} and uses \\spadfun{*$A} to define the Lie bracket \\spad{a*b \\spad{:=} (a *$A \\spad{b} - \\spad{b} *$A a)} (commutator). Note that the notation \\spad{[a,b]} cannot be used due to restrictions of the current compiler. This domain only gives a Lie algebra if the Jacobi-identity \\spad{(a*b)*c + (b*c)*a + (c*a)*b = 0} holds for all \\spad{a},\\spad{b},\\spad{c} in \\spad{A}. This relation can be checked by \\spad{lieAdmissible?()$A}. \\blankline If the underlying algebra is of type \\spadtype{FramedNonAssociativeAlgebra(R)} (\\spadignore{i.e.} a non associative algebra over \\spad{R} which is a free \\spad{R}-module of finite rank, together with a fixed \\spad{R}-module basis), then the same is \\spad{true} for the associated Lie algebra. Also, if the underlying algebra is of type \\spadtype{FiniteRankNonAssociativeAlgebra(R)} (\\spadignore{i.e.} a non associative algebra over \\spad{R} which is a free R-module of finite rank), then the same is \\spad{true} for the associated Lie algebra."

=========================================================================
typos 40069:

>compiling MYUP.spad to MYUP.nrlib

--------(fmecg (% % (NonNegativeInteger) R %))---------
--->bookvol10.3.pamphlet-->MyUnivariatePolynomial((coerce (% R))): Not documented!!!!
--->bookvol10.3.pamphlet-->MyUnivariatePolynomial((coerce (% (Polynomial R)))): Not documented!!!!


=========================================================================
typos 40068:

>compiling MYEXPR.spad to MYEXPR.nrlib
 
--->bookvol10.3.pamphlet-->MyExpression((* (% % %))): Not documented!!!!
--->bookvol10.3.pamphlet-->MyExpression((/ (% % %))): Not documented!!!!
--->bookvol10.3.pamphlet-->MyExpression((** (% % %))): Not documented!!!!
--->bookvol10.3.pamphlet-->MyExpression((numerator (% %))): Not documented!!!!
--->bookvol10.3.pamphlet-->MyExpression((denominator (% %))): Not documented!!!!
--->bookvol10.3.pamphlet-->MyExpression((ground? ((Boolean) %))): Not documented!!!!
--->bookvol10.3.pamphlet-->MyExpression((coerce (% (Fraction UP)))): Not documented!!!!
--->bookvol10.3.pamphlet-->MyExpression((retract ((Fraction UP) %))): Not documented!!!!


=========================================================================
typos 40067:

>compiling MYEXPR.spad to MYEXPR.nrlib

--------(fmecg (% % (NonNegativeInteger) R %))---------
--->bookvol10.3.pamphlet-->MyUnivariatePolynomial((coerce (% R))): Not documented!!!!
--->bookvol10.3.pamphlet-->MyUnivariatePolynomial((coerce (% (Polynomial R)))): Not documented!!!!

--->bookvol10.3.pamphlet-->MyExpression((* (% % %))): Not documented!!!!
--->bookvol10.3.pamphlet-->MyExpression((/ (% % %))): Not documented!!!!
--->bookvol10.3.pamphlet-->MyExpression((** (% % %))): Not documented!!!!
--->bookvol10.3.pamphlet-->MyExpression((numerator (% %))): Not documented!!!!
--->bookvol10.3.pamphlet-->MyExpression((denominator (% %))): Not documented!!!!
--->bookvol10.3.pamphlet-->MyExpression((ground? ((Boolean) %))): Not documented!!!!
--->bookvol10.3.pamphlet-->MyExpression((coerce (% (Fraction UP)))): Not documented!!!!
--->bookvol10.3.pamphlet-->MyExpression((retract ((Fraction UP) %))): Not documented!!!!

--->bookvol10.4.pamphlet-->NagMatrixOperationsPackage((f01bsf ((Result) (Integer) (Integer) (Integer) (Matrix (Integer)) (Matrix (Integer)) (Matrix (Integer)) (Matrix (Integer)) (Boolean) (DoubleFloat) (Boolean) (Matrix (Integer)) (Matrix (DoubleFloat)) (Integer)))): Missing close parenthesis on first line: f01bsf(n,nz,licn,ivect,jvect,icn,ikeep,grow,
"f01bsf(n,nz,licn,ivect,jvect,icn,ikeep,grow, \\indented{7}{eta,abort,idisp,avals,ifail)} factorizes a real sparse matrix using the pivotal sequence previously obtained by F01BRF when a matrix of the same sparsity pattern was factorized. See \\downlink{Manual Page}{manpageXXf01bsf}."

=========================================================================
typos 40066:

>compiling NAGF02.spad to NAGF02.nrlib
 
--->bookvol10.4.pamphlet-->NagEigenPackage((f02fjf ((Result) (Integer) (Integer) (DoubleFloat) (Integer) (Integer) (Integer) (Integer) (Integer) (Integer) (Integer) (Matrix (DoubleFloat)) (Integer) (Union (: fn (FileName)) (: fp (Asp27 DOT))) (Union (: fn (FileName)) (: fp (Asp28 IMAGE)))))): Missing close parenthesis on first line: f02fjf(n,k,tol,novecs,nrx,lwork,lrwork,
"f02fjf(n,k,tol,novecs,nrx,lwork,lrwork, \\indented{7}{liwork,m,noits,x,ifail,dot,image)} finds eigenvalues of a real sparse symmetric or generalized symmetric eigenvalue problem. See \\downlink{Manual Page}{manpageXXf02fjf}."

--->bookvol10.4.pamphlet-->NagEigenPackage((f02fjf ((Result) (Integer) (Integer) (DoubleFloat) (Integer) (Integer) (Integer) (Integer) (Integer) (Integer) (Integer) (Matrix (DoubleFloat)) (Integer) (Union (: fn (FileName)) (: fp (Asp27 DOT))) (Union (: fn (FileName)) (: fp (Asp28 IMAGE))) (FileName)))): Missing close parenthesis on first line: f02fjf(n,k,tol,novecs,nrx,lwork,lrwork,
"f02fjf(n,k,tol,novecs,nrx,lwork,lrwork, \\indented{7}{liwork,m,noits,x,ifail,dot,image,monit)} finds eigenvalues of a real sparse symmetric or generalized symmetric eigenvalue problem. See \\downlink{Manual Page}{manpageXXf02fjf}."

=========================================================================
typos 40065:

>compiling NAGF04.spad to NAGF04.nrlib
 
--->bookvol10.4.pamphlet-->NagLinearEquationSolvingPackage((f04maf ((Result) (Integer) (Integer) (Matrix (DoubleFloat)) (Integer) (Matrix (Integer)) (Integer) (Matrix (Integer)) (Matrix (DoubleFloat)) (Matrix (Integer)) (Matrix (Integer)) (Matrix (DoubleFloat)) (Matrix (DoubleFloat)) (Matrix (Integer)) (Integer)))): Missing close parenthesis on first line: f04maf(n,nz,avals,licn,irn,lirn,icn,wkeep,ikeep,
"f04maf(n,nz,avals,licn,irn,lirn,icn,wkeep,ikeep, \\indented{7}{inform,b,acc,noits,ifail)} \\spad{e} a sparse symmetric positive-definite system of linear equations, Ax=b, using a pre-conditioned conjugate gradient method, where A has been factorized by F01MAF. See \\downlink{Manual Page}{manpageXXf04maf}."
--------(f04mbf ((Result) (Integer) (Matrix (DoubleFloat)) (Boolean) (DoubleFloat) (Integer) (Integer) (Integer) (Integer) (DoubleFloat) (Integer) (Union (: fn (FileName)) (: fp (Asp28 APROD))) (Union (: fn (FileName)) (: fp (Asp34 MSOLVE)))))---------

--->bookvol10.4.pamphlet-->NagLinearEquationSolvingPackage((f04qaf ((Result) (Integer) (Integer) (DoubleFloat) (DoubleFloat) (DoubleFloat) (DoubleFloat) (Integer) (Integer) (Integer) (Integer) (Matrix (DoubleFloat)) (Integer) (Union (: fn (FileName)) (: fp (Asp30 APROD)))))): Missing close parenthesis on first line: f04qaf(m,n,damp,atol,btol,conlim,itnlim,msglvl,
"f04qaf(m,n,damp,atol,btol,conlim,itnlim,msglvl, \\indented{7}{lrwork,liwork,b,ifail,aprod)} solves sparse unsymmetric equations, sparse linear least- squares problems and sparse damped linear least-squares problems, using a Lanczos algorithm. See \\downlink{Manual Page}{manpageXXf04qaf}."

=========================================================================
typos 40064:

>compiling OMEXPR.spad to OMEXPR.nrlib
 
--->bookvol10.4.pamphlet-->ExpressionToOpenMath((OMwrite ((String) (Expression R)))): Not documented!!!!
--->bookvol10.4.pamphlet-->ExpressionToOpenMath((OMwrite ((String) (Expression R) (Boolean)))): Not documented!!!!
--->bookvol10.4.pamphlet-->ExpressionToOpenMath((OMwrite ((Void) (OpenMathDevice) (Expression R)))): Not documented!!!!
--->bookvol10.4.pamphlet-->ExpressionToOpenMath((OMwrite ((Void) (OpenMathDevice) (Expression R) (Boolean)))): Not documented!!!!

=========================================================================
typos 40062:

>compiling RULE.spad to RULE.nrlib
 
--->bookvol10.3.pamphlet-->RewriteRule((rule ($ F F))): Improper first word in comments: 
"\\indented{1}{rule(f, \\spad{g)} creates the rewrite rule: \\spad{f \\spad{==} eval(g, \\spad{g} is f)},} \\indented{1}{with left-hand side \\spad{f} and right-hand side \\spad{g.}} \\blankline \\spad{X} logrule \\spad{:=} rule log(x) + log(y) \\spad{==} log(x*y) \\spad{X} \\spad{f} \\spad{:=} log(sin(x)) + log(x) \\spad{X} logrule \\spad{f}"

=========================================================================
typos 40061:

>compiling SD.spad to SD.nrlib

(|PolynomialCategory| (|Expression| |#1|) (|IndexedExponents| (|BasicStochasticDifferential|)) (|BasicStochasticDifferential|))    finalizing nrlib SD 
   Processing StochasticDifferential for Browser database:

--->bookvol10.3.pamphlet-->StochasticDifferential((statusIto (OF))): Improper first word in comments: 
"\\indented{1}{statusIto() displays the current state of \\axiom{setBSD},} \\indented{1}{\\axiom{tableDrift}, and \\axiom{tableQuadVar}. Question} \\indented{1}{marks are printed instead of undefined entries} \\blankline \\spad{X} dt:=introduce!(t,dt) \\spad{X} dX:=introduce!(X,dX) \\spad{X} dY:=introduce!(Y,dY) \\spad{X} copyBSD() \\spad{X} copyIto() \\spad{X} copyhQuadVar() \\spad{X} statusIto()"

=========================================================================
typos 40060:

>compiling SOLVETRA.spad to SOLVETRA.nrlib
 
--->bookvol10.4.pamphlet-->TransSolvePackage((solve ((L (EQ RE)) RE S))): Improper first word in comments: 
"\\indented{1}{solve(expr,x) finds the solutions of the equation expr = 0} \\indented{1}{with respect to the symbol \\spad{x} where expr is a function} \\indented{1}{of type Expression(R).} \\blankline \\spad{X} solve(1/2*v*v*cos(theta+phi)*cos(theta+phi)+g*l*cos(phi)=g*l,phi) \\spad{X} definingPolynomial \\spad{%phi0} \\spad{X} definingPolynomial \\spad{%phi1}"

=========================================================================
typos 40058:

>compiling TRMANIP.spad to TRMANIP.nrlib
 
--->bookvol10.4.pamphlet-->TranscendentalManipulations((expand (F F))): \item appears outside a \begin-\end
--->bookvol10.4.pamphlet-->TranscendentalManipulations((expand (F F))): \item appears outside a \begin-\end
--->bookvol10.4.pamphlet-->TranscendentalManipulations((expand (F F))): \item appears outside a \begin-\end
"\\spad{expand(f)} performs the following expansions on f:\\begin{items} \\item 1. logs of products are expanded into sums of logs, \\item 2. trigonometric and hyperbolic trigonometric functions of sums are expanded into sums of products of trigonometric and hyperbolic trigonometric functions. \\item 3. formal powers of the form \\spad{(a/b)**c} are expanded into \\spad{a**c * b**(-c)}. \\end{items}"

--->bookvol10.4.pamphlet-->TranscendentalManipulations((simplify (F F))): \item appears outside a \begin-\end
--->bookvol10.4.pamphlet-->TranscendentalManipulations((simplify (F F))): \item appears outside a \begin-\end
--->bookvol10.4.pamphlet-->TranscendentalManipulations((simplify (F F))): \item appears outside a \begin-\end
--->bookvol10.4.pamphlet-->TranscendentalManipulations((simplify (F F))): \item appears outside a \begin-\end
"\\spad{simplify(f)} performs the following simplifications on f:\\begin{items} \\item 1. rewrites trigs and hyperbolic trigs in terms of \\spad{sin} ,\\spad{cos}, \\spad{sinh}, \\spad{cosh}. \\item 2. rewrites \\spad{sin**2} and \\spad{sinh**2} in terms of \\spad{cos} and \\spad{cosh}, \\item 3. rewrites \\spad{exp(a)*exp(b)} as \\spad{exp(a+b)}. \\item 4. rewrites \\spad{(a**(1/n))**m * (a**(1/s))**t} as a single power of a single radical of \\spad{a}. \\end{items}"

=========================================================================
typos 40057:

>compiling UPXSSING.spad to UPXSSING.nrlib
 
--------------non extending category----------------------
.. UnivariatePuiseuxSeriesWithExponentialSingularity(#1,#2,#3,#4) of cat 
(|Join| (|FiniteAbelianMonoidRing| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|) (|ExponentialOfUnivariatePuiseuxSeries| |#2| |#3| |#4|)) (|IntegralDomain|) (CATEGORY |domain| (SIGNATURE |limitPlus| ((|Union| (|OrderedCompletion| |#2|) "failed") $)) (SIGNATURE |dominantTerm| ((|Union| (|Record| (|:| |%term| (|Record| (|:| |%coef| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|)) (|:| |%expon| (|ExponentialOfUnivariatePuiseuxSeries| |#2| |#3| |#4|)) (|:| |%expTerms| (|List| (|Record| (|:| |k| (|Fraction| (|Integer|))) (|:| |c| |#2|)))))) (|:| |%type| (|String|))) "failed") $))))   has no 
(IF (|has| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|) (|IntegralDomain|)) (IF (|has| (|ExponentialOfUnivariatePuiseuxSeries| |#2| |#3| |#4|) (|CancellationAbelianMonoid|)) (SIGNATURE |fmecg| ($ $ (|ExponentialOfUnivariatePuiseuxSeries| |#2| |#3| |#4|) (|UnivariatePuiseuxSeries| |#2| |#3| |#4|) $)) |noBranch|) |noBranch|)    finalizing nrlib UPXSSING 

=========================================================================
typos 40056:

>compiling UTSSOL.spad to UTSSOL.nrlib

--->bookvol10.4.pamphlet-->TaylorSolve((seriesSolve (UTSF (Mapping UTSSUPF UTSSUPF) (List F)))): Not documented!!!!

=========================================================================
typos 40051:

>compiling EXPR.spad to EXPR.nrlib
 
--->bookvol10.3.pamphlet-->Expression((simplifyPower (% % (Integer)))): Improper first word in comments: simplifyPower?
"simplifyPower?(f,n) is not documented"

=========================================================================
typos 40050:

>compiling EXPRSOL.spad to EXPRSOL.nrlib
 
--->bookvol10.4.pamphlet-->ExpressionSolve((seriesSolve (UTSF F OP SY (List F)))): Not documented!!!!
--->bookvol10.4.pamphlet-->ExpressionSolve((replaceDiffs (F F OP (Symbol)))): Not documented!!!!

=========================================================================
typos 40049:

>compiling FACTEXT.spad to FACTEXT.nrlib
 
--->bookvol10.4.pamphlet-->FactorisationOverPseudoAlgebraicClosureOfAlgExtOfRationalNumber((factor ((Factored UP) UP K))): Not documented!!!!
--->bookvol10.4.pamphlet-->FactorisationOverPseudoAlgebraicClosureOfAlgExtOfRationalNumber((factorSqFree ((Factored UP) UP K))): Not documented!!!!

=========================================================================
typos 40047:

>compiling GSERIES.spad to GSERIES.nrlib

--------------non extending category----------------------
.. GeneralUnivariatePowerSeries(#1,#2,#3) of cat 
(|Join| (|UnivariatePuiseuxSeriesCategory| |#1|) (CATEGORY |domain| (SIGNATURE |coerce| ($ (|Variable| |#2|))) (SIGNATURE |coerce| ($ (|UnivariatePuiseuxSeries| |#1| |#2| |#3|))) (SIGNATURE |differentiate| ($ $ (|Variable| |#2|))) (IF (|has| |#1| (|Algebra| (|Fraction| (|Integer|)))) (SIGNATURE |integrate| ($ $ (|Variable| |#2|))) |noBranch|)))   has no 
(|UnivariatePuiseuxSeriesConstructorCategory| |#1| (|UnivariateLaurentSeries| |#1| |#2| |#3|))    finalizing nrlib GSERIES 


=========================================================================
typos 40046:

>compiling REGSET.spad to REGSET.nrlib
 
Warning: REGSET;decompose has a duplicate definition in this file


=========================================================================
typos 40045:

>compiling RGCHAIN.spad to RGCHAIN.nrlib

--->bookvol10.3.pamphlet-->RegularChain(constructor): Mismatch: left pren matches right brace
"A domain for regular chains (\\spadignore{i.e.} regular triangular sets) over a Gcd-Domain and with a fix list of variables. This is just a front-end for the \\spadtype{RegularTriangularSet} domain constructor."


=========================================================================
typos 40044:

>compiling RSDCMPK.spad to RSDCMPK.nrlib
 
--->bookvol10.4.pamphlet-->RegularSetDecompositionPackage((KrullNumber (N LP Split))): Not documented!!!!
--->bookvol10.4.pamphlet-->RegularSetDecompositionPackage((numberOfVariables (N LP Split))): Not documented!!!!
--->bookvol10.4.pamphlet-->RegularSetDecompositionPackage((algebraicDecompose ((Record (: done Split) (: todo (List LpWT))) P TS B))): Not documented!!!!
--->bookvol10.4.pamphlet-->RegularSetDecompositionPackage((transcendentalDecompose ((Record (: done Split) (: todo (List LpWT))) P TS N))): Not documented!!!!
--->bookvol10.4.pamphlet-->RegularSetDecompositionPackage((transcendentalDecompose ((Record (: done Split) (: todo (List LpWT))) P TS))): Not documented!!!!
--->bookvol10.4.pamphlet-->RegularSetDecompositionPackage((internalDecompose ((Record (: done Split) (: todo (List LpWT))) P TS N B))): Not documented!!!!
--->bookvol10.4.pamphlet-->RegularSetDecompositionPackage((internalDecompose ((Record (: done Split) (: todo (List LpWT))) P TS N))): Not documented!!!!
--->bookvol10.4.pamphlet-->RegularSetDecompositionPackage((internalDecompose ((Record (: done Split) (: todo (List LpWT))) P TS))): Not documented!!!!
--->bookvol10.4.pamphlet-->RegularSetDecompositionPackage((decompose (Split LP Split B B))): Not documented!!!!
--->bookvol10.4.pamphlet-->RegularSetDecompositionPackage((decompose (Split LP Split B B B B B))): Not documented!!!!
--->bookvol10.4.pamphlet-->RegularSetDecompositionPackage((upDateBranches ((List LpWT) LP Split (List LpWT) Wip N))): Not documented!!!!
--->bookvol10.4.pamphlet-->RegularSetDecompositionPackage((convert ((String) (Record (: val (List P)) (: tower TS))))): Not documented!!!!
--->bookvol10.4.pamphlet-->RegularSetDecompositionPackage((printInfo ((Void) (List (Record (: val (List P)) (: tower TS))) N))): Not documented!!!!

=========================================================================
typos 40043:

>compiling SOLVERAD.spad to SOLVERAD.nrlib

--->bookvol10.4.pamphlet-->RadicalSolvePackage((radicalSolve ((L (EQ RE)) RF SY))): Improper first word in comments: 
"\\indented{1}{radicalSolve(rf,x) finds the solutions expressed in terms of} \\indented{1}{radicals of the equation \\spad{rf} = 0 with respect to the symbol \\spad{x,}} \\indented{1}{where \\spad{rf} is a rational function.} \\blankline \\spad{X} b:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) \\spad{X} radicalSolve(b,x)"

--->bookvol10.4.pamphlet-->RadicalSolvePackage((radicalSolve ((L (EQ RE)) RF))): Improper first word in comments: 
"\\indented{1}{radicalSolve(rf) finds the solutions expressed in terms of} \\indented{1}{radicals of the equation \\spad{rf} = 0, where \\spad{rf} is a} \\indented{1}{univariate rational function.} \\blankline \\spad{X} b:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) \\spad{X} radicalSolve(b)"

--->bookvol10.4.pamphlet-->RadicalSolvePackage((radicalSolve ((L (EQ RE)) (EQ RF) SY))): Improper first word in comments: 
"\\indented{1}{radicalSolve(eq,x) finds the solutions expressed in terms of} \\indented{1}{radicals of the equation of rational functions eq} \\indented{1}{with respect to the symbol \\spad{x.}} \\blankline \\spad{X} b:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) \\spad{X} radicalSolve(b=0,x)"

--->bookvol10.4.pamphlet-->RadicalSolvePackage((radicalSolve ((L (EQ RE)) (EQ RF)))): Improper first word in comments: 
"\\indented{1}{radicalSolve(eq) finds the solutions expressed in terms of} \\indented{1}{radicals of the equation of rational functions eq} \\indented{1}{with respect to the unique symbol \\spad{x} appearing in eq.} \\blankline \\spad{X} b:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) \\spad{X} radicalSolve(b=0)"

--->bookvol10.4.pamphlet-->RadicalSolvePackage((radicalSolve ((L (L (EQ RE))) (L RF) (L SY)))): Improper first word in comments: 
"\\indented{1}{radicalSolve(lrf,lvar) finds the solutions expressed in terms of} \\indented{1}{radicals of the system of equations \\spad{lrf} = 0 with} \\indented{1}{respect to the list of symbols lvar,} \\indented{1}{where \\spad{lrf} is a list of rational functions.} \\blankline \\spad{X} b:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) \\spad{X} c:Fraction(Polynomial(Integer)):=(y^2+4)/(y+1) \\spad{X} radicalSolve([b,c],[x,y])"

--->bookvol10.4.pamphlet-->RadicalSolvePackage((radicalSolve ((L (L (EQ RE))) (L RF)))): Improper first word in comments: 
"\\indented{1}{radicalSolve(lrf) finds the solutions expressed in terms of} \\indented{1}{radicals of the system of equations \\spad{lrf} = 0, where \\spad{lrf} is a} \\indented{1}{system of univariate rational functions.} \\blankline \\spad{X} b:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) \\spad{X} c:Fraction(Polynomial(Integer)):=(y^2+4)/(y+1) \\spad{X} radicalSolve([b,c])"

--->bookvol10.4.pamphlet-->RadicalSolvePackage((radicalSolve ((L (L (EQ RE))) (L (EQ RF)) (L SY)))): Improper first word in comments: 
"\\indented{1}{radicalSolve(leq,lvar) finds the solutions expressed in terms of} \\indented{1}{radicals of the system of equations of rational functions leq} \\indented{1}{with respect to the list of symbols lvar.} \\blankline \\spad{X} b:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) \\spad{X} c:Fraction(Polynomial(Integer)):=(y^2+4)/(y+1) \\spad{X} radicalSolve([b=0,c=0],[x,y])"

--->bookvol10.4.pamphlet-->RadicalSolvePackage((radicalSolve ((L (L (EQ RE))) (L (EQ RF))))): Improper first word in comments: 
"\\indented{1}{radicalSolve(leq) finds the solutions expressed in terms of} \\indented{1}{radicals of the system of equations of rational functions leq} \\indented{1}{with respect to the unique symbol \\spad{x} appearing in leq.} \\blankline \\spad{X} b:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) \\spad{X} c:Fraction(Polynomial(Integer)):=(y^2+4)/(y+1) \\spad{X} radicalSolve([b=0,c=0])"

--->bookvol10.4.pamphlet-->RadicalSolvePackage((radicalRoots ((L RE) RF SY))): Improper first word in comments: 
"\\indented{1}{radicalRoots(rf,x) finds the roots expressed in terms of radicals} \\indented{1}{of the rational function \\spad{rf} with respect to the symbol \\spad{x.}} \\blankline \\spad{X} b:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) \\spad{X} radicalRoots(b,x)"

--->bookvol10.4.pamphlet-->RadicalSolvePackage((radicalRoots ((L (L RE)) (L RF) (L SY)))): Improper first word in comments: 
"\\indented{1}{radicalRoots(lrf,lvar) finds the roots expressed in terms of} \\indented{1}{radicals of the list of rational functions lrf} \\indented{1}{with respect to the list of symbols lvar.} \\blankline \\spad{X} b:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) \\spad{X} c:Fraction(Polynomial(Integer)):=(y^2+4)/(y+1) \\spad{X} radicalRoots([b,c],[x,y])"

--->bookvol10.4.pamphlet-->RadicalSolvePackage((contractSolve (SU (EQ RF) SY))): Improper first word in comments: 
"\\indented{1}{contractSolve(eq,x) finds the solutions expressed in terms of} \\indented{1}{radicals of the equation of rational functions eq} \\indented{1}{with respect to the symbol x.\\space{2}The result contains new} \\indented{1}{symbols for common subexpressions in order to reduce the} \\indented{1}{size of the output.} \\blankline \\spad{X} b:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) \\spad{X} contractSolve(b=0,x)"

--->bookvol10.4.pamphlet-->RadicalSolvePackage((contractSolve (SU RF SY))): Improper first word in comments: 
"\\indented{1}{contractSolve(rf,x) finds the solutions expressed in terms of} \\indented{1}{radicals of the equation \\spad{rf} = 0 with respect to the symbol \\spad{x,}} \\indented{1}{where \\spad{rf} is a rational function. The result contains\\space{2}new} \\indented{1}{symbols for common subexpressions in order to reduce the} \\indented{1}{size of the output.} \\blankline \\spad{X} b:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) \\spad{X} contractSolve(b,x)"

=========================================================================
typos 40040:

>compiling UFPS1.spad to UFPS1.nrlib
 
--->bookvol10.4.pamphlet-->UnivariateFormalPowerSeriesFunctions((hadamard (UFPS UFPS UFPS))): Not documented!!!!

=========================================================================
typos 40037:

>compiling GPAFF.spad to GPAFF.nrlib
 
--->bookvol10.4.pamphlet-->GeneralPackageForAlgebraicFunctionField((reset ((Void)))): Not documented!!!!
--->bookvol10.4.pamphlet-->GeneralPackageForAlgebraicFunctionField((setCurve (PolyRing PolyRing))): Not documented!!!!
--->bookvol10.4.pamphlet-->GeneralPackageForAlgebraicFunctionField((homogenize (PolyRing PolyRing (Integer)))): Not documented!!!!

--->bookvol10.4.pamphlet-->GeneralPackageForAlgebraicFunctionField((genusNeg (INT))): Not documented!!!!

--->bookvol10.4.pamphlet-->GeneralPackageForAlgebraicFunctionField((singularPoints ((List ProjPt)))): Improper first word in comments: rationalPoints
"rationalPoints() returns the singular points of the curve defined by the polynomial given to the package. If the singular points lie in an extension of the specified ground field an error message is issued specifying the extension degree needed to find all singular points."

--->bookvol10.4.pamphlet-->GeneralPackageForAlgebraicFunctionField((findOrderOfDivisor ((Record (: ord (Integer)) (: num PolyRing) (: den PolyRing) (: upTo (Integer))) DIVISOR (Integer) (Integer)))): Not documented!!!!

--->bookvol10.4.pamphlet-->GeneralPackageForAlgebraicFunctionField((interpolateFormsForFact ((List PolyRing) DIVISOR (List PolyRing)))): Not documented!!!!

--->bookvol10.4.pamphlet-->GeneralPackageForAlgebraicFunctionField((placesAbove ((List Plc) ProjPt))): Not documented!!!!

--->bookvol10.4.pamphlet-->GeneralPackageForAlgebraicFunctionField((rationalPoints ((List ProjPt)))): Not documented!!!!

--->bookvol10.4.pamphlet-->GeneralPackageForAlgebraicFunctionField((LPolynomial ((SparseUnivariatePolynomial (Integer))))): Improper first word in comments: Returns
"Returns the L-Polynomial of the curve."

--->bookvol10.4.pamphlet-->GeneralPackageForAlgebraicFunctionField((classNumber ((Integer)))): Improper first word in comments: Returns
"Returns the class number of the curve."

--->bookvol10.4.pamphlet-->GeneralPackageForAlgebraicFunctionField((numberOfPlacesOfDegree ((Integer) PI))): Improper first word in comments: returns
"returns the number of places of the given degree"

--->bookvol10.4.pamphlet-->GeneralPackageForAlgebraicFunctionField((numberPlacesDegExtDeg ((Integer) PI PI))): Improper first word in comments: numberRatPlacesExtDegExtDeg
"numberRatPlacesExtDegExtDeg(d, \\spad{n)} returns the number of places of degree \\spad{d} in the constant field extension of degree \\spad{n}"

--->bookvol10.4.pamphlet-->GeneralPackageForAlgebraicFunctionField((ZetaFunction (UTSZ))): Improper first word in comments: Returns
"Returns the Zeta function of the curve. Calculated by using the L-Polynomial"

--->bookvol10.4.pamphlet-->GeneralPackageForAlgebraicFunctionField((ZetaFunction (UTSZ PI))): Improper first word in comments: Returns
"Returns the Zeta function of the curve in constant field extension. Calculated by using the L-Polynomial"

=========================================================================
typos 40036:

>compiling PACEXT.spad to PACEXT.nrlib
 
--->bookvol10.3.pamphlet-->PseudoAlgebraicClosureOfAlgExtOfRationalNumber((fullOutput ((OutputForm) %))): Not documented!!!!
--->bookvol10.3.pamphlet-->PseudoAlgebraicClosureOfAlgExtOfRationalNumber((retractToGrn (K %))): Not documented!!!!

=========================================================================
typos 40035:

>compiling RECOP.spad to RECOP.nrlib
 
--->bookvol10.4.pamphlet-->RecurrenceOperator((numberOfValuesNeeded ((Integer) (Integer) (BasicOperator) (Symbol) F))): Not documented!!!!
--->bookvol10.4.pamphlet-->RecurrenceOperator((getShiftRec ((Union (Integer) failed) (BasicOperator) (Kernel F) (Symbol)))): Not documented!!!!
--->bookvol10.4.pamphlet-->RecurrenceOperator((shiftInfoRec ((Record (: max (Union (Integer) failed)) (: ord (Union (Integer) failed)) (: ker (Kernel F))) (BasicOperator) (Symbol) F))): Not documented!!!!

=========================================================================
typos 40034:

>compiling SFRGCD.spad to SFRGCD.nrlib
 
--->bookvol10.4.pamphlet-->SquareFreeRegularTriangularSetGcdPackage((startTableGcd! ((Void) S S S))): Not documented!!!!
--->bookvol10.4.pamphlet-->SquareFreeRegularTriangularSetGcdPackage((stopTableGcd! ((Void)))): Not documented!!!!
--->bookvol10.4.pamphlet-->SquareFreeRegularTriangularSetGcdPackage((startTableInvSet! ((Void) S S S))): Not documented!!!!
--->bookvol10.4.pamphlet-->SquareFreeRegularTriangularSetGcdPackage((stopTableInvSet! ((Void)))): Not documented!!!!
--->bookvol10.4.pamphlet-->SquareFreeRegularTriangularSetGcdPackage((stosePrepareSubResAlgo ((List LpWT) P P TS))): Not documented!!!!
--->bookvol10.4.pamphlet-->SquareFreeRegularTriangularSetGcdPackage((stoseInternalLastSubResultant ((List PWT) P P TS B B))): Not documented!!!!
--->bookvol10.4.pamphlet-->SquareFreeRegularTriangularSetGcdPackage((stoseInternalLastSubResultant ((List PWT) (List LpWT) V B))): Not documented!!!!
--->bookvol10.4.pamphlet-->SquareFreeRegularTriangularSetGcdPackage((stoseIntegralLastSubResultant ((List PWT) P P TS))): Not documented!!!!
--->bookvol10.4.pamphlet-->SquareFreeRegularTriangularSetGcdPackage((stoseLastSubResultant ((List PWT) P P TS))): Not documented!!!!
--->bookvol10.4.pamphlet-->SquareFreeRegularTriangularSetGcdPackage((stoseInvertible? (B P TS))): Not documented!!!!
--->bookvol10.4.pamphlet-->SquareFreeRegularTriangularSetGcdPackage((stoseInvertible?sqfreg ((List BWT) P TS))): Not documented!!!!
--->bookvol10.4.pamphlet-->SquareFreeRegularTriangularSetGcdPackage((stoseInvertibleSetsqfreg (Split P TS))): Not documented!!!!
--->bookvol10.4.pamphlet-->SquareFreeRegularTriangularSetGcdPackage((stoseInvertible?reg ((List BWT) P TS))): Not documented!!!!
--->bookvol10.4.pamphlet-->SquareFreeRegularTriangularSetGcdPackage((stoseInvertibleSetreg (Split P TS))): Not documented!!!!
--->bookvol10.4.pamphlet-->SquareFreeRegularTriangularSetGcdPackage((stoseInvertible? ((List BWT) P TS))): Not documented!!!!
--->bookvol10.4.pamphlet-->SquareFreeRegularTriangularSetGcdPackage((stoseInvertibleSet (Split P TS))): Not documented!!!!
--->bookvol10.4.pamphlet-->SquareFreeRegularTriangularSetGcdPackage((stoseSquareFreePart ((List PWT) P TS))): Not documented!!!!

=========================================================================
typos 40033:

>compiling SRDCMPK.spad to SRDCMPK.nrlib
 
--->bookvol10.4.pamphlet-->SquareFreeRegularSetDecompositionPackage((KrullNumber (N LP Split))): Not documented!!!!
--->bookvol10.4.pamphlet-->SquareFreeRegularSetDecompositionPackage((numberOfVariables (N LP Split))): Not documented!!!!
--->bookvol10.4.pamphlet-->SquareFreeRegularSetDecompositionPackage((algebraicDecompose ((Record (: done Split) (: todo (List LpWT))) P TS))): Not documented!!!!
--->bookvol10.4.pamphlet-->SquareFreeRegularSetDecompositionPackage((transcendentalDecompose ((Record (: done Split) (: todo (List LpWT))) P TS N))): Not documented!!!!
--->bookvol10.4.pamphlet-->SquareFreeRegularSetDecompositionPackage((transcendentalDecompose ((Record (: done Split) (: todo (List LpWT))) P TS))): Not documented!!!!
--->bookvol10.4.pamphlet-->SquareFreeRegularSetDecompositionPackage((internalDecompose ((Record (: done Split) (: todo (List LpWT))) P TS N B))): Not documented!!!!
--->bookvol10.4.pamphlet-->SquareFreeRegularSetDecompositionPackage((internalDecompose ((Record (: done Split) (: todo (List LpWT))) P TS N))): Not documented!!!!
--->bookvol10.4.pamphlet-->SquareFreeRegularSetDecompositionPackage((internalDecompose ((Record (: done Split) (: todo (List LpWT))) P TS))): Not documented!!!!
--->bookvol10.4.pamphlet-->SquareFreeRegularSetDecompositionPackage((decompose (Split LP Split B B))): Not documented!!!!
--->bookvol10.4.pamphlet-->SquareFreeRegularSetDecompositionPackage((decompose (Split LP Split B B B B B))): Not documented!!!!
--->bookvol10.4.pamphlet-->SquareFreeRegularSetDecompositionPackage((upDateBranches ((List LpWT) LP Split (List LpWT) Wip N))): Not documented!!!!
--->bookvol10.4.pamphlet-->SquareFreeRegularSetDecompositionPackage((convert ((String) (Record (: val (List P)) (: tower TS))))): Not documented!!!!
--->bookvol10.4.pamphlet-->SquareFreeRegularSetDecompositionPackage((printInfo ((Void) (List (Record (: val (List P)) (: tower TS))) N))): Not documented!!!!

=========================================================================
typos 40031:

>compiling GUESS.spad to GUESS.nrlib
 
--->bookvol10.4.pamphlet-->Guess((* (% % %))): Not documented!!!!
--->bookvol10.4.pamphlet-->Guess((/ (% % %))): Not documented!!!!
--->bookvol10.4.pamphlet-->Guess((** (% % %))): Not documented!!!!
--->bookvol10.4.pamphlet-->Guess((numerator (% %))): Not documented!!!!
--->bookvol10.4.pamphlet-->Guess((denominator (% %))): Not documented!!!!
--->bookvol10.4.pamphlet-->Guess((ground? ((Boolean) %))): Not documented!!!!

=========================================================================
typos 40029:

>compiling PAFF.spad to PAFF.nrlib
 
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((homogenize (PolyRing PolyRing (Integer)))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((interpolateFormsForFact ((List PolyRing) DIVISOR (List PolyRing)))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((fullDesTree ((Void)))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((fullInfClsPt ((Void)))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((setCurve (PolyRing PolyRing))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((projectivePoint (ProjPt (List K)))): Not documented!!!!
--------(pointDominateBy (ProjPt Plc))---------
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((placesAbove ((List Plc) ProjPt))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((setSingularPoints ((List ProjPt) (List ProjPt)))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((goppaCode ((Matrix K) DIVISOR DIVISOR))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((goppaCode ((Matrix K) DIVISOR (List Plc)))): Not documented!!!!
--------(rationalPlaces ((List Plc)))---------
--------(theCurve (PolyRing))---------
--------(genus (NNI))---------
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((genusNeg ((Integer)))): Not documented!!!!

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((rationalPoints ((List ProjPt)))): Not documented!!!!

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((singularPoints ((List ProjPt)))): Improper first word in comments: rationalPoints
"rationalPoints() returns the singular points of the curve defined by the polynomial given to the package. If the singular points lie in an extension of the specified ground field an error message is issued specifying the extension degree needed to find all singular points."

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((lBasis ((List FRACPOLY) DIVISOR NNI))): Not documented!!!!

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((findOrderOfDivisor ((Record (: ord (Integer)) (: num PolyRing) (: den PolyRing) (: upTo (Integer))) DIVISOR (Integer) (Integer)))): Not documented!!!!

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((LPolynomial ((SparseUnivariatePolynomial (Integer))))): Improper first word in comments: Returns
"Returns the L-Polynomial of the curve."

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((classNumber ((Integer)))): Improper first word in comments: Returns
"Returns the class number of the curve."

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((numberOfPlacesOfDegree ((Integer) PI))): Improper first word in comments: returns
"returns the number of places of the given degree"

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((numberPlacesDegExtDeg ((Integer) PI PI))): Improper first word in comments: numberRatPlacesExtDegExtDeg
"numberRatPlacesExtDegExtDeg(d, \\spad{n)} returns the number of places of degree \\spad{d} in the constant field extension of degree \\spad{n}"

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((ZetaFunction (UTSZ))): Improper first word in comments: Returns
"Returns the Zeta function of the curve. Calculated by using the L-Polynomial"

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((ZetaFunction (UTSZ PI))): Improper first word in comments: Returns
"Returns the Zeta function of the curve in constant field extension. Calculated by using the L-Polynomial"

=========================================================================
typos 40028:

>compiling PAFFFF.spad to PAFFFF.nrlib
 
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((homogenize (PolyRing PolyRing (Integer)))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((fullDesTree ((Void)))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((fullInfClsPt ((Void)))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((setCurve (PolyRing PolyRing))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((translateToOrigin (PolyRing2 PolyRing ProjPt))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((goppaCode ((Matrix K) DIVISOR DIVISOR))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((goppaCode ((Matrix K) DIVISOR (List Plc)))): Not documented!!!!

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((placesAbove ((List Plc) ProjPt))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((projectivePoint (ProjPt (List DK)))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((setSingularPoints ((List ProjPt) (List ProjPt)))): Not documented!!!!

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((genusNeg ((Integer)))): Not documented!!!!

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((rationalPoints ((List ProjPt)))): Not documented!!!!

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((singularPoints ((List ProjPt)))): Improper first word in comments: rationalPoints
"rationalPoints() returns the singular points of the curve defined by the polynomial given to the package. If the singular points lie in an extension of the specified ground field an error message is issued specifying the extension degree needed to find all singular points."

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((lBasis ((List FracPoly) DIVISOR NNI))): Not documented!!!!

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((findOrderOfDivisor ((Record (: ord (Integer)) (: num PolyRing) (: den PolyRing) (: upTo (Integer))) DIVISOR (Integer) (Integer)))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((interpolateFormsForFact ((List PolyRing2) DIVISOR (List PolyRing)))): Not documented!!!!

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((LPolynomial ((SparseUnivariatePolynomial (Integer))))): Improper first word in comments: Returns
"Returns the L-Polynomial of the curve."

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((classNumber ((Integer)))): Improper first word in comments: Returns
"Returns the class number of the curve."

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((numberOfPlacesOfDegree ((Integer) PI))): Improper first word in comments: returns
"returns the number of places of the given degree"

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((numberPlacesDegExtDeg ((Integer) PI PI))): Improper first word in comments: numberRatPlacesExtDegExtDeg
"numberRatPlacesExtDegExtDeg(d, \\spad{n)} returns the number of places of degree \\spad{d} in the constant field extension of degree \\spad{n}"

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((ZetaFunction (UTSZ))): Improper first word in comments: Returns
"Returns the Zeta function of the curve. Calculated by using the L-Polynomial"

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((ZetaFunction (UTSZ PI))): Improper first word in comments: Returns
"Returns the Zeta function of the curve in constant field extension. Calculated by using the L-Polynomial"

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((homogenize (PolyRing PolyRing (Integer)))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((interpolateFormsForFact ((List PolyRing) DIVISOR (List PolyRing)))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((fullDesTree ((Void)))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((fullInfClsPt ((Void)))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((setCurve (PolyRing PolyRing))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((projectivePoint (ProjPt (List K)))): Not documented!!!!

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((placesAbove ((List Plc) ProjPt))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((setSingularPoints ((List ProjPt) (List ProjPt)))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((goppaCode ((Matrix K) DIVISOR DIVISOR))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((goppaCode ((Matrix K) DIVISOR (List Plc)))): Not documented!!!!

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((genusNeg ((Integer)))): Not documented!!!!

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((rationalPoints ((List ProjPt)))): Not documented!!!!

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((singularPoints ((List ProjPt)))): Improper first word in comments: rationalPoints
"rationalPoints() returns the singular points of the curve defined by the polynomial given to the package. If the singular points lie in an extension of the specified ground field an error message is issued specifying the extension degree needed to find all singular points."

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((lBasis ((List FRACPOLY) DIVISOR NNI))): Not documented!!!!

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((findOrderOfDivisor ((Record (: ord (Integer)) (: num PolyRing) (: den PolyRing) (: upTo (Integer))) DIVISOR (Integer) (Integer)))): Not documented!!!!


--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((LPolynomial ((SparseUnivariatePolynomial (Integer))))): Improper first word in comments: Returns
"Returns the L-Polynomial of the curve."

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((classNumber ((Integer)))): Improper first word in comments: Returns
"Returns the class number of the curve."

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((numberOfPlacesOfDegree ((Integer) PI))): Improper first word in comments: returns
"returns the number of places of the given degree"

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((numberPlacesDegExtDeg ((Integer) PI PI))): Improper first word in comments: numberRatPlacesExtDegExtDeg
"numberRatPlacesExtDegExtDeg(d, \\spad{n)} returns the number of places of degree \\spad{d} in the constant field extension of degree \\spad{n}"

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((ZetaFunction (UTSZ))): Improper first word in comments: Returns
"Returns the Zeta function of the curve. Calculated by using the L-Polynomial"

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionField((ZetaFunction (UTSZ PI))): Improper first word in comments: Returns
"Returns the Zeta function of the curve in constant field extension. Calculated by using the L-Polynomial"

   PAFFFF abbreviates package 
      PackageForAlgebraicFunctionFieldOverFiniteField 

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((homogenize (PolyRing PolyRing (Integer)))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((fullDesTree ((Void)))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((fullInfClsPt ((Void)))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((setCurve (PolyRing PolyRing))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((translateToOrigin (PolyRing2 PolyRing ProjPt))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((goppaCode ((Matrix K) DIVISOR DIVISOR))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((goppaCode ((Matrix K) DIVISOR (List Plc)))): Not documented!!!!

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((placesAbove ((List Plc) ProjPt))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((projectivePoint (ProjPt (List DK)))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((setSingularPoints ((List ProjPt) (List ProjPt)))): Not documented!!!!

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((genusNeg ((Integer)))): Not documented!!!!

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((rationalPoints ((List ProjPt)))): Not documented!!!!

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((singularPoints ((List ProjPt)))): Improper first word in comments: rationalPoints
"rationalPoints() returns the singular points of the curve defined by the polynomial given to the package. If the singular points lie in an extension of the specified ground field an error message is issued specifying the extension degree needed to find all singular points."

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((lBasis ((List FracPoly) DIVISOR NNI))): Not documented!!!!

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((findOrderOfDivisor ((Record (: ord (Integer)) (: num PolyRing) (: den PolyRing) (: upTo (Integer))) DIVISOR (Integer) (Integer)))): Not documented!!!!
--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((interpolateFormsForFact ((List PolyRing2) DIVISOR (List PolyRing)))): Not documented!!!!

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((LPolynomial ((SparseUnivariatePolynomial (Integer))))): Improper first word in comments: Returns
"Returns the L-Polynomial of the curve."

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((classNumber ((Integer)))): Improper first word in comments: Returns
"Returns the class number of the curve."

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((numberOfPlacesOfDegree ((Integer) PI))): Improper first word in comments: returns
"returns the number of places of the given degree"

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((numberPlacesDegExtDeg ((Integer) PI PI))): Improper first word in comments: numberRatPlacesExtDegExtDeg
"numberRatPlacesExtDegExtDeg(d, \\spad{n)} returns the number of places of degree \\spad{d} in the constant field extension of degree \\spad{n}"

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((ZetaFunction (UTSZ))): Improper first word in comments: Returns
"Returns the Zeta function of the curve. Calculated by using the L-Polynomial"

--->bookvol10.4.pamphlet-->PackageForAlgebraicFunctionFieldOverFiniteField((ZetaFunction (UTSZ PI))): Improper first word in comments: Returns
"Returns the Zeta function of the curve in constant field extension. Calculated by using the L-Polynomial"

=========================================================================
typos 40027:

>compiling ABELGRP.spad to ABELGRP.nrlib

--->-->AbelianGroup&((- (% % %))): Missing left brace
"\\spad{x-y} is the difference of \\spad{x} and \\spad{y} \\spadignore{i.e.} \\spad{x + (-y)}."

--->-->AbelianGroup&(constructor): Missing left brace
"The class of abelian groups, \\spadignore{i.e.} additive monoids where each element has an additive inverse. \\blankline Axioms\\br \\tab{5}\\spad{-(-x) = x}\\br \\tab{5}\\spad{x+(-x) = 0}"

--->bookvol10.2.pamphlet-->AbelianGroup((- (% % %))): Missing left brace
"\\spad{x-y} is the difference of \\spad{x} and \\spad{y} \\spadignore{i.e.} \\spad{x + (-y)}."

--->bookvol10.2.pamphlet-->AbelianGroup(constructor): Missing left brace
"The class of abelian groups, \\spadignore{i.e.} additive monoids where each element has an additive inverse. \\blankline Axioms\\br \\tab{5}\\spad{-(-x) = x}\\br \\tab{5}\\spad{x+(-x) = 0}"

=========================================================================
typos 40026:

>compiling ABELMON.spad to ABELMON.nrlib

--->-->AbelianMonoid&(((Zero) (%) constant)): Improper first word in comments: 
"0 is the additive identity element."

--->-->AbelianMonoid&(constructor): Missing left brace
--->-->AbelianMonoid&(constructor): Missing left brace
"The class of multiplicative monoids, \\spadignore{i.e.} semigroups with an additive identity element. \\blankline Axioms\\br \\tab{5}\\spad{leftIdentity(\"+\":(\\%,\\%)->\\%,0)}\\tab{5}\\spad{ 0+x=x }\\br \\tab{5}\\spad{rightIdentity(\"+\":(\\%,\\%)->\\%,0)}\\tab{4}\\spad{ x+0=x }"

--->bookvol10.2.pamphlet-->AbelianMonoid(((Zero) (%) constant)): Improper first word in comments: 
"0 is the additive identity element."

--->bookvol10.2.pamphlet-->AbelianMonoid(constructor): Missing left brace
--->bookvol10.2.pamphlet-->AbelianMonoid(constructor): Missing left brace
"The class of multiplicative monoids, \\spadignore{i.e.} semigroups with an additive identity element. \\blankline Axioms\\br \\tab{5}\\spad{leftIdentity(\"+\":(\\%,\\%)->\\%,0)}\\tab{5}\\spad{ 0+x=x }\\br \\tab{5}\\spad{rightIdentity(\"+\":(\\%,\\%)->\\%,0)}\\tab{4}\\spad{ x+0=x }"

=========================================================================
typos 40025:

>compiling ABELSG.spad to ABELSG.nrlib
--->-->AbelianSemiGroup&(constructor): Missing left brace
--->-->AbelianSemiGroup&(constructor): Missing left brace
"The class of all additive (commutative) semigroups, \\spadignore{i.e.} a set with a commutative and associative operation \\spadop{+}. \\blankline Axioms\\br \\tab{5}\\spad{associative(\"+\":(\\%,\\%)->\\%)}\\tab{5}\\spad{ (x+y)+z = x+(y+z) }\\br \\tab{6}\\spad{commutative(\"+\":(\\%,\\%)->\\%)}\\tab{5}\\spad{ x+y = \\spad{y+x} }"

--->bookvol10.2.pamphlet-->AbelianSemiGroup(constructor): Missing left brace
--->bookvol10.2.pamphlet-->AbelianSemiGroup(constructor): Missing left brace
"The class of all additive (commutative) semigroups, \\spadignore{i.e.} a set with a commutative and associative operation \\spadop{+}. \\blankline Axioms\\br \\tab{5}\\spad{associative(\"+\":(\\%,\\%)->\\%)}\\tab{5}\\spad{ (x+y)+z = x+(y+z) }\\br \\tab{6}\\spad{commutative(\"+\":(\\%,\\%)->\\%)}\\tab{5}\\spad{ x+y = \\spad{y+x} }"

=========================================================================
typos 40024:

>compiling BOOLEAN.spad to BOOLEAN.nrlib

--->bookvol10.3.pamphlet-->Boolean((true (%) constant)): Improper initial operator in comments: is
"\\spad{true} is a logical constant."
--------(false (%) constant)---------
--->bookvol10.3.pamphlet-->Boolean((false (%) constant)): Improper initial operator in comments: is
"\\spad{false} is a logical constant."

=========================================================================
typos 40023:

>compiling CABMON.spad to CABMON.nrlib

--->bookvol10.2.pamphlet-->CancellationAbelianMonoid(constructor): Missing left brace
"This is an \\spadtype{AbelianMonoid} with the cancellation property, \\spadignore{i.e.} \\tab{5}\\spad{ a+b = a+c \\spad{=>} \\spad{b=c} }.\\br This is formalised by the partial subtraction operator, which satisfies the Axioms\\br \\tab{5}\\spad{c = a+b \\spad{<=>} \\spad{c-b} = a}"

=========================================================================
typos 40022:

>compiling CHAR.spad to CHAR.nrlib

--->bookvol10.3.pamphlet-->Character((ord ((Integer) %))): Improper first word in comments: 
"\\indented{1}{ord(c) provides an integral code corresponding to the} \\indented{1}{character c.\\space{2}It is always \\spad{true} that \\spad{char ord \\spad{c} = c}.} \\blankline \\spad{X} chars \\spad{:=} [char \"a\", char \"A\", char \"X\", char \"8\", char \"+\"] \\spad{X} [ord \\spad{c} for \\spad{c} in chars]"

--->bookvol10.3.pamphlet-->Character((char (% (Integer)))): Improper first word in comments: 
"\\indented{1}{char(i) provides a character corresponding to the integer} \\indented{1}{code i. It is always \\spad{true} that \\spad{ord char \\spad{i} = i}.} \\blankline \\spad{X} [char \\spad{c} for \\spad{c} in [97,65,88,56,43]]"

--->bookvol10.3.pamphlet-->Character((char (% (String)))): Improper first word in comments: 
"\\indented{1}{char(s) provides a character from a string \\spad{s} of length one.} \\blankline \\spad{X} [char \\spad{c} for \\spad{c} in [\"a\",\"A\",\"X\",\"8\",\"+\"]]"

--->bookvol10.3.pamphlet-->Character((space (%))): Improper first word in comments: 
"\\indented{1}{space() provides the blank character.} \\blankline \\spad{X} space()"

--->bookvol10.3.pamphlet-->Character((quote (%))): Improper first word in comments: 
"\\indented{1}{quote() provides the string quote character, \\spad{\"}.} \\blankline \\spad{X} quote()"

--->bookvol10.3.pamphlet-->Character((escape (%))): Improper first word in comments: 
"\\indented{1}{escape() provides the escape character, \\spad{_}, which} \\indented{1}{is used to allow quotes and other characters within} \\indented{1}{strings.} \\blankline \\spad{X} escape()"

--->bookvol10.3.pamphlet-->Character((upperCase (% %))): Improper first word in comments: 
"\\indented{1}{upperCase(c) converts a lower case letter to the corresponding} \\indented{1}{upper case letter.\\space{2}If \\spad{c} is not a lower case letter, then} \\indented{1}{it is returned unchanged.} \\blankline \\spad{X} chars \\spad{:=} [char \"a\", char \"A\", char \"X\", char \"8\", char \"+\"] \\spad{X} [upperCase \\spad{c} for \\spad{c} in chars]"

--->bookvol10.3.pamphlet-->Character((lowerCase (% %))): Improper first word in comments: 
"\\indented{1}{lowerCase(c) converts an upper case letter to the corresponding} \\indented{1}{lower case letter.\\space{2}If \\spad{c} is not an upper case letter, then} \\indented{1}{it is returned unchanged.} \\blankline \\spad{X} chars \\spad{:=} [char \"a\", char \"A\", char \"X\", char \"8\", char \"+\"] \\spad{X} [lowerCase \\spad{c} for \\spad{c} in chars]"

--->bookvol10.3.pamphlet-->Character((digit? ((Boolean) %))): Improper first word in comments: 
--->bookvol10.3.pamphlet-->Character((digit? ((Boolean) %))): Missing left brace
"\\indented{1}{digit?(c) tests if \\spad{c} is a digit character,} \\indented{1}{\\spadignore{i.e.} one of 0..9.} \\blankline \\spad{X} chars \\spad{:=} [char \"a\", char \"A\", char \"X\", char \"8\", char \"+\"] \\spad{X} [digit? \\spad{c} for \\spad{c} in chars]"

--->bookvol10.3.pamphlet-->Character((hexDigit? ((Boolean) %))): Improper first word in comments: 
--->bookvol10.3.pamphlet-->Character((hexDigit? ((Boolean) %))): Missing left brace
"\\indented{1}{hexDigit?(c) tests if \\spad{c} is a hexadecimal numeral,} \\indented{1}{\\spadignore{i.e.} one of 0..9, a..f or A..F.} \\blankline \\spad{X} chars \\spad{:=} [char \"a\", char \"A\", char \"X\", char \"8\", char \"+\"] \\spad{X} [hexDigit? \\spad{c} for \\spad{c} in chars]"

--->bookvol10.3.pamphlet-->Character((alphabetic? ((Boolean) %))): Improper first word in comments: 
--->bookvol10.3.pamphlet-->Character((alphabetic? ((Boolean) %))): Missing left brace
"\\indented{1}{alphabetic?(c) tests if \\spad{c} is a letter,} \\indented{1}{\\spadignore{i.e.} one of a..z or A..Z.} \\blankline \\spad{X} chars \\spad{:=} [char \"a\", char \"A\", char \"X\", char \"8\", char \"+\"] \\spad{X} [alphabetic? \\spad{c} for \\spad{c} in chars]"

--->bookvol10.3.pamphlet-->Character((upperCase? ((Boolean) %))): Improper first word in comments: 
--->bookvol10.3.pamphlet-->Character((upperCase? ((Boolean) %))): Missing left brace
"\\indented{1}{upperCase?(c) tests if \\spad{c} is an upper case letter,} \\indented{1}{\\spadignore{i.e.} one of A..Z.} \\blankline \\spad{X} chars \\spad{:=} [char \"a\", char \"A\", char \"X\", char \"8\", char \"+\"] \\spad{X} [upperCase? \\spad{c} for \\spad{c} in chars]"

--->bookvol10.3.pamphlet-->Character((lowerCase? ((Boolean) %))): Improper first word in comments: 
--->bookvol10.3.pamphlet-->Character((lowerCase? ((Boolean) %))): Missing left brace
"\\indented{1}{lowerCase?(c) tests if \\spad{c} is an lower case letter,} \\indented{1}{\\spadignore{i.e.} one of a..z.} \\blankline \\spad{X} chars \\spad{:=} [char \"a\", char \"A\", char \"X\", char \"8\", char \"+\"] \\spad{X} [lowerCase? \\spad{c} for \\spad{c} in chars]"

--->bookvol10.3.pamphlet-->Character((alphanumeric? ((Boolean) %))): Improper first word in comments: 
--->bookvol10.3.pamphlet-->Character((alphanumeric? ((Boolean) %))): Missing left brace
"\\indented{1}{alphanumeric?(c) tests if \\spad{c} is either a letter or number,} \\indented{1}{\\spadignore{i.e.} one of 0..9, a..z or A..Z.} \\blankline \\spad{X} chars \\spad{:=} [char \"a\", char \"A\", char \"X\", char \"8\", char \"+\"] \\spad{X} [alphanumeric? \\spad{c} for \\spad{c} in chars]"

=========================================================================
typos 40021:

>compiling CLAGG.spad to CLAGG.nrlib
 
--->-->Collection&((reduce (S (Mapping S S S) %))): Improper first word in comments: 
"\\indented{1}{reduce(f,u) reduces the binary operation \\spad{f} across u. For example,} \\indented{1}{if \\spad{u} is \\axiom{[x,y,...,z]} then \\axiom{reduce(f,u)}} \\indented{1}{returns \\axiom{f(..f(f(x,y),...),z)}.} \\indented{1}{Note that if \\spad{u} has one element \\spad{x,} \\axiom{reduce(f,u)} returns \\spad{x.}} \\indented{1}{Error: if \\spad{u} is empty.} \\blankline \\spad{C} )clear all \\spad{X} reduce(+,[C[i]*x**i for \\spad{i} in 1..5])"

--->-->Collection&(constructor): Missing left brace
"A collection is a homogeneous aggregate which can built from list of members. The operation used to build the aggregate is generically named \\spadfun{construct}. However, each collection provides its own special function with the same name as the data type, except with an initial lower case letter, \\spadignore{e.g.} \\spadfun{list} for \\spadtype{List}, \\spadfun{flexibleArray} for \\spadtype{FlexibleArray}, and so on."

--->bookvol10.2.pamphlet-->Collection((reduce (S (Mapping S S S) %))): Improper first word in comments: 
"\\indented{1}{reduce(f,u) reduces the binary operation \\spad{f} across u. For example,} \\indented{1}{if \\spad{u} is \\axiom{[x,y,...,z]} then \\axiom{reduce(f,u)}} \\indented{1}{returns \\axiom{f(..f(f(x,y),...),z)}.} \\indented{1}{Note that if \\spad{u} has one element \\spad{x,} \\axiom{reduce(f,u)} returns \\spad{x.}} \\indented{1}{Error: if \\spad{u} is empty.} \\blankline \\spad{C} )clear all \\spad{X} reduce(+,[C[i]*x**i for \\spad{i} in 1..5])"

--->bookvol10.2.pamphlet-->Collection(constructor): Missing left brace
"A collection is a homogeneous aggregate which can built from list of members. The operation used to build the aggregate is generically named \\spadfun{construct}. However, each collection provides its own special function with the same name as the data type, except with an initial lower case letter, \\spadignore{e.g.} \\spadfun{list} for \\spadtype{List}, \\spadfun{flexibleArray} for \\spadtype{FlexibleArray}, and so on."

=========================================================================
typos 40020:

>compiling COMRING.spad to COMRING.nrlib

--->bookvol10.2.pamphlet-->CommutativeRing(constructor): Missing left brace
"The category of commutative rings with unity, \\spadignore{i.e.} rings where \\spadop{*} is commutative, and which have a multiplicative identity element."

=========================================================================
typos 40019:

>compiling DFLOAT.spad to DFLOAT.nrlib
 
--->bookvol10.3.pamphlet-->DoubleFloat((doubleFloatFormat ((String) (String)))): Improper first word in comments: change
"change the output format for doublefloats using lisp format strings"

--->bookvol10.3.pamphlet-->DoubleFloat((machineFraction ((Fraction (Integer)) %))): Improper first word in comments: 
"\\indented{1}{machineFraction(x) returns a bit-exact fraction of the machine} \\indented{1}{floating point number using the common lisp integer-decode-float} \\indented{1}{function. See Steele, ISBN 0-13-152414-3 p354} \\indented{1}{This function can be used to print results which do not depend} \\indented{1}{on binary-to-decimal conversions} \\blankline \\spad{X} \\spad{a:DFLOAT:=-1.0/3.0} \\spad{X} machineFraction a"

--->bookvol10.3.pamphlet-->DoubleFloat((integerDecode ((List (Integer)) %))): Improper first word in comments: 
"\\indented{1}{integerDecode(x) returns the multiple values of the\\space{2}common} \\indented{1}{lisp integer-decode-float function.} \\indented{1}{See Steele, ISBN 0-13-152414-3 p354. This function can be used} \\indented{1}{to ensure that the results are bit-exact and do not depend on} \\indented{1}{the binary-to-decimal conversions.} \\blankline \\spad{X} \\spad{a:DFLOAT:=-1.0/3.0} \\spad{X} integerDecode a"

=========================================================================
typos 40018:

>compiling DIVRING.spad to DIVRING.nrlib

--->-->DivisionRing&(constructor): Missing left brace
"A division ring (sometimes called a skew field), \\spadignore{i.e.} a not necessarily commutative ring where all non-zero elements have multiplicative inverses."

--->bookvol10.2.pamphlet-->DivisionRing(constructor): Missing left brace
"A division ring (sometimes called a skew field), \\spadignore{i.e.} a not necessarily commutative ring where all non-zero elements have multiplicative inverses."

=========================================================================
typos 40017:

>compiling ENTIRER.spad to ENTIRER.nrlib

--->bookvol10.2.pamphlet-->EntireRing(constructor): Missing left brace
"Entire Rings (non-commutative Integral Domains), \\spadignore{i.e.} a ring not necessarily commutative which has no zero divisors. \\blankline Axioms\\br \\tab{5}\\spad{ab=0 \\spad{=>} \\spad{a=0} or b=0} \\spad{--} known as noZeroDivisors\\br \\tab{5}\\spad{not(1=0)}"

=========================================================================
typos 40016:

>compiling ES.spad to ES.nrlib
 
--->-->ExpressionSpace&((mainKernel ((Union K failed) %))): Mismatch: left pren matches right brace
"\\spad{mainKernel(f)} returns a kernel of \\spad{f} with maximum nesting level, or if \\spad{f} has no kernels (\\spadignore{i.e.} \\spad{f} is a constant)."

--->bookvol10.2.pamphlet-->ExpressionSpace((mainKernel ((Union K failed) %))): Mismatch: left pren matches right brace
"\\spad{mainKernel(f)} returns a kernel of \\spad{f} with maximum nesting level, or if \\spad{f} has no kernels (\\spadignore{i.e.} \\spad{f} is a constant)."

=========================================================================
typos 40015:

>compiling EUCDOM.spad to EUCDOM.nrlib
 
--->-->EuclideanDomain&(constructor): Missing left brace
"A constructive euclidean domain, \\spadignore{i.e.} one can divide producing a quotient and a remainder where the remainder is either zero or is smaller (\\spadfun{euclideanSize}) than the divisor. \\blankline Conditional attributes\\br \\tab{5}multiplicativeValuation\\tab{5}Size(a*b)=Size(a)*Size(b)\\br \\tab{5}additiveValuation\\tab{11}Size(a*b)=Size(a)+Size(b)"

--->bookvol10.2.pamphlet-->EuclideanDomain(constructor): Missing left brace
"A constructive euclidean domain, \\spadignore{i.e.} one can divide producing a quotient and a remainder where the remainder is either zero or is smaller (\\spadfun{euclideanSize}) than the divisor. \\blankline Conditional attributes\\br \\tab{5}multiplicativeValuation\\tab{5}Size(a*b)=Size(a)*Size(b)\\br \\tab{5}additiveValuation\\tab{11}Size(a*b)=Size(a)+Size(b)"

=========================================================================
typos 40014:

>compiling FFIELDC.spad to FFIELDC.nrlib
 
--->-->FiniteFieldCategory&((primitive? ((Boolean) $))): Missing left brace
"\\spad{primitive?(b)} tests whether the element \\spad{b} is a generator of the (cyclic) multiplicative group of the field, \\spadignore{i.e.} is a primitive element. Implementation Note that see ch.IX.1.3, \\spad{th.2} in \\spad{D.} Lipson."

--->bookvol10.2.pamphlet-->FiniteFieldCategory((primitive? ((Boolean) $))): Missing left brace
"\\spad{primitive?(b)} tests whether the element \\spad{b} is a generator of the (cyclic) multiplicative group of the field, \\spadignore{i.e.} is a primitive element. Implementation Note that see ch.IX.1.3, \\spad{th.2} in \\spad{D.} Lipson."

=========================================================================
typos 40013:

>compiling FPS.spad to FPS.nrlib

--->-->FloatingPointSystem&((base ((PositiveInteger)))): Improper first word in comments: 
"\\indented{1}{base() returns the base of the} \\spadfunFrom{exponent}{FloatingPointSystem}."

--->bookvol10.2.pamphlet-->FloatingPointSystem((base ((PositiveInteger)))): Improper first word in comments: 
"\\indented{1}{base() returns the base of the} \\spadfunFrom{exponent}{FloatingPointSystem}."

=========================================================================
typos 40012:

>compiling INTDOM.spad to INTDOM.nrlib

--->-->IntegralDomain&((associates? ((Boolean) % %))): Missing left brace
"\\spad{associates?(x,y)} tests whether \\spad{x} and \\spad{y} are associates, \\spadignore{i.e.} differ by a unit factor."

--->-->IntegralDomain&((unit? ((Boolean) %))): Missing left brace
"\\spad{unit?(x)} tests whether \\spad{x} is a unit, \\spadignore{i.e.} is invertible."

--->-->IntegralDomain&(constructor): Missing left brace
"The category of commutative integral domains, \\spadignore{i.e.} commutative rings with no zero divisors. \\blankline Conditional attributes\\br canonicalUnitNormal\\tab{5}the canonical field is the same for all associates\\br canonicalsClosed\\tab{5}the product of two canonicals is itself canonical"

--->bookvol10.2.pamphlet-->IntegralDomain((associates? ((Boolean) % %))): Missing left brace
"\\spad{associates?(x,y)} tests whether \\spad{x} and \\spad{y} are associates, \\spadignore{i.e.} differ by a unit factor."

--->bookvol10.2.pamphlet-->IntegralDomain((unit? ((Boolean) %))): Missing left brace
"\\spad{unit?(x)} tests whether \\spad{x} is a unit, \\spadignore{i.e.} is invertible."

--->bookvol10.2.pamphlet-->IntegralDomain(constructor): Missing left brace
"The category of commutative integral domains, \\spadignore{i.e.} commutative rings with no zero divisors. \\blankline Conditional attributes\\br canonicalUnitNormal\\tab{5}the canonical field is the same for all associates\\br canonicalsClosed\\tab{5}the product of two canonicals is itself canonical"

=========================================================================
typos 40011:

>compiling LNAGG.spad to LNAGG.nrlib

--->-->LinearAggregate&(constructor): Mismatch: left pren matches right brace
"A linear aggregate is an aggregate whose elements are indexed by integers. Examples of linear aggregates are strings, lists, and arrays. Most of the exported operations for linear aggregates are non-destructive but are not always efficient for a particular aggregate. For example, \\spadfun{concat} of two lists needs only to copy its first argument, whereas \\spadfun{concat} of two arrays needs to copy both arguments. Most of the operations exported here apply to infinite objects (\\spadignore{e.g.} streams) as well to finite ones. For finite linear aggregates, see \\spadtype{FiniteLinearAggregate}."

--->bookvol10.2.pamphlet-->LinearAggregate(constructor): Mismatch: left pren matches right brace
"A linear aggregate is an aggregate whose elements are indexed by integers. Examples of linear aggregates are strings, lists, and arrays. Most of the exported operations for linear aggregates are non-destructive but are not always efficient for a particular aggregate. For example, \\spadfun{concat} of two lists needs only to copy its first argument, whereas \\spadfun{concat} of two arrays needs to copy both arguments. Most of the operations exported here apply to infinite objects (\\spadignore{e.g.} streams) as well to finite ones. For finite linear aggregates, see \\spadtype{FiniteLinearAggregate}."

=========================================================================
typos 40010:

>compiling MONOID.spad to MONOID.nrlib

--->-->Monoid&(((One) (%) constant)): Improper first word in comments: 
"1 is the multiplicative identity."

--->-->Monoid&((** (% % (NonNegativeInteger)))): Missing left brace
"\\spad{x**n} returns the repeated product of \\spad{x} \\spad{n} times, \\spadignore{i.e.} exponentiation."

--->-->Monoid&((^ (% % (NonNegativeInteger)))): Missing left brace
"\\spad{x^n} returns the repeated product of \\spad{x} \\spad{n} times, \\spadignore{i.e.} exponentiation."

--->-->Monoid&(constructor): Missing left brace
"The class of multiplicative monoids, \\spadignore{i.e.} semigroups with a multiplicative identity element. \\blankline Axioms\\br \\tab{5}\\spad{leftIdentity(\"*\":(\\%,\\%)->\\%,1)}\\tab{5}\\spad{1*x=x}\\br \\tab{5}\\spad{rightIdentity(\"*\":(\\%,\\%)->\\%,1)}\\tab{4}\\spad{x*1=x} \\blankline Conditional attributes\\br \\tab{5}unitsKnown - \\spadfun{recip} only returns \"failed\" on non-units"

--->bookvol10.2.pamphlet-->Monoid(((One) (%) constant)): Improper first word in comments: 
"1 is the multiplicative identity."

--->bookvol10.2.pamphlet-->Monoid((** (% % (NonNegativeInteger)))): Missing left brace
"\\spad{x**n} returns the repeated product of \\spad{x} \\spad{n} times, \\spadignore{i.e.} exponentiation."

--->bookvol10.2.pamphlet-->Monoid((^ (% % (NonNegativeInteger)))): Missing left brace
"\\spad{x^n} returns the repeated product of \\spad{x} \\spad{n} times, \\spadignore{i.e.} exponentiation."

--->bookvol10.2.pamphlet-->Monoid(constructor): Missing left brace
"The class of multiplicative monoids, \\spadignore{i.e.} semigroups with a multiplicative identity element. \\blankline Axioms\\br \\tab{5}\\spad{leftIdentity(\"*\":(\\%,\\%)->\\%,1)}\\tab{5}\\spad{1*x=x}\\br \\tab{5}\\spad{rightIdentity(\"*\":(\\%,\\%)->\\%,1)}\\tab{4}\\spad{x*1=x} \\blankline Conditional attributes\\br \\tab{5}unitsKnown - \\spadfun{recip} only returns \"failed\" on non-units"

=========================================================================
typos 40008:

>compiling OUTFORM.spad to OUTFORM.nrlib

--->bookvol10.3.pamphlet-->OutputForm((differentiate ($ $ (NonNegativeInteger)))): Missing left brace
"\\spad{differentiate(f,n)} creates a form for the \\spad{n}th derivative of \\spad{f,} \\spadignore{e.g.} \\spad{f'}, \\spad{f''}, \\spad{f'''}, \\spad{\"f} super \\spad{iv}\"."

--->bookvol10.3.pamphlet-->OutputForm((pile ($ (List $)))): Missing left brace
"\\spad{pile(l)} creates the form consisting of the elements of \\spad{l} which displays as a pile, \\spadignore{i.e.} the elements begin on a new line and are indented right to the same margin."

--->bookvol10.3.pamphlet-->OutputForm(constructor): Mismatch: left pren matches right brace
"This domain is used to create and manipulate mathematical expressions for output. It is intended to provide an insulating layer between the expression rendering software (\\spadignore{e.g.} TeX, or Script) and the output coercions in the various domains."

=========================================================================
typos 40006:

>compiling POLYCAT.spad to POLYCAT.nrlib
 
--->-->PolynomialCategory&((coefficient (% % (List VarSet) (List (NonNegativeInteger))))): Missing left brace
"\\spad{coefficient(p, \\spad{lv,} ln)} views the polynomial \\spad{p} as a polynomial in the variables of \\spad{lv} and returns the coefficient of the term \\spad{lv**ln}, \\spadignore{i.e.} \\spad{prod(lv_i \\spad{**} ln_i)}."

--->-->PolynomialCategory&((monomials ((List %) %))): Missing left brace
"\\spad{monomials(p)} returns the list of non-zero monomials of polynomial \\spad{p,} \\spadignore{i.e.} \\spad{monomials(sum(a_(i) X^(i))) = [a_(1) X^(1),...,a_(n) X^(n)]}."

--->-->PolynomialCategory&((minimumDegree ((NonNegativeInteger) % VarSet))): Missing left brace
"\\spad{minimumDegree(p,v)} gives the minimum degree of polynomial \\spad{p} with respect to \\spad{v,} \\spadignore{i.e.} viewed a univariate polynomial in \\spad{v}"

--->bookvol10.2.pamphlet-->PolynomialCategory((coefficient (% % (List VarSet) (List (NonNegativeInteger))))): Missing left brace
"\\spad{coefficient(p, \\spad{lv,} ln)} views the polynomial \\spad{p} as a polynomial in the variables of \\spad{lv} and returns the coefficient of the term \\spad{lv**ln}, \\spadignore{i.e.} \\spad{prod(lv_i \\spad{**} ln_i)}."

--->bookvol10.2.pamphlet-->PolynomialCategory((monomials ((List %) %))): Missing left brace
"\\spad{monomials(p)} returns the list of non-zero monomials of polynomial \\spad{p,} \\spadignore{i.e.} \\spad{monomials(sum(a_(i) X^(i))) = [a_(1) X^(1),...,a_(n) X^(n)]}."

--->bookvol10.2.pamphlet-->PolynomialCategory((minimumDegree ((NonNegativeInteger) % VarSet))): Missing left brace
"\\spad{minimumDegree(p,v)} gives the minimum degree of polynomial \\spad{p} with respect to \\spad{v,} \\spadignore{i.e.} viewed a univariate polynomial in \\spad{v}"

=========================================================================
typos 40005:

>compiling PSETCAT.spad to PSETCAT.nrlib
 
--->-->PolynomialSetCategory&((triangular? ((Boolean) $))): Missing left brace
"\\axiom{triangular?(ps)} returns \\spad{true} iff \\axiom{ps} is a triangular set, \\spadignore{i.e.} two distinct polynomials have distinct main variables and no constant lies in \\axiom{ps}."

--->bookvol10.2.pamphlet-->PolynomialSetCategory((triangular? ((Boolean) $))): Missing left brace
"\\axiom{triangular?(ps)} returns \\spad{true} iff \\axiom{ps} is a triangular set, \\spadignore{i.e.} two distinct polynomials have distinct main variables and no constant lies in \\axiom{ps}."

=========================================================================
typos 40004:

>compiling QFCAT.spad to QFCAT.nrlib
 
--->-->QuotientFieldCategory&((wholePart (S %))): Missing left brace
"\\spad{wholePart(x)} returns the whole part of the fraction \\spad{x} \\spadignore{i.e.} the truncated quotient of the numerator by the denominator."

--->bookvol10.2.pamphlet-->QuotientFieldCategory((wholePart (S %))): Missing left brace
"\\spad{wholePart(x)} returns the whole part of the fraction \\spad{x} \\spadignore{i.e.} the truncated quotient of the numerator by the denominator."

=========================================================================
typos 40003:

>compiling RNG.spad to RNG.nrlib

--->bookvol10.2.pamphlet-->Rng(constructor): Missing left brace
"The category of associative rings, not necessarily commutative, and not necessarily with a 1. This is a combination of an abelian group and a semigroup, with multiplication distributing over addition. \\blankline Axioms\\br \\tab{5}\\spad{ x*(y+z) = x*y + x*z}\\br \\tab{5}\\spad{ (x+y)*z = \\spad{x*z} + \\spad{y*z} } \\blankline Conditional attributes\\br \\tab{5}noZeroDivisors\\tab{5}\\spad{ ab = 0 \\spad{=>} \\spad{a=0} or b=0}"

=========================================================================
typos 40002:

>compiling SINT.spad to SINT.nrlib
 
--->bookvol10.3.pamphlet-->SingleInteger((/\ (% % %))): Improper initial operator in comments: /
"\\spad{n} \\spad{/\\} \\spad{m} returns the bit-by-bit logical and of the single integers \\spad{n} and \\spad{m.}"

--->bookvol10.3.pamphlet-->SingleInteger((\/ (% % %))): Improper first word in comments: n
"\\spad{n} \\spad{\\/} \\spad{m} returns the bit-by-bit logical or of the single integers \\spad{n} and \\spad{m.}"

=========================================================================
typos 40001:

>compiling UFD.spad to UFD.nrlib
 
--->-->UniqueFactorizationDomain&((prime? ((Boolean) %))): Missing left brace
"\\spad{prime?(x)} tests if \\spad{x} can never be written as the product of two non-units of the ring, \\spadignore{i.e.} \\spad{x} is an irreducible element."

--->-->UniqueFactorizationDomain&((squareFree ((Factored %) %))): Missing left brace
"\\spad{squareFree(x)} returns the square-free factorization of \\spad{x} \\spadignore{i.e.} such that the factors are pairwise relatively prime and each has multiple prime factors."

--->-->UniqueFactorizationDomain&(constructor): Missing left brace
"A constructive unique factorization domain, \\spadignore{i.e.} where we can constructively factor members into a product of a finite number of irreducible elements."

--->bookvol10.2.pamphlet-->UniqueFactorizationDomain((prime? ((Boolean) %))): Missing left brace
"\\spad{prime?(x)} tests if \\spad{x} can never be written as the product of two non-units of the ring, \\spadignore{i.e.} \\spad{x} is an irreducible element."

--->bookvol10.2.pamphlet-->UniqueFactorizationDomain((squareFree ((Factored %) %))): Missing left brace
"\\spad{squareFree(x)} returns the square-free factorization of \\spad{x} \\spadignore{i.e.} such that the factors are pairwise relatively prime and each has multiple prime factors."

--->bookvol10.2.pamphlet-->UniqueFactorizationDomain(constructor): Missing left brace
"A constructive unique factorization domain, \\spadignore{i.e.} where we can constructively factor members into a product of a finite number of irreducible elements."

=========================================================================
typos 40000:

>compiling UPOLYC.spad to UPOLYC.nrlib
 
--->-->UnivariatePolynomialCategory&((pseudoRemainder (% % %))): Missing left brace
"\\spad{pseudoRemainder(p,q)} = \\spad{r,} for polynomials \\spad{p} and \\spad{q,} returns the remainder when \\spad{p' \\spad{:=} p*lc(q)**(deg \\spad{p} - deg \\spad{q} + 1)} is pseudo right-divided by \\spad{q,} \\spadignore{i.e.} \\spad{p' = \\spad{s} \\spad{q} + \\spad{r}.}"

--->-->UnivariatePolynomialCategory&((order ((NonNegativeInteger) % %))): Missing left brace
"\\spad{order(p, \\spad{q)}} returns the largest \\spad{n} such that \\spad{q**n} divides polynomial \\spad{p} \\spadignore{i.e.} the order of \\spad{p(x)} at \\spad{q(x)=0}."

--->-->UnivariatePolynomialCategory&((pseudoQuotient (% % %))): Missing left brace
"\\spad{pseudoQuotient(p,q)} returns \\spad{r,} the quotient when \\spad{p' \\spad{:=} p*lc(q)**(deg \\spad{p} - deg \\spad{q} + 1)} is pseudo right-divided by \\spad{q,} \\spadignore{i.e.} \\spad{p' = \\spad{s} \\spad{q} + \\spad{r}.}"

--->-->UnivariatePolynomialCategory&((pseudoDivide ((Record (: coef R) (: quotient %) (: remainder %)) % %))): Missing left brace
"\\spad{pseudoDivide(p,q)} returns \\spad{[c, \\spad{q,} r]}, when \\spad{p' \\spad{:=} p*lc(q)**(deg \\spad{p} - deg \\spad{q} + 1) = \\spad{c} * \\spad{p}} is pseudo right-divided by \\spad{q,} \\spadignore{i.e.} \\spad{p' = \\spad{s} \\spad{q} + \\spad{r}.}"

--->bookvol10.2.pamphlet-->UnivariatePolynomialCategory((pseudoRemainder (% % %))): Missing left brace
"\\spad{pseudoRemainder(p,q)} = \\spad{r,} for polynomials \\spad{p} and \\spad{q,} returns the remainder when \\spad{p' \\spad{:=} p*lc(q)**(deg \\spad{p} - deg \\spad{q} + 1)} is pseudo right-divided by \\spad{q,} \\spadignore{i.e.} \\spad{p' = \\spad{s} \\spad{q} + \\spad{r}.}"

--->bookvol10.2.pamphlet-->UnivariatePolynomialCategory((order ((NonNegativeInteger) % %))): Missing left brace
"\\spad{order(p, \\spad{q)}} returns the largest \\spad{n} such that \\spad{q**n} divides polynomial \\spad{p} \\spadignore{i.e.} the order of \\spad{p(x)} at \\spad{q(x)=0}."

--->bookvol10.2.pamphlet-->UnivariatePolynomialCategory((pseudoQuotient (% % %))): Missing left brace
"\\spad{pseudoQuotient(p,q)} returns \\spad{r,} the quotient when \\spad{p' \\spad{:=} p*lc(q)**(deg \\spad{p} - deg \\spad{q} + 1)} is pseudo right-divided by \\spad{q,} \\spadignore{i.e.} \\spad{p' = \\spad{s} \\spad{q} + \\spad{r}.}"

--->bookvol10.2.pamphlet-->UnivariatePolynomialCategory((pseudoDivide ((Record (: coef R) (: quotient %) (: remainder %)) % %))): Missing left brace
"\\spad{pseudoDivide(p,q)} returns \\spad{[c, \\spad{q,} r]}, when \\spad{p' \\spad{:=} p*lc(q)**(deg \\spad{p} - deg \\spad{q} + 1) = \\spad{c} * \\spad{p}} is pseudo right-divided by \\spad{q,} \\spadignore{i.e.} \\spad{p' = \\spad{s} \\spad{q} + \\spad{r}.}"

=========================================================================
macros 30233:

>compiling COMPCAT.spad to COMPCAT.nrlib

   processing macro definition stoc ==> elt(Lisp,S-TO-C) 
   processing macro definition ctos ==> elt(Lisp,C-TO-S) 

=========================================================================
macros 30232:

>compiling FLOAT.spad to FLOAT.nrlib

   processing macro definition zero ==> char 0 
   processing macro definition separator ==> (elt (Character) space) 
   compiling local padFromLeft : String -> String

=========================================================================
macros 30231:

>compiling CDFVEC.spad to CDFVEC.nrlib

   processing macro definition Qsize ==> elt(Lisp,CDLEN) 
   processing macro definition Qnew ==> elt(Lisp,MAKE-CDOUBLE-VECTOR) 

=========================================================================
macros 30229:

      AGG-;eq?;2SB;1 is replaced by EQ 

=========================================================================
macros 30228:

      ANY;dom;$Se;2 is replaced by QCAR 
      ANY;domainOf;$Of;3 is replaced by QCAR 
      ANY;obj;$N;1 is replaced by QCDR 

=========================================================================
macros 30227:

      APPRULE;localUnquote;FLF;8 is replaced by f 

=========================================================================
macros 30226:

      AUTOMOR;=;2$B;4 is replaced by EQ 
      AUTOMOR;err is replaced by errorMorphism is not invertible 
      AUTOMOR;ident is replaced by r 
      AUTOMOR;morphism;M$;9 is replaced by f 

=========================================================================
macros 30225:

      BINARY;coerce;$Re;2 is replaced by x 

=========================================================================
macros 30224:

      BLAS1;dasum;SiPaSiDf;2 is replaced by DASUM 
      BLAS1;daxpy;SiDfPaSiPaSiPa;3 is replaced by DAXPY 
      BLAS1;dcopy;SiPaSiPaSiPa;4 is replaced by DCOPY 
      BLAS1;ddot;SiPaSiPaSiDf;5 is replaced by DDOT 
      BLAS1;dnrm2;SiPaSiDf;6 is replaced by DNRM2 
      BLAS1;drot;SiPaSiPaSi2DfL;8 is replaced by DROT 
      BLAS1;drotg;4DfPa;7 is replaced by DROTG 
      BLAS1;dscal;SiDfPaSiPa;9 is replaced by DSCAL 
      BLAS1;dswap;SiPaSiPaSiL;10 is replaced by DSWAPndxincxdyincx 
      BLAS1;dzasum;SiPaSiDf;11 is replaced by DZASUMSPAD 
      BLAS1;dznrm2;SiPaSiDf;12 is replaced by DZNRM2SPAD 
      BLAS1;icamax;IPa2I;13 is replaced by ICAMAXSPAD 
      BLAS1;idamax;IPa2I;14 is replaced by IDAMAX 
      BLAS1;isamax;IPa2I;15 is replaced by ISAMAXSPAD 
      BLAS1;izamax;SiPaSiI;16 is replaced by IZAMAXSPAD 
      BLAS1;zaxpy;SiCPaSiPaSiPa;17 is replaced by ZAXPYSPAD 

=========================================================================
macros 30223:

      BLQT;chartCoord;$I;4 is replaced by QVELTa2 
      BLQT;excepCoord;$I;3 is replaced by QVELTa0 
      BLQT;quotValuation;$I;7 is replaced by 1 
      BLQT;ramifMult;$I;2 is replaced by 1 
      BLQT;ramifMult;$I;6 is replaced by QVELTa3 
      BLQT;transCoord;$I;5 is replaced by QVELTa1 

=========================================================================
macros 30222:

      BOOLEAN;=;3$;15 is replaced by BooleanEquality 
      BOOLEAN;false;$;4 is replaced by  
      BOOLEAN;size;Nni;18 is replaced by 2 
      BOOLEAN;test;2$;1 is replaced by a 
      BOOLEAN;true;$;3 is replaced by QUOTET 

=========================================================================
macros 30221:

      BOP1;cdisp is replaced by a 
      BOP1;csex is replaced by a 

=========================================================================
macros 30220:

      BOP;name;$S;2 is replaced by QVELTop0 
      BOP;oper is replaced by VECTOR 
      BOP;properties;$Al;3 is replaced by QVELTop2 

=========================================================================
macros 30219:

      BTREE;empty;$;2 is replaced by  
      BTREE;empty;$;3 is replaced by  
      BTREE;empty?;$B;7 is replaced by NULL 

=========================================================================
macros 30218:

      CARD;Aleph;Nni$;4 is replaced by CONSn-1 
      CARD;One;$;2 is replaced by CONS-11 
      CARD;Zero;$;1 is replaced by CONS-10 
      CARD;coerce;Nni$;3 is replaced by CONS-1n 

=========================================================================
macros 30217:

      CDFMAT;empty;$;9 is replaced by MAKE-CDOUBLE-MATRIX00 
      CDFMAT;minColIndex;$I;2 is replaced by 0 
      CDFMAT;ncols;$Nni;4 is replaced by CDANCOLS 
      CDFMAT;nrows;$Nni;3 is replaced by CDANROWS 
      CDFMAT;qelt;$2IC;7 is replaced by CDAREF2 
      CDFMAT;qnew;2I$;10 is replaced by MAKE-CDOUBLE-MATRIX 
      CDFMAT;qsetelt!;$2I2C;8 is replaced by CDSETAREF2 

=========================================================================
macros 30216:

      CDFVEC;#;$Nni;3 is replaced by CDLEN 
      CDFVEC;elt;$IC;9 is replaced by CDELT 
      CDFVEC;empty;$;5 is replaced by MAKE-CDOUBLE-VECTOR0 
      CDFVEC;minIndex;$I;4 is replaced by 0 
      CDFVEC;qelt;$IC;1 is replaced by CDELT 
      CDFVEC;qelt;$IC;8 is replaced by CDELT 
      CDFVEC;qnew;I$;6 is replaced by MAKE-CDOUBLE-VECTOR 
      CDFVEC;qsetelt!;$I2C;10 is replaced by CDSETELT 
      CDFVEC;qsetelt!;$I2C;2 is replaced by CDSETELT 
      CDFVEC;setelt;$I2C;11 is replaced by CDSETELT 

=========================================================================
macros 30215:

      CHAR;<;2$B;2 is replaced by QSLESSP 
      CHAR;=;2$B;1 is replaced by EQL 
      CHAR;escape;$;11 is replaced by QENUM_ 0 
      CHAR;ord;$I;7 is replaced by c 
      CHAR;quote;$;10 is replaced by QENUM" 0 
      CHAR;size;Nni;3 is replaced by 256 
      CHAR;space;$;9 is replaced by QENUM   0 

=========================================================================
macros 30214:

      COMPCAT-;rank;Pi;7 is replaced by 2 

=========================================================================
macros 30213:

      COMPLEX;complex;2R$;11 is replaced by CONS 
      COMPLEX;imag;$R;13 is replaced by QCDR 
      COMPLEX;real;$R;12 is replaced by QCAR 

=========================================================================
macros 30212:

      COORDSYS;cartesian;2P;1 is replaced by pt 

=========================================================================
macros 30211:

      DBASE;coerce;L$;1 is replaced by u 

=========================================================================
macros 30210:

      DECIMAL;coerce;$Re;2 is replaced by x 

=========================================================================
macros 30209:

      DERHAM;terms is replaced by a 

=========================================================================
macros 30208:

      DFLOAT;**;$I$;35 is replaced by DFINTEGEREXPT 
      DFLOAT;*;3$;27 is replaced by DFMULTIPLY 
      DFLOAT;*;I2$;28 is replaced by DFINTEGERMULTIPLY 
      DFLOAT;+;3$;25 is replaced by DFADD 
      DFLOAT;-;2$;24 is replaced by DFUNARYMINUS 
      DFLOAT;-;3$;26 is replaced by DFSUBTRACT 
      DFLOAT;/;$I$;32 is replaced by DFINTEGERDIVIDE 
      DFLOAT;/;3$;65 is replaced by DFDIVIDE 
      DFLOAT;<;2$B;23 is replaced by DFLESSTHAN 
      DFLOAT;=;2$B;31 is replaced by DFEQL 
      DFLOAT;One;$;18 is replaced by FLOAT1MOST-POSITIVE-DOUBLE-FLOAT 
      DFLOAT;Zero;$;17 is replaced by FLOAT0MOST-POSITIVE-DOUBLE-FLOAT 
      DFLOAT;abs;2$;92 is replaced by FLOAT-SIGN1.0x 
      DFLOAT;acot;2$;51 is replaced by ACOT 
      DFLOAT;acsch;2$;62 is replaced by ACSCH 
      DFLOAT;asinh;2$;59 is replaced by DFASINH 
      DFLOAT;atan;2$;49 is replaced by DFATAN 
      DFLOAT;base;Pi;9 is replaced by FLOAT-RADIX0.0 
      DFLOAT;checkComplex is replaced by C-TO-R 
      DFLOAT;coerce;I$;37 is replaced by FLOATiMOST-POSITIVE-DOUBLE-FLOAT 
      DFLOAT;convert;2$;83 is replaced by x 
      DFLOAT;cos;2$;42 is replaced by DFCOS 
      DFLOAT;cosh;2$;54 is replaced by COSH 
      DFLOAT;cot;2$;44 is replaced by COT 
      DFLOAT;coth;2$;57 is replaced by COTH 
      DFLOAT;csc;2$;46 is replaced by CSC 
      DFLOAT;csch;2$;56 is replaced by CSCH 
      DFLOAT;differentiate;2$;70 is replaced by 0.0 
      DFLOAT;exp;2$;38 is replaced by DFEXP 
      DFLOAT;hash;$I;68 is replaced by SXHASH 
      DFLOAT;max;$;14 is replaced by MOST-POSITIVE-DOUBLE-FLOAT 
      DFLOAT;max;3$;29 is replaced by DFMAX 
      DFLOAT;min;$;15 is replaced by MOST-NEGATIVE-DOUBLE-FLOAT 
      DFLOAT;min;3$;30 is replaced by DFMIN 
      DFLOAT;negative?;$B;66 is replaced by DFMINUSP 
      DFLOAT;pi;$;20 is replaced by FLOATPIMOST-POSITIVE-DOUBLE-FLOAT 
      DFLOAT;precision;Pi;12 is replaced by FLOAT-DIGITS0.0 
      DFLOAT;sec;2$;45 is replaced by SEC 
      DFLOAT;sech;2$;58 is replaced by SECH 
      DFLOAT;sin;2$;41 is replaced by DFSIN 
      DFLOAT;sinh;2$;53 is replaced by SINH 
      DFLOAT;tan;2$;43 is replaced by DFTAN 
      DFLOAT;tanh;2$;55 is replaced by TANH 
      DFLOAT;wholePart;$I;81 is replaced by TRUNCATE 
      DFLOAT;zero?;$B;67 is replaced by ZEROP 

=========================================================================
macros 30207:

      DFMAT;empty;$;9 is replaced by MAKE-DOUBLE-MATRIX00 
      DFMAT;minColIndex;$I;2 is replaced by 0 
      DFMAT;minRowIndex;$I;1 is replaced by 0 
      DFMAT;ncols;$Nni;4 is replaced by DANCOLS 
      DFMAT;new;2NniDf$;11 is replaced by MAKE-DOUBLE-MATRIX1 
      DFMAT;nrows;$Nni;3 is replaced by DANROWS 
      DFMAT;qelt;$2IDf;7 is replaced by DAREF2 
      DFMAT;qnew;2I$;10 is replaced by MAKE-DOUBLE-MATRIX 
      DFMAT;qsetelt!;$2I2Df;8 is replaced by DSETAREF2 

=========================================================================
macros 30206:

      DFSFUN;Gamma;2C;1 is replaced by CGAMMA 
      DFSFUN;Gamma;2Df;2 is replaced by RGAMMA 
      DFSFUN;besselI;3C;20 is replaced by CBESSELI 
      DFSFUN;besselI;3Df;21 is replaced by RBESSELI 
      DFSFUN;besselJ;3C;18 is replaced by CBESSELJ 
      DFSFUN;besselJ;3Df;19 is replaced by RBESSELJ 
      DFSFUN;hypergeometric0F1;3C;22 is replaced by CHYPER0F1 
      DFSFUN;logGamma;2C;16 is replaced by CLNGAMMA 
      DFSFUN;logGamma;2Df;17 is replaced by RLNGAMMA 
      DFSFUN;polygamma;Nni2C;14 is replaced by CPSI 
      DFSFUN;polygamma;Nni2Df;15 is replaced by RPSI 

=========================================================================
macros 30205:

      DFVEC;#;$Nni;3 is replaced by DLEN 
      DFVEC;elt;$IDf;9 is replaced by DELT 
      DFVEC;empty;$;5 is replaced by MAKE-DOUBLE-VECTOR0 
      DFVEC;minIndex;$I;4 is replaced by 0 
      DFVEC;new;NniDf$;7 is replaced by MAKE-DOUBLE-VECTOR1 
      DFVEC;qelt;$IDf;1 is replaced by DELT 
      DFVEC;qelt;$IDf;8 is replaced by DELT 
      DFVEC;qnew;I$;6 is replaced by MAKE-DOUBLE-VECTOR 
      DFVEC;qsetelt!;$I2Df;10 is replaced by DSETELT 
      DFVEC;qsetelt!;$I2Df;2 is replaced by DSETELT 
      DFVEC;setelt;$I2Df;11 is replaced by DSETELT 

=========================================================================
macros 30204:

      DIRPROD;parts;$L;3 is replaced by VEC2LIST 

=========================================================================
macros 30203:

      DIRRING;per is replaced by f 
      DIRRING;rep is replaced by a 

=========================================================================
macros 30202:

      DIV;Zero;$;10 is replaced by  
      DIV;terms;$L;9 is replaced by a 

=========================================================================
macros 30201:

      DLIST;coerce;$L;5 is replaced by x 
      DLIST;coerce;L$;4 is replaced by x 

=========================================================================
macros 30200:

      DRAWCFUN;id is replaced by x 
      DRAWCFUN;xCoord is replaced by x 
      DRAWCFUN;zCoord is replaced by z 

=========================================================================
macros 30199:

      DROPT;length is replaced by LENGTH 
      DROPT;lengthI is replaced by LENGTH 
      DROPT;lengthR is replaced by LENGTH 

=========================================================================
macros 30198:

      DSTREE;children;$L;11 is replaced by QCDR 
      DSTREE;tree;S$;8 is replaced by CONSs 
      DSTREE;tree;SL$;7 is replaced by CONS 
      DSTREE;value;$S;10 is replaced by QCAR 

=========================================================================
macros 30197:

      EF;specialTrigs;FLU;45 is replaced by CONS1failed 

=========================================================================
macros 30196:

      EQ;=;2S$;2 is replaced by CONS 
      EQ;equation;2S$;3 is replaced by CONS 
      EQ;lhs;$S;4 is replaced by QCAR 
      EQ;rhs;$S;5 is replaced by QCDR 

=========================================================================
macros 30195:

      EXIT;=;2$B;2 is replaced by errorCannot use an Exit value. 
      EXIT;coerce;$Of;1 is replaced by errorCannot use an Exit value. 

=========================================================================
macros 30194:

      EXPEXPAN;exponent is replaced by QVELTterm1 

=========================================================================
macros 30193:

      EXPR;belong?;BoB;1 is replaced by QUOTET 
      EXPR;coerce;K$;156 is replaced by k 
      EXPR;coerce;Smp$;129 is replaced by p 
      EXPR;kernels;$L;157 is replaced by LIST 
      EXPR;numer;$Smp;128 is replaced by x 

=========================================================================
macros 30192:

      EXPRTUBE;project is replaced by x 

=========================================================================
macros 30191:

      EXPUPXS;exponent;$Ups;2 is replaced by f 

=========================================================================
macros 30190:

      FAXF-;algebraic?;SB;5 is replaced by QUOTET 
      FAXF-;transcendent?;SB;6 is replaced by QUOTE 

=========================================================================
macros 30189:

      FC;code;$U;24 is replaced by QCDR 
      FC;operation;$U;25 is replaced by QCAR 

=========================================================================
macros 30188:

      FCOMP;argument;$E;4 is replaced by QCDR 
      FCOMP;sin?;$B;3 is replaced by QCAR 

=========================================================================
macros 30187:

      FDIV;ideal;$Fi;20 is replaced by QCAR 

=========================================================================
macros 30186:

      FFCGP;=;2$B;36 is replaced by EQL 
      FFCGP;One;$;34 is replaced by 0 
      FFCGP;Zero;$;33 is replaced by -1 
      FFCGP;createPrimitiveElement;$;24 is replaced by 1 
      FFCGP;generator;$;23 is replaced by 1 
      FFCGP;primitiveElement;$;25 is replaced by 1 
      FFCGP;representationType;U;12 is replaced by CONS3cyclic 

=========================================================================
macros 30185:

      FFNBP;coordinates;$V;17 is replaced by x 
      FFNBP;representationType;U;48 is replaced by CONS2normal 
      FFNBP;represents;V$;2 is replaced by v 

=========================================================================
macros 30184:

      FFP;representationType;U;29 is replaced by CONS1polynomial 

=========================================================================
macros 30183:

      FIELD-;euclideanSize;SNni;7 is replaced by 0 
      FIELD-;prime?;SB;8 is replaced by QUOTE 

=========================================================================
macros 30182:

      FLOAT;One;$;49 is replaced by CONS10 
      FLOAT;Zero;$;48 is replaced by CONS00 
      FLOAT;base;Pi;50 is replaced by 2 
      FLOAT;convert;2$;116 is replaced by x 
      FLOAT;exponent;$I;52 is replaced by QCDR 
      FLOAT;mantissa;$I;51 is replaced by QCAR 

=========================================================================
macros 30181:

      FM1;leadingTerm;$R;3 is replaced by SPADfirst 
      FM1;listOfTerms;$L;2 is replaced by x 
      FM1;numberOfMonomials;$Nni;1 is replaced by LENGTH 

=========================================================================
macros 30180:

      FNAME;=;2$B;1 is replaced by EQUAL 
      FNAME;coerce;$S;3 is replaced by NAMESTRING 
      FNAME;coerce;S$;4 is replaced by PARSE-NAMESTRING 
      FNAME;directory;$S;6 is replaced by fnameDirectory 
      FNAME;exists?;$B;9 is replaced by fnameExists? 
      FNAME;extension;$S;8 is replaced by fnameType 
      FNAME;filename;3S$;5 is replaced by fnameMake 
      FNAME;name;$S;7 is replaced by fnameName 
      FNAME;new;3S$;12 is replaced by fnameNew 
      FNAME;readable?;$B;10 is replaced by fnameReadable? 
      FNAME;writable?;$B;11 is replaced by fnameWritable? 

=========================================================================
macros 30179:

      FORMULA;epilogue;$L;8 is replaced by QVELTf2 
      FORMULA;formula;$L;7 is replaced by QVELTf1 
      FORMULA;precondition is replaced by outputTran 
      FORMULA;prologue;$L;6 is replaced by QVELTf0 
      FORMULA;setEpilogue!;$2L;11 is replaced by QSETVELTf2l 
      FORMULA;setFormula!;$2L;10 is replaced by QSETVELTf1l 
      FORMULA;setPrologue!;$2L;9 is replaced by QSETVELTf0l 
      FORMULA;stringify is replaced by object2String 

=========================================================================
macros 30178:

      FORT;linkToFortran;SLLLSSe;5 is replaced by makeFortnameargsdeclsresreturnType 
      FORT;linkToFortran;SLLLSe;4 is replaced by makeFortnameargsdeclsres 

=========================================================================
macros 30177:

      FORTRAN;codeFrom is replaced by QCDR 
      FORTRAN;coerce;R$;12 is replaced by u 

=========================================================================
macros 30176:

      FPARFRAC;fracPart;$L;5 is replaced by QCDR 
      FPARFRAC;polyPart;$UP;4 is replaced by QCAR 

=========================================================================
macros 30175:

      FRIDEAL;denom;$R;3 is replaced by QCDR 
      FRIDEAL;mkIdeal is replaced by CONS 
      FRIDEAL;numer;$V;2 is replaced by QCAR 

=========================================================================
macros 30174:

      FRMOD;basis;$V;3 is replaced by m 
      FRMOD;module;V$;2 is replaced by v 

=========================================================================
macros 30173:

      FST;character?;$B;11 is replaced by QEQCARt3 
      FST;complex?;$B;12 is replaced by QEQCARt2 
      FST;double?;$B;8 is replaced by QEQCARt5 
      FST;doubleComplex?;$B;13 is replaced by QEQCARt6 
      FST;integer?;$B;10 is replaced by QEQCARt1 
      FST;logical?;$B;9 is replaced by QEQCARt4 
      FST;real?;$B;7 is replaced by QEQCARt0 

=========================================================================
macros 30172:

      FT;dimensionsOf;$L;3 is replaced by QVELTu1 
      FT;external?;$B;4 is replaced by QVELTu2 
      FT;scalarTypeOf;$U;2 is replaced by QVELTu0 

=========================================================================
macros 30171:

      FTEM;fortranCarriageReturn;V;3 is replaced by TERPRI$fortranOutputStream 
      FTEM;fortranLiteral;SV;2 is replaced by PRINTEXPs$fortranOutputStream 

=========================================================================
macros 30170:

      FUNCTION;=;2$B;3 is replaced by QUOTET 

=========================================================================
macros 30169:

      GBINTERN;virtualDegree;DpolNni;2 is replaced by 0 

=========================================================================
macros 30168:

      GDMP;zero?;$B;1 is replaced by NULL 

=========================================================================
macros 30167:

      GENEEZ;compBound;BPLNni;3 is replaced by errorattempt to use compBound without a well-understood valuation 

=========================================================================
macros 30166:

      GPOLSET;coerce;$L;12 is replaced by ps 
      GPOLSET;empty;$;3 is replaced by  
      GPOLSET;parts;$L;4 is replaced by ps 

=========================================================================
macros 30165:

      GRIMAGE;key;$I;10 is replaced by QVELTgraf0 
      GRIMAGE;pointLists;$L;11 is replaced by QVELTgraf3 

=========================================================================
macros 30164:

      GSERIES;coerce;Ups$;1 is replaced by upxs 
      GSERIES;puiseux is replaced by f 

=========================================================================
macros 30163:

      GTSET;per is replaced by l 
      GTSET;rep is replaced by s 
      GTSET;roughUnitIdeal?;$B;11 is replaced by QUOTE 

=========================================================================
macros 30162:

      HACKPI;convert;$F;2 is replaced by x 

=========================================================================
macros 30161:

      HASHTBL;#;$Nni;3 is replaced by HASH-TABLE-COUNT 
      HASHTBL;=;2$B;1 is replaced by EQ 
      HASHTBL;keys;$L;2 is replaced by HKEYS 
      HASHTBL;setelt;$Key2Entry;4 is replaced by HPUT 

=========================================================================
macros 30160:

      HEXADEC;coerce;$Re;2 is replaced by x 

=========================================================================
macros 30159:

      HTMLFORM;precondition is replaced by outputTran 
      HTMLFORM;stringify is replaced by mathObject2String 

=========================================================================
macros 30158:

      IARRAY1;#;$Nni;1 is replaced by QVSIZE 
      IARRAY1;empty;$;4 is replaced by MAKE-ARRAY0 
      IARRAY1;maxIndex;$I;13 is replaced by QVSIZE 
      IARRAY1;qelt;$IS;9 is replaced by ELT 
      IARRAY1;qsetelt!;$I2S;10 is replaced by SETELT 

=========================================================================
macros 30157:

      IBITS;#;$Nni;7 is replaced by BVEC-SIZE 
      IBITS;<;2$B;9 is replaced by BVEC-GREATERuv 
      IBITS;=;2$B;8 is replaced by BVEC-EQUAL 
      IBITS;Not;2$;15 is replaced by BVEC-NOT 
      IBITS;copy;2$;6 is replaced by BVEC-COPY 
      IBITS;empty;$;5 is replaced by BVEC-MAKE-FULL00 

=========================================================================
macros 30156:

      ICARD;<;2$B;1 is replaced by CGREATERPyx 
      ICARD;=;2$B;2 is replaced by EQUAL 
      ICARD;coerce;S$;5 is replaced by s 

=========================================================================
macros 30155:

      IDEAL;generators;$L;35 is replaced by QCAR 
      IDEAL;groebner?;$B;36 is replaced by QCDR 

=========================================================================
macros 30154:

      IDPAG;qsetrest! is replaced by RPLACD 

=========================================================================
macros 30153:

      IDPAM;Zero;$;1 is replaced by  
      IDPAM;qsetrest! is replaced by RPLACD 
      IDPAM;zero?;$B;2 is replaced by NULL 

=========================================================================
macros 30152:

      IDPO;reductum;2$;5 is replaced by CDR 

=========================================================================
macros 30151:

      IFARRAY;physicalLength;$Nni;1 is replaced by QVELTr0 

=========================================================================
macros 30150:

      IIARRAY2;empty;$;2 is replaced by MAKE-ARRAY0 
      IIARRAY2;nrows;$Nni;8 is replaced by QVSIZE 

=========================================================================
macros 30149:

      ILIST;#;$Nni;1 is replaced by LENGTH 
      ILIST;concat;S2$;2 is replaced by CONS 
      ILIST;construct;L$;14 is replaced by l 
      ILIST;elt;$firstS;5 is replaced by SPADfirstx 
      ILIST;elt;$rest$;9 is replaced by CDRx 
      ILIST;empty;$;6 is replaced by  
      ILIST;empty?;$B;7 is replaced by NULL 
      ILIST;eq?;2$B;3 is replaced by EQ 
      ILIST;first;$S;4 is replaced by SPADfirst 
      ILIST;parts;$L;15 is replaced by s 
      ILIST;rest;2$;8 is replaced by CDR 
      ILIST;reverse!;2$;16 is replaced by NREVERSE 
      ILIST;reverse;2$;17 is replaced by REVERSE 

=========================================================================
macros 30148:

      INFCLSPT;actualExtensionV;$K;20 is replaced by QVELTa8 
      INFCLSPT;chartV;$BLMET;17 is replaced by QVELTa4 
      INFCLSPT;curveV;$Dmp;14 is replaced by QVELTa1 
      INFCLSPT;excpDivV;$DIVISOR;18 is replaced by QVELTa6 
      INFCLSPT;localParamV;$L;19 is replaced by QVELTa7 
      INFCLSPT;localPointV;$Ap;15 is replaced by QVELTa2 
      INFCLSPT;multV;$Nni;16 is replaced by QVELTa3 
      INFCLSPT;pointV;$ProjPt;12 is replaced by QVELTa0 
      INFCLSPT;setchart!;$2BLMET;25 is replaced by QSETVELTa4n 
      INFCLSPT;setcurve!;$2Dmp;22 is replaced by QSETVELTa1n 
      INFCLSPT;setexcpDiv!;$2DIVISOR;27 is replaced by QSETVELTa6n 
      INFCLSPT;setlocalParam!;$2L;26 is replaced by QSETVELTa7n 
      INFCLSPT;setlocalPoint!;$2Ap;23 is replaced by QSETVELTa2n 
      INFCLSPT;setmult!;$2Nni;24 is replaced by QSETVELTa3n 
      INFCLSPT;setpoint!;$2ProjPt;21 is replaced by QSETVELTa0n 
      INFCLSPT;setsubmult!;$2Nni;11 is replaced by QSETVELTa5sm 
      INFCLSPT;setsymbName!;$2S;28 is replaced by QSETVELTa9n 
      INFCLSPT;subMultV;$Nni;10 is replaced by QVELTa5 
      INFCLSPT;symbNameV;$S;13 is replaced by QVELTa9 

=========================================================================
macros 30147:

      INFORM;convert;$Se;3 is replaced by x 
      INFORM;convert;Se$;4 is replaced by x 
      INFORM;parse;S$;13 is replaced by ncParseFromString 

=========================================================================
macros 30146:

      INS-;characteristic;Nni;1 is replaced by 0 
      INS-;copy;2S;5 is replaced by x 
      INS-;rational?;SB;8 is replaced by QUOTET 

=========================================================================
macros 30145:

      INT;**;$Nni$;41 is replaced by EXPT 
      INT;*;3$;39 is replaced by * 
      INT;*;3$;40 is replaced by * 
      INT;+;3$;37 is replaced by + 
      INT;-;2$;36 is replaced by - 
      INT;-;3$;38 is replaced by - 
      INT;<;2$B;35 is replaced by < 
      INT;=;2$B;34 is replaced by EQL 
      INT;One;$;9 is replaced by 1 
      INT;Zero;$;8 is replaced by 0 
      INT;abs;2$;31 is replaced by ABS 
      INT;base;$;10 is replaced by 2 
      INT;coerce;2$;17 is replaced by m 
      INT;convert;$Df;24 is replaced by FLOATxMOST-POSITIVE-DOUBLE-FLOAT 
      INT;convert;$S;26 is replaced by STRINGIMAGE 
      INT;convert;2$;18 is replaced by x 
      INT;copy;2$;11 is replaced by x 
      INT;dec;2$;13 is replaced by -x1 
      INT;divide;2$R;45 is replaced by DIVIDE2 
      INT;gcd;3$;51 is replaced by GCD 
      INT;hash;2$;14 is replaced by SXHASH 
      INT;inc;2$;12 is replaced by +x1 
      INT;length;2$;19 is replaced by INTEGER-LENGTH 
      INT;max;3$;43 is replaced by MAX 
      INT;min;3$;44 is replaced by MIN 
      INT;negative?;$B;15 is replaced by MINUSP 
      INT;odd?;$B;42 is replaced by ODDP 
      INT;one?;$B;7 is replaced by EQLx1 
      INT;quo;3$;46 is replaced by QUOTIENT2 
      INT;random;$;32 is replaced by random 
      INT;random;2$;33 is replaced by RANDOM 
      INT;reducedSystem;2M;29 is replaced by m 
      INT;rem;3$;47 is replaced by REMAINDER2 
      INT;shift;3$;48 is replaced by ASH 
      INT;unitCanonical;2$;53 is replaced by ABS 
      INT;zero?;$B;6 is replaced by ZEROP 

=========================================================================
macros 30144:

      INTBIT;bitLength;2I;1 is replaced by INTEGER-LENGTH 

=========================================================================
macros 30142:

      IPADIC;characteristic;Nni;1 is replaced by 0 
      IPADIC;padic is replaced by x 
      IPADIC;showAll? is replaced by QUOTET 
      IPADIC;stream is replaced by x 

=========================================================================
macros 30141:

      IPF;charthRoot;2$;26 is replaced by x 
      IPF;retractIfCan;$U;21 is replaced by CONS0x 

=========================================================================
macros 30140:

      IR;logpart;$L;5 is replaced by QVELTu1 
      IR;notelem;$L;6 is replaced by QVELTu2 
      IR;ratpart;$F;4 is replaced by QVELTu0 

=========================================================================
macros 30139:

      ISTRING;#;$Nni;4 is replaced by QCSIZE 
      ISTRING;<;2$B;6 is replaced by CGREATERPts 
      ISTRING;=;2$B;5 is replaced by EQUAL 
      ISTRING;concat;3$;7 is replaced by STRCONC 
      ISTRING;copy;2$;8 is replaced by COPY-SEQ 
      ISTRING;empty;$;2 is replaced by MAKE-FULL-CVEC0 
      ISTRING;new;NniC$;1 is replaced by MAKE-FULL-CVEC 

=========================================================================
macros 30138:

      ISUPS;factorials? is replaced by QUOTE 
      ISUPS;getCoef is replaced by QCDR 
      ISUPS;getExpon is replaced by QCAR 
      ISUPS;getRef;$R;5 is replaced by QCAR 
      ISUPS;getStream;$S;6 is replaced by QCDR 
      ISUPS;makeSeries;RS$;4 is replaced by CONS 
      ISUPS;makeTerm is replaced by CONS 
      ISUPS;showAll? is replaced by QUOTET 

=========================================================================
macros 30137:

      ITAYLOR;series;S$;2 is replaced by st 
      ITAYLOR;stream is replaced by x 

=========================================================================
macros 30136:

      JORDAN;**;$Pi$;4 is replaced by a 
      JORDAN;coerce;$A;2 is replaced by a 
      JORDAN;coerce;A$;3 is replaced by a 

=========================================================================
macros 30135:

      KAFILE;iomode;$S;11 is replaced by QVELTf2 
      KAFILE;name;$Fn;10 is replaced by QVELTf0 

=========================================================================
macros 30134:

      KERNEL;argument;$L;6 is replaced by QVELTk1 
      KERNEL;height;$Nni;4 is replaced by QVELTk2 
      KERNEL;operator;$Bo;5 is replaced by QVELTk0 
      KERNEL;position;$Nni;7 is replaced by QVELTk3 
      KERNEL;setPosition;$NniV;8 is replaced by QSETVELTk3n 

=========================================================================
macros 30133:

      LAUPOL;gpol is replaced by CONS 
      LAUPOL;order;$I;5 is replaced by QCDR 
      LAUPOL;poly is replaced by QCAR 

=========================================================================
macros 30132:

      LEXP;coerce;$Xpbwp;11 is replaced by p 

=========================================================================
macros 30131:

      LIE;coerce;$A;2 is replaced by a 
      LIE;coerce;A$;3 is replaced by a 

=========================================================================
macros 30130:

      LIST;append;3$;4 is replaced by APPEND 
      LIST;cons;S2$;3 is replaced by CONS 
      LIST;nil;$;1 is replaced by  
      LIST;null;$B;2 is replaced by NULL 

=========================================================================
macros 30129:

      LMOPS;listOfMonoms;$L;8 is replaced by l 
      LMOPS;makeMulti;L$;6 is replaced by l 
      LMOPS;makeUnit;$;1 is replaced by  
      LMOPS;reverse!;2$;12 is replaced by NREVERSE 
      LMOPS;reverse;2$;11 is replaced by REVERSE 

=========================================================================
macros 30128:

      LO;denom;$S;6 is replaced by QCDR 
      LO;numer;$M;5 is replaced by QCAR 

=========================================================================
macros 30127:

      M3D;coerce;$Pa;4 is replaced by mat 
      M3D;coerce;Pa$;3 is replaced by matrixRep 

=========================================================================
macros 30126:

      MAGMA;coerce;VarSet$;8 is replaced by CONS0l 
      MAGMA;retractable?;$B;5 is replaced by QEQCARx0 

=========================================================================
macros 30125:

      MAPHACK2;arg1;ACA;1 is replaced by a 
      MAPHACK2;arg2;A2C;2 is replaced by c 

=========================================================================
macros 30124:

      MAPPKG1;id;2A;5 is replaced by a 

=========================================================================
macros 30123:

      MATRIX;minColIndex;$I;2 is replaced by 1 
      MATRIX;minRowIndex;$I;1 is replaced by 1 

=========================================================================
macros 30122:

      MATSTOR;rep is replaced by m 

=========================================================================
macros 30121:

      MFLOAT;Zero;$;28 is replaced by CONS00 
      MFLOAT;mantissa;$I;4 is replaced by QCAR 

=========================================================================
macros 30120:

      MINT;retract;$I;5 is replaced by u 
      MINT;retractIfCan;$U;6 is replaced by CONS0u 

=========================================================================
macros 30119:

      MKCHSET;coerce;$S;3 is replaced by QCAR 
      MKCHSET;position;$Nni;1 is replaced by QCDR 

=========================================================================
macros 30118:

      MKRECORD;makeRecord;ST$R;1 is replaced by CONS 

=========================================================================
macros 30117:

      MKUCFUNC;func is replaced by FUNCALLnamex 

=========================================================================
macros 30116:

      MMLFORM;precondition is replaced by outputTran 
      MMLFORM;stringify is replaced by mathObject2String 

=========================================================================
macros 30115:

      MODMON;lift;$Rep;15 is replaced by x 

=========================================================================
macros 30114:

      MODMONOM;coerce;$R;4 is replaced by x 
      MODMONOM;coerce;R$;5 is replaced by x 
      MODMONOM;construct;ISE$;6 is replaced by CONS 
      MODMONOM;exponent;$E;2 is replaced by QCDR 
      MODMONOM;index;$IS;3 is replaced by QCAR 

=========================================================================
macros 30113:

      MODRING;coerce;$R;2 is replaced by QCAR 
      MODRING;modulus;$Mod;1 is replaced by QCDR 

=========================================================================
macros 30112:

      MOEBIUS;a is replaced by QVELTt0 
      MOEBIUS;b is replaced by QVELTt1 
      MOEBIUS;c is replaced by QVELTt2 
      MOEBIUS;d is replaced by QVELTt3 
      MOEBIUS;moebius;4F$;1 is replaced by VECTOR 

=========================================================================
macros 30111:

      MRING;Zero;$;7 is replaced by  
      MRING;coerce;L$;1 is replaced by x 
      MRING;numberOfMonomials;$Nni;21 is replaced by LENGTH 

=========================================================================
macros 30110:

      NAGSP;fortranCompilerName;S;4 is replaced by STRINGIMAGE$fortranCompilerName 
      NAGSP;fortranLinkerArgs;S;5 is replaced by STRINGIMAGE$fortranLibraries 

=========================================================================
macros 30109:

      NIPROB;coerce;R$;1 is replaced by CONS0s 
      NIPROB;coerce;R$;2 is replaced by CONS1s 
      NIPROB;coerce;U$;3 is replaced by s 

=========================================================================
macros 30108:

      NNI;shift;$I$;2 is replaced by ASH 
      NNI;sup;3$;1 is replaced by MAX 

=========================================================================
macros 30107:

      NONE1;coerce;SN;1 is replaced by s 

=========================================================================
macros 30106:

      NONE;=;2$B;2 is replaced by EQ 
      NONE;coerce;$Of;1 is replaced by NONE 

=========================================================================
macros 30105:

      NSDPS;coerce;$S;5 is replaced by s 
      NSDPS;coerce;S$;6 is replaced by s 

=========================================================================
macros 30104:

      NSMP;coerce;$Smp;2 is replaced by p 
      NSMP;coerce;Smp$;3 is replaced by p 
      NSMP;retractIfCan;$U;4 is replaced by CONS0p 

=========================================================================
macros 30103:

      NSUP;coerce;$Sup;3 is replaced by p 
      NSUP;coerce;Sup$;4 is replaced by p 
      NSUP;per is replaced by l 
      NSUP;rep is replaced by s 
      NSUP;retractIfCan;$U;5 is replaced by CONS0p 

=========================================================================
macros 30102:

      NUMFMT;FormatArabic;PiS;7 is replaced by STRINGIMAGE 
      NUMFMT;ScanArabic;SPi;8 is replaced by PARSE-INTEGER 

=========================================================================
macros 30101:

      OCT;octon;2Q$;12 is replaced by CONS 

=========================================================================
macros 30100:

      ODR;coerce;$R;2 is replaced by p 
      ODR;coerce;R$;1 is replaced by u 

=========================================================================
macros 30099:

      ODVAR;makeVariable;SNni$;1 is replaced by CONS 
      ODVAR;order;$Nni;3 is replaced by QCDR 
      ODVAR;variable;$S;2 is replaced by QCAR 

=========================================================================
macros 30098:

      OMCONN;OMbindTCP;$SiB;6 is replaced by OM-BINDTCP 
      OMCONN;OMcloseConn;$V;2 is replaced by OM-CLOSECONN 
      OMCONN;OMconnInDevice;$Omd;3 is replaced by OM-GETCONNINDEV 
      OMCONN;OMconnOutDevice;$Omd;4 is replaced by OM-GETCONNOUTDEV 
      OMCONN;OMconnectTCP;$SSiB;5 is replaced by OM-CONNECTTCP 
      OMCONN;OMmakeConn;Si$;1 is replaced by OM-MAKECONN 

=========================================================================
macros 30097:

      OMDEV;OMclose;$V;3 is replaced by OM-CLOSEDEV 
      OMDEV;OMgetApp;$V;24 is replaced by OM-GETAPP 
      OMDEV;OMgetAtp;$V;25 is replaced by OM-GETATP 
      OMDEV;OMgetAttr;$V;26 is replaced by OM-GETATTR 
      OMDEV;OMgetBVar;$V;28 is replaced by OM-GETBVAR 
      OMDEV;OMgetBind;$V;27 is replaced by OM-GETBIND 
      OMDEV;OMgetEndApp;$V;31 is replaced by OM-GETENDAPP 
      OMDEV;OMgetEndAtp;$V;32 is replaced by OM-GETENDATP 
      OMDEV;OMgetEndAttr;$V;33 is replaced by OM-GETENDATTR 
      OMDEV;OMgetEndBVar;$V;35 is replaced by OM-GETENDBVAR 
      OMDEV;OMgetEndBind;$V;34 is replaced by OM-GETENDBIND 
      OMDEV;OMgetEndError;$V;36 is replaced by OM-GETENDERROR 
      OMDEV;OMgetEndObject;$V;37 is replaced by OM-GETENDOBJECT 
      OMDEV;OMgetError;$V;29 is replaced by OM-GETERROR 
      OMDEV;OMgetFloat;$Df;39 is replaced by OM-GETFLOAT 
      OMDEV;OMgetInteger;$I;38 is replaced by OM-GETINT 
      OMDEV;OMgetObject;$V;30 is replaced by OM-GETOBJECT 
      OMDEV;OMgetString;$S;41 is replaced by OM-GETSTRING 
      OMDEV;OMgetSymbol;$R;42 is replaced by OM-GETSYMBOL 
      OMDEV;OMgetType;$S;43 is replaced by OM-GETTYPE 
      OMDEV;OMgetVariable;$S;40 is replaced by OM-GETVAR 
      OMDEV;OMopenFile;2SOme$;1 is replaced by OM-OPENFILEDEV 
      OMDEV;OMopenString;SOme$;2 is replaced by OM-OPENSTRINGDEV 
      OMDEV;OMputApp;$V;5 is replaced by OM-PUTAPP 
      OMDEV;OMputAtp;$V;6 is replaced by OM-PUTATP 
      OMDEV;OMputAttr;$V;7 is replaced by OM-PUTATTR 
      OMDEV;OMputBVar;$V;9 is replaced by OM-PUTBVAR 
      OMDEV;OMputBind;$V;8 is replaced by OM-PUTBIND 
      OMDEV;OMputEndApp;$V;12 is replaced by OM-PUTENDAPP 
      OMDEV;OMputEndAtp;$V;13 is replaced by OM-PUTENDATP 
      OMDEV;OMputEndAttr;$V;14 is replaced by OM-PUTENDATTR 
      OMDEV;OMputEndBVar;$V;16 is replaced by OM-PUTENDBVAR 
      OMDEV;OMputEndBind;$V;15 is replaced by OM-PUTENDBIND 
      OMDEV;OMputEndError;$V;17 is replaced by OM-PUTENDERROR 
      OMDEV;OMputEndObject;$V;18 is replaced by OM-PUTENDOBJECT 
      OMDEV;OMputError;$V;10 is replaced by OM-PUTERROR 
      OMDEV;OMputFloat;$DfV;20 is replaced by OM-PUTFLOAT 
      OMDEV;OMputInteger;$IV;19 is replaced by OM-PUTINT 
      OMDEV;OMputObject;$V;11 is replaced by OM-PUTOBJECT 
      OMDEV;OMputString;$SV;22 is replaced by OM-PUTSTRING 
      OMDEV;OMputSymbol;$2SV;23 is replaced by OM-PUTSYMBOL 
      OMDEV;OMputVariable;$SV;21 is replaced by OM-PUTVAR 
      OMDEV;OMsetEncoding;$OmeV;4 is replaced by OM-SETDEVENCODING 

=========================================================================
macros 30096:

      OMENC;OMencodingBinary;$;4 is replaced by 1 
      OMENC;OMencodingUnknown;$;3 is replaced by 0 

=========================================================================
macros 30095:

      OMERR;errorInfo;$L;4 is replaced by QCDR 
      OMERR;errorKind;$Omek;3 is replaced by QCAR 
      OMERR;omError;OmekL$;2 is replaced by CONS 

=========================================================================
macros 30094:

      OMERRK;OMParseError?;$B;1 is replaced by QEQCARu0 
      OMERRK;OMReadError?;$B;4 is replaced by QEQCARu3 
      OMERRK;OMUnknownCD?;$B;2 is replaced by QEQCARu1 
      OMERRK;OMUnknownSymbol?;$B;3 is replaced by QEQCARu2 

=========================================================================
macros 30093:

      OMLO;op;P$;1 is replaced by a 
      OMLO;po;$P;2 is replaced by x 

=========================================================================
macros 30092:

      OMPKG;OMlistCDs;L;5 is replaced by OM-LISTCDS 
      OMPKG;OMlistSymbols;SL;6 is replaced by OM-LISTSYMBOLS 

=========================================================================
macros 30091:

      ONECOMP;coerce;R$;1 is replaced by CONS0r 
      ONECOMP;finite?;$B;3 is replaced by QEQCARx0 
      ONECOMP;infinite?;$B;4 is replaced by QEQCARx1 
      ONECOMP;infinity;$;5 is replaced by CONS1infinity 

=========================================================================
macros 30090:

      ORDCOMP;coerce;R$;1 is replaced by CONS0r 
      ORDCOMP;finite?;$B;3 is replaced by QEQCARx0 
      ORDCOMP;infinite?;$B;4 is replaced by QEQCARx1 

=========================================================================
macros 30089:

      OSI;<;2$B;2 is replaced by < 
      OSI;=;2$B;1 is replaced by EQL 
      OSI;coerce;I$;3 is replaced by i 
      OSI;value;$I;4 is replaced by x 

=========================================================================
macros 30088:

      OUTFORM;=;2$B;4 is replaced by EQUAL 
      OUTFORM;coerce;2$;6 is replaced by a 
      OUTFORM;eform is replaced by e 
      OUTFORM;elt;$L$;73 is replaced by CONS 
      OUTFORM;height;$I;15 is replaced by height 
      OUTFORM;height;I;18 is replaced by 20 
      OUTFORM;iform is replaced by n 
      OUTFORM;outputForm;Df$;9 is replaced by f 
      OUTFORM;outputForm;I$;7 is replaced by n 
      OUTFORM;outputForm;S$;8 is replaced by e 
      OUTFORM;print;$V;1 is replaced by mathprint 
      OUTFORM;sform is replaced by s 
      OUTFORM;subHeight;$I;16 is replaced by subspan 
      OUTFORM;superHeight;$I;17 is replaced by superspan 
      OUTFORM;width;$I;14 is replaced by outformWidth 
      OUTFORM;width;I;19 is replaced by 66 

=========================================================================
macros 30087:

      OVAR;<;2$B;10 is replaced by <s2s1 
      OVAR;=;2$B;11 is replaced by EQL 
      OVAR;index;Pi$;6 is replaced by i 
      OVAR;lookup;$Pi;7 is replaced by j 

=========================================================================
macros 30086:

      PACEXT;coerce;Pacorn$;34 is replaced by CONS1a 
      PACEXT;ground?;$B;12 is replaced by QEQCARa1 

=========================================================================
macros 30085:

      PACOFF;coerce;K$;35 is replaced by CONS1a 
      PACOFF;ground?;$B;9 is replaced by QEQCARa1 

=========================================================================
macros 30084:

      PACRAT;coerce;F$;31 is replaced by CONS1a 

=========================================================================
macros 30083:

      PADICRC;getExpon is replaced by QCAR 
      PADICRC;getZp is replaced by QCDR 
      PADICRC;makeQp is replaced by CONS 
      PADICRC;showAll? is replaced by QUOTET 

=========================================================================
macros 30082:

      PATLRES;atoms;$Pmr;2 is replaced by QCAR 
      PATLRES;lists;$Pmr;3 is replaced by QCDR 

=========================================================================
macros 30081:

      PATRES;failed;$;2 is replaced by CONS1failed 
      PATRES;failed?;$B;3 is replaced by QEQCARx1 

=========================================================================
macros 30080:

      PATTERN;constant?;$B;6 is replaced by QVELTp0 
      PATTERN;depth;$Nni;7 is replaced by QVELTp2 

=========================================================================
macros 30079:

      PBWLB;One;$;1 is replaced by  
      PBWLB;coerce;Lw$;7 is replaced by LIST 
      PBWLB;first;$Lw;4 is replaced by SPADfirst 
      PBWLB;listOfTerms;$L;8 is replaced by x 
      PBWLB;rest;2$;5 is replaced by CDR 

=========================================================================
macros 30078:

      PENDTREE;coerce;$T;1 is replaced by t 

=========================================================================
macros 30077:

      PERMGRP;coerce;$L;19 is replaced by QCAR 
      PERMGRP;generators;$L;20 is replaced by QCAR 

=========================================================================
macros 30076:

      PFR;coerce;R$;11 is replaced by CONSr 
      PFR;wholePart;$R;21 is replaced by QCAR 

=========================================================================
macros 30075:

      PLCS;degree;$Pi;24 is replaced by QVELTpl2 
      PLCS;leaf?;$B;14 is replaced by QVELTpl3 
      PLCS;localParam;$L;23 is replaced by QVELTpt1 

=========================================================================
macros 30074:

      PLOT;parametric?;$B;17 is replaced by QVELTp0 

=========================================================================
macros 30073:

      PR;numberOfMonomials;$Nni;3 is replaced by LENGTH 

=========================================================================
macros 30072:

      PRIMARR;#;$Nni;1 is replaced by QVSIZE 
      PRIMARR;elt;$IS;6 is replaced by ELT 
      PRIMARR;empty;$;3 is replaced by MAKE-ARRAY0 
      PRIMARR;minIndex;$I;2 is replaced by 0 
      PRIMARR;qelt;$IS;5 is replaced by ELT 
      PRIMARR;qsetelt!;$I2S;7 is replaced by SETELT 
      PRIMARR;setelt;$I2S;8 is replaced by SETELT 

=========================================================================
macros 30071:

      PRODUCT;makeprod;AB$;3 is replaced by CONS 
      PRODUCT;selectfirst;$A;4 is replaced by QCAR 
      PRODUCT;selectsecond;$B;5 is replaced by QCDR 

=========================================================================
macros 30070:

      PROJSP;coerce;$L;4 is replaced by pt 
      PROJSP;list;$L;6 is replaced by ptt 
      PROJSP;pointValue;$L;7 is replaced by ptt 
      PROJSP;projectivePoint;L$;5 is replaced by pt 

=========================================================================
macros 30069:

      PRTITION;=;2$B;6 is replaced by EQUAL 
      PRTITION;Zero;$;1 is replaced by  
      PRTITION;coerce;$L;2 is replaced by s 

=========================================================================
macros 30068:

      QALGSET;definingEquations;$L;10 is replaced by QVELTx1 
      QALGSET;definingInequation;$Dpoly;11 is replaced by QVELTx2 
      QALGSET;status;$U;8 is replaced by QVELTx0 

=========================================================================
macros 30067:

      QEQUAT;equation;SS$;2 is replaced by CONS 
      QEQUAT;value;$S;4 is replaced by QCDR 
      QEQUAT;variable;$S;3 is replaced by QCAR 

=========================================================================
macros 30066:

      QFORM;matrix;$Sm;2 is replaced by q 

=========================================================================
macros 30065:

      QUAT;imagI;$R;4 is replaced by QVELTx1 
      QUAT;imagJ;$R;5 is replaced by QVELTx2 
      QUAT;imagK;$R;6 is replaced by QVELTx3 
      QUAT;quatern;4R$;7 is replaced by VECTOR 
      QUAT;real;$R;3 is replaced by QVELTx0 

=========================================================================
macros 30064:

      RADIX;Zero;$;3 is replaced by VECTOR1 
      RADIX;characteristic;Nni;1 is replaced by 0 
      RADIX;cycleRagits;$L;28 is replaced by QVELTa3 
      RADIX;prefixRagits;$L;27 is replaced by QVELTa2 
      RADIX;wholeRagits;$L;25 is replaced by QVELTa1 

=========================================================================
macros 30063:

      RCFIELD-;characteristic;Nni;4 is replaced by 0 

=========================================================================
macros 30062:

      RECLOS;coerce;TheField$;35 is replaced by CONS0rn 

=========================================================================
macros 30061:

      REF;=;2$B;1 is replaced by EQ 
      REF;deref;$S;5 is replaced by QCAR 
      REF;elt;$S;3 is replaced by QCAR 
      REF;ref;S$;2 is replaced by LIST 

=========================================================================
macros 30060:

      REGSET;per is replaced by l 
      REGSET;roughUnitIdeal?;$B;11 is replaced by QUOTE 

=========================================================================
macros 30059:

      RESLATC;coerce;ES;2 is replaced by errorBug: Should not be able to obtain value of type Exit 

=========================================================================
macros 30058:

      RESRING;lift;$FPol;5 is replaced by x 

=========================================================================
macros 30057:

      RNS-;characteristic;Nni;1 is replaced by 0 

=========================================================================
macros 30056:

      ROIRC;left;$TheField;31 is replaced by QVELTrootChar0 
      ROIRC;right;$TheField;32 is replaced by QVELTrootChar1 

=========================================================================
macros 30055:

      RULE;lhs;$F;2 is replaced by QVELTx1 
      RULE;mkRule is replaced by VECTOR 
      RULE;pattern;$P;1 is replaced by QVELTx0 
      RULE;quotedOperators;$L;4 is replaced by QVELTx3 
      RULE;rhs;$F;3 is replaced by QVELTx2 

=========================================================================
macros 30054:

      RULECOLD;=;2$B;3 is replaced by QUOTET 

=========================================================================
macros 30053:

      SAE;lift;$UP;10 is replaced by x 

=========================================================================
macros 30052:

      SAOS;<;2$B;2 is replaced by QUOTE 
      SAOS;=;2$B;4 is replaced by QUOTET 
      SAOS;create;$;1 is replaced by ? 
      SAOS;max;3$;6 is replaced by a 
      SAOS;min;3$;5 is replaced by a 

=========================================================================
macros 30051:

      SDVAR;makeVariable;SNni$;1 is replaced by CONS 
      SDVAR;order;$Nni;3 is replaced by QCDR 
      SDVAR;variable;$S;2 is replaced by QCAR 

=========================================================================
macros 30050:

      SEG;SEGMENT;2S$;1 is replaced by VECTORab1 
      SEG;convert;S$;11 is replaced by VECTORaa1 
      SEG;hi;$S;4 is replaced by QVELTs1 
      SEG;high;$S;5 is replaced by QVELTs1 
      SEG;incr;$I;6 is replaced by QVELTs2 
      SEG;lo;$S;2 is replaced by QVELTs0 
      SEG;low;$S;3 is replaced by QVELTs0 
      SEG;segment;2S$;7 is replaced by VECTORab1 

=========================================================================
macros 30049:

      SEGBIND;equation;SS$;1 is replaced by CONS 
      SEGBIND;segment;$S;3 is replaced by QCDR 
      SEGBIND;variable;$S;2 is replaced by QCAR 

=========================================================================
macros 30048:

      SETCAT-;hash;SSi;1 is replaced by SXHASH 
      SETCAT-;latex;SS;2 is replaced by \mbox{\bf Unimplemented} 

=========================================================================
macros 30046:

      SFORT;bodyOf is replaced by QVELTu2 
      SFORT;nameOf is replaced by QVELTu0 

=========================================================================
macros 30045:

      SINT;*;3$;30 is replaced by QSTIMES 
      SINT;+;3$;28 is replaced by QSPLUS 
      SINT;-;2$;27 is replaced by QSMINUS 
      SINT;-;3$;29 is replaced by QSDIFFERENCE 
      SINT;/\;3$;18 is replaced by LOGAND 
      SINT;<;2$B;24 is replaced by QSLESSP 
      SINT;=;2$B;15 is replaced by EQL 
      SINT;And;3$;21 is replaced by LOGAND 
      SINT;Not;2$;20 is replaced by LOGNOT 
      SINT;One;$;11 is replaced by 1 
      SINT;Or;3$;22 is replaced by LOGIOR 
      SINT;Zero;$;10 is replaced by 0 
      SINT;\/;3$;19 is replaced by LOGIOR 
      SINT;abs;2$;36 is replaced by QSABSVAL 
      SINT;addmod;4$;46 is replaced by QSADDMOD 
      SINT;base;$;12 is replaced by 2 
      SINT;convert;$I;8 is replaced by x 
      SINT;dec;2$;26 is replaced by QSSUB1 
      SINT;gcd;3$;35 is replaced by GCD 
      SINT;hash;2$;42 is replaced by SXHASH 
      SINT;inc;2$;25 is replaced by QSADD1 
      SINT;length;2$;43 is replaced by INTEGER-LENGTH 
      SINT;max;$;13 is replaced by MOST-POSITIVE-FIXNUM 
      SINT;max;3$;40 is replaced by QSMAX 
      SINT;min;$;14 is replaced by MOST-NEGATIVE-FIXNUM 
      SINT;min;3$;41 is replaced by QSMIN 
      SINT;mulmod;4$;45 is replaced by QSMULTMOD 
      SINT;negative?;$B;48 is replaced by QSMINUSP 
      SINT;not;2$;17 is replaced by LOGNOT 
      SINT;odd?;$B;37 is replaced by QSODDP 
      SINT;one?;$B;39 is replaced by EQLx1 
      SINT;quo;3$;32 is replaced by QSQUOTIENT 
      SINT;random;2$;53 is replaced by RANDOM 
      SINT;reducedSystem;MM;6 is replaced by m 
      SINT;reducedSystem;MVR;49 is replaced by CONS 
      SINT;rem;3$;33 is replaced by QSREMAINDER 
      SINT;shift;3$;44 is replaced by QSLEFTSHIFT 
      SINT;submod;4$;47 is replaced by QSDIFMOD 
      SINT;xor;3$;23 is replaced by LOGXOR 
      SINT;zero?;$B;38 is replaced by QSZEROP 
      SINT;~;2$;16 is replaced by LOGNOT 

=========================================================================
macros 30044:

      SMP;coerce;R$;21 is replaced by CONS0c 

=========================================================================
macros 30043:

      SMTS;showAll? is replaced by QUOTET 
      SMTS;stream is replaced by x 
      SMTS;stream is replaced by x 

=========================================================================
macros 30042:

      SPACE3;subspace;$Ss;49 is replaced by QVELTs0 

=========================================================================
macros 30041:

      SPLNODE;per is replaced by r 
      SPLNODE;rep is replaced by n 

=========================================================================
macros 30040:

      SPLTREE;eq?;2$B;20 is replaced by errorin eq? from SPLTREE : la vache qui rit est-elle folle? 
      SPLTREE;per is replaced by r 
      SPLTREE;rep is replaced by n 

=========================================================================
macros 30039:

      SREGSET;per is replaced by l 
      SREGSET;rep is replaced by s 
      SREGSET;roughUnitIdeal?;$B;11 is replaced by QUOTE 

=========================================================================
macros 30038:

      STREAM;concat;S2$;38 is replaced by CONS 
      STREAM;frst;$S;3 is replaced by QCAR 
      STREAM;rst;2$;4 is replaced by QCDR 

=========================================================================
macros 30037:

      STRING;string;I$;1 is replaced by STRINGIMAGE 

=========================================================================
macros 30036:

      STTFNC;acos;2S;12 is replaced by erroracos: acos undefined on this coefficient domain 
      STTFNC;acosh;2S;24 is replaced by erroracosh: acosh undefined on this coefficient domain 
      STTFNC;acot;2S;13 is replaced by erroracot: acot undefined on this coefficient domain 
      STTFNC;acoth;2S;25 is replaced by erroracoth: acoth undefined on this coefficient domain 
      STTFNC;acsc;2S;15 is replaced by erroracsc: acsc undefined on this coefficient domain 
      STTFNC;acsch;2S;27 is replaced by erroracsch: acsch undefined on this coefficient domain 
      STTFNC;asec;2S;14 is replaced by errorasec: asec undefined on this coefficient domain 
      STTFNC;asech;2S;26 is replaced by errorasech: asech undefined on this coefficient domain 

=========================================================================
macros 30035:

      SUBSPACE;children;$L;8 is replaced by QVELTspace3 
      SUBSPACE;extractIndex;$Nni;27 is replaced by QVELTspace1 
      SUBSPACE;extractProperty;$Sscp;29 is replaced by QVELTspace2 
      SUBSPACE;level;$Nni;32 is replaced by QVELTspace5 
      SUBSPACE;numberOfChildren;$Nni;9 is replaced by QVELTspace9 
      SUBSPACE;pointData;$L;31 is replaced by QVELTspace6 

=========================================================================
macros 30034:

      SUCH;construct;S1S2$;1 is replaced by CONS 

=========================================================================
macros 30033:

      SULS;coerce;Suts$;5 is replaced by uts 
      SULS;removeZeroes;2$;10 is replaced by uls 
      SULS;removeZeroes;I2$;11 is replaced by uls 

=========================================================================
macros 30032:

      SUP;multivariate;$Saos$;15 is replaced by sup 
      SUP;univariate;2$;14 is replaced by p 
      SUP;zero?;$B;5 is replaced by NULL 

=========================================================================
macros 30031:

      SUTS;acos;2$;74 is replaced by erroracos: acos undefined on this coefficient domain 
      SUTS;acosh;2$;86 is replaced by erroracosh: acosh undefined on this coefficient domain 
      SUTS;acot;2$;75 is replaced by erroracot: acot undefined on this coefficient domain 
      SUTS;acoth;2$;87 is replaced by erroracoth: acoth undefined on this coefficient domain 
      SUTS;acsc;2$;77 is replaced by erroracsc: acsc undefined on this coefficient domain 
      SUTS;acsch;2$;89 is replaced by erroracsch: acsch undefined on this coefficient domain 
      SUTS;asec;2$;76 is replaced by errorasec: asec undefined on this coefficient domain 
      SUTS;asech;2$;88 is replaced by errorasech: asech undefined on this coefficient domain 
      SUTS;getCoef is replaced by QCDR 
      SUTS;getExpon is replaced by QCAR 
      SUTS;makeTerm is replaced by CONS 
      SUTS;pole?;$B;30 is replaced by QUOTE 

=========================================================================
macros 30030:

      SYMBOL;<;2$B;10 is replaced by GGREATERPyx 
      SYMBOL;=;2$B;9 is replaced by EQUAL 
      SYMBOL;convert;2$;7 is replaced by s 

=========================================================================
macros 30029:

      SYMTAB;coerce;$T;2 is replaced by t 

=========================================================================
macros 30028:

      TABLEAU;listOfLists;$L;2 is replaced by x 
      TABLEAU;tableau;L$;1 is replaced by lls 

=========================================================================
macros 30027:

      TEMUTL;parse is replaced by ncParseFromString 

=========================================================================
macros 30026:

      TEX;epilogue;$L;9 is replaced by QVELTf2 
      TEX;precondition is replaced by outputTran 
      TEX;prologue;$L;7 is replaced by QVELTf0 
      TEX;setEpilogue!;$2L;12 is replaced by QSETVELTf2l 
      TEX;setPrologue!;$2L;10 is replaced by QSETVELTf0l 
      TEX;setTex!;$2L;11 is replaced by QSETVELTf1l 
      TEX;stringify is replaced by object2String 
      TEX;tex;$L;8 is replaced by QVELTf1 

=========================================================================
macros 30025:

      TREE;empty;$;2 is replaced by CONS1empty 
      TREE;empty?;$B;1 is replaced by QEQCARt1 

=========================================================================
macros 30024:

      TUBE;closed?;$B;3 is replaced by QVELTplot2 
      TUBE;getCurve;$Curve;1 is replaced by QVELTplot0 
      TUBE;listLoops;$L;2 is replaced by QVELTplot1 
      TUBE;setClosed;$2B;5 is replaced by QSETVELTplot2flag 
      TUBE;tube;CurveLB$;6 is replaced by VECTOR 

=========================================================================
macros 30023:

      TUPLE;coerce;$Pa;2 is replaced by QCDR 
      TUPLE;length;$Nni;3 is replaced by QCAR 

=========================================================================
macros 30022:

      U16MAT;elt;$3I;8 is replaced by AREF2U16 
      U16MAT;empty;$;11 is replaced by MAKEMATRIXU1600 
      U16MAT;minColIndex;$I;2 is replaced by 0 
      U16MAT;minRowIndex;$I;1 is replaced by 0 
      U16MAT;ncols;$Nni;4 is replaced by ANCOLSU16 
      U16MAT;new;2NniI$;13 is replaced by MAKEMATRIX1U16 
      U16MAT;nrows;$Nni;3 is replaced by ANROWSU16 
      U16MAT;qelt;$3I;7 is replaced by AREF2U16 
      U16MAT;qnew;2I$;12 is replaced by MAKEMATRIXU16 
      U16MAT;qsetelt!;$4I;9 is replaced by SETAREF2U16 
      U16MAT;setelt;$4I;10 is replaced by SETAREF2U16 

=========================================================================
macros 30021:

      U16VEC;#;$Nni;1 is replaced by QVLENU16 
      U16VEC;elt;$2I;6 is replaced by ELTU16 
      U16VEC;empty;$;3 is replaced by GETREFVU1600 
      U16VEC;minIndex;$I;2 is replaced by 0 
      U16VEC;new;NniI$;4 is replaced by GETREFVU16 
      U16VEC;qelt;$2I;5 is replaced by ELTU16 
      U16VEC;qsetelt!;$3I;7 is replaced by SETELTU16 
      U16VEC;setelt;$3I;8 is replaced by SETELTU16 

=========================================================================
macros 30020:

      U32MAT;elt;$3I;8 is replaced by AREF2U32 
      U32MAT;empty;$;11 is replaced by MAKEMATRIXU3200 
      U32MAT;minColIndex;$I;2 is replaced by 0 
      U32MAT;minRowIndex;$I;1 is replaced by 0 
      U32MAT;ncols;$Nni;4 is replaced by ANCOLSU32 
      U32MAT;new;2NniI$;13 is replaced by MAKEMATRIX1U32 
      U32MAT;nrows;$Nni;3 is replaced by ANROWSU32 
      U32MAT;qelt;$3I;7 is replaced by AREF2U32 
      U32MAT;qnew;2I$;12 is replaced by MAKEMATRIXU32 
      U32MAT;qsetelt!;$4I;9 is replaced by SETAREF2U32 
      U32MAT;setelt;$4I;10 is replaced by SETAREF2U32 

=========================================================================
macros 30019:

      U32VEC;#;$Nni;1 is replaced by QVLENU32 
      U32VEC;elt;$2I;6 is replaced by ELTU32 
      U32VEC;empty;$;3 is replaced by GETREFVU3200 
      U32VEC;minIndex;$I;2 is replaced by 0 
      U32VEC;new;NniI$;4 is replaced by GETREFVU32 
      U32VEC;qelt;$2I;5 is replaced by ELTU32 
      U32VEC;qsetelt!;$3I;7 is replaced by SETELTU32 
      U32VEC;setelt;$3I;8 is replaced by SETELTU32 

=========================================================================
macros 30018:

      U8MAT;elt;$3I;8 is replaced by AREF2U8 
      U8MAT;empty;$;11 is replaced by MAKEMATRIXU800 
      U8MAT;minColIndex;$I;2 is replaced by 0 
      U8MAT;minRowIndex;$I;1 is replaced by 0 
      U8MAT;ncols;$Nni;4 is replaced by ANCOLSU8 
      U8MAT;new;2NniI$;13 is replaced by MAKEMATRIX1U8 
      U8MAT;nrows;$Nni;3 is replaced by ANROWSU8 
      U8MAT;qelt;$3I;7 is replaced by AREF2U8 
      U8MAT;qnew;2I$;12 is replaced by MAKEMATRIXU8 
      U8MAT;qsetelt!;$4I;9 is replaced by SETAREF2U8 
      U8MAT;setelt;$4I;10 is replaced by SETAREF2U8 

=========================================================================
macros 30017:

      U8VEC;#;$Nni;1 is replaced by QVLENU8 
      U8VEC;elt;$2I;6 is replaced by ELTU8 
      U8VEC;empty;$;3 is replaced by GETREFVU800 
      U8VEC;minIndex;$I;2 is replaced by 0 
      U8VEC;new;NniI$;4 is replaced by GETREFVU8 
      U8VEC;qelt;$2I;5 is replaced by ELTU8 
      U8VEC;qsetelt!;$3I;7 is replaced by SETELTU8 
      U8VEC;setelt;$3I;8 is replaced by SETELTU8 

=========================================================================
macros 30016:

      ULSCONS;getExpon is replaced by QCAR 
      ULSCONS;getUTS is replaced by QCDR 
      ULSCONS;laurent;IUTS$;3 is replaced by CONS 
      ULSCONS;rec is replaced by CONS 
      ULSCONS;showAll? is replaced by QUOTET 
      ULSCONS;termCoef is replaced by QCDR 
      ULSCONS;termExpon is replaced by QCAR 

=========================================================================
macros 30015:

      UNISEG;hasHi;$B;6 is replaced by QEQCARs1 

=========================================================================
macros 30014:

      UPXS;getExpon is replaced by QCAR 

=========================================================================
macros 30013:

      UPXSCONS;getExpon is replaced by QCAR 
      UPXSCONS;getULS is replaced by QCDR 
      UPXSCONS;puiseux;FULS$;3 is replaced by CONS 

=========================================================================
macros 30012:

      UPXSSING;coeff is replaced by QVELTterm0 
      UPXSSING;exponent is replaced by QVELTterm1 
      UPXSSING;exponentTerms is replaced by QVELTterm2 
      UPXSSING;makeTerm is replaced by VECTORcoefexpon 
      UPXSSING;setExponentTerms! is replaced by QSETVELTterm2list 

=========================================================================
macros 30011:

      UTS;getCoef is replaced by QCDR 
      UTS;getExpon is replaced by QCAR 
      UTS;rec is replaced by CONS 
      UTS;stream is replaced by x 

=========================================================================
macros 30010:

      UTSCAT-;factorials? is replaced by QUOTE 
      UTSCAT-;showAll? is replaced by QUOTET 

=========================================================================
macros 30009:

      UTSZ;getCoef is replaced by QCDR 
      UTSZ;getExpon is replaced by QCAR 
      UTSZ;rec is replaced by CONS 

=========================================================================
macros 30008:

      VARIABLE;=;2$B;4 is replaced by QUOTET 

=========================================================================
macros 30007:

      VIEW2D;graphStates;$V;7 is replaced by QVELTviewport2 
      VIEW2D;graphs;$V;8 is replaced by QVELTviewport1 
      VIEW2D;key;$I;9 is replaced by QVELTviewport0 
      VIEW2D;options;$L;3 is replaced by QVELTviewport7 

=========================================================================
macros 30006:

      VIEW3D;key;$I;43 is replaced by QVELTviewport0 
      VIEW3D;options;$L;8 is replaced by QVELTviewport12 
      VIEW3D;subspace;$Ts;6 is replaced by QVELTviewport11 

=========================================================================
macros 30005:

      VIEWDEF;viewWriteAvailable;L;24 is replaced by LISTPIXMAPBITMAPPOSTSCRIPTIMAGE 

=========================================================================
macros 30004:

      VOID;void;$;1 is replaced by voidValue 

=========================================================================
macros 30003:

      WUTSET;per is replaced by l 
      WUTSET;rep is replaced by s 

=========================================================================
macros 30002:

      XPR;#;$Nni;3 is replaced by LENGTH 

=========================================================================
macros 30001:

      XRPOLY;coerce;R$;22 is replaced by CONS0r 
      XRPOLY;constant?;$B;18 is replaced by QEQCARp0 
      XRPOLY;construct is replaced by lt 

=========================================================================
macros 30000:

      ZMOD;=;2$B;11 is replaced by EQL 
      ZMOD;=;2$B;29 is replaced by EQL 
      ZMOD;One;$;26 is replaced by 1 
      ZMOD;One;$;8 is replaced by 1 
      ZMOD;Zero;$;25 is replaced by 0 
      ZMOD;Zero;$;7 is replaced by 0 
      ZMOD;convert;$I;22 is replaced by x 
      ZMOD;convert;$I;4 is replaced by x 
      ZMOD;init;$;27 is replaced by 0 
      ZMOD;init;$;9 is replaced by 0 


=========================================================================
warnings 20566:

>compiling MAPPKG1.spad to MAPPKG1.nrlib
 
   Warnings: 
      [1] Use: import (MappingPackageInternalHacks1 A)
      [2] fixedPoint: :A -- should replace by pretend
      [3] **:  a1 has no value
      [4] recur:  n1 has no value
      [5] recur:  a2 has no value

=========================================================================
warnings 20565:

>compiling MAPPKG2.spad to MAPPKG2.nrlib
 
   Warnings: 
      [1] Use: import (MappingPackageInternalHacks2 A C)
      [2] const:  a1 has no value
      [3] constant:  a1 has no value
      [4] diag:  a1 has no value

=========================================================================
warnings 20564:

>compiling MAPPKG3.spad to MAPPKG3.nrlib
 
   Warnings: 
      [1] Use: import (MappingPackageInternalHacks3 A B C)
      [2] curryRight:  a has no value
      [3] curryLeft:  b has no value
      [4] constantRight:  a has no value
      [5] constantLeft:  b has no value
      [6] twist:  a has no value
      [7] twist:  b has no value
      [8] *:  a has no value

=========================================================================
warnings 20563:

>compiling MKBCFUNC.spad to MKBCFUNC.nrlib
 
   Warnings: 
      [1] binaryFunction:  d1 has no value
      [2] binaryFunction:  d2 has no value

=========================================================================
warnings 20562:

>compiling MKUCFUNC.spad to MKUCFUNC.nrlib
 
   Warnings: 
      [1] unaryFunction:  d1 has no value
 
=========================================================================
warnings 20561:

>compiling NIPROB.spad to NIPROB.nrlib
 
   Warnings: 
      [1] coerce:  nia has no value
      [2] coerce:  mdnia has no value
      [3] retract:  nia has no value
      [4] retract:  mdnia has no value
 
=========================================================================
warnings 20560:

>compiling OPTPROB.spad to OPTPROB.nrlib
 
   Warnings: 
      [1] coerce:  noa has no value
      [2] coerce:  lsa has no value
      [3] retract:  noa has no value
      [4] retract:  lsa has no value

=========================================================================
warnings 20559:

>compiling PATTERN1.spad to PATTERN1.nrlib

   Warnings: 
      [1] predicate:  d1 has no value
      [2] satisfy?:  var has no value
      [3] satisfy?:  pred has no value

=========================================================================
warnings 20558:

>compiling ASP29.spad to ASP29.nrlib
 
   Warnings: 
      [1]  ISTATE has no value
      [2]  NEXTIT has no value
      [3]  NEVALS has no value
      [4]  NVECS has no value
      [5]  K has no value
      [6]  F has no value
      [7]  D has no value

=========================================================================
warnings 20557:

>compiling BEZIER.spad to BEZIER.nrlib
 
   Warnings: 
      [1] linearBezier:  t has no value
      [2] quadraticBezier:  t has no value
      [3] cubicBezier:  t has no value

=========================================================================
warnings 20556:

>compiling FCOMP.spad to FCOMP.nrlib
 
   Warnings: 
      [1] elt:  y has no value
      [2] eval:  y has no value

=========================================================================
warnings 20555:

>compiling IDPAG.spad to IDPAG.nrlib
 
   Warnings: 
      [1] -:  res has no value
      [2] -:  endcell has no value

=========================================================================
warnings 20554:

>compiling IDPAM.spad to IDPAM.nrlib
 
   Warnings: 
      [1] +:  res has no value
      [2] +:  endcell has no value

=========================================================================
warnings 20553:

>compiling INCRMAPS.spad to INCRMAPS.nrlib
 
   Warnings: 
      [1] increment:  x has no value
      [2] incrementBy:  x has no value

=========================================================================
warnings 20552:

>compiling MONADWU.spad to MONADWU.nrlib
 
   Warnings: 
      [1] rightPower: signature of lhs not unique: SS(NonNegativeInteger) chosen
      [2] leftPower: signature of lhs not unique: SS(NonNegativeInteger) chosen
 
=========================================================================
warnings 20551:

>compiling PATMATCH.spad to PATMATCH.nrlib
 
   Warnings: 
      [1] ist: not known that (SetCategory) is of mode (CATEGORY package (SIGNATURE is? ((Boolean) Subject Pat)) (SIGNATURE is? ((Boolean) (List Subject) Pat)) (SIGNATURE Is ((PatternMatchListResult Base Subject (List Subject)) (List Subject) Pat)) (IF (has Subject (RetractableTo (Symbol))) (SIGNATURE Is ((List (Equation Subject)) Subject Pat)) (IF (has Subject (Ring)) (SIGNATURE Is ((List (Equation (Polynomial Subject))) Subject Pat)) (SIGNATURE Is ((PatternMatchResult Base Subject) Subject Pat)))))

=========================================================================
warnings 20550:

>compiling AUTOMOR.spad to AUTOMOR.nrlib
 
   Warnings: 
      [1] inv:  r1 has no value
      [2] inv:  i2 has no value
      [3] **: signature of lhs not unique: $$(Integer) chosen
      [4] **:  r1 has no value
      [5] **:  i2 has no value
      [6] morphism:  i2 has no value
      [7] morphism:  r1 has no value
      [8] *:  u1 has no value
      [9] *:  v1 has no value
      [10] *:  i2 has no value
      [11] *:  r1 has no value

=========================================================================
warnings 20549:

>compiling CHARPOL.spad to CHARPOL.nrlib
 
   Warnings: 
      [1] characteristicPolynomial: :(PositiveInteger) -- should replace by pretend

=========================================================================
warnings 20548:

>compiling ELAGG.spad to ELAGG.nrlib
 
   Warnings: 
      [1] remove!:  y has no value

=========================================================================
warnings 20547:

>compiling ES2.spad to ES2.nrlib
 
   Warnings: 
      [1] map:  IN has no value
      [2] map:  x has no value

=========================================================================
warnings 20546:

>compiling MKCHSET.spad to MKCHSET.nrlib
 
   Warnings: 
      [1] coerce:  x has no value
      [2] <:  x1 has no value
      [3] =:  x1 has no value

=========================================================================
warnings 20545:

>compiling IFAMON.spad to IFAMON.nrlib
 
   Warnings: 
      [1] *:  x has no value
      [2] coerce:  y has no value
      [3] coerce:  x has no value

=========================================================================
warnings 20544:

>compiling CARD.spad to CARD.nrlib
 
   Warnings: 
      [1] **: signature of lhs not unique: $$$ chosen
      [2] **: :(NonNegativeInteger) -- should replace by pretend

=========================================================================
warnings 20543:

>compiling FACTFUNC.spad to FACTFUNC.nrlib
 
   Warnings: 
      [1] nthRoot:  radi has no value

=========================================================================
warnings 20541:

>compiling AMR.spad to AMR.nrlib
 
   Warnings: 
      [1] *:  x1 has no value

=========================================================================
warnings 20540:

>compiling DEGRED.spad to DEGRED.nrlib
 
   Warnings: 
      [1] reduce: :(PositiveInteger) -- should replace by pretend

=========================================================================
warnings 20539:

>compiling DLP.spad to DLP.nrlib
 
   Warnings: 
      [1] shanksDiscLogAlgorithm:  found has no value
      [2] shanksDiscLogAlgorithm:  disclog has no value
      [3] shanksDiscLogAlgorithm: pretend(Integer) -- should replace by @

=========================================================================
warnings 20538:

>compiling FAGROUP.spad to FAGROUP.nrlib
 
   Warnings: 
      [1] <:  exp has no value
      [2] <:  gen has no value


=========================================================================
warnings 20537:

>compiling FIELD.spad to FIELD.nrlib
 
   Warnings: 
      [1] squareFree: not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE / (S S S)) (SIGNATURE inv (S S)) (SIGNATURE prime? ((Boolean) S)) (SIGNATURE squareFree ((Factored S) S)) (SIGNATURE factor ((Factored S) S)) (SIGNATURE divide ((Record (: quotient S) (: remainder S)) S S)) (SIGNATURE euclideanSize ((NonNegativeInteger) S)) (SIGNATURE gcd (S (List S))) (SIGNATURE gcd (S S S)) (SIGNATURE associates? ((Boolean) S S)) (SIGNATURE unitCanonical (S S)) (SIGNATURE unitNormal ((Record (: unit S) (: canonical S) (: associate S)) S)) (SIGNATURE exquo ((Union S failed) S S)))
 
=========================================================================
warnings 20536:

>compiling FLAGG.spad to FLAGG.nrlib
 
   Warnings: 
      [1] sorted?:  x has no value
      [2] sorted?:  y has no value

=========================================================================
warnings 20535:

>compiling FLINEXP.spad to FLINEXP.nrlib
 
   Warnings: 
      [1] reducedSystem: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix R)) (: vec (Vector R))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Matrix R) (Matrix S))))

=========================================================================
warnings 20534:

>compiling MAPPKG4.spad to MAPPKG4.nrlib
 
   Warnings: 
      [1] +:  c has no value
      [2] -:  c has no value
      [3] *:  c has no value
      [4] /:  c has no value

=========================================================================
warnings 20533:

>compiling OMLO.spad to OMLO.nrlib

   Warnings: 
      [1] op: :$ -- should replace by @
      [2] po: :P -- should replace by pretend
      [3] *: :P -- should replace by pretend
      [4] coerce: :P -- should replace by pretend

=========================================================================
warnings 20532:

>compiling PRODUCT.spad to PRODUCT.nrlib

   Warnings: 
      [1] count:  n has no value

=========================================================================
warnings 20531:

>compiling ARR2CAT.spad to ARR2CAT.nrlib
 
   Warnings: 
      [1] count:  num has no value
      [2] count:  x has no value

=========================================================================
warnings 20530:

>compiling ASP34.spad to ASP34.nrlib
 
   Warnings: 
      [1]  IFLAG has no value
      [2]  N has no value
      [3]  X has no value
      [4]  Y has no value
      [5]  LRWORK has no value
      [6]  LIWORK has no value
      [7]  RWORK has no value
      [8]  IWORK has no value
      [9] coerce:  I has no value
      [10] coerce:  J has no value
      [11] coerce:  W1 has no value
      [12] coerce:  W2 has no value
      [13] coerce:  MS has no value

=========================================================================
warnings 20529:

>compiling BFUNCT.spad to BFUNCT.nrlib
 
   Warnings: 
      [1] bf:  x1 has no value

=========================================================================
warnings 20528:

>compiling BTREE.spad to BTREE.nrlib
 
   Warnings: 
      [1] empty: pretend$ -- should replace by @
      [2] node: :Rep -- should replace by pretend
      [3] setvalue!: :Rep -- should replace by pretend
      [4] setleft!: :Rep -- should replace by pretend
      [5] setright!: :(List (Tree S)) -- should replace by pretend

=========================================================================
warnings 20527:

>compiling CRAPACK.spad to CRAPACK.nrlib
 
   Warnings: 
      [1] chineseRemainder:  a has no value
      [2] chineseRemainder:  d has no value
      [3] chineseRemainder:  b has no value
      [4] chineseRemainder:  c has no value

=========================================================================
warnings 20526:

>compiling DIRRING.spad to DIRRING.nrlib
 
   Warnings: 
      [1] per: pretend$ -- should replace by @
      [2] rep: pretendRep -- should replace by @
      [3] coerce:  n has no value
      [4] One:  n has no value
      [5] +:  n has no value
      [6] -:  n has no value
      [7] *:  n has no value
      [8] *:  a has no value
      [9] *:  b has no value
      [10] recip:  n has no value
      [11] multiplicative?: not known that (IntegralDomain) is of mode (CATEGORY domain (IF (has Coef (CommutativeRing)) (ATTRIBUTE (IntegralDomain)) noBranch) (IF (has Coef (CommutativeRing)) (ATTRIBUTE (Algebra Coef)) noBranch) (SIGNATURE coerce ($ (Mapping Coef (PositiveInteger)))) (SIGNATURE coerce ((Mapping Coef (PositiveInteger)) $)) (SIGNATURE coerce ($ (Stream Coef))) (SIGNATURE coerce ((Stream Coef) $)) (SIGNATURE zeta ($) constant) (SIGNATURE multiplicative? ((Boolean) $ (PositiveInteger))) (SIGNATURE additive? ((Boolean) $ (PositiveInteger))))
      [12] multiplicative?:  r has no value
      [13] multiplicative?:  s has no value
      [14] additive?:  r has no value
      [15] additive?:  s has no value

=========================================================================
warnings 20525:

>compiling DIV.spad to DIV.nrlib
 
   Warnings: 
      [1] reductum: pretendRep -- should replace by @
      [2] head: pretendRep -- should replace by @
      [3] coefficient:  r has no value
      [4] collect:  inList? has no value
      [5] collect:  t has no value
      [6] +: pretendRep -- should replace by @
      [7] *: pretendRep -- should replace by @

=========================================================================
warnings 20524:

>compiling D01GBFA.spad to D01GBFA.nrlib
 
   Warnings: 
      [1] numericalIntegration:  x has no value

=========================================================================
warnings 20523:

>compiling FAMR.spad to FAMR.nrlib
 
   Warnings: 
      [1] pomopo!:  x1 has no value
      [2] /:  x1 has no value
      [3] exquo: signature of lhs not unique: (Union S failed)SR chosen

=========================================================================
warnings 20522:

>compiling FM1.spad to FM1.nrlib
 
   Warnings: 
      [1] listOfTerms: :(List (Record (: k S) (: c R))) -- should replace by pretend

=========================================================================
warnings 20521:

>compiling FMONOID.spad to FMONOID.nrlib
 
   Warnings: 
      [1] overlap:  l has no value
      [2] divide:  l has no value
      [3] hclf:  h has no value
      [4] lquo:  gen has no value
      [5] lquo:  exp has no value

=========================================================================
warnings 20520:

>compiling IPADIC.spad to IPADIC.nrlib

   Warnings: 
      [1] padic: pretend$ -- should replace by @
      [2] =:  st has no value
      [3] intToPAdic:  digit has no value
      [4] intToPAdic:  carry has no value
      [5] intPlusPAdic:  digit has no value
      [6] intPlusPAdic:  carry has no value
      [7] intMinusPAdic:  digit has no value
      [8] intMinusPAdic:  carry has no value
      [9] plusAux:  digit has no value
      [10] plusAux:  carry has no value
      [11] minusAux:  digit has no value
      [12] minusAux:  carry has no value
      [13] intMult:  digit has no value
      [14] intMult:  carry has no value
      [15] timesAux:  digit has no value
      [16] timesAux:  carry has no value
      [17] coerce: pretend(Integer) -- should replace by @
      [18] coerce:  l has no value

=========================================================================
warnings 20519:

>compiling LIST2MAP.spad to LIST2MAP.nrlib
 
   Warnings: 
      [1] match:  z1 has no value

=========================================================================
warnings 20518:

>compiling LMOPS.spad to LMOPS.nrlib
 
   Warnings: 
      [1] mapExpon:  ans has no value
      [2] outputForm: The conditional modes (List (OutputForm)) and $ conflict

=========================================================================
warnings 20517:

>compiling MESH.spad to MESH.nrlib
 
   Warnings: 
      [1] ptFunc:  z1 has no value
      [2] ptFunc:  z2 has no value
      [3] meshFun2Var:  z1 has no value
      [4] meshFun2Var:  x2 has no value

=========================================================================
warnings 20516:

>compiling MOEBIUS.spad to MOEBIUS.nrlib
 
   Warnings: 
      [1] recip: signature of lhs not unique: $$ chosen
      [2] proportional?:  f1 has no value
      [3] proportional?:  g1 has no value

=========================================================================
warnings 20515:

>compiling MRING.spad to MRING.nrlib
 
   Warnings: 
      [1] index:  ans has no value
      [2] retractIfCan:  coef has no value
      [3] retractIfCan:  monom has no value
      [4] recip:  monom has no value
      [5] recip:  coef has no value
      [6] coerce:  coef has no value
      [7] coerce:  monom has no value
      [8] =:  coef has no value
      [9] =:  monom has no value
      [10] sortAndAdd:  m has no value
      [11] sortAndAdd:  res has no value

=========================================================================
warnings 20514:

>compiling ODR.spad to ODR.nrlib
 
   Warnings: 
      [1] not known that (IntegralDomain) is of mode (CATEGORY domain (IF (has R (Field)) (ATTRIBUTE (Field)) noBranch) (SIGNATURE coerce ($ R)) (SIGNATURE coerce (R $)))

=========================================================================
warnings 20513:

>compiling ORDCOMP.spad to ORDCOMP.nrlib
 
   Warnings: 
      [1] retract:  fin has no value
      [2] retractIfCan:  fin has no value
      [3] coerce:  fin has no value
      [4] coerce:  inf has no value
      [5] whatInfinity:  inf has no value
      [6] =:  inf has no value
      [7] =:  fin has no value
      [8] *:  inf has no value
      [9] *:  fin has no value
      [10] -:  inf has no value
      [11] -:  fin has no value
      [12] +:  inf has no value
      [13] +:  fin has no value
      [14] recip:  fin has no value
      [15] <:  inf has no value
      [16] <:  fin has no value

=========================================================================
warnings 20512:

>compiling PARTPERM.spad to PARTPERM.nrlib
 
   Warnings: 
      [1] partitions:  l1 has no value
      [2] shuffle:  l1 has no value
      [3] shuffle:  l2 has no value
      [4] shufflein:  l1 has no value

=========================================================================
warnings 20511:

>compiling PENDTREE.spad to PENDTREE.nrlib
 
   Warnings: 
      [1] ptree: pretend$ -- should replace by @
      [2] ptree: :Rep -- should replace by pretend
      [3] ptree: :$ -- should replace by @
      [4] =: :Rep -- should replace by pretend

=========================================================================
warnings 20510:

>compiling PLOTTOOL.spad to PLOTTOOL.nrlib
 
   Warnings: 
      [1] xRange:  u1 has no value
      [2] xRange:  v1 has no value
      [3] yRange:  u1 has no value
      [4] yRange:  v1 has no value

=========================================================================
warnings 20509:

>compiling PFR.spad to PFR.nrlib
 
   Warnings: 
      [1] LessThan: :(Boolean) -- should replace by pretend
      [2] multiplyFracTerms: :Rep -- should replace by pretend
      [3] multiplyFracTerms:  c has no value
      [4] compactFraction: :(NonNegativeInteger) -- should replace by pretend
      [5] compactFraction:  s has no value
      [6] compactFraction:  bf has no value

=========================================================================
warnings 20508:

>compiling PMDOWN.spad to PMDOWN.nrlib
 
   Warnings: 
      [1] fixPredicate:  a1 has no value
      [2] patternMatch:  a1 has no value
      [3] patternMatch: not known that (SetCategory) is of mode (CATEGORY package (SIGNATURE fixPredicate ((Mapping (Boolean) A) (Mapping (Boolean) B))) (SIGNATURE patternMatch ((PatternMatchResult S B) A (Pattern S) (PatternMatchResult S B))))
      [4] fixPredicates:  l1 has no value

=========================================================================
warnings 20507:

>compiling PMINS.spad to PMINS.nrlib
 
   Warnings: 
      [1] patternMatchInner:  i1 has no value
      [2] patternMatchInner:  i2 has no value

=========================================================================
warnings 20506:

>compiling PMLSAGG.spad to PMLSAGG.nrlib
 
   Warnings: 
      [1] match: not known that (SetCategory) is of mode (CATEGORY package (SIGNATURE patternMatch ((PatternMatchListResult S R L) L (Pattern S) (PatternMatchListResult S R L))))

=========================================================================
warnings 20505:

>compiling PMTOOLS.spad to PMTOOLS.nrlib
 
   Warnings: 
      [1] patternMatchTimes:  l1 has no value
      [2] patternMatch:  p1 has no value
      [3] patternMatch:  z2 has no value
      [4] patternMatch:  z1 has no value
      [5] patternMatch:  p2 has no value

=========================================================================
warnings 20504:

>compiling PRTITION.spad to PRTITION.nrlib
 
   Warnings: 
      [1] coerce: signature of lhs not unique: (List (Integer))$ chosen
      [2] partition:  i2 has no value
      [3] partition:  i1 has no value
      [4] conjugate: pretendRep -- should replace by @
      [5] coerce: pretendRep -- should replace by @
      [6] pdct: pretendRep -- should replace by @

=========================================================================
warnings 20503:

>compiling PSCAT.spad to PSCAT.nrlib
 
   Warnings: 
      [1] *:  r1 has no value
      [2] -:  r1 has no value
      [3] /:  r1 has no value

=========================================================================
warnings 20502:

>compiling SCACHE.spad to SCACHE.nrlib
 
   Warnings: 
      [1] enterInCache:  pos has no value

=========================================================================
warnings 20500:

>compiling STTAYLOR.spad to STTAYLOR.nrlib
 
   Warnings: 
      [1] +:  z has no value
      [2] -:  z has no value
      [3] *:  z has no value
      [4] exquo:  z has no value
      [5] /:  z has no value
      [6] nnintegers:  y has no value
      [7] integers:  y has no value
      [8] oddintegers:  y has no value
      [9] int:  y has no value
      [10] eval:  y has no value
      [11] eval:  z has no value
      [12] lagrange:  y has no value
      [13] generalLambert:  x has no value
      [14] generalLambert:  y has no value
      [15] comps:  y has no value
      [16] nlde:  y has no value
      [17] smult:  y has no value
      [18] powern:  order has no value
      [19] powern:  y has no value
      [20] power:  y has no value

=========================================================================
warnings 20499:

>compiling TABLBUMP.spad to TABLBUMP.nrlib
 
   Warnings: 
      [1] bumptab1:  s1 has no value
      [2] bumptab1:  s2 has no value
      [3] lex:  s1 has no value
      [4] lex:  s2 has no value
      [5] slex:  s1 has no value
      [6] slex:  s2 has no value
      [7] inverse:  s1 has no value
      [8] inverse:  s2 has no value
      [9] untab:  s2 has no value
      [10] untab:  s1 has no value

=========================================================================
warnings 20498:

>compiling UDPO.spad to UDPO.nrlib
 
   Warnings: 
      [1] more?:  y has no value
      [2] more?:  z has no value
      [3] largest:  y has no value
      [4] largest:  z has no value

=========================================================================
warnings 20497:

>compiling UNISEG.spad to UNISEG.nrlib
 
   Warnings: 
      [1] expand:  x has no value


=========================================================================
warnings 20496:

>compiling XPR.spad to XPR.nrlib
 
   Warnings: 
      [1] quasiRegular?:  k has no value
      [2] *:  k has no value
      [3] *:  c has no value

=========================================================================
warnings 20495:

>compiling AFFSP.spad to AFFSP.nrlib
 
   Warnings: 
      [1] removeConjugate:  conjrem has no value

=========================================================================
warnings 20494:

>compiling COMBINAT.spad to COMBINAT.nrlib
 
   Warnings: 
      [1] binomial:  s has no value
      [2] binomial:  b has no value

=========================================================================
warnings 20493:

>compiling D01FCFA.spad to D01FCFA.nrlib
 
   Warnings: 
      [1] numericalIntegration:  x has no value

=========================================================================
warnings 20492:

>compiling IFARRAY.spad to IFARRAY.nrlib
 
   Warnings: 
      [1] remove!:  k has no value
      [2] select!:  k has no value

=========================================================================
warnings 20491:

>compiling INTHEORY.spad to INTHEORY.nrlib
 
   Warnings: 
      [1] fibonacci:  f2 has no value
      [2] jacobi:  j has no value
      [3] eulerPhi: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE bernoulli ((Fraction (Integer)) (Integer))) (SIGNATURE chineseRemainder ((Integer) (Integer) (Integer) (Integer) (Integer))) (SIGNATURE divisors ((List (Integer)) (Integer))) (SIGNATURE euler ((Integer) (Integer))) (SIGNATURE eulerPhi ((Integer) (Integer))) (SIGNATURE fibonacci ((Integer) (Integer))) (SIGNATURE harmonic ((Fraction (Integer)) (Integer))) (SIGNATURE jacobi ((Integer) (Integer) (Integer))) (SIGNATURE legendre ((Integer) (Integer) (Integer))) (SIGNATURE moebiusMu ((Integer) (Integer))) (SIGNATURE numberOfDivisors ((Integer) (Integer))) (SIGNATURE sumOfDivisors ((Integer) (Integer))) (SIGNATURE sumOfKthPowerDivisors ((Integer) (Integer) (NonNegativeInteger))))
      [4] divisors:  i1 has no value
      [5] divisors:  i2 has no value

=========================================================================
warnings 20490:

>compiling LWORD.spad to LWORD.nrlib
 
   Warnings: 
      [1] factor1:  d has no value
      [2] LyndonWordsList1: :(Integer) -- should replace by pretend
      [3] LyndonWordsList1:  lbase1 has no value

=========================================================================
warnings 20489:

>compiling MATCAT.spad to MATCAT.nrlib
 
   Warnings: 
      [1] matrix:  rows has no value
      [2] -:  r1 has no value
      [3] *:  r1 has no value
      [4] columnSpace:  basis has no value
      [5] PfChar:  g has no value
      [6] /:  r1 has no value

=========================================================================
warnings 20488:

>compiling PLOT3D.spad to PLOT3D.nrlib
 
   Warnings: 
      [1] select:  fp has no value
      [2] rangeRefine:  c has no value
      [3] rangeRefine:  q has no value
      [4] rangeRefine:  NUMFUNEVALS has no value
      [5] refine:  curves has no value
      [6] plot:  curves has no value
      [7] plot:  z has no value

=========================================================================
warnings 20487:

>compiling POLYVEC.spad to POLYVEC.nrlib
 
   Warnings: 
      [1] extendedgcd:  swapped has no value
 
=========================================================================
warnings 20486:

>compiling PR.spad to PR.nrlib
 
   Warnings: 
      [1] times!:  endcell has no value
      [2] times!:  res has no value
      [3] times:  x1 has no value
      [4] addm!:  newcell has no value
      [5] addm!:  res has no value
      [6] addm!:  endcell has no value
      [7] **: pretend(NonNegativeInteger) -- should replace by @
      [8] ^: pretend(NonNegativeInteger) -- should replace by @
      [9] unitNormal:  lcf has no value
      [10] unitCanonical:  lcf has no value
      [11] fmecg:  rout has no value

=========================================================================
warnings 20485:

>compiling PROJSP.spad to PROJSP.nrlib
 
   Warnings: 
      [1] definingField: pretendRep -- should replace by @
      [2] coerce: pretendRep -- should replace by @
      [3] list: pretendRep -- should replace by @
      [4] pointValue: pretendRep -- should replace by @
      [5] removeConjugate:  conjrem has no value
      [6] lastNonNull: pretendRep -- should replace by @
      [7] lastNonNull: pretend(Integer) -- should replace by @

=========================================================================
warnings 20484:

>compiling STREAM.spad to STREAM.nrlib
 
   Warnings: 
      [1] pretendS -- should replace by @
      [2] showAllElements: not known that (LazyStreamAggregate S) is of mode (CATEGORY domain (SIGNATURE repeating? ((Boolean) (List S) $)))
      [3] remove: signature of lhs not unique: $(Mapping (Boolean) S)$ chosen
      [4] lazyEval: :(Mapping $) -- should replace by pretend
      [5] expand!:  d has no value

=========================================================================
warnings 20483:

>compiling VECTCAT.spad to VECTCAT.nrlib

   Warnings: 
      [1] -:  x has no value
      [2] *:  x has no value

=========================================================================
warnings 20482:

>compiling XRPOLY.spad to XRPOLY.nrlib
 
   Warnings: 
      [1] unexpand:  z has no value
      [2] unexpand:  y has no value
 
=========================================================================
warnings 20481:

>compiling IMATRIX.spad to IMATRIX.nrlib
 
   Warnings: 
      [1] determinant: not known that (CommutativeRing) is of mode (CATEGORY R (ATTRIBUTE (commutative *)))
 

=========================================================================
warnings 20479:

>compiling ASSOCEQ.spad to ASSOCEQ.nrlib
 
   Warnings: 
      [1] uncouplingMatrices:  z1 has no value

=========================================================================
warnings 20478:

>compiling CARTEN.spad to CARTEN.nrlib
 
   Warnings: 
      [1] index2int:  n has no value
      [2] permsign!:  nTrans has no value
      [3] elt:  n has no value
 
=========================================================================
warnings 20477:

>compiling CLIF.spad to CLIF.nrlib
 
   Warnings: 
      [1] addMonomProd:  c has no value

=========================================================================
warnings 20476:

>compiling CLIP.spad to CLIP.nrlib
 
   Warnings: 
      [1] iClipParametric:  x has no value
      [2] iClipParametric:  y has no value
      [3] iClipParametric:  z has no value
      [4] discardAndSplit:  ans has no value
      [5] clip:  x has no value
      [6] clip:  y has no value
      [7] clip:  yMax has no value
      [8] clip:  yMin has no value
      [9] clipWithRanges:  x has no value
 
=========================================================================
warnings 20475:

>compiling COORDSYS.spad to COORDSYS.nrlib
 
   Warnings: 
      [1] elliptic:  x has no value
      [2] prolateSpheroidal:  x has no value
      [3] oblateSpheroidal:  x has no value
      [4] bipolar:  x has no value
      [5] toroidal:  x has no value
      [6] conical:  x has no value

=========================================================================
warnings 20474:

>compiling DHMATRIX.spad to DHMATRIX.nrlib
 
   Warnings: 
      [1] *: signature of lhs not unique: (Point R)$(Point R) chosen

=========================================================================
warnings 20473:

>compiling DIOSP.spad to DIOSP.nrlib
 
   Warnings: 
      [1] dioSolve:  c has no value

=========================================================================
warnings 20472:

>compiling DIRPCAT.spad to DIRPCAT.nrlib
 
   Warnings: 
      [1] reducedSystem: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE coerce (S (Integer))) (SIGNATURE coerce ((OutputForm) S)) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix S) (Vector S))) (SIGNATURE coerce (S R)) (SIGNATURE differentiate (S S (Mapping R R))) (SIGNATURE differentiate (S S (Mapping R R) (NonNegativeInteger))) (SIGNATURE reducedSystem ((Matrix R) (Matrix S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix R)) (: vec (Vector R))) (Matrix S) (Vector S))) (SIGNATURE size ((NonNegativeInteger))) (SIGNATURE / (S S R)) (SIGNATURE dimension ((CardinalNumber))) (SIGNATURE coerce ((Vector R) S)))

=========================================================================
warnings 20471:

>compiling D02CJFA.spad to D02CJFA.nrlib
 
   Warnings: 
      [1] ODESolve:  i has no value
 
=========================================================================
warnings 20470:

>compiling FAXF.spad to FAXF.nrlib
 
   Warnings: 
      [1] extensionDegree: signature of lhs not unique: (PositiveInteger) chosen
      [2] minimalPolynomial: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE charthRoot ((Union S failed) S)) (SIGNATURE size ((NonNegativeInteger))) (SIGNATURE charthRoot (S S)) (SIGNATURE linearAssociatedLog ((Union (SparseUnivariatePolynomial F) failed) S S)) (SIGNATURE linearAssociatedLog ((SparseUnivariatePolynomial F) S)) (SIGNATURE linearAssociatedOrder ((SparseUnivariatePolynomial F) S)) (SIGNATURE linearAssociatedExp (S S (SparseUnivariatePolynomial F))) (SIGNATURE normal? ((Boolean) S)) (SIGNATURE createNormalElement (S)) (SIGNATURE trace (S S (PositiveInteger))) (SIGNATURE norm (S S (PositiveInteger))) (SIGNATURE minimalPolynomial ((SparseUnivariatePolynomial S) S (PositiveInteger))) (SIGNATURE trace (F S)) (SIGNATURE norm (F S)) (SIGNATURE degree ((PositiveInteger) S)) (SIGNATURE extensionDegree ((PositiveInteger))) (SIGNATURE minimalPolynomial ((SparseUnivariatePolynomial F) S)) (SIGNATURE represents (S (Vector F))) (SIGNATURE coordinates ((Matrix F) (Vector S))) (SIGNATURE coordinates ((Vector F) S)) (SIGNATURE transcendenceDegree ((NonNegativeInteger))) (SIGNATURE extensionDegree ((OnePointCompletion (PositiveInteger)))) (SIGNATURE degree ((OnePointCompletion (PositiveInteger)) S)) (SIGNATURE transcendent? ((Boolean) S)) (SIGNATURE algebraic? ((Boolean) S)) (SIGNATURE dimension ((CardinalNumber))))
      [3] degree: signature of lhs not unique: (PositiveInteger)S chosen
 
=========================================================================
warnings 20469:

>compiling FFPOLY2.spad to FFPOLY2.nrlib
 
   Warnings: 
      [1] rootOfIrreduciblePoly:  basispointer has no value
      [2] rootOfIrreduciblePoly:  beta has no value

=========================================================================
warnings 20468:

>compiling FNLA.spad to FNLA.nrlib
 
   Warnings: 
      [1] have:  hi has no value

=========================================================================
warnings 20466:

>compiling HB.spad to HB.nrlib
 
   Warnings: 
      [1] lfunc:  sum has no value
      [2] generate:  newNumComms has no value
 
=========================================================================
warnings 20464:

>compiling IRSN.spad to IRSN.nrlib
 
   Warnings: 
      [1] aIdInverse: :(NonNegativeInteger) -- should replace by @
      [2] signum:  s has no value
      [3] signum:  z has no value
      [4] testPermutation:  n has no value
      [5] testPermutation:  ok has no value
 
=========================================================================
warnings 20463:

>compiling LOP.spad to LOP.nrlib
 
   Warnings: 
      [1] rowEchWoZeroLines: pretend(NonNegativeInteger) -- should replace by @
      [2] rowEchWoZeroLinesWOVectorise: pretend(NonNegativeInteger) -- should replace by @
 
=========================================================================
warnings 20462:

>compiling MHROWRED.spad to MHROWRED.nrlib
 
   Warnings: 
      [1] nonzero?:  s has no value
      [2] non0:  allZero has no value
      [3] non0:  ans has no value
      [4] mkMat:  STEP has no value
      [5] mkMat:  i has no value
      [6] diagSubMatrix:  IN has no value
      [7] diagSubMatrix:  r has no value
      [8] diagSubMatrix:  STEP has no value
      [9] diagSubMatrix:  z has no value
      [10] vconc:  s has no value
      [11] rowEchelonLocal:  pivord has no value
 
=========================================================================
warnings 20461:

>compiling NUMQUAD.spad to NUMQUAD.nrlib
 
   Warnings: 
      [1] romberg:  change has no value
      [2] simpson:  change has no value
      [3] trapezoidal:  change has no value
      [4] rombergo:  change has no value
      [5] simpsono:  change has no value
      [6] trapezoidalo:  change has no value
 
=========================================================================
warnings 20460:

>compiling ODESYS.spad to ODESYS.nrlib
 
   Warnings: 
      [1] solve:  f1 has no value
      [2] triangulate:  f1 has no value
      [3] backsolve:  part has no value
      [4] solveInField:  l1 has no value
      [5] solveInField:  f2 has no value
 
=========================================================================
warnings 20459:

>compiling ODETOOLS.spad to ODETOOLS.nrlib
 
   Warnings: 
      [1] wronskianMatrix:  f1 has no value
 
=========================================================================
warnings 20458:

>compiling PERMAN.spad to PERMAN.nrlib
 
   Warnings: 
      [1] permanent3:  a has no value
      [2] permanent: :(Integer) -- should replace by pretend
      [3] permanent: :(PositiveInteger) -- should replace by pretend
      [4] permanent:  a has no value
      [5] permanent2: :(Integer) -- should replace by pretend
      [6] permanent2: :(PositiveInteger) -- should replace by pretend
      [7] permanent2: :(NonNegativeInteger) -- should replace by pretend
      [8] permanent2:  a has no value

=========================================================================
warnings 20457:

>compiling PFECAT.spad to PFECAT.nrlib
 
   Warnings: 
      [1] gcdPolynomial: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE charthRoot ((Union S failed) S)) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))))
      [2] charthRoot: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE charthRoot ((Union S failed) S)) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))))
      [3] solveLinearPolynomialEquation: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE charthRoot ((Union S failed) S)) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))))
 
=========================================================================
warnings 20456:

>compiling PSEUDLIN.spad to PSEUDLIN.nrlib
 
   Warnings: 
      [1] changeBase:  k1 has no value
      [2] normalForm0:  B has no value
      [3] normalForm0:  Binv has no value
 
=========================================================================
warnings 20455:

>compiling REP2.spad to REP2.nrlib
 
   Warnings: 
      [1] cyclicSubmodule:  basis has no value
      [2] standardBasisOfCyclicSubmodule:  standardBasis has no value
      [3] splitInternal:  submoduleRepresentation has no value
      [4] splitInternal:  factormoduleRepresentation has no value
      [5] areEquivalent?:  x0 has no value
      [6] areEquivalent?:  x1 has no value
      [7] areEquivalent?:  foundResult has no value
      [8] areEquivalent?:  result has no value
      [9] areEquivalent?:  transitionM has no value
      [10] isAbsolutelyIrreducible?:  result has no value
      [11] meatAxe: :(PositiveInteger) -- should replace by pretend
      [12] meatAxe:  x has no value
      [13] meatAxe:  foundResult has no value
      [14] meatAxe:  result has no value
      [15] meatAxe: signature of lhs not unique: (List (List (Matrix R)))(List (Matrix R))(Boolean) chosen
 
=========================================================================
warnings 20454:

>compiling SETMN.spad to SETMN.nrlib
 
   Warnings: 
      [1] elements:  l has no value
      [2] replaceKthElement:  found has no value
      [3] replaceKthElement:  i has no value
 
=========================================================================
warnings 20453:

>compiling STRING.spad to STRING.nrlib
 
   Warnings: 
      [1] OMwrite: pretend(String) -- should replace by @
 
=========================================================================
warnings 20452:

>compiling ASP1.spad to ASP1.nrlib
 
   Warnings: 
      [1]  X has no value
 
=========================================================================
warnings 20451:

>compiling ASP10.spad to ASP10.nrlib
 
   Warnings: 
      [1]  P has no value
      [2]  Q has no value
      [3]  DQDL has no value
      [4]  X has no value
      [5]  ELAM has no value
      [6]  JINT has no value
 
=========================================================================
warnings 20450:

>compiling ASP24.spad to ASP24.nrlib
 
   Warnings: 
      [1]  N has no value
      [2]  XC has no value
      [3]  FC has no value
      [4] coerce:  FC has no value
 
=========================================================================
warnings 20449:

>compiling ASP4.spad to ASP4.nrlib
 
   Warnings: 
      [1]  NDIM has no value
      [2]  X has no value
 
=========================================================================
warnings 20448:

>compiling ASP50.spad to ASP50.nrlib
 
   Warnings: 
      [1]  M has no value
      [2]  N has no value
      [3]  XC has no value
      [4]  FVECC has no value
      [5]  I has no value
      [6] coerce:  FVECC has no value
 

=========================================================================
warnings 20447:

>compiling ASP6.spad to ASP6.nrlib
 
   Warnings: 
      [1]  N has no value
      [2]  X has no value
      [3]  FVEC has no value
      [4]  IFLAG has no value
      [5] coerce:  FVEC has no value
 
=========================================================================
warnings 20446:

>compiling ASP73.spad to ASP73.nrlib
 
   Warnings: 
      [1]  X has no value
      [2]  Y has no value
      [3]  ALPHA has no value
      [4]  BETA has no value
      [5]  GAMMA has no value
      [6]  DELTA has no value
      [7]  EPSOLN has no value
      [8]  PHI has no value
      [9]  PSI has no value
 
=========================================================================
warnings 20445:

>compiling AXSERV.spad to AXSERV.nrlib
 
   Warnings: 
      [1] getFile:  contentType has no value
      [2] getContentType:  contentType has no value
 
=========================================================================
warnings 20444:

>compiling BALFACT.spad to BALFACT.nrlib
 
   Warnings: 
      [1] balancedFactorisation:  z1 has no value
      [2] balancedFactorisation: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE balancedFactorisation ((Factored UP) UP UP)) (SIGNATURE balancedFactorisation ((Factored UP) UP (List UP))))
 
=========================================================================
warnings 20443:

>compiling BOUNDZRO.spad to BOUNDZRO.nrlib
 
   Warnings: 
      [1] bringDown: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE integerBound ((Integer) UP)))
      [2] integerBound:  z1 has no value
      [3] qbound:  bound has no value
 
=========================================================================
warnings 20442:

>compiling CDEN.spad to CDEN.nrlib
 
   Warnings: 
      [1] clearDenominator:  x has no value
      [2] splitDenominator:  x has no value
      [3] commonDenominator:  x has no value
 
=========================================================================
warnings 20441:

>compiling CHVAR.spad to CHVAR.nrlib
 
   Warnings: 
      [1] eval:  s has no value
      [2] eval: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE mkIntegral ((Record (: coef (Fraction UP)) (: poly UPUP)) UPUP)) (SIGNATURE radPoly ((Union (Record (: radicand (Fraction UP)) (: deg (NonNegativeInteger))) failed) UPUP)) (SIGNATURE rootPoly ((Record (: exponent (NonNegativeInteger)) (: coef (Fraction UP)) (: radicand UP)) (Fraction UP) (NonNegativeInteger))) (SIGNATURE goodPoint (F UPUP UPUP)) (SIGNATURE eval (UPUP UPUP (Fraction UP) (Fraction UP))) (SIGNATURE chvar ((Record (: func UPUP) (: poly UPUP) (: c1 (Fraction UP)) (: c2 (Fraction UP)) (: deg (NonNegativeInteger))) UPUP UPUP)))
      [3] chvar:  s has no value
      [4] rootPoly: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE mkIntegral ((Record (: coef (Fraction UP)) (: poly UPUP)) UPUP)) (SIGNATURE radPoly ((Union (Record (: radicand (Fraction UP)) (: deg (NonNegativeInteger))) failed) UPUP)) (SIGNATURE rootPoly ((Record (: exponent (NonNegativeInteger)) (: coef (Fraction UP)) (: radicand UP)) (Fraction UP) (NonNegativeInteger))) (SIGNATURE goodPoint (F UPUP UPUP)) (SIGNATURE eval (UPUP UPUP (Fraction UP) (Fraction UP))) (SIGNATURE chvar ((Record (: func UPUP) (: poly UPUP) (: c1 (Fraction UP)) (: c2 (Fraction UP)) (: deg (NonNegativeInteger))) UPUP UPUP)))
 
=========================================================================
warnings 20440:

>compiling CONTFRAC.spad to CONTFRAC.nrlib
 
   Warnings: 
      [1] =:  whole has no value
      [2] =:  den has no value
      [3] partialNumerators:  x1 has no value
      [4] partialDenominators:  x1 has no value
      [5] partialQuotients:  whole has no value
      [6] extend:  fract has no value
      [7] complete:  fract has no value
      [8] iGenApproximants:  num has no value
      [9] iGenApproximants:  den has no value
      [10] iGenConvergents:  num has no value
      [11] iGenConvergents:  den has no value
      [12] +:  x has no value
      [13] +:  y has no value
      [14] -:  x has no value
      [15] -:  y has no value
      [16] *:  x has no value
      [17] *:  y has no value
      [18] /:  x has no value
      [19] /:  y has no value
      [20] recip:  x has no value
      [21] coerce:  l has no value

=========================================================================
warnings 20439:

>compiling DDFACT.spad to DDFACT.nrlib
 
   Warnings: 
      [1] notSqFr: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE factor ((Factored FP) FP)) (SIGNATURE factorSquareFree ((Factored FP) FP)) (SIGNATURE distdfact ((Record (: cont F) (: factors (List (Record (: irr FP) (: pow (Integer)))))) FP (Boolean))) (SIGNATURE separateDegrees ((List (Record (: deg (NonNegativeInteger)) (: prod FP))) FP)) (SIGNATURE separateFactors ((List FP) (List (Record (: deg (NonNegativeInteger)) (: prod FP))))) (SIGNATURE exptMod (FP FP (NonNegativeInteger) FP)) (SIGNATURE trace2PowMod (FP FP (NonNegativeInteger) FP)) (SIGNATURE tracePowMod (FP FP (NonNegativeInteger) FP)) (SIGNATURE irreducible? ((Boolean) FP)))
      [2] exptMod: :FP -- should replace by pretend
      [3] ddffact1:  ddfact has no value
      [4] separateFactors:  n1 has no value
      [5] separateFactors:  ris has no value
      [6] separateFactors:  newaux has no value
      [7] distdfact:  factlist has no value
 
=========================================================================
warnings 20438:

>compiling DIRPROD.spad to DIRPROD.nrlib
 
   Warnings: 
      [1] same?:  x has no value
      [2] Zero: pretend$ -- should replace by @
      [3] One: pretend$ -- should replace by @
      [4] *:  x has no value
      [5] *:  STEP has no value
      [6] *:  i has no value
      [7] *: pretend$ -- should replace by @
      [8] subtractIfCan: pretend$ -- should replace by @
      [9] recip: pretend$ -- should replace by @
      [10] unitVector: pretend$ -- should replace by @
 
=========================================================================
warnings 20437:

>compiling DISPLAY.spad to DISPLAY.nrlib
 
   Warnings: 
      [1] sayLength:  sum has no value
 
=========================================================================
warnings 20436:

>compiling DPOLCAT.spad to DPOLCAT.nrlib
 
   Warnings: 
      [1] makeVariable:  n has no value
      [2] degree:  d has no value
      [3] weights:  ws has no value
      [4] initial: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE coerce (A A)) (SIGNATURE coerce (A (Fraction (Integer)))) (SIGNATURE eval (A A (List S) (List R))) (SIGNATURE eval (A A S R)) (SIGNATURE eval (A A (List S) (List A))) (SIGNATURE eval (A A S A)) (SIGNATURE makeVariable ((Mapping A (NonNegativeInteger)) A)) (SIGNATURE separant (A A)) (SIGNATURE initial (A A)) (SIGNATURE leader (V A)) (SIGNATURE isobaric? ((Boolean) A)) (SIGNATURE weight ((NonNegativeInteger) A S)) (SIGNATURE weights ((List (NonNegativeInteger)) A S)) (SIGNATURE weight ((NonNegativeInteger) A)) (SIGNATURE weights ((List (NonNegativeInteger)) A)) (SIGNATURE degree ((NonNegativeInteger) A S)) (SIGNATURE order ((NonNegativeInteger) A)) (SIGNATURE order ((NonNegativeInteger) A S)) (SIGNATURE differentialVariables ((List S) A)) (SIGNATURE makeVariable ((Mapping A (NonNegativeInteger)) S)) (SIGNATURE retractIfCan ((Union S failed) A)) (SIGNATURE coerce (A S)) (SIGNATURE differentiate (A A (Mapping R R))) (SIGNATURE differentiate (A A (Mapping R R) (NonNegativeInteger))) (SIGNATURE differentiate (A A (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE differentiate (A A (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (A A (List (Symbol)))) (SIGNATURE differentiate (A A (Symbol))) (SIGNATURE differentiate (A A (NonNegativeInteger))) (SIGNATURE differentiate (A A)) (SIGNATURE degree ((List (NonNegativeInteger)) A (List V))) (SIGNATURE degree ((NonNegativeInteger) A V)) (SIGNATURE retractIfCan ((Union V failed) A)) (SIGNATURE coerce (A V)) (SIGNATURE eval (A A (List V) (List A))) (SIGNATURE eval (A A V A)) (SIGNATURE eval (A A (List V) (List R))) (SIGNATURE eval (A A V R)) (SIGNATURE eval (A A (List A) (List A))) (SIGNATURE eval (A A A A)) (SIGNATURE eval (A A (Equation A))) (SIGNATURE eval (A A (List (Equation A)))) (SIGNATURE degree (E A)) (SIGNATURE retractIfCan ((Union (Integer) failed) A)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) A)) (SIGNATURE coerce (A R)) (SIGNATURE retractIfCan ((Union R failed) A)) (SIGNATURE differentiate (A A (List V) (List (NonNegativeInteger)))) (SIGNATURE differentiate (A A V (NonNegativeInteger))) (SIGNATURE differentiate (A A (List V))) (SIGNATURE differentiate (A A V)) (SIGNATURE coerce (A (Integer))) (SIGNATURE coerce ((OutputForm) A)))
      [5] eval:  IN has no value
      [6] eval:  s has no value
      [7] eval:  e has no value
 
=========================================================================
warnings 20435:

>compiling DSTREE.spad to DSTREE.nrlib
 
   Warnings: 
      [1] tree: :(Record (: value S) (: args (List $))) -- should replace by @
      [2] tree: :$ -- should replace by pretend
      [3] value: :(Record (: value S) (: args (List $))) -- should replace by pretend
      [4] children: :(Record (: value S) (: args (List $))) -- should replace by pretend
      [5] children: :(List $) -- should replace by @
      [6] setchildren!: :(Record (: value S) (: args (List $))) -- should replace by pretend
      [7] setchildren!: pretend$ -- should replace by @
      [8] setvalue!: :(Record (: value S) (: args (List $))) -- should replace by pretend
 
=========================================================================
warnings 20434:

>compiling D01AMFA.spad to D01AMFA.nrlib
 
   Warnings: 
      [1] numericalIntegration:  x has no value
 
=========================================================================
warnings 20433:

>compiling D01APFA.spad to D01APFA.nrlib
 
   Warnings: 
      [1] numericalIntegration:  x has no value
 
=========================================================================
warnings 20432:

>compiling D01AQFA.spad to D01AQFA.nrlib
 
   Warnings: 
      [1] numericalIntegration:  x has no value
 
=========================================================================
warnings 20431:

>compiling EQ.spad to EQ.nrlib
 
   Warnings: 
      [1] factorAndSplit: not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE factorAndSplit ((List $) $)))
      [2] factorAndSplit: not known that (IntegralDomain) is of mode (CATEGORY S (SIGNATURE factor ((Factored S) S)))
 
=========================================================================
warnings 20430:

>compiling MDDFACT.spad to MDDFACT.nrlib
 
   Semantic Errors: 
      [1] ddfactor:  degree is BOTH a variable and a literal
      [2] ddfact:  degree is BOTH a variable and a literal
      [3] ddFact:  degree is BOTH a variable and a literal
      [4] sepfact:  degree is BOTH a variable and a literal
      [5] separateFactors:  degree is BOTH a variable and a literal
      [6] sepFact1:  degree is BOTH a variable and a literal
 
=========================================================================
warnings 20429:

>compiling MMAP.spad to MMAP.nrlib
 
   Warnings: 
      [1] map:  x has no value
 
=========================================================================
warnings 20428:

>compiling MODMON.spad to MODMON.nrlib

   Warnings: 
      [1] :(NonNegativeInteger) -- should replace by pretend
      [2] lift: pretendRep -- should replace by @
      [3] not known that (SetCategory) is of mode (CATEGORY domain (SIGNATURE frobenius ($ $)))
      [4] not known that (Ring) is of mode (CATEGORY domain (SIGNATURE frobenius ($ $)))
      [5] not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE frobenius ($ $)))
 
=========================================================================
warnings 20427:

>compiling MONOTOOL.spad to MONOTOOL.nrlib
 
   Warnings: 
      [1] splitSquarefree: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE split ((Record (: normal UP) (: special UP)) UP (Mapping UP UP))) (SIGNATURE splitSquarefree ((Record (: normal (Factored UP)) (: special (Factored UP))) UP (Mapping UP UP))) (SIGNATURE normalDenom (UP (Fraction UP) (Mapping UP UP))) (SIGNATURE decompose ((Record (: poly UP) (: normal (Fraction UP)) (: special (Fraction UP))) (Fraction UP) (Mapping UP UP))))
      [2] splitSquarefree:  s has no value
 
=========================================================================
warnings 20426:

>compiling MPCPF.spad to MPCPF.nrlib
 
   Warnings: 
      [1] factor: not known that (SIGNATURE variable ((Union $ failed) (Symbol))) is of mode (CATEGORY domain (SIGNATURE new ($)) (SIGNATURE new ($ $)) (SIGNATURE resetNew ((Void))) (SIGNATURE coerce ($ (String))) (SIGNATURE name ($ $)) (SIGNATURE scripted? ((Boolean) $)) (SIGNATURE scripts ((Record (: sub (List (OutputForm))) (: sup (List (OutputForm))) (: presup (List (OutputForm))) (: presub (List (OutputForm))) (: args (List (OutputForm)))) $)) (SIGNATURE script ($ $ (List (List (OutputForm))))) (SIGNATURE script ($ $ (Record (: sub (List (OutputForm))) (: sup (List (OutputForm))) (: presup (List (OutputForm))) (: presub (List (OutputForm))) (: args (List (OutputForm)))))) (SIGNATURE subscript ($ $ (List (OutputForm)))) (SIGNATURE superscript ($ $ (List (OutputForm)))) (SIGNATURE argscript ($ $ (List (OutputForm)))) (SIGNATURE elt ($ $ (List (OutputForm)))) (SIGNATURE string ((String) $)) (SIGNATURE list ((List $) $)) (SIGNATURE sample ($) constant))
 
=========================================================================
warnings 20425:

>compiling MPC2.spad to MPC2.nrlib
 
   Warnings: 
      [1] map: not known that (Ring) is of mode (CATEGORY package (SIGNATURE map (PS (Mapping S R) PR)) (SIGNATURE reshape (PS (List S) PR)))

=========================================================================
warnings 20424:

>compiling MPC3.spad to MPC3.nrlib
 
   Warnings: 
      [1] map: not known that (Ring) is of mode (CATEGORY package (SIGNATURE map (PR2 (Mapping Vars2 Vars1) PR1)))

=========================================================================
warnings 20423:

>compiling MPRFF.spad to MPRFF.nrlib
 
   Warnings: 
      [1] factor: not known that (PolynomialCategory (Fraction (Integer)) (IndexedExponents (Symbol)) (Symbol)) is of mode (CATEGORY domain (IF (has R (Algebra (Fraction (Integer)))) (SIGNATURE integrate ($ $ (Symbol))) noBranch))
      [2] factor: pretend(Factored (Polynomial R)) -- should replace by @
      [3] factor:  flist has no value
      [4] pushdown: not known that (Ring) is of mode (CATEGORY package (SIGNATURE totalfract ((Record (: sup (Polynomial R)) (: inf (Polynomial R))) PRF)) (SIGNATURE pushdown (PRF PRF OV)) (SIGNATURE pushdterm (PRF (SparseUnivariatePolynomial PRF) OV)) (SIGNATURE pushup (PRF PRF OV)) (SIGNATURE pushucoef (PRF (SparseUnivariatePolynomial (Polynomial R)) OV)) (SIGNATURE pushuconst (PRF (Fraction (Polynomial R)) OV)) (SIGNATURE factor ((Factored PRF) PRF)))
      [5] pushup:  y has no value
 
=========================================================================
warnings 20422:

>compiling MULTSQFR.spad to MULTSQFR.nrlib

   Warnings: 
      [1] nsqfree:  lcf has no value
      [2] nsqfree:  z2 has no value
      [3] nsqfree:  z1 has no value
      [4] nsqfree:  leadpol has no value
      [5] nsqfree:  sqlc has no value
      [6] nsqfree: :(NonNegativeInteger) -- should replace by pretend
      [7] nsqfree:  sqlead has no value
      [8] nsqfree:  unitsq has no value
      [9] nsqfree:  sqdec has no value
      [10] squareFree: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE squareFree ((Factored P) P)) (SIGNATURE squareFree ((Factored (SparseUnivariatePolynomial P)) (SparseUnivariatePolynomial P))) (SIGNATURE squareFreePrim ((Factored P) P)) (SIGNATURE compdegd ((Integer) (List (Record (: factor (SparseUnivariatePolynomial R)) (: exponent (Integer)))))) (SIGNATURE univcase ((Factored P) P OV)) (SIGNATURE consnewpol ((Record (: pol (SparseUnivariatePolynomial P)) (: polval (SparseUnivariatePolynomial R))) (SparseUnivariatePolynomial P) (SparseUnivariatePolynomial R) (Integer))) (SIGNATURE nsqfree ((Record (: unitPart P) (: suPart (List (Record (: factor (SparseUnivariatePolynomial P)) (: exponent (Integer)))))) (SparseUnivariatePolynomial P) (List OV) (List (List R)))) (SIGNATURE intChoose ((Record (: upol (SparseUnivariatePolynomial R)) (: Lval (List R)) (: Lfact (List (Record (: factor (SparseUnivariatePolynomial R)) (: exponent (Integer))))) (: ctpol R)) (SparseUnivariatePolynomial P) (List OV) (List (List R)))) (SIGNATURE coefChoose (P (Integer) (Factored P))) (SIGNATURE check ((Boolean) (List (Record (: factor (SparseUnivariatePolynomial R)) (: exponent (Integer)))) (List (Record (: factor (SparseUnivariatePolynomial R)) (: exponent (Integer)))))) (SIGNATURE lift ((Union (List (SparseUnivariatePolynomial P)) failed) (SparseUnivariatePolynomial P) (SparseUnivariatePolynomial R) (SparseUnivariatePolynomial R) P (List OV) (List (NonNegativeInteger)) (List R))) (SIGNATURE myDegree ((List (NonNegativeInteger)) (SparseUnivariatePolynomial P) (List OV) (NonNegativeInteger))) (SIGNATURE normDeriv2 ((SparseUnivariatePolynomial R) (SparseUnivariatePolynomial R) (Integer))))
      [11] squareFree:  fctr has no value
      [12] squareFree:  xpnt has no value
      [13] squareFree:  p has no value
      [14] squareFree:  result1 has no value
      [15] squareFree:  lvar has no value
      [16] squareFree: not known that (Ring) is of mode (CATEGORY package (SIGNATURE squareFree ((Factored P) P)) (SIGNATURE squareFree ((Factored (SparseUnivariatePolynomial P)) (SparseUnivariatePolynomial P))) (SIGNATURE squareFreePrim ((Factored P) P)) (SIGNATURE compdegd ((Integer) (List (Record (: factor (SparseUnivariatePolynomial R)) (: exponent (Integer)))))) (SIGNATURE univcase ((Factored P) P OV)) (SIGNATURE consnewpol ((Record (: pol (SparseUnivariatePolynomial P)) (: polval (SparseUnivariatePolynomial R))) (SparseUnivariatePolynomial P) (SparseUnivariatePolynomial R) (Integer))) (SIGNATURE nsqfree ((Record (: unitPart P) (: suPart (List (Record (: factor (SparseUnivariatePolynomial P)) (: exponent (Integer)))))) (SparseUnivariatePolynomial P) (List OV) (List (List R)))) (SIGNATURE intChoose ((Record (: upol (SparseUnivariatePolynomial R)) (: Lval (List R)) (: Lfact (List (Record (: factor (SparseUnivariatePolynomial R)) (: exponent (Integer))))) (: ctpol R)) (SparseUnivariatePolynomial P) (List OV) (List (List R)))) (SIGNATURE coefChoose (P (Integer) (Factored P))) (SIGNATURE check ((Boolean) (List (Record (: factor (SparseUnivariatePolynomial R)) (: exponent (Integer)))) (List (Record (: factor (SparseUnivariatePolynomial R)) (: exponent (Integer)))))) (SIGNATURE lift ((Union (List (SparseUnivariatePolynomial P)) failed) (SparseUnivariatePolynomial P) (SparseUnivariatePolynomial R) (SparseUnivariatePolynomial R) P (List OV) (List (NonNegativeInteger)) (List R))) (SIGNATURE myDegree ((List (NonNegativeInteger)) (SparseUnivariatePolynomial P) (List OV) (NonNegativeInteger))) (SIGNATURE normDeriv2 ((SparseUnivariatePolynomial R) (SparseUnivariatePolynomial R) (Integer))))
      [17] intChoose: :R -- should replace by @
      [18] intChoose:  d1 has no value
      [19] coefChoose:  lcoef has no value
      [20] lift:  leadlist has no value
      [21] lift:  p0 has no value
      [22] lift:  p1 has no value
 
=========================================================================
warnings 20421:

>compiling NPCOEF.spad to NPCOEF.nrlib
 
   Warnings: 
      [1] npcoef: :(NonNegativeInteger) -- should replace by pretend
      [2] npcoef:  ndet has no value
      [3] npcoef:  detufact has no value
      [4] npcoef:  n2 has no value
      [5] npcoef:  n1 has no value
      [6] npcoef:  ltodel has no value
      [7] npcoef:  detcoef has no value
      [8] check: :(NonNegativeInteger) -- should replace by pretend
      [9] check:  doit has no value
      [10] check:  cfu has no value
      [11] check:  poselt has no value
      [12] check:  pp has no value
      [13] buildtable:  table has no value
      [14] modify: :(NonNegativeInteger) -- should replace by pretend
      [15] modify:  lterase has no value
      [16] modify:  n2 has no value
      [17] modify:  n1 has no value

=========================================================================
warnings 20420:

>compiling NSUP.spad to NSUP.nrlib
 
   Warnings: 
      [1] subResultantGcd: not known that (UnivariatePolynomialCategory R) is of mode (CATEGORY domain (SIGNATURE halfExtendedResultant2 ((Record (: resultant R) (: coef2 $)) $ $)))
 
=========================================================================
warnings 20419:

>compiling ODEPRIM.spad to ODEPRIM.nrlib
 
   Warnings: 
      [1] UP2UP2:  f1 has no value
      [2] indicialEquations:  eq has no value
      [3] NPmulambda:  lamb has no value
      [4] NPmulambda:  lf has no value

=========================================================================
warnings 20418:

>compiling ODEPRRIC.spad to ODEPRRIC.nrlib
 
   Warnings: 
      [1] lambda:  z has no value
      [2] infLambda:  z has no value
      [3] infmax:  z has no value
      [4] dmax:  z has no value
      [5] padicsol:  z has no value
      [6] leadingDenomRicDE:  ind has no value
      [7] leadingDenomRicDE:  z2 has no value
      [8] leadingDenomRicDE:  z1 has no value
      [9] constantCoefficientOperator:  ans has no value
      [10] innermax:  ans has no value
      [11] leadingCoefficientRicDE:  ind has no value
      [12] leadingCoefficientRicDE:  z2 has no value
      [13] leadingCoefficientRicDE:  z1 has no value
      [14] innerlb:  lb has no value
      [15] polysol:  z has no value
 
=========================================================================
warnings 20417:

>compiling OMPKG.spad to OMPKG.nrlib
 
   Warnings: 
      [1] OMreadStr: pretend(String) -- should replace by @
      [2] OMlistCDs: pretend(List (String)) -- should replace by @
      [3] OMlistSymbols: pretend(List (String)) -- should replace by @

=========================================================================
warnings 20416:

>compiling PADICRC.spad to PADICRC.nrlib
 
   Warnings: 
      [1] coerce:  l has no value
 
=========================================================================
warnings 20415:

>compiling PFBR.spad to PFBR.nrlib

   Warnings: 
      [1] hensel:  z1 has no value
      [2] hensel: not known that (Ring) is of mode (CATEGORY package (SIGNATURE solveLinearPolynomialEquationByRecursion ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorByRecursion ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreeByRecursion ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE randomR (R)) (SIGNATURE bivariateSLPEBR ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S) VarSet)) (SIGNATURE factorSFBRlcUnit ((Factored (SparseUnivariatePolynomial S)) (List VarSet) (SparseUnivariatePolynomial S))))
      [3] hensel:  foundFactors has no value
      [4] factorSFBRlcUnitInner:  z1 has no value
      [5] factorSFBRlcUnitInner: not known that (Ring) is of mode (CATEGORY package (SIGNATURE solveLinearPolynomialEquationByRecursion ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorByRecursion ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreeByRecursion ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE randomR (R)) (SIGNATURE bivariateSLPEBR ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S) VarSet)) (SIGNATURE factorSFBRlcUnit ((Factored (SparseUnivariatePolynomial S)) (List VarSet) (SparseUnivariatePolynomial S))))
      [6] factorSFBRlcUnitInner:  fctr has no value
      [7] bivariateSLPEBR:  z1 has no value
      [8] chooseFSQViableSubstitutions:  z1 has no value
      [9] chooseFSQViableSubstitutions:  ppR has no value
      [10] chooseSLPEViableSubstitutions:  z1 has no value
      [11] chooseSLPEViableSubstitutions:  lpolysR has no value
      [12] raise:  z1 has no value
      [13] raise: :R -- should replace by pretend
      [14] raise: :R -- should replace by @
      [15] lower:  z1 has no value
      [16] SLPEBR:  z1 has no value
      [17] factorByRecursion: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE solveLinearPolynomialEquationByRecursion ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorByRecursion ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreeByRecursion ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE randomR (R)) (SIGNATURE bivariateSLPEBR ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S) VarSet)) (SIGNATURE factorSFBRlcUnit ((Factored (SparseUnivariatePolynomial S)) (List VarSet) (SparseUnivariatePolynomial S))))
      [18] factorByRecursion:  z1 has no value
      [19] factorByRecursion: :S -- should replace by @
      [20] factorSquareFreeByRecursion:  lcppPow has no value
 
=========================================================================
warnings 20414:

>compiling PFBRU.spad to PFBRU.nrlib
 
   Warnings: 
      [1] solveLinearPolynomialEquationByRecursion:  z1 has no value
      [2] solveLinearPolynomialEquationByRecursion: not known that (Ring) is of mode (CATEGORY package (SIGNATURE solveLinearPolynomialEquationByRecursion ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorByRecursion ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreeByRecursion ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE randomR (R)) (SIGNATURE factorSFBRlcUnit ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))))
      [3] solveLinearPolynomialEquationByRecursion:  answer has no value
      [4] hensel:  z1 has no value
      [5] hensel:  foundFactors has no value
      [6] chooseFSQViableSubstitutions:  z1 has no value
      [7] chooseFSQViableSubstitutions:  ppR has no value
      [8] raise:  z1 has no value
      [9] raise: :R -- should replace by pretend
      [10] raise: :R -- should replace by @
      [11] lower:  z1 has no value
      [12] factorSFBRlcUnitInner:  z1 has no value
      [13] factorSFBRlcUnitInner: not known that (Ring) is of mode (CATEGORY package (SIGNATURE solveLinearPolynomialEquationByRecursion ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorByRecursion ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreeByRecursion ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE randomR (R)) (SIGNATURE factorSFBRlcUnit ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))))
      [14] factorSFBRlcUnitInner:  fctr has no value
      [15] factorByRecursion: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE solveLinearPolynomialEquationByRecursion ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorByRecursion ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreeByRecursion ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE randomR (R)) (SIGNATURE factorSFBRlcUnit ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))))
      [16] factorByRecursion:  z1 has no value
      [17] factorByRecursion: :S -- should replace by pretend
      [18] factorByRecursion: :S -- should replace by @
      [19] factorSquareFreeByRecursion:  lcppPow has no value

=========================================================================
warnings 20413:

>compiling PFORP.spad to PFORP.nrlib
 
   Warnings: 
      [1] translateLocal: The conditional modes (List R) and (Mapping E (Integer)) conflict
      [2] minimalForm:  lminForm has no value
      [3] listAllMonoExp: pretend(Integer) -- should replace by @

=========================================================================
warnings 20412:

>compiling PFRPAC.spad to PFRPAC.nrlib
 
   Warnings: 
      [1] makeSup: not known that (Ring) is of mode (CATEGORY package (SIGNATURE partialFraction ((Any) (Fraction (Polynomial R)) (Symbol))) (SIGNATURE partialFraction ((Any) (Polynomial R) (Factored (Polynomial R)) (Symbol))))
      [2] makeSup:  z1 has no value
 
=========================================================================
warnings 20411:

>compiling PGCD.spad to PGCD.nrlib
 
   Warnings: 
      [1] gcdPrimitive:  b has no value
      [2] gcdPrimitive:  a has no value
      [3] localgcd:  s has no value
      [4] gcdTermList: not known that (Ring) is of mode (CATEGORY package (SIGNATURE gcd (P P P)) (SIGNATURE gcd (P (List P))) (SIGNATURE gcd ((SparseUnivariatePolynomial P) (SparseUnivariatePolynomial P) (SparseUnivariatePolynomial P))) (SIGNATURE gcd ((SparseUnivariatePolynomial P) (List (SparseUnivariatePolynomial P)))) (SIGNATURE gcdPrimitive (P P P)) (SIGNATURE gcdPrimitive ((SparseUnivariatePolynomial P) (SparseUnivariatePolynomial P) (SparseUnivariatePolynomial P))) (SIGNATURE gcdPrimitive (P (List P))))
      [5] lift:  p0 has no value
      [6] gcd:  z1 has no value
      [7] gcd:  z2 has no value

=========================================================================
warnings 20410:

>compiling PLEQN.spad to PLEQN.nrlib
 
   Warnings: 
      [1] regime:  wcd has no value
      [2] regime:  yzero has no value
      [3] bsolve:  rksoln has no value
      [4] bsolve:  lrec3 has no value
      [5] ParCondList:  covered has no value
      [6] ParCondList:  zro has no value
      [7] ParCondList:  npc has no value
      [8] ParCondList:  done has no value
      [9] ParCondList:  rcl has no value
      [10] pr2dmp: pretendGR -- should replace by @
      [11] dmp2rfi:  v1 has no value
      [12] dmp2rfi:  r1 has no value
      [13] sqfree: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE psolve ((List (Record (: eqzro (List GR)) (: neqzro (List GR)) (: wcond (List (Polynomial R))) (: bsoln (Record (: partsol (Vector (Fraction (Polynomial R)))) (: basis (List (Vector (Fraction (Polynomial R))))))))) (Matrix GR) (List GR))) (SIGNATURE psolve ((List (Record (: eqzro (List GR)) (: neqzro (List GR)) (: wcond (List (Polynomial R))) (: bsoln (Record (: partsol (Vector (Fraction (Polynomial R)))) (: basis (List (Vector (Fraction (Polynomial R))))))))) (Matrix GR) (List (Symbol)))) (SIGNATURE psolve ((List (Record (: eqzro (List GR)) (: neqzro (List GR)) (: wcond (List (Polynomial R))) (: bsoln (Record (: partsol (Vector (Fraction (Polynomial R)))) (: basis (List (Vector (Fraction (Polynomial R))))))))) (Matrix GR))) (SIGNATURE psolve ((List (Record (: eqzro (List GR)) (: neqzro (List GR)) (: wcond (List (Polynomial R))) (: bsoln (Record (: partsol (Vector (Fraction (Polynomial R)))) (: basis (List (Vector (Fraction (Polynomial R))))))))) (Matrix GR) (List GR) (PositiveInteger))) (SIGNATURE psolve ((List (Record (: eqzro (List GR)) (: neqzro (List GR)) (: wcond (List (Polynomial R))) (: bsoln (Record (: partsol (Vector (Fraction (Polynomial R)))) (: basis (List (Vector (Fraction (Polynomial R))))))))) (Matrix GR) (List (Symbol)) (PositiveInteger))) (SIGNATURE psolve ((List (Record (: eqzro (List GR)) (: neqzro (List GR)) (: wcond (List (Polynomial R))) (: bsoln (Record (: partsol (Vector (Fraction (Polynomial R)))) (: basis (List (Vector (Fraction (Polynomial R))))))))) (Matrix GR) (PositiveInteger))) (SIGNATURE psolve ((Integer) (Matrix GR) (List GR) (String))) (SIGNATURE psolve ((Integer) (Matrix GR) (List (Symbol)) (String))) (SIGNATURE psolve ((Integer) (Matrix GR) (String))) (SIGNATURE psolve ((Integer) (Matrix GR) (List GR) (PositiveInteger) (String))) (SIGNATURE psolve ((Integer) (Matrix GR) (List (Symbol)) (PositiveInteger) (String))) (SIGNATURE psolve ((Integer) (Matrix GR) (PositiveInteger) (String))) (SIGNATURE wrregime ((Integer) (List (Record (: eqzro (List GR)) (: neqzro (List GR)) (: wcond (List (Polynomial R))) (: bsoln (Record (: partsol (Vector (Fraction (Polynomial R)))) (: basis (List (Vector (Fraction (Polynomial R))))))))) (String))) (SIGNATURE rdregime ((List (Record (: eqzro (List GR)) (: neqzro (List GR)) (: wcond (List (Polynomial R))) (: bsoln (Record (: partsol (Vector (Fraction (Polynomial R)))) (: basis (List (Vector (Fraction (Polynomial R))))))))) (String))) (SIGNATURE bsolve ((Record (: rgl (List (Record (: eqzro (List GR)) (: neqzro (List GR)) (: wcond (List (Polynomial R))) (: bsoln (Record (: partsol (Vector (Fraction (Polynomial R)))) (: basis (List (Vector (Fraction (Polynomial R)))))))))) (: rgsz (Integer))) (Matrix GR) (List (Fraction (Polynomial R))) (NonNegativeInteger) (String) (Integer))) (SIGNATURE dmp2rfi ((Fraction (Polynomial R)) GR)) (SIGNATURE dmp2rfi ((Matrix (Fraction (Polynomial R))) (Matrix GR))) (SIGNATURE dmp2rfi ((List (Fraction (Polynomial R))) (List GR))) (SIGNATURE se2rfi ((List (Fraction (Polynomial R))) (List (Symbol)))) (SIGNATURE pr2dmp (GR (Polynomial R))) (SIGNATURE hasoln ((Record (: sysok (Boolean)) (: z0 (List GR)) (: n0 (List GR))) (List GR) (List GR))) (SIGNATURE ParCondList ((List (Record (: rank (NonNegativeInteger)) (: eqns (List (Record (: det GR) (: rows (List (Integer))) (: cols (List (Integer)))))) (: fgb (List GR)))) (Matrix GR) (NonNegativeInteger))) (SIGNATURE redpps ((Record (: partsol (Vector (Fraction (Polynomial R)))) (: basis (List (Vector (Fraction (Polynomial R)))))) (Record (: partsol (Vector (Fraction (Polynomial R)))) (: basis (List (Vector (Fraction (Polynomial R)))))) (List GR))) (SIGNATURE B1solve ((Record (: partsol (Vector (Fraction (Polynomial R)))) (: basis (List (Vector (Fraction (Polynomial R)))))) (Record (: mat (Matrix (Fraction (Polynomial R)))) (: vec (List (Fraction (Polynomial R)))) (: rank (NonNegativeInteger)) (: rows (List (Integer))) (: cols (List (Integer)))))) (SIGNATURE factorset ((List GR) GR)) (SIGNATURE maxrank ((NonNegativeInteger) (List (Record (: rank (NonNegativeInteger)) (: eqns (List (Record (: det GR) (: rows (List (Integer))) (: cols (List (Integer)))))) (: fgb (List GR)))))) (SIGNATURE minrank ((NonNegativeInteger) (List (Record (: rank (NonNegativeInteger)) (: eqns (List (Record (: det GR) (: rows (List (Integer))) (: cols (List (Integer)))))) (: fgb (List GR)))))) (SIGNATURE minset ((List (List GR)) (List (List GR)))) (SIGNATURE nextSublist ((List (List (Integer))) (Integer) (Integer))) (SIGNATURE overset? ((Boolean) (List GR) (List (List GR)))) (SIGNATURE ParCond ((List (Record (: det GR) (: rows (List (Integer))) (: cols (List (Integer))))) (Matrix GR) (NonNegativeInteger))) (SIGNATURE redmat ((Matrix GR) (Matrix GR) (List GR))) (SIGNATURE regime ((Record (: eqzro (List GR)) (: neqzro (List GR)) (: wcond (List (Polynomial R))) (: bsoln (Record (: partsol (Vector (Fraction (Polynomial R)))) (: basis (List (Vector (Fraction (Polynomial R)))))))) (Record (: det GR) (: rows (List (Integer))) (: cols (List (Integer)))) (Matrix GR) (List (Fraction (Polynomial R))) (List (List GR)) (NonNegativeInteger) (NonNegativeInteger) (Integer))) (SIGNATURE sqfree (GR GR)) (SIGNATURE inconsistent? ((Boolean) (List GR))) (SIGNATURE inconsistent? ((Boolean) (List (Polynomial R)))))
      [14] ParCond:  found has no value
      [15] ParCond:  DetEqn has no value
      [16] ParCond:  z1 has no value
      [17] ParCond:  z2 has no value
 
=========================================================================
warnings 20409:

>compiling PMPLCAT.spad to PMPLCAT.nrlib
 
   Warnings: 
      [1] patternMatch:  l1 has no value
      [2] patternMatch:  p1 has no value
      [3] patternMatch:  p2 has no value
      [4] patternMatch:  p3 has no value

=========================================================================
warnings 20408:

>compiling PNTHEORY.spad to PNTHEORY.nrlib

   Warnings: 
      [1] cyclotomic:  s has no value
      [2] cyclotomic:  c has no value
 

=========================================================================
warnings 20407:

>compiling POLUTIL.spad to POLUTIL.nrlib
 
   Warnings: 
      [1] sylvesterSequence:  res has no value
      [2] sturmVariationsOf:  ll has no value

=========================================================================
warnings 20406:

>compiling POLYCATQ.spad to POLYCATQ.nrlib
 
   Warnings: 
      [1] isPower:  var has no value
      [2] P2UP:  z has no value
      [3] P2UP: not known that (Ring) is of mode (CATEGORY package (SIGNATURE variables ((List V) F)) (SIGNATURE mainVariable ((Union V failed) F)) (SIGNATURE univariate ((Fraction (SparseUnivariatePolynomial F)) F V)) (SIGNATURE multivariate (F (Fraction (SparseUnivariatePolynomial F)) V)) (SIGNATURE univariate ((SparseUnivariatePolynomial F) F V (SparseUnivariatePolynomial F))) (SIGNATURE isPlus ((Union (List F) failed) F)) (SIGNATURE isTimes ((Union (List F) failed) F)) (SIGNATURE isExpt ((Union (Record (: var V) (: exponent (Integer))) failed) F)) (SIGNATURE isPower ((Union (Record (: val F) (: exponent (Integer))) failed) F)))
 
=========================================================================
warnings 20405:

>compiling POLYLIFT.spad to POLYLIFT.nrlib
 
   Warnings: 
      [1] map: not known that (Ring) is of mode (CATEGORY package (SIGNATURE map (S (Mapping S Vars) (Mapping S R) P)))

=========================================================================
warnings 20404:

>compiling POLYROOT.spad to POLYROOT.nrlib
 
   Warnings: 
      [1] zroot: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE rroot ((Record (: exponent (NonNegativeInteger)) (: coef F) (: radicand F)) R (NonNegativeInteger))) (SIGNATURE qroot ((Record (: exponent (NonNegativeInteger)) (: coef F) (: radicand F)) (Fraction (Integer)) (NonNegativeInteger))) (IF (has R (GcdDomain)) (SIGNATURE froot ((Record (: exponent (NonNegativeInteger)) (: coef F) (: radicand F)) F (NonNegativeInteger))) noBranch) (SIGNATURE nthr ((Record (: exponent (NonNegativeInteger)) (: coef P) (: radicand (List P))) P (NonNegativeInteger))))
 
=========================================================================
warnings 20403:

>compiling POLY2.spad to POLY2.nrlib
 
   Warnings: 
      [1] map:  x1 has no value
      [2] map:  x2 has no value

=========================================================================
warnings 20402:

>compiling POLY2UP.spad to POLY2UP.nrlib
 
   Warnings: 
      [1] univariate: not known that (Ring) is of mode (CATEGORY package (SIGNATURE univariate ((UnivariatePolynomial x (Polynomial R)) (Polynomial R) (Variable x))))
      [2] univariate:  x1 has no value

=========================================================================
warnings 20401:

>compiling PRS.spad to PRS.nrlib
 
   Warnings: 
      [1] exquo:  p1 has no value
      [2] resultantnaif:  a has no value
      [3] resultantEuclideannaif:  a has no value
      [4] semiResultantEuclideannaif:  a has no value
      [5] chainSubResultants:  L has no value
      [6] schema:  L has no value
 

=========================================================================
warnings 20400:

>compiling PSQFR.spad to PSQFR.nrlib
 
   Warnings: 
      [1] pPolRoot: not known that (Ring) is of mode (CATEGORY package (SIGNATURE squareFree ((Factored P) P)))
      [2] pthPower:  isSq has no value
      [3] pthPower:  fctr has no value
      [4] pthPower:  xpnt has no value
      [5] finSqFr: :(NonNegativeInteger) -- should replace by pretend
      [6] finSqFr:  cont1 has no value

=========================================================================
warnings 20399:

>compiling PUSHVAR.spad to PUSHVAR.nrlib
 
   Warnings: 
      [1] map:  x has no value
      [2] map: not known that (Ring) is of mode (CATEGORY package (SIGNATURE pushdown (PPR PPR OV)) (SIGNATURE pushdown (PPR PPR (List OV))) (SIGNATURE pushup (PPR PPR OV)) (SIGNATURE pushup (PPR PPR (List OV))) (SIGNATURE map (PPR (Mapping PPR (Polynomial R)) PPR)))
      [3] pushup:  y has no value
 
=========================================================================
warnings 20398:

>compiling QALGSET.spad to QALGSET.nrlib
 
   Warnings: 
      [1] npoly: not known that (OrderedAbelianMonoid) is of mode (CATEGORY domain (IF (has (NonNegativeInteger) (Finite)) (IF (has Expon (Finite)) (ATTRIBUTE (Finite)) noBranch) noBranch) (IF (has (NonNegativeInteger) (Monoid)) (IF (has Expon (Monoid)) (ATTRIBUTE (Monoid)) noBranch) noBranch) (IF (has (NonNegativeInteger) (AbelianMonoid)) (IF (has Expon (AbelianMonoid)) (ATTRIBUTE (AbelianMonoid)) noBranch) noBranch) (IF (has (NonNegativeInteger) (CancellationAbelianMonoid)) (IF (has Expon (CancellationAbelianMonoid)) (ATTRIBUTE (CancellationAbelianMonoid)) noBranch) noBranch) (IF (has (NonNegativeInteger) (Group)) (IF (has Expon (Group)) (ATTRIBUTE (Group)) noBranch) noBranch) (IF (has (NonNegativeInteger) (AbelianGroup)) (IF (has Expon (AbelianGroup)) (ATTRIBUTE (AbelianGroup)) noBranch) noBranch) (IF (has (NonNegativeInteger) (OrderedAbelianMonoidSup)) (IF (has Expon (OrderedAbelianMonoidSup)) (ATTRIBUTE (OrderedAbelianMonoidSup)) noBranch) noBranch) (IF (has (NonNegativeInteger) (OrderedSet)) (IF (has Expon (OrderedSet)) (ATTRIBUTE (OrderedSet)) noBranch) noBranch) (SIGNATURE makeprod ($ (NonNegativeInteger) Expon)) (SIGNATURE selectfirst ((NonNegativeInteger) $)) (SIGNATURE selectsecond (Expon $)))
      [2] idealSimplify: not known that (OrderedAbelianMonoid) is of mode (CATEGORY domain (IF (has (NonNegativeInteger) (Finite)) (IF (has Expon (Finite)) (ATTRIBUTE (Finite)) noBranch) noBranch) (IF (has (NonNegativeInteger) (Monoid)) (IF (has Expon (Monoid)) (ATTRIBUTE (Monoid)) noBranch) noBranch) (IF (has (NonNegativeInteger) (AbelianMonoid)) (IF (has Expon (AbelianMonoid)) (ATTRIBUTE (AbelianMonoid)) noBranch) noBranch) (IF (has (NonNegativeInteger) (CancellationAbelianMonoid)) (IF (has Expon (CancellationAbelianMonoid)) (ATTRIBUTE (CancellationAbelianMonoid)) noBranch) noBranch) (IF (has (NonNegativeInteger) (Group)) (IF (has Expon (Group)) (ATTRIBUTE (Group)) noBranch) noBranch) (IF (has (NonNegativeInteger) (AbelianGroup)) (IF (has Expon (AbelianGroup)) (ATTRIBUTE (AbelianGroup)) noBranch) noBranch) (IF (has (NonNegativeInteger) (OrderedAbelianMonoidSup)) (IF (has Expon (OrderedAbelianMonoidSup)) (ATTRIBUTE (OrderedAbelianMonoidSup)) noBranch) noBranch) (IF (has (NonNegativeInteger) (OrderedSet)) (IF (has Expon (OrderedSet)) (ATTRIBUTE (OrderedSet)) noBranch) noBranch) (SIGNATURE makeprod ($ (NonNegativeInteger) Expon)) (SIGNATURE selectfirst ((NonNegativeInteger) $)) (SIGNATURE selectsecond (Expon $)))
      [3] idealSimplify: not known that (OrderedAbelianMonoidSup) is of mode (CATEGORY domain (IF (has (NonNegativeInteger) (Finite)) (IF (has Expon (Finite)) (ATTRIBUTE (Finite)) noBranch) noBranch) (IF (has (NonNegativeInteger) (Monoid)) (IF (has Expon (Monoid)) (ATTRIBUTE (Monoid)) noBranch) noBranch) (IF (has (NonNegativeInteger) (AbelianMonoid)) (IF (has Expon (AbelianMonoid)) (ATTRIBUTE (AbelianMonoid)) noBranch) noBranch) (IF (has (NonNegativeInteger) (CancellationAbelianMonoid)) (IF (has Expon (CancellationAbelianMonoid)) (ATTRIBUTE (CancellationAbelianMonoid)) noBranch) noBranch) (IF (has (NonNegativeInteger) (Group)) (IF (has Expon (Group)) (ATTRIBUTE (Group)) noBranch) noBranch) (IF (has (NonNegativeInteger) (AbelianGroup)) (IF (has Expon (AbelianGroup)) (ATTRIBUTE (AbelianGroup)) noBranch) noBranch) (IF (has (NonNegativeInteger) (OrderedAbelianMonoidSup)) (IF (has Expon (OrderedAbelianMonoidSup)) (ATTRIBUTE (OrderedAbelianMonoidSup)) noBranch) noBranch) (IF (has (NonNegativeInteger) (OrderedSet)) (IF (has Expon (OrderedSet)) (ATTRIBUTE (OrderedSet)) noBranch) noBranch) (SIGNATURE makeprod ($ (NonNegativeInteger) Expon)) (SIGNATURE selectfirst ((NonNegativeInteger) $)) (SIGNATURE selectsecond (Expon $)))
      [4] idealSimplify: not known that (PolynomialCategory R (Product (NonNegativeInteger) Expon) Var) is of mode (CATEGORY domain (IF (has R (IntegralDomain)) (IF (has (Product (NonNegativeInteger) Expon) (CancellationAbelianMonoid)) (SIGNATURE fmecg ($ $ (Product (NonNegativeInteger) Expon) R $)) noBranch) noBranch) (IF (has R (ATTRIBUTE canonicalUnitNormal)) (ATTRIBUTE canonicalUnitNormal) noBranch))
      [5] idealSimplify:  gb has no value
 
=========================================================================
warnings 20397:

>compiling RADIX.spad to RADIX.nrlib
 
   Warnings: 
      [1] fractionPart: signature of lhs not unique: (Fraction (Integer))$ chosen
      [2] coerce:  le has no value
      [3] radixFrac:  c has no value
      [4] unknown Functor code (error Radix base must be at least 2)
 
=========================================================================
warnings 20396:

>compiling RCFIELD.spad to RCFIELD.nrlib
 
   Warnings: 
      [1] rootOf: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE sqrt (S (Integer))) (SIGNATURE sqrt (S (Fraction (Integer)))) (SIGNATURE sqrt (S S (NonNegativeInteger))) (SIGNATURE allRootsOf ((List S) (Polynomial (Integer)))) (SIGNATURE allRootsOf ((List S) (Polynomial (Fraction (Integer))))) (SIGNATURE allRootsOf ((List S) (Polynomial S))) (SIGNATURE allRootsOf ((List S) (SparseUnivariatePolynomial (Integer)))) (SIGNATURE allRootsOf ((List S) (SparseUnivariatePolynomial (Fraction (Integer))))) (SIGNATURE allRootsOf ((List S) (SparseUnivariatePolynomial S))) (SIGNATURE rootOf ((Union S failed) (SparseUnivariatePolynomial S) (PositiveInteger))) (SIGNATURE rootOf ((Union S failed) (SparseUnivariatePolynomial S) (PositiveInteger) (OutputForm))) (SIGNATURE ** (S S (Fraction (Integer)))) (SIGNATURE nthRoot (S S (Integer))) (SIGNATURE sqrt (S S)) (SIGNATURE ** (S S (Integer))) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE ** (S S (NonNegativeInteger))) (SIGNATURE ** (S S (PositiveInteger))))
      [2] allRootsOf:  z has no value
      [3] allRootsOf: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE sqrt (S (Integer))) (SIGNATURE sqrt (S (Fraction (Integer)))) (SIGNATURE sqrt (S S (NonNegativeInteger))) (SIGNATURE allRootsOf ((List S) (Polynomial (Integer)))) (SIGNATURE allRootsOf ((List S) (Polynomial (Fraction (Integer))))) (SIGNATURE allRootsOf ((List S) (Polynomial S))) (SIGNATURE allRootsOf ((List S) (SparseUnivariatePolynomial (Integer)))) (SIGNATURE allRootsOf ((List S) (SparseUnivariatePolynomial (Fraction (Integer))))) (SIGNATURE allRootsOf ((List S) (SparseUnivariatePolynomial S))) (SIGNATURE rootOf ((Union S failed) (SparseUnivariatePolynomial S) (PositiveInteger))) (SIGNATURE rootOf ((Union S failed) (SparseUnivariatePolynomial S) (PositiveInteger) (OutputForm))) (SIGNATURE ** (S S (Fraction (Integer)))) (SIGNATURE nthRoot (S S (Integer))) (SIGNATURE sqrt (S S)) (SIGNATURE ** (S S (Integer))) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE ** (S S (NonNegativeInteger))) (SIGNATURE ** (S S (PositiveInteger))))
 

=========================================================================
warnings 20395:

>compiling RDETR.spad to RDETR.nrlib
 
   Warnings: 
      [1] polyRDE:  eq has no value
      [2] SPDEnocancel1:  q has no value
      [3] SPDEnocancel2:  q has no value
 
=========================================================================
warnings 20394:

>compiling RDETRS.spad to RDETRS.nrlib
 
   Warnings: 
      [1] baseRDEsys:  z1 has no value
      [2] baseRDEsys:  z2 has no value
      [3] baseRDEsys:  z3 has no value
      [4] baseRDEsys:  z4 has no value
      [5] baseRDEsys:  z5 has no value
      [6] baseRDEsys:  z6 has no value
      [7] DSPDEsys:  z1 has no value
      [8] DSPDEsys:  z2 has no value
      [9] DSPDEsys:  z3 has no value
      [10] DSPDEsys:  z4 has no value
      [11] DSPDEsys:  z5 has no value
 
=========================================================================
warnings 20393:

>compiling REAL0.spad to REAL0.nrlib
 
   Warnings: 
      [1] makeSqfr: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE realZeros ((List (Record (: left (Fraction (Integer))) (: right (Fraction (Integer))))) Pol)) (SIGNATURE realZeros ((List (Record (: left (Fraction (Integer))) (: right (Fraction (Integer))))) Pol (Record (: left (Fraction (Integer))) (: right (Fraction (Integer)))))) (SIGNATURE realZeros ((List (Record (: left (Fraction (Integer))) (: right (Fraction (Integer))))) Pol (Fraction (Integer)))) (SIGNATURE realZeros ((List (Record (: left (Fraction (Integer))) (: right (Fraction (Integer))))) Pol (Record (: left (Fraction (Integer))) (: right (Fraction (Integer)))) (Fraction (Integer)))) (SIGNATURE refine ((Record (: left (Fraction (Integer))) (: right (Fraction (Integer)))) Pol (Record (: left (Fraction (Integer))) (: right (Fraction (Integer)))) (Fraction (Integer)))) (SIGNATURE refine ((Union (Record (: left (Fraction (Integer))) (: right (Fraction (Integer)))) failed) Pol (Record (: left (Fraction (Integer))) (: right (Fraction (Integer)))) (Record (: left (Fraction (Integer))) (: right (Fraction (Integer)))))) (SIGNATURE midpoint ((Fraction (Integer)) (Record (: left (Fraction (Integer))) (: right (Fraction (Integer)))))) (SIGNATURE midpoints ((List (Fraction (Integer))) (List (Record (: left (Fraction (Integer))) (: right (Fraction (Integer))))))))
      [2] Zero1:  G has no value
      [3] rootBound:  i has no value
      [4] transMultInv: :(NonNegativeInteger) -- should replace by pretend
      [5] var:  i has no value
 
=========================================================================
warnings 20392:

>compiling REALSOLV.spad to REALSOLV.nrlib
 
   Warnings: 
      [1] prn2rfi:  x has no value
 
=========================================================================
warnings 20391:

>compiling RESRING.spad to RESRING.nrlib
 
   Warnings: 
      [1] unknown Functor code (error the residue ring is the zero ring)

=========================================================================
warnings 20390:

>compiling RETSOL.spad to RETSOL.nrlib
 
   Warnings: 
      [1] PQ2P:  q1 has no value
      [2] PQIfCan: not known that (Ring) is of mode (CATEGORY package (SIGNATURE solveRetract ((List (List (Equation (Fraction (Polynomial R))))) (List (Polynomial R)) (List (Symbol)))))

=========================================================================
warnings 20389:

>compiling RF.spad to RF.nrlib
 
   Warnings: 
      [1] peval:  z1 has no value
      [2] peval:  z2 has no value
 
=========================================================================
warnings 20388:

>compiling RFFACTOR.spad to RFFACTOR.nrlib
 
   Warnings: 
      [1] factorFraction: not known that (PolynomialCategory (Fraction (Integer)) (IndexedExponents (Symbol)) (Symbol)) is of mode (CATEGORY domain (IF (has R (Algebra (Fraction (Integer)))) (SIGNATURE integrate ($ $ (Symbol))) noBranch))
 
=========================================================================
warnings 20387:

>compiling SHP.spad to SHP.nrlib
 
   Warnings: 
      [1] subresultantSequenceNext: :(List (UnivariatePolynomial x R)) -- should replace by @
      [2] subresultantSequenceInner: :(UnivariatePolynomial x R) -- should replace by @
      [3] subresultantSequenceInner: :(List (UnivariatePolynomial x R)) -- should replace by @
      [4] subresultantSequence: :(List (UnivariatePolynomial x R)) -- should replace by @
      [5] polsth1: :(List (UnivariatePolynomial x R)) -- should replace by @
      [6] polsth1:  Listf has no value
      [7] polsth2: :(List (UnivariatePolynomial x R)) -- should replace by @
      [8] polsth3: :(List (UnivariatePolynomial x R)) -- should replace by @
      [9] wfunctaux: :(List R) -- should replace by @
      [10] wfunctaux: :(NonNegativeInteger) -- should replace by @
      [11] wfunct: :(List R) -- should replace by @
      [12] SturmHabicht: :(UnivariatePolynomial x R) -- should replace by @
      [13] SturmHabichtMultiple: :(UnivariatePolynomial x R) -- should replace by @
      [14] SturmHabichtMultiple: not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE countRealRootsMultiple ((Integer) (UnivariatePolynomial x R))))
 
=========================================================================
warnings 20386:

>compiling SIGNRF.spad to SIGNRF.nrlib
 
   Warnings: 
      [1] psign: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE sign ((Union (Integer) failed) (Fraction (Polynomial R)))) (SIGNATURE sign ((Union (Integer) failed) (Fraction (Polynomial R)) (Symbol) (OrderedCompletion (Fraction (Polynomial R))))) (SIGNATURE sign ((Union (Integer) failed) (Fraction (Polynomial R)) (Symbol) (Fraction (Polynomial R)) (String))))

=========================================================================
warnings 20385:

>compiling SMITH.spad to SMITH.nrlib
 
   Warnings: 
      [1] elRow2:  x has no value
      [2] elColumn2:  x has no value
      [3] ijDivide:  x has no value
      [4] findEqMat:  x has no value

=========================================================================
warnings 20384:

>compiling SMP.spad to SMP.nrlib
 
   Warnings: 
      [1] moreThanOneVariable?:  x1 has no value
      [2] ^: pretend(NonNegativeInteger) -- should replace by @
      [3] **: pretend(NonNegativeInteger) -- should replace by @
      [4] exquo: The conditional modes (SparseUnivariatePolynomial $) and D conflict
      [5] map:  x1 has no value
      [6] evalSortedVarlist:  x1 has no value
      [7] eval:  x2 has no value
      [8] eval:  x1 has no value
      [9] eval:  IN has no value
      [10] eval:  val has no value
      [11] differentiate:  x1 has no value
 
=========================================================================
warnings 20382:

>compiling SOLVEFOR.spad to SOLVEFOR.nrlib
 
   Warnings: 
      [1] mapSolve:  x has no value
      [2] intsolve: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE solve ((List F) UP)) (SIGNATURE particularSolution (F UP)) (SIGNATURE mapSolve ((Record (: solns (List F)) (: maps (List (Record (: arg F) (: res F))))) UP (Mapping F F))) (SIGNATURE linear ((List F) UP)) (SIGNATURE quadratic ((List F) UP)) (SIGNATURE cubic ((List F) UP)) (SIGNATURE quartic ((List F) UP)) (SIGNATURE linear ((List F) F F)) (SIGNATURE quadratic ((List F) F F F)) (SIGNATURE cubic ((List F) F F F F)) (SIGNATURE quartic ((List F) F F F F F)) (SIGNATURE aLinear (F F F)) (SIGNATURE aQuadratic (F F F F)) (SIGNATURE aCubic (F F F F F)) (SIGNATURE aQuartic (F F F F F F)))
 
=========================================================================
warnings 20381:

>compiling SPLTREE.spad to SPLTREE.nrlib
 
   Warnings: 
      [1] splitNodeOf!:  la has no value
 
=========================================================================
warnings 20380:

>compiling STINPROD.spad to STINPROD.nrlib
 
   Warnings: 
      [1] applyOverQF:  z1 has no value
      [2] infiniteProduct:  z1 has no value
      [3] evenInfiniteProduct:  z1 has no value
      [4] oddInfiniteProduct:  z1 has no value
      [5] generalInfiniteProduct:  z1 has no value

=========================================================================
warnings 20379:

>compiling STTF.spad to STTF.nrlib
 
   Warnings: 
      [1] exp:  y has no value
      [2] sincos:  y has no value
      [3] tan:  y has no value
      [4] cot:  y has no value
      [5] sinhcosh:  y has no value
      [6] tanh:  y has no value

=========================================================================
warnings 20378:

>compiling SUBRESP.spad to SUBRESP.nrlib
 
   Warnings: 
      [1] primitivePart:  x1 has no value
 
=========================================================================
warnings 20377:

>compiling SUMRF.spad to SUMRF.nrlib
 
   Warnings: 
      [1] sum:  z has no value
 
=========================================================================
warnings 20376:

>compiling SUP.spad to SUP.nrlib

   Warnings: 
      [1] **: pretend(NonNegativeInteger) -- should replace by @
      [2] ^: pretend(NonNegativeInteger) -- should replace by @
      [3] **:  y has no value
      [4] pomopo!:  rout has no value
      [5] exquo: signature of lhs not unique: (Union $ failed)$$ chosen
      [6] fmecg:  rout has no value
      [7] pseudoRemainder: :(Integer) -- should replace by pretend
      [8] pseudoRemainder: :(NonNegativeInteger) -- should replace by pretend
      [9] elt: :(NonNegativeInteger) -- should replace by pretend
 
=========================================================================
warnings 20375:

>compiling SUPFRACF.spad to SUPFRACF.nrlib

   Warnings: 
      [1] squareFree: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE factor ((Factored (SparseUnivariatePolynomial (Fraction P))) (SparseUnivariatePolynomial (Fraction P)))) (SIGNATURE squareFree ((Factored (SparseUnivariatePolynomial (Fraction P))) (SparseUnivariatePolynomial (Fraction P)))))
 
=========================================================================
warnings 20374:

>compiling TEX.spad to TEX.nrlib
 
   Warnings: 
      [1] display: pretend(Integer) -- should replace by @
      [2] coerce: pretend(Integer) -- should replace by @
      [3] stringify: pretend(String) -- should replace by @
      [4] splitLong1:  l has no value
      [5] splitLong1:  ls has no value
      [6] splitLong1:  s has no value
      [7] formatSpecial:  form has no value
      [8] formatSpecial:  prescript has no value
      [9] formatPlex:  s has no value
      [10] formatTex: pretend(Boolean) -- should replace by @
 
=========================================================================
warnings 20373:

>compiling TEXTFILE.spad to TEXTFILE.nrlib
 
   Warnings: 
      [1] endOfFile?: pretend(Boolean) -- should replace by @

=========================================================================
warnings 20372:

>compiling TREE.spad to TREE.nrlib
 
   Warnings: 
      [1] children:  node has no value
      [2] setchildren!:  node has no value
      [3] setchildren!: pretend$ -- should replace by @
      [4] setvalue!:  node has no value
      [5] count: signature of lhs not unique: (NonNegativeInteger)S$ chosen
      [6] value:  node has no value
      [7] node?:  t has no value
      [8] multipleOverbar: The conditional modes (String) and S conflict

=========================================================================
warnings 20371:

>compiling TWOFACT.spad to TWOFACT.nrlib
 
   Warnings: 
      [1] pthRoot:  x has no value
      [2] generalSqFr: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE generalTwoFactor ((Factored (SparseUnivariatePolynomial (SparseUnivariatePolynomial F))) (SparseUnivariatePolynomial (SparseUnivariatePolynomial F)))) (SIGNATURE generalSqFr ((Factored (SparseUnivariatePolynomial (SparseUnivariatePolynomial F))) (SparseUnivariatePolynomial (SparseUnivariatePolynomial F)))) (SIGNATURE twoFactor ((Factored (SparseUnivariatePolynomial (SparseUnivariatePolynomial F))) (SparseUnivariatePolynomial (SparseUnivariatePolynomial F)) (Integer))))
      [3] generalSqFr:  flg has no value
      [4] generalSqFr:  xpnt has no value
      [5] generalSqFr: :(NonNegativeInteger) -- should replace by pretend
      [6] generalSqFr:  fctr has no value
      [7] generalTwoFactor:  flg has no value
      [8] generalTwoFactor:  fctr has no value
      [9] generalTwoFactor:  xpnt has no value
      [10] generalTwoFactor:  ll has no value
      [11] generalTwoFactor:  x has no value
      [12] generalTwoFactor:  unitPart has no value
      [13] twoFactor:  x has no value
      [14] twoFactor:  n has no value
      [15] twoFactor:  look has no value
      [16] twoFactor:  umv has no value
      [17] twoFactor:  umex has no value

=========================================================================
warnings 20370:

>compiling UNIFACT.spad to UNIFACT.nrlib
 
   Warnings: 
      [1] eisenstein: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE factor ((Factored ZP) ZP)) (SIGNATURE factorSquareFree ((Factored ZP) ZP)) (SIGNATURE henselFact ((Record (: contp (Integer)) (: factors (List (Record (: irr ZP) (: pow (Integer)))))) ZP (Boolean))))
      [2] negShiftp:  x has no value
      [3] bound: :(NonNegativeInteger) -- should replace by pretend
      [4] bound:  cbound has no value
      [5] numFactors: pretend(Integer) -- should replace by @
      [6] numFactors:  ans has no value
      [7] choose:  qSave has no value
      [8] choose:  ddSave has no value
      [9] quadratic:  beta has no value
      [10] quadratic:  alpha has no value
      [11] subMinusX: :ZP -- should replace by pretend
      [12] henselFact:  c has no value
      [13] henselFact:  factorlist has no value
      [14] henselFact: :(List ZP) -- should replace by pretend

=========================================================================
warnings 20369:

>compiling UPCDEN.spad to UPCDEN.nrlib
 
   Warnings: 
      [1] clearDenominator:  x has no value
      [2] splitDenominator:  x has no value

=========================================================================
warnings 20368:

>compiling UPDECOMP.spad to UPDECOMP.nrlib
 
   Warnings: 
      [1] leftFactorIfCan:  g has no value

=========================================================================
warnings 20367:

>compiling UPDIVP.spad to UPDIVP.nrlib
 
   Warnings: 
      [1] divideIfCan:  x has no value

=========================================================================
warnings 20366:

>compiling UPSQFREE.spad to UPSQFREE.nrlib
 
   Warnings: 
      [1] BumInSepFFE: :(NonNegativeInteger) -- should replace by @
      [2] squareFree:  lffe has no value
      [3] squareFree:  dunit has no value

=========================================================================
warnings 20365:

>compiling VIEWDEF.spad to VIEWDEF.nrlib
 
   Warnings: 
      [1] viewWriteDefault:  thingsToWrite has no value

=========================================================================
warnings 20364:

>compiling WEIER.spad to WEIER.nrlib
 
   Warnings: 
      [1] transback: :(Stream (Stream (Polynomial R))) -- should replace by pretend
      [2] transback: :(TaylorSeries R) -- should replace by pretend
      [3] transback: :(Stream (TaylorSeries R)) -- should replace by pretend
      [4] clikeUniv:  p has no value
      [5] clikeUniv: not known that (Ring) is of mode (CATEGORY package (SIGNATURE crest ((Mapping (Stream (Polynomial R)) (Stream (Polynomial R))) (NonNegativeInteger))) (SIGNATURE cfirst ((Mapping (Stream (Polynomial R)) (Stream (Polynomial R))) (NonNegativeInteger))) (SIGNATURE sts2stst ((Stream (Stream (Polynomial R))) (Symbol) (Stream (Polynomial R)))) (SIGNATURE clikeUniv ((Mapping (SparseUnivariatePolynomial (Polynomial R)) (Polynomial R)) (Symbol))) (SIGNATURE weierstrass ((List (TaylorSeries R)) (Symbol) (TaylorSeries R))) (SIGNATURE qqq ((Mapping (Stream (TaylorSeries R)) (Stream (TaylorSeries R))) (NonNegativeInteger) (TaylorSeries R) (Stream (TaylorSeries R)))))
      [6] streamlikeUniv: :(NonNegativeInteger) -- should replace by pretend
      [7] sts2stst:  x has no value
      [8] sts2stst:  y has no value
      [9] sts2stst: :(Stream (NonNegativeInteger)) -- should replace by pretend
      [10] weier: :(TaylorSeries R) -- should replace by pretend
      [11] cfirst:  s has no value
      [12] crest:  s has no value
      [13] qqq:  s has no value
      [14] wei: :(Stream (Polynomial R)) -- should replace by pretend
 
=========================================================================
warnings 20363:

>compiling WP.spad to WP.nrlib
 
   Warnings: 
      [1] innercoerce:  ans has no value
      [2] unknown Functor code (error incompatible length lists in WeightedPolynomial)

=========================================================================
warnings 20362:

>compiling DIAGG.spad to DIAGG.nrlib
 
   Warnings: 
      [1] select!:  x has no value

=========================================================================
warnings 20361:

>compiling DSMP.spad to DSMP.nrlib
 
   Warnings: 
      [1] retractIfCan:  x has no value
      [2] retractIfCan:  y has no value
      [3] coerce:  x has no value
      [4] coerce:  y has no value

=========================================================================
warnings 20360:

>compiling FACTRN.spad to FACTRN.nrlib
 
   Warnings: 
      [1] factor: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE factor ((Factored (SparseUnivariatePolynomial K)) (SparseUnivariatePolynomial K) K)) (SIGNATURE factorSqFree ((Factored (SparseUnivariatePolynomial K)) (SparseUnivariatePolynomial K) K)))
      [2] norm: not known that (Ring) is of mode (CATEGORY package (SIGNATURE factor ((Factored (SparseUnivariatePolynomial K)) (SparseUnivariatePolynomial K) K)) (SIGNATURE factorSqFree ((Factored (SparseUnivariatePolynomial K)) (SparseUnivariatePolynomial K) K)))
 
=========================================================================
warnings 20359:

>compiling FFFACTSE.spad to FFFACTSE.nrlib
 
   Warnings: 
      [1] exp:  Q has no value
      [2] internalFactorCZ:  result has no value
      [3] internalFactorCZ:  listOfFactors has no value
      [4] internalFactorSquareFree:  S has no value

=========================================================================
warnings 20358:

>compiling FRAMALG.spad to FRAMALG.nrlib
 
   Warnings: 
      [1] coordinates: signature of lhs not unique: (Matrix R)(Vector S) chosen
      [2] characteristicPolynomial:  y has no value

=========================================================================
warnings 20357:

>compiling INTFRSP.spad to INTFRSP.nrlib
 
   Warnings: 
      [1] sbSpcOfCurve: pretend(Integer) -- should replace by @

=========================================================================
warnings 20356:

>compiling LPARSPT.spad to LPARSPT.nrlib
 
   Warnings: 
      [1] valuationAndMore: pretend(Integer) -- should replace by @
      [2] localize: pretend(Integer) -- should replace by @
 
=========================================================================
warnings 20355:

>compiling NPOLYGON.spad to NPOLYGON.nrlib
 
   Warnings: 
      [1] slope: pretend(Integer) -- should replace by @
      [2] slope:  remainder has no value

=========================================================================
warnings 20354:

>compiling PLOT.spad to PLOT.nrlib
 
   Warnings: 
      [1] listBranches:  newl has no value
      [2] listBranches:  outList has no value
      [3] rangeRefine:  c has no value
      [4] rangeRefine:  q has no value
      [5] rangeRefine:  NUMFUNEVALS has no value
      [6] refine:  curves has no value
      [7] plot:  curves has no value
      [8] plot:  u1 has no value
      [9] plot:  z1 has no value
      [10] plot:  t has no value
      [11] plotPolar:  u1 has no value
      [12] plotPolar:  v1 has no value
      [13] coerce:  l has no value
 
=========================================================================
warnings 20353:

>compiling RFP.spad to RFP.nrlib
 
   Warnings: 
      [1] distinguishedRootsOf: not known that (Ring) is of mode (CATEGORY package (SIGNATURE distinguishedRootsOf ((Record (: zeros (List K)) (: extDegree (Integer))) (SparseUnivariatePolynomial K) K)) (SIGNATURE distinguishedCommonRootsOf ((Record (: zeros (List K)) (: extDegree (Integer))) (List (SparseUnivariatePolynomial K)) K)) (SIGNATURE foundZeroes ((List K))) (SIGNATURE setFoundZeroes ((List K) (List K))))
      [2] distinguishedRootsOf: pretend(List (Integer)) -- should replace by @
      [3] distinguishedRootsOf: not known that (UnivariatePolynomialCategory (Fraction (Integer))) is of mode (CATEGORY domain (SIGNATURE outputForm ((OutputForm) $ (OutputForm))) (SIGNATURE fmecg ($ $ (NonNegativeInteger) K $)))


=========================================================================
warnings 20352:

>compiling ROIRC.spad to ROIRC.nrlib
 
   Warnings: 
      [1] invert:  z has no value
 
=========================================================================
warnings 20351:

>compiling SMATCAT.spad to SMATCAT.nrlib
 
   Warnings: 
      [1] equation2R: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE ** (S S (Integer))) (SIGNATURE diagonalProduct (R S)) (SIGNATURE trace (R S)) (SIGNATURE diagonal (Row S)) (SIGNATURE reducedSystem ((Matrix R) (Matrix S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix R)) (: vec (Vector R))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix S))) (SIGNATURE retract (R S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE coerce (S R)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Integer) S)) (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE differentiate (S S (Mapping R R) (NonNegativeInteger))) (SIGNATURE differentiate (S S (Mapping R R))) (SIGNATURE coerce (S (Integer))) (SIGNATURE ** (S S (NonNegativeInteger))) (SIGNATURE ** (S S (PositiveInteger))) (SIGNATURE coerce ((OutputForm) S)))

=========================================================================
warnings 20350:

>compiling AFALGGRO.spad to AFALGGRO.nrlib
 
   Warnings: 
      [1] affineAlgSetLocal:  listPtsIdl has no value

=========================================================================
warnings 20349:

>compiling AFALGRES.spad to AFALGRES.nrlib
 
   Warnings: 
      [1] affineAlgSetLocal:  listPtsIdl has no value

=========================================================================
warnings 20348:

>compiling FFINTBAS.spad to FFINTBAS.nrlib
 
   Warnings: 
      [1] squaredFactors: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE integralBasis ((Record (: basis (Matrix R)) (: basisDen R) (: basisInv (Matrix R))))) (SIGNATURE localIntegralBasis ((Record (: basis (Matrix R)) (: basisDen R) (: basisInv (Matrix R))) R)))
 
=========================================================================
warnings 20347:

>compiling FRIDEAL.spad to FRIDEAL.nrlib
 
   Warnings: 
      [1] upmat:  s has no value
      [2] ret?:  s has no value
      [3] inv:  s has no value
 
=========================================================================
warnings 20346:

>compiling FRIDEAL2.spad to FRIDEAL2.nrlib
 
   Warnings: 
      [1] map:  s has no value

=========================================================================
warnings 20345:

>compiling FRMOD.spad to FRMOD.nrlib
 
   Warnings: 
      [1] vectProd: pretend(Vector A) -- should replace by @

=========================================================================
warnings 20344:

>compiling INTFACT.spad to INTFACT.nrlib
 
   Warnings: 
      [1] PollardSmallFactor:  G has no value

=========================================================================
warnings 20343:

>compiling MONOGEN.spad to MONOGEN.nrlib
 
   Warnings: 
      [1] derivationCoordinates:  x has no value

=========================================================================
warnings 20342:

>compiling NFINTBAS.spad to NFINTBAS.nrlib
 
   Warnings: 
      [1] wildPrimes:  ans has no value
      [2] tameProduct:  ans has no value
      [3] integralBasis:  runningRbden has no value
      [4] iWildLocalIntegralBasis:  rbden has no value
 
=========================================================================
warnings 20341:

>compiling CCLASS.spad to CCLASS.nrlib
 
   Warnings: 
      [1] remove!: signature of lhs not unique: $(Character)$ chosen

=========================================================================
warnings 20340:

>compiling CPIMA.spad to CPIMA.nrlib
 
   Warnings: 
      [1] XtoY:  x has no value
 
=========================================================================
warnings 20339:

>compiling GALFACT.spad to GALFACT.nrlib
 
   Warnings: 
      [1] eisensteinIrreducible?: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE makeFR ((Factored UP) (Record (: contp (Integer)) (: factors (List (Record (: irr UP) (: pow (Integer)))))))) (SIGNATURE degreePartition ((Multiset (NonNegativeInteger)) (List (Record (: factor UP) (: degree (Integer)))))) (SIGNATURE musserTrials ((PositiveInteger))) (SIGNATURE musserTrials ((PositiveInteger) (PositiveInteger))) (SIGNATURE stopMusserTrials ((PositiveInteger))) (SIGNATURE stopMusserTrials ((PositiveInteger) (PositiveInteger))) (SIGNATURE numberOfFactors ((NonNegativeInteger) (List (Record (: factor UP) (: degree (Integer)))))) (SIGNATURE modularFactor ((Record (: prime (Integer)) (: factors (List UP))) UP)) (SIGNATURE useSingleFactorBound? ((Boolean))) (SIGNATURE useSingleFactorBound ((Boolean) (Boolean))) (SIGNATURE useEisensteinCriterion? ((Boolean))) (SIGNATURE useEisensteinCriterion ((Boolean) (Boolean))) (SIGNATURE eisensteinIrreducible? ((Boolean) UP)) (SIGNATURE tryFunctionalDecomposition? ((Boolean))) (SIGNATURE tryFunctionalDecomposition ((Boolean) (Boolean))) (SIGNATURE factor ((Factored UP) UP)) (SIGNATURE factor ((Factored UP) UP (NonNegativeInteger))) (SIGNATURE factor ((Factored UP) UP (List (NonNegativeInteger)))) (SIGNATURE factor ((Factored UP) UP (List (NonNegativeInteger)) (NonNegativeInteger))) (SIGNATURE factor ((Factored UP) UP (NonNegativeInteger) (NonNegativeInteger))) (SIGNATURE factorSquareFree ((Factored UP) UP)) (SIGNATURE factorSquareFree ((Factored UP) UP (NonNegativeInteger))) (SIGNATURE factorSquareFree ((Factored UP) UP (List (NonNegativeInteger)))) (SIGNATURE factorSquareFree ((Factored UP) UP (List (NonNegativeInteger)) (NonNegativeInteger))) (SIGNATURE factorSquareFree ((Factored UP) UP (NonNegativeInteger) (NonNegativeInteger))) (SIGNATURE factorOfDegree ((Union UP failed) (PositiveInteger) UP)) (SIGNATURE factorOfDegree ((Union UP failed) (PositiveInteger) UP (NonNegativeInteger))) (SIGNATURE factorOfDegree ((Union UP failed) (PositiveInteger) UP (List (NonNegativeInteger)))) (SIGNATURE factorOfDegree ((Union UP failed) (PositiveInteger) UP (List (NonNegativeInteger)) (NonNegativeInteger))) (SIGNATURE factorOfDegree ((Union UP failed) (PositiveInteger) UP (List (NonNegativeInteger)) (NonNegativeInteger) (Boolean))) (SIGNATURE henselFact ((Record (: contp (Integer)) (: factors (List (Record (: irr UP) (: pow (Integer)))))) UP (Boolean))) (SIGNATURE btwFact ((Record (: contp (Integer)) (: factors (List (Record (: irr UP) (: pow (Integer)))))) UP (Boolean) (Set (NonNegativeInteger)) (NonNegativeInteger))))
      [2] modularFactor:  s has no value
      [3] completeFactor:  g0 has no value
      [4] completeFactor:  degg has no value
      [5] completeFactor:  g has no value
      [6] completeFactor:  x has no value
      [7] completeFactor:  ltrue has no value
      [8] completeFactor:  level has no value
      [9] divideSet:  l has no value
      [10] btwFactor:  reverse? has no value
      [11] btwFactor:  negativelc? has no value
      [12] btwFactor:  x has no value
      [13] btwFactor:  lf has no value
      [14] henselFact:  c has no value
      [15] henselFact:  factorlist has no value
      [16] henselFact:  z has no value
      [17] btwFact:  x has no value
      [18] btwFact:  c has no value
      [19] btwFact:  factorlist has no value
      [20] btwFact:  z has no value
 
=========================================================================
warnings 20338:

>compiling IALGFACT.spad to IALGFACT.nrlib
 
   Warnings: 
      [1] factor: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE factor ((Factored AlPol) AlPol (Mapping (Factored UP) UP))))
      [2]  x has no value
 

=========================================================================
warnings 20337:

>compiling IBACHIN.spad to IBACHIN.nrlib
 
   Warnings: 
      [1] applyFrobToMatrix:  k1 has no value
      [2] listConjugateBases:  k1 has no value
      [3] approximateExtendedEuclidean:  r1 has no value
      [4] approximateExtendedEuclidean:  z1 has no value
 
=========================================================================
warnings 20336:

>compiling MMLFORM.spad to MMLFORM.nrlib
 
   Warnings: 
      [1] exprex:  s has no value
      [2] formatSub:  j has no value
      [3] formatSub:  s has no value
      [4] formatSub1:  s has no value
      [5] formatPlex:  checkarg has no value
      [6] formatPlex:  s has no value
      [7] formatNaryNoGroup:  checkargs has no value
 
=========================================================================
warnings 20335:

>compiling NORMMA.spad to NORMMA.nrlib
 
   Warnings: 
      [1] PolR2SUP:  x has no value
 
=========================================================================
warnings 20334:

>compiling ODERED.spad to ODERED.nrlib
 
   Warnings: 
      [1] matF2L:  f1 has no value
      [2] reduceLODE:  f1 has no value

=========================================================================
warnings 20333:

>compiling PERM.spad to PERM.nrlib
 
   Warnings: 
      [1] rotateCycle:  minpos has no value
      [2] coerceToCycle:  nextCycle has no value
      [3] coercePreimagesImages:  preImage has no value
      [4] coercePreimagesImages:  image has no value

=========================================================================
warnings 20332:

>compiling PERMGRP.spad to PERMGRP.nrlib
 
   Warnings: 
      [1] shortenWord:  newlw has no value
      [2] orbitInternal:  pos has no value
      [3] orbitInternal:  orbitList has no value
      [4] bsgs1:  j has no value
      [5] bsgs1:  out has no value
      [6] bsgs1:  outword has no value
      [7] bsgs1:  baseOfGroup has no value
      [8] reduceGenerators:  wordlist has no value
      [9] bsgs:  gpbase has no value
      [10] bsgs:  baseOfGroup has no value
      [11] bsgs:  wordProblem has no value
      [12] bsgs:  wordlist has no value
      [13] bsgs:  gporb has no value
      [14] bsgs:  noresult has no value
      [15] bsgs:  newBasePoint has no value
      [16] bsgs:  basePoint has no value
      [17] memberInternal:  supp has no value
      [18] memberInternal:  sgs has no value
      [19] memberInternal:  baseOfGroup has no value
      [20] memberInternal:  gporb has no value
      [21] coerce: :(Symbol) -- should replace by pretend
 
=========================================================================
warnings 20331:

>compiling PRIMES.spad to PRIMES.nrlib
 
   Warnings: 
      [1] rabinProvesComposite:  rootsMinus1 has no value
 
=========================================================================
warnings 20330:

>compiling PRJALGPK.spad to PRJALGPK.nrlib
 
   Warnings: 
      [1] singularPoints:  listPtsIdl2 has no value
      [2] algebraicSet:  listPtsIdl2 has no value
      [3] rationalPoints:  listPtsIdl has no value

=========================================================================
warnings 20329:

>compiling PWFFINTB.spad to PWFFINTB.nrlib
 
   Warnings: 
      [1] reducedDiscriminant:  r1 has no value
      [2] compLocalBasisOverExt:  k1 has no value
      [3] listSquaredFactors:  ans has no value
 
=========================================================================
warnings 20328:

>compiling SAE.spad to SAE.nrlib
 
   Warnings: 
      [1] lift: pretendRep -- should replace by @
      [2] coordinates:  y has no value
      [3] index:  ans has no value
      [4] unknown Functor code (error Modulus cannot be made monic)
 
=========================================================================
warnings 20327:

>compiling SGCF.spad to SGCF.nrlib
 
   Warnings: 
      [1] unrankImproperPartitions0:  l has no value
      [2] unrankImproperPartitions1:  nonZeros has no value
      [3] subSet:  l has no value
      [4] nextLatticePermutation:  ready has no value
      [5] listYoungTableaus:  lattice has no value

=========================================================================
warnings 20326:

>compiling SPACE3.spad to SPACE3.nrlib
 
   Warnings: 
      [1] coerce:  llliPt has no value
 
=========================================================================
warnings 200325:

>compiling TBAGG.spad to TBAGG.nrlib
 
   Warnings: 
      [1] map!: signature of lhs not unique: S(Mapping Entry Entry)S chosen
 
=========================================================================
warnings 20324:

>compiling VIEW3D.spad to VIEW3D.nrlib
 
   Warnings: 
      [1] viewpoint:  Theta has no value
 
=========================================================================
warnings 20323:

>compiling WFFINTBS.spad to WFFINTBS.nrlib
 
   Warnings: 
      [1] listSquaredFactors:  ans has no value
      [2] iLocalIntegralBasis:  rbden has no value
      [3] integralBasis:  runningRbden has no value

=========================================================================
warnings 20322:

>compiling ALIST.spad to ALIST.nrlib
 
   Warnings: 
      [1] latex:  s has no value
      [2] remove!:  key has no value

=========================================================================
warnings 20321:

>compiling HASHTBL.spad to HASHTBL.nrlib
 
   Warnings: 
      [1] remove!: pretendEntry -- should replace by @
      [2] search: pretendEntry -- should replace by @

=========================================================================
warnings 20320:

>compiling INTPACK.spad to INTPACK.nrlib
 
   Warnings: 
      [1] integrateConstantList:  x has no value
      [2] integrateConstantList:  y has no value
      [3] preAnalysis:  nia has no value
      [4] measureSpecific:  nia has no value
      [5] measureSpecific:  mdnia has no value
      [6] integrateSpecific:  nia has no value
      [7] integrateSpecific:  mdnia has no value
      [8] recoverAfterFail:  nia has no value
      [9] integrateArgs:  mdnia has no value
      [10] integrateArgs:  nia has no value

=========================================================================
warnings 20319:

>compiling IPF.spad to IPF.nrlib
 
   Warnings: 
      [1] tableForDiscreteLogarithm: pretend(Table (PositiveInteger) (NonNegativeInteger)) -- should replace by @
      [2] initializeLog:  n has no value
      [3] coordinates: signature of lhs not unique: (Vector $)$ chosen
      [4] charthRoot: signature of lhs not unique: $$ chosen
 
=========================================================================
warnings 20318:

>compiling ACF.spad to ACF.nrlib
 
   Warnings: 
      [1] zeroOf: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE zerosOf ((List S) (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE zerosOf ((List S) (SparseUnivariatePolynomial S))) (SIGNATURE zerosOf ((List S) (Polynomial S))) (SIGNATURE zeroOf (S (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE zeroOf (S (SparseUnivariatePolynomial S))) (SIGNATURE zeroOf (S (Polynomial S))) (SIGNATURE rootsOf ((List S) (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE rootsOf ((List S) (SparseUnivariatePolynomial S))) (SIGNATURE rootsOf ((List S) (Polynomial S))) (SIGNATURE rootOf (S (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE rootOf (S (SparseUnivariatePolynomial S))) (SIGNATURE rootOf (S (Polynomial S))))

=========================================================================
warnings 20317:

>compiling ACPLOT.spad to ACPLOT.nrlib
 
   Warnings: 
      [1] listPtsOnHorizBdry:  pointList has no value
      [2] listPtsOnVertBdry:  pointList has no value
      [3] listPtsInRect:  pointList has no value
      [4] newX:  x has no value
      [5] newY:  x has no value
      [6] makeOneVarSketch:  sketchRoots has no value
      [7] makeOneVarSketch:  lf has no value
      [8] makeOneVarSketch:  rt has no value
      [9] makeOneVarSketch:  bt has no value
      [10] makeOneVarSketch:  tp has no value
      [11] makeLineSketch:  branch has no value
      [12] makeLineSketch:  lf has no value
      [13] makeLineSketch:  rt has no value
      [14] makeLineSketch:  bt has no value
      [15] makeLineSketch:  tp has no value
      [16] makeRatFcnSketch:  s has no value
      [17] makeRatFcnSketch:  outList has no value
      [18] makeRatFcnSketch:  lf has no value
      [19] makeRatFcnSketch:  rt has no value
      [20] makeRatFcnSketch:  bt has no value
      [21] makeRatFcnSketch:  tp has no value
      [22] makeRatFcnSketch:  topList has no value
      [23] makeRatFcnSketch:  botList has no value
      [24] makeGeneralSketch:  s has no value
      [25] listPtsOnLoop:  pointList has no value
      [26] computeNextPt:  xPointList has no value
      [27] computeNextPt:  yPointList has no value

=========================================================================
warnings 20316:

>compiling ANTISYM.spad to ANTISYM.nrlib
 
   Warnings: 
      [1] retractable?:  k has no value
      [2] retractIfCan:  k has no value
      [3] *:  k has no value
      [4] *:  c has no value
      [5] *:  z has no value
      [6] coerce:  c has no value
      [7] coerce:  k has no value

=========================================================================
warnings 20315:

>compiling ASP12.spad to ASP12.nrlib
 
   Warnings: 
      [1]  MAXIT has no value
      [2]  IFLAG has no value
      [3]  ELAM has no value
      [4]  FINFO has no value

=========================================================================
warnings 20314:

>compiling ASP27.spad to ASP27.nrlib
 
   Warnings: 
      [1]  IFLAG has no value
      [2]  N has no value
      [3]  LRWORK has no value
      [4]  LIWORK has no value
      [5]  Z has no value
      [6]  W has no value
      [7]  RWORK has no value
      [8]  IWORK has no value
 
=========================================================================
warnings 20313:

>compiling ASP28.spad to ASP28.nrlib
 
   Warnings: 
      [1]  IFLAG has no value
      [2]  N has no value
      [3]  LRWORK has no value
      [4]  LIWORK has no value
      [5]  Z has no value
      [6]  W has no value
      [7]  RWORK has no value
      [8]  IWORK has no value

=========================================================================
warnings 20312:

>compiling ASP30.spad to ASP30.nrlib
 
   Warnings: 
      [1]  MODE has no value
      [2]  M has no value
      [3]  N has no value
      [4]  LRWORK has no value
      [5]  LIWORK has no value
      [6]  X has no value
      [7]  Y has no value
      [8]  RWORK has no value
      [9]  IWORK has no value
      [10]  IFAIL has no value
      [11] coerce:  A has no value

=========================================================================
warnings 20311:

>compiling ASP33.spad to ASP33.nrlib
 
   Warnings: 
      [1]  JINT has no value
      [2]  X has no value
      [3]  V has no value

=========================================================================
warnings 20310:

>compiling ASP49.spad to ASP49.nrlib
 
   Warnings: 
      [1]  MODE has no value
      [2]  N has no value
      [3]  X has no value
      [4]  OBJF has no value
      [5]  OBJGRD has no value
      [6]  NSTATE has no value
      [7]  IUSER has no value
      [8]  USER has no value
 
=========================================================================
warnings 20309:

>compiling ASP55.spad to ASP55.nrlib
 
   Warnings: 
      [1]  MODE has no value
      [2]  NCNLN has no value
      [3]  N has no value
      [4]  NROWJ has no value
      [5]  NEEDC has no value
      [6]  X has no value
      [7]  C has no value
      [8]  CJAC has no value
      [9]  NSTATE has no value
      [10]  IUSER has no value
      [11]  USER has no value
      [12] makeCond:  NEEDC has no value
 

=========================================================================
warnings 20308:

>compiling ASP7.spad to ASP7.nrlib
 
   Warnings: 
      [1]  X has no value
      [2]  Y has no value
      [3]  F has no value
      [4] coerce:  F has no value
 

=========================================================================
warnings 20307:

>compiling ASP78.spad to ASP78.nrlib
 
   Warnings: 
      [1]  X has no value
      [2]  G has no value
      [3] coerce:  G has no value

=========================================================================
warnings 20306:

>compiling ASP8.spad to ASP8.nrlib
 
   Warnings: 
      [1]  COUNT has no value
      [2]  XSOL has no value
      [3]  N has no value
      [4]  Y has no value
      [5]  FORWRD has no value
      [6]  RESULT has no value
      [7]  M has no value
      [8] coerce:  POINTS has no value
      [9] coerce:  X02ALF has no value
      [10] coerce:  RESULT has no value
      [11] coerce:  COUNT has no value
      [12] coerce:  XSOL has no value

=========================================================================
warnings 20305:

>compiling ASP9.spad to ASP9.nrlib
 
   Warnings: 
      [1]  X has no value
      [2]  Y has no value
      [3] coerce:  CHDUM1 has no value
      [4] coerce:  CD02EJ has no value
      [5] coerce:  AD02CJ has no value
      [6] coerce:  GOPT1 has no value
      [7] coerce:  GOPT2 has no value
 
=========================================================================
warnings 20304:

>compiling BLUPPACK.spad to BLUPPACK.nrlib
 
   Warnings: 
      [1] stepBlowUp: not known that (FiniteAbelianMonoidRing K (DirectProduct (call LENGTH (LIST (QUOTE X) (QUOTE Y))) (NonNegativeInteger))) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [2] stepBlowUp:  listRec has no value
      [3] blowExp: pretend(Integer) -- should replace by @

=========================================================================
warnings 20303:

>compiling BOP.spad to BOP.nrlib
 
   Warnings: 
      [1] display:  x1 has no value

=========================================================================
warnings 20302:

>compiling BOP1.spad to BOP1.nrlib
 
   Warnings: 
      [1] evaluate:  ll has no value
      [2] derivative:  ll has no value
      [3] constOp:  ll has no value
      [4] constantOperator:  ll has no value
 
=========================================================================
warnings 20301:

>compiling COMPCAT.spad to COMPCAT.nrlib

   Warnings: 
      [1] solveLinearPolynomialEquation: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE coerce (S S)) (SIGNATURE exquo ((Union S failed) S S)) (SIGNATURE unitNormal ((Record (: unit S) (: canonical S) (: associate S)) S)) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE euclideanSize ((NonNegativeInteger) S)) (SIGNATURE divide ((Record (: quotient S) (: remainder S)) S S)) (SIGNATURE quo (S S S)) (SIGNATURE rem (S S S)) (SIGNATURE inv (S S)) (SIGNATURE ** (S S (Integer))) (SIGNATURE * (S S (Fraction (Integer)))) (SIGNATURE * (S (Fraction (Integer)) S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE < ((Boolean) S S)) (SIGNATURE convert ((InputForm) S)) (SIGNATURE convert ((Complex (DoubleFloat)) S)) (SIGNATURE convert ((Complex (Float)) S)) (SIGNATURE tan (S S)) (SIGNATURE sin (S S)) (SIGNATURE cos (S S)) (SIGNATURE acos (S S)) (SIGNATURE asin (S S)) (SIGNATURE atan (S S)) (SIGNATURE cosh (S S)) (SIGNATURE sinh (S S)) (SIGNATURE tanh (S S)) (SIGNATURE acosh (S S)) (SIGNATURE asinh (S S)) (SIGNATURE atanh (S S)) (SIGNATURE log (S S)) (SIGNATURE exp (S S)) (SIGNATURE ** (S S S)) (SIGNATURE pi (S)) (SIGNATURE ** (S S (Fraction (Integer)))) (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE rationalIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE rational ((Fraction (Integer)) S)) (SIGNATURE rational? ((Boolean) S)) (SIGNATURE polarCoordinates ((Record (: r R) (: phi R)) S)) (SIGNATURE argument (R S)) (SIGNATURE abs (S S)) (SIGNATURE exquo ((Union S failed) S R)) (SIGNATURE conjugate (S S)) (SIGNATURE imaginary (S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE patternMatch ((PatternMatchResult (Float) S) S (Pattern (Float)) (PatternMatchResult (Float) S))) (SIGNATURE patternMatch ((PatternMatchResult (Integer) S) S (Pattern (Integer)) (PatternMatchResult (Integer) S))) (SIGNATURE map (S (Mapping R R) S)) (SIGNATURE differentiate (S S (Mapping R R))) (SIGNATURE differentiate (S S (Mapping R R) (NonNegativeInteger))) (SIGNATURE reduce ((Union S failed) (Fraction (SparseUnivariatePolynomial R)))) (SIGNATURE lift ((SparseUnivariatePolynomial R) S)) (SIGNATURE convert (S (SparseUnivariatePolynomial R))) (SIGNATURE reduce (S (SparseUnivariatePolynomial R))) (SIGNATURE definingPolynomial ((SparseUnivariatePolynomial R))) (SIGNATURE reducedSystem ((Matrix R) (Matrix S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix R)) (: vec (Vector R))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix S))) (SIGNATURE retract (R S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Integer) S)) (SIGNATURE convert ((SparseUnivariatePolynomial R) S)) (SIGNATURE discriminant (R)) (SIGNATURE convert (S (Vector R))) (SIGNATURE convert ((Vector R) S)) (SIGNATURE coordinates ((Matrix R) (Vector S))) (SIGNATURE coordinates ((Vector R) S)) (SIGNATURE minimalPolynomial ((SparseUnivariatePolynomial R) S)) (SIGNATURE characteristicPolynomial ((SparseUnivariatePolynomial R) S)) (SIGNATURE discriminant (R (Vector S))) (SIGNATURE coordinates ((Matrix R) (Vector S) (Vector S))) (SIGNATURE coordinates ((Vector R) S (Vector S))) (SIGNATURE norm (R S)) (SIGNATURE trace (R S)) (SIGNATURE rank ((PositiveInteger))) (SIGNATURE coerce (S R)) (SIGNATURE * (S R S)) (SIGNATURE * (S S R)) (SIGNATURE coerce (S (Integer))) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE ** (S S (NonNegativeInteger))) (SIGNATURE recip ((Union S failed) S)) (SIGNATURE * (S S S)) (SIGNATURE ** (S S (PositiveInteger))) (SIGNATURE * (S (Integer) S)) (SIGNATURE - (S S S)) (SIGNATURE - (S S)) (SIGNATURE * (S (NonNegativeInteger) S)) (SIGNATURE * (S (PositiveInteger) S)) (SIGNATURE + (S S S)) (SIGNATURE coerce ((OutputForm) S)) (SIGNATURE = ((Boolean) S S)))
      [2] normPolynomial:  z has no value
      [3] factorPolynomial: not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE coerce (S S)) (SIGNATURE exquo ((Union S failed) S S)) (SIGNATURE unitNormal ((Record (: unit S) (: canonical S) (: associate S)) S)) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE euclideanSize ((NonNegativeInteger) S)) (SIGNATURE divide ((Record (: quotient S) (: remainder S)) S S)) (SIGNATURE quo (S S S)) (SIGNATURE rem (S S S)) (SIGNATURE inv (S S)) (SIGNATURE ** (S S (Integer))) (SIGNATURE * (S S (Fraction (Integer)))) (SIGNATURE * (S (Fraction (Integer)) S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE < ((Boolean) S S)) (SIGNATURE convert ((InputForm) S)) (SIGNATURE convert ((Complex (DoubleFloat)) S)) (SIGNATURE convert ((Complex (Float)) S)) (SIGNATURE tan (S S)) (SIGNATURE sin (S S)) (SIGNATURE cos (S S)) (SIGNATURE acos (S S)) (SIGNATURE asin (S S)) (SIGNATURE atan (S S)) (SIGNATURE cosh (S S)) (SIGNATURE sinh (S S)) (SIGNATURE tanh (S S)) (SIGNATURE acosh (S S)) (SIGNATURE asinh (S S)) (SIGNATURE atanh (S S)) (SIGNATURE log (S S)) (SIGNATURE exp (S S)) (SIGNATURE ** (S S S)) (SIGNATURE pi (S)) (SIGNATURE ** (S S (Fraction (Integer)))) (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE rationalIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE rational ((Fraction (Integer)) S)) (SIGNATURE rational? ((Boolean) S)) (SIGNATURE polarCoordinates ((Record (: r R) (: phi R)) S)) (SIGNATURE argument (R S)) (SIGNATURE abs (S S)) (SIGNATURE exquo ((Union S failed) S R)) (SIGNATURE conjugate (S S)) (SIGNATURE imaginary (S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE patternMatch ((PatternMatchResult (Float) S) S (Pattern (Float)) (PatternMatchResult (Float) S))) (SIGNATURE patternMatch ((PatternMatchResult (Integer) S) S (Pattern (Integer)) (PatternMatchResult (Integer) S))) (SIGNATURE map (S (Mapping R R) S)) (SIGNATURE differentiate (S S (Mapping R R))) (SIGNATURE differentiate (S S (Mapping R R) (NonNegativeInteger))) (SIGNATURE reduce ((Union S failed) (Fraction (SparseUnivariatePolynomial R)))) (SIGNATURE lift ((SparseUnivariatePolynomial R) S)) (SIGNATURE convert (S (SparseUnivariatePolynomial R))) (SIGNATURE reduce (S (SparseUnivariatePolynomial R))) (SIGNATURE definingPolynomial ((SparseUnivariatePolynomial R))) (SIGNATURE reducedSystem ((Matrix R) (Matrix S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix R)) (: vec (Vector R))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix S))) (SIGNATURE retract (R S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Integer) S)) (SIGNATURE convert ((SparseUnivariatePolynomial R) S)) (SIGNATURE discriminant (R)) (SIGNATURE convert (S (Vector R))) (SIGNATURE convert ((Vector R) S)) (SIGNATURE coordinates ((Matrix R) (Vector S))) (SIGNATURE coordinates ((Vector R) S)) (SIGNATURE minimalPolynomial ((SparseUnivariatePolynomial R) S)) (SIGNATURE characteristicPolynomial ((SparseUnivariatePolynomial R) S)) (SIGNATURE discriminant (R (Vector S))) (SIGNATURE coordinates ((Matrix R) (Vector S) (Vector S))) (SIGNATURE coordinates ((Vector R) S (Vector S))) (SIGNATURE norm (R S)) (SIGNATURE trace (R S)) (SIGNATURE rank ((PositiveInteger))) (SIGNATURE coerce (S R)) (SIGNATURE * (S R S)) (SIGNATURE * (S S R)) (SIGNATURE coerce (S (Integer))) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE ** (S S (NonNegativeInteger))) (SIGNATURE recip ((Union S failed) S)) (SIGNATURE * (S S S)) (SIGNATURE ** (S S (PositiveInteger))) (SIGNATURE * (S (Integer) S)) (SIGNATURE - (S S S)) (SIGNATURE - (S S)) (SIGNATURE * (S (NonNegativeInteger) S)) (SIGNATURE * (S (PositiveInteger) S)) (SIGNATURE + (S S S)) (SIGNATURE coerce ((OutputForm) S)) (SIGNATURE = ((Boolean) S S)))
      [4] factorPolynomial: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE coerce (S S)) (SIGNATURE exquo ((Union S failed) S S)) (SIGNATURE unitNormal ((Record (: unit S) (: canonical S) (: associate S)) S)) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE euclideanSize ((NonNegativeInteger) S)) (SIGNATURE divide ((Record (: quotient S) (: remainder S)) S S)) (SIGNATURE quo (S S S)) (SIGNATURE rem (S S S)) (SIGNATURE inv (S S)) (SIGNATURE ** (S S (Integer))) (SIGNATURE * (S S (Fraction (Integer)))) (SIGNATURE * (S (Fraction (Integer)) S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE < ((Boolean) S S)) (SIGNATURE convert ((InputForm) S)) (SIGNATURE convert ((Complex (DoubleFloat)) S)) (SIGNATURE convert ((Complex (Float)) S)) (SIGNATURE tan (S S)) (SIGNATURE sin (S S)) (SIGNATURE cos (S S)) (SIGNATURE acos (S S)) (SIGNATURE asin (S S)) (SIGNATURE atan (S S)) (SIGNATURE cosh (S S)) (SIGNATURE sinh (S S)) (SIGNATURE tanh (S S)) (SIGNATURE acosh (S S)) (SIGNATURE asinh (S S)) (SIGNATURE atanh (S S)) (SIGNATURE log (S S)) (SIGNATURE exp (S S)) (SIGNATURE ** (S S S)) (SIGNATURE pi (S)) (SIGNATURE ** (S S (Fraction (Integer)))) (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE rationalIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE rational ((Fraction (Integer)) S)) (SIGNATURE rational? ((Boolean) S)) (SIGNATURE polarCoordinates ((Record (: r R) (: phi R)) S)) (SIGNATURE argument (R S)) (SIGNATURE abs (S S)) (SIGNATURE exquo ((Union S failed) S R)) (SIGNATURE conjugate (S S)) (SIGNATURE imaginary (S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE patternMatch ((PatternMatchResult (Float) S) S (Pattern (Float)) (PatternMatchResult (Float) S))) (SIGNATURE patternMatch ((PatternMatchResult (Integer) S) S (Pattern (Integer)) (PatternMatchResult (Integer) S))) (SIGNATURE map (S (Mapping R R) S)) (SIGNATURE differentiate (S S (Mapping R R))) (SIGNATURE differentiate (S S (Mapping R R) (NonNegativeInteger))) (SIGNATURE reduce ((Union S failed) (Fraction (SparseUnivariatePolynomial R)))) (SIGNATURE lift ((SparseUnivariatePolynomial R) S)) (SIGNATURE convert (S (SparseUnivariatePolynomial R))) (SIGNATURE reduce (S (SparseUnivariatePolynomial R))) (SIGNATURE definingPolynomial ((SparseUnivariatePolynomial R))) (SIGNATURE reducedSystem ((Matrix R) (Matrix S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix R)) (: vec (Vector R))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix S))) (SIGNATURE retract (R S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Integer) S)) (SIGNATURE convert ((SparseUnivariatePolynomial R) S)) (SIGNATURE discriminant (R)) (SIGNATURE convert (S (Vector R))) (SIGNATURE convert ((Vector R) S)) (SIGNATURE coordinates ((Matrix R) (Vector S))) (SIGNATURE coordinates ((Vector R) S)) (SIGNATURE minimalPolynomial ((SparseUnivariatePolynomial R) S)) (SIGNATURE characteristicPolynomial ((SparseUnivariatePolynomial R) S)) (SIGNATURE discriminant (R (Vector S))) (SIGNATURE coordinates ((Matrix R) (Vector S) (Vector S))) (SIGNATURE coordinates ((Vector R) S (Vector S))) (SIGNATURE norm (R S)) (SIGNATURE trace (R S)) (SIGNATURE rank ((PositiveInteger))) (SIGNATURE coerce (S R)) (SIGNATURE * (S R S)) (SIGNATURE * (S S R)) (SIGNATURE coerce (S (Integer))) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE ** (S S (NonNegativeInteger))) (SIGNATURE recip ((Union S failed) S)) (SIGNATURE * (S S S)) (SIGNATURE ** (S S (PositiveInteger))) (SIGNATURE * (S (Integer) S)) (SIGNATURE - (S S S)) (SIGNATURE - (S S)) (SIGNATURE * (S (NonNegativeInteger) S)) (SIGNATURE * (S (PositiveInteger) S)) (SIGNATURE + (S S S)) (SIGNATURE coerce ((OutputForm) S)) (SIGNATURE = ((Boolean) S S)))
      [5] factorSquareFreePolynomial:  z has no value
      [6] reducedSystem: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE coerce (S S)) (SIGNATURE exquo ((Union S failed) S S)) (SIGNATURE unitNormal ((Record (: unit S) (: canonical S) (: associate S)) S)) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE euclideanSize ((NonNegativeInteger) S)) (SIGNATURE divide ((Record (: quotient S) (: remainder S)) S S)) (SIGNATURE quo (S S S)) (SIGNATURE rem (S S S)) (SIGNATURE inv (S S)) (SIGNATURE ** (S S (Integer))) (SIGNATURE * (S S (Fraction (Integer)))) (SIGNATURE * (S (Fraction (Integer)) S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE < ((Boolean) S S)) (SIGNATURE convert ((InputForm) S)) (SIGNATURE convert ((Complex (DoubleFloat)) S)) (SIGNATURE convert ((Complex (Float)) S)) (SIGNATURE tan (S S)) (SIGNATURE sin (S S)) (SIGNATURE cos (S S)) (SIGNATURE acos (S S)) (SIGNATURE asin (S S)) (SIGNATURE atan (S S)) (SIGNATURE cosh (S S)) (SIGNATURE sinh (S S)) (SIGNATURE tanh (S S)) (SIGNATURE acosh (S S)) (SIGNATURE asinh (S S)) (SIGNATURE atanh (S S)) (SIGNATURE log (S S)) (SIGNATURE exp (S S)) (SIGNATURE ** (S S S)) (SIGNATURE pi (S)) (SIGNATURE ** (S S (Fraction (Integer)))) (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE rationalIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE rational ((Fraction (Integer)) S)) (SIGNATURE rational? ((Boolean) S)) (SIGNATURE polarCoordinates ((Record (: r R) (: phi R)) S)) (SIGNATURE argument (R S)) (SIGNATURE abs (S S)) (SIGNATURE exquo ((Union S failed) S R)) (SIGNATURE conjugate (S S)) (SIGNATURE imaginary (S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE patternMatch ((PatternMatchResult (Float) S) S (Pattern (Float)) (PatternMatchResult (Float) S))) (SIGNATURE patternMatch ((PatternMatchResult (Integer) S) S (Pattern (Integer)) (PatternMatchResult (Integer) S))) (SIGNATURE map (S (Mapping R R) S)) (SIGNATURE differentiate (S S (Mapping R R))) (SIGNATURE differentiate (S S (Mapping R R) (NonNegativeInteger))) (SIGNATURE reduce ((Union S failed) (Fraction (SparseUnivariatePolynomial R)))) (SIGNATURE lift ((SparseUnivariatePolynomial R) S)) (SIGNATURE convert (S (SparseUnivariatePolynomial R))) (SIGNATURE reduce (S (SparseUnivariatePolynomial R))) (SIGNATURE definingPolynomial ((SparseUnivariatePolynomial R))) (SIGNATURE reducedSystem ((Matrix R) (Matrix S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix R)) (: vec (Vector R))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix S))) (SIGNATURE retract (R S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Integer) S)) (SIGNATURE convert ((SparseUnivariatePolynomial R) S)) (SIGNATURE discriminant (R)) (SIGNATURE convert (S (Vector R))) (SIGNATURE convert ((Vector R) S)) (SIGNATURE coordinates ((Matrix R) (Vector S))) (SIGNATURE coordinates ((Vector R) S)) (SIGNATURE minimalPolynomial ((SparseUnivariatePolynomial R) S)) (SIGNATURE characteristicPolynomial ((SparseUnivariatePolynomial R) S)) (SIGNATURE discriminant (R (Vector S))) (SIGNATURE coordinates ((Matrix R) (Vector S) (Vector S))) (SIGNATURE coordinates ((Vector R) S (Vector S))) (SIGNATURE norm (R S)) (SIGNATURE trace (R S)) (SIGNATURE rank ((PositiveInteger))) (SIGNATURE coerce (S R)) (SIGNATURE * (S R S)) (SIGNATURE * (S S R)) (SIGNATURE coerce (S (Integer))) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE ** (S S (NonNegativeInteger))) (SIGNATURE recip ((Union S failed) S)) (SIGNATURE * (S S S)) (SIGNATURE ** (S S (PositiveInteger))) (SIGNATURE * (S (Integer) S)) (SIGNATURE - (S S S)) (SIGNATURE - (S S)) (SIGNATURE * (S (NonNegativeInteger) S)) (SIGNATURE * (S (PositiveInteger) S)) (SIGNATURE + (S S S)) (SIGNATURE coerce ((OutputForm) S)) (SIGNATURE = ((Boolean) S S)))
      [7] patternMatch: not known that (SetCategory) is of mode (CATEGORY domain (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE coerce (S S)) (SIGNATURE exquo ((Union S failed) S S)) (SIGNATURE unitNormal ((Record (: unit S) (: canonical S) (: associate S)) S)) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE euclideanSize ((NonNegativeInteger) S)) (SIGNATURE divide ((Record (: quotient S) (: remainder S)) S S)) (SIGNATURE quo (S S S)) (SIGNATURE rem (S S S)) (SIGNATURE inv (S S)) (SIGNATURE ** (S S (Integer))) (SIGNATURE * (S S (Fraction (Integer)))) (SIGNATURE * (S (Fraction (Integer)) S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE < ((Boolean) S S)) (SIGNATURE convert ((InputForm) S)) (SIGNATURE convert ((Complex (DoubleFloat)) S)) (SIGNATURE convert ((Complex (Float)) S)) (SIGNATURE tan (S S)) (SIGNATURE sin (S S)) (SIGNATURE cos (S S)) (SIGNATURE acos (S S)) (SIGNATURE asin (S S)) (SIGNATURE atan (S S)) (SIGNATURE cosh (S S)) (SIGNATURE sinh (S S)) (SIGNATURE tanh (S S)) (SIGNATURE acosh (S S)) (SIGNATURE asinh (S S)) (SIGNATURE atanh (S S)) (SIGNATURE log (S S)) (SIGNATURE exp (S S)) (SIGNATURE ** (S S S)) (SIGNATURE pi (S)) (SIGNATURE ** (S S (Fraction (Integer)))) (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE rationalIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE rational ((Fraction (Integer)) S)) (SIGNATURE rational? ((Boolean) S)) (SIGNATURE polarCoordinates ((Record (: r R) (: phi R)) S)) (SIGNATURE argument (R S)) (SIGNATURE abs (S S)) (SIGNATURE exquo ((Union S failed) S R)) (SIGNATURE conjugate (S S)) (SIGNATURE imaginary (S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE patternMatch ((PatternMatchResult (Float) S) S (Pattern (Float)) (PatternMatchResult (Float) S))) (SIGNATURE patternMatch ((PatternMatchResult (Integer) S) S (Pattern (Integer)) (PatternMatchResult (Integer) S))) (SIGNATURE map (S (Mapping R R) S)) (SIGNATURE differentiate (S S (Mapping R R))) (SIGNATURE differentiate (S S (Mapping R R) (NonNegativeInteger))) (SIGNATURE reduce ((Union S failed) (Fraction (SparseUnivariatePolynomial R)))) (SIGNATURE lift ((SparseUnivariatePolynomial R) S)) (SIGNATURE convert (S (SparseUnivariatePolynomial R))) (SIGNATURE reduce (S (SparseUnivariatePolynomial R))) (SIGNATURE definingPolynomial ((SparseUnivariatePolynomial R))) (SIGNATURE reducedSystem ((Matrix R) (Matrix S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix R)) (: vec (Vector R))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix S))) (SIGNATURE retract (R S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Integer) S)) (SIGNATURE convert ((SparseUnivariatePolynomial R) S)) (SIGNATURE discriminant (R)) (SIGNATURE convert (S (Vector R))) (SIGNATURE convert ((Vector R) S)) (SIGNATURE coordinates ((Matrix R) (Vector S))) (SIGNATURE coordinates ((Vector R) S)) (SIGNATURE minimalPolynomial ((SparseUnivariatePolynomial R) S)) (SIGNATURE characteristicPolynomial ((SparseUnivariatePolynomial R) S)) (SIGNATURE discriminant (R (Vector S))) (SIGNATURE coordinates ((Matrix R) (Vector S) (Vector S))) (SIGNATURE coordinates ((Vector R) S (Vector S))) (SIGNATURE norm (R S)) (SIGNATURE trace (R S)) (SIGNATURE rank ((PositiveInteger))) (SIGNATURE coerce (S R)) (SIGNATURE * (S R S)) (SIGNATURE * (S S R)) (SIGNATURE coerce (S (Integer))) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE ** (S S (NonNegativeInteger))) (SIGNATURE recip ((Union S failed) S)) (SIGNATURE * (S S S)) (SIGNATURE ** (S S (PositiveInteger))) (SIGNATURE * (S (Integer) S)) (SIGNATURE - (S S S)) (SIGNATURE - (S S)) (SIGNATURE * (S (NonNegativeInteger) S)) (SIGNATURE * (S (PositiveInteger) S)) (SIGNATURE + (S S S)) (SIGNATURE coerce ((OutputForm) S)) (SIGNATURE = ((Boolean) S S)))
 
=========================================================================
warnings 20300:

>compiling DRAWCFUN.spad to DRAWCFUN.nrlib
 
   Warnings: 
      [1] drawToScaleRanges:  x has no value
      [2] drawPlot:  brans has no value
      [3] drawPlot:  xValues has no value
      [4] drawPlot:  yValues has no value
      [5] drawPlot:  x has no value
      [6] draw:  x has no value
      [7] draw:  fcn has no value
      [8] makeObject:  x has no value
      [9] makeObject:  fcn has no value
      [10] makeObject:  pointsColored? has no value
      [11] recolor:  f1 has no value
      [12] recolor:  f2 has no value
      [13] makeObject:  y has no value
      [14] makeObject:  col2 has no value
      [15] makeObject:  col3 has no value

=========================================================================
warnings 20299:

>compiling D01ANFA.spad to D01ANFA.nrlib
 
   Warnings: 
      [1] numericalIntegration:  x has no value
 
=========================================================================
warnings 20298:

>compiling D01ASFA.spad to D01ASFA.nrlib
 
   Warnings: 
      [1] numericalIntegration:  x has no value
 
=========================================================================
warnings 20297:

>compiling EP.spad to EP.nrlib

   Warnings: 
      [1] not known that (SIGNATURE variable ((Union $ failed) (Symbol))) is of mode (CATEGORY domain (SIGNATURE new ($)) (SIGNATURE new ($ $)) (SIGNATURE resetNew ((Void))) (SIGNATURE coerce ($ (String))) (SIGNATURE name ($ $)) (SIGNATURE scripted? ((Boolean) $)) (SIGNATURE scripts ((Record (: sub (List (OutputForm))) (: sup (List (OutputForm))) (: presup (List (OutputForm))) (: presub (List (OutputForm))) (: args (List (OutputForm)))) $)) (SIGNATURE script ($ $ (List (List (OutputForm))))) (SIGNATURE script ($ $ (Record (: sub (List (OutputForm))) (: sup (List (OutputForm))) (: presup (List (OutputForm))) (: presub (List (OutputForm))) (: args (List (OutputForm)))))) (SIGNATURE subscript ($ $ (List (OutputForm)))) (SIGNATURE superscript ($ $ (List (OutputForm)))) (SIGNATURE argscript ($ $ (List (OutputForm)))) (SIGNATURE elt ($ $ (List (OutputForm)))) (SIGNATURE string ((String) $)) (SIGNATURE list ((List $) $)) (SIGNATURE sample ($) constant))
      [2] charpol: :(PositiveInteger) -- should replace by pretend
      [3] eigenvalues:  lrat has no value
      [4] eigenvalues:  lsym has no value
      [5] intAlgEig: not known that (Ring) is of mode (CATEGORY package (SIGNATURE characteristicPolynomial ((Polynomial R) (Matrix (Fraction (Polynomial R))) (Symbol))) (SIGNATURE characteristicPolynomial ((Polynomial R) (Matrix (Fraction (Polynomial R))))) (SIGNATURE eigenvalues ((List (Union (Fraction (Polynomial R)) (SuchThat (Symbol) (Polynomial R)))) (Matrix (Fraction (Polynomial R))))) (SIGNATURE eigenvector ((List (Matrix (Fraction (Polynomial R)))) (Union (Fraction (Polynomial R)) (SuchThat (Symbol) (Polynomial R))) (Matrix (Fraction (Polynomial R))))) (SIGNATURE generalizedEigenvector ((List (Matrix (Fraction (Polynomial R)))) (Union (Fraction (Polynomial R)) (SuchThat (Symbol) (Polynomial R))) (Matrix (Fraction (Polynomial R))) (NonNegativeInteger) (NonNegativeInteger))) (SIGNATURE generalizedEigenvector ((List (Matrix (Fraction (Polynomial R)))) (Record (: eigval (Union (Fraction (Polynomial R)) (SuchThat (Symbol) (Polynomial R)))) (: eigmult (NonNegativeInteger)) (: eigvec (List (Matrix (Fraction (Polynomial R)))))) (Matrix (Fraction (Polynomial R))))) (SIGNATURE generalizedEigenvectors ((List (Record (: eigval (Union (Fraction (Polynomial R)) (SuchThat (Symbol) (Polynomial R)))) (: geneigvec (List (Matrix (Fraction (Polynomial R))))))) (Matrix (Fraction (Polynomial R))))) (SIGNATURE eigenvectors ((List (Record (: eigval (Union (Fraction (Polynomial R)) (SuchThat (Symbol) (Polynomial R)))) (: eigmult (NonNegativeInteger)) (: eigvec (List (Matrix (Fraction (Polynomial R))))))) (Matrix (Fraction (Polynomial R))))))
      [6] eigenvectors:  ratSol has no value
      [7] eigenvectors:  algSol has no value
 

=========================================================================
warnings 20296:

>compiling E04AGNT.spad to E04AGNT.nrlib
 
   Warnings: 
      [1] optAttributes:  noa has no value
      [2] optAttributes:  lsa has no value
      [3] optAttributes:  s has no value

=========================================================================
warnings 20295:

>compiling FEXPR.spad to FEXPR.nrlib
 
   Warnings: 
      [1] checkSymbols:  IN has no value
      [2] checkForNagOperators:  X01AAF has no value
      [3] pi:  X01AAF has no value
 
=========================================================================
warnings 20294:

>compiling FFCAT.spad to FFCAT.nrlib
 
   Warnings: 
      [1] rationalPoint?: not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE rationalPoints ((List (List F)))) (SIGNATURE nonSingularModel ((List (Polynomial F)) (Symbol))) (SIGNATURE algSplitSimple ((Record (: num S) (: den UP) (: derivden UP) (: gd UP)) S (Mapping UP UP))) (SIGNATURE hyperelliptic ((Union UP failed))) (SIGNATURE elliptic ((Union UP failed))) (SIGNATURE elt (F S F F)) (SIGNATURE primitivePart (S S)) (SIGNATURE represents (S (Vector UP) UP)) (SIGNATURE differentiate (S S (Mapping UP UP))) (SIGNATURE integral? ((Boolean) S UP)) (SIGNATURE integral? ((Boolean) S F)) (SIGNATURE yCoordinates ((Record (: num (Vector UP)) (: den UP)) S)) (SIGNATURE reduceBasisAtInfinity ((Vector S) (Vector S))) (SIGNATURE normalizeAtInfinity ((Vector S) (Vector S))) (SIGNATURE complementaryBasis ((Vector S) (Vector S))) (SIGNATURE integral? ((Boolean) S)) (SIGNATURE integralAtInfinity? ((Boolean) S)) (SIGNATURE rationalPoint? ((Boolean) F F)) (SIGNATURE absolutelyIrreducible? ((Boolean))) (SIGNATURE genus ((NonNegativeInteger))) (SIGNATURE numberOfComponents ((NonNegativeInteger))) (SIGNATURE differentiate (S S (Mapping (Fraction UP) (Fraction UP)))) (SIGNATURE differentiate (S S (Mapping (Fraction UP) (Fraction UP)) (NonNegativeInteger))) (SIGNATURE represents (S (Vector (Fraction UP)))) (SIGNATURE represents (S (Vector (Fraction UP)) (Vector S))))
      [2] UP2P:  s has no value
      [3] UPUP2P:  s has no value
      [4] nonSingularModel:  s has no value
      [5] primitivePart:  STEP has no value
      [6] primitivePart:  i has no value
      [7] integralAtInfinity?:  s has no value
      [8] repOrder:  nostart has no value
      [9] kmin:  nostart has no value
      [10] kmin:  k has no value
      [11] integral?:  den has no value
      [12] differentiate:  x has no value
 
=========================================================================
warnings 20293:

>compiling FFCGP.spad to FFCGP.nrlib
 
   Warnings: 
      [1] pretend(NonNegativeInteger) -- should replace by @
      [2] +: pretend(SingleInteger) -- should replace by @
      [3] +: pretendRep -- should replace by @
      [4] retractIfCan: pretendRep -- should replace by @
      [5] inGroundField?: pretendRep -- should replace by @
      [6] -: pretendRep -- should replace by @
      [7] extensionDegree: signature of lhs not unique: (PositiveInteger) chosen
      [8] unknown Functor code (error field too large for this representation)
 
=========================================================================
warnings 20292:

>compiling FFNBP.spad to FFNBP.nrlib
 
   Warnings: 
      [1] degree: signature of lhs not unique: (PositiveInteger)$ chosen
      [2] coerce:  l has no value
      [3] initializeLog:  n has no value
      [4] extensionDegree: signature of lhs not unique: (PositiveInteger) chosen
 
=========================================================================
warnings 20291:

>compiling FFP.spad to FFP.nrlib
 
   Warnings: 
      [1] degree: signature of lhs not unique: (PositiveInteger)$ chosen
      [2] tableForDiscreteLogarithm: pretend(Table (PositiveInteger) (NonNegativeInteger)) -- should replace by @
      [3] initializeLog:  n has no value
      [4] extensionDegree: signature of lhs not unique: (PositiveInteger) chosen
 
=========================================================================
warnings 20290:

>compiling FLOAT.spad to FLOAT.nrlib

   Warnings: 
      [1] OMwrite: pretend(String) -- should replace by @
      [2] cos:  s has no value
      [3] exp:  e1 has no value
      [4] exp1:  E has no value
      [5] normalize:  e has no value
      [6] power:  y has no value
      [7] power10:  y has no value
 
=========================================================================
warnings 20289:

>compiling FPARFRAC.spad to FPARFRAC.nrlib
 
   Warnings: 
      [1] UP2SUP:  z1 has no value
      [2] fullPartialFraction: not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE + ($ UP $)) (SIGNATURE fullPartialFraction ($ (Fraction UP))) (SIGNATURE polyPart (UP $)) (SIGNATURE fracPart ((List (Record (: exponent (NonNegativeInteger)) (: center UP) (: num UP))) $)) (SIGNATURE construct ($ (List (Record (: exponent (NonNegativeInteger)) (: center UP) (: num UP))))) (SIGNATURE differentiate ($ $)) (SIGNATURE D ($ $)) (SIGNATURE differentiate ($ $ (NonNegativeInteger))) (SIGNATURE D ($ $ (NonNegativeInteger))))
      [3] fullParFrac:  ans has no value
 

=========================================================================
warnings 20288:

>compiling FR.spad to FR.nrlib
 
   Warnings: 
      [1] zero?:  fctr has no value
      [2] eval:  IN has no value
      [3] eval:  e has no value
      [4] convert:  fctr has no value
      [5] convert:  xpnt has no value
      [6] exquo:  associate has no value
      [7] exquo:  goodQuotient has no value
 
=========================================================================
warnings 20287:

>compiling FRNAALG.spad to FRNAALG.nrlib
 
   Warnings: 
      [1] leftRankPolynomial:  xx has no value
      [2] rightRankPolynomial:  xx has no value
      [3] coordinates: signature of lhs not unique: (Matrix R)(Vector S) chosen

=========================================================================
warnings 20286:

>compiling FS.spad to FS.nrlib
 
   Warnings: 
      [1] coerce: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE * (S (PositiveInteger) S)) (SIGNATURE * (S (NonNegativeInteger) S)) (SIGNATURE * (S (Integer) S)) (SIGNATURE * (S S S)) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE coerce (S (Integer))) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE convert ((InputForm) S)) (SIGNATURE retract ((Polynomial R) S)) (SIGNATURE retractIfCan ((Union (Polynomial R) failed) S)) (SIGNATURE coerce (S (Polynomial R))) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE * (S S R)) (SIGNATURE * (S R S)) (SIGNATURE coerce (S S)) (SIGNATURE * (S S (Fraction (Integer)))) (SIGNATURE * (S (Fraction (Integer)) S)) (SIGNATURE retract ((Fraction (Polynomial R)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Polynomial R)) failed) S)) (SIGNATURE coerce (S (Fraction (Polynomial R)))) (SIGNATURE univariate ((Fraction (SparseUnivariatePolynomial S)) S (Kernel S))) (SIGNATURE coerce (S (Fraction (Polynomial (Fraction R))))) (SIGNATURE coerce (S (Polynomial (Fraction R)))) (SIGNATURE coerce (S (Fraction R))) (SIGNATURE denominator (S S)) (SIGNATURE convert (S (Factored S))) (SIGNATURE eval (S S (Symbol) (NonNegativeInteger) (Mapping S S))) (SIGNATURE eval (S S (Symbol) (NonNegativeInteger) (Mapping S (List S)))) (SIGNATURE eval (S S (List (Symbol)) (List (NonNegativeInteger)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (Symbol)) (List (NonNegativeInteger)) (List (Mapping S S)))) (SIGNATURE isPower ((Union (Record (: val S) (: exponent (Integer))) failed) S)) (SIGNATURE isExpt ((Union (Record (: var (Kernel S)) (: exponent (Integer))) failed) S (Symbol))) (SIGNATURE isExpt ((Union (Record (: var (Kernel S)) (: exponent (Integer))) failed) S (BasicOperator))) (SIGNATURE numerator (S S)) (SIGNATURE coerce (S (SparseMultivariatePolynomial R (Kernel S)))) (SIGNATURE isMult ((Union (Record (: coef (Integer)) (: var (Kernel S))) failed) S)) (SIGNATURE isPlus ((Union (List S) failed) S)) (SIGNATURE isExpt ((Union (Record (: var (Kernel S)) (: exponent (Integer))) failed) S)) (SIGNATURE isTimes ((Union (List S) failed) S)) (SIGNATURE eval (S S (List (BasicOperator)) (List S) (Symbol))) (SIGNATURE eval (S S (BasicOperator) S (Symbol))) (SIGNATURE eval (S S)) (SIGNATURE eval (S S (List (Symbol)))) (SIGNATURE eval (S S (Symbol))) (SIGNATURE applyQuote (S (Symbol) (List S))) (SIGNATURE applyQuote (S (Symbol) S S S S)) (SIGNATURE applyQuote (S (Symbol) S S S)) (SIGNATURE applyQuote (S (Symbol) S S)) (SIGNATURE applyQuote (S (Symbol) S)) (SIGNATURE variables ((List (Symbol)) S)) (SIGNATURE ground (R S)) (SIGNATURE ground? ((Boolean) S)) (SIGNATURE retract (R S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE coerce (S R)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Integer) S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE retract ((Symbol) S)) (SIGNATURE retractIfCan ((Union (Symbol) failed) S)) (SIGNATURE coerce (S (Symbol))) (SIGNATURE eval (S S (BasicOperator) (Mapping S S))) (SIGNATURE eval (S S (BasicOperator) (Mapping S (List S)))) (SIGNATURE eval (S S (List (BasicOperator)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (BasicOperator)) (List (Mapping S S)))) (SIGNATURE eval (S S (Symbol) (Mapping S S))) (SIGNATURE eval (S S (Symbol) (Mapping S (List S)))) (SIGNATURE eval (S S (List (Symbol)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (Symbol)) (List (Mapping S S)))) (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE kernels ((List (Kernel S)) S)) (SIGNATURE mainKernel ((Union (Kernel S) failed) S)) (SIGNATURE subst (S S (List (Kernel S)) (List S))) (SIGNATURE subst (S S (List (Equation S)))) (SIGNATURE subst (S S (Equation S))) (SIGNATURE elt (S (BasicOperator) (List S))) (SIGNATURE elt (S (BasicOperator) S S S S)) (SIGNATURE elt (S (BasicOperator) S S S)) (SIGNATURE elt (S (BasicOperator) S S)) (SIGNATURE elt (S (BasicOperator) S)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE eval (S S (List (Kernel S)) (List S))) (SIGNATURE eval (S S (Kernel S) S)) (SIGNATURE retract ((Kernel S) S)) (SIGNATURE retractIfCan ((Union (Kernel S) failed) S)) (SIGNATURE coerce (S (Kernel S))) (SIGNATURE coerce ((OutputForm) S)))
      [2] subs:  IN has no value
      [3] subs:  x has no value
      [4] variables: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE * (S (PositiveInteger) S)) (SIGNATURE * (S (NonNegativeInteger) S)) (SIGNATURE * (S (Integer) S)) (SIGNATURE * (S S S)) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE coerce (S (Integer))) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE convert ((InputForm) S)) (SIGNATURE retract ((Polynomial R) S)) (SIGNATURE retractIfCan ((Union (Polynomial R) failed) S)) (SIGNATURE coerce (S (Polynomial R))) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE * (S S R)) (SIGNATURE * (S R S)) (SIGNATURE coerce (S S)) (SIGNATURE * (S S (Fraction (Integer)))) (SIGNATURE * (S (Fraction (Integer)) S)) (SIGNATURE retract ((Fraction (Polynomial R)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Polynomial R)) failed) S)) (SIGNATURE coerce (S (Fraction (Polynomial R)))) (SIGNATURE univariate ((Fraction (SparseUnivariatePolynomial S)) S (Kernel S))) (SIGNATURE coerce (S (Fraction (Polynomial (Fraction R))))) (SIGNATURE coerce (S (Polynomial (Fraction R)))) (SIGNATURE coerce (S (Fraction R))) (SIGNATURE denominator (S S)) (SIGNATURE convert (S (Factored S))) (SIGNATURE eval (S S (Symbol) (NonNegativeInteger) (Mapping S S))) (SIGNATURE eval (S S (Symbol) (NonNegativeInteger) (Mapping S (List S)))) (SIGNATURE eval (S S (List (Symbol)) (List (NonNegativeInteger)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (Symbol)) (List (NonNegativeInteger)) (List (Mapping S S)))) (SIGNATURE isPower ((Union (Record (: val S) (: exponent (Integer))) failed) S)) (SIGNATURE isExpt ((Union (Record (: var (Kernel S)) (: exponent (Integer))) failed) S (Symbol))) (SIGNATURE isExpt ((Union (Record (: var (Kernel S)) (: exponent (Integer))) failed) S (BasicOperator))) (SIGNATURE numerator (S S)) (SIGNATURE coerce (S (SparseMultivariatePolynomial R (Kernel S)))) (SIGNATURE isMult ((Union (Record (: coef (Integer)) (: var (Kernel S))) failed) S)) (SIGNATURE isPlus ((Union (List S) failed) S)) (SIGNATURE isExpt ((Union (Record (: var (Kernel S)) (: exponent (Integer))) failed) S)) (SIGNATURE isTimes ((Union (List S) failed) S)) (SIGNATURE eval (S S (List (BasicOperator)) (List S) (Symbol))) (SIGNATURE eval (S S (BasicOperator) S (Symbol))) (SIGNATURE eval (S S)) (SIGNATURE eval (S S (List (Symbol)))) (SIGNATURE eval (S S (Symbol))) (SIGNATURE applyQuote (S (Symbol) (List S))) (SIGNATURE applyQuote (S (Symbol) S S S S)) (SIGNATURE applyQuote (S (Symbol) S S S)) (SIGNATURE applyQuote (S (Symbol) S S)) (SIGNATURE applyQuote (S (Symbol) S)) (SIGNATURE variables ((List (Symbol)) S)) (SIGNATURE ground (R S)) (SIGNATURE ground? ((Boolean) S)) (SIGNATURE retract (R S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE coerce (S R)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Integer) S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE retract ((Symbol) S)) (SIGNATURE retractIfCan ((Union (Symbol) failed) S)) (SIGNATURE coerce (S (Symbol))) (SIGNATURE eval (S S (BasicOperator) (Mapping S S))) (SIGNATURE eval (S S (BasicOperator) (Mapping S (List S)))) (SIGNATURE eval (S S (List (BasicOperator)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (BasicOperator)) (List (Mapping S S)))) (SIGNATURE eval (S S (Symbol) (Mapping S S))) (SIGNATURE eval (S S (Symbol) (Mapping S (List S)))) (SIGNATURE eval (S S (List (Symbol)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (Symbol)) (List (Mapping S S)))) (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE kernels ((List (Kernel S)) S)) (SIGNATURE mainKernel ((Union (Kernel S) failed) S)) (SIGNATURE subst (S S (List (Kernel S)) (List S))) (SIGNATURE subst (S S (List (Equation S)))) (SIGNATURE subst (S S (Equation S))) (SIGNATURE elt (S (BasicOperator) (List S))) (SIGNATURE elt (S (BasicOperator) S S S S)) (SIGNATURE elt (S (BasicOperator) S S S)) (SIGNATURE elt (S (BasicOperator) S S)) (SIGNATURE elt (S (BasicOperator) S)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE eval (S S (List (Kernel S)) (List S))) (SIGNATURE eval (S S (Kernel S) S)) (SIGNATURE retract ((Kernel S) S)) (SIGNATURE retractIfCan ((Union (Kernel S) failed) S)) (SIGNATURE coerce (S (Kernel S))) (SIGNATURE coerce ((OutputForm) S)))
      [5] eval:  y has no value
      [6] eval:  IN has no value
      [7] eval:  f has no value
      [8] smprep:  IN has no value
      [9] smprep:  a has no value
      [10] smprep:  y has no value
      [11] smprep: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE * (S (PositiveInteger) S)) (SIGNATURE * (S (NonNegativeInteger) S)) (SIGNATURE * (S (Integer) S)) (SIGNATURE * (S S S)) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE coerce (S (Integer))) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE convert ((InputForm) S)) (SIGNATURE retract ((Polynomial R) S)) (SIGNATURE retractIfCan ((Union (Polynomial R) failed) S)) (SIGNATURE coerce (S (Polynomial R))) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE * (S S R)) (SIGNATURE * (S R S)) (SIGNATURE coerce (S S)) (SIGNATURE * (S S (Fraction (Integer)))) (SIGNATURE * (S (Fraction (Integer)) S)) (SIGNATURE retract ((Fraction (Polynomial R)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Polynomial R)) failed) S)) (SIGNATURE coerce (S (Fraction (Polynomial R)))) (SIGNATURE univariate ((Fraction (SparseUnivariatePolynomial S)) S (Kernel S))) (SIGNATURE coerce (S (Fraction (Polynomial (Fraction R))))) (SIGNATURE coerce (S (Polynomial (Fraction R)))) (SIGNATURE coerce (S (Fraction R))) (SIGNATURE denominator (S S)) (SIGNATURE convert (S (Factored S))) (SIGNATURE eval (S S (Symbol) (NonNegativeInteger) (Mapping S S))) (SIGNATURE eval (S S (Symbol) (NonNegativeInteger) (Mapping S (List S)))) (SIGNATURE eval (S S (List (Symbol)) (List (NonNegativeInteger)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (Symbol)) (List (NonNegativeInteger)) (List (Mapping S S)))) (SIGNATURE isPower ((Union (Record (: val S) (: exponent (Integer))) failed) S)) (SIGNATURE isExpt ((Union (Record (: var (Kernel S)) (: exponent (Integer))) failed) S (Symbol))) (SIGNATURE isExpt ((Union (Record (: var (Kernel S)) (: exponent (Integer))) failed) S (BasicOperator))) (SIGNATURE numerator (S S)) (SIGNATURE coerce (S (SparseMultivariatePolynomial R (Kernel S)))) (SIGNATURE isMult ((Union (Record (: coef (Integer)) (: var (Kernel S))) failed) S)) (SIGNATURE isPlus ((Union (List S) failed) S)) (SIGNATURE isExpt ((Union (Record (: var (Kernel S)) (: exponent (Integer))) failed) S)) (SIGNATURE isTimes ((Union (List S) failed) S)) (SIGNATURE eval (S S (List (BasicOperator)) (List S) (Symbol))) (SIGNATURE eval (S S (BasicOperator) S (Symbol))) (SIGNATURE eval (S S)) (SIGNATURE eval (S S (List (Symbol)))) (SIGNATURE eval (S S (Symbol))) (SIGNATURE applyQuote (S (Symbol) (List S))) (SIGNATURE applyQuote (S (Symbol) S S S S)) (SIGNATURE applyQuote (S (Symbol) S S S)) (SIGNATURE applyQuote (S (Symbol) S S)) (SIGNATURE applyQuote (S (Symbol) S)) (SIGNATURE variables ((List (Symbol)) S)) (SIGNATURE ground (R S)) (SIGNATURE ground? ((Boolean) S)) (SIGNATURE retract (R S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE coerce (S R)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Integer) S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE retract ((Symbol) S)) (SIGNATURE retractIfCan ((Union (Symbol) failed) S)) (SIGNATURE coerce (S (Symbol))) (SIGNATURE eval (S S (BasicOperator) (Mapping S S))) (SIGNATURE eval (S S (BasicOperator) (Mapping S (List S)))) (SIGNATURE eval (S S (List (BasicOperator)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (BasicOperator)) (List (Mapping S S)))) (SIGNATURE eval (S S (Symbol) (Mapping S S))) (SIGNATURE eval (S S (Symbol) (Mapping S (List S)))) (SIGNATURE eval (S S (List (Symbol)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (Symbol)) (List (Mapping S S)))) (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE kernels ((List (Kernel S)) S)) (SIGNATURE mainKernel ((Union (Kernel S) failed) S)) (SIGNATURE subst (S S (List (Kernel S)) (List S))) (SIGNATURE subst (S S (List (Equation S)))) (SIGNATURE subst (S S (Equation S))) (SIGNATURE elt (S (BasicOperator) (List S))) (SIGNATURE elt (S (BasicOperator) S S S S)) (SIGNATURE elt (S (BasicOperator) S S S)) (SIGNATURE elt (S (BasicOperator) S S)) (SIGNATURE elt (S (BasicOperator) S)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE eval (S S (List (Kernel S)) (List S))) (SIGNATURE eval (S S (Kernel S) S)) (SIGNATURE retract ((Kernel S) S)) (SIGNATURE retractIfCan ((Union (Kernel S) failed) S)) (SIGNATURE coerce (S (Kernel S))) (SIGNATURE coerce ((OutputForm) S)))
      [12] diffdiff0:  ans has no value
      [13] diffEval:  k has no value
      [14] opderiv:  x has no value
      [15] opderiv:  y has no value
      [16] smpderiv:  s has no value
      [17] coerce:  s has no value
      [18] coerce:  r has no value
      [19] smp2O:  x has no value
      [20] smpsubst:  x has no value
      [21] smpsubst:  s has no value
      [22] smpsubst:  z has no value
      [23] smpsubst:  y has no value
      [24] smpeval:  x has no value
      [25] smpeval:  s has no value
      [26] smpeval:  z has no value
      [27] smpeval:  y has no value
      [28] smpunq:  x has no value
      [29] smpunq:  y has no value
      [30] smpret:  x has no value
      [31] smpret:  y has no value
      [32] univariate: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE * (S (PositiveInteger) S)) (SIGNATURE * (S (NonNegativeInteger) S)) (SIGNATURE * (S (Integer) S)) (SIGNATURE * (S S S)) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE coerce (S (Integer))) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE convert ((InputForm) S)) (SIGNATURE retract ((Polynomial R) S)) (SIGNATURE retractIfCan ((Union (Polynomial R) failed) S)) (SIGNATURE coerce (S (Polynomial R))) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE * (S S R)) (SIGNATURE * (S R S)) (SIGNATURE coerce (S S)) (SIGNATURE * (S S (Fraction (Integer)))) (SIGNATURE * (S (Fraction (Integer)) S)) (SIGNATURE retract ((Fraction (Polynomial R)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Polynomial R)) failed) S)) (SIGNATURE coerce (S (Fraction (Polynomial R)))) (SIGNATURE univariate ((Fraction (SparseUnivariatePolynomial S)) S (Kernel S))) (SIGNATURE coerce (S (Fraction (Polynomial (Fraction R))))) (SIGNATURE coerce (S (Polynomial (Fraction R)))) (SIGNATURE coerce (S (Fraction R))) (SIGNATURE denominator (S S)) (SIGNATURE convert (S (Factored S))) (SIGNATURE eval (S S (Symbol) (NonNegativeInteger) (Mapping S S))) (SIGNATURE eval (S S (Symbol) (NonNegativeInteger) (Mapping S (List S)))) (SIGNATURE eval (S S (List (Symbol)) (List (NonNegativeInteger)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (Symbol)) (List (NonNegativeInteger)) (List (Mapping S S)))) (SIGNATURE isPower ((Union (Record (: val S) (: exponent (Integer))) failed) S)) (SIGNATURE isExpt ((Union (Record (: var (Kernel S)) (: exponent (Integer))) failed) S (Symbol))) (SIGNATURE isExpt ((Union (Record (: var (Kernel S)) (: exponent (Integer))) failed) S (BasicOperator))) (SIGNATURE numerator (S S)) (SIGNATURE coerce (S (SparseMultivariatePolynomial R (Kernel S)))) (SIGNATURE isMult ((Union (Record (: coef (Integer)) (: var (Kernel S))) failed) S)) (SIGNATURE isPlus ((Union (List S) failed) S)) (SIGNATURE isExpt ((Union (Record (: var (Kernel S)) (: exponent (Integer))) failed) S)) (SIGNATURE isTimes ((Union (List S) failed) S)) (SIGNATURE eval (S S (List (BasicOperator)) (List S) (Symbol))) (SIGNATURE eval (S S (BasicOperator) S (Symbol))) (SIGNATURE eval (S S)) (SIGNATURE eval (S S (List (Symbol)))) (SIGNATURE eval (S S (Symbol))) (SIGNATURE applyQuote (S (Symbol) (List S))) (SIGNATURE applyQuote (S (Symbol) S S S S)) (SIGNATURE applyQuote (S (Symbol) S S S)) (SIGNATURE applyQuote (S (Symbol) S S)) (SIGNATURE applyQuote (S (Symbol) S)) (SIGNATURE variables ((List (Symbol)) S)) (SIGNATURE ground (R S)) (SIGNATURE ground? ((Boolean) S)) (SIGNATURE retract (R S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE coerce (S R)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Integer) S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE retract ((Symbol) S)) (SIGNATURE retractIfCan ((Union (Symbol) failed) S)) (SIGNATURE coerce (S (Symbol))) (SIGNATURE eval (S S (BasicOperator) (Mapping S S))) (SIGNATURE eval (S S (BasicOperator) (Mapping S (List S)))) (SIGNATURE eval (S S (List (BasicOperator)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (BasicOperator)) (List (Mapping S S)))) (SIGNATURE eval (S S (Symbol) (Mapping S S))) (SIGNATURE eval (S S (Symbol) (Mapping S (List S)))) (SIGNATURE eval (S S (List (Symbol)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (Symbol)) (List (Mapping S S)))) (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE kernels ((List (Kernel S)) S)) (SIGNATURE mainKernel ((Union (Kernel S) failed) S)) (SIGNATURE subst (S S (List (Kernel S)) (List S))) (SIGNATURE subst (S S (List (Equation S)))) (SIGNATURE subst (S S (Equation S))) (SIGNATURE elt (S (BasicOperator) (List S))) (SIGNATURE elt (S (BasicOperator) S S S S)) (SIGNATURE elt (S (BasicOperator) S S S)) (SIGNATURE elt (S (BasicOperator) S S)) (SIGNATURE elt (S (BasicOperator) S)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE eval (S S (List (Kernel S)) (List S))) (SIGNATURE eval (S S (Kernel S) S)) (SIGNATURE retract ((Kernel S) S)) (SIGNATURE retractIfCan ((Union (Kernel S) failed) S)) (SIGNATURE coerce (S (Kernel S))) (SIGNATURE coerce ((OutputForm) S)))
      [33] convert: not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE * (S (PositiveInteger) S)) (SIGNATURE * (S (NonNegativeInteger) S)) (SIGNATURE * (S (Integer) S)) (SIGNATURE * (S S S)) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE coerce (S (Integer))) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE convert ((InputForm) S)) (SIGNATURE retract ((Polynomial R) S)) (SIGNATURE retractIfCan ((Union (Polynomial R) failed) S)) (SIGNATURE coerce (S (Polynomial R))) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE * (S S R)) (SIGNATURE * (S R S)) (SIGNATURE coerce (S S)) (SIGNATURE * (S S (Fraction (Integer)))) (SIGNATURE * (S (Fraction (Integer)) S)) (SIGNATURE retract ((Fraction (Polynomial R)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Polynomial R)) failed) S)) (SIGNATURE coerce (S (Fraction (Polynomial R)))) (SIGNATURE univariate ((Fraction (SparseUnivariatePolynomial S)) S (Kernel S))) (SIGNATURE coerce (S (Fraction (Polynomial (Fraction R))))) (SIGNATURE coerce (S (Polynomial (Fraction R)))) (SIGNATURE coerce (S (Fraction R))) (SIGNATURE denominator (S S)) (SIGNATURE convert (S (Factored S))) (SIGNATURE eval (S S (Symbol) (NonNegativeInteger) (Mapping S S))) (SIGNATURE eval (S S (Symbol) (NonNegativeInteger) (Mapping S (List S)))) (SIGNATURE eval (S S (List (Symbol)) (List (NonNegativeInteger)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (Symbol)) (List (NonNegativeInteger)) (List (Mapping S S)))) (SIGNATURE isPower ((Union (Record (: val S) (: exponent (Integer))) failed) S)) (SIGNATURE isExpt ((Union (Record (: var (Kernel S)) (: exponent (Integer))) failed) S (Symbol))) (SIGNATURE isExpt ((Union (Record (: var (Kernel S)) (: exponent (Integer))) failed) S (BasicOperator))) (SIGNATURE numerator (S S)) (SIGNATURE coerce (S (SparseMultivariatePolynomial R (Kernel S)))) (SIGNATURE isMult ((Union (Record (: coef (Integer)) (: var (Kernel S))) failed) S)) (SIGNATURE isPlus ((Union (List S) failed) S)) (SIGNATURE isExpt ((Union (Record (: var (Kernel S)) (: exponent (Integer))) failed) S)) (SIGNATURE isTimes ((Union (List S) failed) S)) (SIGNATURE eval (S S (List (BasicOperator)) (List S) (Symbol))) (SIGNATURE eval (S S (BasicOperator) S (Symbol))) (SIGNATURE eval (S S)) (SIGNATURE eval (S S (List (Symbol)))) (SIGNATURE eval (S S (Symbol))) (SIGNATURE applyQuote (S (Symbol) (List S))) (SIGNATURE applyQuote (S (Symbol) S S S S)) (SIGNATURE applyQuote (S (Symbol) S S S)) (SIGNATURE applyQuote (S (Symbol) S S)) (SIGNATURE applyQuote (S (Symbol) S)) (SIGNATURE variables ((List (Symbol)) S)) (SIGNATURE ground (R S)) (SIGNATURE ground? ((Boolean) S)) (SIGNATURE retract (R S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE coerce (S R)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Integer) S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE retract ((Symbol) S)) (SIGNATURE retractIfCan ((Union (Symbol) failed) S)) (SIGNATURE coerce (S (Symbol))) (SIGNATURE eval (S S (BasicOperator) (Mapping S S))) (SIGNATURE eval (S S (BasicOperator) (Mapping S (List S)))) (SIGNATURE eval (S S (List (BasicOperator)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (BasicOperator)) (List (Mapping S S)))) (SIGNATURE eval (S S (Symbol) (Mapping S S))) (SIGNATURE eval (S S (Symbol) (Mapping S (List S)))) (SIGNATURE eval (S S (List (Symbol)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (Symbol)) (List (Mapping S S)))) (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE kernels ((List (Kernel S)) S)) (SIGNATURE mainKernel ((Union (Kernel S) failed) S)) (SIGNATURE subst (S S (List (Kernel S)) (List S))) (SIGNATURE subst (S S (List (Equation S)))) (SIGNATURE subst (S S (Equation S))) (SIGNATURE elt (S (BasicOperator) (List S))) (SIGNATURE elt (S (BasicOperator) S S S S)) (SIGNATURE elt (S (BasicOperator) S S S)) (SIGNATURE elt (S (BasicOperator) S S)) (SIGNATURE elt (S (BasicOperator) S)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE eval (S S (List (Kernel S)) (List S))) (SIGNATURE eval (S S (Kernel S) S)) (SIGNATURE retract ((Kernel S) S)) (SIGNATURE retractIfCan ((Union (Kernel S) failed) S)) (SIGNATURE coerce (S (Kernel S))) (SIGNATURE coerce ((OutputForm) S)))
      [34] coerce:  x has no value
      [35] coerce:  y has no value
 
=========================================================================
warnings 20285:

>compiling FST.spad to FST.nrlib
 
   Warnings: 
      [1] coerce:  REAL has no value
      [2] coerce:  INTEGER has no value
      [3] coerce:  COMPLEX has no value
      [4] coerce:  CHARACTER has no value
      [5] coerce:  LOGICAL has no value
      [6] coerce:  real has no value
      [7] coerce:  integer has no value
      [8] coerce:  complex has no value
      [9] coerce:  character has no value
      [10] coerce:  logical has no value
      [11] coerce:  upperDoubleCOmplexSymbol has no value
 
=========================================================================
warnings 20284:

>compiling GDMP.spad to GDMP.nrlib
 
   Warnings: 
      [1] zero?: :Rep -- should replace by pretend
      [2] listCoef: :Rep -- should replace by pretend
      [3] numberOfMonomials: :Rep -- should replace by pretend
      [4] monomial?: :Rep -- should replace by pretend
      [5] maxNorm:  m has no value
      [6] variables: :(PositiveInteger) -- should replace by pretend
      [7] reorder:  z2 has no value
      [8] reorder:  z1 has no value
      [9] univariate:  deg has no value
      [10] evalSortedVarlist:  x has no value
      [11] eval:  y has no value
      [12] eval:  x has no value
      [13] coerce:  l has no value
 
=========================================================================
warnings 20283:

>compiling HACKPI.spad to HACKPI.nrlib
 
   Warnings: 
      [1] pi: pretend$ -- should replace by @
      [2] p2sf:  x has no value
      [3] p2f:  x has no value

=========================================================================
warnings 20282:

>compiling IDEAL.spad to IDEAL.nrlib
 
   Warnings: 
      [1] not known that (OrderedAbelianMonoidSup) is of mode (CATEGORY domain (IF (has (NonNegativeInteger) (Finite)) (IF (has Expon (Finite)) (ATTRIBUTE (Finite)) noBranch) noBranch) (IF (has (NonNegativeInteger) (Monoid)) (IF (has Expon (Monoid)) (ATTRIBUTE (Monoid)) noBranch) noBranch) (IF (has (NonNegativeInteger) (AbelianMonoid)) (IF (has Expon (AbelianMonoid)) (ATTRIBUTE (AbelianMonoid)) noBranch) noBranch) (IF (has (NonNegativeInteger) (CancellationAbelianMonoid)) (IF (has Expon (CancellationAbelianMonoid)) (ATTRIBUTE (CancellationAbelianMonoid)) noBranch) noBranch) (IF (has (NonNegativeInteger) (Group)) (IF (has Expon (Group)) (ATTRIBUTE (Group)) noBranch) noBranch) (IF (has (NonNegativeInteger) (AbelianGroup)) (IF (has Expon (AbelianGroup)) (ATTRIBUTE (AbelianGroup)) noBranch) noBranch) (IF (has (NonNegativeInteger) (OrderedAbelianMonoidSup)) (IF (has Expon (OrderedAbelianMonoidSup)) (ATTRIBUTE (OrderedAbelianMonoidSup)) noBranch) noBranch) (IF (has (NonNegativeInteger) (OrderedSet)) (IF (has Expon (OrderedSet)) (ATTRIBUTE (OrderedSet)) noBranch) noBranch) (SIGNATURE makeprod ($ (NonNegativeInteger) Expon)) (SIGNATURE selectfirst ((NonNegativeInteger) $)) (SIGNATURE selectsecond (Expon $)))
      [2] leadterm: not known that (Ring) is of mode (CATEGORY package (SIGNATURE * ($ $ $)) (SIGNATURE ** ($ $ (NonNegativeInteger))) (SIGNATURE + ($ $ $)) (SIGNATURE one? ((Boolean) $)) (SIGNATURE zero? ((Boolean) $)) (SIGNATURE element? ((Boolean) DPoly $)) (SIGNATURE in? ((Boolean) $ $)) (SIGNATURE inRadical? ((Boolean) DPoly $)) (SIGNATURE zeroDim? ((Boolean) $ (List VarSet))) (SIGNATURE zeroDim? ((Boolean) $)) (SIGNATURE intersect ($ $ $)) (SIGNATURE intersect ($ (List $))) (SIGNATURE quotient ($ $ $)) (SIGNATURE quotient ($ $ DPoly)) (SIGNATURE groebner ($ $)) (SIGNATURE generalPosition ((Record (: mval (Matrix F)) (: invmval (Matrix F)) (: genIdeal $)) $ (List VarSet))) (SIGNATURE backOldPos ($ (Record (: mval (Matrix F)) (: invmval (Matrix F)) (: genIdeal $)))) (SIGNATURE dimension ((Integer) $ (List VarSet))) (SIGNATURE dimension ((Integer) $)) (SIGNATURE leadingIdeal ($ $)) (SIGNATURE ideal ($ (List DPoly))) (SIGNATURE groebnerIdeal ($ (List DPoly))) (SIGNATURE groebner? ((Boolean) $)) (SIGNATURE generators ((List DPoly) $)) (SIGNATURE coerce ($ (List DPoly))) (SIGNATURE saturate ($ $ DPoly)) (SIGNATURE saturate ($ $ DPoly (List VarSet))) (IF (has VarSet (ConvertibleTo (Symbol))) (SIGNATURE relationsIdeal ((SuchThat (List (Polynomial F)) (List (Equation (Polynomial F)))) (List DPoly))) noBranch))
      [3] contractGrob: not known that (PolynomialCategory F newExpon VarSet) is of mode (CATEGORY domain (IF (has F (IntegralDomain)) (IF (has newExpon (CancellationAbelianMonoid)) (SIGNATURE fmecg ($ $ newExpon F $)) noBranch) noBranch) (IF (has F (ATTRIBUTE canonicalUnitNormal)) (ATTRIBUTE canonicalUnitNormal) noBranch))
      [4] monomDim:  b has no value
      [5] monomDim:  a has no value
      [6] monomDim:  monvar has no value
      [7] **: :(NonNegativeInteger) -- should replace by pretend
      [8] relationsIdeal: not known that (OrderedAbelianMonoid) is of mode (CATEGORY domain (IF (has Expon (Finite)) (IF (has DirP (Finite)) (ATTRIBUTE (Finite)) noBranch) noBranch) (IF (has Expon (Monoid)) (IF (has DirP (Monoid)) (ATTRIBUTE (Monoid)) noBranch) noBranch) (IF (has Expon (AbelianMonoid)) (IF (has DirP (AbelianMonoid)) (ATTRIBUTE (AbelianMonoid)) noBranch) noBranch) (IF (has Expon (CancellationAbelianMonoid)) (IF (has DirP (CancellationAbelianMonoid)) (ATTRIBUTE (CancellationAbelianMonoid)) noBranch) noBranch) (IF (has Expon (Group)) (IF (has DirP (Group)) (ATTRIBUTE (Group)) noBranch) noBranch) (IF (has Expon (AbelianGroup)) (IF (has DirP (AbelianGroup)) (ATTRIBUTE (AbelianGroup)) noBranch) noBranch) (IF (has Expon (OrderedAbelianMonoidSup)) (IF (has DirP (OrderedAbelianMonoidSup)) (ATTRIBUTE (OrderedAbelianMonoidSup)) noBranch) noBranch) (IF (has Expon (OrderedSet)) (IF (has DirP (OrderedSet)) (ATTRIBUTE (OrderedSet)) noBranch) noBranch) (SIGNATURE makeprod ($ Expon DirP)) (SIGNATURE selectfirst (Expon $)) (SIGNATURE selectsecond (DirP $)))
      [9] relationsIdeal: not known that (OrderedAbelianMonoidSup) is of mode (CATEGORY domain (IF (has Expon (Finite)) (IF (has DirP (Finite)) (ATTRIBUTE (Finite)) noBranch) noBranch) (IF (has Expon (Monoid)) (IF (has DirP (Monoid)) (ATTRIBUTE (Monoid)) noBranch) noBranch) (IF (has Expon (AbelianMonoid)) (IF (has DirP (AbelianMonoid)) (ATTRIBUTE (AbelianMonoid)) noBranch) noBranch) (IF (has Expon (CancellationAbelianMonoid)) (IF (has DirP (CancellationAbelianMonoid)) (ATTRIBUTE (CancellationAbelianMonoid)) noBranch) noBranch) (IF (has Expon (Group)) (IF (has DirP (Group)) (ATTRIBUTE (Group)) noBranch) noBranch) (IF (has Expon (AbelianGroup)) (IF (has DirP (AbelianGroup)) (ATTRIBUTE (AbelianGroup)) noBranch) noBranch) (IF (has Expon (OrderedAbelianMonoidSup)) (IF (has DirP (OrderedAbelianMonoidSup)) (ATTRIBUTE (OrderedAbelianMonoidSup)) noBranch) noBranch) (IF (has Expon (OrderedSet)) (IF (has DirP (OrderedSet)) (ATTRIBUTE (OrderedSet)) noBranch) noBranch) (SIGNATURE makeprod ($ Expon DirP)) (SIGNATURE selectfirst (Expon $)) (SIGNATURE selectsecond (DirP $)))
      [10] relationsIdeal: not known that (PolynomialCategory F nExponent VarSet1) is of mode (CATEGORY domain (IF (has F (IntegralDomain)) (IF (has nExponent (CancellationAbelianMonoid)) (SIGNATURE fmecg ($ $ nExponent F $)) noBranch) noBranch) (IF (has F (ATTRIBUTE canonicalUnitNormal)) (ATTRIBUTE canonicalUnitNormal) noBranch))
      [11] relationsIdeal: :(Vector (NonNegativeInteger)) -- should replace by pretend
      [12] relationsIdeal: The conditional modes (Polynomial F) and nPoly conflict
 
=========================================================================
warnings 20281:

>compiling INFORM.spad to INFORM.nrlib

   Warnings: 
      [1] conv: pretend$ -- should replace by @
 
=========================================================================
warnings 20280:

>compiling IR.spad to IR.nrlib
 
   Warnings: 
      [1] nesimp:  IN has no value
      [2] nesimp:  ne has no value
      [3] *:  x1 has no value
      [4] *:  x2 has no value
      [5] differentiate:  x1 has no value
 
=========================================================================
warnings 20279:

>compiling ISUPS.spad to ISUPS.nrlib
 
   Warnings: 
      [1] map:  y has no value
      [2] map:  z has no value
      [3] differentiate:  n has no value
      [4] differentiate:  y has no value
      [5] differentiate:  z has no value
      [6] multiplyCoefficients:  n has no value
      [7] multiplyCoefficients:  y has no value
      [8] multiplyCoefficients:  z has no value
      [9] multiplyExponents:  y has no value
      [10] multiplyExponents:  z has no value
      [11] iPlus1:  x1 has no value
      [12] iPlus1:  z has no value
      [13] iPlus2:  z has no value
      [14] +:  xi has no value
      [15] +:  yi has no value
      [16] -:  xi has no value
      [17] -:  yi has no value
      [18] -:  x has no value
      [19] -:  z has no value
      [20] *:  z has no value
      [21] productByTerm:  y has no value
      [22] productByTerm:  z has no value
      [23] iTimes:  a has no value
      [24] iTimes:  b has no value
      [25] iDivide:  a has no value
      [26] iDivide:  b has no value
      [27] iExquo:  y1 has no value
      [28] iExquo:  z has no value
      [29] taylorQuoByVar:  y has no value
      [30] taylorQuoByVar:  z has no value
      [31] compose0:  s has no value
      [32] compose0:  m has no value
      [33] compose0:  a has no value
      [34] compose0:  b has no value
      [35] integrate:  n has no value
      [36] integrate:  y has no value
      [37] integrate:  z has no value
      [38] cPower:  s has no value
      [39] iExp:  s has no value
      [40] iSincos:  s has no value
      [41] tan0:  a has no value
      [42] tan0:  b has no value
      [43] iTan:  s has no value
      [44] cSin:  %sin has no value
      [45] cCos:  %cos has no value
      [46] sinhcosh:  %sin has no value
      [47] sinhcosh:  %cos has no value
      [48] cSinh:  %sinh has no value
      [49] cCosh:  %cosh has no value
 
=========================================================================
warnings 20278:

>compiling LMDICT.spad to LMDICT.nrlib
 
   Warnings: 
      [1] substitute:  z1 has no value
      [2] select!:  z has no value
 
=========================================================================
warnings 20277:

>compiling LODOOPS.spad to LODOOPS.nrlib
 
   Warnings: 
      [1] nonTrivial?:  x1 has no value
      [2] killer: not known that (Ring) is of mode (CATEGORY package (SIGNATURE symmetricProduct (L L L (Mapping A A))) (SIGNATURE symmetricPower (L L (NonNegativeInteger) (Mapping A A))) (SIGNATURE directSum (L L L (Mapping A A))))
 
=========================================================================
warnings 20276:

>compiling MATRIX.spad to MATRIX.nrlib
 
   Warnings: 
      [1] positivePower: pretend(Matrix R) -- should replace by @
      [2] determinant: not known that (CommutativeRing) is of mode (CATEGORY R (ATTRIBUTE (commutative *)))
 

=========================================================================
warnings 20275:

>compiling MKFLCFN.spad to MKFLCFN.nrlib
 
   Warnings: 
      [1] mkLisp: pretend(InputForm) -- should replace by @
 
=========================================================================
warnings 20274:

>compiling MSET.spad to MSET.nrlib
 
   Warnings: 
      [1] select!:  s1 has no value
      [2] intersect:  n has no value
      [3] difference:  n has no value
 
=========================================================================
warnings 20273:

>compiling M3D.spad to M3D.nrlib
 
   Warnings: 
      [1] matrixConcat3D:  retVal has no value
 
=========================================================================
warnings 20272:

>compiling NAGC02.spad to NAGC02.nrlib
 
   Warnings: 
      [1] c02aff: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [2] c02agf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
 
=========================================================================
warnings 20271:

>compiling NAGC05.spad to NAGC05.nrlib
 
   Warnings: 
      [1] c05adf:  fn has no value
      [2] c05adf:  fp has no value
      [3] c05adf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [4] c05nbf:  fn has no value
      [5] c05nbf:  fp has no value
      [6] c05nbf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [7] c05pbf:  fn has no value
      [8] c05pbf:  fp has no value
      [9] c05pbf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @

=========================================================================
warnings 20270:

>compiling NAGC06.spad to NAGC06.nrlib

   Warnings: 
      [1] c06eaf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [2] c06ebf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [3] c06ecf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [4] c06ekf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [5] c06fpf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [6] c06fqf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [7] c06frf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [8] c06fuf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [9] c06gbf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [10] c06gcf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [11] c06gqf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [12] c06gsf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @

=========================================================================
warnings 20269:

>compiling NAGD01.spad to NAGD01.nrlib
 
   Warnings: 
      [1] d01ajf:  fn has no value
      [2] d01ajf:  fp has no value
      [3] d01ajf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [4] d01akf:  fn has no value
      [5] d01akf:  fp has no value
      [6] d01akf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [7] d01alf:  fn has no value
      [8] d01alf:  fp has no value
      [9] d01alf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [10] d01amf:  fn has no value
      [11] d01amf:  fp has no value
      [12] d01amf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [13] d01anf:  fn has no value
      [14] d01anf:  fp has no value
      [15] d01anf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [16] d01apf:  fn has no value
      [17] d01apf:  fp has no value
      [18] d01apf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [19] d01aqf:  fn has no value
      [20] d01aqf:  fp has no value
      [21] d01aqf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [22] d01asf:  fn has no value
      [23] d01asf:  fp has no value
      [24] d01asf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [25] d01bbf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [26] d01fcf:  fn has no value
      [27] d01fcf:  fp has no value
      [28] d01fcf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [29] d01gaf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [30] d01gbf:  fn has no value
      [31] d01gbf:  fp has no value
      [32] d01gbf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @

=========================================================================
warnings 20268:

>compiling NAGD02.spad to NAGD02.nrlib
 
   Warnings: 
      [1] d02bbf:  fn has no value
      [2] d02bbf:  fp has no value
      [3] d02bbf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [4] d02bhf:  fn has no value
      [5] d02bhf:  fp has no value
      [6] d02bhf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [7] d02cjf:  fn has no value
      [8] d02cjf:  fp has no value
      [9] d02cjf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [10] d02ejf:  fn has no value
      [11] d02ejf:  fp has no value
      [12] d02ejf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [13] d02gaf:  fn has no value
      [14] d02gaf:  fp has no value
      [15] d02gaf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [16] d02gbf:  fn has no value
      [17] d02gbf:  fp has no value
      [18] d02gbf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [19] d02kef:  fn has no value
      [20] d02kef:  fp has no value
      [21] d02kef: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [22] d02raf:  fn has no value
      [23] d02raf:  fp has no value
      [24] d02raf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @

=========================================================================
warnings 20267:

>compiling NAGD03.spad to NAGD03.nrlib
 
   Warnings: 
      [1] d03edf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [2] d03eef:  fn has no value
      [3] d03eef:  fp has no value
      [4] d03eef: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [5] d03faf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @

=========================================================================
warnings 20266:

>compiling NAGE01.spad to NAGE01.nrlib
 
   Warnings: 
      [1] e01baf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [2] e01bef: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [3] e01bff: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [4] e01bgf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [5] e01bhf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [6] e01daf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [7] e01saf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [8] e01sbf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [9] e01sef: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [10] e01sff: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
 

=========================================================================
warnings 20265:

>compiling NAGE02.spad to NAGE02.nrlib
 
   Warnings: 
      [1] e02adf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [2] e02aef: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [3] e02agf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [4] e02ahf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [5] e02ajf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [6] e02akf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [7] e02baf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [8] e02bbf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [9] e02bcf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [10] e02bdf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [11] e02bef: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [12] e02daf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [13] e02dcf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [14] e02ddf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [15] e02def: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [16] e02dff: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [17] e02gaf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [18] e02zaf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
 
=========================================================================
warnings 20264:

>compiling NAGE04.spad to NAGE04.nrlib
 
   Warnings: 
      [1] e04dgf:  fn has no value
      [2] e04dgf:  fp has no value
      [3] e04dgf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [4] e04fdf:  fn has no value
      [5] e04fdf:  fp has no value
      [6] e04fdf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [7] e04gcf:  fn has no value
      [8] e04gcf:  fp has no value
      [9] e04gcf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [10] e04jaf:  fn has no value
      [11] e04jaf:  fp has no value
      [12] e04jaf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [13] e04mbf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [14] e04naf:  fn has no value
      [15] e04naf:  fp has no value
      [16] e04naf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [17] e04ucf:  fn has no value
      [18] e04ucf:  fp has no value
      [19] e04ucf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [20] e04ycf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @

=========================================================================
warnings 20263:

>compiling NAGF07.spad to NAGF07.nrlib
 
   Warnings: 
      [1] f07adf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [2] f07aef: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [3] f07fdf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [4] f07fef: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @

=========================================================================
warnings 20262:

>compiling NAGS.spad to NAGS.nrlib
 
   Warnings: 
      [1] s01eaf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [2] s13aaf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [3] s13acf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [4] s13adf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [5] s14aaf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [6] s14abf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [7] s14baf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [8] s15adf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [9] s15aef: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [10] s17acf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [11] s17adf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [12] s17aef: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [13] s17aff: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [14] s17agf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [15] s17ahf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [16] s17ajf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [17] s17akf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [18] s17dcf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [19] s17def: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [20] s17dgf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [21] s17dhf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [22] s17dlf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [23] s18acf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [24] s18adf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [25] s18aef: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [26] s18aff: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [27] s18dcf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [28] s18def: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [29] s19aaf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [30] s19abf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [31] s19acf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [32] s19adf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [33] s20acf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [34] s20adf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [35] s21baf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [36] s21bbf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [37] s21bcf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [38] s21bdf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
 
=========================================================================
warnings 20261:

>compiling NAGSP.spad to NAGSP.nrlib
 
   Warnings: 
      [1] getUniqueId:  uniqueId has no value
 
=========================================================================
warnings 20260:

>compiling NSDPS.spad to NSDPS.nrlib
 
   Warnings: 
      [1] removeZeroes:  c has no value
      [2] iDiv:  c has no value
      [3] iDiv:  k has no value
      [4] sbt:  k has no value
      [5] sbt:  c has no value
      [6] shift:  k has no value
      [7] shift:  c has no value
      [8] +:  k has no value
      [9] +:  c has no value
      [10] multC:  k has no value
      [11] multC:  c has no value
      [12] *:  k has no value
      [13] *:  c has no value
 
=========================================================================
warnings 20259:

>compiling NUMFMT.spad to NUMFMT.nrlib
 
   Warnings: 
      [1] check:  c1 has no value
      [2] check:  c2 has no value
      [3] ScanRoman:  nprens has no value
 
=========================================================================
warnings 20258:

>compiling ODERAT.spad to ODERAT.nrlib
 
   Warnings: 
      [1] ratDsolve1: not known that (Ring) is of mode (CATEGORY package (SIGNATURE ratDsolve ((Record (: particular (Union (Fraction UP) failed)) (: basis (List (Fraction UP)))) (LinearOrdinaryDifferentialOperator1 (Fraction UP)) (Fraction UP))) (SIGNATURE ratDsolve ((Record (: basis (List (Fraction UP))) (: mat (Matrix F))) (LinearOrdinaryDifferentialOperator1 (Fraction UP)) (List (Fraction UP)))) (SIGNATURE ratDsolve ((Record (: particular (Union (Fraction UP) failed)) (: basis (List (Fraction UP)))) (LinearOrdinaryDifferentialOperator2 UP (Fraction UP)) (Fraction UP))) (SIGNATURE ratDsolve ((Record (: basis (List (Fraction UP))) (: mat (Matrix F))) (LinearOrdinaryDifferentialOperator2 UP (Fraction UP)) (List (Fraction UP)))) (SIGNATURE indicialEquationAtInfinity (UP (LinearOrdinaryDifferentialOperator1 (Fraction UP)))) (SIGNATURE indicialEquationAtInfinity (UP (LinearOrdinaryDifferentialOperator2 UP (Fraction UP)))))
      [2] ratDsolve0:  b has no value
      [3] candidates:  l1 has no value
      [4] infMuLambda:  lamb has no value
      [5] infMuLambda:  lf has no value

=========================================================================
warnings 20257:

>compiling OMERRK.spad to OMERRK.nrlib
 
   Warnings: 
      [1] OMParseError?:  parseError has no value
      [2] OMUnknownCD?:  unknownCD has no value
      [3] OMUnknownSymbol?:  unknownSymbol has no value
      [4] OMReadError?:  readError has no value
      [5] coerce:  OMParseError has no value
      [6] coerce:  OMUnknownCD has no value
      [7] coerce:  OMUnknownSymbol has no value
      [8] coerce:  OMReadError has no value

=========================================================================
warnings 20256:

>compiling OPTPACK.spad to OPTPACK.nrlib
 
   Warnings: 
      [1] constant:  noa has no value
      [2] measureSpecific:  noa has no value
      [3] measureSpecific:  lsa has no value
      [4] optimizeSpecific:  noa has no value
      [5] optimizeSpecific:  lsa has no value
      [6] goodnessOfFit:  lsa has no value
      [7] goodnessOfFit:  method has no value
      [8] goodnessOfFit:  nameOfRoutine has no value
      [9] goodnessOfFit:  w has no value
      [10] goodnessOfFit:  objf has no value
 
=========================================================================
warnings 20255:

>compiling OSI.spad to OSI.nrlib
 
   Warnings: 
      [1] value: :Rep -- should replace by pretend
 
=========================================================================
warnings 20254:

>compiling PACOFF.spad to PACOFF.nrlib
 
   Warnings: 
      [1] repPolynomial: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [2] vectorise: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [3] localRandom:  recTower has no value
      [4] +:  recEl has no value
      [5] *:  recEl has no value
      [6] *:  recTower has no value
      [7] -: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [8] coerce: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [9] fullOutput: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [10] definingPolynomial: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [11] extDegree: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [12] previousTower: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [13] name: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [14] down: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
 
=========================================================================
warnings 20253:

>compiling PACRAT.spad to PACRAT.nrlib
 
   Warnings: 
      [1] down: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [2] lift: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [3] reduce: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [4] vectorise: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [5] +:  recEl has no value
      [6] *:  recEl has no value
      [7] *:  recTower has no value
      [8] inv: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [9] -: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [10] coerce: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [11] fullOutput: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [12] definingPolynomial: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [13] extDegree: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [14] previousTower: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [15] name: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
 
=========================================================================
warnings 20252:

>compiling PATTERN.spad to PATTERN.nrlib
 
   Warnings: 
      [1] quoted?:  sym has no value
      [2] generic?:  sym has no value
      [3] multiple?:  sym has no value
      [4] optional?:  sym has no value
      [5] =: pretend(Boolean) -- should replace by @
      [6] isOp:  ker has no value
      [7] variables:  exp has no value
      [8] variables:  qot has no value
      [9] variables:  ker has no value
      [10] PAT2O:  ret has no value
      [11] PAT2O:  sym has no value
      [12] PAT2O:  exp has no value
      [13] PAT2O:  qot has no value
      [14] PAT2O:  ker has no value
      [15] patcopy:  ret has no value
      [16] patcopy:  sym has no value
      [17] patcopy:  ker has no value
      [18] patcopy:  qot has no value
      [19] patcopy:  exp has no value
      [20] pateq?:  ret has no value
      [21] pateq?:  qot has no value
      [22] pateq?:  sym has no value
      [23] pateq?:  ker has no value
      [24] pateq?:  exp has no value
 
=========================================================================
warnings 20251:

>compiling PLCS.spad to PLCS.nrlib
 
   Warnings: 
      [1]  ActualSetOfPlacesName has no value
      [2] =: The conditional modes (String) and $ conflict
      [3] setFoundPlacesToEmpty:  ActualSetOfPlacesName has no value
      [4] create:  SIMPLE has no value
 
=========================================================================
warnings 20250:

>compiling PMKERNEL.spad to PMKERNEL.nrlib
 
   Warnings: 
      [1] patternMatchArg: not known that (SetCategory) is of mode (CATEGORY package (SIGNATURE patternMatch ((PatternMatchResult S E) (Kernel E) (Pattern S) (PatternMatchResult S E))))
      [2] patternMatchInner: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE patternMatch ((PatternMatchResult S E) (Kernel E) (Pattern S) (PatternMatchResult S E))))
 
=========================================================================
warnings 20249:

>compiling PRIMELT.spad to PRIMELT.nrlib
 
   Warnings: 
      [1] multi:  f1 has no value
      [2] incl?:  s1 has no value
      [3] triangularLinearIfCan: not known that (Ring) is of mode (CATEGORY package (SIGNATURE primitiveElement ((Record (: coef1 (Integer)) (: coef2 (Integer)) (: prim (SparseUnivariatePolynomial F))) (Polynomial F) (Symbol) (Polynomial F) (Symbol))) (SIGNATURE primitiveElement ((Record (: coef (List (Integer))) (: poly (List (SparseUnivariatePolynomial F))) (: prim (SparseUnivariatePolynomial F))) (List (Polynomial F)) (List (Symbol)))) (SIGNATURE primitiveElement ((Record (: coef (List (Integer))) (: poly (List (SparseUnivariatePolynomial F))) (: prim (SparseUnivariatePolynomial F))) (List (Polynomial F)) (List (Symbol)) (Symbol))))
      [4] triangularLinearIfCan:  z1 has no value
      [5] triangularLinearIfCan:  f1 has no value
 
=========================================================================
warnings 20248:

>compiling QALGSET2.spad to QALGSET2.nrlib
 
   Warnings: 
      [1] npoly:  z1 has no value
      [2] npoly:  z2 has no value
      [3] npoly: not known that (PolynomialCategory (Fraction (Integer)) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl)) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [4] oldpoly:  z1 has no value
      [5] oldpoly:  z2 has no value
      [6] radicalSimplify: not known that (PolynomialCategory (Fraction (Integer)) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl)) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [7] radicalSimplify:  gb has no value
 
=========================================================================
warnings 20247:

>compiling RECLOS.spad to RECLOS.nrlib
 
   Warnings: 
      [1] *:  z has no value
 
=========================================================================
warnings 20246:

>compiling REP1.spad to REP1.nrlib
 
   Warnings: 
      [1] antisymmetricTensors: not known that (Ring) is of mode (CATEGORY R (ATTRIBUTE (commutative *)))
 
=========================================================================
warnings 20245:

>compiling RFFACT.spad to RFFACT.nrlib
 
   Warnings: 
      [1] likuniv:  y has no value
      [2] likuniv: not known that (Ring) is of mode (CATEGORY package (SIGNATURE factor ((Factored UP) UP)))
      [3] factor:  x has no value
 
=========================================================================
warnings 20244:

>compiling RPOLCAT.spad to RPOLCAT.nrlib
 
   Warnings: 
      [1] mainCoefficients: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE coerce (S S)) (SIGNATURE gcd (S S S)) (SIGNATURE gcd (S (List S))) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE coerce ((Polynomial R) S)) (SIGNATURE convert ((Polynomial R) S)) (SIGNATURE convert ((String) S)) (SIGNATURE mainSquareFreePart (S S)) (SIGNATURE mainPrimitivePart (S S)) (SIGNATURE mainContent (S S)) (SIGNATURE primitivePart! (S S)) (SIGNATURE gcd (R R S)) (SIGNATURE exactQuotient! (S S S)) (SIGNATURE exactQuotient (S S S)) (SIGNATURE exactQuotient! (S S R)) (SIGNATURE exactQuotient (S S R)) (SIGNATURE primPartElseUnitCanonical! (S S)) (SIGNATURE primPartElseUnitCanonical (S S)) (SIGNATURE convert (S (Polynomial R))) (SIGNATURE retract (S (Polynomial R))) (SIGNATURE retractIfCan ((Union S failed) (Polynomial R))) (SIGNATURE convert (S (Polynomial (Integer)))) (SIGNATURE retract (S (Polynomial (Integer)))) (SIGNATURE retractIfCan ((Union S failed) (Polynomial (Integer)))) (SIGNATURE convert (S (Polynomial (Fraction (Integer))))) (SIGNATURE retract (S (Polynomial (Fraction (Integer))))) (SIGNATURE retractIfCan ((Union S failed) (Polynomial (Fraction (Integer))))) (SIGNATURE initiallyReduce (S S S)) (SIGNATURE headReduce (S S S)) (SIGNATURE lazyResidueClass ((Record (: polnum S) (: polden S) (: power (NonNegativeInteger))) S S)) (SIGNATURE monicModulo (S S S)) (SIGNATURE pseudoDivide ((Record (: quotient S) (: remainder S)) S S)) (SIGNATURE lazyPseudoDivide ((Record (: coef S) (: gap (NonNegativeInteger)) (: quotient S) (: remainder S)) S S V)) (SIGNATURE lazyPseudoDivide ((Record (: coef S) (: gap (NonNegativeInteger)) (: quotient S) (: remainder S)) S S)) (SIGNATURE lazyPremWithDefault ((Record (: coef S) (: gap (NonNegativeInteger)) (: remainder S)) S S V)) (SIGNATURE lazyPremWithDefault ((Record (: coef S) (: gap (NonNegativeInteger)) (: remainder S)) S S)) (SIGNATURE lazyPquo (S S S V)) (SIGNATURE lazyPrem (S S S V)) (SIGNATURE lazyPquo (S S S)) (SIGNATURE lazyPrem (S S S)) (SIGNATURE pquo (S S S V)) (SIGNATURE prem (S S S V)) (SIGNATURE pquo (S S S)) (SIGNATURE prem (S S S)) (SIGNATURE normalized? ((Boolean) S (List S))) (SIGNATURE normalized? ((Boolean) S S)) (SIGNATURE initiallyReduced? ((Boolean) S (List S))) (SIGNATURE initiallyReduced? ((Boolean) S S)) (SIGNATURE headReduced? ((Boolean) S (List S))) (SIGNATURE headReduced? ((Boolean) S S)) (SIGNATURE reduced? ((Boolean) S (List S))) (SIGNATURE reduced? ((Boolean) S S)) (SIGNATURE supRittWu? ((Boolean) S S)) (SIGNATURE infRittWu? ((Boolean) S S)) (SIGNATURE RittWuCompare ((Union (Boolean) failed) S S)) (SIGNATURE mainMonomials ((List S) S)) (SIGNATURE mainCoefficients ((List S) S)) (SIGNATURE leastMonomial (S S)) (SIGNATURE mainMonomial (S S)) (SIGNATURE quasiMonic? ((Boolean) S)) (SIGNATURE monic? ((Boolean) S)) (SIGNATURE reductum (S S V)) (SIGNATURE leadingCoefficient (S S V)) (SIGNATURE deepestInitial (S S)) (SIGNATURE iteratedInitials ((List S) S)) (SIGNATURE deepestTail (S S)) (SIGNATURE tail (S S)) (SIGNATURE head (S S)) (SIGNATURE init (S S)) (SIGNATURE mdeg ((NonNegativeInteger) S)) (SIGNATURE mvar (V S)) (SIGNATURE convert ((InputForm) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE retract (V S)) (SIGNATURE retractIfCan ((Union V failed) S)) (SIGNATURE coerce (S V)) (SIGNATURE leadingCoefficient (R S)) (SIGNATURE reductum (S S)) (SIGNATURE retract ((Integer) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE coerce (S R)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retract (R S)) (SIGNATURE coerce (S (Integer))) (SIGNATURE coerce ((OutputForm) S)))
      [2] convert:  stpol has no value
 
=========================================================================
warnings 20243:

>compiling SWITCH.spad to SWITCH.nrlib
 
   Warnings: 
      [1]  NULL has no value

=========================================================================
warnings 20242:

>compiling SYMTAB.spad to SYMTAB.nrlib
 
   Warnings: 
      [1] typeList:  fst has no value
      [2] typeList2:  fst has no value
      [3] newTypeLists:  fst has no value
      [4] oForm2:  S has no value
      [5] oForm2:  P has no value
      [6] oForm:  bounds has no value

=========================================================================
warnings 20241:

>compiling SYSSOLP.spad to SYSSOLP.nrlib
 
   Warnings: 
      [1] makeEq: not known that (Ring) is of mode (CATEGORY package (SIGNATURE solve ((List (List (Equation (Fraction (Polynomial R))))) (List (Fraction (Polynomial R))) (List (Symbol)))) (SIGNATURE solve ((List (List (Equation (Fraction (Polynomial R))))) (List (Equation (Fraction (Polynomial R)))) (List (Symbol)))) (SIGNATURE solve ((List (List (Equation (Fraction (Polynomial R))))) (List (Fraction (Polynomial R))))) (SIGNATURE solve ((List (List (Equation (Fraction (Polynomial R))))) (List (Equation (Fraction (Polynomial R)))))) (SIGNATURE solve ((List (Equation (Fraction (Polynomial R)))) (Fraction (Polynomial R)) (Symbol))) (SIGNATURE solve ((List (Equation (Fraction (Polynomial R)))) (Equation (Fraction (Polynomial R))) (Symbol))) (SIGNATURE solve ((List (Equation (Fraction (Polynomial R)))) (Fraction (Polynomial R)))) (SIGNATURE solve ((List (Equation (Fraction (Polynomial R)))) (Equation (Fraction (Polynomial R))))) (SIGNATURE triangularSystems ((List (List (Polynomial R))) (List (Fraction (Polynomial R))) (List (Symbol)))))
      [2] triangularSystems: not known that (SIGNATURE variable ((Union $ failed) (Symbol))) is of mode (CATEGORY domain (SIGNATURE new ($)) (SIGNATURE new ($ $)) (SIGNATURE resetNew ((Void))) (SIGNATURE coerce ($ (String))) (SIGNATURE name ($ $)) (SIGNATURE scripted? ((Boolean) $)) (SIGNATURE scripts ((Record (: sub (List (OutputForm))) (: sup (List (OutputForm))) (: presup (List (OutputForm))) (: presub (List (OutputForm))) (: args (List (OutputForm)))) $)) (SIGNATURE script ($ $ (List (List (OutputForm))))) (SIGNATURE script ($ $ (Record (: sub (List (OutputForm))) (: sup (List (OutputForm))) (: presup (List (OutputForm))) (: presub (List (OutputForm))) (: args (List (OutputForm)))))) (SIGNATURE subscript ($ $ (List (OutputForm)))) (SIGNATURE superscript ($ $ (List (OutputForm)))) (SIGNATURE argscript ($ $ (List (OutputForm)))) (SIGNATURE elt ($ $ (List (OutputForm)))) (SIGNATURE string ((String) $)) (SIGNATURE list ((List $) $)) (SIGNATURE sample ($) constant))
      [3] triangularSystems: not known that (PolynomialCategory (Polynomial R) DP OV) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [4] triangularSystems: not known that (PolynomialCategory (Polynomial R) (DirectProduct (# lv) (NonNegativeInteger)) OV) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [5] triangularSystems: not known that (PolynomialCategory (Polynomial R) (DirectProduct (call LENGTH lv) (NonNegativeInteger)) OV) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
 

=========================================================================
warnings 20240:

>compiling UTSCAT.spad to UTSCAT.nrlib
 
   Warnings: 
      [1] coerce:  l has no value

=========================================================================
warnings 20239:

>compiling ACFS.spad to ACFS.nrlib
 
   Warnings: 
      [1] zeroOf: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE zerosOf ((List S) S (Symbol))) (SIGNATURE zeroOf (S S (Symbol))) (SIGNATURE zerosOf ((List S) S)) (SIGNATURE zeroOf (S S)) (SIGNATURE rootsOf ((List S) S (Symbol))) (SIGNATURE rootOf (S S (Symbol))) (SIGNATURE rootsOf ((List S) S)) (SIGNATURE rootOf (S S)) (SIGNATURE zerosOf ((List S) (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE zerosOf ((List S) (SparseUnivariatePolynomial S))) (SIGNATURE zerosOf ((List S) (Polynomial S))) (SIGNATURE zeroOf (S (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE zeroOf (S (SparseUnivariatePolynomial S))) (SIGNATURE zeroOf (S (Polynomial S))) (SIGNATURE rootsOf ((List S) (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE rootsOf ((List S) (SparseUnivariatePolynomial S))) (SIGNATURE rootsOf ((List S) (Polynomial S))) (SIGNATURE rootOf (S (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE rootOf (S (SparseUnivariatePolynomial S))) (SIGNATURE rootOf (S (Polynomial S))))
      [2] zeroOf: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE zerosOf ((List S) S (Symbol))) (SIGNATURE zeroOf (S S (Symbol))) (SIGNATURE zerosOf ((List S) S)) (SIGNATURE zeroOf (S S)) (SIGNATURE rootsOf ((List S) S (Symbol))) (SIGNATURE rootOf (S S (Symbol))) (SIGNATURE rootsOf ((List S) S)) (SIGNATURE rootOf (S S)) (SIGNATURE zerosOf ((List S) (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE zerosOf ((List S) (SparseUnivariatePolynomial S))) (SIGNATURE zerosOf ((List S) (Polynomial S))) (SIGNATURE zeroOf (S (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE zeroOf (S (SparseUnivariatePolynomial S))) (SIGNATURE zeroOf (S (Polynomial S))) (SIGNATURE rootsOf ((List S) (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE rootsOf ((List S) (SparseUnivariatePolynomial S))) (SIGNATURE rootsOf ((List S) (Polynomial S))) (SIGNATURE rootOf (S (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE rootOf (S (SparseUnivariatePolynomial S))) (SIGNATURE rootOf (S (Polynomial S))))
      [3] not known that (Ring) is of mode (CATEGORY domain (SIGNATURE zerosOf ((List S) S (Symbol))) (SIGNATURE zeroOf (S S (Symbol))) (SIGNATURE zerosOf ((List S) S)) (SIGNATURE zeroOf (S S)) (SIGNATURE rootsOf ((List S) S (Symbol))) (SIGNATURE rootOf (S S (Symbol))) (SIGNATURE rootsOf ((List S) S)) (SIGNATURE rootOf (S S)) (SIGNATURE zerosOf ((List S) (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE zerosOf ((List S) (SparseUnivariatePolynomial S))) (SIGNATURE zerosOf ((List S) (Polynomial S))) (SIGNATURE zeroOf (S (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE zeroOf (S (SparseUnivariatePolynomial S))) (SIGNATURE zeroOf (S (Polynomial S))) (SIGNATURE rootsOf ((List S) (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE rootsOf ((List S) (SparseUnivariatePolynomial S))) (SIGNATURE rootsOf ((List S) (Polynomial S))) (SIGNATURE rootOf (S (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE rootOf (S (SparseUnivariatePolynomial S))) (SIGNATURE rootOf (S (Polynomial S))))
 
=========================================================================
warnings 20238:

>compiling AF.spad to AF.nrlib
 
   Warnings: 
      [1] rootOf: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE rootOf (F (SparseUnivariatePolynomial F) (Symbol))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE inrootof (F (SparseUnivariatePolynomial F) F)) (SIGNATURE droot ((OutputForm) (List F))) (IF (has R (RetractableTo (Integer))) (PROGN (SIGNATURE ** (F F (Fraction (Integer)))) (SIGNATURE minPoly ((SparseUnivariatePolynomial F) (Kernel F))) (SIGNATURE definingPolynomial (F F)) (SIGNATURE iroot (F R (Integer)))) noBranch))
      [2] rootOf: not known that (Ring) is of mode (CATEGORY package (SIGNATURE rootOf (F (SparseUnivariatePolynomial F) (Symbol))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE inrootof (F (SparseUnivariatePolynomial F) F)) (SIGNATURE droot ((OutputForm) (List F))) (IF (has R (RetractableTo (Integer))) (PROGN (SIGNATURE ** (F F (Fraction (Integer)))) (SIGNATURE minPoly ((SparseUnivariatePolynomial F) (Kernel F))) (SIGNATURE definingPolynomial (F F)) (SIGNATURE iroot (F R (Integer)))) noBranch))
      [3] dvalg:  s has no value
      [4] inrootof: not known that (Ring) is of mode (CATEGORY package (SIGNATURE rootOf (F (SparseUnivariatePolynomial F) (Symbol))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE inrootof (F (SparseUnivariatePolynomial F) F)) (SIGNATURE droot ((OutputForm) (List F))) (IF (has R (RetractableTo (Integer))) (PROGN (SIGNATURE ** (F F (Fraction (Integer)))) (SIGNATURE minPoly ((SparseUnivariatePolynomial F) (Kernel F))) (SIGNATURE definingPolynomial (F F)) (SIGNATURE iroot (F R (Integer)))) noBranch))
      [5] hackroot: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE iroot (F R (Integer))))
      [6] inroot0:  rn has no value
      [7] inroot0:  coef has no value
      [8] inroot0:  radicand has no value
      [9] inroot0:  exponent has no value
      [10] inroot0:  rd has no value
 
=========================================================================
warnings 20237:

>compiling ALGFACT.spad to ALGFACT.nrlib
 
   Warnings: 
      [1] allk: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE factor ((Factored UP) UP (List (AlgebraicNumber)))) (SIGNATURE factor ((Factored UP) UP)) (SIGNATURE split ((Factored UP) UP)) (SIGNATURE doublyTransitive? ((Boolean) UP)))
      [2] liftpoly:  x has no value
      [3] downpoly:  x has no value
      [4] extend: not known that (Ring) is of mode (CATEGORY package (SIGNATURE factor ((Factored UP) UP (List (AlgebraicNumber)))) (SIGNATURE factor ((Factored UP) UP)) (SIGNATURE split ((Factored UP) UP)) (SIGNATURE doublyTransitive? ((Boolean) UP)))
      [5] fact: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE factor ((Factored UP) UP (List (AlgebraicNumber)))) (SIGNATURE factor ((Factored UP) UP)) (SIGNATURE split ((Factored UP) UP)) (SIGNATURE doublyTransitive? ((Boolean) UP)))
      [6] fact:  x has no value
      [7] fact: not known that (SIGNATURE coerce ($ (SparseMultivariatePolynomial (Integer) (Kernel (AlgebraicNumber))))) is of mode (CATEGORY domain (SIGNATURE coerce ($ (SparseMultivariatePolynomial (Integer) (Kernel $)))) (SIGNATURE numer ((SparseMultivariatePolynomial (Integer) (Kernel $)) $)) (SIGNATURE denom ((SparseMultivariatePolynomial (Integer) (Kernel $)) $)) (SIGNATURE reduce ($ $)) (SIGNATURE norm ((SparseUnivariatePolynomial $) (SparseUnivariatePolynomial $) (Kernel $))) (SIGNATURE norm ((SparseUnivariatePolynomial $) (SparseUnivariatePolynomial $) (List (Kernel $)))) (SIGNATURE norm ($ $ (Kernel $))) (SIGNATURE norm ($ $ (List (Kernel $)))))
      [8] fact: not known that (SIGNATURE numer ((SparseMultivariatePolynomial (Integer) (Kernel (AlgebraicNumber))) $)) is of mode (CATEGORY domain (SIGNATURE coerce ($ (SparseMultivariatePolynomial (Integer) (Kernel $)))) (SIGNATURE numer ((SparseMultivariatePolynomial (Integer) (Kernel $)) $)) (SIGNATURE denom ((SparseMultivariatePolynomial (Integer) (Kernel $)) $)) (SIGNATURE reduce ($ $)) (SIGNATURE norm ((SparseUnivariatePolynomial $) (SparseUnivariatePolynomial $) (Kernel $))) (SIGNATURE norm ((SparseUnivariatePolynomial $) (SparseUnivariatePolynomial $) (List (Kernel $)))) (SIGNATURE norm ($ $ (Kernel $))) (SIGNATURE norm ($ $ (List (Kernel $)))))
      [9] fact: not known that (SIGNATURE denom ((SparseMultivariatePolynomial (Integer) (Kernel (AlgebraicNumber))) $)) is of mode (CATEGORY domain (SIGNATURE coerce ($ (SparseMultivariatePolynomial (Integer) (Kernel $)))) (SIGNATURE numer ((SparseMultivariatePolynomial (Integer) (Kernel $)) $)) (SIGNATURE denom ((SparseMultivariatePolynomial (Integer) (Kernel $)) $)) (SIGNATURE reduce ($ $)) (SIGNATURE norm ((SparseUnivariatePolynomial $) (SparseUnivariatePolynomial $) (Kernel $))) (SIGNATURE norm ((SparseUnivariatePolynomial $) (SparseUnivariatePolynomial $) (List (Kernel $)))) (SIGNATURE norm ($ $ (Kernel $))) (SIGNATURE norm ($ $ (List (Kernel $)))))
      [10] fact:  y has no value
 
=========================================================================
warnings 20236:

>compiling ALGFF.spad to ALGFF.nrlib
 
   Warnings: 
      [1] getInfBasis:  s has no value
 
=========================================================================
warnings 20235:

>compiling ALGMANIP.spad to ALGMANIP.nrlib
 
   Warnings: 
      [1] ratDenom: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE rootSplit (F F)) (SIGNATURE ratDenom (F F)) (SIGNATURE ratDenom (F F F)) (SIGNATURE ratDenom (F F (List F))) (SIGNATURE ratDenom (F F (List (Kernel F)))) (SIGNATURE ratPoly ((SparseUnivariatePolynomial F) F)) (IF (has R (OrderedSet)) (IF (has R (GcdDomain)) (IF (has R (RetractableTo (Integer))) (IF (has F (FunctionSpace R)) (PROGN (SIGNATURE rootPower (F F)) (SIGNATURE rootProduct (F F)) (SIGNATURE rootSimp (F F)) (SIGNATURE rootKerSimp (F (BasicOperator) F (NonNegativeInteger)))) noBranch) noBranch) noBranch) noBranch))
      [2] algkernels:  z1 has no value
      [3] rootkernels:  z1 has no value
      [4] ratPoly: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE rootSplit (F F)) (SIGNATURE ratDenom (F F)) (SIGNATURE ratDenom (F F F)) (SIGNATURE ratDenom (F F (List F))) (SIGNATURE ratDenom (F F (List (Kernel F)))) (SIGNATURE ratPoly ((SparseUnivariatePolynomial F) F)) (IF (has R (OrderedSet)) (IF (has R (GcdDomain)) (IF (has R (RetractableTo (Integer))) (IF (has F (FunctionSpace R)) (PROGN (SIGNATURE rootPower (F F)) (SIGNATURE rootProduct (F F)) (SIGNATURE rootSimp (F F)) (SIGNATURE rootKerSimp (F (BasicOperator) F (NonNegativeInteger)))) noBranch) noBranch) noBranch) noBranch))
      [5] ratPoly: not known that (SIGNATURE coerce ($ (SparseMultivariatePolynomial R (Kernel F)))) is of mode (CATEGORY domain (SIGNATURE numer ((SparseMultivariatePolynomial R (Kernel $)) $)) (SIGNATURE denom ((SparseMultivariatePolynomial R (Kernel $)) $)) (SIGNATURE coerce ($ (SparseMultivariatePolynomial R (Kernel $)))))
      [6] ratPoly: not known that (SIGNATURE numer ((SparseMultivariatePolynomial R (Kernel F)) $)) is of mode (CATEGORY domain (SIGNATURE numer ((SparseMultivariatePolynomial R (Kernel $)) $)) (SIGNATURE denom ((SparseMultivariatePolynomial R (Kernel $)) $)) (SIGNATURE coerce ($ (SparseMultivariatePolynomial R (Kernel $)))))
      [7] ratPoly: not known that (SIGNATURE denom ((SparseMultivariatePolynomial R (Kernel F)) $)) is of mode (CATEGORY domain (SIGNATURE numer ((SparseMultivariatePolynomial R (Kernel $)) $)) (SIGNATURE denom ((SparseMultivariatePolynomial R (Kernel $)) $)) (SIGNATURE coerce ($ (SparseMultivariatePolynomial R (Kernel $)))))
      [8] innerRF:  z2 has no value
      [9] innerRF:  z1 has no value
      [10] innerRF:  z3 has no value
      [11] innerRF:  z4 has no value
      [12] innerRF: not known that (Ring) is of mode (CATEGORY package (SIGNATURE rootSplit (F F)) (SIGNATURE ratDenom (F F)) (SIGNATURE ratDenom (F F F)) (SIGNATURE ratDenom (F F (List F))) (SIGNATURE ratDenom (F F (List (Kernel F)))) (SIGNATURE ratPoly ((SparseUnivariatePolynomial F) F)) (IF (has R (OrderedSet)) (IF (has R (GcdDomain)) (IF (has R (RetractableTo (Integer))) (IF (has F (FunctionSpace R)) (PROGN (SIGNATURE rootPower (F F)) (SIGNATURE rootProduct (F F)) (SIGNATURE rootSimp (F F)) (SIGNATURE rootKerSimp (F (BasicOperator) F (NonNegativeInteger)))) noBranch) noBranch) noBranch) noBranch))
      [13] innerRF:  z5 has no value
      [14] innerRF:  z6 has no value
 

=========================================================================
warnings 20234:

>compiling ALGMFACT.spad to ALGMFACT.nrlib
 
   Warnings: 
      [1] factor:  z1 has no value
 
=========================================================================
warnings 20233:

>compiling ALGSC.spad to ALGSC.nrlib
 
   Warnings: 
      [1] elt: :Rep -- should replace by pretend
      [2] coerce:  le has no value
 
=========================================================================
warnings 20232:

>compiling APPRULE.spad to APPRULE.nrlib
 
   Warnings: 
      [1] splitRules: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE applyRules (F (List (RewriteRule Base R F)) F)) (SIGNATURE applyRules (F (List (RewriteRule Base R F)) F (PositiveInteger))) (SIGNATURE localUnquote (F F (List (Symbol)))))
      [2] rewrite: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE applyRules (F (List (RewriteRule Base R F)) F)) (SIGNATURE applyRules (F (List (RewriteRule Base R F)) F (PositiveInteger))) (SIGNATURE localUnquote (F F (List (Symbol)))))
      [3] isitwithpred: not known that (SetCategory) is of mode (CATEGORY package (SIGNATURE applyRules (F (List (RewriteRule Base R F)) F)) (SIGNATURE applyRules (F (List (RewriteRule Base R F)) F (PositiveInteger))) (SIGNATURE localUnquote (F F (List (Symbol)))))
 
=========================================================================
warnings 20231:

>compiling ASP19.spad to ASP19.nrlib
 
   Warnings: 
      [1]  M has no value
      [2]  N has no value
      [3]  LJC has no value
      [4]  XC has no value
      [5]  FVECC has no value
      [6]  FJACC has no value
      [7] localAssign1: not known that (FiniteLinearAggregate (FortranExpression (construct) (construct (QUOTE XC)) (MachineFloat))) is of mode (CATEGORY domain (SIGNATURE vector ($ (List (FortranExpression  (LIST (QUOTE XC)) (MachineFloat))))))
      [8] coerce:  FJACC has no value
 
=========================================================================
warnings 20230:

>compiling ASP20.spad to ASP20.nrlib
 
   Warnings: 
      [1]  N has no value
      [2]  NROWH has no value
      [3]  NCOLH has no value
      [4]  JTHCOL has no value
      [5]  HESS has no value
      [6]  X has no value
      [7]  HX has no value

=========================================================================
warnings 20229:

>compiling ASP31.spad to ASP31.nrlib
 
   Warnings: 
      [1]  X has no value
      [2]  Y has no value
      [3] localAssign: not known that (FiniteLinearAggregate (FortranExpression (construct (QUOTE X)) (construct (QUOTE Y)) (MachineFloat))) is of mode (CATEGORY domain (SIGNATURE vector ($ (List (FortranExpression (LIST (QUOTE X)) (LIST (QUOTE Y)) (MachineFloat))))))
      [4] coerce:  PW has no value
 
=========================================================================
warnings 20228:

>compiling ASP35.spad to ASP35.nrlib
 
   Warnings: 
      [1]  N has no value
      [2]  X has no value
      [3]  FVEC has no value
      [4]  LDFJAC has no value
      [5]  FJAC has no value
      [6]  IFLAG has no value
      [7] localAssign1: not known that (FiniteLinearAggregate (FortranExpression (construct) (construct (QUOTE X)) (MachineFloat))) is of mode (CATEGORY domain (SIGNATURE vector ($ (List (FortranExpression  (LIST (QUOTE X)) (MachineFloat))))))
 
=========================================================================
warnings 20227:

>compiling ASP41.spad to ASP41.nrlib
 
   Warnings: 
      [1]  N has no value
      [2]  X has no value
      [3]  EPS has no value
      [4]  Y has no value
      [5]  F has no value
      [6] localAssign1: not known that (FiniteLinearAggregate (FortranExpression (construct (QUOTE X) (QUOTE EPS)) (construct (QUOTE Y)) (MachineFloat))) is of mode (CATEGORY domain (SIGNATURE vector ($ (List (FortranExpression (LIST (QUOTE X) (QUOTE EPS)) (LIST (QUOTE Y)) (MachineFloat))))))
      [7] makeCodeThree:  EPS has no value
 
=========================================================================
warnings 20226:

>compiling ASP42.spad to ASP42.nrlib
 
   Warnings: 
      [1]  EPS has no value
      [2]  N has no value
      [3]  YA has no value
      [4]  YB has no value
      [5]  BC has no value
      [6]  AJ has no value
      [7]  BJ has no value
      [8]  BCEP has no value
      [9] localAssign1: not known that (FiniteLinearAggregate (FortranExpression (construct (QUOTE EPS)) (construct (QUOTE YA) (QUOTE YB)) (MachineFloat))) is of mode (CATEGORY domain (SIGNATURE vector ($ (List (FortranExpression (LIST (QUOTE EPS)) (LIST (QUOTE YA) (QUOTE YB)) (MachineFloat))))))
      [10] makeCodeThree:  EPS has no value
 
=========================================================================
warnings 20225:

>compiling ASP74.spad to ASP74.nrlib
 
   Warnings: 
      [1]  X has no value
      [2]  Y has no value
      [3]  A has no value
      [4]  B has no value
      [5]  C has no value
      [6]  IBND has no value
 
=========================================================================
warnings 20224:

>compiling ASP77.spad to ASP77.nrlib
 
   Warnings: 
      [1]  X has no value
      [2] localAssign: not known that (FiniteLinearAggregate (FortranExpression (construct (QUOTE X)) (construct) (MachineFloat))) is of mode (CATEGORY domain (SIGNATURE vector ($ (List (FortranExpression (LIST (QUOTE X))  (MachineFloat))))))
      [3] coerce:  F has no value
 
=========================================================================
warnings 20223:

>compiling ASP80.spad to ASP80.nrlib
 
   Warnings: 
      [1]  XL has no value
      [2]  XR has no value
      [3]  ELAM has no value
      [4]  YL has no value
      [5]  YR has no value

 
=========================================================================
warnings 20222:

>compiling CINTSLPE.spad to CINTSLPE.nrlib
 
   Warnings: 
      [1] solveLinearPolynomialEquation:  slpePrime has no value
      [2] solveLinearPolynomialEquation:  oldtable has no value

=========================================================================
warnings 20221:

>compiling COMBF.spad to COMBF.nrlib
 
   Warnings: 
      [1] **: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE ** (F F F)) (SIGNATURE binomial (F F F)) (SIGNATURE permutation (F F F)) (SIGNATURE factorial (F F)) (SIGNATURE factorials (F F)) (SIGNATURE factorials (F F (Symbol))) (SIGNATURE summation (F F (Symbol))) (SIGNATURE summation (F F (SegmentBinding F))) (SIGNATURE product (F F (Symbol))) (SIGNATURE product (F F (SegmentBinding F))) (SIGNATURE iifact (F F)) (SIGNATURE iibinom (F (List F))) (SIGNATURE iiperm (F (List F))) (SIGNATURE iipow (F (List F))) (SIGNATURE iidsum (F (List F))) (SIGNATURE iidprod (F (List F))) (SIGNATURE ipow (F (List F))))
      [2] facts: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE ** (F F F)) (SIGNATURE binomial (F F F)) (SIGNATURE permutation (F F F)) (SIGNATURE factorial (F F)) (SIGNATURE factorials (F F)) (SIGNATURE factorials (F F (Symbol))) (SIGNATURE summation (F F (Symbol))) (SIGNATURE summation (F F (SegmentBinding F))) (SIGNATURE product (F F (Symbol))) (SIGNATURE product (F F (SegmentBinding F))) (SIGNATURE iifact (F F)) (SIGNATURE iibinom (F (List F))) (SIGNATURE iiperm (F (List F))) (SIGNATURE iipow (F (List F))) (SIGNATURE iidsum (F (List F))) (SIGNATURE iidprod (F (List F))) (SIGNATURE ipow (F (List F))))
      [3] summand: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE ** (F F F)) (SIGNATURE binomial (F F F)) (SIGNATURE permutation (F F F)) (SIGNATURE factorial (F F)) (SIGNATURE factorials (F F)) (SIGNATURE factorials (F F (Symbol))) (SIGNATURE summation (F F (Symbol))) (SIGNATURE summation (F F (SegmentBinding F))) (SIGNATURE product (F F (Symbol))) (SIGNATURE product (F F (SegmentBinding F))) (SIGNATURE iifact (F F)) (SIGNATURE iibinom (F (List F))) (SIGNATURE iiperm (F (List F))) (SIGNATURE iipow (F (List F))) (SIGNATURE iidsum (F (List F))) (SIGNATURE iidprod (F (List F))) (SIGNATURE ipow (F (List F))))
      [4] smpfact:  x has no value
      [5] smpfact:  y has no value
      [6] ipow:  n has no value

=========================================================================
warnings 20220:

>compiling COMPFACT.spad to COMPFACT.nrlib
 
   Warnings: 
      [1] conv:  pris has no value
      [2] conv:  dris has no value
      [3] backConv:  fctr has no value
      [4] backConv:  xpnt has no value
      [5] backConv:  flg has no value
 
=========================================================================
warnings 20219:

>compiling COMPLEX.spad to COMPLEX.nrlib
 
   Warnings: 
      [1] OMwrite: pretend(String) -- should replace by @

=========================================================================
warnings 20218:

>compiling CPMATCH.spad to CPMATCH.nrlib
 
   Warnings: 
      [1] patternMatch: not known that (SetCategory) is of mode (CATEGORY $ (SIGNATURE patternMatch ((PatternMatchResult R CS) CS (Pattern R) (PatternMatchResult R CS))))

=========================================================================
warnings 20217:

>compiling CRFP.spad to CRFP.nrlib
 
   Warnings: 
      [1] pleskenSplit:  split has no value
      [2] startPolynomial:  centerIsRoot has no value
      [3] startPolynomial:  fp has no value
      [4] factor:  result has no value

=========================================================================
warnings 20216:

>compiling CTRIGMNP.spad to CTRIGMNP.nrlib
 
   Warnings: 
      [1] complexForm: not known that (RadicalCategory) is of mode (CATEGORY domain (IF (has R (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace R)) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has R (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has R (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [2] complexForm: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (IF (has R (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace R)) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has R (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has R (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [3] real?: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE complexNormalize (F F)) (SIGNATURE complexNormalize (F F (Symbol))) (SIGNATURE complexElementary (F F)) (SIGNATURE complexElementary (F F (Symbol))) (SIGNATURE real ((Expression R) F)) (SIGNATURE imag ((Expression R) F)) (SIGNATURE real? ((Boolean) F)) (SIGNATURE trigs (F F)) (SIGNATURE complexForm ((Complex (Expression R)) F)))
      [4] complexElementary:  x has no value
      [5] complexElementary:  y has no value
      [6] complexElementary: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE complexNormalize (F F)) (SIGNATURE complexNormalize (F F (Symbol))) (SIGNATURE complexElementary (F F)) (SIGNATURE complexElementary (F F (Symbol))) (SIGNATURE real ((Expression R) F)) (SIGNATURE imag ((Expression R) F)) (SIGNATURE real? ((Boolean) F)) (SIGNATURE trigs (F F)) (SIGNATURE complexForm ((Complex (Expression R)) F)))
      [7] complexNormalize:  y has no value

=========================================================================
warnings 20215:

>compiling D01WGTS.spad to D01WGTS.nrlib
 
   Warnings: 
      [1] inRest?:  x has no value
      [2] findCommonFactor:  x has no value
      [3] exprIsLogarithmicWeight: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE exprHasWeightCosWXorSinWX ((Union (Record (: op (BasicOperator)) (: w (DoubleFloat))) failed) (Record (: var (Symbol)) (: fn (Expression (DoubleFloat))) (: range (Segment (OrderedCompletion (DoubleFloat)))) (: abserr (DoubleFloat)) (: relerr (DoubleFloat))))) (SIGNATURE exprHasAlgebraicWeight ((Union (List (DoubleFloat)) failed) (Record (: var (Symbol)) (: fn (Expression (DoubleFloat))) (: range (Segment (OrderedCompletion (DoubleFloat)))) (: abserr (DoubleFloat)) (: relerr (DoubleFloat))))) (SIGNATURE exprHasLogarithmicWeights ((Integer) (Record (: var (Symbol)) (: fn (Expression (DoubleFloat))) (: range (Segment (OrderedCompletion (DoubleFloat)))) (: abserr (DoubleFloat)) (: relerr (DoubleFloat))))))
      [4] functionIsQuotient: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE exprHasWeightCosWXorSinWX ((Union (Record (: op (BasicOperator)) (: w (DoubleFloat))) failed) (Record (: var (Symbol)) (: fn (Expression (DoubleFloat))) (: range (Segment (OrderedCompletion (DoubleFloat)))) (: abserr (DoubleFloat)) (: relerr (DoubleFloat))))) (SIGNATURE exprHasAlgebraicWeight ((Union (List (DoubleFloat)) failed) (Record (: var (Symbol)) (: fn (Expression (DoubleFloat))) (: range (Segment (OrderedCompletion (DoubleFloat)))) (: abserr (DoubleFloat)) (: relerr (DoubleFloat))))) (SIGNATURE exprHasLogarithmicWeights ((Integer) (Record (: var (Symbol)) (: fn (Expression (DoubleFloat))) (: range (Segment (OrderedCompletion (DoubleFloat)))) (: abserr (DoubleFloat)) (: relerr (DoubleFloat))))))
 
=========================================================================
warnings 20214:

>compiling D02AGNT.spad to D02AGNT.nrlib
 
   Warnings: 
      [1] stiffnessAndStabilityFactor:  b has no value
      [2] stiffnessAndStabilityFactor:  e has no value
      [3] stiffnessAndStabilityOfODE:  Y has no value
 
=========================================================================
warnings 20213:

>compiling DBLRESP.spad to DBLRESP.nrlib
 
   Warnings: 
      [1] UP22:  x has no value
      [2] UP23:  x has no value
 
=========================================================================
warnings 20212:

>compiling D01AGNT.spad to D01AGNT.nrlib
 
   Warnings: 
      [1] continuousAtPoint?: not known that (AlgebraicallyClosedField) is of mode (CATEGORY domain (IF (has (Fraction (Integer)) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Fraction (Integer)))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Fraction (Integer)) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Fraction (Integer)) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [2] continuousAtPoint?: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (IF (has (Fraction (Integer)) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Fraction (Integer)))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Fraction (Integer)) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Fraction (Integer)) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [3] functionIsOscillatory: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE rangeIsFinite ((Union (: finite The range is finite) (: lowerInfinite The bottom of range is infinite) (: upperInfinite The top of range is infinite) (: bothInfinite Both top and bottom points are infinite) (: notEvaluated Range not yet evaluated)) (Record (: var (Symbol)) (: fn (Expression (DoubleFloat))) (: range (Segment (OrderedCompletion (DoubleFloat)))) (: abserr (DoubleFloat)) (: relerr (DoubleFloat))))) (SIGNATURE functionIsContinuousAtEndPoints ((Union (: continuous Continuous at the end points) (: lowerSingular There is a singularity at the lower end point) (: upperSingular There is a singularity at the upper end point) (: bothSingular There are singularities at both end points) (: notEvaluated End point continuity not yet evaluated)) (Record (: var (Symbol)) (: fn (Expression (DoubleFloat))) (: range (Segment (OrderedCompletion (DoubleFloat)))) (: abserr (DoubleFloat)) (: relerr (DoubleFloat))))) (SIGNATURE getlo ((DoubleFloat) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE gethi ((DoubleFloat) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE functionIsOscillatory ((Float) (Record (: var (Symbol)) (: fn (Expression (DoubleFloat))) (: range (Segment (OrderedCompletion (DoubleFloat)))) (: abserr (DoubleFloat)) (: relerr (DoubleFloat))))) (SIGNATURE problemPoints ((List (DoubleFloat)) (Expression (DoubleFloat)) (Symbol) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE singularitiesOf ((Stream (DoubleFloat)) (Record (: var (Symbol)) (: fn (Expression (DoubleFloat))) (: range (Segment (OrderedCompletion (DoubleFloat)))) (: abserr (DoubleFloat)) (: relerr (DoubleFloat))))) (SIGNATURE df2st ((String) (DoubleFloat))) (SIGNATURE ldf2lst ((List (String)) (List (DoubleFloat)))) (SIGNATURE sdf2lst ((List (String)) (Stream (DoubleFloat)))) (SIGNATURE commaSeparate ((String) (List (String)))) (SIGNATURE changeName ((Result) (Symbol) (Symbol) (Result))))
      [4] singularitiesOf:  str has no value
 
=========================================================================
warnings 20211:

>compiling DFSFUN.spad to DFSFUN.nrlib
 
   Warnings: 
      [1] En: The conditional modes (DoubleFloat) and (Complex (DoubleFloat)) conflict
      [2] fresnelC: The conditional modes (Integer) and (DoubleFloat) conflict
      [3] fresnelS: The conditional modes (Integer) and (DoubleFloat) conflict
 
=========================================================================
warnings 20210:

>compiling DRAWCURV.spad to DRAWCURV.nrlib
 
   Warnings: 
      [1] draw:  s has no value
      [2] draw:  xRangeFloat has no value
      [3] draw:  yRangeFloat has no value
      [4] draw:  floatRanges has no value

=========================================================================
warnings 20209:

>compiling DTP.spad to DTP.nrlib
 
   Warnings: 
      [1] blowUp:  I has no value
      [2] adjunctionDivisorForHamburgeNoether: pretend(Integer) -- should replace by @
      [3] adjunctionDivisorForQuadTrans: pretend(Integer) -- should replace by @

=========================================================================
warnings 20208:

>compiling D01TRNS.spad to D01TRNS.nrlib

   Warnings: 
      [1] transformFunction: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (IF (has (Fraction (Integer)) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Fraction (Integer)))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Fraction (Integer)) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Fraction (Integer)) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [2] transformFunction:  x has no value
 
=========================================================================
warnings 20207:

>compiling EF.spad to EF.nrlib
 
   Warnings: 
      [1] pi:  Pie has no value
      [2] iisqrt1:  isqrt1 has no value
      [3] iisqrt2:  isqrt2 has no value
      [4] iisqrt3:  isqrt3 has no value
      [5] kernel: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE exp (F F)) (SIGNATURE log (F F)) (SIGNATURE sin (F F)) (SIGNATURE cos (F F)) (SIGNATURE tan (F F)) (SIGNATURE cot (F F)) (SIGNATURE sec (F F)) (SIGNATURE csc (F F)) (SIGNATURE asin (F F)) (SIGNATURE acos (F F)) (SIGNATURE atan (F F)) (SIGNATURE acot (F F)) (SIGNATURE asec (F F)) (SIGNATURE acsc (F F)) (SIGNATURE sinh (F F)) (SIGNATURE cosh (F F)) (SIGNATURE tanh (F F)) (SIGNATURE coth (F F)) (SIGNATURE sech (F F)) (SIGNATURE csch (F F)) (SIGNATURE asinh (F F)) (SIGNATURE acosh (F F)) (SIGNATURE atanh (F F)) (SIGNATURE acoth (F F)) (SIGNATURE asech (F F)) (SIGNATURE acsch (F F)) (SIGNATURE pi (F)) (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE iisqrt2 (F)) (SIGNATURE iisqrt3 (F)) (SIGNATURE iiexp (F F)) (SIGNATURE iilog (F F)) (SIGNATURE iisin (F F)) (SIGNATURE iicos (F F)) (SIGNATURE iitan (F F)) (SIGNATURE iicot (F F)) (SIGNATURE iisec (F F)) (SIGNATURE iicsc (F F)) (SIGNATURE iiasin (F F)) (SIGNATURE iiacos (F F)) (SIGNATURE iiatan (F F)) (SIGNATURE iiacot (F F)) (SIGNATURE iiasec (F F)) (SIGNATURE iiacsc (F F)) (SIGNATURE iisinh (F F)) (SIGNATURE iicosh (F F)) (SIGNATURE iitanh (F F)) (SIGNATURE iicoth (F F)) (SIGNATURE iisech (F F)) (SIGNATURE iicsch (F F)) (SIGNATURE iiasinh (F F)) (SIGNATURE iiacosh (F F)) (SIGNATURE iiatanh (F F)) (SIGNATURE iiacoth (F F)) (SIGNATURE iiasech (F F)) (SIGNATURE iiacsch (F F)) (SIGNATURE specialTrigs ((Union F failed) F (List (Record (: func F) (: pole (Boolean)))))) (SIGNATURE localReal? ((Boolean) F)))
      [6] ilog: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE exp (F F)) (SIGNATURE log (F F)) (SIGNATURE sin (F F)) (SIGNATURE cos (F F)) (SIGNATURE tan (F F)) (SIGNATURE cot (F F)) (SIGNATURE sec (F F)) (SIGNATURE csc (F F)) (SIGNATURE asin (F F)) (SIGNATURE acos (F F)) (SIGNATURE atan (F F)) (SIGNATURE acot (F F)) (SIGNATURE asec (F F)) (SIGNATURE acsc (F F)) (SIGNATURE sinh (F F)) (SIGNATURE cosh (F F)) (SIGNATURE tanh (F F)) (SIGNATURE coth (F F)) (SIGNATURE sech (F F)) (SIGNATURE csch (F F)) (SIGNATURE asinh (F F)) (SIGNATURE acosh (F F)) (SIGNATURE atanh (F F)) (SIGNATURE acoth (F F)) (SIGNATURE asech (F F)) (SIGNATURE acsch (F F)) (SIGNATURE pi (F)) (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE iisqrt2 (F)) (SIGNATURE iisqrt3 (F)) (SIGNATURE iiexp (F F)) (SIGNATURE iilog (F F)) (SIGNATURE iisin (F F)) (SIGNATURE iicos (F F)) (SIGNATURE iitan (F F)) (SIGNATURE iicot (F F)) (SIGNATURE iisec (F F)) (SIGNATURE iicsc (F F)) (SIGNATURE iiasin (F F)) (SIGNATURE iiacos (F F)) (SIGNATURE iiatan (F F)) (SIGNATURE iiacot (F F)) (SIGNATURE iiasec (F F)) (SIGNATURE iiacsc (F F)) (SIGNATURE iisinh (F F)) (SIGNATURE iicosh (F F)) (SIGNATURE iitanh (F F)) (SIGNATURE iicoth (F F)) (SIGNATURE iisech (F F)) (SIGNATURE iicsch (F F)) (SIGNATURE iiasinh (F F)) (SIGNATURE iiacosh (F F)) (SIGNATURE iiatanh (F F)) (SIGNATURE iiacoth (F F)) (SIGNATURE iiasech (F F)) (SIGNATURE iiacsch (F F)) (SIGNATURE specialTrigs ((Union F failed) F (List (Record (: func F) (: pole (Boolean)))))) (SIGNATURE localReal? ((Boolean) F)))
      [7]  x has no value

=========================================================================
warnings 20206:

>compiling EFSTRUC.spad to EFSTRUC.nrlib
 
   Warnings: 
      [1] realElem: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE normalize (F F)) (SIGNATURE normalize (F F (Symbol))) (SIGNATURE rischNormalize ((Record (: func F) (: kers (List (Kernel F))) (: vals (List F))) F (Symbol))) (SIGNATURE realElementary (F F)) (SIGNATURE realElementary (F F (Symbol))) (SIGNATURE validExponential ((Union F failed) (List (Kernel F)) F (Symbol))) (SIGNATURE rootNormalize (F F (Kernel F))) (SIGNATURE tanQ (F (Fraction (Integer)) F)))
      [2] rtNormalize:  func has no value
      [3] toR:  s has no value
      [4] tanQ: not known that (Ring) is of mode (CATEGORY package (SIGNATURE normalize (F F)) (SIGNATURE normalize (F F (Symbol))) (SIGNATURE rischNormalize ((Record (: func F) (: kers (List (Kernel F))) (: vals (List F))) F (Symbol))) (SIGNATURE realElementary (F F)) (SIGNATURE realElementary (F F (Symbol))) (SIGNATURE validExponential ((Union F failed) (List (Kernel F)) F (Symbol))) (SIGNATURE rootNormalize (F F (Kernel F))) (SIGNATURE tanQ (F (Fraction (Integer)) F)))
      [5] rootNormalize0:  s has no value
      [6] rootNormalize0: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE normalize (F F)) (SIGNATURE normalize (F F (Symbol))) (SIGNATURE rischNormalize ((Record (: func F) (: kers (List (Kernel F))) (: vals (List F))) F (Symbol))) (SIGNATURE realElementary (F F)) (SIGNATURE realElementary (F F (Symbol))) (SIGNATURE validExponential ((Union F failed) (List (Kernel F)) F (Symbol))) (SIGNATURE rootNormalize (F F (Kernel F))) (SIGNATURE tanQ (F (Fraction (Integer)) F)))
      [7] ktoY: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE normalize (F F)) (SIGNATURE normalize (F F (Symbol))) (SIGNATURE rischNormalize ((Record (: func F) (: kers (List (Kernel F))) (: vals (List F))) F (Symbol))) (SIGNATURE realElementary (F F)) (SIGNATURE realElementary (F F (Symbol))) (SIGNATURE validExponential ((Union F failed) (List (Kernel F)) F (Symbol))) (SIGNATURE rootNormalize (F F (Kernel F))) (SIGNATURE tanQ (F (Fraction (Integer)) F)))
      [8] smpElem:  x has no value
      [9] smpElem:  y has no value
      [10] k2Elem:  ez has no value
      [11] k2Elem:  iez has no value
      [12] k2Elem:  tz2 has no value
      [13] tannosimp:  x has no value
      [14] tannosimp:  den has no value
      [15] tannosimp:  num has no value
      [16] expnosimp:  x has no value
      [17] expnosimp:  den has no value
      [18] expnosimp:  num has no value
      [19] rischNormalize:  vec has no value
      [20] rootKernelNormalize:  vec has no value
      [21] validExponential:  IN has no value
      [22] validExponential:  g has no value
 

=========================================================================
warnings 20205:

>compiling ELFUTS.spad to ELFUTS.nrlib
 
   Warnings: 
      [1] sncndn:  x has no value

=========================================================================
warnings 20204:

>compiling ESTOOLS.spad to ESTOOLS.nrlib
 
   Warnings: 
      [1] isQuotient: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE f2df ((DoubleFloat) (Float))) (SIGNATURE ef2edf ((Expression (DoubleFloat)) (Expression (Float)))) (SIGNATURE ocf2ocdf ((OrderedCompletion (DoubleFloat)) (OrderedCompletion (Float)))) (SIGNATURE socf2socdf ((Segment (OrderedCompletion (DoubleFloat))) (Segment (OrderedCompletion (Float))))) (SIGNATURE convert ((List (Segment (OrderedCompletion (DoubleFloat)))) (List (Segment (OrderedCompletion (Float)))))) (SIGNATURE df2fi ((Fraction (Integer)) (DoubleFloat))) (SIGNATURE edf2fi ((Fraction (Integer)) (Expression (DoubleFloat)))) (SIGNATURE edf2df ((DoubleFloat) (Expression (DoubleFloat)))) (SIGNATURE isQuotient ((Union (Expression (DoubleFloat)) failed) (Expression (DoubleFloat)))) (SIGNATURE expenseOfEvaluation ((Float) (Vector (Expression (DoubleFloat))))) (SIGNATURE numberOfOperations ((Record (: additions (Integer)) (: multiplications (Integer)) (: exponentiations (Integer)) (: functionCalls (Integer))) (Vector (Expression (DoubleFloat))))) (SIGNATURE edf2efi ((Expression (Fraction (Integer))) (Expression (DoubleFloat)))) (SIGNATURE dfRange ((Segment (OrderedCompletion (DoubleFloat))) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE dflist ((List (DoubleFloat)) (List (Record (: left (Fraction (Integer))) (: right (Fraction (Integer))))))) (SIGNATURE df2mf ((MachineFloat) (DoubleFloat))) (SIGNATURE ldf2vmf ((Vector (MachineFloat)) (List (DoubleFloat)))) (SIGNATURE edf2ef ((Expression (Float)) (Expression (DoubleFloat)))) (SIGNATURE vedf2vef ((Vector (Expression (Float))) (Vector (Expression (DoubleFloat))))) (SIGNATURE in? ((Boolean) (DoubleFloat) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE df2st ((String) (DoubleFloat))) (SIGNATURE f2st ((String) (Float))) (SIGNATURE ldf2lst ((List (String)) (List (DoubleFloat)))) (SIGNATURE sdf2lst ((List (String)) (Stream (DoubleFloat)))) (SIGNATURE getlo ((DoubleFloat) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE gethi ((DoubleFloat) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE concat ((Result) (Result) (Result))) (SIGNATURE concat ((Result) (List (Result)))) (SIGNATURE outputMeasure ((String) (Float))) (SIGNATURE measure2Result ((Result) (Record (: measure (Float)) (: name (String)) (: explanations (List (String)))))) (SIGNATURE measure2Result ((Result) (Record (: measure (Float)) (: name (String)) (: explanations (List (String))) (: extra (Result))))) (SIGNATURE att2Result ((Result) (Record (: endPointContinuity (Union (: continuous Continuous at the end points) (: lowerSingular There is a singularity at the lower end point) (: upperSingular There is a singularity at the upper end point) (: bothSingular There are singularities at both end points) (: notEvaluated End point continuity not yet evaluated))) (: singularitiesStream (Union (: str (Stream (DoubleFloat))) (: notEvaluated Internal singularities not yet evaluated))) (: range (Union (: finite The range is finite) (: lowerInfinite The bottom of range is infinite) (: upperInfinite The top of range is infinite) (: bothInfinite Both top and bottom points are infinite) (: notEvaluated Range not yet evaluated)))))) (SIGNATURE iflist2Result ((Result) (Record (: stiffness (Float)) (: stability (Float)) (: expense (Float)) (: accuracy (Float)) (: intermediateResults (Float))))) (SIGNATURE pdf2ef ((Expression (Float)) (Polynomial (DoubleFloat)))) (SIGNATURE pdf2df ((DoubleFloat) (Polynomial (DoubleFloat)))) (SIGNATURE df2ef ((Expression (Float)) (DoubleFloat))) (SIGNATURE fi2df ((DoubleFloat) (Fraction (Integer)))) (SIGNATURE mat ((Matrix (DoubleFloat)) (List (DoubleFloat)) (NonNegativeInteger))))
      [2] numberOfOperations1: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE f2df ((DoubleFloat) (Float))) (SIGNATURE ef2edf ((Expression (DoubleFloat)) (Expression (Float)))) (SIGNATURE ocf2ocdf ((OrderedCompletion (DoubleFloat)) (OrderedCompletion (Float)))) (SIGNATURE socf2socdf ((Segment (OrderedCompletion (DoubleFloat))) (Segment (OrderedCompletion (Float))))) (SIGNATURE convert ((List (Segment (OrderedCompletion (DoubleFloat)))) (List (Segment (OrderedCompletion (Float)))))) (SIGNATURE df2fi ((Fraction (Integer)) (DoubleFloat))) (SIGNATURE edf2fi ((Fraction (Integer)) (Expression (DoubleFloat)))) (SIGNATURE edf2df ((DoubleFloat) (Expression (DoubleFloat)))) (SIGNATURE isQuotient ((Union (Expression (DoubleFloat)) failed) (Expression (DoubleFloat)))) (SIGNATURE expenseOfEvaluation ((Float) (Vector (Expression (DoubleFloat))))) (SIGNATURE numberOfOperations ((Record (: additions (Integer)) (: multiplications (Integer)) (: exponentiations (Integer)) (: functionCalls (Integer))) (Vector (Expression (DoubleFloat))))) (SIGNATURE edf2efi ((Expression (Fraction (Integer))) (Expression (DoubleFloat)))) (SIGNATURE dfRange ((Segment (OrderedCompletion (DoubleFloat))) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE dflist ((List (DoubleFloat)) (List (Record (: left (Fraction (Integer))) (: right (Fraction (Integer))))))) (SIGNATURE df2mf ((MachineFloat) (DoubleFloat))) (SIGNATURE ldf2vmf ((Vector (MachineFloat)) (List (DoubleFloat)))) (SIGNATURE edf2ef ((Expression (Float)) (Expression (DoubleFloat)))) (SIGNATURE vedf2vef ((Vector (Expression (Float))) (Vector (Expression (DoubleFloat))))) (SIGNATURE in? ((Boolean) (DoubleFloat) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE df2st ((String) (DoubleFloat))) (SIGNATURE f2st ((String) (Float))) (SIGNATURE ldf2lst ((List (String)) (List (DoubleFloat)))) (SIGNATURE sdf2lst ((List (String)) (Stream (DoubleFloat)))) (SIGNATURE getlo ((DoubleFloat) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE gethi ((DoubleFloat) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE concat ((Result) (Result) (Result))) (SIGNATURE concat ((Result) (List (Result)))) (SIGNATURE outputMeasure ((String) (Float))) (SIGNATURE measure2Result ((Result) (Record (: measure (Float)) (: name (String)) (: explanations (List (String)))))) (SIGNATURE measure2Result ((Result) (Record (: measure (Float)) (: name (String)) (: explanations (List (String))) (: extra (Result))))) (SIGNATURE att2Result ((Result) (Record (: endPointContinuity (Union (: continuous Continuous at the end points) (: lowerSingular There is a singularity at the lower end point) (: upperSingular There is a singularity at the upper end point) (: bothSingular There are singularities at both end points) (: notEvaluated End point continuity not yet evaluated))) (: singularitiesStream (Union (: str (Stream (DoubleFloat))) (: notEvaluated Internal singularities not yet evaluated))) (: range (Union (: finite The range is finite) (: lowerInfinite The bottom of range is infinite) (: upperInfinite The top of range is infinite) (: bothInfinite Both top and bottom points are infinite) (: notEvaluated Range not yet evaluated)))))) (SIGNATURE iflist2Result ((Result) (Record (: stiffness (Float)) (: stability (Float)) (: expense (Float)) (: accuracy (Float)) (: intermediateResults (Float))))) (SIGNATURE pdf2ef ((Expression (Float)) (Polynomial (DoubleFloat)))) (SIGNATURE pdf2df ((DoubleFloat) (Polynomial (DoubleFloat)))) (SIGNATURE df2ef ((Expression (Float)) (DoubleFloat))) (SIGNATURE fi2df ((DoubleFloat) (Fraction (Integer)))) (SIGNATURE mat ((Matrix (DoubleFloat)) (List (DoubleFloat)) (NonNegativeInteger))))
 

=========================================================================
warnings 20203:

>compiling EXPRODE.spad to EXPRODE.nrlib
 
   Warnings: 
      [1] diffRhs: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE seriesSolve ((Any) (Equation F) (BasicOperator) (Equation F) (Equation F))) (SIGNATURE seriesSolve ((Any) (Equation F) (BasicOperator) (Equation F) (List F))) (SIGNATURE seriesSolve ((Any) (List (Equation F)) (List (BasicOperator)) (Equation F) (List (Equation F)))) (SIGNATURE seriesSolve ((Any) (List (Equation F)) (List (BasicOperator)) (Equation F) (List F))) (SIGNATURE seriesSolve ((Any) (List F) (List (BasicOperator)) (Equation F) (List F))) (SIGNATURE seriesSolve ((Any) (List F) (List (BasicOperator)) (Equation F) (List (Equation F)))) (SIGNATURE seriesSolve ((Any) (Equation F) (BasicOperator) (Equation F) F)) (SIGNATURE seriesSolve ((Any) F (BasicOperator) (Equation F) F)) (SIGNATURE seriesSolve ((Any) F (BasicOperator) (Equation F) (Equation F))) (SIGNATURE seriesSolve ((Any) F (BasicOperator) (Equation F) (List F))))
      [2] k2exquo:  IN has no value
      [3] k2exquo:  f has no value
      [4] smp2exquo:  x has no value
      [5] div2exquo: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE seriesSolve ((Any) (Equation F) (BasicOperator) (Equation F) (Equation F))) (SIGNATURE seriesSolve ((Any) (Equation F) (BasicOperator) (Equation F) (List F))) (SIGNATURE seriesSolve ((Any) (List (Equation F)) (List (BasicOperator)) (Equation F) (List (Equation F)))) (SIGNATURE seriesSolve ((Any) (List (Equation F)) (List (BasicOperator)) (Equation F) (List F))) (SIGNATURE seriesSolve ((Any) (List F) (List (BasicOperator)) (Equation F) (List F))) (SIGNATURE seriesSolve ((Any) (List F) (List (BasicOperator)) (Equation F) (List (Equation F)))) (SIGNATURE seriesSolve ((Any) (Equation F) (BasicOperator) (Equation F) F)) (SIGNATURE seriesSolve ((Any) F (BasicOperator) (Equation F) F)) (SIGNATURE seriesSolve ((Any) F (BasicOperator) (Equation F) (Equation F))) (SIGNATURE seriesSolve ((Any) F (BasicOperator) (Equation F) (List F))))
      [6] diffRhsK: not known that (Ring) is of mode (CATEGORY package (SIGNATURE seriesSolve ((Any) (Equation F) (BasicOperator) (Equation F) (Equation F))) (SIGNATURE seriesSolve ((Any) (Equation F) (BasicOperator) (Equation F) (List F))) (SIGNATURE seriesSolve ((Any) (List (Equation F)) (List (BasicOperator)) (Equation F) (List (Equation F)))) (SIGNATURE seriesSolve ((Any) (List (Equation F)) (List (BasicOperator)) (Equation F) (List F))) (SIGNATURE seriesSolve ((Any) (List F) (List (BasicOperator)) (Equation F) (List F))) (SIGNATURE seriesSolve ((Any) (List F) (List (BasicOperator)) (Equation F) (List (Equation F)))) (SIGNATURE seriesSolve ((Any) (Equation F) (BasicOperator) (Equation F) F)) (SIGNATURE seriesSolve ((Any) F (BasicOperator) (Equation F) F)) (SIGNATURE seriesSolve ((Any) F (BasicOperator) (Equation F) (Equation F))) (SIGNATURE seriesSolve ((Any) F (BasicOperator) (Equation F) (List F))))
      [7] findEq: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE seriesSolve ((Any) (Equation F) (BasicOperator) (Equation F) (Equation F))) (SIGNATURE seriesSolve ((Any) (Equation F) (BasicOperator) (Equation F) (List F))) (SIGNATURE seriesSolve ((Any) (List (Equation F)) (List (BasicOperator)) (Equation F) (List (Equation F)))) (SIGNATURE seriesSolve ((Any) (List (Equation F)) (List (BasicOperator)) (Equation F) (List F))) (SIGNATURE seriesSolve ((Any) (List F) (List (BasicOperator)) (Equation F) (List F))) (SIGNATURE seriesSolve ((Any) (List F) (List (BasicOperator)) (Equation F) (List (Equation F)))) (SIGNATURE seriesSolve ((Any) (Equation F) (BasicOperator) (Equation F) F)) (SIGNATURE seriesSolve ((Any) F (BasicOperator) (Equation F) F)) (SIGNATURE seriesSolve ((Any) F (BasicOperator) (Equation F) (Equation F))) (SIGNATURE seriesSolve ((Any) F (BasicOperator) (Equation F) (List F))))
      [8] seriesSolve:  IN has no value
      [9] seriesSolve:  deq has no value
      [10] seriesSolve:  y has no value
 
=========================================================================
warnings 20202:

>compiling EXPRTUBE.spad to EXPRTUBE.nrlib
 
   Warnings: 
      [1] constantToUnaryFunction:  s has no value
 
=========================================================================
warnings 20201:

>compiling EXPR2.spad to EXPR2.nrlib
 
   Warnings: 
      [1] map:  x1 has no value
      [2] map: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE map ((Expression S) (Mapping S R) (Expression R))))
 
=========================================================================
warnings 20200:

>compiling FC.spad to FC.nrlib
 
   Warnings: 
      [1] getElseIf:  conditionalBranch has no value
      [2] getCode:  assignmentBranch has no value
      [3] getCode:  arrayAssignmentBranch has no value
      [4] getCode:  conditionalBranch has no value
      [5] getCode:  returnBranch has no value
      [6] getCode:  blockBranch has no value
      [7] getCode:  commentBranch has no value
      [8] getCode:  callBranch has no value
      [9] getCode:  forBranch has no value
      [10] getCode:  labelBranch has no value
      [11] getCode:  loopBranch has no value
      [12] getCode:  printBranch has no value
      [13] getCode:  commonBranch has no value
 
=========================================================================
warnings 20199:

>compiling FDIV2.spad to FDIV2.nrlib
 
   Warnings: 
      [1] map:  s has no value
 
=========================================================================
warnings 20198:

>compiling FSPRMELT.spad to FSPRMELT.nrlib
 
   Warnings: 
      [1] F2P: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE primitiveElement ((Record (: primelt F) (: poly (List (SparseUnivariatePolynomial F))) (: prim (SparseUnivariatePolynomial F))) (List F))) (IF (has F (AlgebraicallyClosedField)) (SIGNATURE primitiveElement ((Record (: primelt F) (: pol1 (SparseUnivariatePolynomial F)) (: pol2 (SparseUnivariatePolynomial F)) (: prim (SparseUnivariatePolynomial F))) F F)) noBranch))
      [2] F2P:  k1 has no value
      [3] F2P:  r1 has no value
      [4] K2P: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE primitiveElement ((Record (: primelt F) (: poly (List (SparseUnivariatePolynomial F))) (: prim (SparseUnivariatePolynomial F))) (List F))) (IF (has F (AlgebraicallyClosedField)) (SIGNATURE primitiveElement ((Record (: primelt F) (: pol1 (SparseUnivariatePolynomial F)) (: pol2 (SparseUnivariatePolynomial F)) (: prim (SparseUnivariatePolynomial F))) F F)) noBranch))
      [5] primitiveElement: not known that (Ring) is of mode (CATEGORY package (SIGNATURE primitiveElement ((Record (: primelt F) (: poly (List (SparseUnivariatePolynomial F))) (: prim (SparseUnivariatePolynomial F))) (List F))) (IF (has F (AlgebraicallyClosedField)) (SIGNATURE primitiveElement ((Record (: primelt F) (: pol1 (SparseUnivariatePolynomial F)) (: pol2 (SparseUnivariatePolynomial F)) (: prim (SparseUnivariatePolynomial F))) F F)) noBranch))
      [6] primitiveElement: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE primitiveElement ((Record (: primelt F) (: poly (List (SparseUnivariatePolynomial F))) (: prim (SparseUnivariatePolynomial F))) (List F))) (IF (has F (AlgebraicallyClosedField)) (SIGNATURE primitiveElement ((Record (: primelt F) (: pol1 (SparseUnivariatePolynomial F)) (: pol2 (SparseUnivariatePolynomial F)) (: prim (SparseUnivariatePolynomial F))) F F)) noBranch))
      [7] F2UP: not known that (Ring) is of mode (CATEGORY $ (SIGNATURE primitiveElement ((Record (: primelt F) (: pol1 (SparseUnivariatePolynomial F)) (: pol2 (SparseUnivariatePolynomial F)) (: prim (SparseUnivariatePolynomial F))) F F)))
      [8] primitiveElement:  z1 has no value

=========================================================================
warnings 20197:

>compiling FSRED.spad to FSRED.nrlib
 
   Warnings: 
      [1] bringDown: not known that (Ring) is of mode (CATEGORY package (SIGNATURE bringDown ((Fraction (Integer)) F)) (SIGNATURE bringDown ((SparseUnivariatePolynomial (Fraction (Integer))) F (Kernel F))) (SIGNATURE newReduc ((Void))))
      [2] bringDown: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE bringDown ((Fraction (Integer)) F)) (SIGNATURE bringDown ((SparseUnivariatePolynomial (Fraction (Integer))) F (Kernel F))) (SIGNATURE newReduc ((Void))))
 
=========================================================================
warnings 20196:

>compiling FSUPFACT.spad to FSUPFACT.nrlib
 
   Warnings: 
      [1] UPAN2F:  x has no value
      [2] UPQ2AN:  x has no value
      [3] anfactor:  overq has no value
      [4] anfactor:  overan has no value
      [5] UPQ2F:  x has no value
      [6] ffactor0: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE ffactor ((Factored UP) UP)) (SIGNATURE qfactor ((Union (Factored (SparseUnivariatePolynomial (Fraction (Integer)))) failed) UP)) (SIGNATURE UP2ifCan ((Union (: overq (SparseUnivariatePolynomial (Fraction (Integer)))) (: overan (SparseUnivariatePolynomial (AlgebraicNumber))) (: failed (Boolean))) UP)) (IF (has F (RetractableTo (AlgebraicNumber))) (SIGNATURE anfactor ((Union (Factored (SparseUnivariatePolynomial (AlgebraicNumber))) failed) UP)) noBranch))
      [7] ffactor0:  x has no value
      [8] ffactor0: not known that (Ring) is of mode (CATEGORY package (SIGNATURE ffactor ((Factored UP) UP)) (SIGNATURE qfactor ((Union (Factored (SparseUnivariatePolynomial (Fraction (Integer)))) failed) UP)) (SIGNATURE UP2ifCan ((Union (: overq (SparseUnivariatePolynomial (Fraction (Integer)))) (: overan (SparseUnivariatePolynomial (AlgebraicNumber))) (: failed (Boolean))) UP)) (IF (has F (RetractableTo (AlgebraicNumber))) (SIGNATURE anfactor ((Union (Factored (SparseUnivariatePolynomial (AlgebraicNumber))) failed) UP)) noBranch))
      [9] UPQ2UP:  x has no value
      [10] PQ2F:  x has no value
      [11] PQ2F:  y has no value
      [12] qfactor:  overq has no value
      [13] P2QifCan:  x has no value
      [14] P2QifCan:  y has no value

=========================================================================
warnings 20195:

>compiling FSPECF.spad to FSPECF.nrlib
 
   Warnings: 
      [1] iiabs: not known that (Ring) is of mode (CATEGORY R (SIGNATURE abs (R R)))
      [2] not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE abs (F F)) (SIGNATURE Gamma (F F)) (SIGNATURE Gamma (F F F)) (SIGNATURE Beta (F F F)) (SIGNATURE digamma (F F)) (SIGNATURE polygamma (F F F)) (SIGNATURE besselJ (F F F)) (SIGNATURE besselY (F F F)) (SIGNATURE besselI (F F F)) (SIGNATURE besselK (F F F)) (SIGNATURE airyAi (F F)) (SIGNATURE airyBi (F F)) (SIGNATURE iiGamma (F F)) (SIGNATURE iiabs (F F)) (SIGNATURE iiBeta (F (List F))) (SIGNATURE iidigamma (F F)) (SIGNATURE iipolygamma (F (List F))) (SIGNATURE iiBesselJ (F (List F))) (SIGNATURE iiBesselY (F (List F))) (SIGNATURE iiBesselI (F (List F))) (SIGNATURE iiBesselK (F (List F))) (SIGNATURE iiAiryAi (F F)) (SIGNATURE iiAiryBi (F F)))
      [3]  x has no value

=========================================================================
warnings 20194:

>compiling FS2.spad to FS2.nrlib
 
   Warnings: 
      [1] smpmap:  z has no value
      [2] smpmap:  x has no value
      [3] smpmap:  y has no value
      [4] map: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE map (B (Mapping S R) A)))
 
=========================================================================
warnings 20193:

>compiling FS2UPS.spad to FS2UPS.nrlib
 
   Warnings: 
      [1] exprToUPS: not known that (Ring) is of mode (CATEGORY package (SIGNATURE exprToUPS ((Union (: %series UPS) (: %problem (Record (: func (String)) (: prob (String))))) FE (Boolean) (String))) (SIGNATURE exprToGenUPS ((Union (: %series UPS) (: %problem (Record (: func (String)) (: prob (String))))) FE (Boolean) (String))) (SIGNATURE localAbs (FE FE)))
      [2] exprToUPS:  y1 has no value
      [3] exprToUPS:  y2 has no value
      [4] listToUPS:  %series has no value
      [5] powerToUPS:  %series has no value
      [6] kernelToUPS: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE exprToUPS ((Union (: %series UPS) (: %problem (Record (: func (String)) (: prob (String))))) FE (Boolean) (String))) (SIGNATURE exprToGenUPS ((Union (: %series UPS) (: %problem (Record (: func (String)) (: prob (String))))) FE (Boolean) (String))) (SIGNATURE localAbs (FE FE)))
      [7] nthRootToUPS:  %series has no value
      [8] logToUPS:  %series has no value
      [9] atancotToUPS:  %series has no value
      [10] applyIfCan:  %series has no value
      [11] powToUPS:  %series has no value
      [12] newElem: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE exprToUPS ((Union (: %series UPS) (: %problem (Record (: func (String)) (: prob (String))))) FE (Boolean) (String))) (SIGNATURE exprToGenUPS ((Union (: %series UPS) (: %problem (Record (: func (String)) (: prob (String))))) FE (Boolean) (String))) (SIGNATURE localAbs (FE FE)))
      [13] smpElem:  x1 has no value
      [14] iExprToGenUPS:  y1 has no value
      [15] iExprToGenUPS:  y2 has no value
      [16] opsInvolvingX: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE exprToUPS ((Union (: %series UPS) (: %problem (Record (: func (String)) (: prob (String))))) FE (Boolean) (String))) (SIGNATURE exprToGenUPS ((Union (: %series UPS) (: %problem (Record (: func (String)) (: prob (String))))) FE (Boolean) (String))) (SIGNATURE localAbs (FE FE)))
      [17] powerToGenUPS:  %series has no value
      [18] nthRootToGenUPS:  %series has no value
      [19] logToGenUPS:  %series has no value
      [20] expToGenUPS:  %series has no value
      [21] expGenUPS:  %series has no value
      [22] atancotToGenUPS:  %problem has no value
      [23] atancotToGenUPS:  %series has no value
      [24] genUPSApplyIfCan:  %series has no value
      [25] applyBddIfCan:  %problem has no value
      [26] applyBddIfCan:  %series has no value
      [27] powToGenUPS:  %series has no value
 

=========================================================================
warnings 20192:

>compiling GAUSSFAC.spad to GAUSSFAC.nrlib
 
   Warnings: 
      [1] intfactor:  unity has no value
      [2] factor: :(NonNegativeInteger) -- should replace by pretend
      [3] factor:  result has no value
      [4] factor:  unity has no value

=========================================================================
warnings 20191:

>compiling GCNAALG.spad to GCNAALG.nrlib

   Warnings: 
      [1] leftRankPolynomial: signature of lhs not unique: (SparseUnivariatePolynomial (Fraction (Polynomial R))) chosen
      [2] rightRankPolynomial: signature of lhs not unique: (SparseUnivariatePolynomial (Fraction (Polynomial R))) chosen
      [3] genericLeftMinimalPolynomial:  x has no value
      [4] genericRightMinimalPolynomial:  x has no value
      [5] genericLeftNorm:  rf has no value
      [6] genericRightNorm:  rf has no value

=========================================================================
warnings 20190:

>compiling GENUFACT.spad to GENUFACT.nrlib
 
   Warnings: 
      [1] factor: not known that (UnivariatePolynomialCategory (Integer)) is of mode (CATEGORY domain (SIGNATURE outputForm ((OutputForm) $ (OutputForm))) (SIGNATURE fmecg ($ $ (NonNegativeInteger) R $)))
      [2] factor: not known that (UnivariatePolynomialCategory (Fraction (Integer))) is of mode (CATEGORY domain (SIGNATURE outputForm ((OutputForm) $ (OutputForm))) (SIGNATURE fmecg ($ $ (NonNegativeInteger) R $)))
      [3] factor: not known that (UnivariatePolynomialCategory (Complex (Integer))) is of mode (CATEGORY domain (SIGNATURE outputForm ((OutputForm) $ (OutputForm))) (SIGNATURE fmecg ($ $ (NonNegativeInteger) R $)))
      [4] factor: not known that (UnivariatePolynomialCategory (Complex (Fraction (Integer)))) is of mode (CATEGORY domain (SIGNATURE outputForm ((OutputForm) $ (OutputForm))) (SIGNATURE fmecg ($ $ (NonNegativeInteger) R $)))
      [5] factor: not known that (UnivariatePolynomialCategory (AlgebraicNumber)) is of mode (CATEGORY domain (SIGNATURE outputForm ((OutputForm) $ (OutputForm))) (SIGNATURE fmecg ($ $ (NonNegativeInteger) R $)))
      [6] factor: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE factor ((Factored (SparseUnivariatePolynomial R)) (SparseUnivariatePolynomial R))))

=========================================================================
warnings 20189:

>compiling GENUPS.spad to GENUPS.nrlib
 
   Warnings: 
      [1] taylor:  i has no value
      [2] laurent:  i has no value
      [3] puiseux:  i has no value
      [4] puiseux:  r has no value
      [5] series:  r has no value
      [6] series:  x has no value
      [7] series:  i has no value

=========================================================================
warnings 20188:

>compiling IAN.spad to IAN.nrlib
 
   Warnings: 
      [1] makeUnivariate:  x has no value
      [2] norm:  x has no value
      [3] convert:  y has no value

=========================================================================
warnings 20187:

>compiling INEP.spad to INEP.nrlib
 
   Warnings: 
      [1] charpol: :(PositiveInteger) -- should replace by pretend
      [2] unknown Functor code (error unsupported matrix type)

=========================================================================
warnings 20186:

>compiling INFSP.spad to INFSP.nrlib
 
   Warnings: 
      [1] evaluate: not known that (Ring) is of mode (CATEGORY package (SIGNATURE innerSolve1 ((List F) (SparseUnivariatePolynomial K) Par)) (SIGNATURE innerSolve1 ((List F) (Polynomial K) Par)) (SIGNATURE innerSolve ((List (List F)) (List (Polynomial K)) (List (Polynomial K)) (List (Symbol)) Par)) (SIGNATURE makeEq ((List (Equation (Polynomial F))) (List F) (List (Symbol)))))
      [2] innerSolve1: not known that (UnivariatePolynomialCategory (Complex (Integer))) is of mode (CATEGORY domain (SIGNATURE outputForm ((OutputForm) $ (OutputForm))) (SIGNATURE fmecg ($ $ (NonNegativeInteger) K $)))
      [3] innerSolve1: pretend(List F) -- should replace by @
      [4] innerSolve: pretenddmp -- should replace by @
      [5] innerSolve:  lq has no value
      [6] innerSolve: not known that (PolynomialCategory K (DirectProduct (# lv) (NonNegativeInteger)) OV) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [7] innerSolve: not known that (PolynomialCategory K (DirectProduct (call LENGTH lv) (NonNegativeInteger)) OV) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [8] innerSolve: pretend(List dmp) -- should replace by @
      [9] innerSolve:  listGen has no value
      [10] innerSolve:  result has no value
 
=========================================================================
warnings 20185:

>compiling INPRODPF.spad to INPRODPF.nrlib
 
   Warnings: 
      [1] applyOverZ:  z1 has no value
      [2] generalInfiniteProduct:  z1 has no value

=========================================================================
warnings 20184:

>compiling INTAF.spad to INTAF.nrlib
 
   Warnings: 
      [1] rootintegrate: not known that (Ring) is of mode (CATEGORY package (SIGNATURE algint ((IntegrationResult F) F (Kernel F) (Kernel F) (Mapping (SparseUnivariatePolynomial F) (SparseUnivariatePolynomial F)))))
      [2] rootintegrate: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE algint ((IntegrationResult F) F (Kernel F) (Kernel F) (Mapping (SparseUnivariatePolynomial F) (SparseUnivariatePolynomial F)))))
      [3] rootintegrate:  x1 has no value
      [4] algintegrate:  x1 has no value
      [5] UP2UPUP:  x1 has no value
      [6] UP2UPUP: not known that (Ring) is of mode (CATEGORY package (SIGNATURE algint ((IntegrationResult F) F (Kernel F) (Kernel F) (Mapping (SparseUnivariatePolynomial F) (SparseUnivariatePolynomial F)))))
      [7] UPUP2F:  x1 has no value
 

=========================================================================
warnings 20183:

>compiling INTALG.spad to INTALG.nrlib
 
   Warnings: 
      [1] algintexp:  x1 has no value
      [2] UPQ2F:  x has no value
      [3] UP2SUP:  x has no value
      [4] SUP2UP:  x has no value
      [5] R2UP: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE algintegrate ((IntegrationResult R) R (Mapping UP UP))) (SIGNATURE palgintegrate ((IntegrationResult R) R (Mapping UP UP))) (SIGNATURE palginfieldint ((Union R failed) R (Mapping UP UP))))
      [6] R2UP:  f1 has no value
      [7] R2UP: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE algintegrate ((IntegrationResult R) R (Mapping UP UP))) (SIGNATURE palgintegrate ((IntegrationResult R) R (Mapping UP UP))) (SIGNATURE palginfieldint ((Union R failed) R (Mapping UP UP))))
      [8] R2UP:  x1 has no value
      [9] R2UP: not known that (Ring) is of mode (CATEGORY package (SIGNATURE algintegrate ((IntegrationResult R) R (Mapping UP UP))) (SIGNATURE palgintegrate ((IntegrationResult R) R (Mapping UP UP))) (SIGNATURE palginfieldint ((Union R failed) R (Mapping UP UP))))
      [10] univ: not known that (Ring) is of mode (CATEGORY package (SIGNATURE algintegrate ((IntegrationResult R) R (Mapping UP UP))) (SIGNATURE palgintegrate ((IntegrationResult R) R (Mapping UP UP))) (SIGNATURE palginfieldint ((Union R failed) R (Mapping UP UP))))
      [11] rlift:  x1 has no value
      [12] palgintegrate:  x1 has no value
      [13] alglogint:  x1 has no value
 
=========================================================================
warnings 20182:

>compiling INTEF.spad to INTEF.nrlib
 
   Warnings: 
      [1] tanint: not known that (Ring) is of mode (CATEGORY package (SIGNATURE lfextendedint ((Union (Record (: ratpart F) (: coeff F)) failed) F (Symbol) F)) (SIGNATURE lflimitedint ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Symbol) (List F))) (SIGNATURE lfinfieldint ((Union F failed) F (Symbol))) (SIGNATURE lfintegrate ((IntegrationResult F) F (Symbol))) (SIGNATURE lfextlimint ((Union (Record (: ratpart F) (: coeff F)) failed) F (Symbol) (Kernel F) (List (Kernel F)))))
      [2] tanint: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE lfextendedint ((Union (Record (: ratpart F) (: coeff F)) failed) F (Symbol) F)) (SIGNATURE lflimitedint ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Symbol) (List F))) (SIGNATURE lfinfieldint ((Union F failed) F (Symbol))) (SIGNATURE lfintegrate ((IntegrationResult F) F (Symbol))) (SIGNATURE lfextlimint ((Union (Record (: ratpart F) (: coeff F)) failed) F (Symbol) (Kernel F) (List (Kernel F)))))
      [3] tanint:  x1 has no value
      [4] tanint:  x2 has no value
      [5] tanint:  x3 has no value
      [6] tanint:  x4 has no value
      [7] tanint:  x5 has no value
      [8] tanint:  x6 has no value
      [9] tanint:  x7 has no value
      [10] tanint:  x8 has no value
      [11] tanint:  x9 has no value
      [12] unknownint: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE lfextendedint ((Union (Record (: ratpart F) (: coeff F)) failed) F (Symbol) F)) (SIGNATURE lflimitedint ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Symbol) (List F))) (SIGNATURE lfinfieldint ((Union F failed) F (Symbol))) (SIGNATURE lfintegrate ((IntegrationResult F) F (Symbol))) (SIGNATURE lfextlimint ((Union (Record (: ratpart F) (: coeff F)) failed) F (Symbol) (Kernel F) (List (Kernel F)))))
      [13] droponex: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE lfextendedint ((Union (Record (: ratpart F) (: coeff F)) failed) F (Symbol) F)) (SIGNATURE lflimitedint ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Symbol) (List F))) (SIGNATURE lfinfieldint ((Union F failed) F (Symbol))) (SIGNATURE lfintegrate ((IntegrationResult F) F (Symbol))) (SIGNATURE lfextlimint ((Union (Record (: ratpart F) (: coeff F)) failed) F (Symbol) (Kernel F) (List (Kernel F)))))
      [14] alglfint: not known that (Ring) is of mode (CATEGORY package (SIGNATURE lfextendedint ((Union (Record (: ratpart F) (: coeff F)) failed) F (Symbol) F)) (SIGNATURE lflimitedint ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Symbol) (List F))) (SIGNATURE lfinfieldint ((Union F failed) F (Symbol))) (SIGNATURE lfintegrate ((IntegrationResult F) F (Symbol))) (SIGNATURE lfextlimint ((Union (Record (: ratpart F) (: coeff F)) failed) F (Symbol) (Kernel F) (List (Kernel F)))))
      [15] alglfint:  x1 has no value
      [16] alglflimint:  x1 has no value
      [17] lfintegrate0:  x1 has no value
      [18] tryChangeVar:  x1 has no value
      [19] algexpint:  x1 has no value
      [20] algexpint:  x2 has no value
      [21] algprimint:  x1 has no value
      [22] algprimint:  x2 has no value
      [23] lfextendedint:  x1 has no value
      [24] lflimitedint:  x1 has no value
      [25] primextint:  x1 has no value
      [26] primextint:  x2 has no value
      [27] primextint:  x3 has no value
      [28] expextint:  x1 has no value
      [29] expextint:  x2 has no value
      [30] expextint:  x3 has no value
      [31] expextint:  x4 has no value
      [32] expextint:  x5 has no value
      [33] expextint:  x6 has no value
      [34] expextint:  x7 has no value
      [35] expextint:  x8 has no value
      [36] primint:  x1 has no value
      [37] primint:  x2 has no value
      [38] primint:  x3 has no value
      [39] expint:  x1 has no value
      [40] expint:  x2 has no value
      [41] expint:  x3 has no value
      [42] expint:  x4 has no value
      [43] expint:  x5 has no value
      [44] expint:  x6 has no value
      [45] expint:  x7 has no value
      [46] expint:  x8 has no value
      [47] primlimint:  x1 has no value
      [48] primlimint:  x2 has no value
      [49] primlimint:  x3 has no value
      [50] explimint:  x1 has no value
      [51] explimint:  x2 has no value
      [52] explimint:  x3 has no value
      [53] explimint:  x4 has no value
      [54] explimint:  x5 has no value
      [55] explimint:  x6 has no value
      [56] explimint:  x7 has no value
      [57] explimint:  x8 has no value

=========================================================================
warnings 20181:

>compiling INTG0.spad to INTG0.nrlib
 
   Warnings: 
      [1] kerdiff: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE palgint0 ((IntegrationResult F) F (Kernel F) (Kernel F) F (SparseUnivariatePolynomial F))) (SIGNATURE palgint0 ((IntegrationResult F) F (Kernel F) (Kernel F) (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE palgextint0 ((Union (Record (: ratpart F) (: coeff F)) failed) F (Kernel F) (Kernel F) F F (SparseUnivariatePolynomial F))) (SIGNATURE palgextint0 ((Union (Record (: ratpart F) (: coeff F)) failed) F (Kernel F) (Kernel F) F (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE palglimint0 ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Kernel F) (Kernel F) (List F) F (SparseUnivariatePolynomial F))) (SIGNATURE palglimint0 ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Kernel F) (Kernel F) (List F) (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE palgRDE0 ((Union F failed) F F (Kernel F) (Kernel F) (Mapping (Union F failed) F F (Symbol)) F (SparseUnivariatePolynomial F))) (SIGNATURE palgRDE0 ((Union F failed) F F (Kernel F) (Kernel F) (Mapping (Union F failed) F F (Symbol)) (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE univariate ((SparseUnivariatePolynomial (Fraction (SparseUnivariatePolynomial F))) F (Kernel F) (Kernel F) (SparseUnivariatePolynomial F))) (SIGNATURE multivariate (F (SparseUnivariatePolynomial (Fraction (SparseUnivariatePolynomial F))) (Kernel F) F)) (SIGNATURE lift ((SparseUnivariatePolynomial (Fraction (SparseUnivariatePolynomial F))) (SparseUnivariatePolynomial F) (Kernel F))) (IF (has L (LinearOrdinaryDifferentialOperatorCategory F)) (PROGN (SIGNATURE palgLODE0 ((Record (: particular (Union F failed)) (: basis (List F))) L F (Kernel F) (Kernel F) F (SparseUnivariatePolynomial F))) (SIGNATURE palgLODE0 ((Record (: particular (Union F failed)) (: basis (List F))) L F (Kernel F) (Kernel F) (Kernel F) F (Fraction (SparseUnivariatePolynomial F))))) noBranch))
      [2] univ: not known that (Ring) is of mode (CATEGORY package (SIGNATURE palgint0 ((IntegrationResult F) F (Kernel F) (Kernel F) F (SparseUnivariatePolynomial F))) (SIGNATURE palgint0 ((IntegrationResult F) F (Kernel F) (Kernel F) (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE palgextint0 ((Union (Record (: ratpart F) (: coeff F)) failed) F (Kernel F) (Kernel F) F F (SparseUnivariatePolynomial F))) (SIGNATURE palgextint0 ((Union (Record (: ratpart F) (: coeff F)) failed) F (Kernel F) (Kernel F) F (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE palglimint0 ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Kernel F) (Kernel F) (List F) F (SparseUnivariatePolynomial F))) (SIGNATURE palglimint0 ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Kernel F) (Kernel F) (List F) (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE palgRDE0 ((Union F failed) F F (Kernel F) (Kernel F) (Mapping (Union F failed) F F (Symbol)) F (SparseUnivariatePolynomial F))) (SIGNATURE palgRDE0 ((Union F failed) F F (Kernel F) (Kernel F) (Mapping (Union F failed) F F (Symbol)) (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE univariate ((SparseUnivariatePolynomial (Fraction (SparseUnivariatePolynomial F))) F (Kernel F) (Kernel F) (SparseUnivariatePolynomial F))) (SIGNATURE multivariate (F (SparseUnivariatePolynomial (Fraction (SparseUnivariatePolynomial F))) (Kernel F) F)) (SIGNATURE lift ((SparseUnivariatePolynomial (Fraction (SparseUnivariatePolynomial F))) (SparseUnivariatePolynomial F) (Kernel F))) (IF (has L (LinearOrdinaryDifferentialOperatorCategory F)) (PROGN (SIGNATURE palgLODE0 ((Record (: particular (Union F failed)) (: basis (List F))) L F (Kernel F) (Kernel F) F (SparseUnivariatePolynomial F))) (SIGNATURE palgLODE0 ((Record (: particular (Union F failed)) (: basis (List F))) L F (Kernel F) (Kernel F) (Kernel F) F (Fraction (SparseUnivariatePolynomial F))))) noBranch))
      [3] univ: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE palgint0 ((IntegrationResult F) F (Kernel F) (Kernel F) F (SparseUnivariatePolynomial F))) (SIGNATURE palgint0 ((IntegrationResult F) F (Kernel F) (Kernel F) (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE palgextint0 ((Union (Record (: ratpart F) (: coeff F)) failed) F (Kernel F) (Kernel F) F F (SparseUnivariatePolynomial F))) (SIGNATURE palgextint0 ((Union (Record (: ratpart F) (: coeff F)) failed) F (Kernel F) (Kernel F) F (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE palglimint0 ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Kernel F) (Kernel F) (List F) F (SparseUnivariatePolynomial F))) (SIGNATURE palglimint0 ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Kernel F) (Kernel F) (List F) (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE palgRDE0 ((Union F failed) F F (Kernel F) (Kernel F) (Mapping (Union F failed) F F (Symbol)) F (SparseUnivariatePolynomial F))) (SIGNATURE palgRDE0 ((Union F failed) F F (Kernel F) (Kernel F) (Mapping (Union F failed) F F (Symbol)) (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE univariate ((SparseUnivariatePolynomial (Fraction (SparseUnivariatePolynomial F))) F (Kernel F) (Kernel F) (SparseUnivariatePolynomial F))) (SIGNATURE multivariate (F (SparseUnivariatePolynomial (Fraction (SparseUnivariatePolynomial F))) (Kernel F) F)) (SIGNATURE lift ((SparseUnivariatePolynomial (Fraction (SparseUnivariatePolynomial F))) (SparseUnivariatePolynomial F) (Kernel F))) (IF (has L (LinearOrdinaryDifferentialOperatorCategory F)) (PROGN (SIGNATURE palgLODE0 ((Record (: particular (Union F failed)) (: basis (List F))) L F (Kernel F) (Kernel F) F (SparseUnivariatePolynomial F))) (SIGNATURE palgLODE0 ((Record (: particular (Union F failed)) (: basis (List F))) L F (Kernel F) (Kernel F) (Kernel F) F (Fraction (SparseUnivariatePolynomial F))))) noBranch))
      [4] lift:  x1 has no value
      [5] palgint0: not known that (Ring) is of mode (CATEGORY package (SIGNATURE palgint0 ((IntegrationResult F) F (Kernel F) (Kernel F) F (SparseUnivariatePolynomial F))) (SIGNATURE palgint0 ((IntegrationResult F) F (Kernel F) (Kernel F) (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE palgextint0 ((Union (Record (: ratpart F) (: coeff F)) failed) F (Kernel F) (Kernel F) F F (SparseUnivariatePolynomial F))) (SIGNATURE palgextint0 ((Union (Record (: ratpart F) (: coeff F)) failed) F (Kernel F) (Kernel F) F (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE palglimint0 ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Kernel F) (Kernel F) (List F) F (SparseUnivariatePolynomial F))) (SIGNATURE palglimint0 ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Kernel F) (Kernel F) (List F) (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE palgRDE0 ((Union F failed) F F (Kernel F) (Kernel F) (Mapping (Union F failed) F F (Symbol)) F (SparseUnivariatePolynomial F))) (SIGNATURE palgRDE0 ((Union F failed) F F (Kernel F) (Kernel F) (Mapping (Union F failed) F F (Symbol)) (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE univariate ((SparseUnivariatePolynomial (Fraction (SparseUnivariatePolynomial F))) F (Kernel F) (Kernel F) (SparseUnivariatePolynomial F))) (SIGNATURE multivariate (F (SparseUnivariatePolynomial (Fraction (SparseUnivariatePolynomial F))) (Kernel F) F)) (SIGNATURE lift ((SparseUnivariatePolynomial (Fraction (SparseUnivariatePolynomial F))) (SparseUnivariatePolynomial F) (Kernel F))) (IF (has L (LinearOrdinaryDifferentialOperatorCategory F)) (PROGN (SIGNATURE palgLODE0 ((Record (: particular (Union F failed)) (: basis (List F))) L F (Kernel F) (Kernel F) F (SparseUnivariatePolynomial F))) (SIGNATURE palgLODE0 ((Record (: particular (Union F failed)) (: basis (List F))) L F (Kernel F) (Kernel F) (Kernel F) F (Fraction (SparseUnivariatePolynomial F))))) noBranch))
      [6] palgint0:  f1 has no value
      [7] palgint0: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE palgint0 ((IntegrationResult F) F (Kernel F) (Kernel F) F (SparseUnivariatePolynomial F))) (SIGNATURE palgint0 ((IntegrationResult F) F (Kernel F) (Kernel F) (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE palgextint0 ((Union (Record (: ratpart F) (: coeff F)) failed) F (Kernel F) (Kernel F) F F (SparseUnivariatePolynomial F))) (SIGNATURE palgextint0 ((Union (Record (: ratpart F) (: coeff F)) failed) F (Kernel F) (Kernel F) F (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE palglimint0 ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Kernel F) (Kernel F) (List F) F (SparseUnivariatePolynomial F))) (SIGNATURE palglimint0 ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Kernel F) (Kernel F) (List F) (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE palgRDE0 ((Union F failed) F F (Kernel F) (Kernel F) (Mapping (Union F failed) F F (Symbol)) F (SparseUnivariatePolynomial F))) (SIGNATURE palgRDE0 ((Union F failed) F F (Kernel F) (Kernel F) (Mapping (Union F failed) F F (Symbol)) (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE univariate ((SparseUnivariatePolynomial (Fraction (SparseUnivariatePolynomial F))) F (Kernel F) (Kernel F) (SparseUnivariatePolynomial F))) (SIGNATURE multivariate (F (SparseUnivariatePolynomial (Fraction (SparseUnivariatePolynomial F))) (Kernel F) F)) (SIGNATURE lift ((SparseUnivariatePolynomial (Fraction (SparseUnivariatePolynomial F))) (SparseUnivariatePolynomial F) (Kernel F))) (IF (has L (LinearOrdinaryDifferentialOperatorCategory F)) (PROGN (SIGNATURE palgLODE0 ((Record (: particular (Union F failed)) (: basis (List F))) L F (Kernel F) (Kernel F) F (SparseUnivariatePolynomial F))) (SIGNATURE palgLODE0 ((Record (: particular (Union F failed)) (: basis (List F))) L F (Kernel F) (Kernel F) (Kernel F) F (Fraction (SparseUnivariatePolynomial F))))) noBranch))
      [8] palgint0:  x1 has no value
      [9] palgextint0:  x1 has no value
      [10] palglimint0:  x1 has no value
      [11] multivariate:  x1 has no value
      [12] palgextint0:  f1 has no value
      [13] palglimint0:  f1 has no value
      [14] palgRDE0:  var has no value
      [15] palgRDE0:  coeff has no value
 

=========================================================================
warnings 20180:

>compiling INTHERAL.spad to INTHERAL.nrlib
 
   Warnings: 
      [1] HermiteIntegrate: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE HermiteIntegrate ((Record (: answer R) (: logpart R)) R (Mapping UP UP))))
      [2] localsolve:  x has no value
      [3] localsolve:  coef1 has no value

=========================================================================
warnings 20179:

>compiling INTPAF.spad to INTPAF.nrlib
 
   Warnings: 
      [1] UPUP2F0: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE palgint ((IntegrationResult F) F (Kernel F) (Kernel F))) (SIGNATURE palgextint ((Union (Record (: ratpart F) (: coeff F)) failed) F (Kernel F) (Kernel F) F)) (SIGNATURE palglimint ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Kernel F) (Kernel F) (List F))) (SIGNATURE palgRDE ((Union F failed) F F F (Kernel F) (Kernel F) (Mapping (Union F failed) F F (Symbol)))) (IF (has L (LinearOrdinaryDifferentialOperatorCategory F)) (SIGNATURE palgLODE ((Record (: particular (Union F failed)) (: basis (List F))) L F (Kernel F) (Kernel F) (Symbol))) noBranch))
      [2] chv: not known that (Ring) is of mode (CATEGORY package (SIGNATURE palgint ((IntegrationResult F) F (Kernel F) (Kernel F))) (SIGNATURE palgextint ((Union (Record (: ratpart F) (: coeff F)) failed) F (Kernel F) (Kernel F) F)) (SIGNATURE palglimint ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Kernel F) (Kernel F) (List F))) (SIGNATURE palgRDE ((Union F failed) F F F (Kernel F) (Kernel F) (Mapping (Union F failed) F F (Symbol)))) (IF (has L (LinearOrdinaryDifferentialOperatorCategory F)) (SIGNATURE palgLODE ((Record (: particular (Union F failed)) (: basis (List F))) L F (Kernel F) (Kernel F) (Symbol))) noBranch))
      [3] RF2UPUP:  z1 has no value
      [4] RF2UPUP:  x1 has no value
      [5] linearInXIfCan: not known that (Ring) is of mode (CATEGORY package (SIGNATURE palgint ((IntegrationResult F) F (Kernel F) (Kernel F))) (SIGNATURE palgextint ((Union (Record (: ratpart F) (: coeff F)) failed) F (Kernel F) (Kernel F) F)) (SIGNATURE palglimint ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Kernel F) (Kernel F) (List F))) (SIGNATURE palgRDE ((Union F failed) F F F (Kernel F) (Kernel F) (Mapping (Union F failed) F F (Symbol)))) (IF (has L (LinearOrdinaryDifferentialOperatorCategory F)) (SIGNATURE palgLODE ((Record (: particular (Union F failed)) (: basis (List F))) L F (Kernel F) (Kernel F) (Symbol))) noBranch))
      [6] linearInXIfCan: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE palgint ((IntegrationResult F) F (Kernel F) (Kernel F))) (SIGNATURE palgextint ((Union (Record (: ratpart F) (: coeff F)) failed) F (Kernel F) (Kernel F) F)) (SIGNATURE palglimint ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Kernel F) (Kernel F) (List F))) (SIGNATURE palgRDE ((Union F failed) F F F (Kernel F) (Kernel F) (Mapping (Union F failed) F F (Symbol)))) (IF (has L (LinearOrdinaryDifferentialOperatorCategory F)) (SIGNATURE palgLODE ((Record (: particular (Union F failed)) (: basis (List F))) L F (Kernel F) (Kernel F) (Symbol))) noBranch))
      [7] prootintegrate:  f1 has no value
      [8] prootintegrate1: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE palgint ((IntegrationResult F) F (Kernel F) (Kernel F))) (SIGNATURE palgextint ((Union (Record (: ratpart F) (: coeff F)) failed) F (Kernel F) (Kernel F) F)) (SIGNATURE palglimint ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Kernel F) (Kernel F) (List F))) (SIGNATURE palgRDE ((Union F failed) F F F (Kernel F) (Kernel F) (Mapping (Union F failed) F F (Symbol)))) (IF (has L (LinearOrdinaryDifferentialOperatorCategory F)) (SIGNATURE palgLODE ((Record (: particular (Union F failed)) (: basis (List F))) L F (Kernel F) (Kernel F) (Symbol))) noBranch))
      [9] prootintegrate1:  x1 has no value
      [10] candidates:  l has no value
      [11] prootlimint:  x1 has no value
      [12] prootextint:  x1 has no value
      [13] palgintegrate:  x1 has no value
 
=========================================================================
warnings 20178:

>compiling INTPM.spad to INTPM.nrlib
 
   Warnings: 
      [1]  x1 has no value
      [2] splitConstant: more than 1 modemap for: (One) with dc=F ===>(((F F) ((has R (SemiGroup)) (CONST F ($)))) ((F F) (T (CONST F ($)))))
      [3] matcherfei: not known that (SetCategory) is of mode (CATEGORY domain (SIGNATURE pmintegrate ((Union (Record (: special F) (: integrand F)) failed) F (Symbol))))
      [4] matchdilog: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE pmintegrate ((Union (Record (: special F) (: integrand F)) failed) F (Symbol))))
      [5] matchdilog:  x1 has no value
      [6] matchdilog0: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE pmintegrate ((Union (Record (: special F) (: integrand F)) failed) F (Symbol))))
      [7] matchdilog0: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE pmintegrate ((Union (Record (: special F) (: integrand F)) failed) F (Symbol))))
      [8] matchli:  x1 has no value
      [9] matchli0: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE pmintegrate ((Union (Record (: special F) (: integrand F)) failed) F (Symbol))))
      [10] matchsici:  ci0? has no value
      [11] pmintegrate:  const has no value
      [12] pmintegrate:  nconst has no value
      [13] pmComplexintegrate:  const has no value
      [14] pmComplexintegrate:  nconst has no value
      [15] formula1: not known that (OrderedSet) is of mode (CATEGORY $ (SIGNATURE pmintegrate ((Union F failed) F (Symbol) (OrderedCompletion F) (OrderedCompletion F))))
      [16] pmintegrate:  x1 has no value
 

=========================================================================
warnings 20177:

>compiling INTTOOLS.spad to INTTOOLS.nrlib
 
   Warnings: 
      [1] varselect: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE varselect ((List (Kernel F)) (List (Kernel F)) (Symbol))) (SIGNATURE kmax ((Kernel F) (List (Kernel F)))) (SIGNATURE ksec ((Kernel F) (Kernel F) (List (Kernel F)) (Symbol))) (SIGNATURE union ((List (Kernel F)) (List (Kernel F)) (List (Kernel F)))) (SIGNATURE vark ((List (Kernel F)) (List F) (Symbol))) (IF (has R (IntegralDomain)) (SIGNATURE removeConstantTerm (F F (Symbol))) noBranch) (IF (has R (GcdDomain)) (IF (has F (ElementaryFunctionCategory)) (PROGN (SIGNATURE mkPrim (F F (Symbol))) (IF (has R (ConvertibleTo (Pattern (Integer)))) (IF (has R (PatternMatchable (Integer))) (IF (has F (LiouvillianFunctionCategory)) (IF (has F (RetractableTo (Symbol))) (SIGNATURE intPatternMatch ((IntegrationResult F) F (Symbol) (Mapping (IntegrationResult F) F (Symbol)) (Mapping (Union (Record (: special F) (: integrand F)) failed) F (Symbol)))) noBranch) noBranch) noBranch) noBranch)) noBranch) noBranch))
      [2] vark: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE varselect ((List (Kernel F)) (List (Kernel F)) (Symbol))) (SIGNATURE kmax ((Kernel F) (List (Kernel F)))) (SIGNATURE ksec ((Kernel F) (Kernel F) (List (Kernel F)) (Symbol))) (SIGNATURE union ((List (Kernel F)) (List (Kernel F)) (List (Kernel F)))) (SIGNATURE vark ((List (Kernel F)) (List F) (Symbol))) (IF (has R (IntegralDomain)) (SIGNATURE removeConstantTerm (F F (Symbol))) noBranch) (IF (has R (GcdDomain)) (IF (has F (ElementaryFunctionCategory)) (PROGN (SIGNATURE mkPrim (F F (Symbol))) (IF (has R (ConvertibleTo (Pattern (Integer)))) (IF (has R (PatternMatchable (Integer))) (IF (has F (LiouvillianFunctionCategory)) (IF (has F (RetractableTo (Symbol))) (SIGNATURE intPatternMatch ((IntegrationResult F) F (Symbol) (Mapping (IntegrationResult F) F (Symbol)) (Mapping (Union (Record (: special F) (: integrand F)) failed) F (Symbol)))) noBranch) noBranch) noBranch) noBranch)) noBranch) noBranch))
      [3] removeConstantTerm: not known that (OrderedSet) is of mode (CATEGORY $ (SIGNATURE removeConstantTerm (F F (Symbol))))
      [4] removeConstantTerm:  ans has no value
      [5] cont: not known that (Ring) is of mode (CATEGORY $ (SIGNATURE mkPrim (F F (Symbol))))
      [6] cont:  unit has no value
      [7] linearLog?: not known that (Ring) is of mode (CATEGORY $ (SIGNATURE mkPrim (F F (Symbol))))
      [8] intPatternMatch:  nl has no value
 

=========================================================================
warnings 20176:

>compiling ITRIGMNP.spad to ITRIGMNP.nrlib
 
   Warnings: 
      [1] FG2F: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE GF2FG (FG (Complex F))) (SIGNATURE FG2F (F FG)) (SIGNATURE F2FG (FG F)) (SIGNATURE explogs2trigs ((Complex F) FG)) (SIGNATURE trigs2explogs (FG FG (List (Kernel FG)) (List (Symbol)))))
      [2] F2FG:  x has no value
      [3] ker2explogs:  IN has no value
      [4] ker2explogs:  v has no value
      [5] ker2explogs: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE GF2FG (FG (Complex F))) (SIGNATURE FG2F (F FG)) (SIGNATURE F2FG (FG F)) (SIGNATURE explogs2trigs ((Complex F) FG)) (SIGNATURE trigs2explogs (FG FG (List (Kernel FG)) (List (Symbol)))))
      [6] ker2explogs:  a has no value
      [7] ker2trigs:  IN has no value
      [8] smp2trigs:  x has no value
      [9] explogs2trigs: not known that (Ring) is of mode (CATEGORY package (SIGNATURE GF2FG (FG (Complex F))) (SIGNATURE FG2F (F FG)) (SIGNATURE F2FG (FG F)) (SIGNATURE explogs2trigs ((Complex F) FG)) (SIGNATURE trigs2explogs (FG FG (List (Kernel FG)) (List (Symbol)))))
      [10] smp2explogs:  x has no value
      [11] smp2explogs:  y has no value
 
=========================================================================
warnings 20175:

>compiling KOVACIC.spad to KOVACIC.nrlib
 
   Warnings: 
      [1] kovacic: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE kovacic ((Union (SparseUnivariatePolynomial (Fraction UP)) failed) (Fraction UP) (Fraction UP) (Fraction UP))) (SIGNATURE kovacic ((Union (SparseUnivariatePolynomial (Fraction UP)) failed) (Fraction UP) (Fraction UP) (Fraction UP) (Mapping (Factored UP) UP))))
 
=========================================================================
warnings 20174:

>compiling LF.spad to LF.nrlib
 
   Warnings: 
      [1] integrand: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE Ei (F F)) (SIGNATURE Si (F F)) (SIGNATURE Ci (F F)) (SIGNATURE li (F F)) (SIGNATURE erf (F F)) (SIGNATURE dilog (F F)) (SIGNATURE fresnelS (F F)) (SIGNATURE fresnelC (F F)) (SIGNATURE integral (F F (Symbol))) (SIGNATURE integral (F F (SegmentBinding F))))
      [2] eqint: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE Ei (F F)) (SIGNATURE Si (F F)) (SIGNATURE Ci (F F)) (SIGNATURE li (F F)) (SIGNATURE erf (F F)) (SIGNATURE dilog (F F)) (SIGNATURE fresnelS (F F)) (SIGNATURE fresnelC (F F)) (SIGNATURE integral (F F (Symbol))) (SIGNATURE integral (F F (SegmentBinding F))))
      [3]  z1 has no value
 
=========================================================================
warnings 20173:

>compiling LODOF.spad to LODOF.nrlib
 
   Warnings: 
      [1] factor: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE factor ((List (LinearOrdinaryDifferentialOperator1 (Fraction UP))) (LinearOrdinaryDifferentialOperator1 (Fraction UP)) (Mapping (List F) UP))) (IF (has F (AlgebraicallyClosedField)) (PROGN (SIGNATURE factor ((List (LinearOrdinaryDifferentialOperator1 (Fraction UP))) (LinearOrdinaryDifferentialOperator1 (Fraction UP)))) (SIGNATURE factor1 ((List (LinearOrdinaryDifferentialOperator1 (Fraction UP))) (LinearOrdinaryDifferentialOperator1 (Fraction UP))))) noBranch))
      [2] rfactor:  z has no value
      [3] zro1:  z1 has no value
      [4] zro1: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE factor1 ((List (LinearOrdinaryDifferentialOperator1 (Fraction UP))) (LinearOrdinaryDifferentialOperator1 (Fraction UP)))))
      [5] factor:  p has no value
      [6] factor1:  p has no value

=========================================================================
warnings 20172:

>compiling LSQM.spad to LSQM.nrlib
 
   Warnings: 
      [1] not known that (NonAssociativeAlgebra R) is of mode (CATEGORY domain (SIGNATURE transpose ($ $)) (SIGNATURE squareMatrix ($ (Matrix R))) (SIGNATURE coerce ((Matrix R) $)) (IF (has R (ATTRIBUTE (commutative *))) (ATTRIBUTE central) noBranch) (IF (has R (ATTRIBUTE (commutative *))) (IF (has R (ATTRIBUTE unitsKnown)) (ATTRIBUTE unitsKnown) noBranch) noBranch) (IF (has R (ConvertibleTo (InputForm))) (ATTRIBUTE (ConvertibleTo (InputForm))) noBranch))
 
=========================================================================
warnings 20171:

>compiling MULTFACT.spad to MULTFACT.nrlib
 
   Warnings: 
      [1] factor: not known that (OrderedSet) is of mode (CATEGORY OV (SIGNATURE convert ((Symbol) $)))

=========================================================================
warnings 20170:

>compiling MYUP.spad to MYUP.nrlib
 
   Warnings: 
      [1] coerce:  z1 has no value
 
=========================================================================
warnings 20169:

>compiling MYEXPR.spad to MYEXPR.nrlib
 
   Warnings: 
      [1] iunivariate:  z1 has no value
 
=========================================================================
warnings 20168:

>compiling MYEXPR.spad to MYEXPR.nrlib
 
   Warnings: 
      [1] coerce:  z1 has no value
 
   Warnings: 
      [1] iunivariate:  z1 has no value

=========================================================================
warnings 20167:

>compiling NAGF01.spad to NAGF01.nrlib
 
   Warnings: 
      [1] f01brf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [2] f01bsf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [3] f01maf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [4] f01mcf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [5] f01qcf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [6] f01qdf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [7] f01qef: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [8] f01rcf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [9] f01rdf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [10] f01ref: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
 
=========================================================================
warnings 20166:

>compiling NAGF02.spad to NAGF02.nrlib
 
   Warnings: 
      [1] f02aaf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [2] f02abf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [3] f02adf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [4] f02aef: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [5] f02aff: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [6] f02agf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [7] f02ajf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [8] f02akf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [9] f02awf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [10] f02axf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [11] f02bbf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [12] f02bjf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [13] f02fjf:  fn has no value
      [14] f02fjf:  fp has no value
      [15] f02fjf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [16] f02wef: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [17] f02xef: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
 
=========================================================================
warnings 20165:

>compiling NAGF04.spad to NAGF04.nrlib
 
   Warnings: 
      [1] f04adf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [2] f04arf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [3] f04asf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [4] f04atf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [5] f04axf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [6] f04faf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [7] f04jgf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [8] f04maf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [9] f04mbf:  fn has no value
      [10] f04mbf:  fp has no value
      [11] f04mbf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [12] f04mcf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [13] f04qaf:  fn has no value
      [14] f04qaf:  fp has no value
      [15] f04qaf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @

=========================================================================
warnings 20164:

>compiling NLINSOL.spad to NLINSOL.nrlib
 
   Warnings: 
      [1] allRoots: not known that (Ring) is of mode (CATEGORY package (SIGNATURE solveInField ((List (List (Equation (Fraction (Polynomial R))))) (List (Polynomial R)) (List (Symbol)))) (SIGNATURE solveInField ((List (List (Equation (Fraction (Polynomial R))))) (List (Polynomial R)))) (SIGNATURE solve ((List (List (Equation (Fraction (Polynomial R))))) (List (Polynomial R)) (List (Symbol)))) (SIGNATURE solve ((List (List (Equation (Fraction (Polynomial R))))) (List (Polynomial R)))))
 
=========================================================================
warnings 20163:

>compiling NSMP.spad to NSMP.nrlib
 
   Warnings: 
      [1] localMonicModulo:  a1 has no value
      [2] monicModulo:  mM has no value
      [3] exactQuotient:  a1 has no value
      [4] exactQuotient!:  a1 has no value
      [5] primitivePart!:  a1 has no value

=========================================================================
warnings 20162:

>compiling ODERTRIC.spad to ODERTRIC.nrlib
 
   Warnings: 
      [1] UP2SUP:  z has no value
      [2] ricDsolve: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE ricDsolve ((List (Fraction UP)) (LinearOrdinaryDifferentialOperator1 (Fraction UP)) (Mapping (List F) UP))) (SIGNATURE ricDsolve ((List (Fraction UP)) (LinearOrdinaryDifferentialOperator1 (Fraction UP)) (Mapping (List F) UP) (Mapping (Factored UP) UP))) (SIGNATURE ricDsolve ((List (Fraction UP)) (LinearOrdinaryDifferentialOperator2 UP (Fraction UP)) (Mapping (List F) UP))) (SIGNATURE ricDsolve ((List (Fraction UP)) (LinearOrdinaryDifferentialOperator2 UP (Fraction UP)) (Mapping (List F) UP) (Mapping (Factored UP) UP))) (SIGNATURE singRicDE ((List (Record (: frac (Fraction UP)) (: eq (LinearOrdinaryDifferentialOperator2 UP (Fraction UP))))) (LinearOrdinaryDifferentialOperator2 UP (Fraction UP)) (Mapping (Factored UP) UP))) (SIGNATURE polyRicDE ((List (Record (: poly UP) (: eq (LinearOrdinaryDifferentialOperator2 UP (Fraction UP))))) (LinearOrdinaryDifferentialOperator2 UP (Fraction UP)) (Mapping (List F) UP))) (IF (has F (AlgebraicallyClosedField)) (PROGN (SIGNATURE ricDsolve ((List (Fraction UP)) (LinearOrdinaryDifferentialOperator1 (Fraction UP)))) (SIGNATURE ricDsolve ((List (Fraction UP)) (LinearOrdinaryDifferentialOperator1 (Fraction UP)) (Mapping (Factored UP) UP))) (SIGNATURE ricDsolve ((List (Fraction UP)) (LinearOrdinaryDifferentialOperator2 UP (Fraction UP)))) (SIGNATURE ricDsolve ((List (Fraction UP)) (LinearOrdinaryDifferentialOperator2 UP (Fraction UP)) (Mapping (Factored UP) UP)))) noBranch))
      [3] mapeval:  z has no value
      [4] ratsln:  ls has no value
      [5] ratsln:  lv has no value
      [6] ratsol:  ans has no value
      [7] polyRicDE:  deg has no value
      [8] polyRicDE:  ans has no value
      [9] newtonSolution:  m has no value
      [10] nopoly:  z has no value
      [11] ricDsolve:  z has no value
      [12] zro1:  z has no value
      [13] zro1: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE ricDsolve ((List (Fraction UP)) (LinearOrdinaryDifferentialOperator2 UP (Fraction UP)) (Mapping (Factored UP) UP))))
 

=========================================================================
warnings 20161:

>compiling OMEXPR.spad to OMEXPR.nrlib
 
   Warnings: 
      [1] outputOMFunction:  %defint has no value
      [2] outputOMFunction:  %defsum has no value
      [3] outputOMFunction:  %defprod has no value
      [4] outputOMFunction:  %power has no value
      [5] outputOMExpr: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE OMwrite ((String) (Expression R))) (SIGNATURE OMwrite ((String) (Expression R) (Boolean))) (SIGNATURE OMwrite ((Void) (OpenMathDevice) (Expression R))) (SIGNATURE OMwrite ((Void) (OpenMathDevice) (Expression R) (Boolean))))
      [6] OMwrite: pretend(String) -- should replace by @
 
=========================================================================
warnings 20160:

>compiling PADE.spad to PADE.nrlib
 
   Warnings: 
      [1] padeInner:  plist has no value
      [2] padeInner:  alist has no value

=========================================================================
warnings 20159:

>compiling PAN2EXPR.spad to PAN2EXPR.nrlib
 
   Warnings: 
      [1] coerce:  x has no value
      [2] coerce:  y has no value

=========================================================================
warnings 20158:

>compiling PFO.spad to PFO.nrlib
 
   Warnings: 
      [1] klist: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE order ((Union (NonNegativeInteger) failed) (FiniteDivisor F UP UPUP R))) (SIGNATURE torsion? ((Boolean) (FiniteDivisor F UP UPUP R))) (SIGNATURE torsionIfCan ((Union (Record (: order (NonNegativeInteger)) (: function R)) failed) (FiniteDivisor F UP UPUP R))))
      [2] UPQ2F: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE order ((Union (NonNegativeInteger) failed) (FiniteDivisor F UP UPUP R))) (SIGNATURE torsion? ((Boolean) (FiniteDivisor F UP UPUP R))) (SIGNATURE torsionIfCan ((Union (Record (: order (NonNegativeInteger)) (: function R)) failed) (FiniteDivisor F UP UPUP R))))
      [3] UP22UP:  p1 has no value
      [4] UP32UPUP:  p1 has no value
      [5] commonDen: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE order ((Union (NonNegativeInteger) failed) (FiniteDivisor F UP UPUP R))) (SIGNATURE torsion? ((Boolean) (FiniteDivisor F UP UPUP R))) (SIGNATURE torsionIfCan ((Union (Record (: order (NonNegativeInteger)) (: function R)) failed) (FiniteDivisor F UP UPUP R))))
      [6] alglist:  k1 has no value
      [7] krmod:  z1 has no value
      [8] raise2:  z1 has no value
      [9] algcurve:  z1 has no value
      [10] algcurve:  q1 has no value
      [11] rat:  q1 has no value
      [12] selectIntegers: not known that (Ring) is of mode (CATEGORY package (SIGNATURE order ((Union (NonNegativeInteger) failed) (FiniteDivisor F UP UPUP R))) (SIGNATURE torsion? ((Boolean) (FiniteDivisor F UP UPUP R))) (SIGNATURE torsionIfCan ((Union (Record (: order (NonNegativeInteger)) (: function R)) failed) (FiniteDivisor F UP UPUP R))))
      [13] toQ1:  p1 has no value
      [14] toQ2:  p1 has no value
      [15] kpmod:  p1 has no value
      [16] goodRed:  z1 has no value

=========================================================================
warnings 20157:

>compiling PFOQ.spad to PFOQ.nrlib
 
   Warnings: 
      [1] rat:  z1 has no value

=========================================================================
warnings 20156:

>compiling PICOERCE.spad to PICOERCE.nrlib
 
   Warnings: 
      [1] p2e:  x1 has no value

=========================================================================
warnings 20155:

>compiling PMASSFS.spad to PMASSFS.nrlib
 
   Warnings: 
      [1] ass: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE assert (F F (String))) (SIGNATURE constant (F F)) (SIGNATURE optional (F F)) (SIGNATURE multiple (F F)))

=========================================================================
warnings 20154:

>compiling PMFS.spad to PMFS.nrlib
 
   Warnings: 
      [1] patternMatch: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE patternMatch ((PatternMatchResult S F) F (Pattern S) (PatternMatchResult S F))))
      [2] patternMatch:  l1 has no value
      [3] patternMatch:  var has no value

=========================================================================
warnings 20153:

>compiling PMPREDFS.spad to PMPREDFS.nrlib
 
   Warnings: 
      [1] suchThat: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE suchThat (F F (Mapping (Boolean) D))) (SIGNATURE suchThat (F F (List (Mapping (Boolean) D)))))

=========================================================================
warnings 20152:

>compiling PSETPK.spad to PSETPK.nrlib
 
   Warnings: 
      [1] selectPolynomials:  gps has no value
      [2] selectPolynomials:  bps has no value
      [3] selectOrPolynomials:  gps has no value
      [4] selectOrPolynomials:  bps has no value
      [5] selectAndPolynomials:  gps has no value
      [6] selectAndPolynomials:  bps has no value
      [7] certainlySubVariety?:  polnum has no value
      [8] autoRemainder:  newlp has no value
      [9] rewriteSetByReducingWithParticularGenerators:  rs has no value
      [10] squareFreeFactors: not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE removeRedundantFactorsInPols ((List P) (List P) (List P))))
      [11] univariatePolynomialsGcds:  p has no value
      [12] univariatePolynomialsGcds:  pInV has no value
      [13] univariatePolynomialsGcds:  stop has no value
      [14] univariatePolynomialsGcds:  lg has no value
      [15] removeRoughlyRedundantFactorsInContents:  newcp has no value
      [16] removeRedundantFactorsInContents:  newcp has no value
      [17] removeRedundantFactorsInPols:  newcp has no value
      [18] removeRedundantFactorsInPols:  newp has no value
      [19] unprotectedRemoveRedundantFactors:  d has no value
      [20] removeRedundantFactors:  toSee has no value
      [21] removeRedundantFactors:  toSave has no value
 

=========================================================================
warnings 20151:

>compiling RADFF.spad to RADFF.nrlib
 
   Warnings: 
      [1] fullVector:  s has no value
      [2] charPintbas:  s has no value

=========================================================================
warnings 20150:

>compiling RDEEF.spad to RDEEF.nrlib
 
   Warnings: 
      [1] rischDEalg:  z1 has no value
      [2] rischDEalg:  z2 has no value
      [3] rischDEalg:  z3 has no value
      [4] rischDEalg: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE rischDE ((Record (: ans F) (: right F) (: sol? (Boolean))) (Integer) F F (Symbol) (Mapping (Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (List F)) (Mapping (Union (Record (: ratpart F) (: coeff F)) failed) F F))))
      [5] rischDEalg: not known that (Ring) is of mode (CATEGORY package (SIGNATURE rischDE ((Record (: ans F) (: right F) (: sol? (Boolean))) (Integer) F F (Symbol) (Mapping (Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (List F)) (Mapping (Union (Record (: ratpart F) (: coeff F)) failed) F F))))
      [6] normalise0: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE rischDE ((Record (: ans F) (: right F) (: sol? (Boolean))) (Integer) F F (Symbol) (Mapping (Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (List F)) (Mapping (Union (Record (: ratpart F) (: coeff F)) failed) F F))))
      [7] normalise0: not known that (Ring) is of mode (CATEGORY package (SIGNATURE rischDE ((Record (: ans F) (: right F) (: sol? (Boolean))) (Integer) F F (Symbol) (Mapping (Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (List F)) (Mapping (Union (Record (: ratpart F) (: coeff F)) failed) F F))))
      [8] normalise:  z1 has no value
      [9] normalise:  z2 has no value
      [10] polyDElog:  z1 has no value
      [11] polyDElog:  limitedlogs has no value
      [12] polyDElog: more than 1 modemap for: (Zero) with dc=F ===>(((F F) ((has R (AbelianSemiGroup)) (CONST F ($)))) ((F F) (T (CONST F ($)))))
      [13] polyDElog:  eq has no value
      [14] gpolDEexp:  z1 has no value
      [15] gpolDEexp:  z2 has no value
      [16] polyDEexp:  z1 has no value
      [17] polyDEexp:  z2 has no value
      [18] polyDEexp:  eq has no value
      [19] logdegrad:  z1 has no value
      [20] expdegrad:  z1 has no value
      [21] expdegrad:  z2 has no value

=========================================================================
warnings 20149:

>compiling RDEEFS.spad to RDEEFS.nrlib
 
   Warnings: 
      [1] basecase: not known that (Ring) is of mode (CATEGORY package (SIGNATURE rischDEsys ((Union (List F) failed) (Integer) F F F (Symbol) (Mapping (Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (List F)) (Mapping (Union (Record (: ratpart F) (: coeff F)) failed) F F))))
      [2] basecase: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE rischDEsys ((Union (List F) failed) (Integer) F F F (Symbol) (Mapping (Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (List F)) (Mapping (Union (Record (: ratpart F) (: coeff F)) failed) F F))))
      [3] rischDEsys: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE rischDEsys ((Union (List F) failed) (Integer) F F F (Symbol) (Mapping (Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (List F)) (Mapping (Union (Record (: ratpart F) (: coeff F)) failed) F F))))
 
=========================================================================
warnings 20148:

>compiling RSETCAT.spad to RSETCAT.nrlib
 
   Warnings: 
      [1] intersect:  toSave has no value
 
=========================================================================
warnings 20147:

>compiling RSETGCD.spad to RSETGCD.nrlib
 
   Warnings: 
      [1] toseInvertible?:  x has no value
      [2] toseInvertible?:  y has no value
      [3] toseInvertibleSet:  toSave has no value
      [4] prepareSubResAlgo:  toSave has no value
      [5] internalLastSubResultant:  toReturn has no value

=========================================================================
warnings 20146:

>compiling RULE.spad to RULE.nrlib
 
   Warnings: 
      [1] F2Symbol:  z has no value
      [2] F2Symbol: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE rule ($ F F)) (SIGNATURE rule ($ F F (List (Symbol)))) (SIGNATURE suchThat ($ $ (List (Symbol)) (Mapping (Boolean) (List F)))) (SIGNATURE pattern ((Pattern Base) $)) (SIGNATURE lhs (F $)) (SIGNATURE rhs (F $)) (SIGNATURE elt (F $ F (PositiveInteger))) (SIGNATURE quotedOperators ((List (Symbol)) $)))
      [3] retractIfCan: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE rule ($ F F)) (SIGNATURE rule ($ F F (List (Symbol)))) (SIGNATURE suchThat ($ $ (List (Symbol)) (Mapping (Boolean) (List F)))) (SIGNATURE pattern ((Pattern Base) $)) (SIGNATURE lhs (F $)) (SIGNATURE rhs (F $)) (SIGNATURE elt (F $ F (PositiveInteger))) (SIGNATURE quotedOperators ((List (Symbol)) $)))
 
=========================================================================
warnings 20145:

>compiling SIGNEF.spad to SIGNEF.nrlib
 
   Warnings: 
      [1] sign: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE sign ((Union (Integer) failed) F)) (SIGNATURE sign ((Union (Integer) failed) F (Symbol) (OrderedCompletion F))) (SIGNATURE sign ((Union (Integer) failed) F (Symbol) F (String))))
      [2] sign:  z has no value
      [3] smpsign: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE sign ((Union (Integer) failed) F)) (SIGNATURE sign ((Union (Integer) failed) F (Symbol) (OrderedCompletion F))) (SIGNATURE sign ((Union (Integer) failed) F (Symbol) F (String))))
 

=========================================================================
warnings 20144:

>compiling SIMPAN.spad to SIMPAN.nrlib
 
   Warnings: 
      [1] simplify: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (IF (has (Integer) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Integer))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Integer) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Integer) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
 

=========================================================================
warnings 20143:

>compiling SOLVESER.spad to SOLVESER.nrlib
 
   Warnings: 
      [1] unvectorise: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE decomposeFunc ((Fraction (SparseUnivariatePolynomial (Expression R))) (Fraction (SparseUnivariatePolynomial (Expression R))) (Fraction (SparseUnivariatePolynomial (Expression R))) (Fraction (SparseUnivariatePolynomial (Expression R))))) (SIGNATURE unvectorise ((Fraction (SparseUnivariatePolynomial (Expression R))) (Vector (Expression R)) (Fraction (SparseUnivariatePolynomial (Expression R))) (Integer))))
      [2] unvectorise: not known that (Ring) is of mode (CATEGORY package (SIGNATURE decomposeFunc ((Fraction (SparseUnivariatePolynomial (Expression R))) (Fraction (SparseUnivariatePolynomial (Expression R))) (Fraction (SparseUnivariatePolynomial (Expression R))) (Fraction (SparseUnivariatePolynomial (Expression R))))) (SIGNATURE unvectorise ((Fraction (SparseUnivariatePolynomial (Expression R))) (Vector (Expression R)) (Fraction (SparseUnivariatePolynomial (Expression R))) (Integer))))
 
=========================================================================
warnings 20142:

>compiling SOLVETRA.spad to SOLVETRA.nrlib
 
   Warnings: 
      [1] solveInner: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE solve ((List (Equation (Expression R))) (Expression R))) (SIGNATURE solve ((List (Equation (Expression R))) (Equation (Expression R)))) (SIGNATURE solve ((List (Equation (Expression R))) (Equation (Expression R)) (Symbol))) (SIGNATURE solve ((List (Equation (Expression R))) (Expression R) (Symbol))) (SIGNATURE solve ((List (List (Equation (Expression R)))) (List (Equation (Expression R))) (List (Symbol)))))
      [2] solveInner: not known that (Ring) is of mode (CATEGORY package (SIGNATURE solve ((List (Equation (Expression R))) (Expression R))) (SIGNATURE solve ((List (Equation (Expression R))) (Equation (Expression R)))) (SIGNATURE solve ((List (Equation (Expression R))) (Equation (Expression R)) (Symbol))) (SIGNATURE solve ((List (Equation (Expression R))) (Expression R) (Symbol))) (SIGNATURE solve ((List (List (Equation (Expression R)))) (List (Equation (Expression R))) (List (Symbol)))))
      [3] tryToTrans: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (IF (has R (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace R)) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has R (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has R (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [4] tryToTrans: not known that (AlgebraicallyClosedField) is of mode (CATEGORY domain (IF (has R (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace R)) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has R (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has R (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [5] subsTan: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE solve ((List (Equation (Expression R))) (Expression R))) (SIGNATURE solve ((List (Equation (Expression R))) (Equation (Expression R)))) (SIGNATURE solve ((List (Equation (Expression R))) (Equation (Expression R)) (Symbol))) (SIGNATURE solve ((List (Equation (Expression R))) (Expression R) (Symbol))) (SIGNATURE solve ((List (List (Equation (Expression R)))) (List (Equation (Expression R))) (List (Symbol)))))
      [6] buildnexpr:  anscoeff has no value
      [7] buildnexpr:  ansmant has no value
      [8] combineLog:  ans has no value
      [9] funcinv: not known that (OrderedSet) is of mode (CATEGORY R (ATTRIBUTE complex))
      [10] smp2Poly:  x has no value
      [11] smp2Poly:  y has no value

=========================================================================
warnings 20141:

>compiling SUMFS.spad to SUMFS.nrlib
 
   Warnings: 
      [1] sum: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE sum (F F (Symbol))) (SIGNATURE sum (F F (SegmentBinding F))))
      [2] notRF?: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE sum (F F (Symbol))) (SIGNATURE sum (F F (SegmentBinding F))))
 
=========================================================================
warnings 20140:

>compiling TOOLSIGN.spad to TOOLSIGN.nrlib
 
   Warnings: 
      [1] nonQsign: pretend(AlgebraicNumber) -- should replace by @
      [2] nonQsign: not known that (AlgebraicallyClosedField) is of mode (CATEGORY domain (IF (has (Integer) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Integer))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Integer) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Integer) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [3] nonQsign: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (IF (has (Integer) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Integer))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Integer) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Integer) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
 
=========================================================================
warnings 20139:

>compiling TRIGMNIP.spad to TRIGMNIP.nrlib
 
   Warnings: 
      [1] K2KG: not known that (RadicalCategory) is of mode (CATEGORY domain (IF (has (Complex R) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Complex R))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Complex R) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Complex R) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [2] K2KG: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (IF (has (Complex R) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Complex R))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Complex R) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Complex R) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [3] K2KG: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE complexNormalize (F F)) (SIGNATURE complexNormalize (F F (Symbol))) (SIGNATURE complexElementary (F F)) (SIGNATURE complexElementary (F F (Symbol))) (SIGNATURE trigs (F F)) (SIGNATURE real (F F)) (SIGNATURE imag (F F)) (SIGNATURE real? ((Boolean) F)) (SIGNATURE complexForm ((Complex F) F)))
      [4] real?:  ker has no value
      [5] complexKernels: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE complexNormalize (F F)) (SIGNATURE complexNormalize (F F (Symbol))) (SIGNATURE complexElementary (F F)) (SIGNATURE complexElementary (F F (Symbol))) (SIGNATURE trigs (F F)) (SIGNATURE real (F F)) (SIGNATURE imag (F F)) (SIGNATURE real? ((Boolean) F)) (SIGNATURE complexForm ((Complex F) F)))
      [6] complexKernels:  lk has no value
      [7] complexKernels:  lv has no value
      [8] locexplogs:  x has no value
      [9] complexNormalize:  y has no value
      [10] complexNormalize: not known that (AlgebraicallyClosedField) is of mode (CATEGORY domain (IF (has (Complex R) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Complex R))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Complex R) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Complex R) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [11] complexNormalize: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (IF (has (Complex R) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Complex R))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Complex R) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Complex R) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [12] complexNormalize:  x has no value
      [13] complexElementary:  y has no value
      [14] complexElementary:  x has no value
 
=========================================================================
warnings 20138:

>compiling TRMANIP.spad to TRMANIP.nrlib
 
   Warnings: 
      [1] logArgs: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE expand (F F)) (SIGNATURE simplify (F F)) (SIGNATURE htrigs (F F)) (SIGNATURE simplifyExp (F F)) (SIGNATURE simplifyLog (F F)) (SIGNATURE expandPower (F F)) (SIGNATURE expandLog (F F)) (SIGNATURE cos2sec (F F)) (SIGNATURE cosh2sech (F F)) (SIGNATURE cot2trig (F F)) (SIGNATURE coth2trigh (F F)) (SIGNATURE csc2sin (F F)) (SIGNATURE csch2sinh (F F)) (SIGNATURE sec2cos (F F)) (SIGNATURE sech2cosh (F F)) (SIGNATURE sin2csc (F F)) (SIGNATURE sinh2csch (F F)) (SIGNATURE tan2trig (F F)) (SIGNATURE tanh2trigh (F F)) (SIGNATURE tan2cot (F F)) (SIGNATURE tanh2coth (F F)) (SIGNATURE cot2tan (F F)) (SIGNATURE coth2tanh (F F)) (SIGNATURE removeCosSq (F F)) (SIGNATURE removeSinSq (F F)) (SIGNATURE removeCoshSq (F F)) (SIGNATURE removeSinhSq (F F)) (IF (has R (PatternMatchable R)) (IF (has R (ConvertibleTo (Pattern R))) (IF (has F (ConvertibleTo (Pattern R))) (IF (has F (PatternMatchable R)) (SIGNATURE expandTrigProducts (F F)) noBranch) noBranch) noBranch) noBranch))
      [2] logArgs:  sum has no value
      [3] logArgs:  arg has no value
      [4] simplifyLog1:  exprs has no value
      [5] simplifyLog1:  terms has no value
      [6] simplifyLog1: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE expand (F F)) (SIGNATURE simplify (F F)) (SIGNATURE htrigs (F F)) (SIGNATURE simplifyExp (F F)) (SIGNATURE simplifyLog (F F)) (SIGNATURE expandPower (F F)) (SIGNATURE expandLog (F F)) (SIGNATURE cos2sec (F F)) (SIGNATURE cosh2sech (F F)) (SIGNATURE cot2trig (F F)) (SIGNATURE coth2trigh (F F)) (SIGNATURE csc2sin (F F)) (SIGNATURE csch2sinh (F F)) (SIGNATURE sec2cos (F F)) (SIGNATURE sech2cosh (F F)) (SIGNATURE sin2csc (F F)) (SIGNATURE sinh2csch (F F)) (SIGNATURE tan2trig (F F)) (SIGNATURE tanh2trigh (F F)) (SIGNATURE tan2cot (F F)) (SIGNATURE tanh2coth (F F)) (SIGNATURE cot2tan (F F)) (SIGNATURE coth2tanh (F F)) (SIGNATURE removeCosSq (F F)) (SIGNATURE removeSinSq (F F)) (SIGNATURE removeCoshSq (F F)) (SIGNATURE removeSinhSq (F F)) (IF (has R (PatternMatchable R)) (IF (has R (ConvertibleTo (Pattern R))) (IF (has F (ConvertibleTo (Pattern R))) (IF (has F (PatternMatchable R)) (SIGNATURE expandTrigProducts (F F)) noBranch) noBranch) noBranch) noBranch))
      [7] expandpow: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE expand (F F)) (SIGNATURE simplify (F F)) (SIGNATURE htrigs (F F)) (SIGNATURE simplifyExp (F F)) (SIGNATURE simplifyLog (F F)) (SIGNATURE expandPower (F F)) (SIGNATURE expandLog (F F)) (SIGNATURE cos2sec (F F)) (SIGNATURE cosh2sech (F F)) (SIGNATURE cot2trig (F F)) (SIGNATURE coth2trigh (F F)) (SIGNATURE csc2sin (F F)) (SIGNATURE csch2sinh (F F)) (SIGNATURE sec2cos (F F)) (SIGNATURE sech2cosh (F F)) (SIGNATURE sin2csc (F F)) (SIGNATURE sinh2csch (F F)) (SIGNATURE tan2trig (F F)) (SIGNATURE tanh2trigh (F F)) (SIGNATURE tan2cot (F F)) (SIGNATURE tanh2coth (F F)) (SIGNATURE cot2tan (F F)) (SIGNATURE coth2tanh (F F)) (SIGNATURE removeCosSq (F F)) (SIGNATURE removeSinSq (F F)) (SIGNATURE removeCoshSq (F F)) (SIGNATURE removeSinhSq (F F)) (IF (has R (PatternMatchable R)) (IF (has R (ConvertibleTo (Pattern R))) (IF (has F (ConvertibleTo (Pattern R))) (IF (has F (PatternMatchable R)) (SIGNATURE expandTrigProducts (F F)) noBranch) noBranch) noBranch) noBranch))
      [8] termexp:  z has no value
      [9] termexp:  exponent has no value
      [10] expandPower:  z has no value
      [11] powersimp:  z has no value
      [12] cos2sec:  z1 has no value
      [13] sin2csc:  z1 has no value
      [14] tan2cot:  z1 has no value
      [15] cot2tan:  z1 has no value
      [16] cosh2sech:  z1 has no value
      [17] sinh2csch:  z1 has no value
      [18] tanh2coth:  z1 has no value
      [19] coth2tanh:  z1 has no value
      [20] removeCosSq:  z1 has no value
      [21] removeCoshSq:  z1 has no value
      [22] smpexpand:  r1 has no value
      [23] smplog:  r1 has no value
      [24] smp2htrigs:  k1 has no value
      [25] smp2htrigs:  r1 has no value
      [26] htrigs: not known that (Ring) is of mode (CATEGORY package (SIGNATURE expand (F F)) (SIGNATURE simplify (F F)) (SIGNATURE htrigs (F F)) (SIGNATURE simplifyExp (F F)) (SIGNATURE simplifyLog (F F)) (SIGNATURE expandPower (F F)) (SIGNATURE expandLog (F F)) (SIGNATURE cos2sec (F F)) (SIGNATURE cosh2sech (F F)) (SIGNATURE cot2trig (F F)) (SIGNATURE coth2trigh (F F)) (SIGNATURE csc2sin (F F)) (SIGNATURE csch2sinh (F F)) (SIGNATURE sec2cos (F F)) (SIGNATURE sech2cosh (F F)) (SIGNATURE sin2csc (F F)) (SIGNATURE sinh2csch (F F)) (SIGNATURE tan2trig (F F)) (SIGNATURE tanh2trigh (F F)) (SIGNATURE tan2cot (F F)) (SIGNATURE tanh2coth (F F)) (SIGNATURE cot2tan (F F)) (SIGNATURE coth2tanh (F F)) (SIGNATURE removeCosSq (F F)) (SIGNATURE removeSinSq (F F)) (SIGNATURE removeCoshSq (F F)) (SIGNATURE removeSinhSq (F F)) (IF (has R (PatternMatchable R)) (IF (has R (ConvertibleTo (Pattern R))) (IF (has F (ConvertibleTo (Pattern R))) (IF (has F (PatternMatchable R)) (SIGNATURE expandTrigProducts (F F)) noBranch) noBranch) noBranch) noBranch))
      [27] exlog: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE expand (F F)) (SIGNATURE simplify (F F)) (SIGNATURE htrigs (F F)) (SIGNATURE simplifyExp (F F)) (SIGNATURE simplifyLog (F F)) (SIGNATURE expandPower (F F)) (SIGNATURE expandLog (F F)) (SIGNATURE cos2sec (F F)) (SIGNATURE cosh2sech (F F)) (SIGNATURE cot2trig (F F)) (SIGNATURE coth2trigh (F F)) (SIGNATURE csc2sin (F F)) (SIGNATURE csch2sinh (F F)) (SIGNATURE sec2cos (F F)) (SIGNATURE sech2cosh (F F)) (SIGNATURE sin2csc (F F)) (SIGNATURE sinh2csch (F F)) (SIGNATURE tan2trig (F F)) (SIGNATURE tanh2trigh (F F)) (SIGNATURE tan2cot (F F)) (SIGNATURE tanh2coth (F F)) (SIGNATURE cot2tan (F F)) (SIGNATURE coth2tanh (F F)) (SIGNATURE removeCosSq (F F)) (SIGNATURE removeSinSq (F F)) (SIGNATURE removeCoshSq (F F)) (SIGNATURE removeSinhSq (F F)) (IF (has R (PatternMatchable R)) (IF (has R (ConvertibleTo (Pattern R))) (IF (has F (ConvertibleTo (Pattern R))) (IF (has F (PatternMatchable R)) (SIGNATURE expandTrigProducts (F F)) noBranch) noBranch) noBranch) noBranch))
      [28] logexpand:  IN has no value
      [29] logexpand:  x has no value
      [30] kerexpand:  IN has no value
      [31] kerexpand:  x has no value
 
=========================================================================
warnings 20137:

>compiling UPXSSING.spad to UPXSSING.nrlib
 
   Warnings: 
      [1] retractIfCan: signature of lhs not unique: (Union (UnivariatePuiseuxSeries FE var cen) failed)$ chosen
      [2] sortAndDiscardTerms:  zeroTerms has no value
      [3] sortAndDiscardTerms:  infiniteTerms has no value
      [4] sortAndDiscardTerms:  failedTerms has no value
      [5] dominantTermOnList:  x has no value
      [6] dominantTermOnList:  y has no value
      [7] dominantTermOnList:  %list has no value
      [8] dominantTermOnList:  %order has no value
 
=========================================================================
warnings 20136:

>compiling UTSODE.spad to UTSODE.nrlib
 
   Warnings: 
      [1] stFunc1:  s has no value
      [2] stFunc2:  s1 has no value
      [3] stFunc2:  s2 has no value
      [4] stFuncN:  ls has no value
      [5] divloop:  s has no value
      [6] iOde1:  s has no value
      [7] iOde2:  s has no value
      [8] iOde:  ls has no value
      [9] iMpsode:  ls has no value
 
=========================================================================
warnings 20135:

>compiling UTSODETL.spad to UTSODETL.nrlib
 
   Warnings: 
      [1] LODO2FUN:  l1 has no value
 
=========================================================================
warnings 20134:

>compiling UTSSOL.spad to UTSSOL.nrlib

   Warnings: 
      [1] seriesSolve:  x has no value
      [2] seriesSolve:  res has no value
 
=========================================================================
warnings 20133:

>compiling WUTSET.spad to WUTSET.nrlib
 
   Warnings: 
      [1] medialSetWithTrace:  rs has no value
      [2] medialSetWithTrace:  contradiction has no value
      [3] medialSetWithTrace:  bs has no value
      [4] characteristicSetUsingTrace:  contradiction has no value
      [5] characteristicSetUsingTrace:  rs has no value
      [6] characteristicSetUsingTrace:  ms has no value
      [7] zeroSetSplit:  newlts has no value
 
=========================================================================
warnings 20132:

>compiling DEFINTEF.spad to DEFINTEF.nrlib
 
   Warnings: 
      [1] checkForPole: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE integrate ((Union (: f1 (OrderedCompletion F)) (: f2 (List (OrderedCompletion F))) (: fail failed) (: pole potentialPole)) F (SegmentBinding (OrderedCompletion F)))) (SIGNATURE integrate ((Union (: f1 (OrderedCompletion F)) (: f2 (List (OrderedCompletion F))) (: fail failed) (: pole potentialPole)) F (SegmentBinding (OrderedCompletion F)) (String))) (SIGNATURE innerint ((Union (: f1 (OrderedCompletion F)) (: f2 (List (OrderedCompletion F))) (: fail failed) (: pole potentialPole)) F (Symbol) (OrderedCompletion F) (OrderedCompletion F) (Boolean))))
      [2] polyIfCan: not known that (Ring) is of mode (CATEGORY package (SIGNATURE integrate ((Union (: f1 (OrderedCompletion F)) (: f2 (List (OrderedCompletion F))) (: fail failed) (: pole potentialPole)) F (SegmentBinding (OrderedCompletion F)))) (SIGNATURE integrate ((Union (: f1 (OrderedCompletion F)) (: f2 (List (OrderedCompletion F))) (: fail failed) (: pole potentialPole)) F (SegmentBinding (OrderedCompletion F)) (String))) (SIGNATURE innerint ((Union (: f1 (OrderedCompletion F)) (: f2 (List (OrderedCompletion F))) (: fail failed) (: pole potentialPole)) F (Symbol) (OrderedCompletion F) (OrderedCompletion F) (Boolean))))
      [3] polyIfCan: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE integrate ((Union (: f1 (OrderedCompletion F)) (: f2 (List (OrderedCompletion F))) (: fail failed) (: pole potentialPole)) F (SegmentBinding (OrderedCompletion F)))) (SIGNATURE integrate ((Union (: f1 (OrderedCompletion F)) (: f2 (List (OrderedCompletion F))) (: fail failed) (: pole potentialPole)) F (SegmentBinding (OrderedCompletion F)) (String))) (SIGNATURE innerint ((Union (: f1 (OrderedCompletion F)) (: f2 (List (OrderedCompletion F))) (: fail failed) (: pole potentialPole)) F (Symbol) (OrderedCompletion F) (OrderedCompletion F) (Boolean))))
 
=========================================================================
warnings 20131:

>compiling DEFINTRF.spad to DEFINTRF.nrlib
 
   Warnings: 
      [1] nopole: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (IF (has R (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace R)) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has R (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has R (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [2] nopole: not known that (AlgebraicallyClosedFunctionSpace R) is of mode (CATEGORY domain (IF (has R (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace R)) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has R (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has R (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [3] integrate:  x has no value
 
=========================================================================
warnings 20130:

>compiling DFINTTLS.spad to DFINTTLS.nrlib
 
   Warnings: 
      [1] findLimit: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE ignore? ((Boolean) (String))) (SIGNATURE computeInt ((Union (OrderedCompletion F) failed) (Kernel F) F (OrderedCompletion F) (OrderedCompletion F) (Boolean))) (SIGNATURE checkForZero ((Union (Boolean) failed) (Polynomial R) (Symbol) (OrderedCompletion F) (OrderedCompletion F) (Boolean))) (SIGNATURE checkForZero ((Union (Boolean) failed) (SparseUnivariatePolynomial F) (OrderedCompletion F) (OrderedCompletion F) (Boolean))))
      [2] mkLogPos: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE ignore? ((Boolean) (String))) (SIGNATURE computeInt ((Union (OrderedCompletion F) failed) (Kernel F) F (OrderedCompletion F) (OrderedCompletion F) (Boolean))) (SIGNATURE checkForZero ((Union (Boolean) failed) (Polynomial R) (Symbol) (OrderedCompletion F) (OrderedCompletion F) (Boolean))) (SIGNATURE checkForZero ((Union (Boolean) failed) (SparseUnivariatePolynomial F) (OrderedCompletion F) (OrderedCompletion F) (Boolean))))
      [3] checkForZero:  s has no value
      [4] checkForZero: not known that (Ring) is of mode (CATEGORY package (SIGNATURE ignore? ((Boolean) (String))) (SIGNATURE computeInt ((Union (OrderedCompletion F) failed) (Kernel F) F (OrderedCompletion F) (OrderedCompletion F) (Boolean))) (SIGNATURE checkForZero ((Union (Boolean) failed) (Polynomial R) (Symbol) (OrderedCompletion F) (OrderedCompletion F) (Boolean))) (SIGNATURE checkForZero ((Union (Boolean) failed) (SparseUnivariatePolynomial F) (OrderedCompletion F) (OrderedCompletion F) (Boolean))))
      [5] findRealZero:  fin has no value
      [6] findRealZero:  s has no value
      [7] findRealZero:  halfinf has no value
      [8] var:  i has no value
 
=========================================================================
warnings 20129:

>compiling EFULS.spad to EFULS.nrlib

   Warnings: 
      [1] tanIfCan: not known that (Algebra (Fraction (Integer))) is of mode (CATEGORY Coef (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) Coef)))

=========================================================================
warnings 20128:

>compiling ESCONT.spad to ESCONT.nrlib
 
   Warnings: 
      [1] zerosOf: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE getlo ((DoubleFloat) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE gethi ((DoubleFloat) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE functionIsFracPolynomial? ((Boolean) (Record (: var (Symbol)) (: fn (Expression (DoubleFloat))) (: range (Segment (OrderedCompletion (DoubleFloat)))) (: abserr (DoubleFloat)) (: relerr (DoubleFloat))))) (SIGNATURE problemPoints ((List (DoubleFloat)) (Expression (DoubleFloat)) (Symbol) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE zerosOf ((Stream (DoubleFloat)) (Expression (DoubleFloat)) (List (Symbol)) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE singularitiesOf ((Stream (DoubleFloat)) (Expression (DoubleFloat)) (List (Symbol)) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE singularitiesOf ((Stream (DoubleFloat)) (Vector (Expression (DoubleFloat))) (List (Symbol)) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE polynomialZeros ((List (DoubleFloat)) (Polynomial (Fraction (Integer))) (Symbol) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE df2st ((String) (DoubleFloat))) (SIGNATURE ldf2lst ((List (String)) (List (DoubleFloat)))) (SIGNATURE sdf2lst ((List (String)) (Stream (DoubleFloat)))))
      [2] zerosOf:  t1 has no value
      [3] zerosOf:  t2 has no value
      [4] singularitiesOf:  t3 has no value
 
=========================================================================
warnings 20127:

>compiling EXPR.spad to EXPR.nrlib
 
   Warnings: 
      [1] not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [2] simplifyPower: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [3] **: pretend(Integer) -- should replace by @
      [4] **: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [5] <: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [6] numer: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [7] algkernels:  x has no value
      [8] toprat: not known that (Field) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [9] toprat: not known that (ExpressionSpace) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [10] toprat: not known that (SIGNATURE numer ((SparseMultivariatePolynomial R (Kernel $)) $)) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [11] toprat: not known that (SIGNATURE denom ((SparseMultivariatePolynomial R (Kernel $)) $)) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [12] toprat: not known that (SIGNATURE coerce ($ (SparseMultivariatePolynomial R (Kernel $)))) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [13] reducedSystem: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [14] commonk0: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [15] rootOf: not known that (FunctionSpace R) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [16] rootOf: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [17] pi: not known that (FunctionSpace R) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [18] pi: not known that (RadicalCategory) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [19] abs: not known that (FunctionSpace R) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [20] **: not known that (FunctionSpace R) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [21] erf: not known that (FunctionSpace R) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [22] erf: not known that (RadicalCategory) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [23] erf: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [24] operator: not known that (FunctionSpace R) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [25] operator: not known that (ExpressionSpace) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [26] evl0: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [27] gcdPolynomial: not known that (GcdDomain) is of mode (CATEGORY domain (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))))
      [28] factorPolynomial: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))))
      [29] factorPolynomial: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))))
      [30] coerce: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [31] retract: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [32] retractIfCan: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [33] k2expr:  x has no value
      [34] k2expr: not known that (ExpressionSpace) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [35] smp2expr:  x has no value
      [36] smp2expr: not known that (SetCategory) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [37] smp2expr: not known that (SIGNATURE + ($ $ $)) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [38] smp2expr: not known that (SIGNATURE * ($ $ $)) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [39] smp2expr: not known that (SIGNATURE ** ($ $ (NonNegativeInteger))) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [40] smp2an: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [41] convert: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [42] eval: not known that (ConvertibleTo (InputForm)) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [43] patternMatch: not known that (FunctionSpace R) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [44] patternMatch: not known that (ConvertibleTo (Pattern (Integer))) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [45] patternMatch: not known that (PatternMatchable (Integer)) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [46] patternMatch: not known that (RetractableTo (Kernel $)) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [47] patternMatch: not known that (SetCategory) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [48] patternMatch: not known that (ConvertibleTo (Pattern (Float))) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [49] patternMatch: not known that (PatternMatchable (Float)) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [50] kereval:  x1 has no value
      [51] kereval:  x2 has no value
      [52] subeval:  x has no value
      [53] isPlus:  gen has no value
      [54] eval:  x2 has no value
      [55] eval:  x1 has no value
      [56] subst:  x1 has no value
      [57] not known that (Ring) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [58] not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))

=========================================================================
warnings 20126:

>compiling EXPRSOL.spad to EXPRSOL.nrlib
 
   Warnings: 
      [1] replaceDiffs: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE seriesSolve (UTSF F (BasicOperator) (Symbol) (List F))) (SIGNATURE replaceDiffs (F F (BasicOperator) (Symbol))))
      [2] replaceDiffs:  %diff has no value
      [3] seriesSolve:  x has no value
 
=========================================================================
warnings 20125:

>compiling EXPR2UPS.spad to EXPR2UPS.nrlib
 
   Warnings: 
      [1] iTaylor:  %problem has no value
      [2] iTaylor:  %series has no value
      [3] taylor: more than 1 modemap for: (Zero) with dc=FE ===>(((FE FE) ((has R (AbelianSemiGroup)) (CONST FE ($)))) ((FE FE) (T (CONST FE ($)))))
      [4] iLaurent:  %problem has no value
      [5] iLaurent:  %series has no value
      [6] laurent: more than 1 modemap for: (Zero) with dc=FE ===>(((FE FE) ((has R (AbelianSemiGroup)) (CONST FE ($)))) ((FE FE) (T (CONST FE ($)))))
      [7] iPuiseux:  %problem has no value
      [8] iPuiseux:  %series has no value
      [9] puiseux: more than 1 modemap for: (Zero) with dc=FE ===>(((FE FE) ((has R (AbelianSemiGroup)) (CONST FE ($)))) ((FE FE) (T (CONST FE ($)))))
      [10] iSeries:  %problem has no value
      [11] iSeries:  %series has no value
      [12] series: more than 1 modemap for: (Zero) with dc=FE ===>(((FE FE) ((has R (AbelianSemiGroup)) (CONST FE ($)))) ((FE FE) (T (CONST FE ($)))))
 
=========================================================================
warnings 20124:

>compiling FACTEXT.spad to FACTEXT.nrlib
 
   Warnings: 
      [1] factor: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE factor ((Factored (SparseUnivariatePolynomial K)) (SparseUnivariatePolynomial K) K)) (SIGNATURE factorSqFree ((Factored (SparseUnivariatePolynomial K)) (SparseUnivariatePolynomial K) K)))
      [2] norm: not known that (Ring) is of mode (CATEGORY package (SIGNATURE factor ((Factored (SparseUnivariatePolynomial K)) (SparseUnivariatePolynomial K) K)) (SIGNATURE factorSqFree ((Factored (SparseUnivariatePolynomial K)) (SparseUnivariatePolynomial K) K)))
 
=========================================================================
warnings 20123:

>compiling FDIV.spad to FDIV.nrlib
 
   Warnings: 
      [1] *: signature of lhs not unique: $(Integer)$ chosen
      [2] reduce:  s has no value
 
=========================================================================
warnings 20122:

>compiling FSCINT.spad to FSCINT.nrlib
 
   Warnings: 
      [1] K2KG: not known that (RadicalCategory) is of mode (CATEGORY domain (IF (has (Complex R) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Complex R))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Complex R) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Complex R) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [2] K2KG: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (IF (has (Complex R) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Complex R))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Complex R) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Complex R) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [3] K2KG: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE internalIntegrate ((IntegrationResult F) F (Symbol))) (SIGNATURE internalIntegrate0 ((IntegrationResult F) F (Symbol))) (SIGNATURE complexIntegrate (F F (Symbol))))
      [4] internalIntegrate:  x1 has no value
      [5] internalIntegrate: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE internalIntegrate ((IntegrationResult F) F (Symbol))) (SIGNATURE internalIntegrate0 ((IntegrationResult F) F (Symbol))) (SIGNATURE complexIntegrate (F F (Symbol))))
      [6] internalIntegrate: not known that (AlgebraicallyClosedField) is of mode (CATEGORY domain (IF (has (Complex R) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Complex R))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Complex R) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Complex R) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [7] internalIntegrate: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (IF (has (Complex R) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Complex R))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Complex R) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Complex R) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
 
=========================================================================
warnings 20121:

>compiling FSINT.spad to FSINT.nrlib
 
   Warnings: 
      [1] K2KG: not known that (RadicalCategory) is of mode (CATEGORY domain (IF (has (Complex R) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Complex R))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Complex R) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Complex R) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [2] K2KG: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (IF (has (Complex R) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Complex R))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Complex R) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Complex R) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [3] K2KG: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE integrate ((Union F (List F)) F (Symbol))))
      [4] trans?:  x1 has no value
      [5] postSubst: not known that (Ring) is of mode (CATEGORY package (SIGNATURE integrate ((Union F (List F)) F (Symbol))))
      [6] postSubst: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE integrate ((Union F (List F)) F (Symbol))))
      [7] integrate:  x1 has no value
      [8] integrate: not known that (AlgebraicallyClosedField) is of mode (CATEGORY domain (IF (has (Complex R) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Complex R))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Complex R) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Complex R) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [9] integrate: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (IF (has (Complex R) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Complex R))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Complex R) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Complex R) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
 
=========================================================================
warnings 20120:

>compiling FS2EXPXP.spad to FS2EXPXP.nrlib
 
   Warnings: 
      [1] newElem: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE exprToXXP ((Union (: %expansion (ExponentialExpansion R FE x cen)) (: %problem (Record (: func (String)) (: prob (String))))) FE (Boolean))) (SIGNATURE localAbs (FE FE)))
      [2] smpElem:  x1 has no value
      [3] k2Elem: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE exprToXXP ((Union (: %expansion (ExponentialExpansion R FE x cen)) (: %problem (Record (: func (String)) (: prob (String))))) FE (Boolean))) (SIGNATURE localAbs (FE FE)))
      [4] iExprToXXP:  %series has no value
      [5] iExprToXXP:  y1 has no value
      [6] iExprToXXP:  y2 has no value
      [7] listToXXP:  %expansion has no value
      [8] powerToXXP:  %expansion has no value
      [9] nthRootXXPIfCan:  %problem has no value
      [10] nthRootXXPIfCan:  %series has no value
      [11] nthRootToXXP:  %problem has no value
      [12] nthRootToXXP:  %expansion has no value
      [13] genPowerToXXP:  %expansion has no value
      [14] genExp:  %series has no value
      [15] exponential:  %problem has no value
      [16] exponential:  %series has no value
      [17] expToXXP:  %expansion has no value
      [18] logToXXP:  %expansion has no value
      [19] logToXXP:  %problem has no value
      [20] logToXXP:  %series has no value
      [21] applyIfCan:  %expansion has no value
      [22] applyBddIfCan:  %problem has no value
      [23] applyBddIfCan:  %expansion has no value
      [24] opsInvolvingX: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE exprToXXP ((Union (: %expansion (ExponentialExpansion R FE x cen)) (: %problem (Record (: func (String)) (: prob (String))))) FE (Boolean))) (SIGNATURE localAbs (FE FE)))
      [25] atancotToXXP:  %problem has no value
      [26] atancotToXXP:  %series has no value
 
=========================================================================
warnings 20119:

>compiling GSERIES.spad to GSERIES.nrlib

   Warnings: 
      [1] differentiate:  x has no value
      [2] integrate:  x has no value

=========================================================================
warnings 20118:

>compiling HELLFDIV.spad to HELLFDIV.nrlib
 
   Warnings: 
      [1] unknown Functor code (error HyperellipticFiniteDivisor: curve must be hyperelliptic)
 
=========================================================================
warnings 20117:

>compiling INTDIVP.spad to INTDIVP.nrlib
 
   Warnings: 
      [1] intersectionDivisor: pretend(Integer) -- should replace by @

=========================================================================
warnings 20116:

>compiling INVLAPLA.spad to INVLAPLA.nrlib
 
   Warnings: 
      [1] ilt: not known that (Ring) is of mode (CATEGORY package (SIGNATURE inverseLaplace ((Union F failed) F (Symbol) (Symbol))))
      [2] ilt: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE inverseLaplace ((Union F failed) F (Symbol) (Symbol))))
      [3] iltsqfr: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE inverseLaplace ((Union F failed) F (Symbol) (Symbol))))
      [4] iltirred: not known that (Ring) is of mode (CATEGORY package (SIGNATURE inverseLaplace ((Union F failed) F (Symbol) (Symbol))))
 
=========================================================================
warnings 20115:

>compiling IR2F.spad to IR2F.nrlib
 
   Warnings: 
      [1] evenRoots: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE split ((IntegrationResult F) (IntegrationResult F))) (SIGNATURE expand ((List F) (IntegrationResult F))) (SIGNATURE complexExpand (F (IntegrationResult F))))
      [2] ilog: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE split ((IntegrationResult F) (IntegrationResult F))) (SIGNATURE expand ((List F) (IntegrationResult F))) (SIGNATURE complexExpand (F (IntegrationResult F))))
      [3] ilog: not known that (Ring) is of mode (CATEGORY package (SIGNATURE split ((IntegrationResult F) (IntegrationResult F))) (SIGNATURE expand ((List F) (IntegrationResult F))) (SIGNATURE complexExpand (F (IntegrationResult F))))
      [4] lg2func: not known that (Ring) is of mode (CATEGORY package (SIGNATURE split ((IntegrationResult F) (IntegrationResult F))) (SIGNATURE expand ((List F) (IntegrationResult F))) (SIGNATURE complexExpand (F (IntegrationResult F))))
 
=========================================================================
warnings 20114:

>compiling IRRF2F.spad to IRRF2F.nrlib
 
   Warnings: 
      [1] toEF:  z1 has no value
      [2] expand: not known that (AlgebraicallyClosedFunctionSpace R) is of mode (CATEGORY domain (IF (has R (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace R)) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has R (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has R (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [3] expand: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (IF (has R (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace R)) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has R (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has R (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [4] integrate: not known that (AlgebraicallyClosedField) is of mode (CATEGORY domain (IF (has R (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace R)) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has R (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has R (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [5] integrate: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (IF (has R (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace R)) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has R (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has R (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
 

=========================================================================
warnings 20113:

>compiling LAPLACE.spad to LAPLACE.nrlib
 
   Warnings: 
      [1] algebraic?: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE laplace (F F (Symbol) (Symbol))))
      [2] isLinear: not known that (Ring) is of mode (CATEGORY package (SIGNATURE laplace (F F (Symbol) (Symbol))))
      [3] isLinear: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE laplace (F F (Symbol) (Symbol))))
      [4] atn:  d has no value
      [5] mkPlus: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE laplace (F F (Symbol) (Symbol))))
      [6] locallaplace:  const has no value
      [7] locallaplace:  nconst has no value

=========================================================================
warnings 20112:

>compiling LIMITPS.spad to LIMITPS.nrlib
 
   Warnings: 
      [1] firstNonLogPtr: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE limit ((Union (OrderedCompletion FE) (Record (: leftHandLimit (Union (OrderedCompletion FE) failed)) (: rightHandLimit (Union (OrderedCompletion FE) failed))) failed) FE (Equation (OrderedCompletion FE)))) (SIGNATURE complexLimit ((Union (OnePointCompletion FE) failed) FE (Equation (OnePointCompletion FE)))) (SIGNATURE limit ((Union (OrderedCompletion FE) failed) FE (Equation FE) (String))))
      [2] complLimit:  %series has no value
      [3] realLimit:  %problem has no value
      [4] realLimit:  %series has no value
      [5] realLimit:  func has no value
      [6] realLimit:  prob has no value
      [7] xxpLimit:  %expansion has no value
      [8] limitPlus:  %problem has no value
      [9] limitPlus:  %series has no value
      [10] limitPlus:  func has no value
      [11] limitPlus:  prob has no value
 
=========================================================================
warnings 20111:

>compiling LODEEF.spad to LODEEF.nrlib
 
   Warnings: 
      [1] algSolve: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE solve ((Union (Record (: particular F) (: basis (List F))) failed) L F (Symbol))) (SIGNATURE solve ((Union F failed) L F (Symbol) F (List F))))
      [2] algSolve: not known that (Ring) is of mode (CATEGORY package (SIGNATURE solve ((Union (Record (: particular F) (: basis (List F))) failed) L F (Symbol))) (SIGNATURE solve ((Union F failed) L F (Symbol) F (List F))))
      [3] algSolve:  f1 has no value
      [4] doVarParams:  f1 has no value
      [5] xpart: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE solve ((Union (Record (: particular F) (: basis (List F))) failed) L F (Symbol))) (SIGNATURE solve ((Union F failed) L F (Symbol) F (List F))))
      [6] kovode:  z1 has no value
      [7] ulodo: not known that (Ring) is of mode (CATEGORY package (SIGNATURE solve ((Union (Record (: particular F) (: basis (List F))) failed) L F (Symbol))) (SIGNATURE solve ((Union F failed) L F (Symbol) F (List F))))
      [8] solve:  f1 has no value
 
=========================================================================
warnings 20110:

>compiling NODE1.spad to NODE1.nrlib
 
   Warnings: 
      [1] solve: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE solve ((Union F failed) F F (BasicOperator) (Symbol))))
      [2] checkBernoulli: not known that (Ring) is of mode (CATEGORY package (SIGNATURE solve ((Union F failed) F F (BasicOperator) (Symbol))))
 
=========================================================================
warnings 20109:

>compiling ODECONST.spad to ODECONST.nrlib
 
   Warnings: 
      [1] constDsolve:  f1 has no value
      [2] basisSqfr: not known that (Ring) is of mode (CATEGORY package (SIGNATURE constDsolve ((Record (: particular F) (: basis (List F))) L F (Symbol))))
 
=========================================================================
warnings 20108:

>compiling ODEEF.spad to ODEEF.nrlib
 
   Warnings: 
      [1] solve:  z1 has no value
      [2] solve:  z2 has no value
      [3] solve: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE solve ((Union (Record (: particular (Vector F)) (: basis (List (Vector F)))) failed) (Matrix F) (Vector F) (Symbol))) (SIGNATURE solve ((Union (List (Vector F)) failed) (Matrix F) (Symbol))) (SIGNATURE solve ((Union (Record (: particular (Vector F)) (: basis (List (Vector F)))) failed) (List (Equation F)) (List (BasicOperator)) (Symbol))) (SIGNATURE solve ((Union (Record (: particular (Vector F)) (: basis (List (Vector F)))) failed) (List F) (List (BasicOperator)) (Symbol))) (SIGNATURE solve ((Union (Record (: particular F) (: basis (List F))) F failed) (Equation F) (BasicOperator) (Symbol))) (SIGNATURE solve ((Union (Record (: particular F) (: basis (List F))) F failed) F (BasicOperator) (Symbol))) (SIGNATURE solve ((Union F failed) (Equation F) (BasicOperator) (Equation F) (List F))) (SIGNATURE solve ((Union F failed) F (BasicOperator) (Equation F) (List F))))
      [4] parseODE:  n has no value
      [5] parseODE:  c has no value
      [6] parseODE:  k has no value
      [7] getcoeff: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE solve ((Union (Record (: particular (Vector F)) (: basis (List (Vector F)))) failed) (Matrix F) (Vector F) (Symbol))) (SIGNATURE solve ((Union (List (Vector F)) failed) (Matrix F) (Symbol))) (SIGNATURE solve ((Union (Record (: particular (Vector F)) (: basis (List (Vector F)))) failed) (List (Equation F)) (List (BasicOperator)) (Symbol))) (SIGNATURE solve ((Union (Record (: particular (Vector F)) (: basis (List (Vector F)))) failed) (List F) (List (BasicOperator)) (Symbol))) (SIGNATURE solve ((Union (Record (: particular F) (: basis (List F))) F failed) (Equation F) (BasicOperator) (Symbol))) (SIGNATURE solve ((Union (Record (: particular F) (: basis (List F))) F failed) F (BasicOperator) (Symbol))) (SIGNATURE solve ((Union F failed) (Equation F) (BasicOperator) (Equation F) (List F))) (SIGNATURE solve ((Union F failed) F (BasicOperator) (Equation F) (List F))))
      [8] getcoeff: not known that (Ring) is of mode (CATEGORY package (SIGNATURE solve ((Union (Record (: particular (Vector F)) (: basis (List (Vector F)))) failed) (Matrix F) (Vector F) (Symbol))) (SIGNATURE solve ((Union (List (Vector F)) failed) (Matrix F) (Symbol))) (SIGNATURE solve ((Union (Record (: particular (Vector F)) (: basis (List (Vector F)))) failed) (List (Equation F)) (List (BasicOperator)) (Symbol))) (SIGNATURE solve ((Union (Record (: particular (Vector F)) (: basis (List (Vector F)))) failed) (List F) (List (BasicOperator)) (Symbol))) (SIGNATURE solve ((Union (Record (: particular F) (: basis (List F))) F failed) (Equation F) (BasicOperator) (Symbol))) (SIGNATURE solve ((Union (Record (: particular F) (: basis (List F))) F failed) F (BasicOperator) (Symbol))) (SIGNATURE solve ((Union F failed) (Equation F) (BasicOperator) (Equation F) (List F))) (SIGNATURE solve ((Union F failed) F (BasicOperator) (Equation F) (List F))))
 
=========================================================================
warnings 20107:

>compiling ODEINT.spad to ODEINT.nrlib
 
   Warnings: 
      [1] diff:  f1 has no value
      [2] mkprod:  z1 has no value
      [3] expint: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE int (F F (Symbol))) (SIGNATURE expint (F F (Symbol))) (SIGNATURE diff ((Mapping F F) (Symbol))))
      [4] expint:  lrec has no value
      [5] expint:  exponent has no value
      [6] isQlog: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE int (F F (Symbol))) (SIGNATURE expint (F F (Symbol))) (SIGNATURE diff ((Mapping F F) (Symbol))))
 
=========================================================================
warnings 20106:

>compiling QCMPACK.spad to QCMPACK.nrlib
 
   Warnings: 
      [1] removeSuperfluousCases:  x has no value
      [2] removeSuperfluousCases:  y has no value
      [3] removeSuperfluousCases:  maxcases has no value
      [4] removeSuperfluousCases:  lpwt1 has no value
      [5] removeSuperfluousCases:  headmaxcases has no value
      [6] removeSuperfluousCases:  toSave has no value
      [7] removeSuperfluousQuasiComponents:  maxlts has no value
      [8] removeSuperfluousQuasiComponents:  headmaxlts has no value
      [9] removeSuperfluousQuasiComponents:  toSave has no value
      [10] branchIfCan:  polnum has no value
      [11] prepareDecompose:  branches has no value
      [12] prepareDecompose:  x has no value
      [13] prepareDecompose:  y has no value
 
=========================================================================
warnings 20105:

>compiling REGSET.spad to REGSET.nrlib
 
   Warnings: 
      [1] construct:  ts has no value
      [2] preprocess:  lp1 has no value
      [3] preprocess:  lp2 has no value
      [4] preprocess:  lts has no value
 
=========================================================================
warnings 20104:

>compiling REP.spad to REP.nrlib
 
   Warnings: 
      [1] evalvect: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE radicalEigenvectors ((List (Record (: radval (Expression (Integer))) (: radmult (Integer)) (: radvect (List (Matrix (Expression (Integer))))))) (Matrix (Fraction (Polynomial (Integer)))))) (SIGNATURE radicalEigenvector ((List (Matrix (Expression (Integer)))) (Expression (Integer)) (Matrix (Fraction (Polynomial (Integer)))))) (SIGNATURE radicalEigenvalues ((List (Expression (Integer))) (Matrix (Fraction (Polynomial (Integer)))))) (SIGNATURE eigenMatrix ((Union (Matrix (Expression (Integer))) failed) (Matrix (Fraction (Polynomial (Integer)))))) (SIGNATURE normalise ((Matrix (Expression (Integer))) (Matrix (Expression (Integer))))) (SIGNATURE gramschmidt ((List (Matrix (Expression (Integer)))) (List (Matrix (Expression (Integer)))))) (SIGNATURE orthonormalBasis ((List (Matrix (Expression (Integer)))) (Matrix (Fraction (Polynomial (Integer)))))))
      [2] gramschmidt: :(PositiveInteger) -- should replace by pretend
      [3] gramschmidt: :RMR -- should replace by pretend
      [4] gramschmidt: :(Matrix (Expression (Integer))) -- should replace by pretend
 
=========================================================================
warnings 20103:

>compiling RSDCMPK.spad to RSDCMPK.nrlib
 
   Warnings: 
      [1] algebraicDecompose:  llpwt has no value
      [2] internalDecompose:  llpwt has no value
      [3] internalDecompose:  lts has no value
      [4] decompose:  toSave has no value
      [5] upDateBranches:  branches1 has no value
      [6] upDateBranches:  branches2 has no value
 
=========================================================================
warnings 20102:

>compiling SOLVERAD.spad to SOLVERAD.nrlib
 
   Warnings: 
      [1] quadratic: not known that (SIGNATURE ** ($ $ (Fraction (Integer)))) is of mode (CATEGORY domain (IF (has R (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace R)) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has R (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has R (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [2] findGenZeros: not known that (Ring) is of mode (CATEGORY package (SIGNATURE radicalSolve ((List (Equation (Expression R))) (Fraction (Polynomial R)) (Symbol))) (SIGNATURE radicalSolve ((List (Equation (Expression R))) (Fraction (Polynomial R)))) (SIGNATURE radicalSolve ((List (Equation (Expression R))) (Equation (Fraction (Polynomial R))) (Symbol))) (SIGNATURE radicalSolve ((List (Equation (Expression R))) (Equation (Fraction (Polynomial R))))) (SIGNATURE radicalSolve ((List (List (Equation (Expression R)))) (List (Fraction (Polynomial R))) (List (Symbol)))) (SIGNATURE radicalSolve ((List (List (Equation (Expression R)))) (List (Fraction (Polynomial R))))) (SIGNATURE radicalSolve ((List (List (Equation (Expression R)))) (List (Equation (Fraction (Polynomial R)))) (List (Symbol)))) (SIGNATURE radicalSolve ((List (List (Equation (Expression R)))) (List (Equation (Fraction (Polynomial R)))))) (SIGNATURE radicalRoots ((List (Expression R)) (Fraction (Polynomial R)) (Symbol))) (SIGNATURE radicalRoots ((List (List (Expression R))) (List (Fraction (Polynomial R))) (List (Symbol)))) (SIGNATURE contractSolve ((SuchThat (List (Expression R)) (List (Equation (Expression R)))) (Equation (Fraction (Polynomial R))) (Symbol))) (SIGNATURE contractSolve ((SuchThat (List (Expression R)) (List (Equation (Expression R)))) (Fraction (Polynomial R)) (Symbol))))
      [3] findGenZeros: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE radicalSolve ((List (Equation (Expression R))) (Fraction (Polynomial R)) (Symbol))) (SIGNATURE radicalSolve ((List (Equation (Expression R))) (Fraction (Polynomial R)))) (SIGNATURE radicalSolve ((List (Equation (Expression R))) (Equation (Fraction (Polynomial R))) (Symbol))) (SIGNATURE radicalSolve ((List (Equation (Expression R))) (Equation (Fraction (Polynomial R))))) (SIGNATURE radicalSolve ((List (List (Equation (Expression R)))) (List (Fraction (Polynomial R))) (List (Symbol)))) (SIGNATURE radicalSolve ((List (List (Equation (Expression R)))) (List (Fraction (Polynomial R))))) (SIGNATURE radicalSolve ((List (List (Equation (Expression R)))) (List (Equation (Fraction (Polynomial R)))) (List (Symbol)))) (SIGNATURE radicalSolve ((List (List (Equation (Expression R)))) (List (Equation (Fraction (Polynomial R)))))) (SIGNATURE radicalRoots ((List (Expression R)) (Fraction (Polynomial R)) (Symbol))) (SIGNATURE radicalRoots ((List (List (Expression R))) (List (Fraction (Polynomial R))) (List (Symbol)))) (SIGNATURE contractSolve ((SuchThat (List (Expression R)) (List (Equation (Expression R)))) (Equation (Fraction (Polynomial R))) (Symbol))) (SIGNATURE contractSolve ((SuchThat (List (Expression R)) (List (Equation (Expression R)))) (Fraction (Polynomial R)) (Symbol))))
      [4] findZeros: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE radicalSolve ((List (Equation (Expression R))) (Fraction (Polynomial R)) (Symbol))) (SIGNATURE radicalSolve ((List (Equation (Expression R))) (Fraction (Polynomial R)))) (SIGNATURE radicalSolve ((List (Equation (Expression R))) (Equation (Fraction (Polynomial R))) (Symbol))) (SIGNATURE radicalSolve ((List (Equation (Expression R))) (Equation (Fraction (Polynomial R))))) (SIGNATURE radicalSolve ((List (List (Equation (Expression R)))) (List (Fraction (Polynomial R))) (List (Symbol)))) (SIGNATURE radicalSolve ((List (List (Equation (Expression R)))) (List (Fraction (Polynomial R))))) (SIGNATURE radicalSolve ((List (List (Equation (Expression R)))) (List (Equation (Fraction (Polynomial R)))) (List (Symbol)))) (SIGNATURE radicalSolve ((List (List (Equation (Expression R)))) (List (Equation (Fraction (Polynomial R)))))) (SIGNATURE radicalRoots ((List (Expression R)) (Fraction (Polynomial R)) (Symbol))) (SIGNATURE radicalRoots ((List (List (Expression R))) (List (Fraction (Polynomial R))) (List (Symbol)))) (SIGNATURE contractSolve ((SuchThat (List (Expression R)) (List (Equation (Expression R)))) (Equation (Fraction (Polynomial R))) (Symbol))) (SIGNATURE contractSolve ((SuchThat (List (Expression R)) (List (Equation (Expression R)))) (Fraction (Polynomial R)) (Symbol))))
      [5] radicalRoots:  result has no value
      [6] solveInner:  solutions has no value
 
=========================================================================
warnings 20101:

>compiling SULS.spad to SULS.nrlib
 
   Warnings: 
      [1] exp: not known that (UnivariateLaurentSeriesConstructorCategory Coef (SparseUnivariateTaylorSeries Coef var cen)) is of mode (CATEGORY domain (SIGNATURE integrate ($ $ (Variable var))))
 
=========================================================================
warnings 20100:

>compiling UFPS1.spad to UFPS1.nrlib
 
   Warnings: 
      [1] hadamard:  z1 has no value
      [2] hadamard:  z2 has no value

=========================================================================
warnings 20099:

>compiling ULSCONS.spad to ULSCONS.nrlib
 
   Warnings: 
      [1] multiplyCoefficients:  z1 has no value
      [2] differentiate:  z1 has no value
      [3] integrate:  z has no value
      [4] integrate:  z1 has no value
      [5] termsToOutputForm:  l has no value
 
=========================================================================
warnings 20098:

>compiling UPXS.spad to UPXS.nrlib
 
   Warnings: 
      [1] termsToOutputForm:  l has no value
 
=========================================================================
warnings 20097:

>compiling UPXSCONS.spad to UPXSCONS.nrlib
 
   Warnings: 
      [1] terms:  t1 has no value
      [2] series:  t1 has no value
      [3] +:  z1 has no value
      [4] +:  z2 has no value
      [5] -:  z1 has no value
      [6] -:  z2 has no value
      [7] *:  z1 has no value
      [8] *:  z2 has no value
      [9] /:  z1 has no value
      [10] /:  z2 has no value
      [11] differentiate:  z1 has no value
      [12] integrate:  z1 has no value
 
=========================================================================
warnings 20096:

>compiling UTS.spad to UTS.nrlib
 
   Warnings: 
      [1] differentiate:  y has no value
      [2] integrate:  y has no value
 
=========================================================================
warnings 20095:

>compiling GPAFF.spad to GPAFF.nrlib
 
   Warnings: 
      [1] lBasis: pretend(Integer) -- should replace by @
      [2] genus:  theGenus has no value
      [3] genusNeg:  theGenus has no value
      [4] findOrderOfDivisor: pretend(Integer) -- should replace by @
      [5] desingTreeWoFullParam:  theTree has no value
      [6] adjunctionDivisor:  theAdjDiv has no value
      [7] singularPoints:  lesPtsSing has no value
      [8] rationalPoints:  lesRatPts has no value
      [9] ZetaFunction:  zf has no value
      [10] ZetaFunction: pretend(UnivariateTaylorSeriesCZero (Integer) t) -- should replace by @
      [11] numberOfPlacesOfDegreeUsingZeta: pretend(UnivariateTaylorSeriesCZero (Integer) t) -- should replace by @
      [12] numberOfPlacesOfDegreeUsingZeta:  serdel has no value
      [13] numberOfPlacesOfDegree:  calculatedNP has no value
      [14] numberPlacesDegExtDeg:  res has no value
 
=========================================================================
warnings 20094:

>compiling IRURPK.spad to IRURPK.nrlib
 
   Warnings: 
      [1] makeLinearAndMonic:  toSave has no value
      [2] rur:  toSave has no value

=========================================================================
warnings 20093:

>compiling LEXTRIPK.spad to LEXTRIPK.nrlib
 
   Warnings: 
      [1] trueVariables:  truels has no value
      [2] lexTriangular:  polnum has no value
      [3] lexTriangular:  toSave has no value
      [4] squareFreeLexTriangular:  polnum has no value
      [5] squareFreeLexTriangular:  toSave has no value
 
=========================================================================
warnings 20092:

>compiling NORMPK.spad to NORMPK.nrlib
 
   Warnings: 
      [1] normalizedAssociate:  mp has no value
      [2] normalizedAssociate:  tp has no value

=========================================================================
warnings 20091:

>compiling PACEXT.spad to PACEXT.nrlib
 
   Warnings: 
      [1] retractToGrn: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [2] down: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [3] lift: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [4] reduce: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [5] vectorise: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [6] +:  recEl has no value
      [7] *:  recEl has no value
      [8] *:  recTower has no value
      [9] inv: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [10] -: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [11] coerce: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [12] fullOutput: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [13] definingPolynomial: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [14] extDegree: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [15] previousTower: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
      [16] name: pretend(Record (: recEl (SparseUnivariatePolynomial $)) (: recTower (SparseUnivariatePolynomial $)) (: recDeg (PositiveInteger)) (: recPrevTower $) (: recName (Symbol))) -- should replace by @
 
=========================================================================
warnings 20090:

>compiling RECOP.spad to RECOP.nrlib
 
   Warnings: 
      [1] operatorName: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE evalRec (F (BasicOperator) (Symbol) F F F (List F))) (SIGNATURE evalADE (F (BasicOperator) (Symbol) F F F (List F))) (SIGNATURE getEq (F F)) (SIGNATURE getOp ((BasicOperator) F)) (SIGNATURE numberOfValuesNeeded ((Integer) (Integer) (BasicOperator) (Symbol) F)) (IF (has R (Ring)) (PROGN (SIGNATURE getShiftRec ((Union (Integer) failed) (BasicOperator) (Kernel F) (Symbol))) (SIGNATURE shiftInfoRec ((Record (: max (Union (Integer) failed)) (: ord (Union (Integer) failed)) (: ker (Kernel F))) (BasicOperator) (Symbol) F))) noBranch))
      [2] getShiftRec:  z has no value
      [3] getShiftRec: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE evalRec (F (BasicOperator) (Symbol) F F F (List F))) (SIGNATURE evalADE (F (BasicOperator) (Symbol) F F F (List F))) (SIGNATURE getEq (F F)) (SIGNATURE getOp ((BasicOperator) F)) (SIGNATURE numberOfValuesNeeded ((Integer) (Integer) (BasicOperator) (Symbol) F)) (IF (has R (Ring)) (PROGN (SIGNATURE getShiftRec ((Union (Integer) failed) (BasicOperator) (Kernel F) (Symbol))) (SIGNATURE shiftInfoRec ((Record (: max (Union (Integer) failed)) (: ord (Union (Integer) failed)) (: ker (Kernel F))) (BasicOperator) (Symbol) F))) noBranch))
      [4] getShiftRec: not known that (Ring) is of mode (CATEGORY package (SIGNATURE evalRec (F (BasicOperator) (Symbol) F F F (List F))) (SIGNATURE evalADE (F (BasicOperator) (Symbol) F F F (List F))) (SIGNATURE getEq (F F)) (SIGNATURE getOp ((BasicOperator) F)) (SIGNATURE numberOfValuesNeeded ((Integer) (Integer) (BasicOperator) (Symbol) F)) (IF (has R (Ring)) (PROGN (SIGNATURE getShiftRec ((Union (Integer) failed) (BasicOperator) (Kernel F) (Symbol))) (SIGNATURE shiftInfoRec ((Record (: max (Union (Integer) failed)) (: ord (Union (Integer) failed)) (: ker (Kernel F))) (BasicOperator) (Symbol) F))) noBranch))
      [5] shiftInfoRec:  maxShift has no value
      [6] shiftInfoRec:  minShift has no value
      [7] shiftInfoRec:  nextKernel has no value
      [8] evalRec:  ord has no value
      [9] evalRec:  ker has no value
      [10] evalRec:  z has no value
      [11] getOrder:  %diff has no value

 
=========================================================================
warnings 20089:

>compiling RURPK.spad to RURPK.nrlib
 
   Warnings: 
      [1] rur:  lq has no value
      [2] rur:  q has no value
      [3] rur:  toSave has no value
      [4] rur:  toReturn has no value
 
=========================================================================
warnings 20088:

>compiling SFRGCD.spad to SFRGCD.nrlib
 
   Warnings: 
      [1] stosePrepareSubResAlgo:  toSave has no value
      [2] stoseInternalLastSubResultant:  toReturn has no value
      [3] stoseInvertible?sqfreg:  x has no value
      [4] stoseInvertible?sqfreg:  y has no value
      [5] stoseInvertibleSetsqfreg:  toSave has no value
      [6] stoseInvertible?reg:  x has no value
      [7] stoseInvertible?reg:  y has no value
      [8] stoseInvertibleSetreg:  toSave has no value
 
=========================================================================
warnings 20087:

>compiling SFQCMPK.spad to SFQCMPK.nrlib
 
   Warnings: 
      [1] removeSuperfluousCases:  x has no value
      [2] removeSuperfluousCases:  y has no value
      [3] removeSuperfluousCases:  maxcases has no value
      [4] removeSuperfluousCases:  lpwt1 has no value
      [5] removeSuperfluousCases:  headmaxcases has no value
      [6] removeSuperfluousCases:  toSave has no value
      [7] removeSuperfluousQuasiComponents:  maxlts has no value
      [8] removeSuperfluousQuasiComponents:  headmaxlts has no value
      [9] removeSuperfluousQuasiComponents:  toSave has no value
      [10] branchIfCan:  polnum has no value
      [11] prepareDecompose:  branches has no value
      [12] prepareDecompose:  x has no value
      [13] prepareDecompose:  y has no value
 
=========================================================================
warnings 20086:

>compiling SRDCMPK.spad to SRDCMPK.nrlib
 
   Warnings: 
      [1] algebraicDecompose:  lts has no value
      [2] internalDecompose:  llpwt has no value
      [3] internalDecompose:  lts has no value
      [4] decompose:  toSave has no value
      [5] upDateBranches:  branches1 has no value
      [6] upDateBranches:  branches2 has no value

=========================================================================
warnings 20085:

>compiling SREGSET.spad to SREGSET.nrlib
 
   Warnings: 
      [1] construct:  ts has no value
      [2] internalAugment:  lts has no value
      [3] preprocess:  lp1 has no value
      [4] preprocess:  lp2 has no value
      [5] preprocess:  lts has no value
 
=========================================================================
warnings 20084:

>compiling ZDSOLVE.spad to ZDSOLVE.nrlib
 
   Warnings: 
      [1] squareFree:  toSave has no value
      [2] realSolve: not known that (Ring) is of mode (CATEGORY package (SIGNATURE triangSolve ((List (RegularChain R ls)) (List (Polynomial R)) (Boolean) (Boolean))) (SIGNATURE triangSolve ((List (RegularChain R ls)) (List (Polynomial R)) (Boolean))) (SIGNATURE triangSolve ((List (RegularChain R ls)) (List (Polynomial R)))) (SIGNATURE univariateSolve ((List (Record (: complexRoots (SparseUnivariatePolynomial R)) (: coordinates (List (Polynomial R))))) (RegularChain R ls))) (SIGNATURE univariateSolve ((List (Record (: complexRoots (SparseUnivariatePolynomial R)) (: coordinates (List (Polynomial R))))) (List (Polynomial R)) (Boolean) (Boolean) (Boolean))) (SIGNATURE univariateSolve ((List (Record (: complexRoots (SparseUnivariatePolynomial R)) (: coordinates (List (Polynomial R))))) (List (Polynomial R)) (Boolean) (Boolean))) (SIGNATURE univariateSolve ((List (Record (: complexRoots (SparseUnivariatePolynomial R)) (: coordinates (List (Polynomial R))))) (List (Polynomial R)) (Boolean))) (SIGNATURE univariateSolve ((List (Record (: complexRoots (SparseUnivariatePolynomial R)) (: coordinates (List (Polynomial R))))) (List (Polynomial R)))) (SIGNATURE realSolve ((List (List (RealClosure (Fraction R)))) (RegularChain R ls))) (SIGNATURE realSolve ((List (List (RealClosure (Fraction R)))) (List (Polynomial R)) (Boolean) (Boolean) (Boolean))) (SIGNATURE realSolve ((List (List (RealClosure (Fraction R)))) (List (Polynomial R)) (Boolean) (Boolean))) (SIGNATURE realSolve ((List (List (RealClosure (Fraction R)))) (List (Polynomial R)) (Boolean))) (SIGNATURE realSolve ((List (List (RealClosure (Fraction R)))) (List (Polynomial R)))) (SIGNATURE positiveSolve ((List (List (RealClosure (Fraction R)))) (RegularChain R ls))) (SIGNATURE positiveSolve ((List (List (RealClosure (Fraction R)))) (List (Polynomial R)) (Boolean) (Boolean))) (SIGNATURE positiveSolve ((List (List (RealClosure (Fraction R)))) (List (Polynomial R)) (Boolean))) (SIGNATURE positiveSolve ((List (List (RealClosure (Fraction R)))) (List (Polynomial R)))) (SIGNATURE squareFree ((List (SquareFreeRegularTriangularSet R (IndexedExponents (OrderedVariableList ls2)) (OrderedVariableList ls2) (NewSparseMultivariatePolynomial R (OrderedVariableList ls2)))) (RegularChain R ls))) (SIGNATURE convert ((NewSparseMultivariatePolynomial R (OrderedVariableList ls2)) (NewSparseMultivariatePolynomial R (OrderedVariableList ls)))) (SIGNATURE convert ((Polynomial (RealClosure (Fraction R))) (Polynomial R))) (SIGNATURE convert ((Polynomial (RealClosure (Fraction R))) (NewSparseMultivariatePolynomial R (OrderedVariableList ls2)))) (SIGNATURE convert ((SparseUnivariatePolynomial (RealClosure (Fraction R))) (SparseUnivariatePolynomial R))) (SIGNATURE convert ((List (NewSparseMultivariatePolynomial R (OrderedVariableList ls2))) (SquareFreeRegularTriangularSet R (IndexedExponents (OrderedVariableList ls2)) (OrderedVariableList ls2) (NewSparseMultivariatePolynomial R (OrderedVariableList ls2))))))
      [3] realSolve:  toSave has no value
      [4] positiveSolve:  toSave has no value
      [5] univariateSolve:  lq2 has no value
 

=========================================================================
warnings 20083:

>compiling GUESS.spad to GUESS.nrlib
 
   Warnings: 
      [1] guessExpRatAux: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE guess ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F))) (SIGNATURE guess ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption)))) (SIGNATURE guess ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (Mapping (List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption)))) (List (Symbol)))) (SIGNATURE guess ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (Mapping (List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption)))) (List (Symbol)) (List (GuessOption)))) (SIGNATURE guessExpRat ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F))) (SIGNATURE guessExpRat ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption)))) (SIGNATURE guessBinRat ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F))) (SIGNATURE guessBinRat ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption)))) (IF (has F (RetractableTo (Symbol))) (IF (has S (RetractableTo (Symbol))) (PROGN (SIGNATURE guessExpRat ((Mapping (List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption))) (Symbol))) (SIGNATURE guessBinRat ((Mapping (List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption))) (Symbol)))) noBranch) noBranch) (SIGNATURE guessHP ((Mapping (List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption))) (Mapping (Record (: guessStream (Mapping (Stream (UnivariateFormalPowerSeries F)) (UnivariateFormalPowerSeries F))) (: degreeStream (Stream (NonNegativeInteger))) (: testStream (Mapping (Stream (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F))) (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F)))) (: exprStream (Mapping (Stream EXPRR) EXPRR (Symbol))) (: A (Mapping S (NonNegativeInteger) (NonNegativeInteger) (SparseUnivariatePolynomial S))) (: AF (Mapping (SparseUnivariatePolynomial F) (NonNegativeInteger) (NonNegativeInteger) (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F)))) (: AX (Mapping EXPRR (NonNegativeInteger) (Symbol) EXPRR)) (: C (Mapping (List S) (NonNegativeInteger)))) (List (GuessOption))))) (SIGNATURE guessADE ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F))) (SIGNATURE guessADE ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption)))) (SIGNATURE guessAlg ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F))) (SIGNATURE guessAlg ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption)))) (SIGNATURE guessHolo ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F))) (SIGNATURE guessHolo ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption)))) (SIGNATURE guessPade ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption)))) (SIGNATURE guessPade ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F))) (SIGNATURE guessRec ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F))) (SIGNATURE guessRec ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption)))) (SIGNATURE guessPRec ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption)))) (SIGNATURE guessPRec ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F))) (SIGNATURE guessRat ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption)))) (SIGNATURE guessRat ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F))) (SIGNATURE diffHP ((Record (: guessStream (Mapping (Stream (UnivariateFormalPowerSeries F)) (UnivariateFormalPowerSeries F))) (: degreeStream (Stream (NonNegativeInteger))) (: testStream (Mapping (Stream (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F))) (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F)))) (: exprStream (Mapping (Stream EXPRR) EXPRR (Symbol))) (: A (Mapping S (NonNegativeInteger) (NonNegativeInteger) (SparseUnivariatePolynomial S))) (: AF (Mapping (SparseUnivariatePolynomial F) (NonNegativeInteger) (NonNegativeInteger) (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F)))) (: AX (Mapping EXPRR (NonNegativeInteger) (Symbol) EXPRR)) (: C (Mapping (List S) (NonNegativeInteger)))) (List (GuessOption)))) (SIGNATURE shiftHP ((Record (: guessStream (Mapping (Stream (UnivariateFormalPowerSeries F)) (UnivariateFormalPowerSeries F))) (: degreeStream (Stream (NonNegativeInteger))) (: testStream (Mapping (Stream (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F))) (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F)))) (: exprStream (Mapping (Stream EXPRR) EXPRR (Symbol))) (: A (Mapping S (NonNegativeInteger) (NonNegativeInteger) (SparseUnivariatePolynomial S))) (: AF (Mapping (SparseUnivariatePolynomial F) (NonNegativeInteger) (NonNegativeInteger) (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F)))) (: AX (Mapping EXPRR (NonNegativeInteger) (Symbol) EXPRR)) (: C (Mapping (List S) (NonNegativeInteger)))) (List (GuessOption)))) (IF (has F (RetractableTo (Symbol))) (IF (has S (RetractableTo (Symbol))) (PROGN (SIGNATURE shiftHP ((Mapping (Record (: guessStream (Mapping (Stream (UnivariateFormalPowerSeries F)) (UnivariateFormalPowerSeries F))) (: degreeStream (Stream (NonNegativeInteger))) (: testStream (Mapping (Stream (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F))) (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F)))) (: exprStream (Mapping (Stream EXPRR) EXPRR (Symbol))) (: A (Mapping S (NonNegativeInteger) (NonNegativeInteger) (SparseUnivariatePolynomial S))) (: AF (Mapping (SparseUnivariatePolynomial F) (NonNegativeInteger) (NonNegativeInteger) (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F)))) (: AX (Mapping EXPRR (NonNegativeInteger) (Symbol) EXPRR)) (: C (Mapping (List S) (NonNegativeInteger)))) (List (GuessOption))) (Symbol))) (SIGNATURE diffHP ((Mapping (Record (: guessStream (Mapping (Stream (UnivariateFormalPowerSeries F)) (UnivariateFormalPowerSeries F))) (: degreeStream (Stream (NonNegativeInteger))) (: testStream (Mapping (Stream (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F))) (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F)))) (: exprStream (Mapping (Stream EXPRR) EXPRR (Symbol))) (: A (Mapping S (NonNegativeInteger) (NonNegativeInteger) (SparseUnivariatePolynomial S))) (: AF (Mapping (SparseUnivariatePolynomial F) (NonNegativeInteger) (NonNegativeInteger) (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F)))) (: AX (Mapping EXPRR (NonNegativeInteger) (Symbol) EXPRR)) (: C (Mapping (List S) (NonNegativeInteger)))) (List (GuessOption))) (Symbol))) (SIGNATURE guessRec ((Mapping (List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption))) (Symbol))) (SIGNATURE guessPRec ((Mapping (List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption))) (Symbol))) (SIGNATURE guessRat ((Mapping (List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption))) (Symbol))) (SIGNATURE guessADE ((Mapping (List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption))) (Symbol)))) noBranch) noBranch))
      [2] guessExpRatAux: not known that (SIGNATURE variable ((Union $ failed) (Symbol))) is of mode (CATEGORY domain (SIGNATURE create ($)) (SIGNATURE convert ((Symbol) $)))
      [3] guessExpRatAux: not known that (PolynomialCategory F (IndexedExponents (OrderedVariableList (construct (QUOTE a1) (QUOTE A)))) (SingletonAsOrderedSet)) is of mode (CATEGORY domain (SIGNATURE outputForm ((OutputForm) $ (OutputForm))) (SIGNATURE fmecg ($ $ (NonNegativeInteger) F $)))
      [4] guessExpRatAux: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE guess ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F))) (SIGNATURE guess ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption)))) (SIGNATURE guess ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (Mapping (List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption)))) (List (Symbol)))) (SIGNATURE guess ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (Mapping (List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption)))) (List (Symbol)) (List (GuessOption)))) (SIGNATURE guessExpRat ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F))) (SIGNATURE guessExpRat ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption)))) (SIGNATURE guessBinRat ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F))) (SIGNATURE guessBinRat ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption)))) (IF (has F (RetractableTo (Symbol))) (IF (has S (RetractableTo (Symbol))) (PROGN (SIGNATURE guessExpRat ((Mapping (List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption))) (Symbol))) (SIGNATURE guessBinRat ((Mapping (List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption))) (Symbol)))) noBranch) noBranch) (SIGNATURE guessHP ((Mapping (List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption))) (Mapping (Record (: guessStream (Mapping (Stream (UnivariateFormalPowerSeries F)) (UnivariateFormalPowerSeries F))) (: degreeStream (Stream (NonNegativeInteger))) (: testStream (Mapping (Stream (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F))) (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F)))) (: exprStream (Mapping (Stream EXPRR) EXPRR (Symbol))) (: A (Mapping S (NonNegativeInteger) (NonNegativeInteger) (SparseUnivariatePolynomial S))) (: AF (Mapping (SparseUnivariatePolynomial F) (NonNegativeInteger) (NonNegativeInteger) (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F)))) (: AX (Mapping EXPRR (NonNegativeInteger) (Symbol) EXPRR)) (: C (Mapping (List S) (NonNegativeInteger)))) (List (GuessOption))))) (SIGNATURE guessADE ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F))) (SIGNATURE guessADE ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption)))) (SIGNATURE guessAlg ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F))) (SIGNATURE guessAlg ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption)))) (SIGNATURE guessHolo ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F))) (SIGNATURE guessHolo ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption)))) (SIGNATURE guessPade ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption)))) (SIGNATURE guessPade ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F))) (SIGNATURE guessRec ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F))) (SIGNATURE guessRec ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption)))) (SIGNATURE guessPRec ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption)))) (SIGNATURE guessPRec ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F))) (SIGNATURE guessRat ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption)))) (SIGNATURE guessRat ((List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F))) (SIGNATURE diffHP ((Record (: guessStream (Mapping (Stream (UnivariateFormalPowerSeries F)) (UnivariateFormalPowerSeries F))) (: degreeStream (Stream (NonNegativeInteger))) (: testStream (Mapping (Stream (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F))) (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F)))) (: exprStream (Mapping (Stream EXPRR) EXPRR (Symbol))) (: A (Mapping S (NonNegativeInteger) (NonNegativeInteger) (SparseUnivariatePolynomial S))) (: AF (Mapping (SparseUnivariatePolynomial F) (NonNegativeInteger) (NonNegativeInteger) (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F)))) (: AX (Mapping EXPRR (NonNegativeInteger) (Symbol) EXPRR)) (: C (Mapping (List S) (NonNegativeInteger)))) (List (GuessOption)))) (SIGNATURE shiftHP ((Record (: guessStream (Mapping (Stream (UnivariateFormalPowerSeries F)) (UnivariateFormalPowerSeries F))) (: degreeStream (Stream (NonNegativeInteger))) (: testStream (Mapping (Stream (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F))) (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F)))) (: exprStream (Mapping (Stream EXPRR) EXPRR (Symbol))) (: A (Mapping S (NonNegativeInteger) (NonNegativeInteger) (SparseUnivariatePolynomial S))) (: AF (Mapping (SparseUnivariatePolynomial F) (NonNegativeInteger) (NonNegativeInteger) (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F)))) (: AX (Mapping EXPRR (NonNegativeInteger) (Symbol) EXPRR)) (: C (Mapping (List S) (NonNegativeInteger)))) (List (GuessOption)))) (IF (has F (RetractableTo (Symbol))) (IF (has S (RetractableTo (Symbol))) (PROGN (SIGNATURE shiftHP ((Mapping (Record (: guessStream (Mapping (Stream (UnivariateFormalPowerSeries F)) (UnivariateFormalPowerSeries F))) (: degreeStream (Stream (NonNegativeInteger))) (: testStream (Mapping (Stream (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F))) (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F)))) (: exprStream (Mapping (Stream EXPRR) EXPRR (Symbol))) (: A (Mapping S (NonNegativeInteger) (NonNegativeInteger) (SparseUnivariatePolynomial S))) (: AF (Mapping (SparseUnivariatePolynomial F) (NonNegativeInteger) (NonNegativeInteger) (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F)))) (: AX (Mapping EXPRR (NonNegativeInteger) (Symbol) EXPRR)) (: C (Mapping (List S) (NonNegativeInteger)))) (List (GuessOption))) (Symbol))) (SIGNATURE diffHP ((Mapping (Record (: guessStream (Mapping (Stream (UnivariateFormalPowerSeries F)) (UnivariateFormalPowerSeries F))) (: degreeStream (Stream (NonNegativeInteger))) (: testStream (Mapping (Stream (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F))) (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F)))) (: exprStream (Mapping (Stream EXPRR) EXPRR (Symbol))) (: A (Mapping S (NonNegativeInteger) (NonNegativeInteger) (SparseUnivariatePolynomial S))) (: AF (Mapping (SparseUnivariatePolynomial F) (NonNegativeInteger) (NonNegativeInteger) (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F)))) (: AX (Mapping EXPRR (NonNegativeInteger) (Symbol) EXPRR)) (: C (Mapping (List S) (NonNegativeInteger)))) (List (GuessOption))) (Symbol))) (SIGNATURE guessRec ((Mapping (List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption))) (Symbol))) (SIGNATURE guessPRec ((Mapping (List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption))) (Symbol))) (SIGNATURE guessRat ((Mapping (List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption))) (Symbol))) (SIGNATURE guessADE ((Mapping (List (Record (: function EXPRR) (: order (NonNegativeInteger)))) (List F) (List (GuessOption))) (Symbol)))) noBranch) noBranch))
      [5] guessExpRatAux0:  zeros has no value
      [6] guessExpRatAux0:  newlist has no value
      [7] guessExpRatAux0:  xValues has no value
      [8] guessBinRatAux0:  zeros has no value
      [9] guessBinRatAux0:  newlist has no value
      [10] guessBinRatAux0:  xValues has no value
      [11] diffHP: signature of lhs not unique: (Record (: guessStream (Mapping (Stream (UnivariateFormalPowerSeries F)) (UnivariateFormalPowerSeries F))) (: degreeStream (Stream (NonNegativeInteger))) (: testStream (Mapping (Stream (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F))) (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F)))) (: exprStream (Mapping (Stream EXPRR) EXPRR (Symbol))) (: A (Mapping S (NonNegativeInteger) (NonNegativeInteger) (SparseUnivariatePolynomial S))) (: AF (Mapping (SparseUnivariatePolynomial F) (NonNegativeInteger) (NonNegativeInteger) (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F)))) (: AX (Mapping EXPRR (NonNegativeInteger) (Symbol) EXPRR)) (: C (Mapping (List S) (NonNegativeInteger))))(List (GuessOption)) chosen
      [12] shiftHP: signature of lhs not unique: (Record (: guessStream (Mapping (Stream (UnivariateFormalPowerSeries F)) (UnivariateFormalPowerSeries F))) (: degreeStream (Stream (NonNegativeInteger))) (: testStream (Mapping (Stream (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F))) (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F)))) (: exprStream (Mapping (Stream EXPRR) EXPRR (Symbol))) (: A (Mapping S (NonNegativeInteger) (NonNegativeInteger) (SparseUnivariatePolynomial S))) (: AF (Mapping (SparseUnivariatePolynomial F) (NonNegativeInteger) (NonNegativeInteger) (UnivariateFormalPowerSeries (SparseUnivariatePolynomial F)))) (: AX (Mapping EXPRR (NonNegativeInteger) (Symbol) EXPRR)) (: C (Mapping (List S) (NonNegativeInteger))))(List (GuessOption)) chosen
      [13] guessInterpolate: not known that (FiniteAbelianMonoidRing (Fraction S) (NonNegativeInteger)) is of mode (CATEGORY domain (SIGNATURE outputForm ((OutputForm) $ (OutputForm))) (SIGNATURE fmecg ($ $ (NonNegativeInteger) F $)))
      [14] testInterpolant:  nonZeroCoefficient has no value
      [15] guessHPaux:  guessDegree has no value
      [16] guessHPaux:  maxEta has no value
      [17] guessHPaux:  reslist has no value
      [18] guessHPaux:  eta has no value
      [19] guess:  res has no value

=========================================================================
warnings 20082:

>compiling INFCLSPT.spad to INFCLSPT.nrlib
 
   Warnings: 
      [1] create:  P has no value
      [2] create:  chartA has no value
      [3] subMultV: :Rep -- should replace by pretend
      [4] setsubmult!: :Rep -- should replace by pretend
      [5] pointV: :Rep -- should replace by pretend
      [6] symbNameV: :Rep -- should replace by pretend
      [7] curveV: :Rep -- should replace by pretend
      [8] localPointV: :Rep -- should replace by pretend
      [9] multV: :Rep -- should replace by pretend
      [10] chartV: :Rep -- should replace by pretend
      [11] excpDivV: :Rep -- should replace by pretend
      [12] localParamV: :Rep -- should replace by pretend
      [13] actualExtensionV: :Rep -- should replace by pretend
      [14] setpoint!: :Rep -- should replace by pretend
      [15] setcurve!: :Rep -- should replace by pretend
      [16] setlocalPoint!: :Rep -- should replace by pretend
      [17] setmult!: :Rep -- should replace by pretend
      [18] setchart!: :Rep -- should replace by pretend
      [19] setlocalParam!: :Rep -- should replace by pretend
      [20] setexcpDiv!: :Rep -- should replace by pretend
      [21] setsymbName!: :Rep -- should replace by pretend
 
=========================================================================
warnings 20081:

>compiling GUESSAN.spad to GUESSAN.nrlib
 
   Warnings: 
      [1] not known that (RetractableTo (AlgebraicNumber)) is of mode (CATEGORY domain (IF (has (Integer) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Integer))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Integer) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Integer) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [2] not known that (CombinatorialOpsCategory) is of mode (CATEGORY domain (IF (has (Integer) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Integer))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Integer) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Integer) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [3] not known that (SIGNATURE ** ($ $ $)) is of mode (CATEGORY domain (IF (has (Integer) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Integer))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Integer) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Integer) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))

=========================================================================
warnings 20080:

>compiling GUESSINT.spad to GUESSINT.nrlib
 
   Warnings: 
      [1] not known that (CombinatorialOpsCategory) is of mode (CATEGORY domain (IF (has (Integer) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Integer))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Integer) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Integer) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [2] not known that (SIGNATURE ** ($ $ $)) is of mode (CATEGORY domain (IF (has (Integer) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Integer))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Integer) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Integer) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
 
=========================================================================
warnings 20079:

>compiling GUESSP.spad to GUESSP.nrlib
 
   Warnings: 
      [1] not known that (CombinatorialOpsCategory) is of mode (CATEGORY domain (IF (has (Integer) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Integer))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Integer) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Integer) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [2] not known that (SIGNATURE ** ($ $ $)) is of mode (CATEGORY domain (IF (has (Integer) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Integer))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Integer) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Integer) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
 
=========================================================================
warnings 20078:

>compiling GUESSUP.spad to GUESSUP.nrlib
 
   Warnings: 
      [1] not known that (RetractableTo (Fraction (MyUnivariatePolynomial q (Integer)))) is of mode (CATEGORY domain (SIGNATURE * ($ $ $)) (SIGNATURE / ($ $ $)) (SIGNATURE ** ($ $ $)) (SIGNATURE numerator ($ $)) (SIGNATURE denominator ($ $)) (SIGNATURE ground? ((Boolean) $)) (SIGNATURE coerce ($ (Fraction (MyUnivariatePolynomial q (Integer))))) (SIGNATURE retract ((Fraction (MyUnivariatePolynomial q (Integer))) $)))
 
=========================================================================
warnings 20077:

>compiling GUESSF.spad to GUESSF.nrlib
 
   Warnings: 
      [1] not known that (CombinatorialOpsCategory) is of mode (CATEGORY domain (IF (has (Integer) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Integer))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Integer) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Integer) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [2] not known that (SIGNATURE ** ($ $ $)) is of mode (CATEGORY domain (IF (has (Integer) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Integer))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Integer) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Integer) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
 
=========================================================================
warnings 20076:

>compiling PAFF.spad to PAFF.nrlib
 
   Warnings: 
      [1] homogenize: not known that (FiniteAbelianMonoidRing K (DirectProduct (call LENGTH symb) (NonNegativeInteger))) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
 
=========================================================================
warnings 20075:

>compiling PAFFFF.spad to PAFFFF.nrlib
 
   Warnings: 
      [1] homogenize: not known that (FiniteAbelianMonoidRing K (DirectProduct (call LENGTH symb) (NonNegativeInteger))) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
 
(1) -> copying PAFFFF.nrlib to PAFFFF.o
cl1 making /research/test/mnt/ubuntu/algebra/PAFF.o from /research/test/int/algebra/clique2.spad
cl1 making /research/test/mnt/ubuntu/algebra/PAFFFF.o from /research/test/int/algebra/clique2.spad
 
   Warnings: 
      [1] homogenize: not known that (FiniteAbelianMonoidRing K (DirectProduct (call LENGTH symb) (NonNegativeInteger))) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))

=========================================================================
warnings 20074:

>compiling CLAGG.spad to CLAGG.nrlib
 
   Warnings: 
      [1] remove:  y has no value
 
=========================================================================
warnings 20072:

>compiling ES.spad to ES.nrlib
 
   Warnings: 
      [1] tower: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE odd? ((Boolean) S)) (SIGNATURE even? ((Boolean) S)) (SIGNATURE eval (S S (BasicOperator) (Mapping S S))) (SIGNATURE eval (S S (BasicOperator) (Mapping S (List S)))) (SIGNATURE eval (S S (List (BasicOperator)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (BasicOperator)) (List (Mapping S S)))) (SIGNATURE eval (S S (Symbol) (Mapping S S))) (SIGNATURE eval (S S (Symbol) (Mapping S (List S)))) (SIGNATURE eval (S S (List (Symbol)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (Symbol)) (List (Mapping S S)))) (SIGNATURE freeOf? ((Boolean) S (Symbol))) (SIGNATURE freeOf? ((Boolean) S S)) (SIGNATURE map (S (Mapping S S) (Kernel S))) (SIGNATURE kernel (S (BasicOperator) (List S))) (SIGNATURE kernel (S (BasicOperator) S)) (SIGNATURE is? ((Boolean) S (Symbol))) (SIGNATURE is? ((Boolean) S (BasicOperator))) (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE operators ((List (BasicOperator)) S)) (SIGNATURE tower ((List (Kernel S)) S)) (SIGNATURE mainKernel ((Union (Kernel S) failed) S)) (SIGNATURE height ((NonNegativeInteger) S)) (SIGNATURE distribute (S S S)) (SIGNATURE distribute (S S)) (SIGNATURE paren (S (List S))) (SIGNATURE paren (S S)) (SIGNATURE box (S (List S))) (SIGNATURE box (S S)) (SIGNATURE subst (S S (List (Kernel S)) (List S))) (SIGNATURE subst (S S (List (Equation S)))) (SIGNATURE subst (S S (Equation S))) (SIGNATURE elt (S (BasicOperator) (List S))) (SIGNATURE elt (S (BasicOperator) S S S S)) (SIGNATURE elt (S (BasicOperator) S S S)) (SIGNATURE elt (S (BasicOperator) S S)) (SIGNATURE elt (S (BasicOperator) S)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE eval (S S (List (Kernel S)) (List S))) (SIGNATURE eval (S S (Kernel S) S)) (SIGNATURE retract ((Kernel S) S)) (SIGNATURE retractIfCan ((Union (Kernel S) failed) S)))
      [2] freeOf?: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE odd? ((Boolean) S)) (SIGNATURE even? ((Boolean) S)) (SIGNATURE eval (S S (BasicOperator) (Mapping S S))) (SIGNATURE eval (S S (BasicOperator) (Mapping S (List S)))) (SIGNATURE eval (S S (List (BasicOperator)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (BasicOperator)) (List (Mapping S S)))) (SIGNATURE eval (S S (Symbol) (Mapping S S))) (SIGNATURE eval (S S (Symbol) (Mapping S (List S)))) (SIGNATURE eval (S S (List (Symbol)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (Symbol)) (List (Mapping S S)))) (SIGNATURE freeOf? ((Boolean) S (Symbol))) (SIGNATURE freeOf? ((Boolean) S S)) (SIGNATURE map (S (Mapping S S) (Kernel S))) (SIGNATURE kernel (S (BasicOperator) (List S))) (SIGNATURE kernel (S (BasicOperator) S)) (SIGNATURE is? ((Boolean) S (Symbol))) (SIGNATURE is? ((Boolean) S (BasicOperator))) (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE operators ((List (BasicOperator)) S)) (SIGNATURE tower ((List (Kernel S)) S)) (SIGNATURE mainKernel ((Union (Kernel S) failed) S)) (SIGNATURE height ((NonNegativeInteger) S)) (SIGNATURE distribute (S S S)) (SIGNATURE distribute (S S)) (SIGNATURE paren (S (List S))) (SIGNATURE paren (S S)) (SIGNATURE box (S (List S))) (SIGNATURE box (S S)) (SIGNATURE subst (S S (List (Kernel S)) (List S))) (SIGNATURE subst (S S (List (Equation S)))) (SIGNATURE subst (S S (Equation S))) (SIGNATURE elt (S (BasicOperator) (List S))) (SIGNATURE elt (S (BasicOperator) S S S S)) (SIGNATURE elt (S (BasicOperator) S S S)) (SIGNATURE elt (S (BasicOperator) S S)) (SIGNATURE elt (S (BasicOperator) S)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE eval (S S (List (Kernel S)) (List S))) (SIGNATURE eval (S S (Kernel S) S)) (SIGNATURE retract ((Kernel S) S)) (SIGNATURE retractIfCan ((Union (Kernel S) failed) S)))
      [3] eval:  y has no value
      [4] eval:  IN has no value
      [5] eval:  f has no value
      [6] eval:  s has no value
      [7] map:  IN has no value
      [8] map:  x has no value

=========================================================================
warnings 20071:

>compiling EUCDOM.spad to EUCDOM.nrlib
 
   Warnings: 
      [1] principalIdeal:  coef1 has no value
      [2] principalIdeal:  coef2 has no value

=========================================================================
warnings 20070:

>compiling FFIELDC.spad to FFIELDC.nrlib
 
   Warnings: 
      [1] conditionP: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE order ((PositiveInteger) S)) (SIGNATURE discreteLog ((NonNegativeInteger) S)) (SIGNATURE primitive? ((Boolean) S)) (SIGNATURE createPrimitiveElement (S)) (SIGNATURE conditionP ((Union (Vector S) failed) (Matrix S))) (SIGNATURE charthRoot (S S)) (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE init (S)) (SIGNATURE nextItem ((Union S failed) S)) (SIGNATURE discreteLog ((Union (NonNegativeInteger) failed) S S)) (SIGNATURE order ((OnePointCompletion (PositiveInteger)) S)) (SIGNATURE charthRoot ((Union S failed) S)) (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))))
      [2] order: signature of lhs not unique: (PositiveInteger)S chosen
      [3] order:  ord has no value
      [4] discreteLog:  disc1 has no value
      [5] discreteLog:  disclog has no value
      [6] discreteLog: not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE order ((PositiveInteger) S)) (SIGNATURE discreteLog ((NonNegativeInteger) S)) (SIGNATURE primitive? ((Boolean) S)) (SIGNATURE createPrimitiveElement (S)) (SIGNATURE conditionP ((Union (Vector S) failed) (Matrix S))) (SIGNATURE charthRoot (S S)) (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE init (S)) (SIGNATURE nextItem ((Union S failed) S)) (SIGNATURE discreteLog ((Union (NonNegativeInteger) failed) S S)) (SIGNATURE order ((OnePointCompletion (PositiveInteger)) S)) (SIGNATURE charthRoot ((Union S failed) S)) (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))))
      [7] gcdPolynomial: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE order ((PositiveInteger) S)) (SIGNATURE discreteLog ((NonNegativeInteger) S)) (SIGNATURE primitive? ((Boolean) S)) (SIGNATURE createPrimitiveElement (S)) (SIGNATURE conditionP ((Union (Vector S) failed) (Matrix S))) (SIGNATURE charthRoot (S S)) (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE init (S)) (SIGNATURE nextItem ((Union S failed) S)) (SIGNATURE discreteLog ((Union (NonNegativeInteger) failed) S S)) (SIGNATURE order ((OnePointCompletion (PositiveInteger)) S)) (SIGNATURE charthRoot ((Union S failed) S)) (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))))
 
=========================================================================
warnings 20069:

>compiling GCDDOM.spad to GCDDOM.nrlib
 
   Warnings: 
      [1] gcdPolynomial: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))) (SIGNATURE lcm (S (List S))) (SIGNATURE lcm (S S S)) (SIGNATURE gcd (S (List S))) (SIGNATURE gcd (S S S)))
 
=========================================================================
warnings 20068:

>compiling HOAGG.spad to HOAGG.nrlib
 
   Warnings: 
      [1] eval:  x has no value
      [2] count:  y has no value
      [3] member?:  x has no value
 

=========================================================================
warnings 20067:

>compiling ILIST.spad to ILIST.nrlib
 
   Warnings: 
      [1] latex:  s has no value
 
=========================================================================
warnings 20066:

>compiling INS.spad to INS.nrlib
 
   Warnings: 
      [1] factor: not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE invmod (S S S)) (SIGNATURE powmod (S S S S)) (SIGNATURE mask (S S)) (SIGNATURE copy (S S)) (SIGNATURE rationalIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE rational ((Fraction (Integer)) S)) (SIGNATURE rational? ((Boolean) S)) (SIGNATURE symmetricRemainder (S S S)) (SIGNATURE bit? ((Boolean) S S)) (SIGNATURE even? ((Boolean) S)) (SIGNATURE init (S)) (SIGNATURE nextItem ((Union S failed) S)) (SIGNATURE convert ((DoubleFloat) S)) (SIGNATURE convert ((Float) S)) (SIGNATURE permutation (S S S)) (SIGNATURE factorial (S S)) (SIGNATURE binomial (S S S)) (SIGNATURE patternMatch ((PatternMatchResult (Integer) S) S (Pattern (Integer)) (PatternMatchResult (Integer) S))) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE convert ((InputForm) S)) (SIGNATURE retract ((Integer) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE convert ((Integer) S)) (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE positive? ((Boolean) S)) (SIGNATURE euclideanSize ((NonNegativeInteger) S)) (SIGNATURE factor ((Factored S) S)) (SIGNATURE squareFree ((Factored S) S)) (SIGNATURE prime? ((Boolean) S)) (SIGNATURE characteristic ((NonNegativeInteger))))
      [2] patternMatch: not known that (SetCategory) is of mode (CATEGORY domain (SIGNATURE invmod (S S S)) (SIGNATURE powmod (S S S S)) (SIGNATURE mask (S S)) (SIGNATURE copy (S S)) (SIGNATURE rationalIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE rational ((Fraction (Integer)) S)) (SIGNATURE rational? ((Boolean) S)) (SIGNATURE symmetricRemainder (S S S)) (SIGNATURE bit? ((Boolean) S S)) (SIGNATURE even? ((Boolean) S)) (SIGNATURE init (S)) (SIGNATURE nextItem ((Union S failed) S)) (SIGNATURE convert ((DoubleFloat) S)) (SIGNATURE convert ((Float) S)) (SIGNATURE permutation (S S S)) (SIGNATURE factorial (S S)) (SIGNATURE binomial (S S S)) (SIGNATURE patternMatch ((PatternMatchResult (Integer) S) S (Pattern (Integer)) (PatternMatchResult (Integer) S))) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE convert ((InputForm) S)) (SIGNATURE retract ((Integer) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE convert ((Integer) S)) (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE positive? ((Boolean) S)) (SIGNATURE euclideanSize ((NonNegativeInteger) S)) (SIGNATURE factor ((Factored S) S)) (SIGNATURE squareFree ((Factored S) S)) (SIGNATURE prime? ((Boolean) S)) (SIGNATURE characteristic ((NonNegativeInteger))))
      [3] powmod:  y has no value
 

=========================================================================
warnings 20065:

>compiling INT.spad to INT.nrlib
 
   Warnings: 
      [1] OMwrite: pretend(String) -- should replace by @
      [2] hash: signature of lhs not unique: $$ chosen
      [3] factorPolynomial: not known that (UnivariatePolynomialCategory (Integer)) is of mode (CATEGORY domain (SIGNATURE outputForm ((OutputForm) $ (OutputForm))) (SIGNATURE fmecg ($ $ (NonNegativeInteger) $ $)))
      [4] factorPolynomial:  x1 has no value
      [5] gcdPolynomial: not known that (UnivariatePolynomialCategory (Integer)) is of mode (CATEGORY domain (SIGNATURE outputForm ((OutputForm) $ (OutputForm))) (SIGNATURE fmecg ($ $ (NonNegativeInteger) $ $)))
 

=========================================================================
warnings 20064:

>compiling ISTRING.spad to ISTRING.nrlib
 
   Warnings: 
      [1] split:  j has no value
 
=========================================================================
warnings 20062:

>compiling LSAGG.spad to LSAGG.nrlib
 
   Warnings: 
      [1] removeDuplicates!:  x has no value
 
=========================================================================
warnings 20061:

>compiling POLYCAT.spad to POLYCAT.nrlib
 
   Warnings: 
      [1] eval:  IN has no value
      [2] coefficient: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))) (SIGNATURE squareFree ((Factored S) S)) (SIGNATURE squareFreePart (S S)) (SIGNATURE charthRoot ((Union S failed) S)) (SIGNATURE < ((Boolean) S S)) (SIGNATURE convert ((InputForm) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE patternMatch ((PatternMatchResult (Integer) S) S (Pattern (Integer)) (PatternMatchResult (Integer) S))) (SIGNATURE patternMatch ((PatternMatchResult (Float) S) S (Pattern (Float)) (PatternMatchResult (Float) S))) (SIGNATURE factor ((Factored S) S)) (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE conditionP ((Union (Vector S) failed) (Matrix S))) (SIGNATURE primitivePart (S S VarSet)) (SIGNATURE content (S S VarSet)) (SIGNATURE discriminant (S S VarSet)) (SIGNATURE resultant (S S S VarSet)) (SIGNATURE primitiveMonomials ((List S) S)) (SIGNATURE totalDegree ((NonNegativeInteger) S (List VarSet))) (SIGNATURE totalDegree ((NonNegativeInteger) S)) (SIGNATURE isExpt ((Union (Record (: var VarSet) (: exponent (NonNegativeInteger))) failed) S)) (SIGNATURE isTimes ((Union (List S) failed) S)) (SIGNATURE isPlus ((Union (List S) failed) S)) (SIGNATURE monomial (S S (List VarSet) (List (NonNegativeInteger)))) (SIGNATURE monomial (S S VarSet (NonNegativeInteger))) (SIGNATURE monicDivide ((Record (: quotient S) (: remainder S)) S S VarSet)) (SIGNATURE monomials ((List S) S)) (SIGNATURE coefficient (S S (List VarSet) (List (NonNegativeInteger)))) (SIGNATURE coefficient (S S VarSet (NonNegativeInteger))) (SIGNATURE reducedSystem ((Matrix R) (Matrix S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix R)) (: vec (Vector R))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix S))) (SIGNATURE retract (VarSet S)) (SIGNATURE retractIfCan ((Union VarSet failed) S)) (SIGNATURE eval (S S (List VarSet) (List S))) (SIGNATURE eval (S S VarSet S)) (SIGNATURE eval (S S (List VarSet) (List R))) (SIGNATURE eval (S S VarSet R)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE monomial (S R E)) (SIGNATURE coefficient (R S E)) (SIGNATURE retract ((Integer) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retract (R S)) (SIGNATURE content (R S)) (SIGNATURE primitivePart (S S)))
      [3] totalDegree:  w has no value
      [4] reducedSystem:  IN has no value
      [5] reducedSystem:  r has no value
      [6] reducedSystem: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))) (SIGNATURE squareFree ((Factored S) S)) (SIGNATURE squareFreePart (S S)) (SIGNATURE charthRoot ((Union S failed) S)) (SIGNATURE < ((Boolean) S S)) (SIGNATURE convert ((InputForm) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE patternMatch ((PatternMatchResult (Integer) S) S (Pattern (Integer)) (PatternMatchResult (Integer) S))) (SIGNATURE patternMatch ((PatternMatchResult (Float) S) S (Pattern (Float)) (PatternMatchResult (Float) S))) (SIGNATURE factor ((Factored S) S)) (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE conditionP ((Union (Vector S) failed) (Matrix S))) (SIGNATURE primitivePart (S S VarSet)) (SIGNATURE content (S S VarSet)) (SIGNATURE discriminant (S S VarSet)) (SIGNATURE resultant (S S S VarSet)) (SIGNATURE primitiveMonomials ((List S) S)) (SIGNATURE totalDegree ((NonNegativeInteger) S (List VarSet))) (SIGNATURE totalDegree ((NonNegativeInteger) S)) (SIGNATURE isExpt ((Union (Record (: var VarSet) (: exponent (NonNegativeInteger))) failed) S)) (SIGNATURE isTimes ((Union (List S) failed) S)) (SIGNATURE isPlus ((Union (List S) failed) S)) (SIGNATURE monomial (S S (List VarSet) (List (NonNegativeInteger)))) (SIGNATURE monomial (S S VarSet (NonNegativeInteger))) (SIGNATURE monicDivide ((Record (: quotient S) (: remainder S)) S S VarSet)) (SIGNATURE monomials ((List S) S)) (SIGNATURE coefficient (S S (List VarSet) (List (NonNegativeInteger)))) (SIGNATURE coefficient (S S VarSet (NonNegativeInteger))) (SIGNATURE reducedSystem ((Matrix R) (Matrix S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix R)) (: vec (Vector R))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix S))) (SIGNATURE retract (VarSet S)) (SIGNATURE retractIfCan ((Union VarSet failed) S)) (SIGNATURE eval (S S (List VarSet) (List S))) (SIGNATURE eval (S S VarSet S)) (SIGNATURE eval (S S (List VarSet) (List R))) (SIGNATURE eval (S S VarSet R)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE monomial (S R E)) (SIGNATURE coefficient (R S E)) (SIGNATURE retract ((Integer) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retract (R S)) (SIGNATURE content (R S)) (SIGNATURE primitivePart (S S)))
      [7] solveLinearPolynomialEquation: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))) (SIGNATURE squareFree ((Factored S) S)) (SIGNATURE squareFreePart (S S)) (SIGNATURE charthRoot ((Union S failed) S)) (SIGNATURE < ((Boolean) S S)) (SIGNATURE convert ((InputForm) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE patternMatch ((PatternMatchResult (Integer) S) S (Pattern (Integer)) (PatternMatchResult (Integer) S))) (SIGNATURE patternMatch ((PatternMatchResult (Float) S) S (Pattern (Float)) (PatternMatchResult (Float) S))) (SIGNATURE factor ((Factored S) S)) (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE conditionP ((Union (Vector S) failed) (Matrix S))) (SIGNATURE primitivePart (S S VarSet)) (SIGNATURE content (S S VarSet)) (SIGNATURE discriminant (S S VarSet)) (SIGNATURE resultant (S S S VarSet)) (SIGNATURE primitiveMonomials ((List S) S)) (SIGNATURE totalDegree ((NonNegativeInteger) S (List VarSet))) (SIGNATURE totalDegree ((NonNegativeInteger) S)) (SIGNATURE isExpt ((Union (Record (: var VarSet) (: exponent (NonNegativeInteger))) failed) S)) (SIGNATURE isTimes ((Union (List S) failed) S)) (SIGNATURE isPlus ((Union (List S) failed) S)) (SIGNATURE monomial (S S (List VarSet) (List (NonNegativeInteger)))) (SIGNATURE monomial (S S VarSet (NonNegativeInteger))) (SIGNATURE monicDivide ((Record (: quotient S) (: remainder S)) S S VarSet)) (SIGNATURE monomials ((List S) S)) (SIGNATURE coefficient (S S (List VarSet) (List (NonNegativeInteger)))) (SIGNATURE coefficient (S S VarSet (NonNegativeInteger))) (SIGNATURE reducedSystem ((Matrix R) (Matrix S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix R)) (: vec (Vector R))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix S))) (SIGNATURE retract (VarSet S)) (SIGNATURE retractIfCan ((Union VarSet failed) S)) (SIGNATURE eval (S S (List VarSet) (List S))) (SIGNATURE eval (S S VarSet S)) (SIGNATURE eval (S S (List VarSet) (List R))) (SIGNATURE eval (S S VarSet R)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE monomial (S R E)) (SIGNATURE coefficient (R S E)) (SIGNATURE retract ((Integer) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retract (R S)) (SIGNATURE content (R S)) (SIGNATURE primitivePart (S S)))
      [8] factorPolynomial: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))) (SIGNATURE squareFree ((Factored S) S)) (SIGNATURE squareFreePart (S S)) (SIGNATURE charthRoot ((Union S failed) S)) (SIGNATURE < ((Boolean) S S)) (SIGNATURE convert ((InputForm) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE patternMatch ((PatternMatchResult (Integer) S) S (Pattern (Integer)) (PatternMatchResult (Integer) S))) (SIGNATURE patternMatch ((PatternMatchResult (Float) S) S (Pattern (Float)) (PatternMatchResult (Float) S))) (SIGNATURE factor ((Factored S) S)) (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE conditionP ((Union (Vector S) failed) (Matrix S))) (SIGNATURE primitivePart (S S VarSet)) (SIGNATURE content (S S VarSet)) (SIGNATURE discriminant (S S VarSet)) (SIGNATURE resultant (S S S VarSet)) (SIGNATURE primitiveMonomials ((List S) S)) (SIGNATURE totalDegree ((NonNegativeInteger) S (List VarSet))) (SIGNATURE totalDegree ((NonNegativeInteger) S)) (SIGNATURE isExpt ((Union (Record (: var VarSet) (: exponent (NonNegativeInteger))) failed) S)) (SIGNATURE isTimes ((Union (List S) failed) S)) (SIGNATURE isPlus ((Union (List S) failed) S)) (SIGNATURE monomial (S S (List VarSet) (List (NonNegativeInteger)))) (SIGNATURE monomial (S S VarSet (NonNegativeInteger))) (SIGNATURE monicDivide ((Record (: quotient S) (: remainder S)) S S VarSet)) (SIGNATURE monomials ((List S) S)) (SIGNATURE coefficient (S S (List VarSet) (List (NonNegativeInteger)))) (SIGNATURE coefficient (S S VarSet (NonNegativeInteger))) (SIGNATURE reducedSystem ((Matrix R) (Matrix S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix R)) (: vec (Vector R))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix S))) (SIGNATURE retract (VarSet S)) (SIGNATURE retractIfCan ((Union VarSet failed) S)) (SIGNATURE eval (S S (List VarSet) (List S))) (SIGNATURE eval (S S VarSet S)) (SIGNATURE eval (S S (List VarSet) (List R))) (SIGNATURE eval (S S VarSet R)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE monomial (S R E)) (SIGNATURE coefficient (R S E)) (SIGNATURE retract ((Integer) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retract (R S)) (SIGNATURE content (R S)) (SIGNATURE primitivePart (S S)))
      [9] factor: not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))) (SIGNATURE squareFree ((Factored S) S)) (SIGNATURE squareFreePart (S S)) (SIGNATURE charthRoot ((Union S failed) S)) (SIGNATURE < ((Boolean) S S)) (SIGNATURE convert ((InputForm) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE patternMatch ((PatternMatchResult (Integer) S) S (Pattern (Integer)) (PatternMatchResult (Integer) S))) (SIGNATURE patternMatch ((PatternMatchResult (Float) S) S (Pattern (Float)) (PatternMatchResult (Float) S))) (SIGNATURE factor ((Factored S) S)) (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE conditionP ((Union (Vector S) failed) (Matrix S))) (SIGNATURE primitivePart (S S VarSet)) (SIGNATURE content (S S VarSet)) (SIGNATURE discriminant (S S VarSet)) (SIGNATURE resultant (S S S VarSet)) (SIGNATURE primitiveMonomials ((List S) S)) (SIGNATURE totalDegree ((NonNegativeInteger) S (List VarSet))) (SIGNATURE totalDegree ((NonNegativeInteger) S)) (SIGNATURE isExpt ((Union (Record (: var VarSet) (: exponent (NonNegativeInteger))) failed) S)) (SIGNATURE isTimes ((Union (List S) failed) S)) (SIGNATURE isPlus ((Union (List S) failed) S)) (SIGNATURE monomial (S S (List VarSet) (List (NonNegativeInteger)))) (SIGNATURE monomial (S S VarSet (NonNegativeInteger))) (SIGNATURE monicDivide ((Record (: quotient S) (: remainder S)) S S VarSet)) (SIGNATURE monomials ((List S) S)) (SIGNATURE coefficient (S S (List VarSet) (List (NonNegativeInteger)))) (SIGNATURE coefficient (S S VarSet (NonNegativeInteger))) (SIGNATURE reducedSystem ((Matrix R) (Matrix S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix R)) (: vec (Vector R))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix S))) (SIGNATURE retract (VarSet S)) (SIGNATURE retractIfCan ((Union VarSet failed) S)) (SIGNATURE eval (S S (List VarSet) (List S))) (SIGNATURE eval (S S VarSet S)) (SIGNATURE eval (S S (List VarSet) (List R))) (SIGNATURE eval (S S VarSet R)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE monomial (S R E)) (SIGNATURE coefficient (R S E)) (SIGNATURE retract ((Integer) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retract (R S)) (SIGNATURE content (R S)) (SIGNATURE primitivePart (S S)))
      [10] conditionP: :(Integer) -- should replace by pretend
      [11] patternMatch: not known that (SetCategory) is of mode (CATEGORY domain (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))) (SIGNATURE squareFree ((Factored S) S)) (SIGNATURE squareFreePart (S S)) (SIGNATURE charthRoot ((Union S failed) S)) (SIGNATURE < ((Boolean) S S)) (SIGNATURE convert ((InputForm) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE patternMatch ((PatternMatchResult (Integer) S) S (Pattern (Integer)) (PatternMatchResult (Integer) S))) (SIGNATURE patternMatch ((PatternMatchResult (Float) S) S (Pattern (Float)) (PatternMatchResult (Float) S))) (SIGNATURE factor ((Factored S) S)) (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE conditionP ((Union (Vector S) failed) (Matrix S))) (SIGNATURE primitivePart (S S VarSet)) (SIGNATURE content (S S VarSet)) (SIGNATURE discriminant (S S VarSet)) (SIGNATURE resultant (S S S VarSet)) (SIGNATURE primitiveMonomials ((List S) S)) (SIGNATURE totalDegree ((NonNegativeInteger) S (List VarSet))) (SIGNATURE totalDegree ((NonNegativeInteger) S)) (SIGNATURE isExpt ((Union (Record (: var VarSet) (: exponent (NonNegativeInteger))) failed) S)) (SIGNATURE isTimes ((Union (List S) failed) S)) (SIGNATURE isPlus ((Union (List S) failed) S)) (SIGNATURE monomial (S S (List VarSet) (List (NonNegativeInteger)))) (SIGNATURE monomial (S S VarSet (NonNegativeInteger))) (SIGNATURE monicDivide ((Record (: quotient S) (: remainder S)) S S VarSet)) (SIGNATURE monomials ((List S) S)) (SIGNATURE coefficient (S S (List VarSet) (List (NonNegativeInteger)))) (SIGNATURE coefficient (S S VarSet (NonNegativeInteger))) (SIGNATURE reducedSystem ((Matrix R) (Matrix S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix R)) (: vec (Vector R))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix S))) (SIGNATURE retract (VarSet S)) (SIGNATURE retractIfCan ((Union VarSet failed) S)) (SIGNATURE eval (S S (List VarSet) (List S))) (SIGNATURE eval (S S VarSet S)) (SIGNATURE eval (S S (List VarSet) (List R))) (SIGNATURE eval (S S VarSet R)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE monomial (S R E)) (SIGNATURE coefficient (R S E)) (SIGNATURE retract ((Integer) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retract (R S)) (SIGNATURE content (R S)) (SIGNATURE primitivePart (S S)))
 
=========================================================================
warnings 20060:

>compiling PSETCAT.spad to PSETCAT.nrlib
 
   Warnings: 
      [1] variables1:  z2 has no value
      [2] variables1:  z1 has no value
      [3] variables2:  z2 has no value
      [4] variables2:  z1 has no value
      [5] collectUnder:  lq has no value
      [6] collectUpper:  lq has no value
      [7] collect:  lq has no value
      [8] sort:  us has no value
      [9] sort:  vs has no value
      [10] sort:  ws has no value
      [11] localTriangular?:  z2 has no value
      [12] localTriangular?:  z1 has no value
      [13] localTriangular?:  q has no value
      [14] headRemainder:  r has no value
      [15] rewriteIdealWithHeadRemainder:  rs has no value
      [16] rewriteIdealWithRemainder:  rs has no value
 
=========================================================================
warnings 20059:

>compiling QFCAT.spad to QFCAT.nrlib
 
   Warnings: 
      [1] reducedSystem: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE < ((Boolean) A A)) (SIGNATURE init (A)) (SIGNATURE nextItem ((Union A failed) A)) (SIGNATURE retract ((Integer) A)) (SIGNATURE retractIfCan ((Union (Integer) failed) A)) (SIGNATURE retract ((Fraction (Integer)) A)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) A)) (SIGNATURE convert ((DoubleFloat) A)) (SIGNATURE convert ((Float) A)) (SIGNATURE convert ((InputForm) A)) (SIGNATURE retract ((Symbol) A)) (SIGNATURE retractIfCan ((Union (Symbol) failed) A)) (SIGNATURE coerce (A (Symbol))) (SIGNATURE random (A)) (SIGNATURE fractionPart (A A)) (SIGNATURE denominator (A A)) (SIGNATURE numerator (A A)) (SIGNATURE patternMatch ((PatternMatchResult (Float) A) A (Pattern (Float)) (PatternMatchResult (Float) A))) (SIGNATURE patternMatch ((PatternMatchResult (Integer) A) A (Pattern (Integer)) (PatternMatchResult (Integer) A))) (SIGNATURE convert ((Pattern (Float)) A)) (SIGNATURE convert ((Pattern (Integer)) A)) (SIGNATURE reducedSystem ((Matrix S) (Matrix A))) (SIGNATURE reducedSystem ((Record (: mat (Matrix S)) (: vec (Vector S))) (Matrix A) (Vector A))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix A) (Vector A))) (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix A))) (SIGNATURE differentiate (A A (Mapping S S))) (SIGNATURE differentiate (A A (Mapping S S) (NonNegativeInteger))) (SIGNATURE differentiate (A A (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE differentiate (A A (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (A A (List (Symbol)))) (SIGNATURE differentiate (A A (Symbol))) (SIGNATURE differentiate (A A (NonNegativeInteger))) (SIGNATURE differentiate (A A)) (SIGNATURE map (A (Mapping S S) A)) (SIGNATURE retract (S A)) (SIGNATURE retractIfCan ((Union S failed) A)) (SIGNATURE coerce (A S)) (SIGNATURE coerce (A (Fraction (Integer)))) (SIGNATURE coerce (A A)) (SIGNATURE coerce (A (Integer))) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE coerce ((OutputForm) A)))
      [2] patternMatch: not known that (SetCategory) is of mode (CATEGORY domain (SIGNATURE < ((Boolean) A A)) (SIGNATURE init (A)) (SIGNATURE nextItem ((Union A failed) A)) (SIGNATURE retract ((Integer) A)) (SIGNATURE retractIfCan ((Union (Integer) failed) A)) (SIGNATURE retract ((Fraction (Integer)) A)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) A)) (SIGNATURE convert ((DoubleFloat) A)) (SIGNATURE convert ((Float) A)) (SIGNATURE convert ((InputForm) A)) (SIGNATURE retract ((Symbol) A)) (SIGNATURE retractIfCan ((Union (Symbol) failed) A)) (SIGNATURE coerce (A (Symbol))) (SIGNATURE random (A)) (SIGNATURE fractionPart (A A)) (SIGNATURE denominator (A A)) (SIGNATURE numerator (A A)) (SIGNATURE patternMatch ((PatternMatchResult (Float) A) A (Pattern (Float)) (PatternMatchResult (Float) A))) (SIGNATURE patternMatch ((PatternMatchResult (Integer) A) A (Pattern (Integer)) (PatternMatchResult (Integer) A))) (SIGNATURE convert ((Pattern (Float)) A)) (SIGNATURE convert ((Pattern (Integer)) A)) (SIGNATURE reducedSystem ((Matrix S) (Matrix A))) (SIGNATURE reducedSystem ((Record (: mat (Matrix S)) (: vec (Vector S))) (Matrix A) (Vector A))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix A) (Vector A))) (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix A))) (SIGNATURE differentiate (A A (Mapping S S))) (SIGNATURE differentiate (A A (Mapping S S) (NonNegativeInteger))) (SIGNATURE differentiate (A A (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE differentiate (A A (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (A A (List (Symbol)))) (SIGNATURE differentiate (A A (Symbol))) (SIGNATURE differentiate (A A (NonNegativeInteger))) (SIGNATURE differentiate (A A)) (SIGNATURE map (A (Mapping S S) A)) (SIGNATURE retract (S A)) (SIGNATURE retractIfCan ((Union S failed) A)) (SIGNATURE coerce (A S)) (SIGNATURE coerce (A (Fraction (Integer)))) (SIGNATURE coerce (A A)) (SIGNATURE coerce (A (Integer))) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE coerce ((OutputForm) A)))
 
=========================================================================
warnings 20058:

>compiling RNS.spad to RNS.nrlib
 
   Warnings: 
      [1] patternMatch: not known that (SetCategory) is of mode (CATEGORY domain (SIGNATURE round (S S)) (SIGNATURE truncate (S S)) (SIGNATURE fractionPart (S S)) (SIGNATURE floor (S S)) (SIGNATURE ceiling (S S)) (SIGNATURE norm (S S)) (SIGNATURE patternMatch ((PatternMatchResult (Float) S) S (Pattern (Float)) (PatternMatchResult (Float) S))) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE coerce (S (Integer))) (SIGNATURE convert ((DoubleFloat) S)) (SIGNATURE convert ((Float) S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE coerce (S S)) (SIGNATURE coerce (S (Integer))) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE coerce ((OutputForm) S)))
 
=========================================================================
warnings 20057:

>compiling SINT.spad to SINT.nrlib
 
   Warnings: 
      [1] hash: signature of lhs not unique: $$ chosen

=========================================================================
warnings 20056:

>compiling SYMBOL.spad to SYMBOL.nrlib
 
   Warnings: 
      [1] latex:  s has no value
      [2] latex:  sc has no value
 
=========================================================================
warnings 20055:

>compiling TSETCAT.spad to TSETCAT.nrlib
 
   Warnings: 
      [1] basicSet:  p has no value
      [2] basicSet:  gps has no value
      [3] basicSet:  bps has no value
      [4] initials:  lip has no value
      [5] initiallyReduced?:  red has no value
      [6] reduce: signature of lhs not unique: PPS(Mapping P P P)(Mapping (Boolean) P P) chosen
      [7] rewriteSetWithReduction:  rs has no value
      [8] select: signature of lhs not unique: (Union P failed)SV chosen
      [9] collectQuasiMonic:  newlp has no value
 
=========================================================================
warnings 20054:

>compiling UFD.spad to UFD.nrlib
 
   Warnings: 
      [1] squareFreePart: not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE squareFreePart (S S)) (SIGNATURE prime? ((Boolean) S)))
 
=========================================================================
warnings 20053:

>compiling UPOLYC.spad to UPOLYC.nrlib
 
   Warnings: 
      [1] monomial:  x1 has no value
      [2] solveLinearPolynomialEquation: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE coerce (S S)) (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))) (SIGNATURE squareFree ((Factored S) S)) (SIGNATURE squareFreePart (S S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE init (S)) (SIGNATURE nextItem ((Union S failed) S)) (SIGNATURE elt ((Fraction S) S (Fraction S))) (SIGNATURE euclideanSize ((NonNegativeInteger) S)) (SIGNATURE divide ((Record (: quotient S) (: remainder S)) S S)) (SIGNATURE integrate (S S)) (SIGNATURE elt (R (Fraction S) R)) (SIGNATURE separate ((Record (: primePart S) (: commonPart S)) S S)) (SIGNATURE pseudoDivide ((Record (: coef R) (: quotient S) (: remainder S)) S S)) (SIGNATURE pseudoQuotient (S S S)) (SIGNATURE composite ((Union (Fraction S) failed) (Fraction S) S)) (SIGNATURE composite ((Union S failed) S S)) (SIGNATURE order ((NonNegativeInteger) S S)) (SIGNATURE elt ((Fraction S) (Fraction S) (Fraction S))) (SIGNATURE differentiate (S S (Mapping R R) S)) (SIGNATURE shiftLeft (S S (NonNegativeInteger))) (SIGNATURE shiftRight (S S (NonNegativeInteger))) (SIGNATURE karatsubaDivide ((Record (: quotient S) (: remainder S)) S (NonNegativeInteger))) (SIGNATURE unmakeSUP (S (SparseUnivariatePolynomial R))) (SIGNATURE makeSUP ((SparseUnivariatePolynomial R) S)) (SIGNATURE vectorise ((Vector R) S (NonNegativeInteger))) (SIGNATURE differentiate (S S (Mapping R R))) (SIGNATURE differentiate (S S (Mapping R R) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE elt (S S S)) (SIGNATURE elt (R S R)) (SIGNATURE factor ((Factored S) S)) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE content (S S (SingletonAsOrderedSet))) (SIGNATURE variables ((List (SingletonAsOrderedSet)) S)) (SIGNATURE totalDegree ((NonNegativeInteger) S (List (SingletonAsOrderedSet)))) (SIGNATURE totalDegree ((NonNegativeInteger) S)) (SIGNATURE monomial (S S (List (SingletonAsOrderedSet)) (List (NonNegativeInteger)))) (SIGNATURE monomial (S S (SingletonAsOrderedSet) (NonNegativeInteger))) (SIGNATURE minimumDegree ((List (NonNegativeInteger)) S (List (SingletonAsOrderedSet)))) (SIGNATURE minimumDegree ((NonNegativeInteger) S (SingletonAsOrderedSet))) (SIGNATURE mainVariable ((Union (SingletonAsOrderedSet) failed) S)) (SIGNATURE degree ((List (NonNegativeInteger)) S (List (SingletonAsOrderedSet)))) (SIGNATURE degree ((NonNegativeInteger) S (SingletonAsOrderedSet))) (SIGNATURE retract ((SingletonAsOrderedSet) S)) (SIGNATURE retractIfCan ((Union (SingletonAsOrderedSet) failed) S)) (SIGNATURE coerce (S (SingletonAsOrderedSet))) (SIGNATURE eval (S S (List (SingletonAsOrderedSet)) (List S))) (SIGNATURE eval (S S (SingletonAsOrderedSet) S)) (SIGNATURE eval (S S (List (SingletonAsOrderedSet)) (List R))) (SIGNATURE eval (S S (SingletonAsOrderedSet) R)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE degree ((NonNegativeInteger) S)) (SIGNATURE monomial (S R (NonNegativeInteger))) (SIGNATURE retract ((Integer) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE coerce (S R)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retract (R S)) (SIGNATURE minimumDegree ((NonNegativeInteger) S)) (SIGNATURE content (R S)) (SIGNATURE differentiate (S S (List (SingletonAsOrderedSet)) (List (NonNegativeInteger)))) (SIGNATURE differentiate (S S (SingletonAsOrderedSet) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (SingletonAsOrderedSet)))) (SIGNATURE differentiate (S S (SingletonAsOrderedSet))) (SIGNATURE coerce (S (Integer))) (SIGNATURE coerce ((OutputForm) S)))
      [3] factorPolynomial: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE coerce (S S)) (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))) (SIGNATURE squareFree ((Factored S) S)) (SIGNATURE squareFreePart (S S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE init (S)) (SIGNATURE nextItem ((Union S failed) S)) (SIGNATURE elt ((Fraction S) S (Fraction S))) (SIGNATURE euclideanSize ((NonNegativeInteger) S)) (SIGNATURE divide ((Record (: quotient S) (: remainder S)) S S)) (SIGNATURE integrate (S S)) (SIGNATURE elt (R (Fraction S) R)) (SIGNATURE separate ((Record (: primePart S) (: commonPart S)) S S)) (SIGNATURE pseudoDivide ((Record (: coef R) (: quotient S) (: remainder S)) S S)) (SIGNATURE pseudoQuotient (S S S)) (SIGNATURE composite ((Union (Fraction S) failed) (Fraction S) S)) (SIGNATURE composite ((Union S failed) S S)) (SIGNATURE order ((NonNegativeInteger) S S)) (SIGNATURE elt ((Fraction S) (Fraction S) (Fraction S))) (SIGNATURE differentiate (S S (Mapping R R) S)) (SIGNATURE shiftLeft (S S (NonNegativeInteger))) (SIGNATURE shiftRight (S S (NonNegativeInteger))) (SIGNATURE karatsubaDivide ((Record (: quotient S) (: remainder S)) S (NonNegativeInteger))) (SIGNATURE unmakeSUP (S (SparseUnivariatePolynomial R))) (SIGNATURE makeSUP ((SparseUnivariatePolynomial R) S)) (SIGNATURE vectorise ((Vector R) S (NonNegativeInteger))) (SIGNATURE differentiate (S S (Mapping R R))) (SIGNATURE differentiate (S S (Mapping R R) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE elt (S S S)) (SIGNATURE elt (R S R)) (SIGNATURE factor ((Factored S) S)) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE content (S S (SingletonAsOrderedSet))) (SIGNATURE variables ((List (SingletonAsOrderedSet)) S)) (SIGNATURE totalDegree ((NonNegativeInteger) S (List (SingletonAsOrderedSet)))) (SIGNATURE totalDegree ((NonNegativeInteger) S)) (SIGNATURE monomial (S S (List (SingletonAsOrderedSet)) (List (NonNegativeInteger)))) (SIGNATURE monomial (S S (SingletonAsOrderedSet) (NonNegativeInteger))) (SIGNATURE minimumDegree ((List (NonNegativeInteger)) S (List (SingletonAsOrderedSet)))) (SIGNATURE minimumDegree ((NonNegativeInteger) S (SingletonAsOrderedSet))) (SIGNATURE mainVariable ((Union (SingletonAsOrderedSet) failed) S)) (SIGNATURE degree ((List (NonNegativeInteger)) S (List (SingletonAsOrderedSet)))) (SIGNATURE degree ((NonNegativeInteger) S (SingletonAsOrderedSet))) (SIGNATURE retract ((SingletonAsOrderedSet) S)) (SIGNATURE retractIfCan ((Union (SingletonAsOrderedSet) failed) S)) (SIGNATURE coerce (S (SingletonAsOrderedSet))) (SIGNATURE eval (S S (List (SingletonAsOrderedSet)) (List S))) (SIGNATURE eval (S S (SingletonAsOrderedSet) S)) (SIGNATURE eval (S S (List (SingletonAsOrderedSet)) (List R))) (SIGNATURE eval (S S (SingletonAsOrderedSet) R)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE degree ((NonNegativeInteger) S)) (SIGNATURE monomial (S R (NonNegativeInteger))) (SIGNATURE retract ((Integer) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE coerce (S R)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retract (R S)) (SIGNATURE minimumDegree ((NonNegativeInteger) S)) (SIGNATURE content (R S)) (SIGNATURE differentiate (S S (List (SingletonAsOrderedSet)) (List (NonNegativeInteger)))) (SIGNATURE differentiate (S S (SingletonAsOrderedSet) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (SingletonAsOrderedSet)))) (SIGNATURE differentiate (S S (SingletonAsOrderedSet))) (SIGNATURE coerce (S (Integer))) (SIGNATURE coerce ((OutputForm) S)))
      [4] factor: not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE coerce (S S)) (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))) (SIGNATURE squareFree ((Factored S) S)) (SIGNATURE squareFreePart (S S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE init (S)) (SIGNATURE nextItem ((Union S failed) S)) (SIGNATURE elt ((Fraction S) S (Fraction S))) (SIGNATURE euclideanSize ((NonNegativeInteger) S)) (SIGNATURE divide ((Record (: quotient S) (: remainder S)) S S)) (SIGNATURE integrate (S S)) (SIGNATURE elt (R (Fraction S) R)) (SIGNATURE separate ((Record (: primePart S) (: commonPart S)) S S)) (SIGNATURE pseudoDivide ((Record (: coef R) (: quotient S) (: remainder S)) S S)) (SIGNATURE pseudoQuotient (S S S)) (SIGNATURE composite ((Union (Fraction S) failed) (Fraction S) S)) (SIGNATURE composite ((Union S failed) S S)) (SIGNATURE order ((NonNegativeInteger) S S)) (SIGNATURE elt ((Fraction S) (Fraction S) (Fraction S))) (SIGNATURE differentiate (S S (Mapping R R) S)) (SIGNATURE shiftLeft (S S (NonNegativeInteger))) (SIGNATURE shiftRight (S S (NonNegativeInteger))) (SIGNATURE karatsubaDivide ((Record (: quotient S) (: remainder S)) S (NonNegativeInteger))) (SIGNATURE unmakeSUP (S (SparseUnivariatePolynomial R))) (SIGNATURE makeSUP ((SparseUnivariatePolynomial R) S)) (SIGNATURE vectorise ((Vector R) S (NonNegativeInteger))) (SIGNATURE differentiate (S S (Mapping R R))) (SIGNATURE differentiate (S S (Mapping R R) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE elt (S S S)) (SIGNATURE elt (R S R)) (SIGNATURE factor ((Factored S) S)) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE content (S S (SingletonAsOrderedSet))) (SIGNATURE variables ((List (SingletonAsOrderedSet)) S)) (SIGNATURE totalDegree ((NonNegativeInteger) S (List (SingletonAsOrderedSet)))) (SIGNATURE totalDegree ((NonNegativeInteger) S)) (SIGNATURE monomial (S S (List (SingletonAsOrderedSet)) (List (NonNegativeInteger)))) (SIGNATURE monomial (S S (SingletonAsOrderedSet) (NonNegativeInteger))) (SIGNATURE minimumDegree ((List (NonNegativeInteger)) S (List (SingletonAsOrderedSet)))) (SIGNATURE minimumDegree ((NonNegativeInteger) S (SingletonAsOrderedSet))) (SIGNATURE mainVariable ((Union (SingletonAsOrderedSet) failed) S)) (SIGNATURE degree ((List (NonNegativeInteger)) S (List (SingletonAsOrderedSet)))) (SIGNATURE degree ((NonNegativeInteger) S (SingletonAsOrderedSet))) (SIGNATURE retract ((SingletonAsOrderedSet) S)) (SIGNATURE retractIfCan ((Union (SingletonAsOrderedSet) failed) S)) (SIGNATURE coerce (S (SingletonAsOrderedSet))) (SIGNATURE eval (S S (List (SingletonAsOrderedSet)) (List S))) (SIGNATURE eval (S S (SingletonAsOrderedSet) S)) (SIGNATURE eval (S S (List (SingletonAsOrderedSet)) (List R))) (SIGNATURE eval (S S (SingletonAsOrderedSet) R)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE degree ((NonNegativeInteger) S)) (SIGNATURE monomial (S R (NonNegativeInteger))) (SIGNATURE retract ((Integer) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE coerce (S R)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retract (R S)) (SIGNATURE minimumDegree ((NonNegativeInteger) S)) (SIGNATURE content (R S)) (SIGNATURE differentiate (S S (List (SingletonAsOrderedSet)) (List (NonNegativeInteger)))) (SIGNATURE differentiate (S S (SingletonAsOrderedSet) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (SingletonAsOrderedSet)))) (SIGNATURE differentiate (S S (SingletonAsOrderedSet))) (SIGNATURE coerce (S (Integer))) (SIGNATURE coerce ((OutputForm) S)))
      [5] elt: not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE coerce (S S)) (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))) (SIGNATURE squareFree ((Factored S) S)) (SIGNATURE squareFreePart (S S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE init (S)) (SIGNATURE nextItem ((Union S failed) S)) (SIGNATURE elt ((Fraction S) S (Fraction S))) (SIGNATURE euclideanSize ((NonNegativeInteger) S)) (SIGNATURE divide ((Record (: quotient S) (: remainder S)) S S)) (SIGNATURE integrate (S S)) (SIGNATURE elt (R (Fraction S) R)) (SIGNATURE separate ((Record (: primePart S) (: commonPart S)) S S)) (SIGNATURE pseudoDivide ((Record (: coef R) (: quotient S) (: remainder S)) S S)) (SIGNATURE pseudoQuotient (S S S)) (SIGNATURE composite ((Union (Fraction S) failed) (Fraction S) S)) (SIGNATURE composite ((Union S failed) S S)) (SIGNATURE order ((NonNegativeInteger) S S)) (SIGNATURE elt ((Fraction S) (Fraction S) (Fraction S))) (SIGNATURE differentiate (S S (Mapping R R) S)) (SIGNATURE shiftLeft (S S (NonNegativeInteger))) (SIGNATURE shiftRight (S S (NonNegativeInteger))) (SIGNATURE karatsubaDivide ((Record (: quotient S) (: remainder S)) S (NonNegativeInteger))) (SIGNATURE unmakeSUP (S (SparseUnivariatePolynomial R))) (SIGNATURE makeSUP ((SparseUnivariatePolynomial R) S)) (SIGNATURE vectorise ((Vector R) S (NonNegativeInteger))) (SIGNATURE differentiate (S S (Mapping R R))) (SIGNATURE differentiate (S S (Mapping R R) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE elt (S S S)) (SIGNATURE elt (R S R)) (SIGNATURE factor ((Factored S) S)) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE content (S S (SingletonAsOrderedSet))) (SIGNATURE variables ((List (SingletonAsOrderedSet)) S)) (SIGNATURE totalDegree ((NonNegativeInteger) S (List (SingletonAsOrderedSet)))) (SIGNATURE totalDegree ((NonNegativeInteger) S)) (SIGNATURE monomial (S S (List (SingletonAsOrderedSet)) (List (NonNegativeInteger)))) (SIGNATURE monomial (S S (SingletonAsOrderedSet) (NonNegativeInteger))) (SIGNATURE minimumDegree ((List (NonNegativeInteger)) S (List (SingletonAsOrderedSet)))) (SIGNATURE minimumDegree ((NonNegativeInteger) S (SingletonAsOrderedSet))) (SIGNATURE mainVariable ((Union (SingletonAsOrderedSet) failed) S)) (SIGNATURE degree ((List (NonNegativeInteger)) S (List (SingletonAsOrderedSet)))) (SIGNATURE degree ((NonNegativeInteger) S (SingletonAsOrderedSet))) (SIGNATURE retract ((SingletonAsOrderedSet) S)) (SIGNATURE retractIfCan ((Union (SingletonAsOrderedSet) failed) S)) (SIGNATURE coerce (S (SingletonAsOrderedSet))) (SIGNATURE eval (S S (List (SingletonAsOrderedSet)) (List S))) (SIGNATURE eval (S S (SingletonAsOrderedSet) S)) (SIGNATURE eval (S S (List (SingletonAsOrderedSet)) (List R))) (SIGNATURE eval (S S (SingletonAsOrderedSet) R)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE degree ((NonNegativeInteger) S)) (SIGNATURE monomial (S R (NonNegativeInteger))) (SIGNATURE retract ((Integer) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE coerce (S R)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retract (R S)) (SIGNATURE minimumDegree ((NonNegativeInteger) S)) (SIGNATURE content (R S)) (SIGNATURE differentiate (S S (List (SingletonAsOrderedSet)) (List (NonNegativeInteger)))) (SIGNATURE differentiate (S S (SingletonAsOrderedSet) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (SingletonAsOrderedSet)))) (SIGNATURE differentiate (S S (SingletonAsOrderedSet))) (SIGNATURE coerce (S (Integer))) (SIGNATURE coerce ((OutputForm) S)))
 
=========================================================================
warnings 20052:

>compiling FFFG.spad to FFFG.nrlib
 
   Warnings: 
      [1] generalCoefficient:  res has no value
      [2] generalInterpolation:  x has no value
      [3] generalInterpolation:  y has no value
      [4] nextVector!:  x has no value
      [5] interpolate:  s has no value
      [6] interpolate:  u has no value
      [7] fffg:  M has no value

=========================================================================
warnings 20051:

>compiling FFFGF.spad to FFFGF.nrlib
 
   Warnings: 
      [1] generalInterpolation:  x has no value
      [2] generalInterpolation:  y has no value

=========================================================================
warnings 20050:

>compiling FFHOM.spad to FFHOM.nrlib
 
   Warnings: 
      [1] compare:  equal has no value
      [2] initialize:  mat has no value
      [3] unknown Functor code (error FFHOM: one extension degree must divide the other one)
 
=========================================================================
warnings 20049:

>compiling FFPOLY.spad to FFPOLY.nrlib
 
   Warnings: 
      [1] leastAffineMultiple:  coeffVector has no value
      [2] primitive?: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE primitive? ((Boolean) (SparseUnivariatePolynomial GF))) (SIGNATURE normal? ((Boolean) (SparseUnivariatePolynomial GF))) (SIGNATURE numberOfIrreduciblePoly ((PositiveInteger) (PositiveInteger))) (SIGNATURE numberOfPrimitivePoly ((PositiveInteger) (PositiveInteger))) (SIGNATURE numberOfNormalPoly ((PositiveInteger) (PositiveInteger))) (SIGNATURE createIrreduciblePoly ((SparseUnivariatePolynomial GF) (PositiveInteger))) (SIGNATURE createPrimitivePoly ((SparseUnivariatePolynomial GF) (PositiveInteger))) (SIGNATURE createNormalPoly ((SparseUnivariatePolynomial GF) (PositiveInteger))) (SIGNATURE createNormalPrimitivePoly ((SparseUnivariatePolynomial GF) (PositiveInteger))) (SIGNATURE createPrimitiveNormalPoly ((SparseUnivariatePolynomial GF) (PositiveInteger))) (SIGNATURE nextIrreduciblePoly ((Union (SparseUnivariatePolynomial GF) failed) (SparseUnivariatePolynomial GF))) (SIGNATURE nextPrimitivePoly ((Union (SparseUnivariatePolynomial GF) failed) (SparseUnivariatePolynomial GF))) (SIGNATURE nextNormalPoly ((Union (SparseUnivariatePolynomial GF) failed) (SparseUnivariatePolynomial GF))) (SIGNATURE nextNormalPrimitivePoly ((Union (SparseUnivariatePolynomial GF) failed) (SparseUnivariatePolynomial GF))) (SIGNATURE nextPrimitiveNormalPoly ((Union (SparseUnivariatePolynomial GF) failed) (SparseUnivariatePolynomial GF))) (SIGNATURE random ((SparseUnivariatePolynomial GF) (PositiveInteger))) (SIGNATURE random ((SparseUnivariatePolynomial GF) (PositiveInteger) (PositiveInteger))) (SIGNATURE leastAffineMultiple ((SparseUnivariatePolynomial GF) (SparseUnivariatePolynomial GF))) (SIGNATURE reducedQPowers ((PrimitiveArray (SparseUnivariatePolynomial GF)) (SparseUnivariatePolynomial GF))))
      [3] nextSubset:  restOfs has no value
      [4] nextSubset:  noGap has no value
      [5] nextSubset:  i has no value
      [6] nextIrreduciblePoly:  fcopy has no value
      [7] nextIrreduciblePoly:  s has no value
      [8] nextPrimitivePoly:  fcopy has no value
      [9] nextPrimitivePoly:  term has no value
      [10] nextPrimitivePoly:  noGenerator has no value
      [11] nextPrimitivePoly:  c has no value
      [12] nextPrimitivePoly:  weight has no value
      [13] nextPrimitivePoly:  s has no value
      [14] nextPrimitivePoly:  l has no value
      [15] nextNormalPoly:  fcopy has no value
      [16] nextNormalPoly:  l has no value
      [17] nextNormalPoly:  a has no value
      [18] nextNormalPoly:  s has no value
      [19] nextNormalPrimitivePoly:  fcopy has no value
      [20] nextNormalPrimitivePoly:  term has no value
      [21] nextNormalPrimitivePoly:  noGenerator has no value
      [22] nextNormalPrimitivePoly:  c has no value
      [23] nextNormalPrimitivePoly:  la has no value
      [24] nextNormalPrimitivePoly:  a has no value
      [25] nextNormalPrimitivePoly:  middlelookuplist has no value
      [26] nextNormalPrimitivePoly:  middlepol has no value
      [27] nextNormalPrimitivePoly:  weight has no value
      [28] nextNormalPrimitivePoly:  s has no value
      [29] nextNormalPrimitivePoly:  lc has no value
      [30] random:  polRepr has no value

=========================================================================
warnings 20048:

>compiling FFSQFR.spad to FFSQFR.nrlib
 
   Warnings: 
      [1] rawMusser:  A has no value
      [2] rawMusser:  decomposition has no value
      [3] oneYunStep:  B has no value

=========================================================================
warnings 20047:

>compiling FFSLPE.spad to FFSLPE.nrlib
 
   Warnings: 
      [1] solveLinearPolynomialEquation:  slpePrime has no value
      [2] solveLinearPolynomialEquation:  oldtable has no value

=========================================================================
warnings 20046:

>compiling FGLMICPK.spad to FGLMICPK.nrlib
 
   Warnings: 
      [1] zeroDim?: not known that (Ring) is of mode (CATEGORY package (SIGNATURE zeroDimensional? ((Boolean) (List (Polynomial R)))) (SIGNATURE fglmIfCan ((Union (List (Polynomial R)) failed) (List (Polynomial R)))) (SIGNATURE groebner ((List (Polynomial R)) (List (Polynomial R)))))
      [2] zeroDim?:  lv has no value

=========================================================================
warnings 20045:

>compiling FFF.spad to FFF.nrlib
 
   Warnings: 
      [1] createLowComplexityTable:  k has no value
      [2] createLowComplexityTable:  t1 has no value
      [3] createLowComplexityTable:  a has no value
      [4] createLowComplexityTable: pretend(NonNegativeInteger) -- should replace by @
      [5] createLowComplexityTable:  l has no value
      [6] createMultiplicationTable:  l has no value

=========================================================================
warnings 20044:

>compiling FORMULA.spad to FORMULA.nrlib
 
   Warnings: 
      [1] display: pretend(Integer) -- should replace by @
      [2] coerce: pretend(Integer) -- should replace by @
      [3] stringify: pretend(String) -- should replace by @
      [4] splitLong1:  l has no value
      [5] splitLong1:  ls has no value
      [6] splitLong1:  s has no value
      [7] formatSpecial:  form has no value
      [8] formatPlex:  s has no value
      [9] formatFormula: pretend(Boolean) -- should replace by @
      [10] formatFormula: :(Integer) -- should replace by pretend
 
=========================================================================
warnings 20043:

>compiling FORT.spad to FORT.nrlib
 
   Warnings: 
      [1] linkToFortran:  fst has no value
 
=========================================================================
warnings 20042:

>compiling FRAC.spad to FRAC.nrlib
 
   Warnings: 
      [1] OMwrite: pretend(String) -- should replace by @
      [2] gcdPolynomial:  x has no value
      [3] factorPolynomial:  x has no value
      [4] factorPolynomial:  den1 has no value
      [5] factorSquareFreePolynomial:  x has no value
      [6] factorSquareFreePolynomial:  den1 has no value

=========================================================================
warnings 20041:

>compiling FTEM.spad to FTEM.nrlib
 
   Warnings: 
      [1] processTemplate:  active has no value
 
=========================================================================
warnings 20040:

>compiling GENEEZ.spad to GENEEZ.nrlib
 
   Warnings: 
      [1] reduction:  x has no value
      [2] liftSol:  x has no value
      [3] solveid:  x has no value
 
=========================================================================
warnings 20039:

>compiling GENMFACT.spad to GENMFACT.nrlib
 
   Warnings: 
      [1] factor: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE factor ((Factored P) P)))

=========================================================================
warnings 20038:

>compiling GENPGCD.spad to GENPGCD.nrlib
 
   Warnings: 
      [1] gcdPolynomial:  canonical has no value
      [2] gcdSameVariables:  x has no value
      [3] gcdSameVariables: not known that (Ring) is of mode (CATEGORY package (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial P) (SparseUnivariatePolynomial P) (SparseUnivariatePolynomial P))) (SIGNATURE randomR (R)))
      [4] gcdSameVariables:  y has no value
      [5] gcdSameVariables:  z has no value
      [6] gcdSameVariables:  x1 has no value
      [7] gcdSameVariables:  y1 has no value
      [8] gcdSameVariables:  up1 has no value
      [9] gcdSameVariables:  up2 has no value
      [10] lift:  x has no value
      [11] lift:  y has no value
      [12] lift:  x1 has no value
      [13] lift:  x2 has no value
      [14] lift: not known that (Ring) is of mode (CATEGORY package (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial P) (SparseUnivariatePolynomial P) (SparseUnivariatePolynomial P))) (SIGNATURE randomR (R)))
      [15] recursivelyGCDCoefficients:  x has no value
      [16] flatten:  x has no value

=========================================================================
warnings 20037:

>compiling GALFACTU.spad to GALFACTU.nrlib
 
   Warnings: 
      [1] singleFactorBound: not known that (Ring) is of mode (CATEGORY F (SIGNATURE Gamma (F F)))
 
=========================================================================
warnings 20036:

>compiling GB.spad to GB.nrlib
 
   Warnings: 
      [1] groebner:  y has no value

=========================================================================
warnings 20035:

>compiling GBEUCLID.spad to GBEUCLID.nrlib
 
   Warnings: 
      [1] strongGbasis:  z2 has no value
      [2] strongGbasis:  z1 has no value
 
=========================================================================
warnings 20034:

>compiling GBF.spad to GBF.nrlib
 
   Warnings: 
      [1] createGroebnerBases:  nP has no value
      [2] createGroebnerBases:  allReducedFactors has no value
      [3] createGroebnerBases:  y has no value
      [4] createGroebnerBases:  x has no value
      [5] createAllFactors:  x has no value
      [6] createAllFactors:  y has no value
      [7] factorGroebnerBasis:  fctr has no value
      [8] groebnerFactorize: signature of lhs not unique: (List (List Dpol))(List Dpol)(List Dpol) chosen
      [9] groebnerFactorize:  x has no value
      [10] groebnerFactorize:  y has no value

=========================================================================
warnings 20033:

>compiling GBINTERN.spad to GBINTERN.nrlib
 
   Warnings: 
      [1] gbasis:  z2 has no value
      [2] gbasis:  z1 has no value
      [3] redPo:  m has no value
 
=========================================================================
warnings 20032:

>compiling GHENSEL.spad to GHENSEL.nrlib
 
   Warnings: 
      [1] reduction:  x has no value
      [2] mQuo:  x has no value
      [3] genFact:  auxfl has no value
      [4] HenselLift:  constp has no value
      [5] HenselLift:  fln has no value
      [6] completeHensel:  factlist has no value
      [7] completeHensel:  finallist has no value
      [8] completeHensel:  aux has no value
      [9] completeHensel:  auxfl has no value
 
=========================================================================
warnings 20031:

>compiling GOSPER.spad to GOSPER.nrlib
 
   Warnings: 
      [1] PQ2R:  x has no value
      [2] PQ2R:  y has no value
      [3] UP2QIfCan:  x has no value
      [4] UP2QIfCan:  y has no value
      [5] GosperF: not known that (Ring) is of mode (CATEGORY package (SIGNATURE GospersMethod ((Union Q failed) Q V (Mapping V))))
 
=========================================================================
warnings 20030:

>compiling GRIMAGE.spad to GRIMAGE.nrlib
 
   Warnings: 
      [1] makeGraphImage: signature of lhs not unique: $(List (List (Point (DoubleFloat)))) chosen

=========================================================================
warnings 20029:

>compiling GROEBSOL.spad to GROEBSOL.nrlib
 
   Warnings: 
      [1] testPower: not known that (Ring) is of mode (CATEGORY package (SIGNATURE groebSolve ((List (List (DistributedMultivariatePolynomial lv F))) (List (DistributedMultivariatePolynomial lv F)) (List (OrderedVariableList lv)))) (SIGNATURE testDim ((Union (List (HomogeneousDistributedMultivariatePolynomial lv F)) failed) (List (HomogeneousDistributedMultivariatePolynomial lv F)) (List (OrderedVariableList lv)))) (SIGNATURE genericPosition ((Record (: dpolys (List (DistributedMultivariatePolynomial lv F))) (: coords (List (Integer)))) (List (DistributedMultivariatePolynomial lv F)) (List (OrderedVariableList lv)))))
      [2] testGenPos:  newlpol has no value
      [3] groebSolve:  result has no value
 
=========================================================================
warnings 20028:

>compiling HEUGCD.spad to HEUGCD.nrlib
 
   Warnings: 
      [1] lintgcd:  z1 has no value
      [2] lintgcd:  z2 has no value
      [3] localgcd:  flag has no value
      [4] localgcd:  result has no value
      [5] internal:  Cgcd has no value
      [6] internal:  contgcd has no value
      [7] internal:  ans has no value

=========================================================================
warnings 20027:

>compiling HTMLFORM.spad to HTMLFORM.nrlib
 
   Warnings: 
      [1] exprex:  s has no value
      [2] outputTree:  allString has no value
      [3] formatNaryNoGroup:  tags has no value

=========================================================================
warnings 20026:

>compiling ICARD.spad to ICARD.nrlib
 
   Warnings: 
      [1] elt: pretend(String) -- should replace by @
 
=========================================================================
warnings 20025:

>compiling ICDEN.spad to ICDEN.nrlib
 
   Warnings: 
      [1] clearDenominator:  x has no value
      [2] splitDenominator:  x has no value

=========================================================================
warnings 20024:

>compiling IDECOMP.spad to IDECOMP.nrlib
 
   Warnings: 
      [1] internalForm: not known that (PolynomialCategory (Fraction (Integer)) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl)) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [2] internalForm: not known that (PolynomialCategory (Fraction (Polynomial (Integer))) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl)) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [3] externalForm: not known that (PolynomialCategory (Fraction (Polynomial (Integer))) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl)) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [4] externalForm: not known that (PolynomialCategory (Fraction (Integer)) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl)) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [5] rearrange:  z2 has no value
      [6] rearrange:  z1 has no value
      [7] zeroRadComp: not known that (PolynomialCategory (Fraction (Polynomial (Integer))) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl)) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [8] zeroRadComp: not known that (Ring) is of mode (CATEGORY package (SIGNATURE zeroDimPrime? ((Boolean) (PolynomialIdeals (Fraction (Integer)) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl) (DistributedMultivariatePolynomial vl (Fraction (Integer)))))) (SIGNATURE zeroDimPrimary? ((Boolean) (PolynomialIdeals (Fraction (Integer)) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl) (DistributedMultivariatePolynomial vl (Fraction (Integer)))))) (SIGNATURE prime? ((Boolean) (PolynomialIdeals (Fraction (Integer)) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl) (DistributedMultivariatePolynomial vl (Fraction (Integer)))))) (SIGNATURE radical ((PolynomialIdeals (Fraction (Integer)) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl) (DistributedMultivariatePolynomial vl (Fraction (Integer)))) (PolynomialIdeals (Fraction (Integer)) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl) (DistributedMultivariatePolynomial vl (Fraction (Integer)))))) (SIGNATURE primaryDecomp ((List (PolynomialIdeals (Fraction (Integer)) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl) (DistributedMultivariatePolynomial vl (Fraction (Integer))))) (PolynomialIdeals (Fraction (Integer)) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl) (DistributedMultivariatePolynomial vl (Fraction (Integer)))))) (SIGNATURE contract ((PolynomialIdeals (Fraction (Integer)) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl) (DistributedMultivariatePolynomial vl (Fraction (Integer)))) (PolynomialIdeals (Fraction (Integer)) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl) (DistributedMultivariatePolynomial vl (Fraction (Integer)))) (List (OrderedVariableList vl)))))
      [9] findvar:  lmonicvar has no value
      [10] zeroPrimDecomp: not known that (PolynomialCategory (Fraction (Polynomial (Integer))) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl)) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [11] testPower: :(Integer) -- should replace by pretend
      [12] primaryDecomp: not known that (PolynomialCategory (Fraction (Integer)) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl)) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [13] contract:  IN has no value
      [14] contract:  vv has no value
      [15] contract: not known that (PolynomialCategory (Fraction (Integer)) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl)) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
 
=========================================================================
warnings 20023:

>compiling IIARRAY2.spad to IIARRAY2.nrlib
 
   Warnings: 
      [1] latex:  s has no value
 
=========================================================================
warnings 20022:

>compiling IMATLIN.spad to IMATLIN.nrlib
 
   Warnings: 
      [1] nullSpace:  basis has no value
      [2] determinant:  ans has no value
      [3] generalizedInverse: not known that (MatrixCategory FSUP VFSUP VFSUP) is of mode (CATEGORY domain (SIGNATURE diagonalMatrix ($ (Vector FSUP))) (IF (has FSUP (ConvertibleTo (InputForm))) (ATTRIBUTE (ConvertibleTo (InputForm))) noBranch) (IF (has FSUP (Field)) (SIGNATURE inverse ((Union $ failed) $)) noBranch))
      [4] generalizedInverse:  r1 has no value
      [5] generalizedInverse:  z1 has no value

=========================================================================
warnings 20021:

>compiling IMATQF.spad to IMATQF.nrlib
 
   Warnings: 
      [1] qfMat:  r1 has no value
      [2] nullSpace: not known that (FiniteLinearAggregate QF) is of mode (CATEGORY Col2 (ATTRIBUTE shallowlyMutable))
 
=========================================================================
warnings 20020:

>compiling INMODGCD.spad to INMODGCD.nrlib
 
   Warnings: 
      [1] reduction:  r1 has no value
 
=========================================================================
warnings 20019:

>compiling INNMFACT.spad to INNMFACT.nrlib
 
   Warnings: 
      [1] supFactor:  factorlist has no value
      [2] supFactor:  irr has no value
      [3] supFactor:  pow has no value
      [4] varChoose: not known that (Ring) is of mode (CATEGORY package (SIGNATURE factor ((Factored P) P (Mapping (Factored (SparseUnivariatePolynomial R)) (SparseUnivariatePolynomial R)))) (SIGNATURE factor ((Factored (SparseUnivariatePolynomial P)) (SparseUnivariatePolynomial P) (Mapping (Factored (SparseUnivariatePolynomial R)) (SparseUnivariatePolynomial R)))))
      [5] intChoose:  unifact has no value
      [6] intChoose:  int has no value
      [7] simplify:  pol1 has no value
      [8] simplify:  factorlist has no value
      [9] intfact:  unifact has no value
      [10] intfact:  lpol has no value
      [11] intfact:  factfin has no value
      [12] monicMfpol:  z1 has no value
      [13] mFactor: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE factor ((Factored P) P (Mapping (Factored (SparseUnivariatePolynomial R)) (SparseUnivariatePolynomial R)))) (SIGNATURE factor ((Factored (SparseUnivariatePolynomial P)) (SparseUnivariatePolynomial P) (Mapping (Factored (SparseUnivariatePolynomial R)) (SparseUnivariatePolynomial R)))))
      [14] mFactor:  flead has no value
      [15] mFactor:  irr has no value
      [16] mFactor:  pow has no value
      [17] mFactor:  x has no value
      [18] mFactor:  ffactor has no value
      [19] mFactor:  lvar has no value
      [20] mFactor:  factorlist has no value
 
=========================================================================
warnings 20018:

>compiling INTERGB.spad to INTERGB.nrlib
 
   Warnings: 
      [1] coerceRtoDwithPF: not known that (PolynomialCategory (PrimeField q) E OV) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [2] coerceDtoRwithPF: not known that (PolynomialCategory (PrimeField q) E OV) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [3] coerceRtoD: not known that (PolynomialCategory K E OV) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [4] coerceDtoR: not known that (PolynomialCategory K E OV) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [5] groebner: not known that (PolynomialCategory (PrimeField q) E OV) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [6] groebner: not known that (PolynomialCategory K E OV) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
 
=========================================================================
warnings 20017:

>compiling INTRF.spad to INTRF.nrlib
 
   Warnings: 
      [1] infieldIntegrate:  x1 has no value
      [2] internalIntegrate:  x1 has no value
      [3] extendedIntegrate:  x1 has no value
      [4] limitedIntegrate:  x1 has no value
 
=========================================================================
warnings 20016:

>compiling INTSLPE.spad to INTSLPE.nrlib
 
   Warnings: 
      [1] solveLinearPolynomialEquation:  slpePrime has no value
      [2] solveLinearPolynomialEquation:  oldtable has no value
 
=========================================================================
warnings 20015:

>compiling INTTR.spad to INTTR.nrlib
 
   Warnings: 
      [1] UP2UP2:  x has no value
      [2] UP2UPR:  x has no value
      [3] UP22UPR:  x has no value
      [4] monomialIntegrate:  x1 has no value
      [5] expintegratepoly:  coef0 has no value
      [6] primlimintfrac:  x1 has no value
      [7] explimintfrac:  x1 has no value
      [8] explimintfrac:  logand has no value
      [9] explimintfrac:  coeff has no value
      [10] tanintegrate:  x has no value
 
=========================================================================
warnings 20014:

>compiling ISUMP.spad to ISUMP.nrlib
 
   Warnings: 
      [1] pmul:  x has no value
      [2] sum: not known that (Ring) is of mode (CATEGORY package (SIGNATURE sum ((Record (: num P) (: den (Integer))) P V (Segment P))) (SIGNATURE sum ((Record (: num P) (: den (Integer))) P V)))
 
=========================================================================
warnings 20013:

>compiling LAUPOL.spad to LAUPOL.nrlib
 
   Warnings: 
      [1] not known that (Ring) is of mode (CATEGORY domain (SIGNATURE separate ((Record (: polyPart $) (: fracPart (Fraction UP))) (Fraction UP))))
 
=========================================================================
warnings 20012:

>compiling LEADCDET.spad to LEADCDET.nrlib
 
   Warnings: 
      [1] distFact:  c has no value
 
=========================================================================
warnings 20011:

>compiling LGROBP.spad to LGROBP.nrlib
 
   Warnings: 
      [1] totolex:  result has no value
      [2] minPol: :(NonNegativeInteger) -- should replace by pretend
      [3] intcompBasis:  part has no value
      [4] linGenPos: :(PositiveInteger) -- should replace by pretend
      [5] linGenPos:  result has no value
      [6] groebgen: :(NonNegativeInteger) -- should replace by pretend
      [7] groebgen: not known that (Ring) is of mode (CATEGORY package (SIGNATURE linGenPos ((Record (: gblist (List (DistributedMultivariatePolynomial lv F))) (: gvlist (List (Integer)))) (List (HomogeneousDistributedMultivariatePolynomial lv F)))) (SIGNATURE groebgen ((Record (: glbase (List (DistributedMultivariatePolynomial lv F))) (: glval (List (Integer)))) (List (DistributedMultivariatePolynomial lv F)))) (SIGNATURE totolex ((List (DistributedMultivariatePolynomial lv F)) (List (HomogeneousDistributedMultivariatePolynomial lv F)))) (SIGNATURE minPol ((HomogeneousDistributedMultivariatePolynomial lv F) (List (HomogeneousDistributedMultivariatePolynomial lv F)) (List (HomogeneousDistributedMultivariatePolynomial lv F)) (OrderedVariableList lv))) (SIGNATURE minPol ((HomogeneousDistributedMultivariatePolynomial lv F) (List (HomogeneousDistributedMultivariatePolynomial lv F)) (OrderedVariableList lv))) (SIGNATURE computeBasis ((List (HomogeneousDistributedMultivariatePolynomial lv F)) (List (HomogeneousDistributedMultivariatePolynomial lv F)))) (SIGNATURE coord ((Vector F) (HomogeneousDistributedMultivariatePolynomial lv F) (List (HomogeneousDistributedMultivariatePolynomial lv F)))) (SIGNATURE anticoord ((DistributedMultivariatePolynomial lv F) (List F) (DistributedMultivariatePolynomial lv F) (List (DistributedMultivariatePolynomial lv F)))) (SIGNATURE intcompBasis ((List (HomogeneousDistributedMultivariatePolynomial lv F)) (OrderedVariableList lv) (List (HomogeneousDistributedMultivariatePolynomial lv F)) (List (HomogeneousDistributedMultivariatePolynomial lv F)))) (SIGNATURE choosemon ((DistributedMultivariatePolynomial lv F) (DistributedMultivariatePolynomial lv F) (List (DistributedMultivariatePolynomial lv F)))) (SIGNATURE transform ((HomogeneousDistributedMultivariatePolynomial lv F) (DistributedMultivariatePolynomial lv F))))
 
=========================================================================
warnings 20010:

>compiling LIMITRF.spad to LIMITRF.nrlib
 
   Warnings: 
      [1] limit:  y has no value
      [2] complexLimit:  y has no value
 
=========================================================================
warnings 20009:

>compiling LINDEP.spad to LINDEP.nrlib
   Warnings: 
      [1] linearlyDependent?: not known that (Ring) is of mode (CATEGORY package (SIGNATURE linearlyDependent? ((Boolean) (Vector R))) (SIGNATURE linearDependence ((Union (Vector S) failed) (Vector R))) (IF (has S (Field)) (SIGNATURE solveLinear ((Union (Vector S) failed) (Vector R) R)) (SIGNATURE solveLinear ((Union (Vector (Fraction S)) failed) (Vector R) R))))
      [2] solveLinear:  z has no value
      [3] solveLinear:  z1 has no value

=========================================================================
warnings 20008:

>compiling LISYSER.spad to LISYSER.nrlib
 
   Warnings: 
      [1] finiteSeries2LinSys: pretend(NonNegativeInteger) -- should replace by @
      [2] finiteSeries2LinSysWOVectorise: pretend(NonNegativeInteger) -- should replace by @


=========================================================================
warnings 20007:

>compiling LPEFRAC.spad to LPEFRAC.nrlib

   Warnings: 
      [1] solveLinearPolynomialEquationByFractions:  x has no value
      [2] solveLinearPolynomialEquationByFractions: not known that (Ring) is of mode (CATEGORY package (SIGNATURE solveLinearPolynomialEquationByFractions ((Union (List (SparseUnivariatePolynomial R)) failed) (List (SparseUnivariatePolynomial R)) (SparseUnivariatePolynomial R))))
 
=========================================================================
warnings 20006:

>compiling LSPP.spad to LSPP.nrlib
 
   Warnings: 
      [1] poly2vect: not known that (Ring) is of mode (CATEGORY package (SIGNATURE linSolve ((Record (: particular (Union (Vector (Fraction P)) failed)) (: basis (List (Vector (Fraction P))))) (List P) (List OV))))
 
=========================================================================
warnings 20005:

>compiling MATLIN.spad to MATLIN.nrlib
 
   Warnings: 
      [1] minorDet:  ans has no value
      [2] elRow2!:  r1 has no value
      [3] elColumn2!:  r1 has no value
      [4] nullSpace:  r2 has no value
      [5] nullSpace:  r1 has no value
      [6] rowEchelon:  xnj has no value
 
=========================================================================
warnings 20004:

>compiling MCDEN.spad to MCDEN.nrlib
 
   Warnings: 
      [1] clearDenominator:  x has no value
      [2] splitDenominator:  x has no value
 
=========================================================================
warnings 20003:

>compiling MDDFACT.spad to MDDFACT.nrlib
 
   Warnings: 
      [1] reduction:  i1 has no value
      [2] ddfact:  ans has no value
      [3] ddfact: :(Integer) -- should replace by @
      [4] sepFact1:  ans has no value
      [5] sepFact1:  stack has no value
      [6] probSplit: :(NonNegativeInteger) -- should replace by pretend
 
=========================================================================
warnings 20002:

>compiling MFINFACT.spad to MFINFACT.nrlib

   Warnings: 
      [1] pretendOV -- should replace by @
      [2] supFactor:  p1 has no value
      [3] supFactor: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE factor ((Factored PG) PG)) (SIGNATURE factor ((Factored (SparseUnivariatePolynomial PG)) (SparseUnivariatePolynomial PG))))
      [4] supFactor:  p has no value
      [5] factor:  p1 has no value
      [6] mFactor:  irr has no value
      [7] mFactor:  pow has no value
      [8] mFactor: not known that (Ring) is of mode (CATEGORY package (SIGNATURE factor ((Factored PG) PG)) (SIGNATURE factor ((Factored (SparseUnivariatePolynomial PG)) (SparseUnivariatePolynomial PG))))
      [9] mFactor:  ffactor has no value
      [10] mFactor:  factorlist has no value
      [11] pushdcoef:  f1 has no value
      [12] intfact:  unifact has no value
      [13] intfact:  lpol has no value
      [14] intfact:  factfin has no value
      [15] intChoose:  newm has no value
      [16] intChoose:  unifact has no value
      [17] intChoose:  int has no value
      [18] simplify:  pol1 has no value
      [19] simplify:  factorlist has no value
 
=========================================================================
warnings 20000:

>compiling MLIFT.spad to MLIFT.nrlib
 
   Warnings: 
      [1] Use: import (GenExEuclid R (SparseUnivariatePolynomial R))
      [2] Use: import (NPCoef (SparseUnivariatePolynomial R) E OV R P)
      [3] Use: import (IntegerCombinatoricFunctions (Integer))
      [4] corrPoly:  p1 has no value
      [5] corrPoly:  p has no value
      [6] lifting1:  p1 has no value
      [7] lifting:  nplist has no value
      [8] normalDerivM: not known that (Ring) is of mode (CATEGORY package (SIGNATURE corrPoly ((Union (List (SparseUnivariatePolynomial P)) failed) (SparseUnivariatePolynomial P) (List OV) (List R) (List (NonNegativeInteger)) (List (SparseUnivariatePolynomial P)) (Vector (List (SparseUnivariatePolynomial R))) R)) (SIGNATURE lifting ((Union (List (SparseUnivariatePolynomial P)) failed) (SparseUnivariatePolynomial P) (List OV) (List (SparseUnivariatePolynomial R)) (List R) (List P) (List (NonNegativeInteger)) R)) (SIGNATURE lifting1 ((Union (List (SparseUnivariatePolynomial P)) failed) (SparseUnivariatePolynomial P) (List OV) (List (SparseUnivariatePolynomial P)) (List R) (List P) (List (List (Record (: expt (NonNegativeInteger)) (: pcoef P)))) (List (NonNegativeInteger)) (Vector (List (SparseUnivariatePolynomial R))) R)))
 
=========================================================================
errors 10000: 

>compiling FT.spad to FT.nrlib
 
   Semantic Errors: 
      [1]  void is not a known type

=========================================================================
errors 10001: 

>compiling ASP34.spad to ASP34.nrlib
 
   Semantic Errors: 
      [1] coerce:  code is BOTH a variable and a literal
 
=========================================================================
errors 10002: 

>compiling MOEBIUS.spad to MOEBIUS.nrlib
 
   Semantic Errors: 
      [1]  a is BOTH a variable and a literal
      [2]  b is BOTH a variable and a literal
      [3]  c is BOTH a variable and a literal
      [4]  d is BOTH a variable and a literal
      [5] eval:  a is BOTH a variable and a literal
      [6] eval:  b is BOTH a variable and a literal
      [7] eval:  c is BOTH a variable and a literal
      [8] eval:  d is BOTH a variable and a literal
      [9] proportional?:  a is BOTH a variable and a literal
      [10] proportional?:  b is BOTH a variable and a literal
      [11] proportional?:  c is BOTH a variable and a literal
      [12] proportional?:  d is BOTH a variable and a literal
 
=========================================================================
errors 10003: 

>compiling POLYVEC.spad to POLYVEC.nrlib
 
   Semantic Errors: 
      [1] vectorcombination:  i has two modes: 
 
=========================================================================
errors 10004: 

>compiling EQ.spad to EQ.nrlib
 
   Semantic Errors: 
      [1] factorAndSplit:  rcf has two modes: 
 
=========================================================================
errors 10005: 

>compiling MULTSQFR.spad to MULTSQFR.nrlib

   Semantic Errors: 
      [1] squareFree:  ff has two modes: 
 
=========================================================================
errors 10006: 

>compiling ASP30.spad to ASP30.nrlib
 
   Semantic Errors: 
      [1] coerce:  code is BOTH a variable and a literal
 
=========================================================================
errors 10007: 

>compiling ASP8.spad to ASP8.nrlib
 
   Semantic Errors: 
      [1] coerce:  code is BOTH a variable and a literal
 
=========================================================================
errors 10008: 

>compiling ASP9.spad to ASP9.nrlib
 
   Semantic Errors: 
      [1] coerce:  code is BOTH a variable and a literal
 
=========================================================================
errors 10009: 

>compiling ISUPS.spad to ISUPS.nrlib
 
   Semantic Errors: 
      [1] compose0:  k is BOTH a variable and a literal
 
=========================================================================
errors 10010: 

>compiling SYMS.spad to SYMS.nrlib
 
   Semantic Errors: 
      [1]  Domain is not a known type
      [2]  void is not a known type
 
=========================================================================
errors 10011: 

>compiling ASP31.spad to ASP31.nrlib
 
   Semantic Errors: 
      [1] coerce:  code is BOTH a variable and a literal
 
=========================================================================
errors 10012: 

>compiling ASP77.spad to ASP77.nrlib
 
   Semantic Errors: 
      [1] coerce:  code is BOTH a variable and a literal
 
=========================================================================
errors 10013: 

>compiling FC.spad to FC.nrlib
 
   Semantic Errors: 
      [1] common:  name is BOTH a variable and a literal
      [2] common:  contents is BOTH a variable and a literal
      [3] forLoop:  body is BOTH a variable and a literal
 
=========================================================================
errors 10014: 

>compiling ODERTRIC.spad to ODERTRIC.nrlib
 
   Semantic Errors: 
      [1]  RatODETools is not a known type
 
=========================================================================
errors 10015: 

>compiling NORMPK.spad to NORMPK.nrlib
 
   Semantic Errors: 
      [1] recip:  hesrg has two modes: 
 

=========================================================================
bug 7233: fill! operation from U8Vector does not show up


)d op fill!

There are 2 exposed functions called fill! :
   [1] (D,D1) -> D from D
            if D has ARR2CAT(D1,D2,D3) and D1 has TYPE and D2 has FLAGG
            (D1) and D3 has FLAGG(D1)
   [2] (D,D1) -> D from D
            if D has shallowlyMutable and D has IXAGG(D2,D1) and D2 has
            SETCAT and D1 has TYPE

Examples of fill! from TwoDimensionalArrayCategory

arr : ARRAY2 INT := new(5,4,0) 
fill!(arr,10)


Examples of fill! from IndexedAggregate


=========================================================================

bug 7232: Cannot convert from type Symbol to PositiveInteger for value #3

)clear all
foo(E:PI,totient:INT,N:INT):LIST(INT) ==
  modN:=IntegerMod(N)
  modtotient:=IntegerMod(totient)
  D:=[x for x in 1..totient | (x*E)::modtotient = 1].1
  secret:=(42^E)::modN 
  clear:=(secret^D)::modN 
  [secret,D,E,N]

P:=11
Q:=17
N:=P*Q
totient:=(P-1)*(Q-1)
t1:=[x for x in 1..totient | gcd(totient,x) = 1]
[foo(t1.y,totient,N) for y in 1..#t1]
-- fails with 
--  Connot convert from type Symbol to PositiveInteger for value #3


=========================================================================

bug 7231: D2 is not of type SEQUENCE

see dop.input.pamphlet S 69
)d op coerce

=========================================================================

bug 7230: richhyper1000-1098 S 272 failed

Bisect to see when this started

=========================================================================

bug 7229: )show FortranCode has NIL for the containing file

similarly
FortranProgram, FortranType, ROIRC

)show InfClsPt simply fails
)show MyExpression simply fails
)show MyUnivariatePolynomial simply fails

)show PackageForAlgebraicFunctionField fails with:
  listSort: second argument must be a list

)show BSD lists the source file as Makefile.pamphlet

=========================================================================

bug 7228: graphics crash running space3

The src/input/space3.input causes an early exit

=========================================================================

bug 7227: Unexpected end of #<input stream 

see exampleagcode.output, test 3. Now gives the result

Unexpected end of 
  #<input stream "/research/test/mnt/ubuntu/algebra/interp.daase">

This is caused by the removal of PAFFFF from the current system.

=========================================================================

bug 7226: )d op coerce regression caused by waldek format update.

correct in git 95402C

see src/input/dop test 69
appears to be in ALGSC
[4] Vector D2 -> AlgebraGivenByStructuralConstants(D2,D3,D4,D5)
    from AlgebraGivenByStructuralConstants(D2,D3,D4,D5)

=========================================================================

bug 7225: Lasagna Larga Doppia Riccia does not plot 0.0

See bookvol8.1, section Lasagna Larga Doppia Riccia

given:

X(i,j) == _
  if ((8 <= i) and (i <= 42)) _
   then 5.0/6.0+(5.0*i-40.0)/34.0 _
   else if (i <= 8) _
         then 5.0*i/48.0 _
         else 5.0/6.0*(7+(i-42.0)/8)
Y(i,j) == j/15.0
Z(i,j) == _
  if ((8 <= i) and (i <= 42)) _
   then 0.0 _
   else if (i <= 8) _
         then (8.0-i)/32.0*cos((j+3)*%pi/6) _
         else 0.25*(i-42)/8.0*cos((j+9)*%pi/6)
v3d:=draw(surface(X(i,j),Y(i,j),Z(i,j)),i=0..50,j=0..150,_
           style=="smooth",title=="Lasagna Larga Doppia Riccia")
colorDef(v3d,yellow(),yellow())
axes(v3d,"off")
zoom(v3d,3.0,3.0,3.0)

The middle part of the image should generate 0.0 for the Z value
but the drawn image does not show a flat plane. Calling Z(30.0,30.0)
shows that the values of 0.0 is generated.

=========================================================================

bug 7224: Axiom2D PS save function clips right side of image

draw(sin(4*t/7),t=0..14*%pi,coordinates==elliptic(1$DFLOAT))

menu -> ps 
use gimp to look at ps

=========================================================================

bug 7223: Bind stack overflow

-- (defun |*2;dot;5;frame1394| is being compiled
-- The variable |*2;dot;5;frame1394;MV is undefined
-- The compiler will assume this variable is a global
-- Internal error
-- The function coerce with signature OrderedCompletion Integer ->
--   Expression OrderedCompletion Integer is missing from domain
--   Expression(OrderedCompletion(Integer))
--
--   Internal Error
--   The function coerce with signature hashcode is missing from domain 
--      Expression(OrderedCompletion (Integer)) 
dot(f,g) == integrate(f*g*x^2,x=-1..1)
proj(f,g) == dot(f,g)*f/dot(f,f)
p0:=1
p1:=x-proj(p0,x)
p2:=x^2-proj(p0,x^2)-proj(p1,x^2)
-- this give bind stack overflow
p(0) == 1
p(n | n > 0) == x^n-sum(proj(p(k),x^n),k=0..n-1)
p(1)

(7) -> )clear all
(1) -> dot(f,g) == integrate(f*g*x^2,x=-1..1)
                                                                   Type: Void
(2) -> proj(f,g) == dot(f,g)*f/dot(f,f)
                                                                   Type: Void
(3) -> p0:=1

   (3)  1
                                                        Type: PositiveInteger
(4) -> p1:=x-proj(p0,x)
   Compiling function dot with type (PositiveInteger,Variable x) -> 
      Union(f1: OrderedCompletion Expression Integer,f2: List 
      OrderedCompletion Expression Integer,fail: failed,pole: 
      potentialPole) 
   There are 34 exposed and 23 unexposed library operations named * 
      having 2 argument(s) but none was determined to be applicable. 
      Use HyperDoc Browse, or issue
                                )display op *
      to learn more about the available operations. Perhaps 
      package-calling the operation or using coercions on the arguments
      will allow you to apply the operation.
   Cannot find a definition or applicable library operation named * 
      with argument type(s) 
Union(f1: OrderedCompletion Expression Integer,f2: List OrderedCompletion Expression Integer,fail: failed,pole: potentialPole)
                               PositiveInteger
      
      Perhaps you should use "@" to indicate the required return type, 
      or "$" to specify which version of the function you need.
   AXIOM will attempt to step through and interpret the code.
   Compiling function dot with type (PositiveInteger,PositiveInteger)
       -> Union(f1: OrderedCompletion Expression Integer,f2: List 
      OrderedCompletion Expression Integer,fail: failed,pole: 
      potentialPole) 

   (4)  x
                                                     Type: Expression Integer
(5) -> p2:=x^2-proj(p0,x^2)-proj(p1,x^2)
   Compiling function dot with type (PositiveInteger,Polynomial Integer
      ) -> Union(f1: OrderedCompletion Expression Integer,f2: List 
      OrderedCompletion Expression Integer,fail: failed,pole: 
      potentialPole) 
   Compiling function dot with type (Expression Integer,Polynomial 
      Integer) -> Union(f1: OrderedCompletion Expression Integer,f2: 
      List OrderedCompletion Expression Integer,fail: failed,pole: 
      potentialPole) 
   Internal Error
   The function coerce with signature hashcode is missing from domain 
      Expression(OrderedCompletion (Integer)) 

(5) -> p(0) == 1
                                                                   Type: Void
(6) -> p(n | n > 0) == x^n-sum(proj(p(k),x^n),k=0..n-1)
                                                                   Type: Void
(7) -> p(1)
   Cannot compile map: proj 
   We will attempt to interpret the code.
   Cannot compile map: p 
   We will attempt to interpret the code.
 
   >> System error:
   Bind stack overflow.

(7) -> 



=========================================================================

bug 7222: errors while compiling bookvol7

make[3]: Entering directory `/research/test/int/hyper'
1 making /research/test/mnt/ubuntu/lib/spadbuf from /research/test/books/bookvol7.pamphlet
spadbuf.c: In function interpIO:
spadbuf.c:89: warning: ignoring return value of write, declared with attribute warn_unused_result
2 making /research/test/mnt/ubuntu/lib/ex2ht from /research/test/books/bookvol7.pamphlet
3 making /research/test/mnt/ubuntu/bin/htadd from /research/test/books/bookvol7.pamphlet
htadd.c: In function buildHtFilename:
htadd.c:1314: warning: ignoring return value of getcwd, declared with attribute warn_unused_result
4 making /research/test/mnt/ubuntu/bin/hthits from /research/test/books/bookvol7.pamphlet
hthits.c: In function handleFile:
hthits.c:65: warning: ignoring return value of fgets, declared with attribute warn_unused_result
hthits.c: In function handlePage:
hthits.c:166: warning: ignoring return value of fread, declared with attribute warn_unused_result
5 making /research/test/mnt/ubuntu/bin/htsearch from /research/test/books/bookvol7.pamphlet
6 making /research/test/mnt/ubuntu/lib/presea from /research/test/books/bookvol7.pamphlet
7 /research/test/mnt/ubuntu/bin/hypertex from /research/test/books/bookvol7.pamphlet
hypertex.c: In function buildHtFilename:
hypertex.c:2029: warning: ignoring return value of getcwd, declared with attribute warn_unused_result
hypertex.c: In function handleKey:
hypertex.c:8748: warning: ignoring return value of system, declared with attribute warn_unused_result
hypertex.c: In function issueUnixcommand:
hypertex.c:13808: warning: ignoring return value of system, declared with attribute warn_unused_result
10 making /research/test/mnt/ubuntu/doc/axbook/xhtml from /research/test/books/axbook.tgz
8 making /research/test/mnt/ubuntu/doc/bigbayou.png from /research/test/books/bigbayou.png
9 making /research/test/mnt/ubuntu/doc/doctitle.png from /research/test/books/d

=========================================================================

bug 7221: The variable IDENTITY is undefined.

; (DEFUN |Pattern;| ...) is being compiled.
;; The variable IDENTITY is undefined.
;; The compiler will assume this variable is a global.
------------------------------------------------------------------------
   Pattern is now explicitly exposed in frame initial 
   Pattern will be automatically loaded when needed from 
      /research/test/int/algebra/PATTERN.nrlib/code


=========================================================================

bug 7220: Manicotti only draws 1/2 of image

See bookvol8.1.pamphlet vs Pasta by Design book

Not clear if the problem is the equations or the graphics

=========================================================================

bug 7219: Funghini draws only lines

See bookvol8.1.pamphlet vs Pasta by Design book

Not clear if the problem is the equations or the graphics

=========================================================================

bug 7218: makeViewport3D closed unexpectedly

given:

A(i)    == sin(i*%pi/2000)^0.5
X1(i,j) == _
  if (i <= 2000) _
   then 2.1*cos((2*A(i)+1)*%pi)+0.65*cos((2*A(i)+0.5)*%pi)+_
        2.5*sin((A(i)+1.83)*%pi)^500 _
   else -2.1
Y1(i,j) == _
  if (i <= 2000) _
   then 2.5*sin((2*A(i)+1)*%pi)+0.1*sin(A(i)*2*%pi)+_
        3*sin((A(i)+1.83)*%pi)^500 _
   else 0.0
Z(i,j) == j/4.0
vsp:=createThreeSpace()
makeObject(surface(X1(i,j),Y1(i,j),Z(i,j)),i=0..3000,j=0..4,space==vsp)
vp:=makeViewport3D(vsp,style=="smooth",title=="Racchette")
axes(vp,"off")

>> Error detected within library code: 
This viewport has already been closed

See section{Racchette} in bookvol8.1.pamphlet

Note that if the whole example is run the viewport is still open.
Only when the subset involves just (X1,Y1,Z) does it fail.

Note the same error occurs in Rotelle.

X1(i,j) == _
  if (i <= 666) _
   then 2*cos(3*i*%pi/1000)+0.03*cos(93*i*%pi/1000) _
   else 2.03
Y1(i,j) == _
  if (i <= 666) _
   then 2.05*sin(3*i*%pi/1000)+0.03*sin(93*i*%pi/1000) _
   else 0.0
Z(i,j) == j/5.0
vsp:=createThreeSpace()
makeObject(surface(X1(i,j),Y1(i,j),Z(i,j)),i=0..2000,j=0..5,space==vsp)
vp:=makeViewport3D(vsp,style=="smooth",title=="Rotelle")
axes(vp,"off")

>> Error detected within library code: 
This viewport has already been closed

draw(surface(X1(i,j),Y1(i,j),Z(i,j)),i=0..2000,j=0..5)

succeeds with a wildly strange float
"float(149787561878521559122,-66,2)/float(1,0,2)

so I suspect the equations are wrong in some way. --tpd


=========================================================================

bug 7216: 

t0207:= -a^3*(a+b*x)*Ei(log(c*(a+b*x)^n)/n)/((c*(a+b*x)^n)^(1/n))/b^4/n+3*a^2*(a+b*x)^2*Ei(2*log(c*(a+b*x)^n)/n)/((c*(a+b*x)^n)^(2/n))/b^4/n-3*a*(a+b*x)^3*Ei(3*log(c*(a+b*x)^n)/n)/((c*(a+b*x)^n)^(3/n))/b^4/n+(a+b*x)^4*Ei(4*log(c*(a+b*x)^n)/n)/((c*(a+b*x)^n)^(4/n))/b^4/n
 

   (32)
                                                               1              2
                                                               -              -
           4 4       3 3     2 2 2     3       4             n n            n n
         (b x  + 4a b x  + 6a b x  + 4a b x + a )(c (b x + a) ) (c (b x + a) )
      *
                       3
                       -                   n
                     n n   4log(c (b x + a) )
         (c (b x + a) ) Ei(------------------)
                                    n
     + 
                                                           1              2
                                                           -              -
                3 3     2 2 2     3        4             n n            n n
         (- 3a b x  - 9a b x  - 9a b x - 3a )(c (b x + a) ) (c (b x + a) )
      *
                       4
                       -                   n
                     n n   3log(c (b x + a) )
         (c (b x + a) ) Ei(------------------)
                                    n
     + 
                                               1              3              4
                                               -              -              -
            2 2 2     3        4             n n            n n            n n
         (3a b x  + 6a b x + 3a )(c (b x + a) ) (c (b x + a) ) (c (b x + a) )
      *
                            n
            2log(c (b x + a) )
         Ei(------------------)
                     n
     + 
                                     2              3              4
                                     -              -              -
             3       4             n n            n n            n n
         (- a b x - a )(c (b x + a) ) (c (b x + a) ) (c (b x + a) )
      *
                           n
            log(c (b x + a) )
         Ei(-----------------)
                    n
  /
                       1              2              3              4
                       -              -              -              -
      4              n n            n n            n n            n n
     b n (c (b x + a) ) (c (b x + a) ) (c (b x + a) ) (c (b x + a) )
                                                     Type: Expression Integer
a0207:= integrate(t0207,x)
 
 
   >> Error detected within library code:
   Sorry - cannot handle that integrand yet

   Continuing to read the file...

=========================================================================

bug 7215: integration bug?

t0317:= (-1+tanh(x)^2)^(3/2)
 

                        +------------+
                 2      |       2
   (85)  (tanh(x)  - 1)\|tanh(x)  - 1
                                                     Type: Expression Integer
r0317:= -1/2*cosh(x)*(-sech(x)^2)^(1/2)*(atan(sinh(x))+sech(x)*tanh(x))
 

                                                          +----------+
                                                          |         2
         (- cosh(x)atan(sinh(x)) - cosh(x)sech(x)tanh(x))\|- sech(x)
   (86)  -------------------------------------------------------------
                                       2
                                                     Type: Expression Integer
a0317:= integrate(t0317,x)
 

   (87)  0
                                          Type: Union(Expression Integer,...)

=========================================================================

bug 7214: integration bug?

(1) -> t0062:= x*(sin(x)^2)^(1/2)

          +-------+
          |      2
   (1)  x\|sin(x)

(2) -> r0062:= -csc(x)*(x*cos(x)-sin(x))*(sin(x)^2)^(1/2)

                                        +-------+
                                        |      2
   (2)  (csc(x)sin(x) - x cos(x)csc(x))\|sin(x)

(3) -> a0062:= integrate(t0062,x)

   (3)  sin(x) - x cos(x)

Axiom's answer seems simpler 

(4) -> t1:=D(a0062,x)

   (4)  x sin(x)

But it is not equivalent to the integrand

(5) -> t2:=t0062-t1

          +-------+
          |      2
   (5)  x\|sin(x)   - x sin(x)

And it does not differ by a constant

(6) -> t3:=D(t2,x)

                              +-------+
                              |      2          2
        (- sin(x) - x cos(x))\|sin(x)   + sin(x)  + x cos(x)sin(x)
   (6)  ----------------------------------------------------------
                                 +-------+
                                 |      2
                                \|sin(x)

Of course, Rich's answer does not differentiate to the closed form

(7) -> t4:=D(r0062,x)

   (7)
                                 3                                        2
       (- cot(x) + x)csc(x)sin(x)  + (x cos(x)cot(x) + cos(x))csc(x)sin(x)
     + 
                 2
       - x cos(x) csc(x)sin(x)
  /
      +-------+
      |      2
     \|sin(x)

And it does not differ by a constant

(8) -> t5:=t4-t1

   (8)
                  +-------+
                  |      2                              3
       - x sin(x)\|sin(x)   + (- cot(x) + x)csc(x)sin(x)
     + 
                                            2           2
       (x cos(x)cot(x) + cos(x))csc(x)sin(x)  - x cos(x) csc(x)sin(x)
  /
      +-------+
      |      2
     \|sin(x)
                                                    Type: Expression(Integer)


=========================================================================

bug 7213: different result appear

--   >> Error detected within library code:
--   Imaginary part is nonzero. Cannot retract.
--
--S 488 of 520 sometimes Imaginary part is nonzero. Cannot retract.
a0093:= integrate(t0093,x)
--R 
--R
--R                       +--------+
--R                       |  2
--R                       |%R b - a
--R               sin(%R) |--------
--R             x         |     2
--R           ++         \|   %R
--R   (360)   |   ------------------ d%R
--R          ++       +----------+
--R                   |    2
--R                  \|- %R b + a
--R                                          Type: Union(Expression Integer,...)

=========================================================================

bug 7212: differing integration? due to random algorithm?


t0404:= (-1+x)^(1/2)/x^(1/2)
integrate(t0404,x)
 

   (23)
            +-----+ +-+               +-+    +-----+             +-----+ +-+
       (- 2\|x - 1 \|x  - 2x + 1)log(\|x  + \|x - 1 ) + (2x - 1)\|x - 1 \|x
     + 
         2
       2x  - 2x
  /
       +-----+ +-+
     2\|x - 1 \|x  + 2x - 1
                                          Type: Union(Expression Integer,...)
--R 
--R
--R                   +-----+ +-+               +-----+ +-+
--R         - log(- 2\|x - 1 \|x  - 2x + 1) + 2\|x - 1 \|x
--R   (23)  -----------------------------------------------
--R                                2
--R                                          Type: Union(Expression Integer,...)

another example:

tt:=sqrt(x)/sqrt(x+1)
integrate(tt,x)

                   +-+ +-----+               +-+ +-----+
         - log(- 2\|x \|x + 1  - 2x - 1) + 2\|x \|x + 1
   (22)  -----------------------------------------------
                                2
                                          Type: Union(Expression Integer,...)

but sometimes we get:

 

   (18)
            +-+ +-----+               +-----+    +-+             +-+ +-----+
       (- 2\|x \|x + 1  - 2x - 1)log(\|x + 1  + \|x ) + (2x + 1)\|x \|x + 1
     + 
         2
       2x  + 2x
  /
       +-+ +-----+
     2\|x \|x + 1  + 2x + 1
                                          Type: Union(Expression Integer,...)


=========================================================================

todo 329: axiom reference info update

get all http://axiom-portal.newsynthesis.org/refs/articles

=========================================================================

bug 7210: but in partial fraction 

Axiom gets a different answer than Fricas.

Is the following close to what you have in mind?  (two problems: you
need to know the extension in advance, and I don't see a way to factor
over extensions of degree higher than one right now.  Possibly Waldek
knows.)

(1) -> SAEs5 := SAE(FRAC INT,UP(s5,FRAC INT),s5^2-5)

   (1)
  SimpleAlgebraicExtension(Fraction(Integer),UnivariatePolynomial(s5,Fra
  ction(Integer)),s5^2+-5)
                                                            Type: Type
(2) -> p:UP(x,SAEs5) :=(x^5-1)*(x^2-1)*(x-1)

         8    7    6    5    3    2
   (2)  x  - x  - x  + x  - x  + x  + x - 1
Type:
   UnivariatePolynomial(x,SimpleAlgebraicExtension(Fraction(Integer),UnivariatePolynomial(s5,Fraction(Integer)),s5^2+-5))
(3) -> factor p

               3         2      1      1         2    1      1
   (3)  (x - 1) (x + 1)(x  + (- - s5 + -)x + 1)(x  + (- s5 + -)x + 1)
                                2      2              2      2
Type:
   Factored(UnivariatePolynomial(x,SimpleAlgebraicExtension(Fraction(Integer),UnivariatePolynomial(s5,Fraction(Integer)),s5^2+-5)))
(4) -> partialFraction(1/p, x)

   (4)
     13  2    9     27     1         1       1      1       1
     -- x  - -- x + --     -     (- -- s5 - --)x + -- s5 - --
     40      10     40     8        50      10     50      10
     ----------------- - ----- + ----------------------------
                 3       x + 1       2      1      1
          (x - 1)                   x  + (- - s5 + -)x + 1
                                            2      2
   +
       1       1      1       1
     (-- s5 - --)x - -- s5 - --
      50      10     50      10
     --------------------------
         2    1      1
        x  + (- s5 + -)x + 1
              2      2
Type:
     PartialFraction(UnivariatePolynomial(x,Fraction(Polynomial(SimpleAlgebraicExtension(Fraction(Integer),UnivariatePolynomial(s5,Fraction(Integer)),s5^2+-5)))))

Apart from that: Grbner bases are in Axiom (FriCAS, OpenAxiom), and a
rather good implementation, too. 

=========================================================================

bug 7209: Factoring in LODOF is incorrect

    rfactor(op, r, zeros, ezfactor, adj?) ==
--      degree r > 1 or not one? leadingCoefficient r =>
      degree r > 1 or not ((leadingCoefficient r) = 1) =>
        recurfactor(op, r, zeros, ezfactor, adj?)
      op1 := opeval(op, dd - coefficient(r, 0)::L)
      map_!((z:L):L+->opeval(z,r), recurfactor(op1, dd, zeros, ezfactor, adj?))

Waldek claims this should read:

    rfactor(op, r, zeros, ezfactor, adj?) ==
      recurfactor(op, r, zeros, ezfactor, adj?)

Martin comments:

 I reworked lodof.input into the unittest framework, including 
 additionally a simplified version of the bug and a new product of two
 irreducible degree 2 factors, which fails, of course. Unfortunately,
 your patched rfactor seems to go into an infinite loop with

-- reducible order 3 operator (1-1-1)
testFactor [(t^9 + t^3)*d +(-sqrt 91+7)*t^8+(-sqrt 91 + 1)*t^2,_
            d + ((sqrt 91 + 6)*t^6 + sqrt 91)/(t^7+t),_
            d + (5*t^6 - 1)/(t^7 + t)]

Waldek comments:

 The real problem seems to be that

 op2 := (t^9+t^3)*d^2 + (13*t^8+t^2)*d - 55*t^7 - 91*t
 factor(op2)

 is extremely slow. I am looking at this -- one problem is
 that we spend a lot of time computing gcd-s of polynomials
 with algebraic coefficients

=========================================================================

bug 7207: integrate(1/(2-3*x)^(1/2)/(2+3*x)^(1/2),x)
 
should be 1/3*asin(3/2*x)
but causes an infinite loop in integration

=========================================================================

bug 7206: from http://bugs.debian.org/349877

X-Debbugs-CC: Jiri Palecek <jpalecek@web.de>
Package: axiom
Version: 20050901-4
Severity: normal

When I enter in axiom

> p:(NonNegativeInteger)->Polynomial AlgebraicNumber
> p i==if i=0 then 1 else x^i-reduce(+,[integrate(x^i*p k,x=0..1)*p k for  
> k in 0..i-1])

and then

> p 1

I get this error:

   Internal Error
   Interpreter code generation failed for expression
      (IF (= |#1| 0) 1
          (- (^ |x| |#1|)
             (|reduce| +
                 (|construct|
                     (COLLECT (STEP |k| 0 1 (- |#1| 1))
                              (* (|integrate|
                                     (* (^ |x| |#1|) (|p| |k|))
                                     (= |x| (SEGMENT 0 1)))
                                 (|p| |k|)))))))



-- System Information:
Debian Release: testing/unstable
  APT prefers testing
  APT policy: (500, 'testing'), (500, 'stable')
Architecture: i386 (i686)
Shell:  /bin/sh linked to /bin/dash
Kernel: Linux 2.6.15
Locale: LANG=C, LC_CTYPE=C (charmap=ISO-8859-2) (ignored: LC_ALL set to  
cs_CZ)

Versions of packages axiom depends on:
ii  axiom-databases               20050901-4 A general purpose computer  
algebra
ii  libc6                         2.3.5-8    GNU C Library: Shared  
libraries an
ii  libgmp3c2                     4.1.4-10   Multiprecision arithmetic  
library
ii  libncurses5                   5.5-1      Shared libraries for terminal  
hand
ii  libreadline5                  5.1-5      GNU readline and history  
libraries

Versions of packages axiom recommends:
ii  axiom-doc                     20050901-4 A general purpose computer  
algebra
ii  axiom-graphics                20050901-4 A general purpose computer  
algebra
ii  axiom-hypertex                20050901-4 A general purpose computer  
algebra
pn  axiom-source                  <none>     (no description available)

-- no debconf information
-- 
Using Opera's revolutionary e-mail client: http://www.opera.com/mail/



=========================================================================

bug 7205: interval is not recognized:

)d op interval

There are 3 exposed functions called interval :
   [1] Fraction Integer -> D from D
            if D has INTCAT D2 and D2 has Join(FloatingPointSystem,
            TranscendentalFunctionCategory)
   [2] D1 -> D from D
            if D has INTCAT D1 and D1 has Join(FloatingPointSystem,
            TranscendentalFunctionCategory)
   [3] (D1,D1) -> D from D
            if D has INTCAT D1 and D1 has Join(FloatingPointSystem,
            TranscendentalFunctionCategory)

Examples of interval from IntervalCategory

(31) -> fi:=1/4::FRAC(INT)

         1
   (31)  -
         4
                                                       Type: Fraction Integer
(32) -> interval(fi)$INTERVAL(FRAC(INT))
   There are 2 exposed and 0 unexposed library operations named 
      interval having 1 argument(s) but none was determined to be 
      applicable. Use HyperDoc Browse, or issue
                            )display op interval
      to learn more about the available operations. Perhaps 
      package-calling the operation or using coercions on the arguments
      will allow you to apply the operation.
 
   Cannot find a definition or applicable library operation named 
      interval with argument type(s) 
                              Fraction Integer
      
      Perhaps you should use "@" to indicate the required return type, 
      or "$" to specify which version of the function you need.


=========================================================================

bug 7204: 

-- bug in this rule form?  int(x+ :y,z) == int(x,z)+int(y,z)
-- and also this one?    int(x+y,z) == int(x,z)+int(y,z)
intRules:=rule 
   int(x+y,z) == int(x,z)+int(y,z)
   int(k*x | freeOf?(k,z),z) == k*int(x,z)
   int(y | integer? y, z) == y*z
   int(x^(?p | D(p,x)=0),x) == x^(p+1)/(p+1)
intRules int(a^2*b+a^b+3*a-5,a)
intRules int(a^(a+1),a)

=========================================================================

bug 7203: in GRAS the line

       vType:SINT := xor(op2type,uType) -- remaining ^factors

fails to compile. It expects op2type to be boolean even though
op2type and uType are SINT and the target vType is SINT. The line

   XOR(x:SINT,y:SINT):SINT == LOGXOR(x,y)$Lisp

was temporarily added to work around the bug.

=========================================================================

bug 7201: sin(x) drawing error

drawing tubeplots does not always work as expected

s:=create3Space()$(ThreeSpace DFLOAT)
draw(curve(x,sin(x),0),x=0..4,style="shade",tubeRadius=0.3,tubePoints=20,
    space==s)
draw(curve(x,sin(x),1),x=-4..4,style="shade",tubeRadius=0.3,tubePoints=20,
    space==s)

=========================================================================

bug 7200: Improper syntax after browse

in hyperdoc click on browse
enter draw
click operations
select descriptions
enter any command in main window: e.g. 1+1
and you get

line  1: 1+1
Error A: Improper syntax
Error A: Improper syntax
Error A: syntax error at top level 
...

=========================================================================

bug 7199: real/imag giving wrong answers

a:=(-1*%i)^(1/2)
b:=(%i)^(3/2)
real(a)
imag(a)
real(b)
imag(b)


=========================================================================

bug 7198: missing coerce function in OrderedCompletion Integer

-- (defun |*2;dot;5;frame1394| is being compiled
-- The variable |*2;dot;5;frame1394;MV is undefined
-- The compiler will assume this variable is a global
-- Internal error
-- The function coerce with signature OrderedCompletion Integer ->
--   Expression OrderedCompletion Integer is missing from domain
--   Expression(OrderedCompletion(Integer))
--
--   Internal Error
--   The function coerce with signature hashcode is missing from domain 
--      Expression(OrderedCompletion (Integer)) 
dot(f,g) == integrate(f*g*x^2,x=-1..1)
proj(f,g) == dot(f,g)*f/dot(f,f)
p0:=1
p1:=x-proj(p0,x)
p2:=x^2-proj(p0,x^2)-proj(p1,x^2)
-- this give bind stack overflow
p(0) == 1
p(n | n > 0) == x^n-sum(proj(p(k),x^n),k=0..n-1)
p(1)


=========================================================================

todo 326: Guess.tex needs to be used to document the guess package

=========================================================================

todo 326: in LODOOPS the fricas version of the killer function differs
          and the nonTrivial function is missing

=========================================================================

todo 325: permute list of anything

n:=[1,2,3,4]
permutations n
p:=[x.[i] for i in 1..4]
permutations p

=========================================================================

bug 7197: hyperdoc/graphics failure

Basic Commands -> Draw -> exit

=========================================================================

bug 7196: factor is partial

n:= 1303 * 16927 * 157543
factor(n)

occasionally only partially factors, returning

1303 * 2666730361

=========================================================================

todo 324: integrate: implementation incomplete (constant residues)

integrate(
 (x^2+2*x+1*(3*x+1)*sqrt(x+log(x)))/
    (x*sqrt(x+log(x))*(x+sqrt(x+log(x)))),x)

the antiderivative is

 2*(sqrt(x+log(x))+log(x+sqrt(x+log(x))))

or, a shorter example is:

integrate(sqrt(x+log(x)),x)

=========================================================================

bug 7195: draw bug
i tried to draw a surface, typing 'z' instead of 'y':
   draw(surface(x,x*x,y),x=0..5,z=0..3)
axiom responds with
Loading .... opensus/algebra/PALETTE.o for domain Palette
Unrecoverable error: Segmentation violation.

)set function compile off
   draw(surface(x,x*x,y),x=0..5,z=0..3)
generates 
 >> System error:
 The variable |y| is unbound.

=========================================================================

bug 7194: .fn files are not used during first compile phase

should be loaded from previous build cache into compile image?

=========================================================================

bug 7193: src/algebra/*.pamphlet files are not copied.

=========================================================================

7190: integrate(sqrt(1+sec(x)),x) returns 0

MMA returns a huge expression
Bug poster claims the Maple and cacl101.com return closed forms

=========================================================================

bug 7189: browsing 'eigenMatrix' works only with 'Operations'
Michael Becker <Michael.Becker@coconet.de>

=========================================================================

bug 7188: hyperdoc browsing with wildcards does not work
Michael Becker <Michael.Becker@coconet.de>

=========================================================================

bug 7187: hyperdoc cat* bug
Michael Becker <Michael.Becker@coconet.de>

Entering 'cat*' in the input area of 'Glossary' gives:
'no glossary items match d*'

=========================================================================

bug 7186: ACPLOT missing functions

sketch:=makeSketch(x+y,x,y,-1/2..1/2,-1/2..1/2)$ACPLOT
xRange(sketch)
   Internal Error
   The function xRange with signature hashcode is missing from domain 
      PlaneAlgebraicCurvePlot 
yRange(sketch)
   Internal Error
   The function yRange with signature hashcode is missing from domain 
      PlaneAlgebraicCurvePlot 


=========================================================================

bug 7181: SQMATRIX(2,INT) has coerce Integer -> %

  is not a valid type

even if:

)expose SQMATRIX

=========================================================================

bug 7169: Matrix printing/parsing bug (notice the - in E21)

E21:=matrix([[1,0,0],[-2,1,-],[0,0,1]])

        + 1   0  0+
        |         |
   (6)  |- 2  1  -|
        |         |
        + 0   0  1+
                                              Type: Matrix Polynomial Integer
(7) -> E32:=matrix([[1,0,0],[0,1,0],[0,-5,1]])

        +1   0   0+
        |         |
   (7)  |0   1   0|
        |         |
        +0  - 5  1+
                                                         Type: Matrix Integer
(8) -> E32*E21

        + 1    0      0    +
        |                  |
   (8)  |- 2   1      -    |
        |                  |
        +10   - 5  - 5- + 1+
                                              Type: Matrix Polynomial Integer
(9) -> 
=========================================================================

todo 322: use charts.jpg to guide axiom graphing

=========================================================================

todo 321: try to use raphael to scale graphs

=========================================================================

todo 320: pick up FLINT package

=========================================================================

bug 7169: algebra bug

)co RESLATC

RESLATC;coerce;ES;2 is replaced by errorBug: 
  Should not be able to obtain value of type Exit 

=========================================================================

bug 7167: KeyedAccessFile fails because

 (a) readable? in defstream is checking the directory name, not the file
 (b) BINARY_OPEN_INPUT does not exist

=========================================================================

bug 7166: library doesn't seem to work

stuff := library "/tmp/Neat.stuff"
stuff.int    := 32**2
stuff."poly" := x**2 + 1
stuff.str    := "Hello"
keys stuff
stuff.poly
stuff("poly")
)system rm -rf /tmp/Neat.stuff

=========================================================================

bug 7165: this rule does not match

--S
sininv:=rule(sin(%i*x) == %i*sinh(x))
--R
--R   (1)  sin(%i x) == %i sinh(x)
--R        Type: RewriteRule(Integer,Complex Integer,Expression Complex Integer)
--E

--S
t1:=sin(x*%i) - %i*sinh(x)
--R
--R   (2)  - %i sinh(x) + sin(%i x)
--R                                             Type: Expression Complex Integer
--E

--S
t2:=sininv t1
--R
--R   (3)  - %i sinh(x) + sin(%i x)
--R                                             Type: Expression Complex Integer
--E

(1) -> cosinv:=rule(cos(x*%i) == cosh(x))
(2) -> t1:=cos(x*%i) - cosh(x)
(3) -> t2:=cosinv t1

(1) -> taninv:=rule(tan(x*%i) == %i*tanh(x))
(2) -> t1:=tan(x*%i) - %i*tanh(x)
(3) -> t2:=taninv t1

(1) -> cscinv:=rule(csc(x*%i) == -%i*csch(x))
(2) -> t1:=csc(x*%i) - -%i*csch(x)
(3) -> t2:=cscinv t1

(1) -> secinv:=rule(sec(x*%i) == sech(x))
(2) -> t1:=sec(x*%i) - sech(x)
(3) -> t2:=secinv t1

(1) -> cotinv:=rule(cot(x*%i) == -%i*coth(x))
(2) -> t1:=cot(x*%i) - -%i*coth(x)
(3) -> t2:=cotinv t1

(1) -> sinhinv:=rule(sinh(x*%i) == %i*sin(x))
(2) -> t1:=sinh(x*%i) - %i*sin(x)
(3) -> t2:=sinhinv t1

(1) -> coshinv:=rule(cosh(x*%i) == cos(x))
(2) -> t1:=cosh(x*%i) - cos(x)
(3) -> t2:=coshinv t1

(1) -> tanhinv:=rule(tanh(x*%i) == %i*tan(x))
(2) -> t1:=tanh(x*%i) - %i*tan(x)
(3) -> t2:=tanhinv t1

(1) -> cschinv:=rule(x*%i == -%i*csc(x))
(2) -> t1:=x*%i - -%i*csc(x)
(3) -> t2:=cschinv t1

(1) -> sechinv:=rule(sech(x*i) == sec(x))
(2) -> t1:=sech(x*i) - sec(x)
(3) -> t2:=sechinv t1

(1) -> cothinv:=rule(coth(x*%i) == -%i*cot(x))
(2) -> t1:=coth(x*%i) - -%i*cot(x)
(3) -> t2:=cothinv t1

(1) -> coshperiod:=rule(cosh(x+2*k*%pi*%i) == cosh(x))
(2) -> t1:=cosh(x+2*k*%pi*%i) - cosh(x)
(3) -> t2:=coshperiod t1

(1) -> tanhperiod:=rule(tanh(x+k*%pi*%i) == tanh(x))
(2) -> t1:=tanh(x+k*%pi*%i) - tanh(x)
(3) -> t2:=tanhperiod t1

(1) -> sechperiod:=rule(sech(x+2*k*%pi*%i) == sech(x))
(2) -> t1:=sech(x+2*k*%pi*%i) - sech(x)
(3) -> t2:=sechperiod t1

(1) -> sinsinh:=rule(sin(%i*x)^(-1) == %i*sinh(x)^(-1))
(2) -> t1:=sin(%i*x)^(-1) - %i*sinh(x)^(-1)
(3) -> t2:=sinsinh t1

(1) -> sinhsin:=rule(sinh(%i*x)^(-1) == %i*sin(x)^(-1))
(2) -> t1:=sinh(%i*x)^(-1) - %i*sin(x)^(-1)
(3) -> t2:=sinhsin t1

(1) -> coscosh:=rule(cos(x)^(-1) == %i*cosh(x)^(-1))
(2) -> t1:=cos(x)^(-1) - %i*cosh(x)^(-1)
(3) -> t2:=coscosh t1

(1) -> coscosh2:=rule(cos(x)^(-1) == -%i*cosh(x)^(-1))
(2) -> t1:=cos(x)^(-1) - -%i*cosh(x)^(-1)
(3) -> t2:=coscosh2 t1

(1) -> coshcos:=rule(cosh(x)^(-1) == %i*cos(x)^(-1))
(2) -> t1:=cosh(x)^(-1) - %i*cos(x)^(-1)
(3) -> t2:=coshcos t1

(1) -> coshcos2:=rule(cosh(x)^(-1) == -%i*cos(x)^(-1))
(2) -> t1:=cosh(x)^(-1) - -%i*cos(x)^(-1)
(3) -> t2:=coshcos2 t1

(1) -> tantanh:=rule(tan(%i*x)^(-1) == %i*tanh(x)^(-1))
(2) -> t1:=tan(%i*x)^(-1) - %i*tanh(x)^(-1)
(3) -> t2:=tantanh t1

(1) -> tanhtan:=rule(tanh(%i*x)^(-1) == %i*tan(x)^(-1))
(2) -> t1:=tanh(%i*x)^(-1) - %i*tan(x)^(-1)
(3) -> t2:=tanhtan t1

=========================================================================

bug 7164: this rule does not match

--S
cschinv:=rule(csch(x)^(-1) == sinh(1/x)^(-1))
--R
--R           1          1
--R   (1)  ------- == -------
--R        csch(x)         1
--R                   sinh(-)
--R                        x
--R                        Type: RewriteRule(Integer,Integer,Expression Integer)
--E

--S
t1:=csch(x)^(-1) - sinh(1/x)^(-1)
--R
--R             1
--R        sinh(-) - csch(x)
--R             x
--R   (2)  -----------------
--R                      1
--R          csch(x)sinh(-)
--R                      x
--R                                                     Type: Expression Integer
--E

--S
t2:=cschinv t1
--R
--R             1
--R        sinh(-) - csch(x)
--R             x
--R   (3)  -----------------
--R                      1
--R          csch(x)sinh(-)
--R                      x
--R                                                     Type: Expression Integer
--E

=========================================================================

bug 7163: tanhneg rule fails

The first 5 succeed, but the 6th (tanhneg t3) loops forever

(1) -> tanhadd:=rule(tanh(x+y) == (tanh(x)+tanh(y))/(1+tanh(x)*tanh(y)))
(2) -> t1:=tanh(x+y) - (tanh(x)+tanh(y))/(1+tanh(x)*tanh(y))
(3) -> t2:=tanhadd t1
(4) -> tanhneg:=rule(tanh(x-y) == (tanh(x)-tanh(y))/(1-tanh(x)*tanh(y)))
(5) -> t3:=tanh(x-y) - (tanh(x)-tanh(y))/(1-tanh(x)*tanh(y))
(6) -> t4:=tanhneg t3

(1) -> cothadd:=rule(coth(x+y) == (coth(x)*coth(y)+1)/(coth(y)+coth(x)))
(2) -> t1:=coth(x+y) - (coth(x)*coth(y)+1)/(coth(y)+coth(x))
(3) -> t2:=cothadd t1
(4) -> cothneg:=rule(coth(x-y) == (coth(x)*coth(y)-1)/(coth(y)-coth(x)))
(5) -> t3:=coth(x-y) - (coth(x)*coth(y)-1)/(coth(y)-coth(x))
(6) -> t4:=cothneg t3

=========================================================================

bug 7162: (p,q):UP(x,INT) fails only in fixed.input.pamphlet

p:UnivariatePolynomial(x,Integer); q:UnivariatePolynomial(x,Integer)
                                                                   Type: Void
 
 
Daly Bug
   Category, domain or package constructor : is not available.


The expression

  (p,q):UP(x,INT)

generates the error

Daly Bug
   Category, domain or package constructor : is not available.

works fine at the top of the fixed.input file but not further down. 
Which means that some property is not being cleared properly. 
The symbol ``p'' does get properly declared despite the error message.

=========================================================================

bug 7160: numeric(erf(0.1))

the erf function is defined as:

erf(x) == 1/sqrt(2*%pi)*integrate(exp(-1/2*t^2),t=0..x) 

ref: CRC Standard Mathematical Tables and Formulae p547

=========================================================================

bug 7159: rootsOf(2*z^4+z^3-z-2) is wrong

   (1)  [%z0,%z1,%z1,- %z1]
                                                   Type: List AlgebraicNumber

(2) -> (z^2-1)*(2*z^2+z+2)

          4    3
   (2)  2z  + z  - z - 2
                                                     Type: Polynomial Integer
(3) -> rootsOf(z^2-1)

   (3)  [%z3,- %z3]
                                                   Type: List AlgebraicNumber
(4) -> rootsOf(2*z^2+z+2)

             - 2%z5 - 1
   (4)  [%z5,----------]
                  2
                                                   Type: List AlgebraicNumber
so no two roots are equal

(5) -> f(z)==(z^2-1)*(2*z^2+z+2)
                                                                   Type: Void
(6) -> m1:=%%(3).1

   (6)  %z3
                                                        Type: AlgebraicNumber
(7) -> m2:=%%(3).2

   (7)  - %z3
                                                        Type: AlgebraicNumber
(8) -> m3:=%%(4).1

   (8)  %z5
                                                        Type: AlgebraicNumber
(9) -> m4:=%%(4).2

        - 2%z5 - 1
   (9)  ----------
             2
                                                        Type: AlgebraicNumber
(10) -> f(m1)
   Compiling function f with type AlgebraicNumber -> AlgebraicNumber 

   (10)  0
                                                        Type: AlgebraicNumber
(11) -> f(m2)

   (11)  0
                                                        Type: AlgebraicNumber
(12) -> f(m3)

   (12)  0
                                                        Type: AlgebraicNumber
(13) -> f(m4)

   (13)  0
                                                        Type: AlgebraicNumber
(14) -> n1:=%%(1).1

   (14)  %z0
                                                        Type: AlgebraicNumber
(15) -> n2:=%%(1).2

   (15)  %z1
                                                        Type: AlgebraicNumber
(16) -> n3:=%%(1).3

   (16)  %z1
                                                        Type: AlgebraicNumber
(17) -> n4:=$$(1).4
 
   Category, domain or package constructor 1 is not available.
(17) -> n4:=%%(1).4

   (17)  - %z1
                                                        Type: AlgebraicNumber
(18) -> f(n1)

   (18)  0
                                                        Type: AlgebraicNumber
(19) -> f(n2)

   (19)  0
                                                        Type: AlgebraicNumber
(20) -> f(n3)

   (20)  0
                                                        Type: AlgebraicNumber
(21) -> f(n4)

                      2        2                     3      2
   (21)  (2%z0 + 1)%z1  + (2%z0  + %z0 + 2)%z1 + 2%z0  + %z0  - 1
                                                        Type: AlgebraicNumber

so %%(1).4 is not a root?


rootsOf(2*z^4  + z^3  - z - 2) wrong
rootsOf(2*z^4  + z^3  - z - 2, z) correct
rootsOf(z^4  + z^3  + z - 1) wrong
rootsOf(z^4  + z^3  + z - 1,z) correct


Sat 22 May 2004 01:48:36 PM GMT, comment #1:

Maybe I should have added why rootsOf(2*z^4 + z^3 - z - 2) is wrong:
2z^4+z^3-z-2=(z^2-1)(2*z^2+z+2),
thus no two roots are equal, contrary to axioms result.

Martin
	Martin Rubey <kratt6>


Wed 10 Mar 2004 09:06:43 AM GMT, original submission:

a fresh Axiom says

(1) -> rootsOf(2*z^4 + z^3 - z - 2,z)

- 2%z2 - 2%z1 - 2%z0 - 1
(1) [%z0,%z1,%z2,------------------------]
2
Type: List Expression Integer

(2) -> rootsOf(2*z^4 + z^3 - z - 2)

(2) [%z4,%z5,%z5,- %z5]
Type: List AlgebraicNumber

which is wrong.

Same thing for zerosOf, same thing for z^4+z^3+z-1

=========================================================================

bug 7158: patch #3127 is wrong fix

currently Axiom gives:

product(summation(i*j,i=a..b),j=c..d)

          d     b
        ++-++  --+
   (1)   | |   >     i j
         | |   --+
        j= c   i= a
                                                     Type: Expression Integer

but NAG version gives

      b        d - c + 1
     --+      2
     >       i
     --+
     i=a

=========================================================================

bug 7157: 0::CARD^0::CARD should be 1?

(1) -> 0::CARD

   (1)  0
                                                         Type: CardinalNumber
(2) -> 0::CARD^0::CARD
 
   >> Error detected within library code:
   0**0 not defined for cardinal numbers.

(2) -> complex(0,0)^complex(0,0.0)
 
   >> Error detected within library code:
   log 0 generated

(2) -> complex(0,0)^complex(2,2.0)
 
   >> Error detected within library code:
   log 0 generated

(2) -> 

=========================================================================

bug 7156: nonsense result

(1) -> matrix([[0,0],[0,0]])^0.1

   (1)  0.0
                                                                  Type: Float
(2) -> matrix([[0,0],[0,0]])^x

         x
   (2)  0
                                                     Type: Expression Integer

(3) -> matrix([[0,0],[0,1]])^0.1
   There are 4 exposed and 0 unexposed library operations named ^ 
      having 2 argument(s) but none was determined to be applicable. 
      Use HyperDoc Browse, or issue
                                )display op ^
      to learn more about the available operations. Perhaps 
      package-calling the operation or using coercions on the arguments
      will allow you to apply the operation.
 
   Cannot find a definition or applicable library operation named ^ 
      with argument type(s) 
                               Matrix Integer
                                    Float
      
      Perhaps you should use "@" to indicate the required return type, 
      or "$" to specify which version of the function you need.
(3) -> matrix([[0,0],[0,1]])^x
   There are 4 exposed and 0 unexposed library operations named ^ 
      having 2 argument(s) but none was determined to be applicable. 
      Use HyperDoc Browse, or issue
                                )display op ^
      to learn more about the available operations. Perhaps 
      package-calling the operation or using coercions on the arguments
      will allow you to apply the operation.
 
   Cannot find a definition or applicable library operation named ^ 
      with argument type(s) 
                               Matrix Integer
                                 Variable x
      
      Perhaps you should use "@" to indicate the required return type, 
      or "$" to specify which version of the function you need.

=========================================================================

bug 7155: fatal error

(1) -> a:=series sin(x)
   Loading /research2/test/mnt/fedora5/algebra/EXPR2UPS.o for package 
      ExpressionToUnivariatePowerSeries 

            1  3    1   5     1   7      1    9       1     11      12
   (1)  x - - x  + --- x  - ---- x  + ------ x  - -------- x   + O(x  )
            6      120      5040      362880      39916800
                        Type: UnivariatePuiseuxSeries(Expression Integer,x,0)
(2) -> a*1.0
   Loading /research2/test/mnt/fedora5/algebra/EXPR2.o for package 
      ExpressionFunctions2 
 
   >> System error:
   Caught fatal error [memory may be damaged]


=========================================================================

bug 7154: strange handling of args outside -%pi/2 < x < $pi/2

(1) -> atan(tan(3))

   (1)  3
                                                     Type: Expression Integer
(2) -> atan(tan(3.0))

   (2)  - 0.1415926535 8979323846
                                                                  Type: Float
(3) -> atan(tan(1))

   (3)  1
                                                     Type: Expression Integer
(4) -> atan(tan(1.0))

   (4)  1.0
                                                                  Type: Float
=========================================================================

bug 7153: division by zero due to definition problem

asin(complex(1.0,0.0))
>> Error detected within library code:
   catdef: division by zero


trigcat.spad.pamphlet => 
asin x == atan(x/sqrt(1-x**2))


asin(1.0) => %pi/2.0
but not for Complex(Float) 

=========================================================================

bug 7152: integration bug

integrate((1/x)::UTS(FRAC POLY INT, x, 0),x)
integrate((1/y)::UTS(FRAC POLY INT, x, 0),z)

The first bug is an indication that 1/x should not be of type 
UTS(x,FRAC POLY INT), UP(x, FRAC POLY INT) and so on. The second is an
indication that QFCAT should have a function variables: % -> List
Symbol.

Sat 02 Oct 2004 12:09:22 PM GMT, comment #2:

I disagree with the previous comment; x should be captured and not
allowed in the FRAC POLY INT. (I agree that the second example in the
original report is not a bug.)

But surely we can all agree that 
integrate((1/x)::ULS(FRAC POLY INT,x, 0),x) 
is a bug? The problem is the same: the 1/x is being treated
in the coefficient domain. Note that 
integrate(1/(x::ULS(FRAC POLYINT, x, 0)),x) 
produces a correct result.

Dylan (dpt@math.harvard.edu)

Sat 02 Oct 2004 08:33:01 AM GMT, comment #1:

Neither of these is a bug. In the first one, Axiom coerced 1/x into
FRAC POLY INT correctly: the only / operation available in UTS is one
induced from the coefficient domain, which requires the denominator to
be in the coefficient domain, and the division is done termwise to the
coefficients of the series. So 1/x ends up in FRAC POLY INT. Note that
to obtain a Taylor series at x = 0 is mathematically is wrong, since
1/x is not defined at x=0. Also the way to obtain a Taylor series is
taylor(func, x=a). If you do integrate(taylor(1/x,x=1),x), that would
cause no problems. Note that the domain of this command is UTS(EXPR
INT, x,1), so such towers are valid and necessary in Axiom. Note also
there are only two exported[coerce] in UTS and they do NOT apply to
1/x. The x in UTS is like the x in UP and is different from the x in
FRAC POLY INT. The representation is Stream Coef (no variable
specified because it is univariate).

For the same reason, in the second command, 1/y is correctly coerced
into FRAC POLY INT. However, in UTS(,x,), the only integrations
allowed are with respect to x. If you want to do integration in 
FRAC POLY INT, then you should do so without coercing 1/y into UTS.

So your examples do not illustrate the problem about mixed up
variables. In fact, it supports use of towers like UTS(EXPR INT, x,a).

William (wyscc@cunyvm.cuny.edu)

Sat 11 Sep 2004 12:34:23 PM GMT, original submission:

integrate((1/x)::UTS(FRAC POLY INT, x, 0),x)

1
(11) - x
x
Type: UnivariateTaylorSeries(Fraction Polynomial Integer,x,0)

integrate((1/y)::UTS(FRAC POLY INT, x, 0),z)

Cannot find a definition or applicable library operation named
integrate with argument type(s)
UnivariateTaylorSeries(Fraction Polynomial Integer,x,0)
Variable z


=========================================================================

bug 7151: bind stack overflow

(1) -> ?::Symbol

   (1)  ?
                                                                 Type: Symbol
(2) -> ?::Symbol::SAOS
 
   >> System error:
   Bind stack overflow.

(2) -> x::Symbol::SAOS

   (2)  "?"
                                                  Type: SingletonAsOrderedSet

=========================================================================

bug 7150: exquo cannot detect zero equivalence?

gcd((A-2^a)::UP(A,EXPR INT),(A^2-2^(2*a))::UP(A,EXPR INT))

Cause:
In EXPR INT, 2^a and 2^(2*a) are treated as two variables without
relatoins in EXPR INT. Therefore exquo in
gcdPrimitive(p1:SUPP,p2:SUPP)$PGCD fails.


(+) Discussion
Thu 30 Sep 2004 09:31:59 AM GMT, comment #3:

>> Sorry, this is not correct. It is in FIELD (for EXPR INT)

Excuse me, I was to quick again. Here is the (hopefully correct) anaylysis:

exquo(simplify((A-2^a)*(A+2^a))::UP(A,EXPR INT),(A-2^a)::UP(A,EXPR INT))

calls exquo$SUP(EXPR INT). This implements exact division of
polynomials p1 by p2 as usual. After each subtraction - done via
fmecg$SUP - the result is again stored in p1. exquo terminates when p1
is the empty list - note that SUPs are stored as lists of pairs
(degree, coefficient) - or the degree of p2 is larger than p1. In the
latter case, exquo fails.

Thus, in our case, at one point p1 is 4^a-2^(2*a), which is zero
mathematically, but axiom does not know it. In particular, p1 is not
the empty list, but rather a constant polynomial...

It would be interesting to see how MuPAD or Aldor handle this.
	Martin Rubey <kratt6>

Wed 29 Sep 2004 04:20:16 PM GMT, comment #2:

>> The instance of exquo involved is the one in SMP.

Sorry, this is not correct. It is in FIELD (for EXPR INT)
	Martin Rubey <kratt6>

Wed 29 Sep 2004 04:02:03 PM GMT, comment #1:

I should have added:

(1) -> exquo(normalize(simplify(((A-2^a)*(A+2^a)))::EXPR INT),normalize((A-2^a)::EXPR INT))

a log(4) 2
 %e   - A
(1) ---------------
a log(2)
 %e -   A
Type: Union(Expression Integer,...)

(2) -> exquo(simplify((A-2^a)*(A+2^a))::UP(A,EXPR INT),(A-2^a)::UP(A,EXPR INT))

(2) "failed"
Type: Union("failed",...)

I'm afraid that this cannot be fixed easily, since there is no general
mechanism to determine whether an expression is zero or not, which is
needed in exquo. The instance of exquo involved is the one in SMP.
	Martin Rubey <kratt6>


Wed 29 Sep 2004 03:36:55 PM GMT, original submission:

gcd((x-2^a)::UP(x, EXPR INT), simplify((x-2^a)*(x+2^a))::UP(x, EXPR INT))

gives 1, while the correct answer should be x-2^a, as given by

gcd((x-2^a)::UP(x, EXPR INT),((x-2^a)*(x+2^a))::UP(x, EXPR INT))

A workaround is presented on
http://page.axiom-developer.org/zope/mathaction/EXPR_GCD


=========================================================================

bug 7149: bad choice of signature by interpreter

y x == (1+x)^x/x
                                                                   Type: Void
interpolate(x,[1,2,3],[1/z(i) for i in 1..3])$PINTERP(x,FRAC POLY INT)
   Compiling function y with type PositiveInteger -> Polynomial Integer
      
   Conversion failed in the compiled user function y .
   Loading /research2/test/mnt/fedora5/algebra/UNISEG.o for domain 
      UniversalSegment 
 
   Cannot convert from type Float to Polynomial Integer for value
   4.5

y(2)
   Conversion failed in the compiled user function y .
 
   Cannot convert from type Float to Polynomial Integer for value
   4.5


HOWEVER:

z(x) == (1+x)^x/x
                                                                   Type: Void
z(2)
   Compiling function z with type PositiveInteger -> Fraction Integer 

        9
   (3)  -
        2
                                                       Type: Fraction Integer
interpolate(x,[1,2,3],[1/z(i) for i in 1..3])$PINTERP(x,FRAC POLY INT)

         59   2    497     169
   (4)  ---- x  - ---- x + ---
        1152      1152     192
                    Type: UnivariatePolynomial(x,Fraction Polynomial Integer)

)clear all

y(x:PositiveInteger):Fraction(Integer) == (1+x)^x/x
   Function declaration y : PositiveInteger -> Fraction Integer has 
      been added to workspace.
                                                                   Type: Void
interpolate(x,[1,2,3],[1/y(i) for i in 1..3])$PINTERP(x,FRAC POLY INT)
   Compiling function y with type PositiveInteger -> Fraction Integer 

         59   2    497     169
   (2)  ---- x  - ---- x + ---
        1152      1152     192
                    Type: UnivariatePolynomial(x,Fraction Polynomial Integer)


=========================================================================

bug 7147: integrate(1/(1+x^4),x=%minusInfinity..%plusInfinity)
NOTE: fixed in Fricas prior to fork

returns 0
should return %pi*sqrt(2)/2

integrate(1/(4+x^4),x=%minusInfinity..%plusInfinity)
returns %pi/4
should return %pi/4

integrate(1/(1+x^6),x=%minusInfinity..%plusInfinity) 
returns 0
should return 2*%pi/3

integrate(1/(1+x^2),x=%minusInfinity..%plusInfinity) 
returns %pi
should return %pi

=========================================================================

bug 7145: fxiedPointExquo bug

see: 
http://groups.google.com/group/fricas-commit/browse_thread/thread/1befef363e8c02be?hl=en#

exprode.spad.pamphlet
  opex := operator("exquo"::Symbol)$OP
  opex := operator("fixedPointExquo"::Symbol)$OP


a:=operator 'a
sol:=seriesSolve((2*x-2)*D(a(x),x)+4*a(x),a,x=0,[1])

[coefficient(sol,i) for i in 0..7] = [1,2,3,4,5,6,7,8]?

=========================================================================

todo 319: construct coerce graph

=========================================================================

bug 7144: bug in eval

http://groups.google.com/group/fricas-devel/browse_thread/thread/964c156e5925db15

y:=operator 'y
  (1) y
deq:=differentiate(y x, x) + y x
       '
  (2) y (x) + y(x)
res:=first(solve(deq, y, x).basis)
        - x
  (3) %e
eval(deq, y, x+->res)
        - x
  (4) %e

instead:

y:=operator 'y
  (1) y
deq:=differentiate(y x, x) + y x
       '
  (2) y (x) + y(x)
res:=first(solve(deq, y, x).basis)
        - x
  (3) %e
function(res,f::Symbol,variables(res))
  (4) f
f(1)
       1
  (5) --
      %e
eval(deq,y,f)
  (6) 0

=========================================================================

bug 7143: asq cannot find AHYP

=========================================================================

bug 7142: exp^log(x)

 
   >> System error:
   Cannot take first of an empty list

=========================================================================

todo 318: do a plucker/grassman example


Hi,

The Grassmannian G(d,n) is the set of all d-dimensional subspaces of
k^n. Such a subspace can be represented as a d*n matrix whose d rows
are a basis for the subspace. The d*d minors of this matrix are the
Plucker coordinates for the subspace, which gives an embedding of the
the Grassmannian into projective space.

(For example, a 2-dimensional subspace of k^4 can be represented as a
2*4 matrix, and the minors are the determinants of the 2*2 matrices we
get by taking pairs of columns 12, 13, 14, 23, 24, 34. The values of
these minors can be used for form a point [p12:p13:p14:p23:p24:p34] in
projective 5-space, where pij is the ijth Plucker coordinate.)

It is claimed that the Grassmannian is a variety - in other words, the
zero set of a set of polynomials. How do I go about listing these
polynomials (ie generators for the ideal), in terms of the Plucker
coordinates? (In other words, what relations must hold between the
minors of a matrix, given that the rows are linearly independent?)

(I'm aware that there's a way to think about this in terms of the
exterior algebra, but I'm hoping that there's a more straightforward
way to see it.)

Thanks, David

Daniel Lichtblau   	

Newsgroups: sci.math.symbolic
From: Daniel Lichtblau <d...@wolfram.com>
Date: Wed, 10 Sep 2008 15:05:51 -0700 (PDT)
Local: Wed, Sep 10 2008 6:05 pm
Subject: Re: Defining relations for Grassmannian in Plucker coordinates?
Reply | Reply to author | Forward | Print | Individual message | Show original | Report this message | Find messages by this author
On Sep 10, 3:56 pm, DavidA <polyom...@f2s.com> wrote:

- Hide quoted text -
- Show quoted text -
> Hi,

> The Grassmannian G(d,n) is the set of all d-dimensional subspaces of
> k^n. Such a subspace can be represented as a d*n matrix whose d rows
> are a basis for the subspace. The d*d minors of this matrix are the
> Plucker coordinates for the subspace, which gives an embedding of the
> the Grassmannian into projective space.

> (For example, a 2-dimensional subspace of k^4 can be represented as a
> 2*4 matrix, and the minors are the determinants of the 2*2 matrices we
> get by taking pairs of columns 12, 13, 14, 23, 24, 34. The values of
> these minors can be used for form a point [p12:p13:p14:p23:p24:p34] in
> projective 5-space, where pij is the ijth Plucker coordinate.)

> It is claimed that the Grassmannian is a variety - in other words, the
> zero set of a set of polynomials. How do I go about listing these
> polynomials (ie generators for the ideal), in terms of the Plucker
> coordinates? (In other words, what relations must hold between the
> minors of a matrix, given that the rows are linearly independent?)

> (I'm aware that there's a way to think about this in terms of the
> exterior algebra, but I'm hoping that there's a more straightforward
> way to see it.)

> Thanks, David

I don't know if this helps, but such a generating set can be computed
explicitly for fixed (d,n). One uses an elimination order on
polynomials of the form {y1-p1,y2-p2,...} and the result comprises
polynomial relations between the yj.

Here is code for this in Mathematica. It is simple enough that it
should not be too hard to translate to other languages if so desired
(I mean by you; I do not intend to do that).

relationsGrassman[dims_List] := Module[
  {x, xmat, y, yvars, pcoords},
  xmat = Array[x,dims];
  pcoords = First[Minors[xmat,dims[[1]]]];
  yvars = Array[y,Length[pcoords]];
  GroebnerBasis[yvars-pcoords, yvars,
    Flatten[xmat], MonomialOrder->EliminationOrder]
  ]

In[5]:= relationsGrassman[{2,4}]
Out[5]= {y$19[3] y$19[4] - y$19[2] y$19[5] + y$19[1] y$19[6]}

In[6]:= relationsGrassman[{2,5}]
Out[6]= {y$20[7] y$20[8] - y$20[6] y$20[9] + y$20[5] y$20[10],
    y$20[4] y$20[8] - y$20[3] y$20[9] + y$20[2] y$20[10],
    y$20[4] y$20[6] - y$20[3] y$20[7] + y$20[1] y$20[10],
    y$20[4] y$20[5] - y$20[2] y$20[7] + y$20[1] y$20[9],
    y$20[3] y$20[5] - y$20[2] y$20[6] + y$20[1] y$20[8]}

I note that use of Minors probably changes ordering of the p_jk minors
from what you have in mind, so the order of the y variables would need
to be altered accordingly.

Daniel Lichtblau
Wolfram Research

		
David L. Johnson   	

	 More options Sep 10, 10:37 pm
Newsgroups: sci.math.symbolic
From: "David L. Johnson" <david.john...@lehigh.edu>
Date: Wed, 10 Sep 2008 22:37:18 -0400
Local: Wed, Sep 10 2008 10:37 pm
Subject: Re: Defining relations for Grassmannian in Plucker coordinates?
Reply | Reply to author | Forward | Print | Individual message | Show original | Report this message | Find messages by this author

- Hide quoted text -
- Show quoted text -
DavidA wrote:
> Hi,

> The Grassmannian G(d,n) is the set of all d-dimensional subspaces of
> k^n. Such a subspace can be represented as a d*n matrix whose d rows
> are a basis for the subspace. The d*d minors of this matrix are the
> Plucker coordinates for the subspace, which gives an embedding of the
> the Grassmannian into projective space.

> (For example, a 2-dimensional subspace of k^4 can be represented as a
> 2*4 matrix, and the minors are the determinants of the 2*2 matrices we
> get by taking pairs of columns 12, 13, 14, 23, 24, 34. The values of
> these minors can be used for form a point [p12:p13:p14:p23:p24:p34] in
> projective 5-space, where pij is the ijth Plucker coordinate.)

> It is claimed that the Grassmannian is a variety - in other words, the
> zero set of a set of polynomials. How do I go about listing these
> polynomials (ie generators for the ideal), in terms of the Plucker
> coordinates? (In other words, what relations must hold between the
> minors of a matrix, given that the rows are linearly independent?)

> (I'm aware that there's a way to think about this in terms of the
> exterior algebra, but I'm hoping that there's a more straightforward
> way to see it.)

Well, that is what I was going to mention.  It is also the source of the
Pluecker coordinates.  A k-plane in R^n is a unit, decomposable k-vector
in \Lambda_k (R^n).  For G(2,n), the relationship is simpler than for
larger subspace dimensions, because a bivector \xi \in \Lambda_2 (R^n)
is decomposable if and only if \xi \wedge \xi = 0.  You can then write
that out explicitly as equations in the coordinates in \Lambda_2 (R^n),
and they will be quadratics.  For k>2, certainly \xi \wedge \xi =0, but
that is not sufficient for \xi to be decomposable.  Instead, the kernel
of the map R^n --> \Lambda_(k+1) (R^n) given by v --> \xi \wedge v  has
to be k-dimensional, but that still is polynomial in the coordinates.

 From that description, though, it is not clear that G(2,n) is smooth,
and of the right dimension, since it is not a complete intersection, but
of course it is.

-- 

David L. Johnson

When you are up to your ass in alligators, it's hard to remember that
your initial objective was to drain the swamp.
                -- LBJ

		
DavidA   	

	 More options Sep 11, 8:55 am
Newsgroups: sci.math.symbolic
From: DavidA <polyom...@f2s.com>
Date: Thu, 11 Sep 2008 05:55:51 -0700 (PDT)
Local: Thurs, Sep 11 2008 8:55 am
Subject: Re: Defining relations for Grassmannian in Plucker coordinates?
Reply | Reply to author | Forward | Print | Individual message | Show original | Report this message | Find messages by this author
Ah yes, thanks, that should have been obvious.

However, that still leaves a couple of questions:

- Clearly the Grassmannian is contained in the zero-set of those
relations, but how do we know that they coincide? That is, how do we
know that there aren't other zeroes of those relations, which are not
the image of a d*n matrix under the Pluecker embedding.

- Is there any way we could have written down the relations a priori,
without Groebner basis computations (and without exterior algebra)?

		
David L. Johnson   	

	 More options Sep 11, 10:45 am
Newsgroups: sci.math.symbolic
From: "David L. Johnson" <david.john...@lehigh.edu>
Date: Thu, 11 Sep 2008 10:45:21 -0400
Local: Thurs, Sep 11 2008 10:45 am
Subject: Re: Defining relations for Grassmannian in Plucker coordinates?
Reply | Reply to author | Forward | Print | Individual message | Show original | Report this message | Find messages by this author

DavidA wrote:
> Ah yes, thanks, that should have been obvious.

> However, that still leaves a couple of questions:

> - Clearly the Grassmannian is contained in the zero-set of those
> relations, but how do we know that they coincide? That is, how do we
> know that there aren't other zeroes of those relations, which are not
> the image of a d*n matrix under the Pluecker embedding.

Because of the nature of the Pluecker embedding.  These coordinates are
  only the exterior algebra with respect to an explicit basis.  In
particular, as Lichtblau wrote, in the case of 2-planes, the condition
\xi \wedge \xi = 0 is exactly equivalent to \xi being decomposable, \xi
= v \wedge w.  In higher dimensions the conditions are more complicated,
but nevertheless completely describe the Grassmannian.

> - Is there any way we could have written down the relations a priori,
> without Groebner basis computations (and without exterior algebra)?

I can't imagine it, but I also can't imagine why you would want it.
Exterior algebra is the natural setting for this question.  For the
price of making sense of the mechanics, it clarifies exactly these
relationships and makes clear what the relations are.

-- 

David L. Johnson

Some people used to claim that, if enough monkeys sat in front of
enough typewriters and typed long enough, eventually one of them would
reproduce the collected works of Shakespeare.  The internet has
proven this not to be the case.

		
DavidA   	

	 More options Sep 11, 4:14 pm
Newsgroups: sci.math.symbolic
From: DavidA <polyom...@f2s.com>
Date: Thu, 11 Sep 2008 13:14:36 -0700 (PDT)
Local: Thurs, Sep 11 2008 4:14 pm
Subject: Re: Defining relations for Grassmannian in Plucker coordinates?
Reply | Reply to author | Forward | Print | Individual message | Show original | Report this message | Find messages by this author
Perhaps the problem is that I don't understand the connection between
the exterior algebra description of the Grassmannian and the Plucker
coordinates (matrix minors) description. Please can someone spell it
out.

		
Maarten Bergvelt   	

	 More options Sep 11, 4:35 pm
Newsgroups: sci.math.symbolic
From: Maarten Bergvelt <be...@math.uiuc.edu>
Date: Thu, 11 Sep 2008 20:35:47 +0000 (UTC)
Local: Thurs, Sep 11 2008 4:35 pm
Subject: Re: Defining relations for Grassmannian in Plucker coordinates?
Reply | Reply to author | Forward | Print | Individual message | Show original | Report this message | Find messages by this author
On 2008-09-11, DavidA <polyom...@f2s.com> wrote:

> Perhaps the problem is that I don't understand the connection between
> the exterior algebra description of the Grassmannian and the Plucker
> coordinates (matrix minors) description. Please can someone spell it
> out.

The matrix minors are the coefficients of the exterior products
of the basis elements.

So let v, w be vectors in C^4, and consider the
wedge product v^w. It can be expanded in terms of the standard basis
e_i^e_j, for i<j of the second exterior power of C^4, where e_i are
the standard basis vectors of C^4. Just write it
out and you will see the 2x2 minors appear. In some detail:
v=v_1e_1+v_2e_2+v_3e_3+v_4e_4, w=w_1e_1+w_2e_2+w_3e_3+w_4e_4,
so
v^w=(v_1w_2-v_2w_1) e_1^e_2 + ......

The pattern still holds for k vectors in C^n.

Hope that helps.
-- 
Maarten Bergvelt                 

=========================================================================

todo 317: update INFORM notes

PRETTYPRINT((matrix [[1,2],[3,4]])::INFORM)$Lisp

=========================================================================

todo 316: CircularList domain

make a new CircularList domain that handles length (#) properly.
Move the destructive operations out of list and into here.

=========================================================================

bug 7140: this returns the wrong answers

p:=(x:EXPR(INT)):EXPR(INT)+->3*x
q:=(x:EXPR(INT)):EXPR(INT)+->2*x+3
(p+q)(4) => 23     (correct)
(p+q)(x) => 5x + 3 (correct)
(p-q)(4) => 1      (correct)
(p-q)(x) => x-3    (correct)
(p*q)(4) => 33     (wrong)
(p*q)(x) => 6x+9   (wrong)

\section{package FUNMAPS FunctionMaps}
<<package FUNMAPS FunctionMaps>>=
)abbrev package FUNMAPS FunctionMaps
++ Description: Functional composition
++ Given functions f and g, returns the function composition (f op g)
FunctionMaps(A:SetCategory, B:IntegralDomain): cat == def where
 EXP ==> Expression(Integer)
 cat == with
   "+": (A->B, A->B) -> (A->B) 
        ++ \spad(+) does functional addition
   "-": (A->B, A->B) -> (A->B) 
        ++ \spad(-) does functional addition
   "*": (A->B, A->B) -> (A->B) 
        ++ \spad(*) does functional addition
 def == add
    funcAdd: (A->B, A->B, A) -> B 
    funcSub: (A->B, A->B, A) -> B 
    funcMul: (A->B, A->B, A) -> B 

    funcAdd(g,h,x) == ((g x) + (h x))$B
    funcSub(g,h,x) == ((g x) - (h x))$B
    funcMul(g,h,x) == ((g x) * (h x))$B

    (a:(A -> B))+(b:(A -> B)) == funcAdd(a,b,#1)
    (a:(A -> B))-(b:(A -> B)) == funcSub(a,b,#1)
    (a:(A -> B))*(b:(A -> B)) == funcMul(a,b,#1)

=========================================================================

bug 7139: this crashes Axiom when compiled

\section{package FUNMAPS FunctionMaps}
<<package FUNMAPS FunctionMaps>>=
)abbrev package FUNMAPS FunctionMaps
++ Description: Functional composition
++ Given functions f and g, returns the function composition (f op g)
FunctionMaps(A:SetCategory, B:IntegralDomain): cat == def where
 EXP ==> Expression(Integer)
 cat == with
   "+": (A->B, A->B) -> (A->B) 
        ++ \spad(+) does functional addition
        ++
        ++E f:=(x:INT):INT +-> 3*x
        ++E g:=(x:INT):INT +-> 2*x+3
        ++E (f+g)(4)
   "-": (A->B, A->B) -> (A->B) 
        ++ \spad(+) does functional addition
        ++
        ++E f:=(x:INT):INT +-> 3*x
        ++E g:=(x:INT):INT +-> 2*x+3
        ++E (f-g)(4)
   "*": (A->B, A->B) -> (A->B) 
        ++ \spad(+) does functional addition
        ++
        ++E f:=(x:INT):INT +-> 3*x
        ++E g:=(x:INT):INT +-> 2*x+3
        ++E (f*g)(4)
   "/": (A->EXP, A->EXP) -> (A->EXP)
        ++ \spad(+) does functional addition
        ++
        ++E p:=(x:EXPR(INT)):EXPR(INT)+->3*x
        ++E q:=(x:EXPR(INT)):EXPR(INT)+->2*x+3
        ++E (p/q)(4)
        ++E (p/q)(x)
 def == add
    fab ==> (A -> B)
    faei ==> (A -> Expression(Integer))
    EXP ==> Expression(Integer)

    funcAdd: (A->B, A->B, A) -> B 
    funcSub: (A->B, A->B, A) -> B 
    funcMul: (A->B, A->B, A) -> B 
    funcDiv: (A -> EXP, A -> EXP, A) -> EXP
    funcAdd(g,h,x) == ((g x) + (h x))$B
    funcSub(g,h,x) == ((g x) - (h x))$B
    funcMul(g,h,x) == ((g x) * (h x))$B
    funcDiv(g,h,x) == ((g x) / (h x))$EXP

    (a:fab)+(b:fab) == funcAdd(a,b,#1)
    (a:fab)-(b:fab) == funcSub(a,b,#1)
    (a:fab)*(b:fab) == funcMul(a,b,#1)
    (a:faei)/(b:faei) == funcDiv(a,b,#1)


=========================================================================

bug 7138: unravel in CartesianTensor does not work

n:SquareMatrix(2,Integer):=matrix [[2,3],[0,1]]
tn:CartesianTensor(1,2,Integer):=n
unravel ravel tn

=========================================================================

bug 7137: {}$(List INT)
 
The function SEQ is not implemented in List Integer .

=========================================================================

meh 4: as of aug 2008, changecount/name/percent in changelog

tpd 4485 Tim Daly          82.55
gdr  452 Gabriel Dos Reis   8.31
wxh  216 Waldek Hebisch     3.97
mxm   46 Mark Murray        0.84
wsp   28 Bill Page          0.51
mxr   24 Martin Rubey       0.44
acr   21 Arthur C. Ralfs    0.38
gxv   19 Gregory Vanuxem    0.34
sxw   19 Stephen Wilson     0.34
rhx   13 Ralf Hemmecke      0.23
pab   11 Peter Broadbery    0.20
cxc    8 Christophe Conil   0.01
cxm    8 Camm Maguire       0.01
dxm    8 David Mentre       0.01
mxt    6 Mike Thomas        0.01
fxl    5 Frederic Lehobey   0.00
rxr    5 Renaud Rioboo
cys    4 Chris Yapp
jap    3 Jose Alfredo Portes
jxw    3 Juergen Weiss
mmm    3 Marc Moreno Maza
wys    3 William Sit
axh    2 Antoine Hersen
bmt    2 Barry Trager
bsm    2 Bob McElrath
bxt    2 Baldir Thomas
hoz    2 Humberto Ortiz-Zuazaga
exs    2 Eugene Surowitz
dxh    2 Dan Hatton
mvz    2 Matijs van Zuijlen
rxh    2 Richard Harke
tst    2 Themos Tsikas
axr    1 Anatoly Raportirenko
dpt    1 Dylan Thurston
fxm    1 Francois Maltey
kxo    1 Kostas Oikonomou


=========================================================================

bug 7136: uncommenting --output("") changes behavior (greg vanuxem)

Further investigation shows that it is a bug in PARSE-Conditional

This appears to be a problem only when you have a nested one-armed
if-statement (gaby)

)abb package FOO Foo
Foo(R,VCR): Exports == Implementation where
 R : FloatingPointSystem
 VCR : VectorCategory R
 Exports == with
   bar: (Boolean,VCR) -> Integer
   ++ bar(b,v)
   bad: (Boolean,VCR) -> Integer
   ++ bad(b,v)
 Implementation == add
   import OutputPackage
   bar(b,v)==
    if b then
      --output("")
      for i in minIndex v..maxIndex v repeat
        if v.i <= 0 then return -1
    else
      for i in minIndex.v..maxIndex.v repeat
        v.i:=1
    output(v::OutputForm)
    0

   bad(b,v)==
    if b then
      output("")
      for i in minIndex v..maxIndex v repeat
        if v.i <= 0 then return -1
    else
      for i in minIndex.v..maxIndex.v repeat
        v.i:=1
    output(v::OutputForm)
    0

v:=new(5,0)$Vector(SF)
bar(false,v)
   [0.,0.,0.,0.,0.]

   (7)  0
                                                     Type: NonNegativeInteger
v:=new(5,0)$Vector(SF)
bad(false,v)
   [1.,1.,1.,1.,1.]

   (3)  0


=========================================================================

meh 3: from Bill Page

I just wanted to mention something here that I just learned about how
the Axiom interpreter handles option arguments. When discovering how
the 'draw' operations in Axiom processes optional arguments, e.g.

  draw(sin(x), x=1..10, title=="sin function")

I realized the interpreter does something rather clever but probably
quite unexpected. The problem is that (unlike Aldor) SPAD does not
provide built-in support for calling functions with optional
arguments. Instead what it does is collect all the arguments
containing == into a List *and* then it applies the name to the left
of == as a function to the value on the right. So much to my surprize:

(1) -> (x+->x)(sin==x,cos==y)

   (1)  [sin(x),cos(y)]

                                  Type: List Expression Integer

is equivalent to:

(2) -> (x+->x)([sin(x),cos(y)])

   (2)  [sin(x),cos(y)]

                                   Type: List Expression Integer

The list of optional arguments is always passed as the last argument
to the function. This is completely general so one can write for
example:

(3) -> ((x,y)+->[x,y])(sin==x,n,cos==y)

   (3)  [n,[sin(x),cos(y)]]

                                     Type: List Any

What do you think? Do you like that, or is this something that should
be implemented in a deeper way?



=========================================================================

todo 316: EGADS Evolutionary Gaussian Automatic Decomposition

look at implementing such an algorithm for axiom

=========================================================================

todo 315: missing input files
/research/research/Axiom.NAG/development/int/doc/htex/input

  LAZM3PK.input
  bios.input
  copyright.input
  cover.input
  foreword.input
  intro.input
  redo.input
  sum.input
  tecintro.input
  ug00.input
  ug01.input
  ug02.input
  ug03.input
  ug04.input
  ug05.input
  ug06.input
  ug07.input
  ug08.input
  ug10.input
  ug11.input
  ug12.input
  ug13.input
  ug14.input
  ug15.input
  ug16.input
  ug17.input
  ug18.input
  ug19.input
  ug20.input
  ug21.input

/research/research/Axiom.NAG/development/int/input

  .input.record
  ANNA-ES.input
  CPHelp.input
  HTXAdvPage1.input
  HTXAdvPage2.input
  HTXAdvPage3.input
  HTXAdvPage4.input
  HTXAdvPage5.input
  HTXAdvPage6.input
  HTXAdvTopPage.input
  HTXFormatPage1.input
  HTXFormatPage2.input
  HTXFormatPage3.input
  HTXFormatPage4.input
  HTXFormatPage5.input
  HTXFormatPage6.input
  HTXFormatPage7.input
  HTXFormatPage8.input
  HTXFormatTopPage.input
  HTXIntroPage1.input
  HTXIntroPage2.input
  HTXIntroPage3.input
  HTXIntroTopPage.input
  HTXLinkPage1.input
  HTXLinkPage2.input
  HTXLinkPage3.input
  HTXLinkPage4.input
  HTXLinkPage5.input
  HTXLinkPage6.input
  HTXLinkTopPage.input
  HTXTopPage.input
  HTXTryPage.input
  HTXplay.input
  LAZM3PK.input
  Link.input
  algebra.input
  aspex.input
  basic.input
  bmcat.input
  coverex.input
  exmatrix.input
  expose.input
  gloss.input
  hilbert.input
  hilbert0.input
  hyperdoc.input
  images6a.input
  man0.input
  mapping.input
  matops.input
  nagaux.input
  nagc.input
  nagd.input
  nage.input
  nagf.input
  nagm.input
  nags.input
  nagx.input
  newuser.input
  patch.input
  r2.0_bugs.input
  r2.0a_bugs.input
  r2.1_bugs.input
  r2.1_bugs_big.input
  record.input
  romnum.input
  rootpage.input
  srchkey.input
  topics.input
  type.input
  ug.input
  ug00.input
  ug01.input
  ug02.input
  ug03.input
  ug04.input
  ug05.input
  ug06.input
  ug07.input
  ug08.input
  ug10.input
  ug11.input
  ug12.input
  ug13.input
  ug14.input
  ug15.input
  ug16.input
  ug20.input
  ug21.input
  union.input
  util.input
  xmpexp.input

/research/research/Axiom.NAG/development/int/newpaste/

  ANNA-ES.input
  CPHelp.input
  HTXAdvPage1.input
  HTXAdvPage2.input
  HTXAdvPage3.input
  HTXAdvPage4.input
  HTXAdvPage5.input
  HTXAdvPage6.input
  HTXAdvTopPage.input
  HTXFormatPage1.input
  HTXFormatPage2.input
  HTXFormatPage3.input
  HTXFormatPage4.input
  HTXFormatPage5.input
  HTXFormatPage6.input
  HTXFormatPage7.input
  HTXFormatPage8.input
  HTXFormatTopPage.input
  HTXIntroPage1.input
  HTXIntroPage2.input
  HTXIntroPage3.input
  HTXIntroTopPage.input
  HTXLinkPage1.input
  HTXLinkPage2.input
  HTXLinkPage3.input
  HTXLinkPage4.input
  HTXLinkPage5.input
  HTXLinkPage6.input
  HTXLinkTopPage.input
  HTXTopPage.input
  HTXTryPage.input
  HTXplay.input
  Link.input
  algebra.input
  asug.input
  asug01.input
  asug02.input
  asug03.input
  asug04.input
  asug05.input
  asug06.input
  asug07.input
  asug08.input
  asug0A.input
  asug0B.input
  asug0C.input
  asutil.input
  basic.input
  bmcat.input
  coverex.input
  exmatrix.input
  expose.input
  gloss.input
  hyperdoc.input
  man0.input
  mapping.input
  nagaux.input
  nagc.input
  nagd.input
  nage.input
  nagf.input
  nagm.input
  nags.input
  nagx.input
  newuser.input
  patch.input
  record.input
  redo.input
  rootpage.input
  srchkey.input
  topics.input
  type.input
  ug.input
  ug00.input
  ug01.input
  ug02.input
  ug03.input
  ug04.input
  ug05.input
  ug06.input
  ug07.input
  ug08.input
  ug10.input
  ug11.input
  ug12.input
  ug13.input
  ug14.input
  ug15.input
  ug20.input
  union.input
  util.input
  xmpexp.input

/research/research/Axiom.NAG/development/int/paste/

  ANNA-ES.input
  CPHelp.input
  HTXAdvPage1.input
  HTXAdvPage2.input
  HTXAdvPage3.input
  HTXAdvPage4.input
  HTXAdvPage5.input
  HTXAdvPage6.input
  HTXAdvTopPage.input
  HTXFormatPage1.input
  HTXFormatPage2.input
  HTXFormatPage3.input
  HTXFormatPage4.input
  HTXFormatPage5.input
  HTXFormatPage6.input
  HTXFormatPage7.input
  HTXFormatPage8.input
  HTXFormatTopPage.input
  HTXIntroPage1.input
  HTXIntroPage2.input
  HTXIntroPage3.input
  HTXIntroTopPage.input
  HTXLinkPage1.input
  HTXLinkPage2.input
  HTXLinkPage3.input
  HTXLinkPage4.input
  HTXLinkPage5.input
  HTXLinkPage6.input
  HTXLinkTopPage.input
  HTXTopPage.input
  HTXTryPage.input
  HTXplay.input
  LAZM3PK.input
  Link.input
  algebra.input
  aspex.input
  basic.input
  bmcat.input
  mapping.input
  redo.input
  topics.input
  ug00.input
  ug01.input
  ug02.input
  ug03.input
  ug04.input
  ug05.input
  ug06.input
  ug07.input
  ug08.input
  ug10.input
  ug11.input
  ug12.input
  ug13.input
  ug14.input
  ug15.input
  ug16.input
  ug21.input

/research/research/Axiom.NAG/development/src/algebra_marc

  benchs.input

/research/research/Axiom.NAG/development/src/htex/input.awk

  input.awk
  mktinput.c
  tinput.awk
  tinput.awk.old

/research/research/Axiom.NAG/development/src/input

  as-eg7.input
  hilbert.input
  hilbert0.input
  images6a.input
  matops.input
  romnum.input

/research/research/gold/src/input

  images6a.input.pamphlet

/research/research/integration/src/input

  1.input
  10.input
  100.input
  101.input
  102.input
  103.input
  104.input
  105.input
  106.input
  107.input
  108.input
  109.input
  11.input
  110.input
  111.input
  112.input
  113.input
  114.input
  115.input
  116.input
  117.input
  118.input
  119.input
  12.input
  120.input
  121.input
  122.input
  123.input
  124.input
  125.input
  126.input
  127.input
  128.input
  129.input
  13.input
  130.input
  131.input
  132.input
  133.input
  134.input
  135.input
  136.input
  137.input
  138.input
  139.input
  14.input
  140.input
  141.input
  142.input
  143.input
  144.input
  145.input
  146.input
  147.input
  148.input
  149.input
  15.input
  150.input
  151.input
  152.input
  153.input
  154.input
  155.input
  156.input
  157.input
  158.input
  159.input
  16.input
  160.input
  161.input
  162.input
  163.input
  164.input
  165.input
  166.input
  167.input
  168.input
  169.input
  17.input
  170.input
  171.input
  172.input
  173.input
  174.input
  175.input
  176.input
  177.input
  178.input
  179.input
  18.input
  180.input
  181.input
  182.input
  183.input
  184.input
  185.input
  186.input
  187.input
  188.input
  189.input
  19.input
  190.input
  191.input
  192.input
  193.input
  194.input
  195.input
  196.input
  197.input
  198.input
  199.input
  2.input
  20.input
  200.input
  201.input
  202.input
  203.input
  204.input
  205.input
  206.input
  207.input
  208.input
  209.input
  21.input
  210.input
  211.input
  212.input
  213.input
  214.input
  215.input
  216.input
  217.input
  218.input
  219.input
  22.input
  220.input
  221.input
  222.input
  223.input
  224.input
  225.input
  226.input
  227.input
  228.input
  229.input
  23.input
  230.input
  231.input
  232.input
  24.input
  25.input
  26.input
  27.input
  28.input
  29.input
  3.input
  30.input
  31.input
  32.input
  33.input
  34.input
  35.input
  36.input
  37.input
  38.input
  39.input
  4.input
  40.input
  41.input
  42.input
  43.input
  44.input
  45.input
  46.input
  47.input
  48.input
  49.input
  5.input
  50.input
  51.input
  52.input
  53.input
  54.input
  55.input
  56.input
  57.input
  58.input
  59.input
  6.input
  60.input
  61.input
  62.input
  63.input
  64.input
  65.input
  66.input
  67.input
  68.input
  69.input
  7.input
  70.input
  71.input
  72.input
  73.input
  74.input
  75.input
  76.input
  77.input
  78.input
  79.input
  8.input
  80.input
  81.input
  82.input
  83.input
  84.input
  85.input
  86.input
  87.input
  88.input
  89.input
  9.input
  90.input
  91.input
  92.input
  93.input
  94.input
  95.input
  96.input
  97.input
  98.input
  99.input
  Xinf.input
  Xinfinite.input
  demo.input
  f.input
  foo.input
  foo1.input
  redo.input

/research/research/integration/src/provisos/foo.input

/research/research/journal/bailey/cl-f2cl-1.0+cvs.2002.11.11/packages/minpack/lmdif-input.dat

/research/newdatabase/src/input

  images6a.input.pamphlet

/research/newdatabase

  intparfrac.input.pamphlet
  improper.input.pamphlet
  typeconv.input.pamphlet
  doit.input

/research/axiom/src/input

  xpr.input.pamphlet
  images6a.input.pamphlet

/research/may07/wh-sandbox/src/input

  images6a.input.pamphlet

/research/pending

  improper.input.pamphlet
  intparfrac.input.pamphlet
  ioutput.input.pamphlet
  typeconv.input.pamphlet
  doit.input
  bonda.input
  bug361.input
  expint.input
  r.input

/research/pending/ODE/input

  f.input
  keep/f.input
  keep/kamke10.input
  keep/kamke2a.input
  keep/kamke2.input
  keep/kamke3.input
  keep/kamke4.input
  keep/kamke5.input
  keep/kamke6.input
  keep/kamke7.input
  keep/kamke8.input
  keep/kamke9.input
  keep/k.input
  keep/kamke3a.input
  k.input
  ODES.input
  ODESzero.input
  #ODES.input#
  krantz.input
  decomp.input
  bronson.input

/research/pending/p.input

  hyper/input.pamphlet
  hyper/parse_input.pamphlet
  storevar.input.txt
  storevar1.input.txt
  des.input
  debug.input
  strang.input
  magma/magmafirst.input
  guessrec.input
  redblack.input
  vb/vb1-20.input
  vb/vb1001-1020.input
  vb/vb101-120.input
  vb/vb1021-1040.input
  vb/vb1041-1060.input
  vb/vb1061-1080.input
  vb/vb1081-1100.input
  vb/vb1101-1120.input
  vb/vb1121-1140.input
  vb/vb1141-1160.input
  vb/vb1161-1180.input
  vb/vb1181-1200.input
  vb/vb1201-1220.input
  vb/vb121-140.input
  vb/vb1221-1240.input
  vb/vb1241-1260.input
  vb/vb1261-1280.input
  vb/vb1281-1300.input
  vb/vb1301-1320.input
  vb/vb1321-1340.input
  vb/vb1341-1360.input
  vb/vb1361-1380.input
  vb/vb1381-1400.input
  vb/vb1401-1420.input
  vb/vb141-160.input
  vb/vb1421-1440.input
  vb/vb1441-1460.input
  vb/vb1461-1480.input
  vb/vb1481-1500.input
  vb/vb1501-1520.input
  vb/vb1521-1540.input
  vb/vb1541-1560.input
  vb/vb1561-1580.input
  vb/vb1581-1600.input
  vb/vb1601-1620.input
  vb/vb161-180.input
  vb/vb1621-1640.input
  vb/vb1641-1660.input
  vb/vb1661-1680.input
  vb/vb1681-1700.input
  vb/vb1701-1720.input
  vb/vb1721-1740.input
  vb/vb1741-1760.input
  vb/vb1761-1780.input
  vb/vb1781-1800.input
  vb/vb1801-1820.input
  vb/vb181-200.input
  vb/vb1821-1840.input
  vb/vb1841-1860.input
  vb/vb1861-1880.input
  vb/vb1881-1900.input
  vb/vb1901-1920.input
  vb/vb1921-1940.input
  vb/vb1941-1960.input
  vb/vb1961-1980.input
  vb/vb1981-2000.input
  vb/vb2001-2020.input
  vb/vb201-220.input
  vb/vb2021-2040.input
  vb/vb2041-2060.input
  vb/vb2061-2080.input
  vb/vb2081-2100.input
  vb/vb21-40.input
  vb/vb2101-2120.input
  vb/vb2121-2140.input
  vb/vb2141-2160.input
  vb/vb2161-2180.input
  vb/vb2181-2200.input
  vb/vb2201-2220.input
  vb/vb221-240.input
  vb/vb2221-2240.input
  vb/vb2241-2260.input
  vb/vb2261-2280.input
  vb/vb2281-2300.input
  vb/vb2301-2320.input
  vb/vb2321-2340.input
  vb/vb2341-2360.input
  vb/vb2361-2380.input
  vb/vb2381-2400.input
  vb/vb2401-2420.input
  vb/vb241-260.input
  vb/vb2421-2440.input
  vb/vb2441-2460.input
  vb/vb2461-2480.input
  vb/vb2481-2500.input
  vb/vb2501-2520.input
  vb/vb2521-2540.input
  vb/vb2541-2560.input
  vb/vb2561-2580.input
  vb/vb2581-2600.input
  vb/vb2601-2620.input
  vb/vb261-280.input
  vb/vb2621-2640.input
  vb/vb2641-2660.input
  vb/vb2641-2760.input
  vb/vb2661-vb2680.input
  vb/vb2661a-2680a.input
  vb/vb2681-2700.input
  vb/vb2701-2720.input
  vb/vb2721-2740.input
  vb/vb2761-2780.input
  vb/vb2781-2800.input
  vb/vb2801-2820.input
  vb/vb281-300.input
  vb/vb2821-2840.input
  vb/vb2841-2860.input
  vb/vb2861-2880.input
  vb/vb2881-2900.input
  vb/vb2901-2920.input
  vb/vb2921-2940.input
  vb/vb2941-2960.input
  vb/vb2961-2980.input
  vb/vb2981-3000.input
  vb/vb3001-3020.input
  vb/vb301-320.input
  vb/vb3021-3040.input
  vb/vb3041-3060.input
  vb/vb3061-3080.input
  vb/vb3081-3100.input
  vb/vb3101-3120.input
  vb/vb3121-3140.input
  vb/vb3141-3160.input
  vb/vb3161-3180.input
  vb/vb3181-3200.input
  vb/vb3201-3220.input
  vb/vb321-340.input
  vb/vb3221-3240.input
  vb/vb3241-3260.input
  vb/vb3261-3280.input
  vb/vb3281-3300.input
  vb/vb3301-3320.input
  vb/vb3321-3340.input
  vb/vb3341-3360.input
  vb/vb3361-3380.input
  vb/vb3381-3400.input
  vb/vb3401-3420.input
  vb/vb341-360.input
  vb/vb3421-3440.input
  vb/vb3441-3460.input
  vb/vb3461-3480.input
  vb/vb3481-3500.input
  vb/vb3501-3520.input
  vb/vb3521-3540.input
  vb/vb3541-3560.input
  vb/vb3561-3580.input
  vb/vb3581-3600.input
  vb/vb3601-3620.input
  vb/vb361-380.input
  vb/vb3621-3640.input
  vb/vb3641-3660.input
  vb/vb3661-3680.input
  vb/vb3681-3700.input
  vb/vb3701-3720.input
  vb/vb3721-3740.input
  vb/vb3741-3760.input
  vb/vb3761-3780.input
  vb/vb3781-3800.input
  vb/vb3801-3820.input
  vb/vb381-400.input
  vb/vb3821-3840.input
  vb/vb3841-3860.input
  vb/vb3861-3880.input
  vb/vb3881-3900.input
  vb/vb3901-3920.input
  vb/vb3921-3940.input
  vb/vb3941-3960.input
  vb/vb3961-3980.input
  vb/vb3981-4000.input
  vb/vb4001-4020.input
  vb/vb401-420.input
  vb/vb4021-4040.input
  vb/vb4041-4060.input
  vb/vb4061-4080.input
  vb/vb4081-4100.input
  vb/vb41-60.input
  vb/vb4101-4120.input
  vb/vb4121-4140.input
  vb/vb4141-4160.input
  vb/vb4161-4180.input
  vb/vb4181-4200.input
  vb/vb4201-4220.input
  vb/vb421-440.input
  vb/vb4221-4440.input
  vb/vb4241-4260.input
  vb/vb4261-4280.input
  vb/vb4281-4300.input
  vb/vb4301-4320.input
  vb/vb4321-4340.input
  vb/vb4341-4360.input
  vb/vb4361-4380.input
  vb/vb4381-4400.input
  vb/vb4401-4420.input
  vb/vb441-460.input
  vb/vb4422-4440.input
  vb/vb4441-4460.input
  vb/vb4461-4480.input
  vb/vb4481-4500.input
  vb/vb4501-4520.input
  vb/vb4521-4540.input
  vb/vb4541-4560.input
  vb/vb4561-4580.input
  vb/vb4581-4600.input
  vb/vb4601-4620.input
  vb/vb461-480.input
  vb/vb4621-4640.input
  vb/vb4641-4660.input
  vb/vb4661-4680.input
  vb/vb4681-4700.input
  vb/vb4701-4720.input
  vb/vb4721-4740.input
  vb/vb4741-4760.input
  vb/vb4761-4772.input
  vb/vb481-500.input
  vb/vb501-520.input
  vb/vb521-540.input
  vb/vb541-560.input
  vb/vb561-580.input
  vb/vb581-600.input
  vb/vb601-620.input
  vb/vb61-80.input
  vb/vb621-640.input
  vb/vb641-660.input
  vb/vb661-680.input
  vb/vb681-700.input
  vb/vb701-720.input
  vb/vb721-740.input
  vb/vb741-760.input
  vb/vb761-780.input
  vb/vb781-800.input
  vb/vb801-820.input
  vb/vb81-100.input
  vb/vb821-840.input
  vb/vb841-860.input
  vb/vb861-880.input
  vb/vb881-900.input
  vb/vb901-920.input
  vb/vb921-940.input
  vb/vb941-960.input
  vb/vb961-980.input
  vb/vb980-1000.input
  factor/twister.input
  groebner.input
  testgrob.input
  factor.input
  gcd.input
  twister.input
  outofmemory.input
  redo.input
  kkttest.input
  cannotsolve.input
  normalizeBug.input
  sinaxminusaxBUG.input
  cannotsolve.input~
  integrationBUG.input
  integrateBUG.input
  mail.input
  mail.input~
  mathmlbug.input.pamphlet

/research/int/input

  ACPLOT.input
  REALSOLV.input
  TESTFR.input
  VIEW2D.input
  images6a.input


=========================================================================

todo 314: Tiny programs for computing constants
http://numbers.computation.free.fr/Constants/TinyPrograms/tinycodes.html

=========================================================================

bug 7135: hyperdoc bug

topics -> calculus -> integrate -> first integral
(close the integration popup window kills axiom) with:
(1) -> (HyperDoc) Unknown command from SessionServer -1

=========================================================================

meh 2: Fonts available at www.dafont.com

=========================================================================

bug 7134: lodo.spad LinearOrdinaryDifferentialOperator1

% NOTE: the book has a different answer
  f := rightLcm(a,b)

% NOTE: the book has a different answer
  rightRemainder(f, b)

% NOTE: the book has a different answer
  leftRemainder(f, b)

====================================================================

bug 7133: files.spad Library
)spool Library.output
 
Starts dribbling to Library.output (2007/8/31, 12:8:10).
)set message test on
 
)set message auto off
 
)clear all
 
   All user variables and function definitions have been cleared.
stuff := library "Neat.stuff"
 
 
Daly Bug
   >> Error detected within library code:
   File is not readable
   "Neat.stuff"

====================================================================

bug 7132: numtheor.spad IntegerNumberTheoryFunctions

check the text against the book


====================================================================

bug 7131: -- files.spad.pamphlet KeyedAccessFile
ey: KeyedAccessFile(Integer) := open("editor.year", "output")
 

   (1)  "editor.year"
                                                Type: KeyedAccessFile Integer
ey."Char":= 1986
 

   (2)  1986
                                                        Type: PositiveInteger
ey."Caviness" := 1985
 

   (3)  1985
                                                        Type: PositiveInteger
ey."Fitch"    := 1984
 

   (4)  1984
                                                        Type: PositiveInteger
ey."Char"
 
 
Daly Bug
   >> Error detected within library code:
   File is not readable
   "editor.year"



====================================================================

bug 7130: -- table.spad.pamphlet GeneralSparseTable.input
)spool GeneralSparseTable.output
)set message test on
)set message auto off
)clear all
patrons: GeneralSparseTable(String, Integer, KeyedAccessFile(Integer), 0) := table() ; 
patrons: GeneralSparseTable(String, Integer, KeyedAccessFile(Integer), 0) := table() ; 
 
 
Daly Bug
   >> Error detected within library code:
   File is not readable
   "kaf1405.sdata"

(1) -> 
patrons."Smith" := 10500 
patrons."Jones" := 22000
patrons."Jones" 
patrons."Stingy"
reduce(+, entries patrons) 
)system rm -r kaf*.sdata
)spool
)lisp (bye)

=========================================================================

bug 7129: these take a long time

ode97 := x*D(y(x),x) + a*y(x)**2 - y(x) + b*x**2
ode104 := x*D(y(x),x) + a*x*y(x)**2 + 2*y(x) + b*x
ode105 := x*D(y(x),x) + a*x*y(x)**2 + b*y(x) + c*x + d

=========================================================================

todo 313: put PolynomialCategory, etc into front matter diagram

=========================================================================

todo 312: maple routines

sharelib.zip
maplenuts.zip

=========================================================================

bug 7128: This kills Axiom

draw(1/a*log(a*x+b),x=-1..1)

; (DEFUN %A ...) is being compiled.
;; The variable |a| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |b| is undefined.
;; The compiler will assume this variable is a global.
   Compiling function %B with type DoubleFloat -> DoubleFloat 

=========================================================================

meh 1: script for exploring domain relationships

getDomains(cat: Symbol): Set Symbol ==
  set map(d +-> symbol first destruct first destruct d,
                destruct domainsOf(cat, nil)$Lisp)

=========================================================================

bug 7127: Schaums 14:472 fails to integrate properly

(1) -> t1:=x*asin(x/a)

               x
   (1)  x asin(-)
               a
                                                     Type: Expression Integer
(2) -> t2:=integrate(t1,x)

                            +---------+
                            |   2    2        +---------+
             2    2      2x\|- x  + a         |   2    2
        (- 2x  + a )atan(--------------) + 2x\|- x  + a
                              2    2
                            2x  - a
   (2)  -------------------------------------------------
                                8
                                          Type: Union(Expression Integer,...)
(3) -> t3:=D(t2,x)

                    +---------+
                    |   2    2
                 2x\|- x  + a
          x atan(--------------)
                      2    2
                    2x  - a
   (3)  - ----------------------
                     2
                                                     Type: Expression Integer
(4) -> t4:=(x^2/2-a^2/4)*asin(x/a)+(x*sqrt(a^2-x^2))/4

          +---------+
          |   2    2       2    2      x
        x\|- x  + a   + (2x  - a )asin(-)
                                       a
   (4)  ---------------------------------
                        4
                                                     Type: Expression Integer
(5) -> t5:=D(t4,x)

   (5)
                                           +---------+
                 +---------+               |   2    2               +---------+
              x  |   2    2        2    3  |- x  + a        2    2  |   2    2
   (4a x asin(-)\|- x  + a   - 2a x  + a ) |---------  + (2x  - a )\|- x  + a
              a                            |     2
                                          \|    a
   ----------------------------------------------------------------------------
                                           +---------+
                               +---------+ |   2    2
                               |   2    2  |- x  + a
                            4a\|- x  + a   |---------
                                           |     2
                                          \|    a
                                                     Type: Expression Integer
(6) -> f:=makeFloatFunction(t1,x,a)
   Compiling function %BF with type (DoubleFloat,DoubleFloat) -> 
      DoubleFloat 

   (6)  theMap(MKBCFUNC;binaryFunction;SM;2!0,120)
                             Type: ((DoubleFloat,DoubleFloat) -> DoubleFloat)

(7) -> axiom:=makeFloatFunction(t3,x,a)
   Compiling function %BJ with type (DoubleFloat,DoubleFloat) -> 
      DoubleFloat 

   (7)  theMap(MKBCFUNC;binaryFunction;SM;2!0,996)
                             Type: ((DoubleFloat,DoubleFloat) -> DoubleFloat)
(8) -> schaums:=makeFloatFunction(t5,x,a)
   Compiling function %BK with type (DoubleFloat,DoubleFloat) -> 
      DoubleFloat 

   (8)  theMap(MKBCFUNC;binaryFunction;SM;2!0,62)
                             Type: ((DoubleFloat,DoubleFloat) -> DoubleFloat)
(9) -> [ [f(i::Float,i::Float+1.0::Float)::Float,axiom(i::Float,i::Float+1.0::Float)::Float,schaums(i::Float,i::Float+1.0::Float)::Float] for i in 1..4]

   (9)
   [[0.5235987755 9829892668,0.5235987755 9829892668,0.5235987755 9829881566],
    [1.4594553124 539326738,1.4594553124 539326738,1.4594553124 539324518],
    [2.5441862369 444430136,- 2.1682027434 402466604,2.5441862369 444430136],
    [3.7091808720 064496363,- 2.5740044351 731374839,3.7091808720 064500804]]
                                                        Type: List List Float
(10) -> 

=========================================================================

bug 7126: sinaxminusaxBUG.input shows a bug

why does sin(a x-ax) not become sin(0) then 0?

=========================================================================

bug 7125: normalizeBug.input shows a bug

=========================================================================

bug 7124: why is the superscript not in smallest terms?

--S 100
aa:=integrate(1/(x^2*(x^2-a^2)^(3/2)),x)
--R 
--R
--R                           1
--R   (1)  - -----------------------------------
--R                      +-------+
--R             3    2   | 2    2      4     2 2
--R          (2x  - a x)\|x  - a   - 2x  + 2a x
--R                                          Type: Union(Expression Integer,...)
--E 

--S 101
bb:=-sqrt(x^2-a^2)/(a^4*x)-x/(a^4*sqrt(x^2-a^2))
--R
--R              2    2
--R          - 2x  + a
--R   (2)  -------------
--R            +-------+
--R         4  | 2    2
--R        a x\|x  - a
--R                                                     Type: Expression Integer
--E

--S 102    14:228 Schaums and Axiom differ by a constant
cc:=aa-bb
--R
--R           2
--R   (3)  - --
--R           4
--R          a
--R                                                     Type: Expression Integer
--E

=========================================================================

todo 311: integerMathLibrary FFLAS_technical_report.ps.gz

=========================================================================

todo 310: /research/femlisp (finite element meshes)

=========================================================================

bug 7123: cannot simplify forms like (ax+b)(ax+b)^n into (ax+b)^(n+1)

=========================================================================

wish 1010: look at ocalc.tex for big-O notation by Knuth

=========================================================================

todo 309: huh?

in2360a:=integrate(1/(1-%i*z^2)^(1/2)-csch(z-1), z= -1..1,"noPole")
 

   (175)  [ + infinity, + infinity]
       Type: Union(f2: List OrderedCompletion Expression Complex Integer,...)

Note: verified against NAG

=========================================================================

todo 309: these won't integrate

in13:=integrate(cos(z)^2*sin(z)^n, z)
in160:=integrate((-z^2-z)^sin(z), z)
in163:=integrate(log(z)*abs(exp(z)/z), z)
in166:=integrate((1+z)^z, z)


=========================================================================

bug 7122: "failed"

in106a:=integrate(((%i+z)^%i)^%i, z= 0..1,"noPole")
in1029a:=integrate((%i*z/(%i*z+1))^(1/2), z= 0..%plusInfinity,"noPole")
in1107a:=integrate(-log(z)/(-1+z^(1/2))^3, z= 0..1/2*%i,"noPole")
in1108a:=integrate(log(z)/(-1+z^(1/2))^3, z= 0..1/2*%i,"noPole")
in159a:=integrate(log(z)/z^2, z= -%i..-1,"noPole")
in1859a:=integrate(1/(z^2-1)*(1+1/z^3)^(1/2), z= 0..1,"noPole")
in1867a:=integrate(1/(z^2-1)*(1-(%i*z)^(1/2))^(1/2), z= 0..1,"noPole")
in1869a:=integrate(1/(z^2-1)*(1-1/(%i*z)^(1/2))^(1/2), z= 0..1,"noPole")
in2109a:=integrate((1+%i*z)^(1/2)+cot(z-1), z= 0..1,"noPole")
in2179a:=integrate((z^3-%i*(1-z^4)^(1/2))^4, z= -1..1,"noPole")
in2247a:=integrate(1/(z^2-%i*z+2)^(1/2)+csc(z), z= 0..1,"noPole")
in2340a:=integrate(exp(%i*(%i*z)^(1/2))+cot(z-1), z= -1..1,"noPole")
in2527a:=integrate(1/(1+%i*z^(1/3))+cosh(z), z= %minusInfinity..0,"noPole")
in2567a:=integrate(1/(%i*z)^(1/3)*log(abs(z-1)), z= 0..1/2*%pi,"noPole")
in2597a:=integrate((1+%i/z)^(1/2)-log(1-1/z^2), z= 0..%plusInfinity,"noPole")
in2963a:=integrate(cosh(-1+(1-z)^(1/2))+(z^2+%i*z-3)^(1/2), z= -1..1,"noPole")

=========================================================================

bug 7121: Imaginary part is nonzero. Cannot retract.

in2691a:=integrate(1/(z^2+%i*z-1)^(1/2)+(1-%i*z)^(1/2), z= -1..1,"noPole")

=========================================================================

bug 7120: Zero divisor

in2307a:=integrate(tan(z)-1/(z^2+%i*z-3)^(1/2), z= -1..1,"noPole")

=========================================================================

bug 7119: Cannot take first of an empty list

in1278a:=integrate((1+1/(%i*z)^(1/2))^(1/2), z= 0..%plusInfinity,"noPole")
in1433a:=integrate(-1/((%i*z)^(1/2)-1)*(-2+(%i*z)^(1/2)), z= 0..%plusInfinity,"noPole")
in1435a:=integrate(-1/(1+(%i*z)^(1/2))*(%i*z)^(1/2), z= 0..%plusInfinity,"noPole")
in1436a:=integrate(-((%i*z)^(1/2)-1)/(-2+(%i*z)^(1/2)), z= 0..%plusInfinity,"noPole")
in1463a:=integrate(1-(%i*z)^(1/2)/(1-%i*z), z= 0..%plusInfinity,"noPole")
in1563a:=integrate(log(1-z^3)*(%i*z)^(1/2), z= 0..1,"noPole")
in1638a:=integrate(-z/(z-1)/(1-%i*z)^(1/2), z= 0..1,"noPole")
in1724a:=integrate(-z^2/(z^2-1)*(1-(%i*z)^(1/2))^(1/2), z= 0..1,"noPole")
in183:=integrate(1/z, z= %i..2*%i)
in2108a:=integrate((1-%i/(1+%i/z)^2)^(1/2), z= -1..1,"noPole")
in2124a:=integrate(-1/z-1/(%i/(z+%i))^(1/2), z= -1..0,"noPole")
in2815a:=integrate((%i*z)^(1/2)-(1+1/(%i*z)^(1/2))^(1/2), z= -1..1,"noPole")
in2924a:=integrate(1/(%i*z)^(1/2)+(1+1/(%i*z)^(1/2))^(1/2), z= -1..1,"noPole")
in3001a:=integrate(((%i*z)^(1/2)-1)/(-2+(%i*z)^(1/2)), z= 0..%plusInfinity,"noPole")


=========================================================================

wish 1009: integrate computational geometry algorithms (CGAL)

bounding volumes
polyhedral surfaces
boolean operators
triangulations
voronoi diagrams
mesh generation
subdivision
simplification
parametrization
streamlines
ridge detection
neighbor search
kinetic data structures
lower envelope
arrangement
intersection detection
minkowski sum
PCA
polytope distance
QP solver

geometric objects in 2d, 3d, nd: point, segment, ray, line, circle,
sphere, iso-rectangle, predicates (orientation, in_circle),
constructions (intersection, circumcenter)

delaunay triangles and regular, fully dynamic, 
=========================================================================

todo 308: combinat

=========================================================================

todo 307: elliptic

figure this stuff out

=========================================================================

todo 306: fastmatrix.spad

follow Waldek's lead on this

=========================================================================

bug 7118: Factored AlgebraicNumber

 sqrt(2^32)

   (1)  65536
                                                        Type: AlgebraicNumber
(2) -> %^2

   (2)  4294967296
                                                        Type: AlgebraicNumber
(3) -> factor %

   (3)  4294967296
                                               Type: Factored AlgebraicNumber
(4) -> factor 4294967296

         32
   (4)  2
                                                       Type: Factored Integer
(5) ->

=========================================================================

todo 305: in bookvol11, in graphviewport.xhtml

make graphics automatically pop up when the image is clicked

=========================================================================

todo 304: make graphics be saved as .bmp during build

=========================================================================

todo 303: remove .Z format 

=========================================================================

bug 7116: topics -> graphics -> 3D graphics -> building object -> cube

makeViewport3D(spaceC,title=="Cube") never appears

=========================================================================

wish 1008: ArbitraryConstant domain

  C+3 => C

or potentially

 C+3+5 => C[3+5]

=========================================================================

bug 7114: "possible missing then" bug

insert(h:NODE,key:KEY,value:VALUE):NODE
  if h = null then return node(key,value,red)
  if isRed(h.left) and isRed(h.left.left) then h:=splitFourNode(h)
  if h.key = key 
   then h.value:=value
   else if h.key < key then h.left := insert(h.left,key,value)
    else h.right:= insert(h.right,key,value)
  if isRed(h.right) then h:=leanLeft(h)
  h

insert(h:NODE,key:KEY,value:VALUE):NODE
  if h = null then return node(key,value,red)
  if isRed(h.left) and isRed(h.left.left) then h:=splitFourNode(h)
  if h.key = key then h.value:=value
   else if h.key < key then h.left := insert(h.left,key,value)
    else h.right:= insert(h.right,key,value)
  if isRed(h.right) then h:=leanLeft(h)
  h

=========================================================================

wish 1007: probe-file vs truename

maybe use (defun my-probe-file (path) (ignore-errors (truename path)))

camm writes, the way to test if a directory exists without error...

(defun pathname-pop-slash (pn)
 (let ((pn (pathname pn)))
  (if (or (pathname-name pn) (pathname-type pn)) pn
   (merge-pathnames
    (make-pathname :directory (butlast (pathname-directory pn)))
    (merge-pathnames (pathname (car (last (pathname-directory pn)))) pn)))))

(defun directory-exists-p (pm)
 (let ((pn (pathname-pop-slash pn)))
  (and (not (probe-file pn)) (member pn (directory pn) :test 'equal) t)))

or, in GCL

(defun directory-exists-p (pn)
 (unless (fboundp 'si::stat) (error "no stat"))
 (eq :directory (car (si::stat (namestring pn)))))
  

=========================================================================

bug 7112: t3:=coerce([i for i in 1..10])$Tuple(Integer)

t3:=coerce([i for i in 1..10])$Tuple(Integer)

   (1)  (1,2,3,4,5,6,7,8,9,10)
                                  Type: OutputForm

should be Type: Tuple(Integer)

=========================================================================

bug 7111: NIL is not of type CONS.

fun:=(a:IntegralDomain):IntegralDomain +-> a**2
 
   >> System error:
   NIL is not of type CONS.

=========================================================================

todo 302: getdatabase information unit tests

=========================================================================

bug 7110: RadicalFunctionField(Integer) ramifiedAtInfinity? not implemented

ramifiedAtInfinity()$R
   The function ramifiedAtInfinity is not implemented in 
      RadicalFunctionField(Integer,UnivariatePolynomial(x,Integer),
      UnivariatePolynomial(y,Fraction UnivariatePolynomial(x,Integer)),
      x*x,1) .

=========================================================================

bug 7109: RadicalFunctionField(Integer) singularAtInfinity? not implemented

singularAtInfinity?()$R
   Internal Error
   The function singularAtInfinity? with signature hashcode is missing 
      from domain RadicalFunctionField(Integer)
      (UnivariatePolynomial x (Integer))
      (UnivariatePolynomial y (Fraction (UnivariatePolynomial x (Integer))))
      (((2 . 1)) (0 . 1))1 

=========================================================================

bug 7108: axiom crashes if draw does not include all variables

(1) -> draw(5*y^2+(-4*x+4)*y+8*x^2+2*x-1,x=-5..5)
; (DEFUN %A ...) is being compiled.
;; The variable |y| is undefined.
;; The compiler will assume this variable is a global.

=========================================================================

bug 7107: function xRange with signature hashcode is missing from ACPLOT

m:=makeSketch(x+y,x,y,-1/2..1/2,-1/2..1/2)$ACPLOT
xRange m
   Internal Error
   The function xRange with signature hashcode is missing from domain 
      PlaneAlgebraicCurvePlot 

=========================================================================

wish 1006: API domain for lisp functions

=========================================================================

wish 1005: algebra graph

=========================================================================

wish 1004: create )example for all functions in all domains

construct set of all domains

=========================================================================

bug 7105: [print [i,i*exp(-i)*Ei(i/10.0)] for i in 20..70]
   Internal Error
   The function coerce with signature hashcode is missing from domain 
      Expression(OnePointCompletion (DoubleFloat)) 

=========================================================================

bug 7104: integrate(%e^(a*x)/x^2,x)


           x   %I a
         ++  %e
   (5)   |   ------ d%I
        ++       2
               %I
                                          Type: Union(Expression Integer,...)
 
should be
     ax
    e
  - --- + aEi(ax)
     x

but integrate(%e^(a*x)/x,x)

   (4)  Ei(a x)


=========================================================================

wish 1003: )help limit, integrate, etc

=========================================================================

bug 7103/47: complexForm(log(-%i))

        %pi
   (4)  --- %i
         2
                                             Type: Complex Expression Integer

should be 

         %pi
   (4) - --- %i
          2


=========================================================================

todo 301: etags

etags `find . -name "*.pamphlet"`

=========================================================================

fixed 7096: numeric(Ei(0.01))
 
   >> Error detected within library code:
   Can only compute the numerical value of a constant, real-valued Expression

EI(x) == -0.57721566+0.99999192*x-0.24991055*x^2+0.05519968*x^3-.00976004*x^4+0.00107857*x^5-log(x)

=========================================================================

bug 7098: numeric(Si(0.01))
 
   >> Error detected within library code:
   Can only compute the numerical value of a constant, real-valued Expression

=========================================================================

bug 7097: numeric(Ci(0.01))
 
   >> Error detected within library code:
   Can only compute the numerical value of a constant, real-valued Expression

=========================================================================

wish 1000: WHERE form

a:= b+c
  where
    b = 3x
    c = 4y


=========================================================================

bug 7095: occasional failure of is.input

)clear all
 
--S 1 of 4
 f n ==
   not empty?(u := Is(n, 2*m%)) => integer eval(m%, u)
   3 * n + 1
 
                                                                   Type: Void
--R 
--R                                                                   Type: Void
--E 1

)set stream showall on
 
 
--S 2 of 4
g(n:INT):STREAM(INT) == generate(f, n)
 
   Function declaration g : Integer -> Stream Integer has been added to
      workspace.
                                                                   Type: Void
--R 
--R   Function declaration g : Integer -> Stream Integer has been added to
--R      workspace.
--R                                                                   Type: Void
--E 2

--S 3 of 4
s := g 27
 
   There are 3 exposed and 0 unexposed library operations named 
      generate having 2 argument(s) but none was determined to be 
      applicable. Use HyperDoc Browse, or issue
                            )display op generate
      to learn more about the available operations. Perhaps 
      package-calling the operation or using coercions on the arguments
      will allow you to apply the operation.
   Cannot find a definition or applicable library operation named 
      generate with argument type(s) 
                                 Variable f
                                   Integer
      
      Perhaps you should use "@" to indicate the required return type, 
      or "$" to specify which version of the function you need.
   AXIOM will attempt to step through and interpret the code.
   Compiling function g with type Integer -> Stream Integer 
   There are 3 exposed and 0 unexposed library operations named 
      generate having 2 argument(s) but none was determined to be 
      applicable. Use HyperDoc Browse, or issue
                            )display op generate
      to learn more about the available operations. Perhaps 
      package-calling the operation or using coercions on the arguments
      will allow you to apply the operation.
 
Daly Bug
   Cannot find a definition or applicable library operation named 
      generate with argument type(s) 
                                 Variable f
                                   Integer
      
      Perhaps you should use "@" to indicate the required return type, 
      or "$" to specify which version of the function you need.
--R 
--R   Compiling function f with type Integer -> Integer 
--R   Compiling function g with type Integer -> Stream Integer 
--R
--R   (3)  [27,82,41,124,62,31,94,47,142,71,...]
--R                                                         Type: Stream Integer
--E 3

=========================================================================

todo 300: pending/besselk.input.pamphlet

=========================================================================

bug 7092: .axiom.input screws up builds

=========================================================================

bug 7091: bootstrap bugs

Only in .: boo1.input
Only in .: boo2.input
Only in .: boo3.input
Only in .: boo4.input
Only in .: boo5.input
Only in .: boo6.input
Only in .: boo-cat.input
Only in .: boo-dom1.input
Only in .: boo-dom2.input
Only in .: boo-nilcat.spad
Only in .: boo-nildom.spad
Only in .: boo-pack1.input
Only in .: boo-pack2.input
Only in .: bootstrap.spad
Only in .: boot-sum.in

=========================================================================

bug 7088/347:

-- bug in map$Set (issue 347)
A:Set Integer:=set [-2,-1,0]
B:Set Integer:=set [0,1,4]
C:=map(x +-> x^2,A)
test(C=B)

=========================================================================

bug 7087/312:

-- Bug in sqrt() for UnivariateTaylorSeries (issue 312)
UTSx := UTS(FRAC INT,x,0)
monx2 := monomial(1,2)$UTSx
sqrt(monx2)

=========================================================================

bug 7086/340:

-- issue 340 'divisors$IntegerNumberTheoryFunctions' incorrect for units,
-- i.e., 1, -1
divisors 1
divisors (-1)

=========================================================================

bug 7085/15:

integrate(1/(1+z^4), z=0..1)::Complex Float

=========================================================================

bug 7084/293:

integrate (1/(1+x^4),x = %minusInfinity..%plusInfinity)

=========================================================================

bug 7083/314:

integrate(2*atan(x)/(1+x^2),x)

=========================================================================

bug 7081/184:

argument (-%i)

=========================================================================

bug 7078/114:

dom:=(INT->INT)
g(f:dom):dom== x+->(f(x))^2
p(x:INT):INT == x-1
q:= g p

=========================================================================

bug 7077/156:

)clear all
)set function compile off
u := operator `u;
multidiff(expr, variable, count) == if count > 0 then D(multidiff(expr, variable, count-1), variable) else expr
maketaylor(expr) == series( n +-> multidiff(expr, x, n), x=0)
maketaylor(u(x))
)set function compile on


=========================================================================

bug 7076/176:

p := -x*y^2+x*y+x^3-x^2
D(factor(p),x)

=========================================================================

bug 7075/182:

round(3.77623)
round(-3.77623)

=========================================================================

bug 7074/186:

)clear all
E := Expression Integer
F := E -> E
compose(f:F, g:F):F == (e:E):E +-> f(g(e))
p(e:E):E == 2*e+1
q(e:E):E == 3*e+1
compose(p,q)

=========================================================================

bug 7072/19:

D(0^z, z)

=========================================================================

bug 7071/211:

)clear all
D(product((1-q^(n-i))/(1-q^(m-i)),i=0..m-1),q)
f:=operator `f;
D(product(f(i,q),i=0..m),q)

=========================================================================

bug 7070/278:

simplifyLog(2*sqrt(2)*log(2))

=========================================================================

bug 7069/83:

1::DMP([x],FRAC INT)::POLY FRAC INT
1::DMP([x],INT)::POLY INT
vv := 1::DMP([x],FRAC INT)
uu := vv ::POLY FRAC INT
1 * uu

=========================================================================

bug 7068/371:

iprint("Release the hounds!")$IPRNTPK
for i in 1..10 repeat (iprint$IPRNTPK)(i::String)

-- tracing sanity check
)trace Integer )math
-1
)trace Integer )off

=========================================================================

bug 7067/102:

solve(sinh(z)=cosh(z), z)

=========================================================================

bug 7066/187:

(INT, INT)
Tuple Any

-- missing exports
MyFD := DirectProduct(3, PrimeField(100000000000000006579))
myv := [3, 2, 1]::MyFD
ii := lookup(myv)
index(ii)$MyFD
ii := lookup([1, 1, 1]::MyFD)
index(ii)$MyFD
ii := lookup([1, 1, 0]::MyFD)
index(ii)$MyFD
ii := lookup([1, 2, 3]::MyFD)
index(ii)$MyFD
hash([3, 2, 1]::MyFD)

MyFD:= Product(PrimeField(100000000000000006579), PrimeField(257))
myv := makeprod(1, 1)$MyFD
ii := lookup(myv)
index(ii)$MyFD
ii := lookup(makeprod(2, 1)$MyFD)
index(ii)$MyFD
ii := lookup(makeprod(1, 2)$MyFD)
index(ii)$MyFD
ii := lookup(makeprod(2, 128)$MyFD)
index(ii)$MyFD
hash(myv)

=========================================================================

bug 7064/258:

R==>RectangularMatrix(2,4, PF 2)
every?(zero?, [lookup(index(i)$R)$R - i for i in 1..2^8])

=========================================================================

bug 7063/198:

zero?(complexIntegrate(%i/2*e^(-%i*x^2),x)-_
      (sqrt %pi * sqrt(%i * log e)*erf(x*sqrt(%i*log e)))/(4*log e))

zero?(complexIntegrate(-%i/2*e^(%i*x^2),x)-_
      (sqrt %pi * sqrt(-%i * log e)*erf(x*sqrt(-%i*log e)))/(4*log e))

zero?(complexIntegrate(log(x)/(x-1),x)+dilog x)

zero?(complexIntegrate(2*log(x)/(x-1),x)+2*dilog x)

=========================================================================

bug 7062/408: 

abs(Gamma(1/5::EXPR INT)::EXPR DFLOAT - 4.59084) < 0.00001
abs(digamma(1/5::EXPR INT)::EXPR DFLOAT+5.28904) < 0.000001
abs(besselJ(1,1::EXPR INT)::EXPR DFLOAT - 0.440051) < 0.000001
-- fails, because airyAi yields complex results even for real arguments
abs(airyAi(1/5::EXPR INT)::EXPR DFLOAT - 0.303703) < 0.00001


=========================================================================

bug 7061:

integrate(sqrt(z+sqrt(1+z))/(1+z)^2,z=0..%plusInfinity,"noPole")

                 3
         - 5atan(-) + 4
                 4
   (12)  --------------
                4
                    Type: Union(f1: OrderedCompletion Expression Integer,...)


   (3)  0.1956236140 0839451649
                                                       Type: Expression Float

but MMA6/Maple11/Derive gives

   1+5*atan(1/2)/2 = 2.1591190




=========================================================================

bug 7060: integration bug (different answer in fricas)

 -> ex1:=integrate(sqrt(1+sqrt(1+z))/(1+z^2),z);

                                          Type: Union(Expression Integer,...)
 -> ex2:=eval(ex1,z=0);

                                                     Type: Expression Integer
 -> numeric ex2

  1.0243175471 308082709
                                                                  Type: Float

fricas returns:

  -2.5898455408 37987845


curiously

ex3:=limit(ex1,z=%plusInfinity) 

   (11)  0
                        Type: Union(OrderedCompletion Expression Integer,...)

but fricas doesn't return???


========================================================================

bug 7059: integration bug (different answer in fricas)

integrate(sqrt(1+sqrt(1+z))/(1+z^2),z=0..%plusInfinity,"noPole")::EXPR Float

gives the wrong answer:

   (3)  - 1.0243175471 308082709
                                                       Type: Expression Float

the correct answer:

(5*atan(3)-5*atan(1/3)+4)/4

                         1
        5atan(3) - 5atan(-) + 4
                         3
   (4)  -----------------------
                   4
                                                     Type: Expression Integer
(5) -> numeric %

   (5)  2.1591190225 020152905
                                                                  Type: Float
(6) -> 


=======================================================================

bug 7058: calling AXIOMsys from anywhere on the path without giving
          full path name sometimes causes a segfault

which AXIOMsys
/research2/test/mnt/fedora5/bin/AXIOMsys
[root@localhost test]# AXIOMsys
                        AXIOM Computer Algebra System 
                         Version: Axiom (Sept 2007)
              Timestamp: Tuesday October 16, 2007 at 09:21:36 
-----------------------------------------------------------------------------
   Issue )copyright to view copyright notices.
   Issue )summary for a summary of useful system commands.
   Issue )quit to leave AXIOM and return to shell.
-----------------------------------------------------------------------------
 
   Re-reading compress.daase   Re-reading interp.daase
   Re-reading operation.daase
   Re-reading category.daase
   Re-reading browse.daase
(1) -> )lisp (bye)
[root@localhost test]# echo $AXIOM
/research2/test/mnt/fedora5
[root@localhost test]# AXIOMsys
Segmentation fault
[root@localhost test]# which AXIOMsys
/research2/test/mnt/fedora5/bin/AXIOMsys
[root@localhost test]# AXIOMsys
Segmentation fault
[root@localhost test]# `which AXIOMsys`
                        AXIOM Computer Algebra System 
                         Version: Axiom (Sept 2007)
              Timestamp: Tuesday October 16, 2007 at 09:21:36 
-----------------------------------------------------------------------------
   Issue )copyright to view copyright notices.
   Issue )summary for a summary of useful system commands.
   Issue )quit to leave AXIOM and return to shell.
-----------------------------------------------------------------------------
 
   Re-reading compress.daase   Re-reading interp.daase
   Re-reading operation.daase
   Re-reading category.daase
   Re-reading browse.daase
(1) -> 


[root@localhost test]# strace AXIOMsys
execve("/research2/test/mnt/fedora5/bin/AXIOMsys", ["AXIOMsys"], [/* 39 vars */]) = 0
brk(0)                                  = 0x96a1000
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f73000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
open("/etc/ld.so.cache", O_RDONLY)      = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=67432, ...}) = 0
mmap2(NULL, 67432, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7f62000
close(3)                                = 0
open("/lib/libm.so.6", O_RDONLY)        = 3
read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0`Cv\000"..., 512) = 512
fstat64(3, {st_mode=S_IFREG|0755, st_size=199700, ...}) = 0
mmap2(0x761000, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x761000
mmap2(0x784000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x22) = 0x784000
close(3)                                = 0
open("/usr/lib/sse2/libgmp.so.3", O_RDONLY) = 3
read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\0fv\000"..., 512) = 512
fstat64(3, {st_mode=S_IFREG|0644, st_size=842637, ...}) = 0
mmap2(0x761000, 186848, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x110000
mmap2(0x13d000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x2c) = 0x13d000
close(3)                                = 0
open("/usr/lib/libreadline.so.5", O_RDONLY) = 3
read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@D|\000"..., 512) = 512
fstat64(3, {st_mode=S_IFREG|0755, st_size=197832, ...}) = 0
mmap2(0x7b9000, 199036, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7b9000
mmap2(0x7e5000, 16384, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x2c) = 0x7e5000
mmap2(0x7e9000, 2428, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7e9000
close(3)                                = 0
open("/usr/lib/libncurses.so.5", O_RDONLY) = 3
read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \265\35"..., 512) = 512
fstat64(3, {st_mode=S_IFREG|0755, st_size=304280, ...}) = 0
mmap2(0x71cd000, 296964, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x71cd000
mmap2(0x720d000, 32768, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x40) = 0x720d000
mmap2(0x7215000, 2052, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7215000
close(3)                                = 0
open("/lib/libc.so.6", O_RDONLY)        = 3
read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\n\31d\000"..., 512) = 512
fstat64(3, {st_mode=S_IFREG|0755, st_size=1528292, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f61000
mmap2(0x62c000, 1254780, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x62c000
mmap2(0x758000, 16384, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x12b) = 0x758000
mmap2(0x75c000, 9596, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x75c000
close(3)                                = 0
open("/lib/libdl.so.2", O_RDONLY)       = 3
read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\214x\000"..., 512) = 512
fstat64(3, {st_mode=S_IFREG|0755, st_size=16352, ...}) = 0
mmap2(0x788000, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x788000
mmap2(0x78a000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1) = 0x78a000
close(3)                                = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f60000
set_thread_area({entry_number:-1 -> 6, base_addr:0xb7f606b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
mprotect(0x78a000, 4096, PROT_READ)     = 0
mprotect(0x758000, 12288, PROT_READ)    = 0
mprotect(0x784000, 4096, PROT_READ)     = 0
mprotect(0x628000, 4096, PROT_READ)     = 0
munmap(0xb7f62000, 67432)               = 0
personality(0xffffffff /* PER_??? */)   = 0
personality(0x40000 /* PER_??? */)      = 0
execve("AXIOMsys", ["AXIOMsys"], [/* 39 vars */]) = -1 ENOENT (No such file or directory)
getpid()                                = 25855
stat64("/proc/25855/exe", {st_mode=S_IFREG|0755, st_size=16188532, ...}) = 0
lstat64("/proc", {st_mode=S_IFDIR|0555, st_size=0, ...}) = 0
lstat64("/proc/25855", {st_mode=S_IFDIR|0555, st_size=0, ...}) = 0
lstat64("/proc/25855/exe", {st_mode=S_IFLNK|0777, st_size=0, ...}) = 0
readlink("/proc/25855/exe", "/research2/test/mnt/fedora5/bin/AXIOMsys", 4096) = 40
lstat64("/research2", {st_mode=S_IFDIR|0777, st_size=4096, ...}) = 0
lstat64("/research2/test", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
lstat64("/research2/test/mnt", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
lstat64("/research2/test/mnt/fedora5", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
lstat64("/research2/test/mnt/fedora5/bin", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
lstat64("/research2/test/mnt/fedora5/bin/AXIOMsys", {st_mode=S_IFREG|0755, st_size=16188532, ...}) = 0
rt_sigaction(SIGSEGV, {0x807ae70, [SEGV], SA_RESTART}, {SIG_DFL}, 8) = 0
getrlimit(RLIMIT_STACK, {rlim_cur=10240*1024, rlim_max=RLIM_INFINITY}) = 0
setrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
getrlimit(RLIMIT_DATA, {rlim_cur=RLIM_INFINITY, rlim_max=RLIM_INFINITY}) = 0
mprotect(0x8403000, 10555392, PROT_READ|PROT_WRITE|PROT_EXEC) = 0
rt_sigaction(SIGSEGV, {0x807ae70, [SEGV], SA_RESTART}, {0x807ae70, [SEGV], SA_RESTART}, 8) = 0
getrlimit(RLIMIT_DATA, {rlim_cur=RLIM_INFINITY, rlim_max=RLIM_INFINITY}) = 0
brk(0)                                  = 0x96a1000
brk(0xc765000)                          = 0xc765000
rt_sigaction(SIGFPE, {0x80b3740, [FPE], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
rt_sigaction(SIGPIPE, {0x80b37f0, [PIPE], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
rt_sigaction(SIGINT, {0x80b3410, [INT], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
rt_sigaction(SIGUSR1, {0x80b3410, [USR1], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
rt_sigaction(SIGIO, {0x80b3410, [IO], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
rt_sigaction(SIGALRM, {0x80b3410, [ALRM], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, {B38400 opost isig icanon -echo ...}) = 0
--- SIGSEGV (Segmentation fault) @ 0 (0) ---
rt_sigaction(SIGSEGV, {0x807ae70, [SEGV], SA_RESTART}, {0x807ae70, [SEGV], SA_RESTART}, 8) = 0
--- SIGSEGV (Segmentation fault) @ 0 (0) ---
+++ killed by SIGSEGV +++
Process 25855 detached


[root@localhost test]# echo $AXIOM
/research2/test/mnt/fedora5


[root@localhost test]# echo $PATH
/research2/test/mnt/fedora5/bin:/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/X11R6/bin:/root/bin

[root@localhost test]# uname -a
Linux localhost.localdomain 2.6.18-1.2239.fc5 #1 Fri Nov 10 13:04:06 EST 2006 i686 i686 i386 GNU/Linux

============================================================================

bug 7056: )browse has a bug

)browse
   Your argument list is not valid.

============================================================================

bug 7055: cd doesn't start from the current location

)cd pending
 
   >> System error:
   Can't change the current directory to "/usr/local/axiom/mnt/fedora5/NIL/".

============================================================================

bug 7053: close(viewport) dumps core

============================================================================

bug 7051: is.input intermittent failures

)set message test on
 
)set message auto off
 
)clear all
 
--S 1 of 4
 f n == ( not empty?(u := Is(n, 2*m%)) => integer eval(m%, u) ;  3 * n + 1 )
 
                                                                   Type: Void
--R 
--R                                                                   Type: Void
--E 1

)set stream showall on
 
 
--S 2 of 4
g(n:INT):STREAM(INT) == generate(f, n)
 
   Function declaration g : Integer -> Stream Integer has been added to
      workspace.
                                                                   Type: Void
--R 
--R   Function declaration g : Integer -> Stream Integer has been added to
--R      workspace.
--R                                                                   Type: Void
--E 2

--S 3 of 4
s := g 27
 
   There are 3 exposed and 0 unexposed library operations named 
      generate having 2 argument(s) but none was determined to be 
      applicable. Use HyperDoc Browse, or issue
                            )display op generate
      to learn more about the available operations. Perhaps 
      package-calling the operation or using coercions on the arguments
      will allow you to apply the operation.
   Cannot find a definition or applicable library operation named 
      generate with argument type(s) 
                                 Variable f
                                   Integer
      
      Perhaps you should use "@" to indicate the required return type, 
      or "$" to specify which version of the function you need.
   AXIOM will attempt to step through and interpret the code.
   Compiling function g with type Integer -> Stream Integer 
   There are 3 exposed and 0 unexposed library operations named 
      generate having 2 argument(s) but none was determined to be 
      applicable. Use HyperDoc Browse, or issue
                            )display op generate
      to learn more about the available operations. Perhaps 
      package-calling the operation or using coercions on the arguments
      will allow you to apply the operation.
 
Daly Bug
   Cannot find a definition or applicable library operation named 
      generate with argument type(s) 
                                 Variable f
                                   Integer
      
      Perhaps you should use "@" to indicate the required return type, 
      or "$" to specify which version of the function you need.
--R 
--R   Compiling function f with type Integer -> Integer 
--R   Compiling function g with type Integer -> Stream Integer 
--R
--R   (3)  [27,82,41,124,62,31,94,47,142,71,...]
--R                                                         Type: Stream Integer
--E 3

--S 4 of 4
extend(s, 150)
 
   There are 11 exposed and 0 unexposed library operations named extend
      having 2 argument(s) but none was determined to be applicable. 
      Use HyperDoc Browse, or issue
                             )display op extend
      to learn more about the available operations. Perhaps 
      package-calling the operation or using coercions on the arguments
      will allow you to apply the operation.
 
Daly Bug
   Cannot find a definition or applicable library operation named 
      extend with argument type(s) 
                                 Variable s
                               PositiveInteger
      
      Perhaps you should use "@" to indicate the required return type, 
      or "$" to specify which version of the function you need.
--R 
--R
--R   (4)
--R   [27, 82, 41, 124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242,
--R    121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350,
--R    175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167,
--R    502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479,
--R    1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734,
--R    1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433,
--R    1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53,
--R    160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20,
--R    10, 5, 16, 8, 4, 2, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4,
--R    2, 7, 22, 11, 34, 17, 52, 26, ...]
--R                                                         Type: Stream Integer
--E 4


============================================================================

bug 7050: DFLOAT ignores outputFixed

outputFixed() 
(11) -> 0.0004

   (11)  0.0004
                                                                  Type: Float
(12) -> 0.0004::DFLOAT

   (12)  4.0000000000000002E-4
                                                            Type: DoubleFloat
(13) ->

============================================================================

bug 7049: Ei isn't computing correctly

integrate(e^u/u,u=%minusInfinity..-1,"noPole")

   (19)  potentialPole
                                         Type: Union(pole: potentialPole,...)
(20) -> integrate(e^u/u,u=%minusInfinity..-1,"noPole")
   Loading /usr/local/axiom/mnt/fedora5/algebra/RDETR.o for package 
      TranscendentalRischDE 

   (20)  "failed"
                                                Type: Union(fail: failed,...)
(21) -> integrate(e^u/u,u)

   (21)  Ei(u log(e))
                                          Type: Union(Expression Integer,...)
(22) -> Ei(13)

   (22)  Ei(13)
                                                     Type: Expression Integer
(23) -> 

============================================================================

bug 7048: cannot simplify expression using e^(x log e)

integrate(e^x,x)

           x log(e)
         %e
   (18)  ----------
           log(e)
                                          Type: Union(Expression Integer,...)

============================================================================

bug 7047: Gamma returns a random garbage value

Gamma 1000/1000

   (7)  i.nfE+0
                                                            Type: DoubleFloat

============================================================================

bug 7046: radix has wrong ragits
;;;  radix(5/24,39)  ==> 0 . 8 4 34
;;;
;;;                            _
;;;  radix(5/24,40)  ==> 0 . 8 D
;;;
;;;                          ____
;;;  radix(5/24,43)  ==> 0 . 8 41
;;;
;;;  radix(35,36)    ==> Z
;;;
;;;  radix(36,37)    ==> Error ... index out of range
;;;
;;;  radix(10,16)    ==> A
;;;

============================================================================

idea: )example command taken from regression test chunks

1) identify (using --S comment tags) the functions being demonstrated
2) move the regression chunks near the example function in the algebra
3) dynamically pull the chunks from the sources
4) remove the regression test comment prefix

============================================================================

bug 7044: why?
generic 16 making /research2/test/int/input/iprntpk.input from /research2/test/src/input/iprntpk.input.pamphlet

============================================================================

bug 7043: FAILED 1 of 139 stanzas file kamke3
MISMATCH
expected:"           (9216a  - 7168a )b - 2048a  + 2048a"
     got:"           (18432a  - 57344a )b - 2048a  + 8192a"
MISMATCH
expected:"                 8        6          9        7"
     got:"                  8         6          9        7"
MISMATCH
expected:"           (- 20736a  + 34048a  - 6400a )b  + (4608a  - 22016a  + 9728a )b"
     got:"           (- 41472a  + 272384a  - 204800a )b  + (4608a  - 88064a  + 155648a )b"
MISMATCH
expected:"                    8         6        4  3         9         7        5  2"
     got:"                    8          6          4  3         9         7          5  2"
MISMATCH
expected:"           (- 3072a  + 45312a  - 35840a  + 2048a )b"
     got:"           (- 3072a  + 181248a  - 573440a  + 131072a )b"
MISMATCH
expected:"                   9         7         5        3  4"
     got:"                   9          7          5          3  4"
MISMATCH
expected:"           (13824a  - 61824a  + 25984a  - 256a )b"
     got:"           (27648a  - 494592a  + 831488a  - 32768a )b"
MISMATCH
expected:"                  8         6         4       2  5"
     got:"                  8          6          4         2  5"
MISMATCH
expected:"           (512a  - 28416a  + 56736a  - 12800a )b"
     got:"           (512a  - 113664a  + 907776a  - 819200a )b"
MISMATCH
expected:"                9         7         5         3  6"
     got:"                9          7          5          3  6"
MISMATCH
expected:"           (- 2304a  + 34944a  - 35664a  + 4096a )b"
     got:"           (- 4608a  + 279552a  - 1141248a  + 524288a )b"
MISMATCH
expected:"                   8         6         4        2  7"
     got:"                   8          6           4          2  7"
MISMATCH
expected:"           (4608a  - 28224a  + 15168a  - 768a)b"
     got:"           (18432a  - 451584a  + 970752a  - 196608a)b"
MISMATCH
expected:"                 7         5         3         8"
     got:"                  7          5          3            8"
MISMATCH
expected:"           (- 5376a  + 15456a  - 4176a  + 64)b"
     got:"           (- 43008a  + 494592a  - 534528a  + 32768)b"
MISMATCH
expected:"                   6         4        2       9"
     got:"                    6          4          2          9"
MISMATCH
expected:"           (- 2016a  + 1368a  - 48)b   + (4032a  - 5712a  + 672a)b"
     got:"           (- 64512a  + 175104a  - 24576)b   + (64512a  - 365568a  + 172032a)b"
MISMATCH
expected:"                   4        2       11         5        3         10"
     got:"                    4          2          11          5          3            10"
MISMATCH
expected:"           - b   + 18a b   + (- 144a  + 12)b   + (672a  - 192a)b"
     got:"           - 512b   + 4608a b   + (- 18432a  + 6144)b   + (43008a  - 49152a)b"
MISMATCH
expected:"              15        14          2       13        3         12"
     got:"                 15          14            2         13          3           12"
MISMATCH
expected:"               (82944a  - 50176a  - 10240a )b - 18432a   + 14336a  + 4096a"
     got:"               (165888a  - 401408a  - 327680a )b - 18432a   + 57344a  + 65536a"
MISMATCH
expected:"                      9         7         5           10         8        6"
     got:"                       9          7          5           10         8         6"
MISMATCH
expected:"               (24576a   - 196608a  + 82432a  + 9216a )b"
     got:"               (24576a   - 786432a  + 1318912a  + 589824a )b"
MISMATCH
expected:"                      10          8         6        4  2"
     got:"                      10          8           6          4  2"
MISMATCH
expected:"               (- 110592a  + 301056a  - 80640a  - 3584a )b"
     got:"               (- 221184a  + 2408448a  - 2580480a  - 458752a )b"
MISMATCH
expected:"                         9          7         5        3  3"
     got:"                         9           7           5          3  3"
MISMATCH
expected:"               (- 6144a   + 230400a  - 309888a  + 49664a  + 512a )b"
     got:"               (- 6144a   + 921600a  - 4958208a  + 3178496a  + 131072a )b"
MISMATCH
expected:"                       10          8          6         4       2  4"
     got:"                       10          8           6           4          2  4"
MISMATCH
expected:"               (27648a  - 290304a  + 215616a  - 18944a )b"
     got:"               (55296a  - 2322432a  + 6899712a  - 2424832a )b"
MISMATCH
expected:"                      9          7          5         3  5"
     got:"                      9           7           5           3  5"
MISMATCH
expected:"               (- 55296a  + 241920a  - 100032a  + 4096a )b"
     got:"               (- 221184a  + 3870720a  - 6402048a  + 1048576a )b"
MISMATCH
expected:"                        8          6          4        2  6"
     got:"                         8           6           4           2  6"
MISMATCH
expected:"               (64512a  - 137088a  + 29664a  - 384a)b"
     got:"               (516096a  - 4386816a  + 3796992a  - 196608a)b"
MISMATCH
expected:"                      7          5         3         7"
     got:"                       7           5           3            7"
MISMATCH
expected:"               (24192a  - 12960a  + 384a)b  + (- 48384a  + 52416a  - 5088a )b"
     got:"               (- 774144a  + 3354624a  - 1302528a )b"
MISMATCH
expected:"                      5         3         9            6         4        2  8"
     got:"                         6           4           2  8"
MISMATCH
expected:"               12a b   - 216a b   + (1728a  - 120a)b   + (- 8064a  + 1872a )b"
     got:"               (- 516096a  + 479232a )b   + (774144a  - 1658880a  + 196608a)b"
MISMATCH
expected:"                    13       2 12         3         11           4        2  10"
     got:"                         4          2  10           5           3            9"
MISMATCH
expected:"         + "
     got:"             + "
MISMATCH
expected:"             c"
     got:"               6144a b   - 55296a b   + (221184a  - 61440a)b"
MISMATCH
expected:"              2"
     got:"                      13         2 12           3           11"
MISMATCH
expected:"          *"
     got:"         + "
MISMATCH
expected:"               - 14336a  + 2048a"
     got:"             c"
MISMATCH
expected:"                       7        5"
     got:"              2"
MISMATCH
expected:"             + "
     got:"          *"
MISMATCH
expected:"               (221184a   - 215040a  + 35840a  - 3072a )b - 49152a   + 61440a"
     got:"               245760a  - 229376a  + 131072a"
MISMATCH
expected:"                       10          8         6        4           11         9"
     got:"                      9          7          5"
MISMATCH
expected:"               (24576a   - 479232a  + 336384a  - 37376a  + 1536a )b"
     got:"               (442368a   - 1720320a  + 1146880a  - 393216a )b - 49152a"
MISMATCH
expected:"                      11          9          7         5        3  2"
     got:"                       10           8           6          4           11"
MISMATCH
expected:"               (- 110592a   + 645120a  - 303360a  + 20224a  - 256a )b"
     got:"               (24576a   - 1916928a  + 5382144a  - 2392064a  + 393216a )b"
MISMATCH
expected:"                         10          8          6         4       2  3"
     got:"                      11           9           7           5          3  2"
MISMATCH
expected:"               (221184a  - 580608a  + 168960a  - 5632a )b"
     got:"               (- 221184a   + 5160960a  - 9707520a  + 2588672a  - 131072a )b"
MISMATCH
expected:"                       9          7          5        3  4"
     got:"                         10           8           6           4          2  3"
MISMATCH
expected:"               (- 258048a  + 354816a  - 57600a  + 640a )b"
     got:"               (884736a  - 9289728a  + 10813440a  - 1441792a )b"
MISMATCH
expected:"                         8          6         4       2  5"
     got:"                       9           7            5           3  4"
MISMATCH
expected:"               (193536a  - 145152a  + 11040a )b"
     got:"               (- 2064384a  + 11354112a  - 7372800a  + 327680a )b"
MISMATCH
expected:"                       7          5         3  6"
     got:"                          8            6           4          2  5"
MISMATCH
expected:"               (32256a  - 5760a )b  + (- 96768a  + 38016a  - 912a )b"
     got:"               (3096576a  - 9289728a  + 2826240a )b"
MISMATCH
expected:"                      5        3  8            6         4       2  7"
     got:"                        7           5           3  6"
MISMATCH
expected:"               - 48a b   + 864a b   + (- 6912a  + 384a )b"
     got:"               (- 3096576a  + 4866048a  - 466944a )b"
MISMATCH
expected:"                    2 11       3 10           4       2  9"
     got:"                          6           4          2  7"
MISMATCH
expected:"         + "
     got:"             + "
MISMATCH
expected:"             c"
     got:"               (2064384a  - 1474560a )b"
MISMATCH
expected:"              3"
     got:"                        5           3  8"
MISMATCH
expected:"          *"
     got:"             + "
MISMATCH
expected:"               - 18432a  + 2048a"
     got:"               - 24576a b   + 221184a b   + (- 884736a  + 196608a )b"
MISMATCH
expected:"                       8        6"
     got:"                       2 11          3 10             4          2  9"
MISMATCH
expected:"             + "
     got:"         + "
MISMATCH
expected:"               (147456a   - 172032a  + 46080a  - 3072a )b - 32768a   + 49152a"
     got:"             c"
MISMATCH
expected:"                       11          9         7        5           12         10"
     got:"              3"
MISMATCH
expected:"             + "
     got:"          *"
MISMATCH
expected:"               (- 294912a   + 258048a  - 46080a  + 1536a )b"
     got:"               196608a   - 294912a  + 131072a"
MISMATCH
expected:"                         10          8         6        4  2"
     got:"                      10          8          6"
MISMATCH
expected:"               (344064a  - 215040a  + 23040a  - 256a )b"
     got:"               (294912a   - 1376256a  + 1474560a  - 393216a )b - 32768a"
MISMATCH
expected:"                       9          7         5       3  3"
     got:"                       11           9           7          5           12"
MISMATCH
expected:"               (- 258048a  + 107520a  - 5760a )b"
     got:"               (- 1179648a   + 4128768a  - 2949120a  + 393216a )b"
MISMATCH
expected:"                         8          6        4  4"
     got:"                          10           8           6          4  2"
MISMATCH
expected:"               (129024a  - 32256a  + 576a )b"
     got:"               (2752512a  - 6881280a  + 2949120a  - 131072a )b"
MISMATCH
expected:"                       7         5       3  5"
     got:"                        9           7           5          3  3"
MISMATCH
expected:"               64a b  - 1152a b  + (9216a  - 384a )b  + (- 43008a  + 5376a )b"
     got:"               (- 4128768a  + 6881280a  - 1474560a )b"
MISMATCH
expected:"                  3 9        4 8         5       3  7            6        4  6"
     got:"                          8           6           4  4"
MISMATCH
expected:"     + "
     got:"             + "
MISMATCH
expected:"         ?"
     got:"               (4128768a  - 4128768a  + 294912a )b"
MISMATCH
expected:"      *"
     got:"                        7           5          3  5"
MISMATCH
expected:"           64a  c  - 48a  b c  + 12a b c - a b"
     got:"             + "
MISMATCH
expected:"              11 3      10 2 2      9 4     8 6"
     got:"               (- 2752512a  + 1376256a )b"
MISMATCH
expected:"        /"
     got:"                          6           4  6"
MISMATCH
expected:"             (- 12288a  + 3072a )b + 3072a  - 1024a"
     got:"             + "
MISMATCH
expected:"                      7        5          8        6"
     got:"               32768a b  - 294912a b  + (1179648a  - 196608a )b"
MISMATCH
expected:"           + "
     got:"                     3 9          4 8            5          3  7"
MISMATCH
expected:"             (46080a  - 37632a  + 1536a )b  + (- 11520a  + 26880a  - 3328a )b"
     got:"     + "
MISMATCH
expected:"                    7         5        3  3            8         6        4  2"
     got:"         ?"
MISMATCH
expected:"           + "
     got:"      *"
MISMATCH
expected:"             (10752a  - 90240a  + 34944a  - 256a )b"
     got:"           64a  c  - 48a  b c  + 12a b c - a b"
MISMATCH
expected:"                    8         6         4       2  4"
     got:"              11 3      10 2 2      9 4     8 6"
MISMATCH
expected:"           + "
     got:"        /"
MISMATCH
expected:"             (- 43008a  + 109440a  - 21504a )b"
     got:"             3072a  - 4096a"
MISMATCH
expected:"                      7          5         3  5"
     got:"                  8        6"
MISMATCH
expected:"             (- 2304a  + 77952a  - 87120a  + 8448a )b"
     got:"             (- 11520a  + 107520a  - 53248a )b  + (- 24576a  + 24576a )b"
MISMATCH
expected:"                     8         6         4        2  6"
     got:"                      8          6         4  2            7         5"
MISMATCH
expected:"             (9216a  - 83328a  + 45600a  - 1920a)b"
     got:"             (92160a  - 301056a  + 49152a )b"
MISMATCH
expected:"                   7         5         3          7"
     got:"                    7          5         3  3"
MISMATCH
expected:"             (- 16128a  + 57120a  - 15120a  + 192)b"
     got:"             (10752a  - 360960a  + 559104a  - 16384a )b"
MISMATCH
expected:"                      6         4         2        8"
     got:"                    8          6          4         2  4"
MISMATCH
expected:"             (- 10080a  + 7224a  - 240)b   + (16128a  - 25536a  + 2880a)b"
     got:"             (- 86016a  + 875520a  - 688128a )b"
MISMATCH
expected:"                      4        2        10          5         3          9"
     got:"                      7          5          3  5"
MISMATCH
expected:"             - 9b   + 144a b   + (- 1008a  + 84)b   + (4032a  - 1176a)b"
     got:"             (- 2304a  + 311808a  - 1393920a  + 540672a )b"
MISMATCH
expected:"                 14         13           2       12         3          11"
     got:"                     8          6           4          2  6"
MISMATCH
expected:"               c"
     got:"             (18432a  - 666624a  + 1459200a  - 245760a)b"
MISMATCH
expected:"            *"
     got:"                    7          5           3            7"
MISMATCH
expected:"                 (- 184320a  + 64512a  + 4096a )b + 46080a  - 21504a  - 2048a"
     got:"           + "
MISMATCH
expected:"                           8         6        4           9         7        5"
     got:"             (- 64512a  + 913920a  - 967680a  + 49152)b"
MISMATCH
expected:"               + "
     got:"                      6          4          2          8"
MISMATCH
expected:"                 (- 86016a  + 399360a  - 91392a  - 2560a )b"
     got:"           + "
MISMATCH
expected:"                          9          7         5        3  2"
     got:"             (129024a  - 817152a  + 368640a)b"
MISMATCH
expected:"               + "
     got:"                     5          3            9"
MISMATCH
expected:"                 (344064a  - 552960a  + 75264a  + 512a )b"
     got:"           + "
MISMATCH
expected:"                         8          6         4       2  3"
     got:"             (129024a  - 150528a)b   + (- 161280a  + 462336a  - 61440)b"
MISMATCH
expected:"               + "
     got:"                     3            11             4          2          10"
MISMATCH
expected:"                 (27648a  - 634368a  + 498240a  - 36864a )b"
     got:"           + "
MISMATCH
expected:"                        9          7          5         3  4"
     got:"             - 2304b   + 18432a b   + (- 64512a  + 21504)b"
MISMATCH
expected:"               + "
     got:"                    14           13            2          12"
MISMATCH
expected:"                 (- 110592a  + 698880a  - 289920a  + 9984a )b"
     got:"           + "
MISMATCH
expected:"                           8          6          4        2  5"
     got:"               c"
MISMATCH
expected:"               + "
     got:"            *"
MISMATCH
expected:"                 (193536a  - 497280a  + 105120a  - 1152a)b"
     got:"               (- 368640a  + 516096a  + 131072a )b + 46080a  - 86016a  - 32768a"
MISMATCH
expected:"                         7          5          3          6"
     got:"                         8          6          4           9         7         5"
MISMATCH
expected:"                 (- 193536a  + 231168a  - 21600a )b"
     got:"                 (- 86016a  + 1597440a  - 1462272a  - 163840a )b"
MISMATCH
expected:"                           6          4         2  7"
     got:"                          9           7           5          3  2"
MISMATCH
expected:"                 (- 48384a  + 11424a )b  + (120960a  - 67872a  + 1920a)b"
     got:"                 (688128a  - 4423680a  + 2408448a  + 65536a )b"
MISMATCH
expected:"                          4         2  9           5         3          8"
     got:"                         8           6           4         2  3"
MISMATCH
expected:"                 108a b   - 1728a b   + (12096a  - 840a)b"
     got:"                 (27648a  - 2537472a  + 7971840a  - 2359296a )b"
MISMATCH
expected:"                       12        2 11          3         10"
     got:"                        9           7           5           3  4"
MISMATCH
expected:"           + "
     got:"               + "
MISMATCH
expected:"               c"
     got:"                 (- 221184a  + 5591040a  - 9277440a  + 1277952a )b"
MISMATCH
expected:"                2"
     got:"                           8           6           4           2  5"
MISMATCH
expected:"            *"
     got:"               + "
MISMATCH
expected:"                 - 153600a  + 21504a  - 1024a"
     got:"                 (774144a  - 7956480a  + 6727680a  - 294912a)b"
MISMATCH
expected:"                          8         6        4"
     got:"                         7           5           3            6"
MISMATCH
expected:"                 (- 688128a  + 460800a  - 43008a  + 1024a )b + 172032a"
     got:"                 (- 1548288a  + 7397376a  - 2764800a )b"
MISMATCH
expected:"                           9          7         5        3            10"
     got:"                            6           4           2  7"
MISMATCH
expected:"                 (- 110592a   + 1333248a  - 610560a  + 34560a  - 256a )b"
     got:"                 (1935360a  - 4343808a  + 491520a)b"
MISMATCH
expected:"                           10           8          6         4       2  2"
     got:"                          5           3            8"
MISMATCH
expected:"                 (442368a  - 1591296a  + 453120a  - 13056a )b"
     got:"                 (- 1548288a  + 1462272a )b"
MISMATCH
expected:"                         9           7          5         3  3"
     got:"                            4           2  9"
MISMATCH
expected:"                 (- 774144a  + 1236480a  - 195840a  + 1920a )b"
     got:"                 27648a b   - 221184a b   + (774144a  - 215040a)b"
MISMATCH
expected:"                           8           6          4        2  4"
     got:"                         12          2 11           3            10"
MISMATCH
expected:"               + "
     got:"           + "
MISMATCH
expected:"                 (774144a  - 623616a  + 46080a )b"
     got:"               c"
MISMATCH
expected:"                         7          5         3  5"
     got:"                2"
MISMATCH
expected:"               + "
     got:"            *"
MISMATCH
expected:"                 (193536a  - 34944a )b  + (- 483840a  + 196224a  - 4560a )b"
     got:"                 - 614400a  + 344064a  - 65536a"
MISMATCH
expected:"                         5         3  7             6          4        2  6"
     got:"                          8          6         4"
MISMATCH
expected:"                 - 432a b   + 6912a b  + (- 48384a  + 2688a )b"
     got:"                 (- 1376256a  + 3686400a  - 1376256a  + 131072a )b + 172032a"
MISMATCH
expected:"                       2 10        3 9            4        2  8"
     got:"                            9           7           5          3            10"
MISMATCH
expected:"           + "
     got:"               + "
MISMATCH
expected:"               c"
     got:"                 (- 110592a   + 5332992a  - 9768960a  + 2211840a  - 65536a )b"
MISMATCH
expected:"                3"
     got:"                           10           8           6           4         2  2"
MISMATCH
expected:"            *"
     got:"               + "
MISMATCH
expected:"                 - 172032a  + 46080a  - 3072a"
     got:"                 (884736a  - 12730368a  + 14499840a  - 1671168a )b"
MISMATCH
expected:"                          9         7        5"
     got:"                         9            7            5           3  3"
MISMATCH
expected:"                 (- 589824a   + 516096a  - 92160a  + 3072a )b + 147456a"
     got:"                 (- 3096576a  + 19783680a  - 12533760a  + 491520a )b"
MISMATCH
expected:"                           10          8         6        4            11"
     got:"                            8            6            4          2  4"
MISMATCH
expected:"                 (1032192a  - 645120a  + 69120a  - 768a )b"
     got:"                 (6193152a  - 19955712a  + 5898240a )b"
MISMATCH
expected:"                          9          7         5       3  2"
     got:"                          7            5           3  5"
MISMATCH
expected:"                 (- 1032192a  + 430080a  - 23040a )b"
     got:"                 (- 7741440a  + 12558336a  - 1167360a )b"
MISMATCH
expected:"                            8          6         4  3"
     got:"                            6            4           2  6"
MISMATCH
expected:"                 (- 258048a  + 32256a )b  + (645120a  - 161280a  + 2880a )b"
     got:"                 (6193152a  - 4472832a )b"
MISMATCH
expected:"                           6         4  5           7          5        3  4"
     got:"                          5           3  7"
MISMATCH
expected:"                 576a b  - 9216a b  + (64512a  - 2688a )b"
     got:"                 - 110592a b   + 884736a b  + (- 3096576a  + 688128a )b"
MISMATCH
expected:"                     3 8        4 7          5        3  6"
     got:"                          2 10          3 9              4          2  8"
MISMATCH
expected:"     + "
     got:"           + "
MISMATCH
expected:"         ?"
     got:"               c"
MISMATCH
expected:"          2"
     got:"                3"
MISMATCH
expected:"      *"
     got:"            *"
MISMATCH
expected:"           64a  c  - 48a b c  + 12a b c - a b"
     got:"                 - 688128a  + 737280a  - 196608a"
MISMATCH
expected:"              10 3      9 2 2      8 4     7 6"
     got:"                          9          7          5"
MISMATCH
expected:"        /"
     got:"               + "
MISMATCH
expected:"             (- 40320a  + 13440a )b  + (11520a  - 10752a )b  + 5376a b - 1536a"
     got:"                 (- 1179648a   + 4128768a  - 2949120a  + 393216a )b + 147456a"
MISMATCH
expected:"                      6         4  3          7         5  2        6         7"
     got:"                            10           8           6          4            11"
MISMATCH
expected:"           + "
     got:"               + "
MISMATCH
expected:"             (56448a  - 74400a  + 5376a )b  + (- 16128a  + 70080a  - 10752a )b"
     got:"                 (4128768a  - 10321920a  + 4423680a  - 196608a )b"
MISMATCH
expected:"                    6         4        2  5            7         5         3  4"
     got:"                          9            7           5          3  2"
MISMATCH
expected:"           + "
     got:"               + "
MISMATCH
expected:"             (4608a  - 88704a  + 49920a  - 1536a)b"
     got:"                 (- 8257536a  + 13762560a  - 2949120a )b"
MISMATCH
expected:"                   7         5         3          6"
     got:"                            8            6           4  3"
MISMATCH
expected:"           + "
     got:"               + "
MISMATCH
expected:"             (- 16128a  + 80640a  - 20640a  + 192)b"
     got:"                 (10321920a  - 10321920a  + 737280a )b"
MISMATCH
expected:"                      6         4         2        7"
     got:"                           7            5          3  4"
MISMATCH
expected:"           + "
     got:"               + "
MISMATCH
expected:"             (- 20160a  + 15624a  - 480)b  + (24192a  - 45360a  + 4800a)b"
     got:"                 (- 8257536a  + 4128768a )b"
MISMATCH
expected:"                      4         2        9          5         3          8"
     got:"                            6           4  5"
MISMATCH
expected:"           + "
     got:"               + "
MISMATCH
expected:"             - 36b   + 504a b   + (- 3024a  + 252)b   + (10080a  - 3024a)b"
     got:"                 147456a b  - 1179648a b  + (4128768a  - 688128a )b"
MISMATCH
expected:"                  13         12           2        11          3          10"
     got:"                        3 8           4 7            5          3  6"
MISMATCH
expected:"           + "
     got:"     + "
MISMATCH
expected:"               c"
     got:"         ?"
MISMATCH
expected:"            *"
     got:"          2"
MISMATCH
expected:"                 - 46080a  + 10752a"
     got:"      *"
MISMATCH
expected:"                         8         6"
     got:"           64a  c  - 48a b c  + 12a b c - a b"
MISMATCH
expected:"               + "
     got:"              10 3      9 2 2      8 4     7 6"
MISMATCH
expected:"                 (129024a  - 318720a  + 32256a )b  + (161280a  - 26880a )b"
     got:"        /"
MISMATCH
expected:"                         8          6         4  2           7         5"
     got:"             (11520a  - 43008a )b  + 10752a b - 1536a"
MISMATCH
expected:"               + "
     got:"                    7         5  2         6         7"
MISMATCH
expected:"                 (- 451584a  + 393600a  - 21504a )b"
     got:"           + "
MISMATCH
expected:"                           7          5         3  3"
     got:"             (- 16128a  + 280320a  - 172032a )b  + (- 80640a  + 107520a )b"
MISMATCH
expected:"               + "
     got:"                      7          5          3  4            6          4  3"
MISMATCH
expected:"                 (- 55296a  + 725760a  - 301440a  + 7680a )b"
     got:"           + "
MISMATCH
expected:"                          8          6          4        2  4"
     got:"             (112896a  - 595200a  + 172032a )b"
MISMATCH
expected:"               + "
     got:"                     6          4          2  5"
MISMATCH
expected:"                 (193536a  - 685440a  + 139200a  - 1152a)b"
     got:"           + "
MISMATCH
expected:"                         7          5          3          5"
     got:"             (4608a  - 354816a  + 798720a  - 98304a)b"
MISMATCH
expected:"               + "
     got:"                   7          5          3           6"
MISMATCH
expected:"                 (- 290304a  + 403200a  - 35520a )b"
     got:"           + "
MISMATCH
expected:"                           6          4         2  6"
     got:"             (- 32256a  + 645120a  - 660480a  + 24576)b"
MISMATCH
expected:"               + "
     got:"                      6          4          2          7"
MISMATCH
expected:"                 (- 120960a  + 29232a )b  + (241920a  - 145152a  + 3840a)b"
     got:"           + "
MISMATCH
expected:"                           4         2  8           5          3          7"
     got:"             (96768a  - 725760a  + 307200a)b"
MISMATCH
expected:"               + "
     got:"                    5          3            8"
MISMATCH
expected:"                 432a b   - 6048a b   + (36288a  - 2520a)b"
     got:"           + "
MISMATCH
expected:"                       11        2 10          3          9"
     got:"             (161280a  - 193536a)b   + (- 161280a  + 499968a  - 61440)b"
MISMATCH
expected:"           + "
     got:"                     3            10             4          2          9"
MISMATCH
expected:"               c"
     got:"           + "
MISMATCH
expected:"                2"
     got:"             - 4608b   + 32256a b   + (- 96768a  + 32256)b"
MISMATCH
expected:"            *"
     got:"                    13           12            2          11"
MISMATCH
expected:"               (903168a  - 384000a  + 16128a )b - 258048a  + 153600a  - 10752a"
     got:"           + "
MISMATCH
expected:"                       8          6         4            9          7         5"
     got:"               c"
MISMATCH
expected:"               + "
     got:"            *"
MISMATCH
expected:"                 (221184a  - 1548288a  + 418560a  - 9216a )b"
     got:"                 - 46080a  + 43008a"
MISMATCH
expected:"                         9           7          5        3  2"
     got:"                         8         6"
MISMATCH
expected:"                 (- 774144a  + 1612800a  - 243840a  + 1920a )b"
     got:"                 (129024a  - 1274880a  + 516096a )b  + (322560a  - 215040a )b"
MISMATCH
expected:"                           8           6          4        2  3"
     got:"                         8           6          4  2           7          5"
MISMATCH
expected:"                 (1161216a  - 1048320a  + 73920a )b"
     got:"                 (- 903168a  + 3148800a  - 688128a )b"
MISMATCH
expected:"                          7           5         3  4"
     got:"                           7           5          3  3"
MISMATCH
expected:"                 (483840a  - 88704a )b  + (- 967680a  + 411264a  - 9120a )b"
     got:"                 (- 55296a  + 2903040a  - 4823040a  + 491520a )b"
MISMATCH
expected:"                         5         3  6             6          4        2  5"
     got:"                          8           6           4          2  4"
MISMATCH
expected:"                 - 1728a b  + 24192a b  + (- 145152a  + 8064a )b"
     got:"                 (387072a  - 5483520a  + 4454400a  - 147456a)b"
MISMATCH
expected:"                        2 9         3 8             4        2  7"
     got:"                         7           5           3            5"
MISMATCH
expected:"           + "
     got:"               + "
MISMATCH
expected:"               c"
     got:"                 (- 1161216a  + 6451200a  - 2273280a )b"
MISMATCH
expected:"                3"
     got:"                            6           4           2  6"
MISMATCH
expected:"            *"
     got:"               + "
MISMATCH
expected:"                 258048a  - 46080a  + 1536a"
     got:"                 (1935360a  - 4644864a  + 491520a)b"
MISMATCH
expected:"                        8         6        4"
     got:"                          5           3            7"
MISMATCH
expected:"                 (1032192a  - 645120a  + 69120a  - 768a )b - 294912a"
     got:"                 (- 1935360a  + 1870848a )b"
MISMATCH
expected:"                          9          7         5       3            10"
     got:"                            4           2  8"
MISMATCH
expected:"                 (- 1548288a  + 645120a  - 34560a )b"
     got:"                 55296a b   - 387072a b   + (1161216a  - 322560a)b"
MISMATCH
expected:"                            8          6         4  2"
     got:"                         11          2 10            3            9"
MISMATCH
expected:"               + "
     got:"           + "
MISMATCH
expected:"                 (- 645120a  + 80640a )b  + (1290240a  - 322560a  + 5760a )b"
     got:"               c"
MISMATCH
expected:"                           6         4  4            7          5        3  3"
     got:"                2"
MISMATCH
expected:"               + "
     got:"            *"
MISMATCH
expected:"                 2304a b  - 32256a b  + (193536a  - 8064a )b"
     got:"                 - 172032a"
MISMATCH
expected:"                      3 7         4 6           5        3  5"
     got:"                          5"
MISMATCH
expected:"     + "
     got:"               + "
MISMATCH
expected:"         ?"
     got:"                 (1806336a  - 3072000a  + 516096a )b - 258048a  + 614400a"
MISMATCH
expected:"          3"
     got:"                          8           6          4            9          7"
MISMATCH
expected:"      *"
     got:"               + "
MISMATCH
expected:"           64a c  - 48a b c  + 12a b c - a b"
     got:"                 (221184a  - 6193152a  + 6696960a  - 589824a )b"
MISMATCH
expected:"              9 3      8 2 2      7 4     6 6"
     got:"                         9           7           5          3  2"
MISMATCH
expected:"        /"
     got:"               + "
MISMATCH
expected:"             (17280a  - 1536a )b  + (- 5760a  + 1408a )b  - 768a b + 256a"
     got:"                 (- 1548288a  + 12902400a  - 7802880a  + 245760a )b"
MISMATCH
expected:"                    5        3  3           6        4  2       5        6"
     got:"                            8            6           4          2  3"
MISMATCH
expected:"           + "
     got:"               + "
MISMATCH
expected:"             (- 40320a  + 24000a  - 384a)b  + (13440a  - 26400a  + 1024a )b"
     got:"                 (4644864a  - 16773120a  + 4730880a )b"
MISMATCH
expected:"                      5         3         5          6         4        2  4"
     got:"                          7            5           3  4"
MISMATCH
expected:"           + "
     got:"               + "
MISMATCH
expected:"             (- 5376a  + 53760a  - 12960a  + 64)b"
     got:"                 (- 7741440a  + 13160448a  - 1167360a )b"
MISMATCH
expected:"                     6         4         2       6"
     got:"                            6            4           2  5"
MISMATCH
expected:"           + "
     got:"               + "
MISMATCH
expected:"             (- 20160a  + 17640a  - 480)b  + (16128a  - 40320a  + 3840a)b"
     got:"                 (7741440a  - 5677056a )b"
MISMATCH
expected:"                      4         2        8          5         3          7"
     got:"                          5           3  6"
MISMATCH
expected:"           + "
     got:"               + "
MISMATCH
expected:"             - 84b   + 1008a b   + (- 5040a  + 420)b   + (13440a  - 4200a)b"
     got:"                 - 221184a b  + 1548288a b  + (- 4644864a  + 1032192a )b"
MISMATCH
expected:"                  12          11           2        10          3          9"
     got:"                          2 9           3 8              4           2  7"
MISMATCH
expected:"            *"
     got:"                3"
MISMATCH
expected:"                 23040a  - 1792a"
     got:"            *"
MISMATCH
expected:"                       7        5"
     got:"                 1032192a  - 737280a  + 98304a"
MISMATCH
expected:"               + "
     got:"                         8          6         4"
MISMATCH
expected:"                 (- 107520a  + 124800a  - 3584a )b  + (- 69120a  + 3584a )b"
     got:"               + "
MISMATCH
expected:"                           7          5        3  2            6        4"
     got:"                 (2064384a  - 5160960a  + 2211840a  - 98304a )b - 294912a"
MISMATCH
expected:"               + "
     got:"                          9           7           5         3            10"
MISMATCH
expected:"                 (322560a  - 134400a  + 1792a )b"
     got:"               + "
MISMATCH
expected:"                         6          4        2  3"
     got:"                 (- 6193152a  + 10321920a  - 2211840a )b"
MISMATCH
expected:"               + "
     got:"                            8            6           4  2"
MISMATCH
expected:"                 (64512a  - 443520a  + 83520a  - 384a)b"
     got:"               + "
MISMATCH
expected:"                        7          5         3         4"
     got:"                 (10321920a  - 10321920a  + 737280a )b"
MISMATCH
expected:"               + "
     got:"                           7            5          3  3"
MISMATCH
expected:"                 (- 193536a  + 349440a  - 27840a )b"
     got:"               + "
MISMATCH
expected:"                           6          4         2  5"
     got:"                 (- 10321920a  + 5160960a )b"
MISMATCH
expected:"               + "
     got:"                             6           4  4"
MISMATCH
expected:"                 (- 161280a  + 40320a )b  + (241920a  - 161280a  + 3840a)b"
     got:"               + "
MISMATCH
expected:"                           4         2  7           5          3          6"
     got:"                 294912a b  - 2064384a b  + (6193152a  - 1032192a )b"
MISMATCH
expected:"               + "
     got:"                        3 7           4 6            5           3  5"
MISMATCH
expected:"                 1008a b   - 12096a b  + (60480a  - 4200a)b"
     got:"     + "
MISMATCH
expected:"                        10         2 9          3          8"
     got:"         ?"
MISMATCH
expected:"           + "
     got:"          3"
MISMATCH
expected:"               c"
     got:"      *"
MISMATCH
expected:"                2"
     got:"           64a c  - 48a b c  + 12a b c - a b"
MISMATCH
expected:"            *"
     got:"              9 3      8 2 2      7 4     6 6"
MISMATCH
expected:"               (- 645120a  + 153600a  - 1792a )b + 215040a  - 76800a  + 1792a"
     got:"        /"
MISMATCH
expected:"                         7          5        3            8         6        4"
     got:"             (- 5760a  + 5632a )b  - 1536a b + 256a"
MISMATCH
expected:"               + "
     got:"                     6        4  2        5        6"
MISMATCH
expected:"                 (- 258048a  + 967680a  - 132480a  + 640a )b"
     got:"           + "
MISMATCH
expected:"                           8          6          4       2  2"
     got:"             (13440a  - 105600a  + 16384a )b  + (34560a  - 12288a )b"
MISMATCH
expected:"               + "
     got:"                    6          4         2  4          5         3  3"
MISMATCH
expected:"                 (774144a  - 860160a  + 55680a )b"
     got:"           + "
MISMATCH
expected:"                         7          5         3  3"
     got:"             (- 80640a  + 192000a  - 12288a)b"
MISMATCH
expected:"               + "
     got:"                      5          3           5"
MISMATCH
expected:"                 (645120a  - 120960a )b  + (- 967680a  + 443520a  - 9120a )b"
     got:"           + "
MISMATCH
expected:"                         5          3  5             6          4        2  4"
     got:"             (- 5376a  + 215040a  - 207360a  + 4096)b"
MISMATCH
expected:"               + "
     got:"                     6          4          2         6"
MISMATCH
expected:"                 - 4032a b  + 48384a b  + (- 241920a  + 13440a )b"
     got:"           + "
MISMATCH
expected:"                        2 8         3 7             4         2  6"
     got:"             (32256a  - 322560a  + 122880a)b"
MISMATCH
expected:"           + "
     got:"                    5          3            7"
MISMATCH
expected:"               c"
     got:"           + "
MISMATCH
expected:"                3"
     got:"             (107520a  - 134400a)b  + (- 80640a  + 282240a  - 30720)b"
MISMATCH
expected:"            *"
     got:"                     3            9            4          2          8"
MISMATCH
expected:"                 23040a  - 256a"
     got:"           + "
MISMATCH
expected:"                       5       3"
     got:"             - 5376b   + 32256a b   + (- 80640a  + 26880)b"
MISMATCH
expected:"               + "
     got:"                    12           11            2          10"
MISMATCH
expected:"                 (- 1032192a  + 430080a  - 23040a )b + 344064a  - 215040a"
     got:"           + "
MISMATCH
expected:"                            8          6         4            9          7"
     got:"               c"
MISMATCH
expected:"               + "
     got:"            *"
MISMATCH
expected:"                 (- 860160a  + 107520a )b  + (1290240a  - 322560a  + 5760a )b"
     got:"                 23040a  - 7168a"
MISMATCH
expected:"                           6          4  3            7          5        3  2"
     got:"                       7        5"
MISMATCH
expected:"                 5376a b  - 64512a b  + (322560a  - 13440a )b"
     got:"                 (- 107520a  + 499200a  - 57344a )b  + (- 138240a  + 28672a )b"
MISMATCH
expected:"                      3 6         4 5           5         3  4"
     got:"                           7          5         3  2             6         4"
MISMATCH
expected:"     + "
     got:"               + "
MISMATCH
expected:"         ?"
     got:"                 (645120a  - 1075200a  + 57344a )b"
MISMATCH
expected:"          4"
     got:"                         6           4         2  3"
MISMATCH
expected:"      *"
     got:"               + "
MISMATCH
expected:"           16a c  - 8a b c + a b"
     got:"                 (64512a  - 1774080a  + 1336320a  - 24576a)b"
MISMATCH
expected:"              7 2     6 2     5 4"
     got:"                        7           5           3           4"
MISMATCH
expected:"        /"
     got:"               + "
MISMATCH
expected:"             (- 16800a  + 3600a )b  + (6720a  - 4800a )b  + 3600a b - 1440a"
     got:"                 (- 387072a  + 2795520a  - 890880a )b"
MISMATCH
expected:"                      4        2  3         5        3  2        4         5"
     got:"                           6           4          2  5"
MISMATCH
expected:"           + "
     got:"               + "
MISMATCH
expected:"             (10080a  - 10920a  + 240)b  + (- 4032a  + 18480a  - 1440a)b"
     got:"                 (967680a  - 2580480a  + 245760a)b"
MISMATCH
expected:"                    4         2        5           5         3          4"
     got:"                         5           3            6"
MISMATCH
expected:"           + "
     got:"               + "
MISMATCH
expected:"             126b  - 1260a b  + (5040a  - 420)b  + (- 10080a  + 3360a)b"
     got:"                 (- 1290240a  + 1290240a )b"
MISMATCH
expected:"                 9          8         2        7            3          6"
     got:"                            4           2  7"
MISMATCH
expected:"           + "
     got:"               + "
MISMATCH
expected:"               c"
     got:"                 64512a b   - 387072a b  + (967680a  - 268800a)b"
MISMATCH
expected:"            *"
     got:"                         10          2 9           3            8"
MISMATCH
expected:"                 4800a"
     got:"           + "
MISMATCH
expected:"                      4"
     got:"               c"
MISMATCH
expected:"               + "
     got:"                2"
MISMATCH
expected:"                 (32256a  - 80640a  + 4320a )b  + (67200a  - 7200a )b - 26880a"
     got:"            *"
MISMATCH
expected:"                        6         4        2  2          5        3           6"
     got:"                 28672a"
MISMATCH
expected:"               + "
     got:"                       4"
MISMATCH
expected:"                 (80640a  - 18480a )b  + (- 80640a  + 53760a  - 960a)b"
     got:"               + "
MISMATCH
expected:"                        4         2  4            5         3         3"
     got:"                 (- 1290240a  + 1228800a  - 57344a )b + 215040a  - 307200a"
MISMATCH
expected:"               + "
     got:"                            7           5         3            8          6"
MISMATCH
expected:"                 - 1008a b  + 10080a b  + (- 40320a  + 2520a)b"
     got:"               + "
MISMATCH
expected:"                          7         2 6            3          5"
     got:"                 (- 258048a  + 3870720a  - 2119680a  + 40960a )b"
MISMATCH
expected:"           + "
     got:"                           8           6           4         2  2"
MISMATCH
expected:"               c"
     got:"               + "
MISMATCH
expected:"                2"
     got:"                 (1548288a  - 6881280a  + 1781760a )b"
MISMATCH
expected:"            *"
     got:"                          7           5           3  3"
MISMATCH
expected:"                 - 64512a  + 26880a  - 1440a"
     got:"               + "
MISMATCH
expected:"                         7         5        3"
     got:"                 (- 3870720a  + 7096320a  - 583680a )b"
MISMATCH
expected:"               + "
     got:"                            6           4          2  4"
MISMATCH
expected:"                 (- 161280a  + 20160a )b  + (161280a  - 40320a  + 720a )b"
     got:"               + "
MISMATCH
expected:"                           5         3  2           6         4       2"
     got:"                 (5160960a  - 3870720a )b"
MISMATCH
expected:"               + "
     got:"                          5           3  5"
MISMATCH
expected:"                 2016a b  - 20160a b  + (80640a  - 3360a )b"
     got:"               + "
MISMATCH
expected:"                      2 5         3 4          4        2  3"
     got:"                 - 258048a b  + 1548288a b  + (- 3870720a  + 860160a )b"
MISMATCH
expected:"     + "
     got:"                          2 8           3 7              4          2  6"
MISMATCH
expected:"         ?"
     got:"           + "
MISMATCH
expected:"          5"
     got:"               c"
MISMATCH
expected:"      *"
     got:"                3"
MISMATCH
expected:"           16a c  - 8a b c + a b"
     got:"            *"
MISMATCH
expected:"              6 2     5 2     4 4"
     got:"                 368640a  - 16384a"
MISMATCH
expected:"        /"
     got:"                        5         3"
MISMATCH
expected:"             - 288a b + 144a"
     got:"               + "
MISMATCH
expected:"                   3        4"
     got:"                 (- 2064384a  + 3440640a  - 737280a )b + 344064a  - 860160a"
MISMATCH
expected:"           + "
     got:"                            8           6          4            9          7"
MISMATCH
expected:"             (2016a  - 3528a  + 48)b  + (4032a  - 192a)b  + (- 2016a  + 336a )b"
     got:"               + "
MISMATCH
expected:"                   4        2       4         3         3           4       2  2"
     got:"                 (5160960a  - 5160960a  + 368640a )b"
MISMATCH
expected:"           + "
     got:"                          7           5          3  2"
MISMATCH
expected:"             126b  - 1008a b  + (3024a  - 252)b  + (- 4032a  + 1512a)b"
     got:"               + "
MISMATCH
expected:"                 8          7         2        6           3          5"
     got:"                 (- 6881280a  + 3440640a )b"
MISMATCH
expected:"           + "
     got:"                            6           4  3"
MISMATCH
expected:"               c"
     got:"               + "
MISMATCH
expected:"            *"
     got:"                 344064a b  - 2064384a b  + (5160960a  - 860160a )b"
MISMATCH
expected:"                 (- 16128a  + 480a )b + 8064a  - 480a"
     got:"                        3 6           4 5            5          3  4"
MISMATCH
expected:"                          4       2          5       3"
     got:"     + "
MISMATCH
expected:"               + "
     got:"         ?"
MISMATCH
expected:"                 (32256a  - 8064a )b  + (- 16128a  + 16128a  - 192a)b"
     got:"          4"
MISMATCH
expected:"                        4        2  3            5         3         2"
     got:"      *"
MISMATCH
expected:"               + "
     got:"           16a c  - 8a b c + a b"
MISMATCH
expected:"                 - 1008a b  + 8064a b  + (- 24192a  + 1512a)b"
     got:"              7 2     6 2     5 4"
MISMATCH
expected:"                          6        2 5            3          4"
     got:"        /"
MISMATCH
expected:"           + "
     got:"             (- 33600a  + 28800a )b  + (6720a  - 19200a )b  + 7200a b - 1440a"
MISMATCH
expected:"               c"
     got:"                      4         2  3         5         3  2        4         5"
MISMATCH
expected:"                2"
     got:"           + "
MISMATCH
expected:"            *"
     got:"             (20160a  - 87360a  + 7680)b  + (- 4032a  + 73920a  - 23040a)b"
MISMATCH
expected:"                 (- 64512a  + 8064a )b + 32256a  - 8064a  + 144a"
     got:"                    4         2         5           5         3           4"
MISMATCH
expected:"                          5        3           6        4       2"
     got:"           + "
MISMATCH
expected:"               + "
     got:"             4032b  - 20160a b  + (40320a  - 13440)b  + (- 40320a  + 53760a)b"
MISMATCH
expected:"                 2016a b  - 16128a b  + (48384a  - 2016a )b"
     got:"                  9           8          2          7            3           6"
MISMATCH
expected:"                      2 4         3 3          4        2  2"
     got:"           + "
MISMATCH
expected:"     + "
     got:"               c"
MISMATCH
expected:"         ?"
     got:"            *"
MISMATCH
expected:"          6"
     got:"                 - 26880a  + 19200a"
MISMATCH
expected:"      *"
     got:"                         6         4"
MISMATCH
expected:"           4a c - a b"
     got:"               + "
MISMATCH
expected:"             4     3 2"
     got:"                 (32256a  - 322560a  + 69120a )b  + (134400a  - 57600a )b"
MISMATCH
expected:"        /"
     got:"                        6          4         2  2           5         3"
MISMATCH
expected:"             504a b  + (- 1008a  + 84)b  + (672a  - 336a)b  + 504a b - 336a"
     got:"               + "
MISMATCH
expected:"                   4           2       3        3         2       2        3"
     got:"                 (322560a  - 295680a )b  + (- 161280a  + 430080a  - 30720a)b"
MISMATCH
expected:"           + "
     got:"                         4          2  4             5          3           3"
MISMATCH
expected:"             (336a b  - 2016a b  + (4032a  - 168a)b - 2688a  + 336a )c - 84b"
     got:"               + "
MISMATCH
expected:"                    3        2 2         3                 4       2        5"
     got:"                 - 32256a b  + 161280a b  + (- 322560a  + 80640a)b"
MISMATCH
expected:"     + "
     got:"                           7          2 6             3           5"
MISMATCH
expected:"         ?"
     got:"           + "
MISMATCH
expected:"          7"
     got:"               c"
MISMATCH
expected:"      *"
     got:"                2"
MISMATCH
expected:"           4a c - a b"
     got:"            *"
MISMATCH
expected:"             3     2 2"
     got:"                 - 64512a  + 107520a  - 23040a"
MISMATCH
expected:"        /"
     got:"                         7          5         3"
MISMATCH
expected:"             (- 144a  + 12)b  - 24a b + 24a"
     got:"               + "
MISMATCH
expected:"                    2       2              2"
     got:"                 (- 645120a  + 322560a )b  + (322560a  - 322560a  + 23040a )b"
MISMATCH
expected:"           + "
     got:"                           5          3  2           6          4         2"
MISMATCH
expected:"             (144a b  - 576a b + 576a  - 24a)c - 36b  + 144a b"
     got:"               + "
MISMATCH
expected:"                    2       2        3              4         3"
     got:"                 64512a b  - 322560a b  + (645120a  - 107520a )b"
MISMATCH
expected:"     + "
     got:"                       2 5          3 4           4          2  3"
MISMATCH
expected:"                a"
     got:"     + "
MISMATCH
expected:"       ?  + -------- ?"
     got:"         ?"
MISMATCH
expected:"        9   9b - 18a  8"
     got:"          5"
MISMATCH
expected:"   WARNING (genufact): No known algorithm to factor"
     got:"      *"
MISMATCH
expected:"     , trying square-free."
     got:"           16a c  - 8a b c + a b"
MISMATCH
expected:"         64a  c  - 48a  b c  + 12a  b c - a b"
     got:"              6 2     5 2     4 4"
MISMATCH
expected:"            12 3      11 2 2      10 4     9 6"
     got:"        /"
MISMATCH
expected:"      /"
     got:"             (- 2016a  + 1344a )b  - 576a b + 144a"
MISMATCH
expected:"           - 64b"
     got:"                     4        2  2       3        4"
MISMATCH
expected:"                9"
     got:"           + "
MISMATCH
expected:"         + "
     got:"             (2016a  - 14112a  + 768)b  + (8064a  - 1536a)b"
MISMATCH
expected:"           (- 12a b   + 120a b   - 384a b  + 384a b )c + b   - 12b   + 48b"
     got:"                   4         2        4         3          3"
MISMATCH
expected:"                   13         11         9         7      15      13      11"
     got:"           + "
MISMATCH
expected:"         + "
     got:"             2016b  - 8064a b  + (12096a  - 4032)b  + (- 8064a  + 12096a)b"
MISMATCH
expected:"           (48a b   - 384a b  + 912a b  - 640a b  + 256a b )c"
     got:"                  8          7          2         6           3           5"
MISMATCH
expected:"               2 11       2 9       2 7       2 5       2 3  2"
     got:"           + "
MISMATCH
expected:"         + "
     got:"               c"
MISMATCH
expected:"           (- 64a b  + 384a b  - 576a b  + 256a b )c"
     got:"            *"
MISMATCH
expected:"                 3 9       3 7       3 5       3 3  3"
     got:"                 (- 32256a  + 3840a )b + 8064a  - 1920a"
MISMATCH
expected:"     + "
     got:"                          4        2          5        3"
MISMATCH
expected:"         ?"
     got:"               + "
MISMATCH
expected:"      *"
     got:"                 (64512a  - 64512a )b  + (- 16128a  + 64512a  - 3072a)b"
MISMATCH
expected:"           64a  c  - 48a  b c  + 12a b c - a b"
     got:"                        4         2  3            5         3          2"
MISMATCH
expected:"              11 3      10 2 2      9 4     8 6"
     got:"               + "
MISMATCH
expected:"        /"
     got:"                 - 16128a b  + 64512a b  + (- 96768a  + 24192a)b"
MISMATCH
expected:"             - 240b   + 192b"
     got:"                           6         2 5            3           4"
MISMATCH
expected:"                   10       8"
     got:"           + "
MISMATCH
expected:"           + "
     got:"               c"
MISMATCH
expected:"             (108a b   - 840a b   + 1920a b  - 1152a b )c - 9b   + 84b"
     got:"                2"
MISMATCH
expected:"                    12         10          8          6       14      12"
     got:"            *"
MISMATCH
expected:"           + "
     got:"                 (- 129024a  + 64512a )b + 32256a  - 32256a  + 2304a"
MISMATCH
expected:"             (- 432a b   + 2688a b  - 4560a b  + 1920a b  - 256a b )c"
     got:"                           5         3           6         4        2"
MISMATCH
expected:"                    2 10        2 8        2 6        2 4       2 2  2"
     got:"               + "
MISMATCH
expected:"           + "
     got:"                 32256a b  - 129024a b  + (193536a  - 32256a )b"
MISMATCH
expected:"             (576a b  - 2688a b  + 2880a b  - 768a b )c"
     got:"                       2 4          3 3           4         2  2"
MISMATCH
expected:"                  3 8        3 6        3 4       3 2  3"
     got:"     + "
MISMATCH
expected:"     + "
     got:"         ?"
MISMATCH
expected:"         ?"
     got:"          6"
MISMATCH
expected:"          2"
     got:"      *"
MISMATCH
expected:"      *"
     got:"           4a c - a b"
MISMATCH
expected:"           64a  c  - 48a b c  + 12a b c - a b"
     got:"             4     3 2"
MISMATCH
expected:"              10 3      9 2 2      8 4     7 6"
     got:"        /"
MISMATCH
expected:"        /"
     got:"             1008a b - 336a"
MISMATCH
expected:"             480b  - 192b"
     got:"                  2        3"
MISMATCH
expected:"                 9       7"
     got:"           + "
MISMATCH
expected:"           + "
     got:"             - 672b  + 2016a b  + (- 2016a  + 672)b  + (672a  - 1344a)b"
MISMATCH
expected:"             (- 432a b   + 2520a b  - 3840a b  + 1152a b )c + 36b   - 252b"
     got:"                   5          4           2        3        3          2"
MISMATCH
expected:"                      11          9          7          5        13       11"
     got:"           + "
MISMATCH
expected:"           + "
     got:"             (2688a b  - 8064a b  + (8064a  - 1344a)b - 2688a  + 1344a )c"
MISMATCH
expected:"             (1728a b  - 8064a b  + 9120a b  - 1920a b )c"
     got:"                     3        2 2         3                  4        2"
MISMATCH
expected:"                   2 9        2 7        2 5        2 3  2"
     got:"     + "
MISMATCH
expected:"           + "
     got:"         ?"
MISMATCH
expected:"             (- 2304a b  + 8064a b  - 5760a b  + 768a b)c"
     got:"          7"
MISMATCH
expected:"                     3 7        3 5        3 3       3   3"
     got:"      *"
MISMATCH
expected:"     + "
     got:"           4a c - a b"
MISMATCH
expected:"         ?"
     got:"             3     2 2"
MISMATCH
expected:"          3"
     got:"        /"
MISMATCH
expected:"      *"
     got:"             (- 144a  + 48)b  - 48a b + 24a"
MISMATCH
expected:"           64a c  - 48a b c  + 12a b c - a b"
     got:"                    2       2              2"
MISMATCH
expected:"              9 3      8 2 2      7 4     6 6"
     got:"           + "
MISMATCH
expected:"        /"
     got:"             (576a b  - 1152a b + 576a  - 96a)c - 144b  + 288a b"
MISMATCH
expected:"             - 480b  + 64b"
     got:"                    2        2        3               4         3"
MISMATCH
expected:"                   8      6"
     got:"     + "
MISMATCH
expected:"           + "
     got:"                a"
MISMATCH
expected:"             (1008a b   - 4200a b  + 3840a b  - 384a b )c - 84b   + 420b"
     got:"       ?  + --------- ?"
MISMATCH
expected:"                     10          8          6         4        12       10"
     got:"        9   18b - 18a  8"
MISMATCH
expected:"           + "
     got:"   WARNING (genufact): No known algorithm to factor"
MISMATCH
expected:"             (- 4032a b  + 13440a b  - 9120a b  + 640a b )c"
     got:"     , trying square-free."
MISMATCH
expected:"                     2 8         2 6        2 4       2 2  2"
     got:"         64a  c  - 48a  b c  + 12a  b c - a b"
MISMATCH
expected:"           + "
     got:"            12 3      11 2 2      10 4     9 6"
MISMATCH
expected:"             (5376a b  - 13440a b  + 5760a b  - 256a )c"
     got:"      /"
MISMATCH
expected:"                   3 6         3 4        3 2       3  3"
     got:"           - 64b"
MISMATCH
expected:"     + "
     got:"                9"
MISMATCH
expected:"         ?"
     got:"         + "
MISMATCH
expected:"          4"
     got:"           (- 12a b   + 120a b   - 384a b  + 384a b )c + b   - 12b   + 48b"
MISMATCH
expected:"      *"
     got:"                   13         11         9         7      15      13      11"
MISMATCH
expected:"           16a c  - 8a b c + a b"
     got:"         + "
MISMATCH
expected:"              7 2     6 2     5 4"
     got:"           (48a b   - 384a b  + 912a b  - 640a b  + 256a b )c"
MISMATCH
expected:"        /"
     got:"               2 11       2 9       2 7       2 5       2 3  2"
MISMATCH
expected:"             (1008a b  - 2520a b  + 960a b )c - 126b  + 420b  - 240b"
     got:"         + "
MISMATCH
expected:"                     7          5         3         9       7       5"
     got:"           (- 64a b  + 384a b  - 576a b  + 256a b )c"
MISMATCH
expected:"           + "
     got:"                 3 9       3 7       3 5       3 3  3"
MISMATCH
expected:"             (- 2016a b  + 3360a b  - 720a b)c"
     got:"     + "
MISMATCH
expected:"                     2 5        2 3       2   2"
     got:"         ?"
MISMATCH
expected:"     + "
     got:"      *"
MISMATCH
expected:"         ?"
     got:"           64a  c  - 48a  b c  + 12a b c - a b"
MISMATCH
expected:"          5"
     got:"              11 3      10 2 2      9 4     8 6"
MISMATCH
expected:"      *"
     got:"        /"
MISMATCH
expected:"           16a c  - 8a b c + a b"
     got:"             - 240b   + 192b"
MISMATCH
expected:"              6 2     5 2     4 4"
     got:"                   10       8"
MISMATCH
expected:"        /"
     got:"           + "
MISMATCH
expected:"             (- 1008a b  + 1512a b  - 192a b )c + 126b  - 252b  + 48b"
     got:"             (108a b   - 840a b   + 1920a b  - 1152a b )c - 9b   + 84b"
MISMATCH
expected:"                       6          4         2         8       6      4"
     got:"                    12         10          8          6       14      12"
MISMATCH
expected:"             (2016a b  - 2016a b  + 144a )c"
     got:"             (- 432a b   + 2688a b  - 4560a b  + 1920a b  - 256a b )c"
MISMATCH
expected:"                   2 4        2 2       2  2"
     got:"                    2 10        2 8        2 6        2 4       2 2  2"
MISMATCH
expected:"     + "
     got:"           + "
MISMATCH
expected:"                   4a c - a b"
     got:"             (576a b  - 2688a b  + 2880a b  - 768a b )c"
MISMATCH
expected:"                     4     3 2"
     got:"                  3 8        3 6        3 4       3 2  3"
MISMATCH
expected:"       ----------------------------------- ?"
     got:"     + "
MISMATCH
expected:"       (- 336a b  + 168a b)c + 84b  - 84b   6"
     got:"         ?"
MISMATCH
expected:"                3                 5      3"
     got:"          2"
MISMATCH
expected:"     + "
     got:"      *"
MISMATCH
expected:"                              4a c - a b"
     got:"           64a  c  - 48a b c  + 12a b c - a b"
MISMATCH
expected:"             a                  3     2 2"
     got:"              10 3      9 2 2      8 4     7 6"
MISMATCH
expected:"       ?  - -- ?  + ------------------------------ ?"
     got:"        /"
MISMATCH
expected:"        9   9b  8   (144a b  - 24a)c - 36b  + 12b   7"
     got:"             480b  - 192b"
MISMATCH
expected:"                           2              4      2"
     got:"                 9       7"
MISMATCH
expected:"   WARNING (genufact): No known algorithm to factor"
     got:"           + "
MISMATCH
expected:"                 4a c - a b                 4a c - a b"
     got:"             (- 432a b   + 2520a b  - 3840a b  + 1152a b )c + 36b   - 252b"
MISMATCH
expected:"                   3     2 2                  5     4 2"
     got:"                      11          9          7          5        13       11"
MISMATCH
expected:"     ?  + ------------------------- ?  + -----------------, trying square-free."
     got:"           + "
MISMATCH
expected:"      4   - 4a c + 2b  - 4a b + 4a   2   - b  + 4a b - 4a"
     got:"             (1728a b  - 8064a b  + 9120a b  - 1920a b )c"
MISMATCH
expected:"                     2            2         2            2"
     got:"                   2 9        2 7        2 5        2 3  2"
MISMATCH
expected:"   WARNING (genufact): No known algorithm to factor"
     got:"           + "
MISMATCH
expected:"           4a c - a b       4a c - a b"
     got:"             (- 2304a b  + 8064a b  - 5760a b  + 768a b)c"
MISMATCH
expected:"             3     2 2        5     4 2"
     got:"                     3 7        3 5        3 3       3   3"
MISMATCH
expected:"     ?  + ------------ ?  - -----------, trying square-free."
     got:"     + "
MISMATCH
expected:"      4   - 4a c + 2b   2        b"
     got:"         ?"
MISMATCH
expected:"                     2            2"
     got:"          3"
MISMATCH
expected:"   WARNING (genufact): No known algorithm to factor"
     got:"      *"
MISMATCH
expected:" "
     got:"           64a c  - 48a b c  + 12a b c - a b"
FAILED kamke3  85 of 139

============================================================================

bug 7040:
edible.c: In function main:
edible.c:226: warning: missing sentinel in function call

============================================================================

bug 7039:
/research2/test/int/hyper/spadint.c: In function print_source_to_string1:
/research2/test/int/hyper/spadint.c:990: warning: suggest explicit braces to avoid ambiguous else

============================================================================

bug 7038:
/research2/test/int/hyper/spadint.c: In function print_to_string1:
/research2/test/int/hyper/spadint.c:503: warning: suggest explicit braces to avoid ambiguous else
/research2/test/int/hyper/spadint.c:511: warning: suggest explicit braces to avoid ambiguous else

============================================================================

bug 7037:
/research2/test/int/hyper/parse-types.c: In function parse_condnode:
/research2/test/int/hyper/parse-types.c:159: warning: passing argument 2 of htperror makes pointer from integer without a cast

============================================================================

bug 7036:
/research2/test/int/hyper/event.c: In function handle_event:
/research2/test/int/hyper/event.c:244: warning: dereferencing type-punned pointer will break strict-aliasing rules

============================================================================

bug 7035:
/research2/test/int/sman/sman.c:752: warning: clean_up_terminal defined but not used

============================================================================

bug 7034:
/research2/test/int/sman/session.c:58: warning: pr defined but not used

============================================================================

bug 7033:
/research2/test/obj/fedora5/graph/gdraws/gfun.o: In function `PSInit':gfun.c:(.text+0x237f): warning: the use of `tmpnam' is dangerous, better use `mkstemp'
/research2/test/obj/fedora5/graph/gdraws/gfun.o: In function `PSGlobalInit':gfun.c:(.text+0xd21): warning: the use of `tempnam' is dangerous, better use `mkstemp'

============================================================================

bug 7032: 
/research2/test/src/graph/view3d/static.h:42: warning: labels defined but not used

============================================================================

bug 7031: 
/research2/test/int/graph/view3d/surface3d.c: In function drawRenderedPolygon:
/research2/test/int/graph/view3d/surface3d.c:392: warning: col_rgb.r may be used uninitialized in this function
/research2/test/int/graph/view3d/surface3d.c:392: warning: col_rgb.g may be used uninitialized in this function
/research2/test/int/graph/view3d/surface3d.c:392: warning: col_rgb.b may be used uninitialized in this function

============================================================================

bug 7030:
/research2/test/int/graph/view3d/stuff3d.c: In function norm_dist:
/research2/test/int/graph/view3d/stuff3d.c:126: warning: pert.z is used uninitialized in this function

============================================================================

bug 7029:
/research2/test/int/graph/view3d/process3d.c: In function processEvents:
/research2/test/int/graph/view3d/process3d.c:855: warning: linearMouseXY.x may be used uninitialized in this function
/research2/test/int/graph/view3d/process3d.c:855: warning: linearMouseXY.y may be used uninitialized in this function
/research2/test/int/graph/view3d/process3d.c:855: warning: mouseXY.x may be used uninitialized in this function
/research2/test/int/graph/view3d/process3d.c:855: warning: mouseXY.y may be used uninitialized in this function

============================================================================

bug 7028:
/research2/test/int/graph/view3d/control3d.c: In function getControlXY:
/research2/test/int/graph/view3d/control3d.c:798: warning: cXY.putX may be used uninitialized in this function
/research2/test/int/graph/view3d/control3d.c:798: warning: cXY.putY may be used uninitialized in this function

============================================================================

bug 7027:
/research2/test/obj/fedora5/graph/gdraws/gfun.o: In function `PSInit':gfun.c:(.text+0x237f): warning: the use of `tmpnam' is dangerous, better use `mkstemp'
/research2/test/obj/fedora5/graph/gdraws/gfun.o: In function `PSGlobalInit':gfun.c:(.text+0xd21): warning: the use of `tempnam' is dangerous, better use `mkstemp'

============================================================================

bug 7026:
/research2/test/int/graph/view2d/process2d.c: In function processEvents:
/research2/test/int/graph/view2d/process2d.c:491: warning: mouseXY.x may be used uninitialized in this function
/research2/test/int/graph/view2d/process2d.c:491: warning: mouseXY.y may be used uninitialized in this function

============================================================================

bug 7025: 
/research2/test/int/graph/view2d/control2d.c: In function getControlXY:
/research2/test/int/graph/view2d/control2d.c:367: warning: cXY.putX may be used uninitialized in this function
/research2/test/int/graph/view2d/control2d.c:367: warning: cXY.putY may be used uninitialized in this function

============================================================================

bug 7024: edible.c:226: warning: missing sentinel in function call

============================================================================

bug 7022: NewDistributedMultivariatePolynomial does not exist
Hyperdoc bug Topics>Polynomials>Specific Types>Polynomial
likely this is XDistributedPolynomial... change all refs in help 

============================================================================

bug 7021: vertical bar is not implemented properly.

m1:=matrix [[1,2,1],[2,1,-2],[1,-2,4]]
eigenvalues(m1)
  should be
                 2
     [5,%DA | %DA  - %DA - 5]

  but instead prints as:
                 2
     [5,%DA ? %DA  - %DA - 5]
            ?

============================================================================

bug 7018: mathml does not render "failed" properly
limit(x*log(x),x=0)
  [leftHandLimit=~failed~,rightHandLimit=0]

============================================================================

bug 7017: time screws the regression tests
add )set mes time off 
to all regression tests

============================================================================

bug 7013: DirectProduct harms matrix multiply by constant
(9) -> k

        + 2   - 1   0 +
        |             |
   (9)  |- 1   2   - 1|
        |             |
        + 0   - 1   2 +
                                       Type: SquareMatrix(3,Fraction Integer)
(10) -> k*4

   (10)  [4,0,4]
                                      Type: DirectProduct(3,Fraction Integer)


============================================================================

bug 7012 (SF/1795259): Error printing lists
fixed in OpenAxiom by changing:
  aggcat.spad
  array1.spad
  list.spad
  tree.spad

)abbrev domain FOO foo

foo(): with
   makeFoo: () -> %
   coerce: % -> OutputForm
 == add 
   makeFoo() == "a foo" pretend %

   coerce x == (x pretend String)::OutputForm

)co foo.spad

                                                               Type: List foo
(7) -> makeFoo()

   (7)  "a foo"
                                                                    Type: foo
(8) -> [makeFoo()]

 LISP output:
(a foo)
                                                               Type: List foo
The reason is that the List functor is defined
to have a coercion to OutputForm only if its argument
is of tyep SetCategory. This is clearly wrong. There is
no reason to associate prettyprinting with SetCategory 
membership.

changing the signature line to read:
   foo(): SetCategory with
causes 
                                                               Type: List foo
(10) -> [makeFoo()]

   (10)  ["a foo"]
                                                               Type: List foo

============================================================================

bug7009 (SF/1790563): fatal error (fixed in openaxiom rev 135)
(1) -> Insn == Enumeration(New, Move, Line, Close)
                                                                   Type: Void
(2) -> Insn
   Compiling body of rule Insn to compute value of type Domain 

 
   >> System error:
   Caught fatal error [memory may be damaged]

in i-output.boot function outputDomainConstructor change
  if VECTORP form then form := devaluate form
  if VECTORP CAR form then form := devaluate form

============================================================================

bug7008: never completes
y:=operator 'y
ode360 := D(y(x),x)*cos(a*y(x))-b*(1-c*cos(a*y(x)))*_
           sqrt(cos(a*y(x))**2-(1-c*cos(a*y(x))))
solve(ode360,y,x)

IDEA: write a new axiom output for
        X+Y+Z
       where X=
       where Y=
       where Z=
and it linebreaks properly

============================================================================

bug7007: never completes
y:=operator 'y
ode184 := (a*x**2+b*x+c)**2*(D(y(x),x)+y(x)**2) + A
ode184a:=solve(ode184,y,x)

============================================================================

bug7006: never completes
y:=operator 'y
ode182 := x*(x**3-1)*D(y(x),x) - 2*x*y(x)**2 + y(x) + x**2
ode182a:=solve(ode182,y,x)

============================================================================

bug7005: infinite loop trying to factor
y:=operator 'y
ode162 := (x-a)*(x-b)*D(y(x),x) + y(x)**2 + k*(y(x)+x-a)*(y(x)+x-b)
ode162a:=solve(ode162,y,x)
 
   WARNING (genufact): No known algorithm to factor
      3     2       2          2
     ?  - 3?  + (- k  + 3)? + k  - 1, trying square-free.


============================================================================

bug7004: plugging the particular solution into the ODE using eval fails
         to take the derivative. And eval will not let you use y'(x)
y:=operator 'y
ode2 := D(y(x),x) + a*y(x) - c*exp(b*x)
ode2a:=solve(ode2,y,x)
mm:=ode2a.particular
eval(ode2,y(x)=mm)                        <= should be zero
D(mm,x)-c*exp(b*x)+a*mm

============================================================================

bug7003:
ode73 := D(y(x),x) - ((a3*x**3+a2*x**2+a1*x+a0)/_
                       (a3*y(x)**3+a2*y(x)**2+a1*y(x)+a0))**(2/3)
 

                 +----------------------------------+2
                 |         3       2
         ,       |     a3 x  + a2 x  + a1 x + a0
   (4)  y (x) -  |----------------------------------
                3|       3          2
                \|a3 y(x)  + a2 y(x)  + a1 y(x) + a0
                                                     Type: Expression Integer
solve(ode73,y,x)
 
 
   >> Error detected within library code:
   Table construction failed in MLIFT

============================================================================

bug7002: infinite loop
  ode59 := D(y(x),x) - a*sqrt(y(x)**2+1) - b
  solve(ode59,y,x)

============================================================================

bug7001:
B0 n == matrix [[(if i=j+1 and odd? j then -1 else _
                   if i=j-1 and odd? i then 1 else 0) _
                     for j in 1..n] for i in 1..n]

PfChar(lambda, A) ==
    n := nrows A
    (n = 2) => lambda^2 + A.(1,2)
    M := subMatrix(A, 3, n, 3, n)
    r := subMatrix(A, 1, 1, 3, n)
    s := subMatrix(A, 3, n, 2, 2)

    p := PfChar(lambda, M)
    d := degree(p, lambda)

    B := B0(n-2)
    C := r*B
    g := [(C*s).(1,1), A.(1,2), 1]
    if d >= 4 then 
        B := M*B
        for i in 4..d by 2 repeat
            C := C*B
            g := cons((C*s).(1,1), g)
    g := reverse! g

    res := 0
    for i in 0..d by 2 for j in 2..d+2 repeat
        c := coefficient(p, lambda, i)
        for e in first(g, j) for k in 2..-d by -2 repeat
            res := res +  c * e * lambda^(k+i)

    res

pfaffian A == eval(PfChar(l, A), l=0)

makepfaff(seq,n) == 
  m:= matrix [[(if i<j then (seq.(j-i)) _
                 else if i>j then -(seq.(i-j))    
                  else 0) for j in 1..n] for i in 1..n]

seq:=[2 for i in 1..]
mp:=[makepfaff(seq,k) for k in 2..10 by 2]
[pfaffian mp.i for i in 1..5]

=======================================================================


question: can we represent portions of n-dimensional space in provisos?

============================================================================

bug7000:
 m0:=[[0,0],[0,0]]
 m1:Matrix(Integer):=[[0,3],[-3,0]]
 m2:Matrix(Integer):=[[0,5],[-5,0]]
 m3:Matrix(Integer):=[[0,7],[-7,0]]
 mn:Matrix(Integer):=[[m1,m0,m0],[m0,m2,m0],[m0,m0,m3]]

============================================================================

bug102:
solve(sinh(z)=cosh(z),z)
 
   >> Error detected within library code:
   No identity element for reduce of empty list using operation
   append

============================================================================

bug104:
solve(cos(z)/sin(z)=0,z)

   (2)  []
                                       Type: List Equation Expression Integer
should be %pi/2

(3) -> solve(cot(z)=0,z)

            %pi
   (3)  [z= ---]
             2
                                       Type: List Equation Expression Integer


============================================================================

why do these differ?
diff -Naur ./viewdef.spad.pamphlet /research/may07/build-improvements/src/algebra/viewdef.spad.pamphlet
diff -Naur ./view3d.spad.pamphlet /research/may07/build-improvements/src/algebra/view3d.spad.pamphlet
diff -Naur ./view2d.spad.pamphlet /research/may07/build-improvements/src/algebra/view2d.spad.pamphlet


============================================================================

--- src/algebra/intrf.spad.pamphlet	2007-04-27 21:29:46.000000000 -0400
+++ /research/may07/build-improvements/src/algebra/intrf.spad.pamphlet	2007-04-27 21:34:07.000000000 -0400
@@ -478,7 +478,7 @@
                           else notelm := notelm + monomial(missing, n)
         p   := reductum p
       zero? notelm => [answr, coef0]
-      [answr, notelm + monomial(coef0, 0)]
+      [answr, notelm]
 
 -- f is either 0 or of the form p(t)/(1 + t**2)**n
 -- returns either


============================================================================

--- src/algebra/intfact.spad.pamphlet	2007-04-27 21:29:46.000000000 -0400
+++ /research/may07/build-improvements/src/algebra/intfact.spad.pamphlet	2007-04-27 21:34:07.000000000 -0400
@@ -401,51 +401,27 @@
        r:I := 1
        q:I := 1
        G:I := 1
-       l:I
-       k:I
        until G > 1 repeat
           x := y
-          ys := y
           for i in 1..convert(r)@Integer repeat
              y := (y*y+5::I) rem n
              q := (q*abs(x-y)) rem n
-          k := 0::I
-          G := gcd(q,n)
+             k:I := 0
           until (k>=r) or (G>1) repeat
              ys := y
              for i in 1..convert(min(m,r-k))@Integer repeat
                 y := (y*y+5::I) rem n
-                q := (q*abs(x-y)) rem n
+                q := q*abs(x-y) rem n
              G := gcd(q,n)
              k := k+m
-          k := k + r
           r := 2*r
        if G=n then
-          l := k - m
-          G := 1::I
           until G>1 repeat
              ys := (ys*ys+5::I) rem n
              G := gcd(abs(x-ys),n)
-             l := l + 1
-          if G = n then
-             y := x0
-             x := x0
-             for i in 1..convert(l)@Integer repeat
-               y := (y*y+5::I) rem n
-             G := gcd(abs(x-y), n)
-             until G>1 repeat
-               y := (y*y+5::I) rem n
-               x := (x*x+5::I) rem n
-               G := gcd(abs(x-y), n)
        G=n => "failed"
        G
 
-    PollardSmallFactor20(n:I):Union(I,"failed") ==
-       for i in 1..20 repeat
-          r := PollardSmallFactor n
-          r case I => return r
-       r
-
     BasicSieve(r, lim) ==
        l:List(I) :=
           [1::I,2::I,2::I,4::I,2::I,4::I,2::I,4::I,6::I,2::I,6::I]
@@ -494,7 +470,7 @@
           (y:=perfectSqrt (x**2-n)) case I =>
                 insert_!(x+y,a,c)
                 insert_!(x-y,a,c)
-          (d := PollardSmallFactor20 n) case I =>
+          (d := PollardSmallFactor n) case I =>
              for m in 0.. while zero?(n rem d) repeat n := n quo d
              insert_!(d, a, m * c)
              if n > 1 then insert_!(n, a, c)

============================================================================

--- src/algebra/gaussian.spad.pamphlet	2007-04-27 21:29:46.000000000 -0400
+++ /research/may07/build-improvements/src/algebra/gaussian.spad.pamphlet	2007-04-27 21:34:07.000000000 -0400
@@ -367,18 +367,10 @@
            argument x == atan2loc(imag x, real x)
 
          else
-           if R has RadicalCategory then
-             argument x ==
-               n1 := sqrt(norm(x))
-               x1 := real(x) + n1
-               (2::R)*atan(imag(x) * recip(x1)::R)
-
-           else
-             -- Emulate sqrt using exp and log
-             argument x ==
-               n1 := exp(half*log(norm(x)))
-               x1 := real(x) + n1
-               (2::R)*atan(imag(x) * recip(x1)::R)
+           -- Not ordered so dictate two quadrants
+           argument x ==
+             zero? real x => pi()$R * half
+             atan(imag(x) * recip(real x)::R)
 
          pi()  == pi()$R :: %
 

============================================================================

--- src/algebra/free.spad.pamphlet	2007-04-27 21:29:46.000000000 -0400
+++ /research/may07/build-improvements/src/algebra/free.spad.pamphlet	2007-04-27 21:34:07.000000000 -0400
@@ -531,21 +531,21 @@
       inmax l ==
         mx := first l
         for t in rest l repeat
-          if mx.gen < t.gen then mx := t
+          if t.gen > mx.gen then mx := t
         mx
 
-      -- lexicographic order
       a < b ==
         zero? a  =>
           zero? b => false
-          0 < (inmax terms b).exp
+          (inmax terms b).exp > 0
         ta := inmax terms a
         zero? b => ta.exp < 0
+        ta := inmax terms a
         tb := inmax terms b
-        ta.gen < tb.gen => 0 < tb.exp
-        tb.gen < ta.gen => ta.exp < 0
+        ta.gen < tb.gen => true
+        ta.gen > tb.gen => false
         ta.exp < tb.exp => true
-        tb.exp < ta.exp => false
+        ta.exp > tb.exp => false
         lc := ta.exp * ta.gen
         (a - lc) < (b - lc)
 
============================================================================

--- src/algebra/files.spad.pamphlet	2007-04-27 21:29:46.000000000 -0400
+++ /research/may07/build-improvements/src/algebra/files.spad.pamphlet	2007-04-27 21:34:07.000000000 -0400
@@ -389,8 +389,10 @@
  
         defstream(fn: Name, mode: IOMode): FileState ==
             mode = "input"  =>
+              not readable? fn => error ["File is not readable", fn]
               RDEFINSTREAM(fn::String)$Lisp
             mode = "output" =>
+              not writable? fn => error ["File is not writable", fn]
               RDEFOUTSTREAM(fn::String)$Lisp
             error ["IO mode must be input or output", mode]
  
@@ -407,7 +409,9 @@
             mode = "either" =>
                 exists? fname =>
                     open(fname, "input")
-                reopen_!(open(fname, "output"), "input")
+                writable? fname =>
+                    reopen_!(open(fname, "output"), "input")
+                error "File does not exist and cannot be created"
             [fname, defstream(fname, mode), mode]
         reopen_!(f, mode) ==
             close_! f
@@ -502,10 +506,6 @@
              ++ \spad{lib.k := v} saves the value \spad{v} in the library
              ++ \spad{lib}.  It can later be extracted using the key \spad{k}.
 
-         close_!: % -> %
-          ++ close!(f) returns the library f closed to input and output.
-
-
     == KeyedAccessFile(Any) add
          Rep := KeyedAccessFile(Any)
          library f == open f

============================================================================

--- src/algebra/efstruc.spad.pamphlet	2007-04-27 21:29:46.000000000 -0400
+++ /research/may07/build-improvements/src/algebra/efstruc.spad.pamphlet	2007-04-27 21:34:07.000000000 -0400
@@ -2,7 +2,7 @@
 \usepackage{axiom}
 \begin{document}
 \title{\$SPAD/src/algebra efstruc.spad}
-\author{Manuel Bronstein, Waldek Hebisch}
+\author{Manuel Bronstein}
 \maketitle
 \begin{abstract}
 \end{abstract}
@@ -101,9 +101,9 @@
 <<package EFSTRUC ElementaryFunctionStructurePackage>>=
 )abbrev package EFSTRUC ElementaryFunctionStructurePackage
 ++ Risch structure theorem
-++ Author: Manuel Bronstein, Waldek Hebisch
+++ Author: Manuel Bronstein
 ++ Date Created: 1987
-++ Date Last Updated: 9 October 2006
+++ Date Last Updated: 16 August 1995
 ++ Description:
 ++   ElementaryFunctionStructurePackage provides functions to test the
 ++   algebraic independence of various elementary functions, using the
@@ -346,102 +346,9 @@
           return false
       true
 
-@
-
-\begin{verbatim}
-1) the patch correct problem in goodCoef, there are other bugs in
-   integrator, I will work on them separately.
-2) AFAICS goodCoef is an optimization, it should be safe to return
-   "failed" always (but since we take different path in the other
-   part we hit different bugs).  I tried to preserve optimization
-   done by goodCoef whenever it is safe.
-3) I would like to use higher level constructs, but I keept hitting
-   into problems with SPAD compiler, so finally I used a rather low
-   level way
-4) without the patch the AXIOM recurses infinitely handling the 
-   few integrals below (first I previosly gave in the bug report).
-   With the patch the first two are correctly handled, the other
-   two quickly hit into unimplemented part of Risch algorithm:
-\end{verbatim}
-
-\begin{verbatim}
-integrate(
- simplify(
-  D((log((x)+1)+a)
-       / (2*((((x*(exp(exp(x)/2)))-(a*(x+exp(-x/2))))*(2/x))-3)),
-    x)),
-   x)
-\end{verbatim}
-
-\begin{verbatim}
-integrate(
- simplify(
-  D(((((
-    (sqrt((sqrt((x)/(x)))/(a)))
-       / (sqrt(x)))
-        * ((((x)-(1))*(1))-(1)))
-         * (a))
-      * (((log((x)
-       * ((a)/(log(sqrt((x)/(((x)*(x))*(x))))))))
-        + (((x)/(sqrt(2)))*(exp(exp(x)))))
-         + ((x)-(exp(2)))))
-     + ((1)*(2)), x)),
-  x)
-\end{verbatim}
-
-This fails with ``Function not supported by Risch d.e.''
-\begin{verbatim}
-integrate(
- simplify(
-  D(((((((a)/(sqrt((sqrt(x))-(x))))+(x))*(x))+(1))
-     * ((((((1)-(log(x)))+(1))*(exp(exp(2))))*(2))
-      * (((1)*((log((a)*(1)))*(a)))
-       * (exp(((exp(x))*(x))
-        - (exp(x)))))))
-   * (a), x)),
-  x)
-\end{verbatim}
-This fails with ``intef: failed1 - cannot handle that integrand''
-\begin{verbatim}
-integrate(
- simplify(
-  D((((((((x)+(log(x)))*(((x)/(x))/(sqrt(x))))
-     / ((a)*(x)))
-      - (sqrt(sqrt(((exp(x))/((x)-(sqrt(x))))-(log(x))))))
-       - (x))
-    - (((exp((sqrt(log(1)))*((x)*((x)/(log(x))))))
-       / (exp((1)+((2)-((x)-(x))))))
-      * (((((x)/(1))-(log(x)))*(1))+(((2)+(a))/(exp(sqrt(x)))))))
-  / (2), x)), 
- x)
-\end{verbatim}
-
-If k1 is part of k2 we should not express k1 in terms of k2
-(othewise we would get infinite recursion).
-Below we impose a stronger condition: we require
-height(k1) to be maximal
-
-@
-<<package EFSTRUC ElementaryFunctionStructurePackage>>=
     goodCoef(v, l, s) ==
-      h:NonNegativeInteger := 0
-      j:Integer := 0
-      ll : List K := [];
-      for k in l repeat
-        if (is?(k, "log"::SY) or is?(k, "exp"::SY)
-            or is?(k, "tan"::SY) or is?(k, "atan"::SY)) then
-              ll := [k, :ll]
-              h := h + 1
-      not (h = (maxIndex(v) - minIndex(v) + 1)) => "failed"
-      h := 0
-      ll := reverse(ll)
-      for i in minIndex v .. maxIndex v for k in ll repeat
-        h1 := height(k)
-        if (h1 > h) then
-          j := i
-          h := h1
-      for i in minIndex v .. maxIndex v for k in ll repeat
-        is?(k, s) and (i >= j) and
+      for i in minIndex v .. maxIndex v for k in l repeat
+        is?(k, s) and
            ((r:=recip(qelt(v,i))) case Q) and
             (retractIfCan(r::Q)@Union(Z, "failed") case Z)
               and gdCoef?(qelt(v, i), v) => return([i, k])

============================================================================

--- src/algebra/draw.spad.pamphlet	2007-04-27 21:29:46.000000000 -0400
+++ /research/may07/build-improvements/src/algebra/draw.spad.pamphlet	2007-04-27 21:34:07.000000000 -0400
@@ -318,10 +318,9 @@
     myTrap1: (SF-> SF, SF) -> SF
     myTrap1(ff:SF-> SF, f:SF):SF ==
       s := trapNumericErrors(ff(f))$Lisp :: Union(SF, "failed")
-      s case "failed" => 0
+      s case "failed" => _$NaNvalue$Lisp
       r:=s::SF
-      r >max()$SF => max()$SF
-      r < min()$SF => min()$SF
+      r >max()$SF or r < min()$SF => _$NaNvalue$Lisp
       r
 
     makePt2: (SF,SF) -> Point SF
@@ -494,10 +493,9 @@
     myTrap2: ((SF, SF) -> SF, SF, SF) -> SF
     myTrap2(ff:(SF, SF) -> SF, u:SF, v:SF):SF ==
       s := trapNumericErrors(ff(u, v))$Lisp :: Union(SF, "failed")
-      s case "failed" =>  0
+      s case "failed" =>  _$NaNvalue$Lisp
       r:SF := s::SF
-      r >max()$SF => max()$SF
-      r < min()$SF => min()$SF
+      r >max()$SF or r < min()$SF => _$NaNvalue$Lisp
       r
 
     recolor(ptFunc,colFunc) ==


============================================================================

--- src/algebra/plot3d.spad.pamphlet	2007-04-27 21:29:46.000000000 -0400
+++ /research/may07/build-improvements/src/algebra/plot3d.spad.pamphlet	2007-04-27 21:34:07.000000000 -0400
@@ -192,11 +192,11 @@
  
     select(l,f,g) ==
       m := f first l
-      -- if (EQL(m, _$NaNvalue$Lisp)$Lisp) then m := 0
+      if (EQL(m, _$NaNvalue$Lisp)$Lisp) then m := 0
 --      for p in rest l repeat m := g(m,fp)
       for p in rest l repeat
         fp : F := f p
-        -- if (EQL(fp, _$NaNvalue$Lisp)$Lisp) then fp := 0
+        if (EQL(fp, _$NaNvalue$Lisp)$Lisp) then fp := 0
         m := g(m,fp)
       m
  
@@ -447,7 +447,7 @@
     myTrap(ff:F-> F, f:F):F ==
       s := trapNumericErrors(ff(f))$Lisp :: Union(F, "failed")
       if (s) case "failed" then
-        r:F := 0
+        r:F := _$NaNvalue$Lisp
       else
         r:F := s
       r

============================================================================

--- src/algebra/numtheor.spad.pamphlet	2007-04-27 21:29:46.000000000 -0400
+++ /research/may07/build-improvements/src/algebra/numtheor.spad.pamphlet	2007-04-27 21:34:07.000000000 -0400
@@ -432,50 +432,18 @@
     for entry in factors factor n repeat
       r := ((entry.factor - 1) /$RN entry.factor) * r
     numer(n * r)
-@
 
-<<package INTHEORY IntegerNumberTheoryFunctions>>=
   divisors n ==
-    oldList : List Integer := [1]
+    oldList : List Integer := concat(1,nil())
     for f in factors factor n repeat
-      newList : List Integer := oldList
-      for k in 1..f.exponent repeat
+      newList : List Integer := nil()
+      for k in 0..f.exponent repeat
         pow := f.factor ** k
         for m in oldList repeat
-          newList := concat(pow * m, newList)
+          newList := concat(pow * m,newList)
       oldList := newList
+    sort(#1 < #2,newList)
 
-    sort(#1 < #2, oldList)
-@
-
-[[divisors]] generates the list of positive divisors of an integer. We proceed
-in an inductive manner: [[oldList]] contains the list of all possible divisors
-containing only the first few factors of [[n]]. We then prepend all possible
-divisors containing the new factor [[f]] by multiplying the [[oldList]] with
-all possible positive powers of [[f]].
-
-Up to [[patch--50]] the last line read
-\begin{verbatim}
-    sort(#1 < #2, newList)
-\end{verbatim}
-which fails when [[n]] equals $1$ or $-1$, since in this case %
-[[factors factor n]] returns the empty list, and thus the loop in which
-[[newlist]] is initialised is never entered. (issue 340)
-
-Furthermore, we took the opportunity to make the function slightly more
-efficient. Up to [[patch--50]], we had
-\begin{verbatim}
-    ...
-      newList : List Integer := []
-      for k in 0..f.exponent repeat
-        ...
-\end{verbatim}
-
-Thus, the [[oldList]] was copied element by element every time a new factor was
-added.  Since we \emph{prepend} the new elements of [[newList]], the two list
-can safely share memory.
-
-<<package INTHEORY IntegerNumberTheoryFunctions>>=
   numberOfDivisors n ==
     n = 0 => 0
     */[1+entry.exponent for entry in factors factor n]


============================================================================

--- src/algebra/newdata.spad.pamphlet	2007-04-27 21:29:46.000000000 -0400
+++ /research/may07/build-improvements/src/algebra/newdata.spad.pamphlet	2007-04-27 21:34:07.000000000 -0400
@@ -10,21 +10,6 @@
 \tableofcontents
 \eject
 \section{package IPRNTPK InternalPrintPackage}
-Putting (or omitting) the final call to {\bf FORCE-OUPUT} in {\bf iprint}
-is controversial:
-\begin{verbatim}
-Waldek: iprint is used to print (regular) triangular sets.
-  Unconditional flush defeats buffering optimizations, so IMHO
-  it should be done only for some streams (for example streams
-  connected to terminals).
-  Flushing output should be done when the outupt is complete,
-  while iprint clearly is used to compose bigger units from small parts.
-Tim: unless the princ contains a newline there is no guarantee that
-  the output will appear. if the output is intended to be a prompt,
-  for instance, which does not contain a newline then the flush
-  is needed to force the output to appear.
-  Deleting the call to flush breaks the existing semantics of the package.
-\end{verbatim}
 <<package IPRNTPK InternalPrintPackage>>=
 )abbrev package IPRNTPK InternalPrintPackage
 ++ Author: Themos Tsikas
@@ -49,7 +34,7 @@
   Implementation == add
      iprint(s:String) == 
           PRINC(coerce(s)@Symbol)$Lisp
-          FORCE_-OUTPUT$Lisp
+          FLUSH()$Lisp
 

============================================================================

--- src/algebra/manip.spad.pamphlet	2007-04-27 21:29:46.000000000 -0400
+++ /research/may07/build-improvements/src/algebra/manip.spad.pamphlet	2007-04-27 21:34:07.000000000 -0400
@@ -623,13 +623,10 @@
         -- like to combine it with a log term.
         terms :List F := [simplifyLog(term) for term in termList::List(F)]
         exprs :List F := []
-        nterms :List F := []
-        for term in terms repeat
-          if retractIfCan(term)@Union(FPR,"failed") case FPR then
-            exprs := cons(term, exprs)
-          else
-            nterms := cons(term, nterms)
-        terms := nterms
+        for i in 1..#terms repeat
+          if retractIfCan(terms.i)@Union(FPR,"failed") case FPR then
+            exprs := cons(terms.i,exprs)
+            terms := delete!(terms,i)
         if not empty? exprs then
           foundLog := false
           i : NonNegativeInteger := 0

============================================================================

--- src/algebra/plot.spad.pamphlet	2007-04-27 21:29:46.000000000 -0400
+++ /research/may07/build-improvements/src/algebra/plot.spad.pamphlet	2007-04-27 21:34:07.000000000 -0400
@@ -477,10 +477,9 @@
     myTrap: (F-> F, F) -> F
     myTrap(ff:F-> F, f:F):F ==
       s := trapNumericErrors(ff(f))$Lisp :: Union(F, "failed")
-      s case "failed" => 0
+      s case "failed" => _$NaNvalue$Lisp
       r:F:=s::F
-      r > max()$F => max()$F
-      r < min()$F => min()$F
+      r > max()$F or r < min()$F => _$NaNvalue$Lisp
       r
 
     plot(f:F -> F,xRange:R) ==

============================================================================

Files src/algebra/sttaylor.spad.pamphlet and /research/may07/build-improvements/src/algebra/sttaylor.spad.pamphlet differ
--- src/algebra/sttaylor.spad.pamphlet	2007-04-27 21:29:46.000000000 -0400
+++ /research/may07/build-improvements/src/algebra/sttaylor.spad.pamphlet	2007-04-27 21:34:07.000000000 -0400
@@ -434,8 +434,6 @@
         (ord := (order exquo denom(rn))) case "failed" =>
           error "**: rational power does not exist"
         co := frst x
-        if ord > 0 and rn < 0 then
-           error "**: negative power does not exist" 
         (invCo := recip co) case "failed" =>
            error "** rational power of coefficient undefined"
 -- This error message is misleading, isn't it? see sups.spad/cRationalPower
@@ -450,7 +448,6 @@
 
           RATPOWERS => co**rn * YS(powerrn(rn,(invCo :: A) * x,#1))
           error "** rational power of coefficient undefined"
-        monom(1,(ord :: I) * numer(rn)) * power
 
     if A has Field then
       mapdiv(x,y) == delay

 \section{domain DFLOAT DoubleFloat}
 Greg Vanuxem has added some functionality to allow the user to modify
 the printed format of floating point numbers. The format of the numbers
@@ -422,7 +846,7 @@
          ++ (that is, \spad{|(r-f)/f| < b**(-n)}).
 
  == add
-   format: String := "~A"
+   format: String := "~G"
    MER ==> Record(MANTISSA:Integer,EXPONENT:Integer)
 
    manexp: % -> MER
@@ -481,17 +905,16 @@
      base() = 2 => precision()
      base() = 16 => 4*precision()
      wholePart(precision()*log2(base()::%))::PositiveInteger
-   max()            == MOST_-POSITIVE_-DOUBLE_-FLOAT$Lisp
-   min()            == MOST_-NEGATIVE_-DOUBLE_-FLOAT$Lisp
+   max()            == MOST_-POSITIVE_-LONG_-FLOAT$Lisp
+   min()            == MOST_-NEGATIVE_-LONG_-FLOAT$Lisp
    order(a) == precision() + exponent a - 1
-   0                == FLOAT(0$Lisp,MOST_-POSITIVE_-DOUBLE_-FLOAT$Lisp)$Lisp
-   1                == FLOAT(1$Lisp,MOST_-POSITIVE_-DOUBLE_-FLOAT$Lisp)$Lisp
+   0                == FLOAT(0$Lisp,MOST_-POSITIVE_-LONG_-FLOAT$Lisp)$Lisp
+   1                == FLOAT(1$Lisp,MOST_-POSITIVE_-LONG_-FLOAT$Lisp)$Lisp
    -- rational approximation to e accurate to 23 digits
-   exp1()           == FLOAT(534625820200,MOST_-POSITIVE_-DOUBLE_-FLOAT$Lisp)$Lisp / FLOAT(196677847971,MOST_-POSITIVE_-DOUBLE_-FLOAT$Lisp)$Lisp
+   exp1()           == FLOAT(534625820200,MOST_-POSITIVE_-LONG_-FLOAT$Lisp)$Lisp / FLOAT(196677847971,MOST_-POSITIVE_-LONG_-FLOAT$Lisp)$Lisp
    pi()             == PI$Lisp
    coerce(x:%):OutputForm == 
-     x >= 0 => message(FORMAT(NIL$Lisp,format,x)$Lisp pretend String)
-     - (message(FORMAT(NIL$Lisp,format,-x)$Lisp pretend String))
+     outputForm(FORMAT(NIL$Lisp,format,x)$Lisp pretend DoubleFloat)
    convert(x:%):InputForm == convert(x pretend DoubleFloat)$InputForm
    x < y            == (x<y)$Lisp
    - x              == (-x)$Lisp
@@ -507,7 +930,7 @@
    log10 x          == checkComplex log(x)$Lisp
    x:% ** i:Integer == EXPT(x,i)$Lisp
    x:% ** y:%       == checkComplex EXPT(x,y)$Lisp
-   coerce(i:Integer):% == FLOAT(i,MOST_-POSITIVE_-DOUBLE_-FLOAT$Lisp)$Lisp
+   coerce(i:Integer):% == FLOAT(i,MOST_-POSITIVE_-LONG_-FLOAT$Lisp)$Lisp
    exp x            == EXP(x)$Lisp
    log x            == checkComplex LN(x)$Lisp
    log2 x           == checkComplex LOG2(x)$Lisp
@@ -650,7 +1073,286 @@
       x ** (n::% / d::%)

============================================================================

--- src/algebra/sets.spad.pamphlet	2007-04-27 21:29:46.000000000 -0400
+++ /research/may07/build-improvements/src/algebra/sets.spad.pamphlet	2007-04-27 21:34:07.000000000 -0400
@@ -22,14 +22,14 @@
 ++ Keywords:
 ++ References:
 ++ Description:
-++ A set over a domain S models the usual mathematical notion of a finite set
-++ of elements from S.
+++ A set over a domain D models the usual mathematical notion of a finite set
+++ of elements from D.
 ++ Sets are unordered collections of distinct elements
 ++ (that is, order and duplication does not matter).
 ++ The notation \spad{set [a,b,c]} can be used to create
 ++ a set and the usual operations such as union and intersection are available
 ++ to form new sets.
-++ If S has OrderdSet, \Language{} maintains the entries in
+++ In our implementation, \Language{} maintains the entries in
 ++ sorted order.  Specifically, the parts function returns the entries
 ++ as a list in ascending order and
 ++ the extract operation returns the maximum entry.
@@ -59,6 +59,10 @@
 
    map(f, s) == map_!(f,copy s)
 
+   map_!(f,s) ==
+     map_!(f,s)$Rep
+     removeDuplicates_! s
+
    reduce(f, s) == reduce(f, s)$Rep
 
    reduce(f, s, x) == reduce(f, s, x)$Rep
@@ -75,11 +79,6 @@
      max s == inspect s
      min s == (empty? s => error "Empty set"; s(minIndex s))
 
-     map_!(f,s) ==
-        map_!(f,s)$Rep
-        sort_!(s)$Rep
-        removeDuplicates_! s
-
      construct l ==
        zero?(n := #l) => empty()
        a := new(n, first l)
@@ -188,10 +187,6 @@
           k := inc k
         s
 
-      map_!(f,s) ==
-        map_!(f,s)$Rep
-        removeDuplicates_! s
-

============================================================================

--- src/algebra/polycat.spad.pamphlet	2007-04-27 21:29:46.000000000 -0400
+++ /research/may07/build-improvements/src/algebra/polycat.spad.pamphlet	2007-04-27 21:34:07.000000000 -0400
@@ -162,7 +162,7 @@
        x/r == map(#1/r,x)
     if R has IntegralDomain then
        x exquo r ==
-          zero? r => error "Division by 0"
+          -- probably not a very good definition in most special cases
           zero? x => 0
           ans:% :=0
           t:=leadingCoefficient x exquo r
@@ -568,10 +568,8 @@
         unit(s := squareFree p) * */[f.factor for f in factors s]
       content(p,v) == content univariate(p,v)
       primitivePart p ==
-        zero? p => p
         unitNormal((p exquo content p) ::%).canonical
       primitivePart(p,v) ==
-        zero? p => p
         unitNormal((p exquo content(p,v)) ::%).canonical
     if R has OrderedSet then
       p:% < q:% ==
@@ -608,7 +606,2117 @@
                     p)$PolynomialCategoryLifting(E,VarSet,R,%,InputForm)
 

============================================================================

--- src/algebra/combfunc.spad.pamphlet	2007-04-27 21:29:46.000000000 -0400
+++ /research/may07/build-improvements/src/algebra/combfunc.spad.pamphlet	2007-04-27 21:34:07.000000000 -0400
@@ -1,5 +1,5 @@
 \documentclass{article}
-\usepackage{axiom, amsmath, amsfonts}
+\usepackage{axiom}
 \begin{document}
 \title{\$SPAD/src/algebra combfunc.spad}
 \author{Manuel Bronstein, Martin Rubey}
@@ -88,53 +88,6 @@
     binomial   : (F, F) -> F
       ++ binomial(n, r) returns the number of subsets of r objects
       ++ taken among n objects, i.e. n!/(r! * (n-r)!);
-@
-
-We currently simplify binomial coefficients only for non-negative integral
-second argument, using the formula
-$$ \binom{n}{k}=\frac{1}{k!}\prod_{i=0..k-1} (n-i),$$
-except if the second argument is symbolic: in this case [[binomial(n,n)]] is
-simplified to one.
- 
-Note that there are at least two different ways to define binomial coefficients
-for negative integral second argument. One way, particular suitable for
-combinatorics, is to set the binomial coefficient equal to zero for negative
-second argument. This is, partially, also the approach taken in
-[[combinat.spad]], where we find
-
-\begin{verbatim}
-   binomial(n, m) ==
-      n < 0 or m < 0 or m > n => 0
-      m = 0 => 1
-\end{verbatim}
-
-Of course, here [[n]] and [[m]] are integers. This definition agrees with the
-recurrence
-
-$$\binom{n}{k}+\binom{n}{k+1}=\binom{n+1}{k+1}.$$
-
-Alternatively, one can use the formula
-$$ \binom{n}{k}=\frac{\Gamma(n+1)}{\Gamma(k+1)\Gamma(n-k+1)}, $$
-and leave the case where $k\in\mathbb Z$, $n\in\mathbb Z$ and $k \leq n < 0$
-undefined, since the limit does not exist in this case:
-
-Since we then have that $n-k+1\geq 1$, $\Gamma(n-k+1)$ is finite. So it is
-sufficient to consider $\frac{\Gamma(n+1)}{\Gamma(k+1)}$. On the one hand, we
-have
-$$\lim_{n_0\to n} \lim_{k_0\to k}\frac{\Gamma(n_0+1)}{\Gamma(k_0+1)} = 0,$$
-since for any non-integral $n_0$, $\Gamma(n_0+1)$ is finite. On the other
-hand,
-$$\lim_{k_0\to k} \lim_{n_0\to n}\frac{\Gamma(n_0+1)}{\Gamma(k_0+1)}$$
-does not exist, since for non-integral $k_0$, $\Gamma(k_0+1)$ is finite while
-$\Gamma(n_0+1)$ is unbounded.
-
-However, since for $k\in\mathbb Z$, $n\in\mathbb Z$ and $0 < k < n$ both
-definitions agree, one could also combine them. This is what, for example,
-Mathematica does. It seems that MuPAD sets [[binomial(n,n)=1]] for all
-arguments [[n]], and returns [[binomial(-2, n)]] unevaluated. Provisos may help
-here.
-
-<<package COMBF CombinatorialFunction>>=
     permutation: (F, F) -> F
       ++ permutation(n, r) returns the number of permutations of
       ++ n objects taken r at a time, i.e. n!/(n-r)!;
@@ -569,33 +522,17 @@
 
       if R has RetractableTo(Z) and F has Algebra(Fraction(Z)) then
          iibinom l ==
-           (s:=retractIfCan(second l)@Union(R,"failed")) case R and
-              (t:=retractIfCan(s)@Union(Z,"failed")) case Z and t>0 =>
-                ans:=1::F
-                for i in 0..t-1 repeat
-                    ans:=ans*(first l - i::R::F)
-                (1/factorial t) * ans
            (s:=retractIfCan(first l-second l)@Union(R,"failed")) case R and
-             (t:=retractIfCan(s)@Union(Z,"failed")) case Z and t>0 =>
-                ans:=1::F
-                for i in 1..t repeat
-                    ans:=ans*(second l+i::R::F)
-                (1/factorial t) * ans
+             (t:=retractIfCan(s)@Union(Z,"failed")) case Z and s>0=>
+              ans:=1::F
+              for i in 1..t repeat
+                  ans:=ans*(second l+i::R::F)
+              (1/factorial t) * ans
            (r1 := retractIfCan(first l)@Union(R,"failed")) case "failed" or
              (r2 := retractIfCan(second l)@Union(R,"failed")) case "failed"
                => ibinom l
            binomial(r1::R, r2::R)::F
 
-@
-
-[[iibinom]] checks those cases in which the binomial coefficient may be
-evaluated explicitly. Note that up to [[patch--51]], the case where the second
-argument is a positive integer was not checked.(Issue~\#336) Currently, the
-naive iterative algorithm is used to calculate the coefficient, there is room
-for improvement here.
-
-<<package COMBF CombinatorialFunction>>=
-
       else
          iibinom l ==
            (r1 := retractIfCan(first l)@Union(R,"failed")) case "failed" or


============================================================================

maybe this fixes bug 100?
--- ./defintrf.spad.pamphlet	2007-04-27 21:29:46.000000000 -0400
+++ /research/may07/build-improvements/src/algebra/defintrf.spad.pamphlet	2007-04-27 21:34:07.000000000 -0400
@@ -182,10 +182,7 @@
           ["min"/[t.left for t in l], i.halfinf.endpoint]
         l := [u::REC for t in l | (u := refine(p, t, bounds)) case REC]
         incl? => l
-        -- greg, FIXME dirty workaround
-        -- select_!(keeprec?(i.halfinf.endpoint, #1), l)
-        ep := i.halfinf.endpoint
-        select_!(keeprec?(ep, #1), l)
+        select_!(keeprec?(i.halfinf.endpoint, #1), l)
       error "findRealZero: should not happpen"
 
     checkBudan(p, a, b, incl?) ==

============================================================================

Find who fixes bug 100 in wh-sandbox

============================================================================

Remove any bootstrap code that is not actually needed

============================================================================

fix src/algebra/exprode.spad.pamphlet

    diffRhsK(k, g) ==
      h := univariate(g, k)
      (degree(numer h) <= 1) and ground? denom h =>
        zero? coefficient(numer h, 1) => 
            error "EXPRODE:diffRhsK:Division by zero"
        - coefficient(numer h, 0) / coefficient(numer h, 1)
      error "Improper differential equation"

============================================================================

rewrite trig functions using a simplest notion supplied by user "fructer"

============================================================================

fix file write bug regression result 0 of 0

============================================================================

change )help to 
  (0) handle abbrev and synonym
  (1) show all topics
  (2) use min prefix
  (3) be case sensitive Eg library vs Library
  (4) )help name )function to show the docs on a function
  (5) )view file should fire up a dvi reader on the appropriate dvi file
  (6) create help files on the fly from axiom commands so help
      expands as the user works
  (8) )drag should auto-create help for newly drag-and-dropped files
  (9) )document should update help
 (10) )weave should update help
 (11) )lib should update help
 (12) )co  should update help

============================================================================

make sure that savesystem works

============================================================================

develop a "where" syntax, eg. a_b where a=2 and b=3

============================================================================

get configure from oaxiom, run on mac and windows

============================================================================

document ThreeDimensionalViewport, e.g. to generate pixmaps:
port:=draw(5*besselJ(0,sqrt(x^2+y^2)),x=-20..20,y=-20..20)
drawStyle(port,"shade")
outlineRender(port,"on")
write(port,"temp",["pixmap"])
write(port,"temp1",["postscript"])


============================================================================

document how to document algebra with input files

============================================================================

apply fracas patch 32

============================================================================

(\end occurred inside a group at level 1)

### simple group (level 1) entered at line 17255 ({)
### bottom level
(see the transcript file for additional information)
Output written on book.dvi (1134 pages, 2650492 bytes).

============================================================================

)spool intlf.output
this file should be in REGRESS, not OUTS

============================================================================

special note: 
   compiling exported coerce : String -> $
      FNAME;coerce;S$;4 is replaced by PARSE-NAMESTRING 


============================================================================

remove member function from boot:
 Files /research/may07/wh-sandbox/src/boot/typrops.boot.pamphlet and silver/src/boot/typrops.boot.pamphlet differ

============================================================================

package handling:
 Files /research/may07/wh-sandbox/src/boot/ptyout.boot.pamphlet and silver/src/boot/ptyout.boot.pamphlet differ
 Files /research/may07/wh-sandbox/src/boot/typars.boot.pamphlet and silver/src/boot/typars.boot.pamphlet differ

============================================================================

no idea:
 Files /research/may07/wh-sandbox/src/boot/tytree1.boot.pamphlet and silver/src/boot/tytree1.boot.pamphlet differ
 Files /research/may07/wh-sandbox/src/boot/btscan2.boot.pamphlet and silver/src/boot/btscan2.boot.pamphlet differ
 Files /research/may07/wh-sandbox/src/boot/btpile2.boot.pamphlet and silver/src/boot/btpile2.boot.pamphlet differ

============================================================================

call graph documentation
 Files /research/may07/wh-sandbox/src/boot/btincl2.boot.pamphlet and silver/src/boot/btincl2.boot.pamphlet differ

============================================================================

fix htsearch
 Files /research/may07/wh-sandbox/src/hyper/pages/man0.ht and silver/src/hyper/pages/man0.ht differ

============================================================================

no idea
 Files /research/may07/wh-sandbox/src/hyper/pages/MSET.ht and silver/src/hyper/pages/MSET.ht differ

============================================================================

dead file?
 Only in silver/src/interp: nag-e02b.boot.pamphlet
 Only in silver/src/interp: postprop.lisp.pamphlet

============================================================================

missing $ERASE function?

============================================================================

call to (OBEY "ERASE ... is nonsense

============================================================================

document PLEQN

============================================================================

gclweb latex rewrite
 needs chunk environment
 needs standalone pass

============================================================================

find/fix factor bug
  factor 3474749660383 = 1303 * 2666730361 = 1303 * 16927 * 157543

============================================================================

rewrite graphics
  into single file
  into lisp

============================================================================

rewrite hyperdoc
  into single file
  into lisp

============================================================================

split out X11 functionality 

============================================================================

clean up latex files

============================================================================

check libs
 src/algebra/Makefile libcheck

============================================================================

interp.exposed seems to have disappeared.
 src/interp/exposed.lsp is involved.
 )lisp (libcheck "absolute path to algebra")
 the interp.exposed file is missing from int/algebra
 also fix bookvol4 documentation for this

============================================================================

gclweb weave
  \spadcommand{a+b=c} -> (spadcommand ("a+b=c")

============================================================================

run ./configure everywhere, make new Makefile stanzas

============================================================================

radix(36,37) fails

============================================================================

Jon Claerbout (Stanford University) as quoted in
Buckheit, Jonathan B., Donoho, David L. "WaveLab and Reproducible Research"
http://www.stat.stanford.edu/~donoho/Reports/1995/wavelab.pdf
"An article about computational science in a scientific publication is not the
scholarship itself, it is merely advertising of the scholarship. The actual
scholarship is the complete software development environment and the complete
set of instructions which generated the figures."


============================================================================

   initializing nrlib RPOLCAT- for RecursivePolynomialCategory& 
Warning: RPOLCAT-;exactQuo has a duplicate definition in this file
Warning: RPOLCAT-;ZToR has a duplicate definition in this file
Warning: RPOLCAT-;PZToPR has a duplicate definition in this file

============================================================================

Compiling POLYCAT-.lsp.
Warning: PSETCAT-;exactQuo has a duplicate definition in this file

============================================================================

add Stephen's patch:
 width-fix.patch

============================================================================

Merge Martin's Algebra:
 find Martins algebra examples on the wiki

 SUPEXPR FAMR2 NEWTON UPFS GOPT GUESSF1 UTSSOL FFFG UFPS1 GOPTO EXPRSOL
 FFFGF RECOP GUESS GUESSINT GUESSP GUESSF

 fffg ssolve recop mantepse

 arxiv.org/MartinAlgebra.pdf

============================================================================

asq and databases:
 modify asq to add -csvdump switch which outputs the databases as
 comma separated values

============================================================================

in src/interp/bootlex.lisp the |$PrettyPrint| variable seems to allow
defuns to be prettyprinted.

(defun print-defun (name body)
   (let* ((sp (assoc 'vmlisp::compiler-output-stream vmlisp::optionlist))
	  (st (if sp (cdr sp) *standard-output*)))
     (if (and (is-console st) (symbolp name) (fboundp name)
	      (not (compiled-function-p (symbol-function name))))
	 (compile name))
     (when (or |$PrettyPrint| (not (is-console st)))
	   (print-full body st) (force-output st))))

============================================================================

unused functions in metalex?
-; (trace skip-blanks)
-; (trace get-special-token)
-; (trace token-lookahead-type)
-; (trace make-adjustable-string)
-; (trace print-package)
-; (trace get-number-token)
-
-(trace next-META-line)
-(trace kill-comments)
-(trace kill-trailing-blanks)
-(trace get-META-token)
-(trace get-identifier-token)
-(trace get-string-token)
-(trace get-bstring-token)
-(trace make-defun)
-(trace print-fluids)
-(trace set-prefix)
-(trace print-rule)
-(trace meta-meta-error-handler)

============================================================================

4 arguments instead of 3 in build algebra 

============================================================================

duplicate definition in file
 PSETCAT-;exactQuo 
 SREGSET;decompose
 REGSET;decompose
 PFO;cmult
 RPOLCAT-;exactQuo
 RPOLCAT-;ZToR
 RPOLCAT-;PZToPR

============================================================================

unify
 make tangle accept both syntaxes

============================================================================

sbcl
 port

============================================================================

STRING
.. String of cat 
(|StringCategory|)    has no  hash : % -> Integer 
   finalizing nrlib STRING 
   Processing String for Browser database:
--->/research2/test0819/mnt/fedora5/../../src/algebra/STRING.spad-->String(): Missing Description

============================================================================

Compiling npextras.lisp.
; (DEFUN COMPILER::CMPNOTE ...) is being compiled.
;; Warning: The variable X is not used.
; (IN-PACKAGE 'BOOTTRAN ...) is being compiled.
;; Warning: The package operation (IN-PACKAGE 'BOOTTRAN :USE
                                      '("LISP" "SYSTEM")) was in a bad place.

============================================================================

Compiling ptyout.lisp.
; (DEFUN |bMap1| ...) is being compiled.
;; The variable |bStreamNil| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling btincl2.lisp.
; (DEFUN |shoeFileMap| ...) is being compiled.
;; The variable |bStreamNil| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling btscan2.lisp.
; (DEFUN |shoeConstructToken| ...) is being compiled.
;; Warning: The variable |ln| is not used.
; (DEFUN |shoeNextLine| ...) is being compiled.
;; The variable |shoeTAB| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |shoeLineToks| ...) is being compiled.
;; The variable |shoeCLOSEPAREN| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |shoeToken| ...) is being compiled.
;; The variable |shoeLispESCAPE| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |shoeSPACE| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |shoeSTRINGCHAR| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |shoeESCAPE| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |shoeStartsComment| ...) is being compiled.
;; The variable |shoePLUSCOMMENT| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |shoeStartsNegComment| ...) is being compiled.
;; The variable |shoeMINUSCOMMENT| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |shoeNumber| ...) is being compiled.
;; The variable |shoeDOT| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |shoeExponent| ...) is being compiled.
;; The variable |shoeEXPONENT1| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |shoeEXPONENT2| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |shoeKeyWord| ...) is being compiled.
;; The variable |shoeKeyTable| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |shoeMatch| ...) is being compiled.
;; The variable |shoeDict| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |shoePunctuation| ...) is being compiled.
;; The variable |shoePun| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |shoeKeyTableCons| ...) is being compiled.
;; The variable |shoeKeyWords| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling tyextra.lisp.
; (DEFUN |bfStruct| ...) is being compiled.
;; Warning: The variable |name| is not used.

============================================================================

Compiling tytree1.lisp.
; (DEFUN |bfMDef| ...) is being compiled.
;; Warning: The variable |defOp| is not used.

============================================================================

Compiling /research2/test0819/obj/fedora5/interp/postpar.lsp.
; (DEFUN |postError| ...) is being compiled.
;; The variable |$defOp| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |postCategory| ...) is being compiled.
;; The variable |$insidePostCategoryIfTrue| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |postDef| ...) is being compiled.
;; The variable |$maxSignatureLineNumber| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$docList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$headerDocumentation| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |postIf| ...) is being compiled.
;; Warning: The variable |x| is not used.

============================================================================

Compiling /research2/test0819/obj/fedora5/interp/parse.lsp.
; (DEFUN |parseType| ...) is being compiled.
;; The variable |$oldParserExpandAbbrs| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |parseTypeError| ...) is being compiled.
;; The variable |$op| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |x| is not used.
; (DEFUN |specialModeTran| ...) is being compiled.
;; The variable |$QuotientField| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |parseTranCheckForRecord| ...) is being compiled.
;; Warning: The variable |op| is not used.
; (DEFUN |transCategoryItem| ...) is being compiled.
;; The variable |$transCategoryAssoc| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/obj/fedora5/interp/parsing.lsp.
; (DEFUN ESCAPE-KEYWORDS ...) is being compiled.
;; The variable KEYWORDS is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN /EMBED-Q ...) is being compiled.
;; The variable /EMBEDNAMES is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN IOCLEAR ...) is being compiled.
;; Warning: The variable IN is not used.
;; Warning: The variable OUT is not used.

============================================================================

Compiling /research2/test0819/obj/fedora5/interp/metalex.lsp.
; (DEFUN MAKE-DEFUN ...) is being compiled.
;; The variable META_PREFIX is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/obj/fedora5/interp/bootlex.lsp.
; (DEFUN INIT-BOOT/SPAD-READER ...) is being compiled.
;; The variable SPADERRORSTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN SPAD_SYNTAX_ERROR ...) is being compiled.
;; Warning: The variable BYEBYE is not used.

============================================================================

Compiling /research2/test0819/obj/fedora5/interp/newaux.lsp.
; (DEFUN SPECIALCASESYNTAX ...) is being compiled.
;; The variable TOK is undefined.
;; The compiler will assume this variable is a global.
;; The variable CHR is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/obj/fedora5/interp/preparse.lsp.
; (DEFUN PREPARSE ...) is being compiled.
;; The variable $COMBLOCKLIST is undefined.
;; The compiler will assume this variable is a global.
;; The variable $SKIPME is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$headerDocumentation| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$docList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$maxSignatureLineNumber| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$constructorLineNumber| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN PREPARSE-ECHO ...) is being compiled.
;; Warning: The variable LINELIST is not used.

============================================================================

Compiling /research2/test0819/obj/fedora5/interp/def.lsp.
; (DEFUN B-MDEF ...) is being compiled.
;; Warning: The variable X is not used.
; (DEFUN DEF-INNER ...) is being compiled.
;; Warning: The variable SIGNATURE is not used.

============================================================================

Compiling /research2/test0819/obj/fedora5/interp/clam.lsp.
; (DEFUN |consForHashLookup| ...) is being compiled.
;; The variable |$hashNode| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |mkCircularCountAlist| ...) is being compiled.
;; The variable |$reportFavoritesIfNumber| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |remHashEntriesWith0Count,fn| ...) is being compiled.
;; The variable |$hashTable| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |remHashEntriesWith0Count| ...) is being compiled.
;; The variable |remHashEntriesWith0Count,fn| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |initCache| ...) is being compiled.
;; The variable |$failed| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |addToSlam| ...) is being compiled.
;; The variable |$mutableDomain| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |recordInstantiation1| ...) is being compiled.
;; The variable |$insideCoerceInteractive| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$instantCoerceCount| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$insideCanCoerceFrom| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$instantCanCoerceCount| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$insideEvalMmCondIfTrue| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$instantMmCondCount| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |listTruncate| ...) is being compiled.
;; The variable |$op| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/obj/fedora5/interp/slam.lsp.
; (DEFUN |reportFunctionCompilation| ...) is being compiled.
;; The variable |$compiledOpNameList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$minivectorNames| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$compilingInputFile| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$minivectorCode| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$minivector| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$compileRecurrence| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |mkCircularAlist| ...) is being compiled.
;; The variable |$failed| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compileRecurrenceRelation| ...) is being compiled.
;; The variable |$TriangleVariableList| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |junk| is not used.
; (DEFUN |clearAllSlams,fn| ...) is being compiled.
;; The variable |$functorDependencyAlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFMACRO |clearSlam| ...) is being compiled.
;; Warning: The variable #:G2668 is not used.

============================================================================

Compiling /research2/test0819/obj/fedora5/interp/g-boot.lsp.
; (DEFUN |bootAbsorbSEQsAndPROGNs,flatten| ...) is being compiled.
;; The variable |$labelsForGO| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |defLetForm| ...) is being compiled.
;; The variable $LET is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |defLET1| ...) is being compiled.
;; The variable |$letGenVarCounter| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |defLET2| ...) is being compiled.
;; The variable |$inDefIS| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |defIS1| ...) is being compiled.
;; The variable |$inDefLET| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$isGenVarCounter| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/obj/fedora5/interp/c-util.lsp.
; (DEFUN |continue| ...) is being compiled.
;; The variable |$x| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$m| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$f| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |level| ...) is being compiled.
;; The variable |$level| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |displayComp| ...) is being compiled.
;; The variable |$bright| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$dim| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$op| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$s| is undefined.
;; The compiler will assume this variable is a global.
;; The variable $X is undefined.
;; The compiler will assume this variable is a global.
;; The variable $M is undefined.
;; The compiler will assume this variable is a global.
;; The variable $F is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |intersectionContour,modeCompare| ...) is being compiled.
;; The variable |$var| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |isAlmostSimple,setAssignment| ...) is being compiled.
;; The variable |$assignmentList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |stackSemanticError| ...) is being compiled.
;; The variable |$initCapsuleErrorCount| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |stackMessage| ...) is being compiled.
;; The variable |$compErrorMessageStack| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |?modemaps| ...) is being compiled.
;; The variable |$CapsuleModemapFrame| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |traverse,traverseInner| ...) is being compiled.
;; The variable |$seen| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$notseen| is undefined.
;; The compiler will assume this variable is a global.
;; The variable SET-PA-SPEC is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/obj/fedora5/interp/g-util.lsp.
; (DEFUN |reshape| ...) is being compiled.
;; Warning: The variable |b| is not used.
; (DEFUN |update| ...) is being compiled.
;; The variable /VERSION is undefined.
;; The compiler will assume this variable is a global.
;; The variable /WSNAME is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |spadThrow| ...) is being compiled.
;; The variable |$interpOnly| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$mapName| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |semchkProplist| ...) is being compiled.
;; Warning: The variable |val| is not used.
; (DEFUN |leftTrim| ...) is being compiled.
;; The variable |$blank| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/vmlisp.lisp.
; (DEFUN UNEMBED ...) is being compiled.
;; Warning: The variable #:G163615 is not used.
;; Warning: The variable #:G163896 is not used.
; (IN-PACKAGE 'BOOT) is being compiled.
;; Warning: The package operation (IN-PACKAGE 'BOOT) was in a bad place.

============================================================================

Compiling /research2/test0819/int/interp/macros.lisp.
; (DEFUN |sayTeX| ...) is being compiled.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |sayMSG2File| ...) is being compiled.
;; The variable |$listingDirectory| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN BLANKS ...) is being compiled.
;; Warning: Type declaration was found for not bound variable N.
; (DEFUN EVAL-DEFUN ...) is being compiled.
;; Warning: The variable NAME is not used.
; (DEFMACRO WI ...) is being compiled.
;; Warning: The variable A is not used.
; (DEFUN MARKHASH ...) is being compiled.
;; The variable HT is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/unlisp.lisp.
; (DEFMACRO |CatchAsCan| ...) is being compiled.
;; Warning: The variable TAGVAR is not used.

============================================================================

Compiling /research2/test0819/int/interp/buildom.clisp.
; (DEFUN |MappingEqual| ...) is being compiled.
;; Warning: The variable |dom| is not used.
; (DEFUN |MappingPrint| ...) is being compiled.
;; Warning: The variable |dom| is not used.
; (DEFUN |coerceMap2E| ...) is being compiled.
;; The variable |$testingSystem| is undefined.
;; The compiler will assume this variable is a global.
; (DEFMACRO |Enumeration| ...) is being compiled.
;; Warning: The variable #:G154733 is not used.
; (DEFUN |EnumEqual| ...) is being compiled.
;; Warning: The variable |dom| is not used.
; (DEFMACRO |RecordCategory| ...) is being compiled.
;; Warning: The variable #:G154763 is not used.
; (DEFMACRO |EnumerationCategory| ...) is being compiled.
;; Warning: The variable #:G154770 is not used.
; (DEFMACRO |UnionCategory| ...) is being compiled.
;; Warning: The variable #:G154777 is not used.
; (DEFUN |mkMappingFunList| ...) is being compiled.
;; Warning: The variable |mapForm| is not used.

============================================================================

Compiling /research2/test0819/int/interp/cattable.clisp.
; (DEFUN |showCategoryTable| ...) is being compiled.
;; The variable *HASCATEGORY-HASH* is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |displayCategoryTable| ...) is being compiled.
;; The variable |$ct| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |genCategoryTable| ...) is being compiled.
;; The variable *ANCESTORS-HASH* is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$nonLisplibDomains| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$noCategoryDomains| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |simpHasPred,simp| ...) is being compiled.
;; The variable |$hasArgs| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |simpHasAttribute| ...) is being compiled.
;; The variable |$domain| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$predvec| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |moreGeneralCategoryPredicate| ...) is being compiled.
;; Warning: The variable |id| is not used.
; (DEFUN |catPairUnion| ...) is being compiled.
;; Warning: The variable |op| is not used.
;; Warning: The variable |cat| is not used.
; (DEFUN |categoryParts,exportsOf| ...) is being compiled.
;; The variable |$conslist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |categoryParts,build| ...) is being compiled.
;; The variable |$oplist| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$attrlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |categoryParts| ...) is being compiled.
;; The variable |$TriangleVariableList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compressSexpr| ...) is being compiled.
;; The variable |$found| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |updateCategoryTable| ...) is being compiled.
;; The variable |$newcompMode| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NRTflag| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |updateCategoryTableForDomain| ...) is being compiled.
;; The variable |$doNotCompressHashTableIfTrue| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |clearCategoryTable1| ...) is being compiled.
;; The variable |$cname| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |val| is not used.

============================================================================

Compiling /research2/test0819/int/interp/cformat.clisp.
; (DEFUN |%id| ...) is being compiled.
;; The variable IDENTITY is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/clam.clisp.
; (DEFUN |consForHashLookup| ...) is being compiled.
;; The variable |$hashNode| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |mkCircularCountAlist| ...) is being compiled.
;; The variable |$reportFavoritesIfNumber| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |remHashEntriesWith0Count,fn| ...) is being compiled.
;; The variable |$hashTable| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |remHashEntriesWith0Count| ...) is being compiled.
;; The variable |remHashEntriesWith0Count,fn| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |initCache| ...) is being compiled.
;; The variable |$failed| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |addToSlam| ...) is being compiled.
;; The variable |$mutableDomain| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |recordInstantiation1| ...) is being compiled.
;; The variable |$insideCoerceInteractive| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$instantCoerceCount| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$insideCanCoerceFrom| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$instantCanCoerceCount| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$insideEvalMmCondIfTrue| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$instantMmCondCount| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |listTruncate| ...) is being compiled.
;; The variable |$op| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/clammed.clisp.
; (DEFUN |canCoerceFrom| ...) is being compiled.
;; The variable |canCoerceFrom;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |canCoerce| ...) is being compiled.
;; The variable |canCoerce;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |coerceConvertMmSelection| ...) is being compiled.
;; The variable |coerceConvertMmSelection;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |hasFileProperty| ...) is being compiled.
;; The variable |hasFileProperty;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |isValidType| ...) is being compiled.
;; The variable |isValidType;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |isValidType;| ...) is being compiled.
;; The variable |$QuotientField| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |selectMms1| ...) is being compiled.
;; The variable |selectMms1;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |resolveTT| ...) is being compiled.
;; The variable |resolveTT;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |isLegitimateMode| ...) is being compiled.
;; The variable |isLegitimateMode;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |underDomainOf| ...) is being compiled.
;; The variable |underDomainOf;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/comp.lisp.
; (DEFUN |compQuietly| ...) is being compiled.
;; The variable |$compileDontDefineFunctions| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dropInputLibrary| ...) is being compiled.
;; The variable INPUT-LIBRARIES is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |openOutputLibrary| ...) is being compiled.
;; The variable OUTPUT-LIBRARY is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN COMP-NEWNAM ...) is being compiled.
;; The variable $CLOSEDFNS is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/compress.clisp.
; (DEFUN |minimalise,HashCheck| ...) is being compiled.
;; The variable |$hash| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/cstream.clisp.
; (DEFUN |incRgen1| ...) is being compiled.
;; The variable |StreamNil| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/database.clisp.
; (DEFUN |augLisplibModemapsFromCategory| ...) is being compiled.
;; The variable |$domainShell| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |buildDatabase| ...) is being compiled.
;; The variable |$constructorList| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |filemode| is not used.
;; Warning: The variable |expensive| is not used.
; (DEFUN |saveUsersHashTable| ...) is being compiled.
;; The variable |$usersTb| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |saveDependentsHashTable| ...) is being compiled.
;; The variable |$depTb| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |getSystemModemaps| ...) is being compiled.
;; The variable |$getUnexposedOperations| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |updateDatabase| ...) is being compiled.
;; The variable |$newcompMode| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |fname| is not used.
; (DEFUN |addCoreModemap| ...) is being compiled.
;; Warning: The variable |cname| is not used.
; (DEFUN |isExposedConstructor| ...) is being compiled.
;; The variable |$localExposureData| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$globalExposureGroupAlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |displayExposedGroups| ...) is being compiled.
;; The variable |$interpreterFrameName| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/debug.lisp.
; (DEFMACRO |/C,LIB| ...) is being compiled.
;; Warning: The variable $REPORTCOMPILATION is not used.
; (DEFUN /D-1 ...) is being compiled.
;; The variable /FN is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN /D-2 ...) is being compiled.
;; The variable |$sourceFiles| is undefined.
;; The compiler will assume this variable is a global.
;; The variable /EDITFILE is undefined.
;; The compiler will assume this variable is a global.
;; The variable /ECHO is undefined.
;; The compiler will assume this variable is a global.
;; The variable $PRETTYPRINT is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable W is not used.
;; Warning: The variable FILE is not used.
;; Warning: The variable X is not used.
; (DEFUN /INITUPDATES ...) is being compiled.
;; The variable FILENAME is undefined.
;; The compiler will assume this variable is a global.
;; The variable /UPDATESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN /UPDATE ...) is being compiled.
;; The variable /VERSION is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN /WRITEUPDATE ...) is being compiled.
;; The variable DATETIME is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable ORECNO is not used.
;; Warning: The variable RECNO is not used.
;; Warning: The variable KEY is not used.
;; Warning: The variable IFT is not used.
;; Warning: The variable FTYPE is not used.
;; Warning: The variable OP is not used.
; (DEFUN |getDateAndTime| ...) is being compiled.
;; Warning: The variable SEC is not used.
; (DEFUN MONITOR-GETVALUE ...) is being compiled.
;; The variable /VALUE is undefined.
;; The compiler will assume this variable is a global.
;; The variable /CALLER is undefined.
;; The compiler will assume this variable is a global.
;; The variable /ARGS is undefined.
;; The compiler will assume this variable is a global.
;; The variable /NAME is undefined.
;; The compiler will assume this variable is a global.
; (DEFMACRO /UNEMBED ...) is being compiled.
;; The variable /EMBEDNAMES is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN /MONITORX ...) is being compiled.
;; Warning: The variable CURDEPTH is not used.
; (DEFUN BPITRACE ...) is being compiled.
;; The variable NEWNAME is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN LISP-BREAK-FROM-AXIOM ...) is being compiled.
;; Warning: The variable IGNORE is not used.
; (DEFUN INTERRUPT ...) is being compiled.
;; Warning: The variable IGNORE is not used.

============================================================================

Compiling /research2/test0819/int/interp/format.clisp.
; (DEFUN |formatOperation| ...) is being compiled.
;; The variable |Undef| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$commentedOps| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |constructorName| ...) is being compiled.
;; The variable |$abbreviateTypes| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |formWrapId| ...) is being compiled.
;; The variable |$formatSigAsTeX| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |formArguments2String,fn| ...) is being compiled.
;; The variable |$OutputForm| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |formDecl2String| ...) is being compiled.
;; The variable |$permitWhere| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |formJoin1| ...) is being compiled.
;; The variable |$abbreviateJoin| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$declVar| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |tuple2String| ...) is being compiled.
;; Warning: The variable |x| is not used.

============================================================================

Compiling /research2/test0819/int/interp/g-boot.clisp.
; (DEFUN |bootAbsorbSEQsAndPROGNs,flatten| ...) is being compiled.
;; The variable |$labelsForGO| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |defLetForm| ...) is being compiled.
;; The variable $LET is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |defLET1| ...) is being compiled.
;; The variable |$letGenVarCounter| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |defLET2| ...) is being compiled.
;; The variable |$inDefIS| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |defIS1| ...) is being compiled.
;; The variable |$inDefLET| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$isGenVarCounter| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/g-cndata.clisp.
; (DEFUN |mkLowerCaseConTable| ...) is being compiled.
;; The variable |$lowerCaseConTb| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |attribute?| ...) is being compiled.
;; The variable *ATTRIBUTES* is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |installConstructor| ...) is being compiled.
;; Warning: The variable |type| is not used.
; (DEFUN |constructorAbbreviationErrorCheck| ...) is being compiled.
;; Warning: The variable |errmess| is not used.
; (DEFUN |abbreviationError| ...) is being compiled.
;; Warning: The variable |abb| is not used.
; (DEFUN |condAbbrev| ...) is being compiled.
;; Warning: The variable |arg| is not used.

============================================================================

Compiling /research2/test0819/int/interp/g-error.clisp.
; (DEFUN |argumentDataError| ...) is being compiled.
;; The variable |$AlgebraError| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |errorSupervisor1| ...) is being compiled.
;; The variable |$SystemError| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$UserError| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |returnToTopLevel| ...) is being compiled.
;; The variable CHR is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |returnToReader| ...) is being compiled.
;; The variable |$ReadingFile| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |sayErrorly| ...) is being compiled.
;; The variable |$saturn| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |saturnSayErrorly| ...) is being compiled.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |sayErrorly1| ...) is being compiled.
;; The variable |$testingSystem| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$testingErrorPrefix| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |throwMessage| ...) is being compiled.
;; The variable |$mapName| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$printMsgsToFile| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/g-opt.clisp.
; (DEFUN |optimizeFunctionDef| ...) is being compiled.
;; The variable |$reportOptimization| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |optCallSpecially| ...) is being compiled.
;; The variable |$optimizableConstructorNames| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$getDomainCode| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |q| is not used.
; (DEFUN |EqualBarGensym,fn| ...) is being compiled.
;; The variable |$GensymAssoc| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/g-timer.clisp.
; (DEFUN |peekTimedName| ...) is being compiled.
;; The variable |$timedNameStack| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |makeLongTimeString| ...) is being compiled.
;; The variable |$printTimeIfTrue| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |makeLongSpaceString| ...) is being compiled.
;; The variable |$printStorageIfTrue| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |computeElapsedTime| ...) is being compiled.
;; The variable |$oldElapsedGCTime| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$oldElapsedTime| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |computeElapsedSpace| ...) is being compiled.
;; The variable |$oldElapsedSpace| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |timedOptimization| ...) is being compiled.
;; The variable |$reportOptimization| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/g-util.clisp.
; (DEFUN |reshape| ...) is being compiled.
;; Warning: The variable |b| is not used.
; (DEFUN |update| ...) is being compiled.
;; The variable /VERSION is undefined.
;; The compiler will assume this variable is a global.
;; The variable /WSNAME is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |spadThrow| ...) is being compiled.
;; The variable |$interpOnly| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$mapName| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |semchkProplist| ...) is being compiled.
;; Warning: The variable |val| is not used.
; (DEFUN |leftTrim| ...) is being compiled.
;; The variable |$blank| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |isDomain| ...) is being compiled.
;; The variable |$domainTypeTokens| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/gclweb.lisp.
; (DEFUN ISCHUNK-LATEX ...) is being compiled.
;; Warning: The variable POSTLINE is not used.
;; Warning: The variable PRELINE is not used.
;; Warning: The variable LEN is not used.

============================================================================

Compiling /research2/test0819/int/interp/ggreater.lisp.
; (DEFUN LEXVGREATERP ...) is being compiled.
;; Warning: The default value of NIL is not FIXNUM.
;; Warning: The default value of NIL is not FIXNUM.
;; Warning: The default value of NIL is not FIXNUM.
; (DEFUN VGREATERP ...) is being compiled.
;; Warning: The default value of NIL is not FIXNUM.
;; Warning: The default value of NIL is not FIXNUM.
;; Warning: The default value of NIL is not FIXNUM.

============================================================================

Compiling /research2/test0819/int/interp/hypertex.clisp.
; (DEFUN |issueHT| ...) is being compiled.
;; The variable |$MenuServer| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$SendLine| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |endHTPage| ...) is being compiled.
;; The variable |$EndOfPage| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |replaceNamedHTPage| ...) is being compiled.
;; The variable |$PageStuff| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$currentFrameNum| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$ReplaceNamedPage| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |startHTPopUpPage| ...) is being compiled.
;; The variable |$PopUpPage| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |startHTPage| ...) is being compiled.
;; The variable |$StartPage| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |startReplaceHTPage| ...) is being compiled.
;; The variable |$ReplacePage| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |killHTPage| ...) is being compiled.
;; The variable |$KillPage| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |linkToHTPage| ...) is being compiled.
;; The variable |$LinkToPage| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |popUpNamedHTPage| ...) is being compiled.
;; The variable |$PopUpNamedPage| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |sendHTErrorSignal| ...) is being compiled.
;; The variable |$SpadError| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/i-analy.clisp.
; (DEFUN |getBasicMode| ...) is being compiled.
;; The variable |$useIntegerSubdomain| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |getBasicMode0| ...) is being compiled.
;; The variable |$DoubleFloat| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |getMinimalVariableTower| ...) is being compiled.
;; The variable |$univariateDomains| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$multivariateDomains| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |polyVarlist| ...) is being compiled.
;; The variable |$QuotientField| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |pushDownTargetInfo| ...) is being compiled.
;; The variable |$OutputForm| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$Any| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$immediateDataSymbol| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |bottomUp| ...) is being compiled.
;; The variable |$localVars| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |bottomUpDefaultCompile| ...) is being compiled.
;; Warning: The variable |isSub| is not used.
; (DEFUN |interpRewriteRule| ...) is being compiled.
;; Warning: The variable |expr| is not used.
; (DEFUN |bottomUpForm| ...) is being compiled.
;; The variable |$inRetract| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |bottomUpFormTuple| ...) is being compiled.
;; Warning: The variable |t| is not used.
;; Warning: The variable |argModeSetList| is not used.
; (DEFUN |printableArgModeSetList| ...) is being compiled.
;; The variable |$origArgModeSetList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |bottomUpForm0| ...) is being compiled.
;; The variable |$HTCompanionWindowID| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/i-code.clisp.
; (DEFUN |intCodeGenCOERCE| ...) is being compiled.
;; The variable |$mapName| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$OutputForm| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |wrapMapBodyWithCatch| ...) is being compiled.
;; The variable |$mapThrowCount| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/i-coerce.clisp.
; (DEFUN |retract1| ...) is being compiled.
;; The variable |$SingleInteger| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |retract2Specialization| ...) is being compiled.
;; The variable |$Any| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$QuotientField| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |coerceRetract| ...) is being compiled.
;; The variable |$OutputForm| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$coerceFailure| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |canCoerceTopMatching| ...) is being compiled.
;; The variable |$univariateDomains| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$multivariateDomains| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |canCoerceLocal| ...) is being compiled.
;; The variable |$CoerceTable| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |canCoerceCommute| ...) is being compiled.
;; The variable |$CommuteTable| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |canConvertByFunction| ...) is being compiled.
;; The variable |$useConvertForCoercions| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |coerceInteractive| ...) is being compiled.
;; The variable |$mapName| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |coerceInt1| ...) is being compiled.
;; The variable |$AnonymousFunction| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |getSubDomainPredicate| ...) is being compiled.
;; The variable |$superHash| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/i-coerfn.clisp.
; (DEFUN |Expr2Complex| ...) is being compiled.
;; The variable |$DoubleFloat| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN I2EI ...) is being compiled.
;; Warning: The variable |source| is not used.
;; Warning: The variable |target| is not used.
; (DEFUN I2OI ...) is being compiled.
;; Warning: The variable |source| is not used.
;; Warning: The variable |target| is not used.
; (DEFUN I2PI ...) is being compiled.
;; Warning: The variable |source| is not used.
;; Warning: The variable |target| is not used.
; (DEFUN I2NNI ...) is being compiled.
;; Warning: The variable |source| is not used.
;; Warning: The variable |target| is not used.
; (DEFUN OV2SE ...) is being compiled.
;; Warning: The variable |target| is not used.
; (DEFUN |OV2Sy| ...) is being compiled.
;; Warning: The variable |target| is not used.
; (DEFUN |Rn2F| ...) is being compiled.
;; Warning: The variable |source| is not used.
;; Warning: The variable |target| is not used.
; (DEFUN |Qf2domain| ...) is being compiled.
;; The variable |$QuotientField| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |Sy2OV| ...) is being compiled.
;; Warning: The variable |source| is not used.
; (DEFUN |Sy2Var| ...) is being compiled.
;; Warning: The variable |source| is not used.
; (DEFUN |commuteComplex| ...) is being compiled.
;; Warning: The variable |source| is not used.
; (DEFUN |commuteQuaternion| ...) is being compiled.
;; Warning: The variable |source| is not used.
; (DEFUN |commuteFraction| ...) is being compiled.
;; Warning: The variable |source| is not used.
; (DEFUN |commuteSparseUnivariatePolynomial| ...) is being compiled.
;; Warning: The variable |source| is not used.

============================================================================

Compiling /research2/test0819/int/interp/i-eval.clisp.
; (DEFUN |evaluateType1| ...) is being compiled.
;; Warning: The variable |x| is not used.
;; Warning: The variable |m| is not used.
; (DEFUN |throwEvalTypeMsg| ...) is being compiled.
;; The variable |$noEvalTypeMsg| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |evalForm| ...) is being compiled.
;; The variable |$localVars| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NRTmonitorIfTrue| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |getMappingArgValue| ...) is being compiled.
;; Warning: The variable |t| is not used.
; (DEFUN |getArgValueComp| ...) is being compiled.
;; The variable |$mapName| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |failCheck| ...) is being compiled.
;; The variable |$coerceFailure| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/i-funsel.clisp.
; (DEFUN |selectMms| ...) is being compiled.
;; The variable |$AnonymousFunction| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |defaultTarget| ...) is being compiled.
;; The variable |$DoubleFloat| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$Any| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$QuotientField| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |defaultTargetFE| ...) is being compiled.
;; The variable |$FunctionalExpression| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |getLocalMms| ...) is being compiled.
;; The variable |$useIntegerSubdomain| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$Coerce| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |mmCost0| ...) is being compiled.
;; Warning: The variable |name| is not used.
; (DEFUN |getFunctionFromDomain| ...) is being compiled.
;; The variable |$nonLisplibDomains| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |allOrMatchingMms| ...) is being compiled.
;; Warning: The variable |tar| is not used.
; (DEFUN |findFunctionInDomain1| ...) is being compiled.
;; The variable |$SubDom| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |matchMmSig| ...) is being compiled.
;; The variable $RTC is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |selectMmsGen,exact?| ...) is being compiled.
;; Warning: The variable |tar| is not used.
; (DEFUN |selectMmsGen,matchMms| ...) is being compiled.
;; The variable |$Subst| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |matchTypes| ...) is being compiled.
;; The variable |$SymbolType| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |t1| is not used.
; (DEFUN |evalMmFreeFunction| ...) is being compiled.
;; Warning: The variable |op| is not used.
;; Warning: The variable |mmC| is not used.
; (DEFUN |evalMmCat| ...) is being compiled.
;; Warning: The variable |sig| is not used.
; (DEFUN |evalMmCat1| ...) is being compiled.
;; The variable |$hope| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |hasCateSpecialNew| ...) is being compiled.
;; The variable |$ComplexInteger| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |hasCaty| ...) is being compiled.
;; The variable |$domPvar| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/bookvol5.lsp.
; (DEFUN |addNewInterpreterFrame| ...) is being compiled.
;; The variable |$interpreterFrameRing| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |changeHistListLen| ...) is being compiled.
;; The variable |$HistListLen| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$HistList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$HistListAct| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |closeInterpreterFrame| ...) is being compiled.
;; The variable |$interpreterFrameName| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |createCurrentInterpreterFrame| ...) is being compiled.
;; The variable |$HistRecord| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$internalHistoryTable| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$localExposureData| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dewritify,dewritifyInner| ...) is being compiled.
;; The variable |$seen| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NullStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NonNullStream| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |emptyInterpreterFrame| ...) is being compiled.
;; The variable |$localExposureDataDefault| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |frameSpad2Cmd| ...) is being compiled.
;; The variable |$options| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN GETENVIRON ...) is being compiled.
;; The variable VAR is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable SHELLVAR is not used.
; (DEFUN INITROOT ...) is being compiled.
;; The variable $SPADROOT is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |removeUndoLines| ...) is being compiled.
;; Warning: The variable Y is not used.
; (DEFUN REROOT ...) is being compiled.
;; The variable |$defaultMsgDatabaseName| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$msgDatabaseName| is undefined.
;; The compiler will assume this variable is a global.
;; The variable $CURRENT-DIRECTORY is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN RESTART ...) is being compiled.
;; The variable |$displayStartMsgs| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |runspad| ...) is being compiled.
;; The variable |$quitTag| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |undoSteps| ...) is being compiled.
;; Warning: The variable FRAMELIST is not used.
; (DEFUN |updateFromCurrentInterpreterFrame| ...) is being compiled.
;; The variable |$frameMessages| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |updateHist| ...) is being compiled.
;; The variable |$mkTestInputStack| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |writifyComplain| ...) is being compiled.
;; The variable |$writifyComplained| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |writeInputLines| ...) is being compiled.
;; The variable UNDERBAR is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable VEC is not used.

============================================================================

Compiling /research2/test0819/int/interp/i-intern.clisp.
; (DEFUN |mkAtreeWithSrcPos| ...) is being compiled.
;; The variable |$useParserSrcPos| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |transferSrcPosInfo| ...) is being compiled.
;; The variable |$transferParserSrcPos| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |mkAtree1| ...) is being compiled.
;; The variable |$immediateDataSymbol| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |transferPropsToNode,transfer| ...) is being compiled.
;; The variable |$localVars| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |atree2Tree1| ...) is being compiled.
;; The variable |$OutputForm| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$mapName| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |get1| ...) is being compiled.
;; The variable |$CapsuleModemapFrame| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |get2| ...) is being compiled.
;; Warning: The variable |e| is not used.
; (DEFUN |objEnv| ...) is being compiled.
;; Warning: The variable |obj| is not used.

============================================================================

Compiling /research2/test0819/int/interp/i-map.clisp.
; (DEFUN |makeInternalMapName| ...) is being compiled.
;; The variable |$interpreterFrameRing| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$specialMapNameSuffix| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |addDefMap| ...) is being compiled.
;; The variable |$mapName| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |addMap| ...) is being compiled.
;; Warning: The variable |x| is not used.
; (DEFUN |sayDroppingFunctions| ...) is being compiled.
;; The variable |$displayDroppedMap| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |mkFormalArg| ...) is being compiled.
;; The variable |$sl| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |clearDependencies| ...) is being compiled.
;; Warning: The variable |clearLocalModemapsIfTrue| is not used.
; (DEFUN |displayRule| ...) is being compiled.
;; Warning: The variable |op| is not used.
; (DEFUN |outputFormat| ...) is being compiled.
;; The variable |$OutputForm| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |analyzeMap| ...) is being compiled.
;; The variable |$analyzingMapList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |analyzeMap0| ...) is being compiled.
;; The variable |$mapList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compFailure| ...) is being compiled.
;; The variable |$useCoerceOrCroak| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$reportInterpOnly| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |interpMap| ...) is being compiled.
;; The variable |$timedNameStack| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |analyzeDeclaredMap| ...) is being compiled.
;; The variable |$mapTarget| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |genMapCode| ...) is being compiled.
;; The variable |$whereCacheList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$localVars| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compileCoerceMap| ...) is being compiled.
;; The variable |$minivectorNames| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$compilingInputFile| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$minivectorCode| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$minivector| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |analyzeNonRecursiveMap| ...) is being compiled.
;; The variable |$mapThrowCount| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |mkLocalVar| ...) is being compiled.
;; Warning: The variable |op| is not used.
; (DEFUN |isFreeVar| ...) is being compiled.
;; The variable |$freeVars| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |mkFreeVar| ...) is being compiled.
;; Warning: The variable |op| is not used.

============================================================================

Compiling /research2/test0819/int/interp/i-output.clisp.
; (DEFUN |specialChar| ...) is being compiled.
;; The variable |$specialCharacterAlist| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$specialCharacters| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |appChar| ...) is being compiled.
;; The variable |$highlightDelta| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |mathprint| ...) is being compiled.
;; The variable |$saturn| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |outputTran| ...) is being compiled.
;; The variable |$DoubleFloat| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$fractionDisplayType| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |outputMapTran| ...) is being compiled.
;; The variable |$op| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |mkSuperSub| ...) is being compiled.
;; The variable |$linearFormatScripts| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |appSum| ...) is being compiled.
;; Warning: The variable |arg| is not used.
; (DEFUN |isRationalNumber| ...) is being compiled.
;; Warning: The variable |x| is not used.
; (DEFUN |widthSC| ...) is being compiled.
;; Warning: The variable |u| is not used.
; (DEFUN |maprin| ...) is being compiled.
;; The variable |$demoFlag| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |maprinChk| ...) is being compiled.
;; The variable |$MatrixList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$collectOutput| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |PushMatrix| ...) is being compiled.
;; The variable |$MatrixCount| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |overbarApp| ...) is being compiled.
;; The variable UNDERBAR is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |concatTrouble,fixUp| ...) is being compiled.
;; The variable |$addBlankIfTrue| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |formulaFormat| ...) is being compiled.
;; The variable |$OutputForm| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |texFormat| ...) is being compiled.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |mathmlFormat| ...) is being compiled.
;; The variable |$mathmlOutputStream| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |output| ...) is being compiled.
;; The variable |$mathmlFormat| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |outputNumber| ...) is being compiled.
;; The variable |$outputLines| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |charyTop| ...) is being compiled.
;; The variable |$testOutputLineFlag| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$testOutputLineList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |charySemiColon| ...) is being compiled.
;; Warning: The variable |v| is not used.
; (DEFUN |charyMinus| ...) is being compiled.
;; Warning: The variable |u| is not used.
; (DEFUN |charyBinary| ...) is being compiled.
;; Warning: The variable |u| is not used.
; (DEFUN |charyEquatnum| ...) is being compiled.
;; Warning: The variable |v| is not used.
; (DEFUN |eq0| ...) is being compiled.
;; Warning: The variable |u| is not used.
; (DEFUN |nothingWidth| ...) is being compiled.
;; Warning: The variable |x| is not used.
; (DEFUN |nothingSuper| ...) is being compiled.
;; Warning: The variable |x| is not used.
; (DEFUN |nothingSub| ...) is being compiled.
;; Warning: The variable |x| is not used.
; (DEFUN |nothingApp| ...) is being compiled.
;; Warning: The variable |u| is not used.
;; Warning: The variable |x| is not used.
;; Warning: The variable |y| is not used.
; (DEFUN |remWidth| ...) is being compiled.
;; The variable |remWidth| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |transcomparg| ...) is being compiled.
;; The variable STANDARGLIST is undefined.
;; The compiler will assume this variable is a global.
;; The variable FRLIS* is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |maPrin| ...) is being compiled.
;; The variable |$runTestFlag| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$mkTestFlag| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$mkTestOutputStack| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/i-resolv.clisp.
; (DEFUN |resolveTypeListAny| ...) is being compiled.
;; The variable |$Any| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |acceptableTypesToResolve1| ...) is being compiled.
;; The variable |$DoubleFloat| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$QuotientField| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |resolveTTRed1| ...) is being compiled.
;; The variable |$Res| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |getConditionalCategoryOfType1| ...) is being compiled.
;; The variable |$TriangleVariableList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |resolveTM1| ...) is being compiled.
;; The variable |$Subst| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$Coerce| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |resolveTMTaggedUnion| ...) is being compiled.
;; Warning: The variable |t| is not used.
; (DEFUN |resolveTMSpecial| ...) is being compiled.
;; The variable |$AnonymousFunction| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |resolveTMEq2| ...) is being compiled.
;; Warning: The variable |cm| is not used.
; (DEFUN |resolveTMRed| ...) is being compiled.
;; The variable |$ResMode| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |constructM| ...) is being compiled.
;; The variable |$FunctionalExpression| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/i-spec1.clisp.
; (DEFUN |evalUntargetedADEF| ...) is being compiled.
;; The variable |$AnonymousFunction| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |types| is not used.
; (DEFUN |evalTargetedADEF| ...) is being compiled.
;; The variable |$anonymousMapCounter| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |mkInterpTargetedADEF| ...) is being compiled.
;; The variable |$mapName| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compileADEFBody| ...) is being compiled.
;; The variable |$compiledOpNameList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$minivectorNames| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$compilingInputFile| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$minivectorCode| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$minivector| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$freeVariables| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$boundVariables| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |upAlgExtension| ...) is being compiled.
;; The variable |$printTypeIfTrue| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |upTARGET| ...) is being compiled.
;; The variable |$localVars| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |upCOLLECT| ...) is being compiled.
;; The variable |$compilingLoop| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |upCOLLECT1| ...) is being compiled.
;; The variable |$interpOnly| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |falseFun| ...) is being compiled.
;; Warning: The variable |x| is not used.
; (DEFUN |interpIter| ...) is being compiled.
;; The variable |$indexVars| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$indexTypes| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |interpCOLLECTbodyIter| ...) is being compiled.
;; The variable |$collectTypeList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |collectOneStream| ...) is being compiled.
;; Warning: The variable |t| is not used.
; (DEFUN |collectSeveralStreams| ...) is being compiled.
;; Warning: The variable |t| is not used.
; (DEFUN |mkAndApplyZippedPredicates| ...) is being compiled.
;; The variable |$indexList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |mkIterZippedFun| ...) is being compiled.
;; The variable |$index| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |indexList| is not used.
; (DEFUN |replaceSymbols| ...) is being compiled.
;; The variable |$declaredMode| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |upNullList| ...) is being compiled.
;; Warning: The variable |l| is not used.
; (DEFUN |replaceSharps| ...) is being compiled.
;; The variable |$TriangleVariableList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |containsPolynomial| ...) is being compiled.
;; The variable |$univariateDomains| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$multivariateDomains| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/i-spec2.clisp.
; (DEFUN |upDollar| ...) is being compiled.
;; The variable |$localVars| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$immediateDataSymbol| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$OutputForm| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |uperror| ...) is being compiled.
;; The variable |$mapName| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |upfreeWithType| ...) is being compiled.
;; Warning: The variable |type| is not used.
; (DEFUN |uplocalWithType| ...) is being compiled.
;; Warning: The variable |type| is not used.
; (DEFUN |compileIF| ...) is being compiled.
;; The variable |$declaredMode| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |cond| is not used.
; (DEFUN |evalIF| ...) is being compiled.
;; The variable |$lastLineInSEQ| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |evalis| ...) is being compiled.
;; The variable |$opIsIs| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |evalIsPredicate| ...) is being compiled.
;; Warning: The variable |mode| is not used.
; (DEFUN |isPatMatch| ...) is being compiled.
;; The variable |$subs| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |upiterate| ...) is being compiled.
;; The variable |$repeatBodyLabel| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$iterateCount| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |upbreak| ...) is being compiled.
;; The variable |$repeatLabel| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$breakCount| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |getInterpMacroNames| ...) is being compiled.
;; The variable |$InterpreterMacroAlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |isInterpMacro| ...) is being compiled.
;; The variable |$specialOps| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |upREPEAT| ...) is being compiled.
;; The variable |$compilingLoop| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |upREPEAT1| ...) is being compiled.
;; The variable |$interpOnly| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |upreturn| ...) is being compiled.
;; The variable |$mapTarget| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$mapThrowCount| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |upNullTuple| ...) is being compiled.
;; Warning: The variable |l| is not used.

============================================================================

Compiling /research2/test0819/int/interp/i-syscmd.clisp.
; (DEFUN |initializeSystemCommands| ...) is being compiled.
;; The variable $SYSCOMMANDS is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |abbreviationsSpad2Cmd| ...) is being compiled.
;; The variable |$options| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |clearSpad2Cmd| ...) is being compiled.
;; The variable |$clearOptions| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |clearCmdCompletely| ...) is being compiled.
;; The variable |$localExposureData| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$localExposureDataDefault| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$xdatabase| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$CatOfCatDatabase| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$DomOfCatDatabase| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$JoinOfCatDatabase| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$JoinOfDomDatabase| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$attributeDb| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$functionTable| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$existingFiles| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |clearCmdAll| ...) is being compiled.
;; The variable |$variableNumberAlist| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$internalHistoryTable| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$frameMessages| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$interpreterFrameName| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |queryClients| ...) is being compiled.
;; The variable |$SessionManager| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$QueryClients| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |close| ...) is being compiled.
;; The variable |$saturn| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$CloseClient| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$currentFrameNum| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |args| is not used.
; (DEFUN |constructor| ...) is being compiled.
;; Warning: The variable |args| is not used.
; (DEFUN |compiler| ...) is being compiled.
;; The variable /EDITFILE is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compileAsharpCmd1| ...) is being compiled.
;; The variable |$asharpCmdlineFlags| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$newConlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compileAsharpArchiveCmd| ...) is being compiled.
;; The variable $CURRENT-DIRECTORY is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |summary| ...) is being compiled.
;; Warning: The variable |l| is not used.
; (DEFUN |credits| ...) is being compiled.
;; The variable CREDITS is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |displaySpad2Cmd| ...) is being compiled.
;; The variable |$displayOptions| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |clearParserMacro| ...) is being compiled.
;; The variable |$pfMacros| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |interpFunctionDepAlists| ...) is being compiled.
;; The variable |$dependentAlist| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$dependeeAlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |fixObjectForPrinting| ...) is being compiled.
;; The variable |$msgdbPrims| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |displayType| ...) is being compiled.
;; Warning: The variable |omitVariableNameIfTrue| is not used.
; (DEFUN |newHelpSpad2Cmd| ...) is being compiled.
;; The variable |$useFullScreenHelp| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |loadSpad2Cmd| ...) is being compiled.
;; Warning: The variable |args| is not used.
; (DEFUN |quitSpad2Cmd| ...) is being compiled.
;; The variable |$quitCommandType| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |reportOpsFromUnitDirectly0| ...) is being compiled.
;; The variable |$useEditorForShowOutput| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |reportOpsFromUnitDirectly1| ...) is being compiled.
;; The variable |$listingDirectory| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |reportOpsFromUnitDirectly| ...) is being compiled.
;; The variable |$showOptions| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |synonymSpad2Cmd| ...) is being compiled.
;; The variable |$CommandSynonymAlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |whatSpad2Cmd| ...) is being compiled.
;; The variable |$whatOptions| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |workfilesSpad2Cmd| ...) is being compiled.
;; The variable |$sourceFiles| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |zsystemdevelopment1| ...) is being compiled.
;; The variable /VERSION is undefined.
;; The compiler will assume this variable is a global.
;; The variable /WSNAME is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |processSynonyms| ...) is being compiled.
;; The variable CHR is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |tabsToBlanks| ...) is being compiled.
;; The variable |$charTab| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$charBlank| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |npboot| ...) is being compiled.
;; The variable |$ans| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |npsynonym| ...) is being compiled.
;; Warning: The variable |unab| is not used.
; (DEFUN |tokenSystemCommand| ...) is being compiled.
;; Warning: The variable |unabr| is not used.
; (DEFUN |handleParsedSystemCommands| ...) is being compiled.
;; Warning: The variable |unabr| is not used.
; (DEFUN |parseFromString| ...) is being compiled.
;; The variable |$useNewParser| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/i-toplev.clisp.
; (DEFUN |start| ...) is being compiled.
;; The variable |$displayStartMsgs| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$interpreterTimedNames| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$interpreterTimedClasses| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$ruleSetsInitialized| is undefined.
;; The compiler will assume this variable is a global.
;; The variable $SPADROOT is undefined.
;; The compiler will assume this variable is a global.
;; The variable $CURRENT-DIRECTORY is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$superHash| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |readSpadProfileIfThere| ...) is being compiled.
;; The variable /EDITFILE is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |processInteractive| ...) is being compiled.
;; The variable |$defaultFortVar| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$ProcessInteractiveValue| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |recordAndPrint| ...) is being compiled.
;; The variable |$printAnyIfTrue| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$printVoidIfTrue| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$collectOutput| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$QuietCommand| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$printTimeIfTrue| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$printTypeIfTrue| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$printStorageIfTrue| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$printStatisticsSummaryIfTrue| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$HTCompanionWindowID| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$mkTestFlag| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$runTestFlag| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$mkTestOutputType| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |printTypeAndTime| ...) is being compiled.
;; The variable |$saturn| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |printTypeAndTimeNormal| ...) is being compiled.
;; The variable |$outputLines| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |printTypeAndTimeSaturn| ...) is being compiled.
;; Warning: The variable |x| is not used.
; (DEFUN |printAsTeX| ...) is being compiled.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |interpretTopLevel| ...) is being compiled.
;; The variable |$timedNameStack| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |interpret1| ...) is being compiled.
;; The variable |$eval| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |interpret2| ...) is being compiled.
;; Warning: The variable |posnForm| is not used.

============================================================================

Compiling /research2/test0819/int/interp/i-util.clisp.
; (DEFUN MKPROMPT ...) is being compiled.
;; The variable |$interpreterFrameName| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |Zeros| ...) is being compiled.
;; The variable |$ZeroVecCache| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |variableNumber| ...) is being compiled.
;; The variable |$variableNumberAlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |newType?| ...) is being compiled.
;; Warning: The variable |t| is not used.
; (DEFUN |Undef| ...) is being compiled.
;; The variable |Undef| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |addModemap| ...) is being compiled.
;; The variable |$CapsuleModemapFrame| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |orderUnionEntries| ...) is being compiled.
;; The variable |$newCompilerUnionFlag| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/incl.clisp.
; (DEFUN |incStringStream| ...) is being compiled.
;; The variable |Top| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |incClassify| ...) is being compiled.
;; The variable |incCommands| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |incLude1| ...) is being compiled.
;; The variable |StreamNil| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |fn| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |IfSkipToEnd| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |IfKeepPart| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |IfSkipPart| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |ElseifKeepPart| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |ElseifSkipPart| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |ElseifSkipToEnd| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |ElseKeepPart| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |ElseSkipToEnd| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |inclHandleBug| ...) is being compiled.
;; Warning: The variable |pos| is not used.

============================================================================

Compiling /research2/test0819/int/interp/int-top.clisp.
; (DEFUN |intloopSpadProcess| ...) is being compiled.
;; The variable TAGVAR is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |phIntReportMsgs| ...) is being compiled.
;; Warning: The variable |interactive?| is not used.
; (DEFUN |incString| ...) is being compiled.
;; The variable |Top| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/lisplib.clisp.
; (DEFUN |hasFilePropertyNoCache| ...) is being compiled.
;; Warning: The variable |abbrev| is not used.
; (DEFUN |loadLibNoUpdate| ...) is being compiled.
;; Warning: The variable |libName| is not used.
; (DEFUN |autoLoad| ...) is being compiled.
;; Warning: The variable |abb| is not used.
; (DEFUN |compileConstructorLib| ...) is being compiled.
;; The variable /FN is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compConLib1| ...) is being compiled.
;; The variable /EDITFILE is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$listingDirectory| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compDefineLisplib| ...) is being compiled.
;; The variable |$compileDocumentation| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$libraryDirectory| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$newConlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |initializeLisplib| ...) is being compiled.
;; The variable ERRORS is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$lisplibAbbreviation| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$lisplibAncestors| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$lisplibOpAlist| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$lisplibSuperDomain| is undefined.
;; The compiler will assume this variable is a global.
;; The variable /MAJOR-VERSION is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |finalizeLisplib| ...) is being compiled.
;; The variable |$lisplibCategory| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$lisplibAttributes| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$lisplibPredicates| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$lisplibParents| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$lisplibSlot1| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$profileCompiler| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |transformOperationAlist| ...) is being compiled.
;; The variable |$functionLocations| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |getSlotFromDomain| ...) is being compiled.
;; The variable |Undef| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/match.clisp.
; (DEFUN |patternCheck,subWild| ...) is being compiled.
;; The variable |$oldWild| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$wildCard| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/msg.clisp.
; (DEFUN |putDatabaseStuff| ...) is being compiled.
;; The variable |aL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |posPointers| ...) is being compiled.
;; The variable |getMsgFTTag| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |setMsgCatlessAttr| ...) is being compiled.
;; The variable |catless| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/msgdb.clisp.
; (DEFUN |substituteSegmentedMsg| ...) is being compiled.
;; The variable |$texFormatting| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |noBlankBeforeP| ...) is being compiled.
;; The variable |$msgdbNoBlanksBeforeGroup| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$msgdbListPrims| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |noBlankAfterP| ...) is being compiled.
;; The variable |$msgdbNoBlanksAfterGroup| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |throwPatternMsg| ...) is being compiled.
;; The variable |$testingSystem| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$testingErrorPrefix| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |sayKeyedMsgLocal| ...) is being compiled.
;; The variable |$displayMsgNumber| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$printMsgsToFile| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |throwKeyedMsg| ...) is being compiled.
;; The variable |$saturn| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |saturnThrowKeyedMsg| ...) is being compiled.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |pushSatOutput| ...) is being compiled.
;; The variable |$saturnMode| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |returnStLFromKey| ...) is being compiled.
;; The variable |$msgDatabaseName| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |keyedMsgCompFailure| ...) is being compiled.
;; The variable |$useCoerceOrCroak| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$Coerce| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$reportInterpOnly| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |throwKeyedMsgCannotCoerceWithValue| ...) is being compiled.
;; The variable |$OutputForm| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |spadStartUpMsgs| ...) is being compiled.
;; The variable *BUILD-VERSION* is undefined.
;; The compiler will assume this variable is a global.
;; The variable *YEARWEEK* is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$opSysName| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$msgAlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |brightPrint0| ...) is being compiled.
;; The variable $MARG is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |escapeSpecialChars| ...) is being compiled.
;; The variable |$htCharAlist| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$htSpecialChars| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/nci.lisp.
; (DEFUN |clearMacroTable| ...) is being compiled.
;; The variable |$pfMacros| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/newfort.clisp.
; (DEFUN |newFortranTempVar| ...) is being compiled.
;; The variable |$exp2FortTempVarIndex| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$defaultFortranType| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |exp2FortOptimize| ...) is being compiled.
;; The variable |$fortranOptimizationLevel| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |beenHere| ...) is being compiled.
;; The variable |$fortCsList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |exp2FortOptimizeCS1,pushCsStacks| ...) is being compiled.
;; The variable |$fortCsExprStack| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$fortCsFuncStack| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |exp2FortOptimizeCS1,popCsStacks| ...) is being compiled.
;; Warning: The variable |x| is not used.
; (DEFUN |exp2FortOptimizeCS1| ...) is being compiled.
;; The variable |$fortCsHash| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |exp2FortOptimizeArray| ...) is being compiled.
;; The variable |$fortName| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$exprStack| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |fortran2Lines1| ...) is being compiled.
;; The variable |$fortIndent| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$fortLength| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |fortError1| ...) is being compiled.
;; The variable |$fortError| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |exp2FortSpecial| ...) is being compiled.
;; The variable |$fortranArrayStartingIndex| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |fortranifyIntrinsicFunctionName| ...) is being compiled.
;; The variable |$useIntrinsicFunctions| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$intrinsics| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$fortranPrecision| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |indentFortLevel| ...) is being compiled.
;; The variable |$maximumFortranExpressionLength| is undefined.
;; The compiler will assume this variable is a global.
; (DEFMACRO |changeExprLength| ...) is being compiled.
;; Warning: The variable #:G155164 is not used.
; (DEFMACRO |nameLen| ...) is being compiled.
;; Warning: The variable #:G155334 is not used.
; (DEFUN |currentSP| ...) is being compiled.
;; The variable |$currentSubprogram| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |fortPre1| ...) is being compiled.
;; The variable |$fortInts2Floats| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |segment| ...) is being compiled.
;; The variable |$fortranSegment| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/nrunfast.clisp.
; (DEFUN |initNewWorld| ...) is being compiled.
;; The variable |$NRTflag| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NRTvec| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NRTmakeCompactDirect| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NRTquick| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NRTmakeShortDirect| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$newWorld| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$monitorNewWorld| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NRTmonitorIfTrue| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$doNotCompressHashTableIfTrue| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |replaceGoGetSlot| ...) is being compiled.
;; The variable |$returnNowhereFromGoGet| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |newLookupInTable| ...) is being compiled.
;; The variable |$lookupDefaults| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |opIsHasCat| ...) is being compiled.
;; The variable |$hasCatOpHash| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |hashNewLookupInTable| ...) is being compiled.
;; The variable |$hashOp1| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$hashOp0| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |hashNewLookupInCategories| ...) is being compiled.
;; The variable |$Slot1DataBase| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |getNewDefaultPackage| ...) is being compiled.
;; The variable |packageVec| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |catVec| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |dom| is not used.
;; Warning: The variable |dollar| is not used.
; (DEFUN |lazyMatchArg2| ...) is being compiled.
;; The variable |$isDefaultingPackage| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |newExpandGoGetTypeSlot| ...) is being compiled.
;; Warning: The variable |dollar| is not used.
; (DEFUN |sigDomainVal| ...) is being compiled.
;; Warning: The variable |dollar| is not used.

============================================================================

Compiling /research2/test0819/int/interp/nrungo.clisp.
; (DEFUN |basicLookup| ...) is being compiled.
;; The variable |$hashOp0| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$hashOp1| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$hashOpApply| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$hashOpSet| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$hashSeg| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |basicLookupCheckDefaults| ...) is being compiled.
;; The variable |$lookupDefaults| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |domain| is not used.
; (DEFUN |lookupInTable| ...) is being compiled.
;; The variable |$predVector| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |lookupInCategories| ...) is being compiled.
;; The variable |$Slot1DataBase| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NRTcompileEvalForm| ...) is being compiled.
;; The variable |$insideCompileBodyIfTrue| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NRTgetMinivectorIndex| ...) is being compiled.
;; The variable |$minivector| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$compilingInputFile| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$minivectorCode| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |mkDiffAssoc| ...) is being compiled.
;; The variable |$TriangleVariableList| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/nrunopt.clisp.
; (DEFUN |getInfovecCode| ...) is being compiled.
;; The variable |$template| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NRTslot1Info| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$lookupFunction| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |makeDomainTemplate| ...) is being compiled.
;; The variable |$byteVec| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |makeGoGetSlot| ...) is being compiled.
;; The variable |$byteAddress| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |makeCompactDirect| ...) is being compiled.
;; The variable |$NRTslot1PredicateList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |makeCompactDirect1,fn| ...) is being compiled.
;; The variable |$isOpPackageName| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |makeCompactDirect1| ...) is being compiled.
;; The variable |$byteVecAcc| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |orderBySubsumption| ...) is being compiled.
;; The variable |$op| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NRTgenInitialAttributeAlist| ...) is being compiled.
;; The variable |$lisplibAttributes| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$pairlis| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NRTgenFinalAttributeAlist| ...) is being compiled.
;; The variable |$NRTattributeAlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |makePredicateBitVector| ...) is being compiled.
;; The variable |$insideCategoryPackageIfTrue| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$categoryPredicateList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$predGensymAlist| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$lisplibPredicates| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |augmentPredCode| ...) is being compiled.
;; The variable $ is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NRTmakeCategoryAlist| ...) is being compiled.
;; The variable |$uncondAlist| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$condAlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NRTcatCompare| ...) is being compiled.
;; The variable |$levelAlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |depthAssoc| ...) is being compiled.
;; The variable |$depthAssocCache| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |getCodeVector| ...) is being compiled.
;; The variable |$infovec| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dcOpTable| ...) is being compiled.
;; Warning: The variable |i| is not used.
; (DEFUN |dcOpPrint| ...) is being compiled.
;; The variable |$predvec| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |extendsCategory| ...) is being compiled.
;; The variable |$why| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |templateVal| ...) is being compiled.
;; Warning: The variable |domform| is not used.

============================================================================

Compiling /research2/test0819/int/interp/nruntime.clisp.
; (DEFUN |lookupDisplay| ...) is being compiled.
;; The variable |$NRTmonitorIfTrue| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/pathname.clisp.
; (DEFUN |makePathname| ...) is being compiled.
;; Warning: The variable |dir| is not used.
; (DEFUN |isSystemDirectory| ...) is being compiled.
;; The variable $SPADROOT is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |updateSourceFiles| ...) is being compiled.
;; The variable |$sourceFiles| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/ptrees.clisp.
; (DEFUN |pfCheckInfop| ...) is being compiled.
;; Warning: The variable |form| is not used.
; (DEFUN |pfHide| ...) is being compiled.
;; Warning: The variable |a| is not used.
; (DEFUN |pfParen| ...) is being compiled.
;; Warning: The variable |a| is not used.

============================================================================

Compiling /research2/test0819/int/interp/record.clisp.
; (DEFUN |inputFile2RecordFile| ...) is being compiled.
;; The variable |$testStream| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |recordAndPrintTest| ...) is being compiled.
;; The variable |$mkTestOutputStack| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$mkTestInputStack| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/rulesets.clisp.
; (DEFUN |createResolveTTRules| ...) is being compiled.
;; The variable |$mpolyTTRules| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$Res| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$nameList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$abList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$generalTTRules| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |createResolveTMRules| ...) is being compiled.
;; The variable |$mpolyTMRules| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$ResMode| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$generalTMRules| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |createTypeEquivRules| ...) is being compiled.
;; The variable |$TypeEQ| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$TypeEqui| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |initializeRuleSets| ...) is being compiled.
;; The variable |$newResolveAbbreviations| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$ruleSetsInitialized| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/scan.clisp.
; (DEFUN |scanIgnoreLine| ...) is being compiled.
;; The variable CLOSEPAREN is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |scanToken| ...) is being compiled.
;; The variable QUESTION is undefined.
;; The compiler will assume this variable is a global.
;; The variable SPACE is undefined.
;; The compiler will assume this variable is a global.
;; The variable STRINGCHAR is undefined.
;; The compiler will assume this variable is a global.
;; The variable ESCAPE is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |constoken| ...) is being compiled.
;; Warning: The variable |ln| is not used.
; (DEFUN |startsComment?| ...) is being compiled.
;; The variable PLUSCOMMENT is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |startsNegComment?| ...) is being compiled.
;; The variable MINUSCOMMENT is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |scanCloser?| ...) is being compiled.
;; The variable |scanCloser| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |scanNumber| ...) is being compiled.
;; The variable RADIXCHAR is undefined.
;; The compiler will assume this variable is a global.
;; The variable DOT is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |scanExponent| ...) is being compiled.
;; The variable EXPONENT1 is undefined.
;; The compiler will assume this variable is a global.
;; The variable EXPONENT2 is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |keyword| ...) is being compiled.
;; The variable |scanKeyTable| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |subMatch| ...) is being compiled.
;; The variable |scanDict| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |scanKeyTableCons| ...) is being compiled.
;; The variable |scanKeyWords| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |punctuation?| ...) is being compiled.
;; The variable |scanPun| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/server.clisp.
; (DEFUN |serverReadLine| ...) is being compiled.
;; The variable |$EndServerSession| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NeedToSignalSessionManager| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$SessionManager| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$EndOfOutput| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$CallInterp| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$CreateFrame| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$frameAlist| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$frameNumber| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$currentFrameNum| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$CreateFrameAnswer| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$SwitchFrames| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$EndSession| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$LispCommand| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$sockBufferLength| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$MenuServer| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$QuietSpadCommand| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$SpadCommand| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NonSmanSession| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$KillLispSystem| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |parseAndInterpret| ...) is being compiled.
;; The variable |$useNewParser| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |serverLoop| ...) is being compiled.
;; The variable |$Prompt| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/setvars.clisp.
; (DEFUN |resetWorkspaceVariables| ...) is being compiled.
;; The variable /EDITFILE is undefined.
;; The compiler will assume this variable is a global.
;; The variable /SOURCEFILES is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$sourceFiles| is undefined.
;; The compiler will assume this variable is a global.
;; The variable /SPACELIST is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$existingFiles| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$functionTable| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$echoLineStack| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$CommandSynonymAlist| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$InitialCommandSynonymAlist| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$UserAbbreviationsAlist| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$msgAlist| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$msgDatabase| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$msgDatabaseName| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$dependeeClosureAlist| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$coerceIntByMapCounter| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$setOptions| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |set1| ...) is being compiled.
;; The variable |$displaySetValue| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |setAsharpArgs| ...) is being compiled.
;; The variable |$asharpCmdlineFlags| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |setInputLibrary| ...) is being compiled.
;; The variable INPUT-LIBRARIES is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |setOutputLibrary| ...) is being compiled.
;; Warning: The variable |fn| is not used.
;; Warning: The variable |arg| is not used.
; (DEFUN |setExposeAddGroup| ...) is being compiled.
;; The variable |$globalExposureGroupAlist| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$localExposureData| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$interpreterFrameName| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |x| is not used.
; (DEFUN |setExposeAddConstr| ...) is being compiled.
;; Warning: The variable |x| is not used.
; (DEFUN |setExposeDropGroup| ...) is being compiled.
;; Warning: The variable |x| is not used.
; (DEFUN |setExposeDropConstr| ...) is being compiled.
;; Warning: The variable |x| is not used.
; (DEFUN |setFortTmpDir| ...) is being compiled.
;; The variable |$fortranTmpDir| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |setFortDir| ...) is being compiled.
;; The variable |$fortranDirectory| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |setLinkerArgs| ...) is being compiled.
;; The variable |$fortranLibraries| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |countCache| ...) is being compiled.
;; The variable |$options| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |setNagHost| ...) is being compiled.
;; The variable |$nagHost| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |setFortPers| ...) is being compiled.
;; The variable |$fortPersistence| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |setOutputAlgebra| ...) is being compiled.
;; The variable |$algebraOutputFile| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |setOutputCharacters| ...) is being compiled.
;; The variable |$specialCharacters| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$plainRTspecialCharacters| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$RTspecialCharacters| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$specialCharacterAlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |setOutputFortran| ...) is being compiled.
;; The variable |$fortranOutputFile| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |setOutputMathml| ...) is being compiled.
;; The variable |$mathmlOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$mathmlOutputFile| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$mathmlFormat| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |setOutputOpenMath| ...) is being compiled.
;; The variable |$openMathOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$openMathOutputFile| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$openMathFormat| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |setOutputFormula| ...) is being compiled.
;; The variable |$formulaOutputFile| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |setOutputTex| ...) is being compiled.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputFile| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/sfsfun.clisp.
; (DEFUN |logH| ...) is being compiled.
;; Warning: The variable |z| is not used.
; (DEFUN |BesselIBackRecur| ...) is being compiled.
;; Warning: The variable |largev| is not used.

============================================================================

Compiling /research2/test0819/int/interp/slam.clisp.
; (DEFUN |reportFunctionCompilation| ...) is being compiled.
;; The variable |$compiledOpNameList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$minivectorNames| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$compilingInputFile| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$minivectorCode| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$minivector| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$compileRecurrence| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |mkCircularAlist| ...) is being compiled.
;; The variable |$failed| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compileRecurrenceRelation| ...) is being compiled.
;; The variable |$TriangleVariableList| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |junk| is not used.
; (DEFUN |clearAllSlams,fn| ...) is being compiled.
;; The variable |$functorDependencyAlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFMACRO |clearSlam| ...) is being compiled.
;; Warning: The variable #:G154929 is not used.

============================================================================

Compiling /research2/test0819/int/interp/spad.lisp.
; (DEFUN |traceComp| ...) is being compiled.
;; The variable $X is undefined.
;; The compiler will assume this variable is a global.
;; The variable $M is undefined.
;; The compiler will assume this variable is a global.
;; The variable $F is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN SPAD-MDTR-2 ...) is being compiled.
;; The variable $DOMVAR is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN READLISP ...) is being compiled.
;; Warning: The variable V is not used.
; (DEFUN TERSYSCOMMAND ...) is being compiled.
;; The variable CHR is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN /READ ...) is being compiled.
;; The variable /EDITFILE is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN /FLAG ...) is being compiled.
;; Warning: The variable X is not used.
;; The variable X is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN S-PROCESS ...) is being compiled.
;; The variable $TRACEFLAG is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$Translation| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |New,ENTRY1| ...) is being compiled.
;; Warning: The variable SPADERRORSTREAM is not used.
; (DEFUN |New,ENTRY,1| ...) is being compiled.
;; The variable SYNTAX_ERROR is undefined.
;; The compiler will assume this variable is a global.
;; The variable COLUMN is undefined.
;; The compiler will assume this variable is a global.
;; The variable SINGLINEMODE is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable STACKX is not used.
;; Warning: The variable STACK is not used.
;; Warning: The variable BACK is not used.
;; Warning: The variable CHR is not used.
;; Warning: The variable NBLNK is not used.
;; Warning: The variable ISID is not used.
;; Warning: The variable OK is not used.
;; Warning: The variable SINGLELINEMODE is not used.
;; Warning: The variable ZZ is not used.
; (DEFUN |New,ENTRY,2| ...) is being compiled.
;; The variable $PREVIOUSTIME is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable RULE is not used.
;; Warning: The variable FN is not used.
; (DEFUN NEW-LEXPR1 ...) is being compiled.
;; The variable STACK is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN PARSERSTATE ...) is being compiled.
;; The variable NBLNK is undefined.
;; The compiler will assume this variable is a global.
;; The variable ISID is undefined.
;; The compiler will assume this variable is a global.
;; The variable STACKX is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |boot2Lisp| ...) is being compiled.
;; The variable S-SPADKEY is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable CHR is not used.
;; Warning: The variable SPADERRORSTREAM is not used.
;; Warning: The variable COLUMN is not used.
;; Warning: The variable COMMENTCHR is not used.
;; Warning: The variable *PROMPT* is not used.
; (DEFUN /FOOBAR ...) is being compiled.
;; The variable $LASTCXARG is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable $XCOUNT is not used.
; (DEFUN FOOBAR ...) is being compiled.
;; Warning: The variable X is not used.
; (DEFUN |/tb| ...) is being compiled.
;; Warning: The variable $PRETTYPRINT is not used.
; (DEFUN |boot2LispError| ...) is being compiled.
;; The variable OK is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/template.clisp.
; (DEFUN |putPredHash| ...) is being compiled.
;; The variable |$predHash| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$predVectorFrontier| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$predVector| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |mkSigPredVectors| ...) is being compiled.
;; The variable |$consDB| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NRTdescendCodeTran| ...) is being compiled.
;; The variable |$template| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |measure| ...) is being compiled.
;; The variable |SparseUnivariatePolynomial;| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |SparseUnivariatePolynomial;opDirect| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |SparseUnivariatePolynomial;template| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |measureCommon,fn| ...) is being compiled.
;; The variable HASH is undefined.
;; The compiler will assume this variable is a global.
;; The variable TABLE is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$table| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/trace.clisp.
; (DEFUN |trace1| ...) is being compiled.
;; The variable |$options| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |saveMapSig| ...) is being compiled.
;; The variable |$tracedMapSignatures| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |getTraceOption| ...) is being compiled.
;; The variable |$traceOptionList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |resetSpacers| ...) is being compiled.
;; The variable /SPACELIST is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |stackTraceOptionError| ...) is being compiled.
;; The variable |$traceErrorStack| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |coerceTraceArgs2E| ...) is being compiled.
;; The variable |$OutputForm| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |traceName| is not used.
; (DEFUN |augmentTraceNames| ...) is being compiled.
;; Warning: The variable |mapSubNames| is not used.
; (DEFMACRO |funfind| ...) is being compiled.
;; Warning: The variable #:G155259 is not used.
; (DEFUN |traceDomainLocalOps| ...) is being compiled.
;; Warning: The variable |dom| is not used.
;; Warning: The variable |lops| is not used.
;; Warning: The variable |options| is not used.
; (DEFUN |untraceDomainLocalOps| ...) is being compiled.
;; The variable |abb| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |dom| is not used.
;; Warning: The variable |lops| is not used.
; (DEFUN |untraceAllDomainLocalOps| ...) is being compiled.
;; Warning: The variable |dom| is not used.
; (DEFUN |addTraceItem| ...) is being compiled.
;; The variable |$constructors| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$domains| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$packages| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |?t| ...) is being compiled.
;; Warning: The variable |x| is not used.
; (DEFUN |break| ...) is being compiled.
;; The variable /BREAKCONDITION is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/daase.lisp.
; (DEFUN |library| ...) is being compiled.
;; The variable ORIGINAL-DIRECTORY is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN WRITE-COMPRESS ...) is being compiled.
;; The variable *ATTRIBUTES* is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/fortcall.clisp.
; (DEFUN |makeFort1| ...) is being compiled.
;; The variable |$fortranDirectory| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |makeFortranFun| ...) is being compiled.
;; The variable |$fortranLibraries| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |writeCFile| ...) is being compiled.
;; The variable |$addUnderscoreToFortranNames| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |makeAspGenerators1| ...) is being compiled.
;; Warning: The variable |type| is not used.
; (DEFUN |makeCompilation| ...) is being compiled.
;; The variable |$fortranCompilerName| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |spadify| ...) is being compiled.
;; The variable RESULTS is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |prepareResults,defaultValue| ...) is being compiled.
;; The variable |shortZero| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |longZero| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |generateDataName| ...) is being compiled.
;; The variable |$fortranTmpDir| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |nagCall| ...) is being compiled.
;; The variable |$nagMessages| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$nagHost| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$fortPersistence| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/util.lisp.
; (DEFUN MAKE-DIRECTORY ...) is being compiled.
;; The variable $SPADROOT is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN INTERP-MAKE-DIRECTORY ...) is being compiled.
;; The variable $CURRENT-DIRECTORY is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN TRANSLATE ...) is being compiled.
;; Warning: The variable FN is not used.
; (DEFUN MAKE-DEPSYS ...) is being compiled.
;; Warning: The variable LSP is not used.
;; Warning: The variable SRC is not used.
;; Warning: The variable INT is not used.
;; Warning: The variable MNT is not used.
; (IN-PACKAGE "BOOTTRAN") is being compiled.
;; Warning: The package operation (IN-PACKAGE "BOOTTRAN") was in a bad place.
; (DEFUN BOOTTOCL ...) is being compiled.
;; Warning: The variable FN is not used.
; (IN-PACKAGE "BOOT") is being compiled.
;; Warning: The package operation (IN-PACKAGE "BOOT") was in a bad place.
; (DEFUN BUILD-INTERPSYS ...) is being compiled.
;; The variable COMP-FUNCTIONS is undefined.
;; The compiler will assume this variable is a global.
;; The variable PARSE-FUNCTIONS is undefined.
;; The compiler will assume this variable is a global.
;; The variable BROWSE-FUNCTIONS is undefined.
;; The compiler will assume this variable is a global.
;; The variable TRANSLATE-FUNCTIONS is undefined.
;; The compiler will assume this variable is a global.
;; The variable NAGBR-FUNCTIONS is undefined.
;; The compiler will assume this variable is a global.
;; The variable ASAUTO-FUNCTIONS is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable LSP is not used.
;; Warning: The variable SRC is not used.
;; Warning: The variable INT is not used.
;; Warning: The variable OBJ is not used.
;; Warning: The variable MNT is not used.
;; Warning: The variable SYS is not used.
; (IN-PACKAGE "COMPILER") is being compiled.
;; Warning: The package operation (IN-PACKAGE "COMPILER") was in a bad place.
; (IN-PACKAGE "BOOT") is being compiled.
;; Warning: The package operation (IN-PACKAGE "BOOT") was in a bad place.
; (DEFUN MAKELIB ...) is being compiled.
;; Warning: The variable NOOPTIMIZE is not used.
; (DEFUN LIBCHECK ...) is being compiled.
;; The variable ABBREVS is undefined.
;; The compiler will assume this variable is a global.
;; The variable CONSTRUCTORS is undefined.
;; The compiler will assume this variable is a global.
;; The variable SRCABBREVS is undefined.
;; The compiler will assume this variable is a global.
;; The variable SRCCONSTRUCTORS is undefined.
;; The compiler will assume this variable is a global.
;; The variable SPADS is undefined.
;; The compiler will assume this variable is a global.
;; The variable SHORT is undefined.
;; The compiler will assume this variable is a global.
;; The variable LONG is undefined.
;; The compiler will assume this variable is a global.
;; The variable POINT is undefined.
;; The compiler will assume this variable is a global.
;; The variable MARK is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable END is not used.
;; Warning: The variable START is not used.
;; Warning: The variable IN is not used.
;; Warning: The variable INTERP is not used.
;; Warning: The variable END is not used.
;; Warning: The variable START is not used.
;; Warning: The variable IN is not used.
;; Warning: The variable INTERP is not used.

============================================================================

Compiling /research2/test0819/int/interp/apply.clisp.
; (DEFUN |compApplication| ...) is being compiled.
;; The variable |$op| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compApplyModemap| ...) is being compiled.
;; The variable |$bindings| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compMapCondFun| ...) is being compiled.
;; Warning: The variable |op| is not used.
;; Warning: The variable |dc| is not used.

============================================================================

Compiling /research2/test0819/int/interp/c-doc.clisp.
; (DEFUN |getDoc| ...) is being compiled.
;; The variable |$FormalMapArgumentList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |recordDocumentation| ...) is being compiled.
;; The variable |$maxSignatureLineNumber| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$docList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |recordHeaderDocumentation| ...) is being compiled.
;; The variable $COMBLOCKLIST is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$headerDocumentation| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |finalizeDocumentation| ...) is being compiled.
;; The variable |$op| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |transDoc| ...) is being compiled.
;; Warning: The variable |conname| is not used.
; (DEFUN |transformAndRecheckComments| ...) is being compiled.
;; The variable |$checkingXmptex?| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$exposeFlag| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |checkRewrite| ...) is being compiled.
;; The variable |$argl| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |name| is not used.
; (DEFUN |checkTexht| ...) is being compiled.
;; The variable |$charLbrace| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$charRbrace| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |checkRecordHash| ...) is being compiled.
;; The variable |$charBack| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$HTlinks| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$htHash| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$name| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$origin| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$HTlisplinks| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$lispHash| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$glossHash| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$currentSysList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$setOptions| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$sysHash| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |checkAddMacros| ...) is being compiled.
;; The variable |$HTmacs| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |checkComments| ...) is being compiled.
;; The variable |$attribute?| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |checkIndentedLines| ...) is being compiled.
;; The variable |$charFauxNewline| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |newWordFrom| ...) is being compiled.
;; The variable |$stringFauxNewline| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$charBlank| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |checkGetArgs| ...) is being compiled.
;; The variable |$charComma| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |checkTrim,wherePP| ...) is being compiled.
;; The variable |$charPlus| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |checkFixCommonProblem| ...) is being compiled.
;; The variable |$HTspadmacros| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |checkDecorate| ...) is being compiled.
;; The variable |$charExclusions| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |checkAddBackSlashes| ...) is being compiled.
;; The variable |$charEscapeList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |checkIeEgfun| ...) is being compiled.
;; The variable |$charPeriod| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: Type mismatch was found in (THE BOOLEAN
                                         (SPADLET |key|
                                          (MAKESTRING "that is"))).
;; Warning: Type mismatch was found in (THE BOOLEAN
                                         (SPADLET |key|
                                          (MAKESTRING "for example"))).
; (DEFUN |checkSplitPunctuation| ...) is being compiled.
;; The variable |$charSemiColon| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$charQuote| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$htMacroTable| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$charDash| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |checkSplitOn| ...) is being compiled.
;; The variable |$charSplitList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |checkBalance| ...) is being compiled.
;; The variable |$checkPrenAlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |checkBeginEnd| ...) is being compiled.
;; The variable |$beginEndList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |checkTransformFirsts| ...) is being compiled.
;; Warning: Type mismatch was found in (THE BOOLEAN
                                         (SPADLET |close| (|char| ']))).
;; Warning: Type mismatch was found in (THE BOOLEAN
                                         (SPADLET |close|
                                          (|char| '|)|))).
; (DEFUN |checkSkipOpToken| ...) is being compiled.
;; The variable |$charDelimiters| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |checkAlphabetic| ...) is being compiled.
;; The variable |$charIdentifierEndings| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |docreport| ...) is being compiled.
;; The variable /EDITFILE is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |setOutStream| ...) is being compiled.
;; The variable |$outStream| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |checkDocError1| ...) is being compiled.
;; The variable |$compileDocumentation| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |checkDocError| ...) is being compiled.
;; The variable |$checkErrorFlag| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$recheckingFlag| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$constructorName| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$exposeFlagHeading| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |checkDocMessage| ...) is being compiled.
;; The variable |$x| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/c-util.clisp.
; (DEFUN |continue| ...) is being compiled.
;; The variable |$x| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$m| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$f| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |level| ...) is being compiled.
;; The variable |$level| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |displayComp| ...) is being compiled.
;; The variable |$bright| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$dim| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$op| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$s| is undefined.
;; The compiler will assume this variable is a global.
;; The variable $X is undefined.
;; The compiler will assume this variable is a global.
;; The variable $M is undefined.
;; The compiler will assume this variable is a global.
;; The variable $F is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |intersectionContour,modeCompare| ...) is being compiled.
;; The variable |$var| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |isAlmostSimple,setAssignment| ...) is being compiled.
;; The variable |$assignmentList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |stackSemanticError| ...) is being compiled.
;; The variable |$initCapsuleErrorCount| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |stackMessage| ...) is being compiled.
;; The variable |$compErrorMessageStack| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |?modemaps| ...) is being compiled.
;; The variable |$CapsuleModemapFrame| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |traverse,traverseInner| ...) is being compiled.
;; The variable |$seen| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$notseen| is undefined.
;; The compiler will assume this variable is a global.
;; The variable SET-PA-SPEC is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/profile.clisp.
; (DEFUN |profileWrite| ...) is being compiled.
;; The variable |$profileAlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |profileTran| ...) is being compiled.
;; The variable |$profileHash| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |profileRecord| ...) is being compiled.
;; The variable |$op| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$signatureOfForm| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/category.clisp.
; (DEFUN |SigListUnion| ...) is being compiled.
;; The variable |$NewCatVec| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |e| is not used.
; (DEFUN |SourceLevelSubset| ...) is being compiled.
;; The variable |$noSubsumption| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$noSubsets| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/compiler.clisp.
; (DEFUN |compOrCroak1,fn| ...) is being compiled.
;; The variable |$s| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$level| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |tc| ...) is being compiled.
;; The variable |$x| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$m| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$f| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |comp| ...) is being compiled.
;; The variable |$compStack| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |comp2| ...) is being compiled.
;; The variable |$packagesUsed| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |hasFormalMapVariable,hasone?| ...) is being compiled.
;; The variable |$formalMapVariables| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compWithMappingMode,FreeList| ...) is being compiled.
;; Warning: Calls to compWithMappingMode,FreeList will be VERY SLOW. Recommend not to proclaim.  
;;The arg caused the problem. e
; (DEFUN |primitiveType| ...) is being compiled.
;; The variable |$DoubleFloat| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compSymbol| ...) is being compiled.
;; The variable |$functorLocalParameters| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compForm2| ...) is being compiled.
;; The variable |$TriangleVariableList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |getFormModemaps| ...) is being compiled.
;; The variable |$insideCategoryPackageIfTrue| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compSubsetCategory| ...) is being compiled.
;; The variable |$lhsOfColon| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |setqSingle| ...) is being compiled.
;; The variable |$profileCompiler| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |setqMultiple,decompose| ...) is being compiled.
;; Warning: The variable |length| is not used.
; (DEFUN |setqMultipleExplicit| ...) is being compiled.
;; Warning: The variable |m| is not used.
; (DEFUN |replaceExitEtc,fn| ...) is being compiled.
;; The variable |$finalEnv| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compImport| ...) is being compiled.
;; Warning: The variable |m| is not used.
; (DEFUN |compPretend| ...) is being compiled.
;; The variable |$newCompilerUnionFlag| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compileSpad2Cmd| ...) is being compiled.
;; The variable /EDITFILE is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$options| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$newConlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |convertSpadToAsFile| ...) is being compiled.
;; The variable |$badStack| is undefined.
;; The compiler will assume this variable is a global.
;; The variable HT is undefined.
;; The compiler will assume this variable is a global.
End of Pass 1.  
; (DEFUN |compWithMappingMode,FreeList| ...) is being compiled.
;; Warning: 
;; compWithMappingMode,FreeList Number of proclaimed args was 3. 
;;Its definition had 4.
; (DEFUN |compWithMappingMode,FreeList|) is being compiled.
;; Warning: compWithMappingMode,FreeList called with 4 args, expected 3 
;; Warning: compWithMappingMode,FreeList called with 4 args, expected 3 
;; Warning: compWithMappingMode,FreeList called with 4 args, expected 3 
;; Warning: compWithMappingMode,FreeList called with 4 args, expected 3 
;; Warning: compWithMappingMode,FreeList called with 4 args, expected 3 
; (DEFUN |compWithMappingMode|) is being compiled.
;; Warning: compWithMappingMode,FreeList called with 4 args, expected 3 

============================================================================

Compiling /research2/test0819/int/interp/define.clisp.
; (DEFUN |compDefine1| ...) is being compiled.
;; The variable |$op| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |addEmptyCapsuleIfNecessary| ...) is being compiled.
;; Warning: The variable |target| is not used.
; (DEFUN |compDefineCategory1| ...) is being compiled.
;; The variable |$lisplibCategory| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |makeCategoryPredicates,fn| ...) is being compiled.
;; The variable |$mvl| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$tvl| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |makeCategoryPredicates| ...) is being compiled.
;; The variable |$TriangleVariableList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |mkCategoryPackage| ...) is being compiled.
;; The variable |$categoryPredicateList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compDefineCategory2| ...) is being compiled.
;; The variable |$domainShell| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$lisplibParents| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$lisplibAncestors| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$lisplibAbbreviation| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |specialCases| is not used.
; (DEFUN |compDefineFunctor1| ...) is being compiled.
;; The variable |$functorSpecialCases| is undefined.
;; The compiler will assume this variable is a global.
;; The variable NRTPARSE is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$myFunctorBody| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$pairlis| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$mutableDomains| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$insideCategoryPackageIfTrue| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$lisplibFunctionLocations| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$lisplibCategoriesExtended| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$lisplibSlot1| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$lisplibMissingFunctions| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compFunctorBody| ...) is being compiled.
;; The variable /EDITFILE is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NRTaddForm| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |parForm| is not used.
; (DEFUN |reportOnFunctorCompilation| ...) is being compiled.
;; The variable |$functorStats| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$functionStats| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |displayMissingFunctions| ...) is being compiled.
;; The variable |$CheckVectorList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |makeFunctorArgumentParameters,augmentSig| ...) is being compiled.
;; The variable |$ConditionalOperators| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |genDomainView| ...) is being compiled.
;; The variable |$getDomainCode| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |mkOpVec| ...) is being compiled.
;; The variable |Undef| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |genDomainViewName| ...) is being compiled.
;; Warning: The variable |category| is not used.
; (DEFUN |compDefWhereClause,transformType| ...) is being compiled.
;; The variable |$sigAlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compDefWhereClause,removeSuchthat| ...) is being compiled.
;; The variable |$predAlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compDefineCapsuleFunction| ...) is being compiled.
;; The variable |$signatureOfForm| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$functionLocations| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$profileCompiler| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |stripOffArgumentConditions| ...) is being compiled.
;; The variable |$argumentConditionList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |addArgumentConditions,fn| ...) is being compiled.
;; The variable |$functionName| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$body| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |canCacheLocalDomain,domargsglobal| ...) is being compiled.
;; The variable |$functorLocalParameters| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |canCacheLocalDomain| ...) is being compiled.
;; The variable |$selector| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$funcLocLen| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$usedDomList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$selcount| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compile| ...) is being compiled.
;; The variable |$savableItems| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$splitUpItemsAlreadyThere| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$lisplibItemsAlreadyThere| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$saveableItems| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$macroIfTrue| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compileConstructor1| ...) is being compiled.
;; The variable |$mutableDomain| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compAdd| ...) is being compiled.
;; The variable |$packagesUsed| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compSubDomain1| ...) is being compiled.
;; The variable |$lisplibSuperDomain| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compCapsuleInner| ...) is being compiled.
;; The variable |$addForm| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$signature| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compCapsuleItems| ...) is being compiled.
;; The variable |data| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |doIt| ...) is being compiled.
;; The variable |$functorsUsed| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NRTopt| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$LocalDomainAlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |DomainSubstitutionFunction,Subst| ...) is being compiled.
;; The variable |$extraParms| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compCategoryItem| ...) is being compiled.
;; The variable |$atList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$sigList| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/functor.clisp.
; (DEFUN |DomainPrint1| ...) is being compiled.
;; The variable |$Sublis| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$WhereList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |DPname| ...) is being compiled.
;; The variable |$WhereCounter| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NewbFVectorCopy| ...) is being compiled.
;; The variable |Undef| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |setVector12| ...) is being compiled.
;; The variable |$extraParms| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$domainShell| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |setVector4| ...) is being compiled.
;; The variable |$HackSlot4| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$getDomainCode| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |setVector4Onecat,Supplementaries| ...) is being compiled.
;; The variable |$supplementaries| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |setVector4part3| ...) is being compiled.
;; The variable |$epilogue| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |mkVectorWithDeferral| ...) is being compiled.
;; The variable |$ConstantAssignments| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |DescendCodeAdd1| ...) is being compiled.
;; The variable |$addFormLhs| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |DescendCode| ...) is being compiled.
;; The variable |$packagesUsed| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$locals| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |ProcessCond| ...) is being compiled.
;; The variable |$pairlis| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NRTslot1PredicateList| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |viewassoc| is not used.
; (DEFUN |SetFunctionSlots| ...) is being compiled.
;; The variable |$catvecList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$MissingFunctionInfo| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |LookUpSigSlots| ...) is being compiled.
;; The variable |$insideCategoryPackageIfTrue| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |CheckVector| ...) is being compiled.
;; The variable |$catNames| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$CheckVectorList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |InvestigateConditions,pessimise| ...) is being compiled.
;; The variable |$Conditions| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |InvestigateConditions| ...) is being compiled.
;; Warning: The variable |u| is not used.
; (DEFUN |resolvePatternVars| ...) is being compiled.
;; The variable |$TriangleVariableList| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/info.clisp.
; (DEFUN |addInfo| ...) is being compiled.
;; The variable |$Information| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |actOnInfo| ...) is being compiled.
;; The variable |$functorLocalParameters| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/iterator.clisp.
; (DEFUN |getIdentity| ...) is being compiled.
;; Warning: The variable |e| is not used.
; (DEFUN |compIterator| ...) is being compiled.
;; The variable |$until| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/modemap.clisp.
; (DEFUN |addModemapKnown| ...) is being compiled.
;; The variable |$CapsuleModemapFrame| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |mkNewModemapList| ...) is being compiled.
;; The variable |$forceAdd| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |mergeModemap| ...) is being compiled.
;; Warning: The variable |mmtail| is not used.
; (DEFUN |augModemapsFromCategoryRep| ...) is being compiled.
;; The variable |$base| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |getOperationAlist| ...) is being compiled.
;; The variable |$domainShell| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compCat| ...) is being compiled.
;; Warning: The variable |m| is not used.
; (DEFUN |getDomainsInScope| ...) is being compiled.
;; The variable |$CapsuleDomainsInScope| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/nruncomp.clisp.
; (DEFUN |NRTaddDeltaCode| ...) is being compiled.
;; The variable |$catvecList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NRTbase| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NRTdeltaList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NRTdeltaListComp| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$template| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NRTaddForm| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$addForm| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |optDeltaEntry| ...) is being compiled.
;; The variable |$killOptimizeIfTrue| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$optimizableConstructorNames| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |genDeltaEntry| ...) is being compiled.
;; The variable |$profileCompiler| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$functorLocalParameters| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NRTdeltaLength| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NRTassocIndex| ...) is being compiled.
;; The variable |$found| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NRTgetLocalIndex1| ...) is being compiled.
;; Warning: The variable |killBindingIfTrue| is not used.
; (DEFUN |NRTgetAddForm| ...) is being compiled.
;; The variable |$Slot1DataBase| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NRTassignCapsuleFunctionSlot| ...) is being compiled.
;; The variable |$insideCategoryPackageIfTrue| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NRTisExported?| ...) is being compiled.
;; The variable |$domainShell| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |consDomainName| ...) is being compiled.
;; The variable |$devaluateList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |buildFunctor| ...) is being compiled.
;; The variable |$NRTvec| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$uncondAlist| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$condAlist| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NRTslot1PredicateList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$setelt| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$CheckVectorList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NRTdomainFormList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$getDomainCode| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NRTvectorCopy| ...) is being compiled.
;; Warning: The variable |cacheName| is not used.
;; Warning: The variable |domName| is not used.
; (DEFUN |NRTsetVector4| ...) is being compiled.
;; The variable |$lisplibCategoriesExtended| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NRTsetVector4Part2| ...) is being compiled.
;; The variable |$pairlis| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NRTsetVector4a| ...) is being compiled.
;; The variable |$uncondList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$condList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NRTmakeSlot1| ...) is being compiled.
;; The variable |$NRTmakeCompactDirect| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |domainShell| is not used.
; (DEFUN |NRTmakeSlot1Info| ...) is being compiled.
;; The variable |$lisplibOpAlist| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NRTderivedTargetIfTrue| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NRToptimizeHas| ...) is being compiled.
;; The variable |$hasCategoryAlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NRTaddToSlam| ...) is being compiled.
;; The variable |$mutableDomain| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |changeDirectoryInSlot1,fn| ...) is being compiled.
;; The variable |$lastPred| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$newEnv| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |genSlotSig| ...) is being compiled.
;; Warning: The variable |pred| is not used.
; (DEFUN |NRTputInHead| ...) is being compiled.
;; The variable |$elt| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/package.clisp.
; (DEFUN |processFunctorOrPackage| ...) is being compiled.
;; Warning: The variable |m| is not used.
; (DEFUN |processPackage| ...) is being compiled.
;; The variable |$domainShell| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$getDomainCode| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$mutableDomain| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$packagesUsed| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$functorLocalParameters| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |PackageDescendCode| ...) is being compiled.
;; The variable |$ResetItems| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/htcheck.clisp.
; (DEFUN |buildHtMacroTable| ...) is being compiled.
;; The variable |$htMacroTable| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$primitiveHtCommands| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/parse.clisp.
; (DEFUN |parseType| ...) is being compiled.
;; The variable |$oldParserExpandAbbrs| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |parseTypeError| ...) is being compiled.
;; The variable |$op| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |x| is not used.
; (DEFUN |specialModeTran| ...) is being compiled.
;; The variable |$QuotientField| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |parseTranCheckForRecord| ...) is being compiled.
;; Warning: The variable |op| is not used.
; (DEFUN |transCategoryItem| ...) is being compiled.
;; The variable |$transCategoryAssoc| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/postpar.clisp.
; (DEFUN |postError| ...) is being compiled.
;; The variable |$defOp| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |postCategory| ...) is being compiled.
;; The variable |$insidePostCategoryIfTrue| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |postDef| ...) is being compiled.
;; The variable |$maxSignatureLineNumber| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$docList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$headerDocumentation| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |postIf| ...) is being compiled.
;; Warning: The variable |x| is not used.

============================================================================

Compiling /research2/test0819/int/interp/bc-matrix.clisp.
; (DEFUN |bcInputMatrixByFormula| ...) is being compiled.
;; The variable |$bcParseOnly| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |junk| is not used.
; (DEFUN |bcInputExplicitMatrix| ...) is being compiled.
;; Warning: The variable |junk| is not used.

============================================================================

Compiling /research2/test0819/int/interp/bc-misc.clisp.
; (DEFUN |bcSeriesExpansion| ...) is being compiled.
;; Warning: The variable |a| is not used.
;; Warning: The variable |b| is not used.
; (DEFUN |bcSeriesByFormula| ...) is being compiled.
;; Warning: The variable |a| is not used.
;; Warning: The variable |b| is not used.
; (DEFUN |bcTaylorSeries| ...) is being compiled.
;; Warning: The variable |a| is not used.
;; Warning: The variable |b| is not used.
; (DEFUN |bcSeriesByFormulaGen| ...) is being compiled.
;; Warning: The variable |htPage| is not used.
; (DEFUN |bcLaurentSeries| ...) is being compiled.
;; Warning: The variable |a| is not used.
;; Warning: The variable |b| is not used.
; (DEFUN |bcPuiseuxSeries| ...) is being compiled.
;; Warning: The variable |a| is not used.
;; Warning: The variable |b| is not used.
; (DEFUN |bcRealLimit| ...) is being compiled.
;; Warning: The variable |a| is not used.
;; Warning: The variable |b| is not used.
; (DEFUN |bcComplexLimit| ...) is being compiled.
;; Warning: The variable |a| is not used.
;; Warning: The variable |b| is not used.

============================================================================

Compiling /research2/test0819/int/interp/bc-solve.clisp.
; (DEFUN |bcLinearSolve| ...) is being compiled.
;; Warning: The variable |p| is not used.
;; Warning: The variable |nn| is not used.
; (DEFUN |bcLinearSolveEqns| ...) is being compiled.
;; Warning: The variable |htPage| is not used.
;; Warning: The variable |p| is not used.
; (DEFUN |bcSystemSolve| ...) is being compiled.
;; Warning: The variable |htPage| is not used.
;; Warning: The variable |p| is not used.
; (DEFUN |bcSolveSingle| ...) is being compiled.
;; Warning: The variable |p| is not used.
; (DEFUN |bcInputEquations| ...) is being compiled.
;; The variable |$bcParseOnly| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |bcSolveEquationsNumerically| ...) is being compiled.
;; Warning: The variable |p| is not used.
; (DEFUN |bcLinearSolveMatrix| ...) is being compiled.
;; Warning: The variable |htPage| is not used.
;; Warning: The variable |junk| is not used.
; (DEFUN |bcLinearSolveMatrixInhomo| ...) is being compiled.
;; Warning: The variable |junk| is not used.
; (DEFUN |bcLinearSolveMatrixHomo| ...) is being compiled.
;; Warning: The variable |key| is not used.
; (DEFUN |linearFinalRequest| ...) is being compiled.
;; Warning: The variable |mat| is not used.
;; Warning: The variable |vect| is not used.
; (DEFUN |finalExactRequest| ...) is being compiled.
;; The variable |flag| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/bc-util.clisp.
; (DEFUN |bcNotReady| ...) is being compiled.
;; Warning: The variable |htPage| is not used.

============================================================================

Compiling /research2/test0819/int/interp/ht-util.clisp.
; (DEFUN |htpDestroyPage| ...) is being compiled.
;; The variable |$activePageList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |iht| ...) is being compiled.
;; The variable |$newPage| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$htLineList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |bcHt| ...) is being compiled.
;; The variable |$curPage| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |doDoitButton| ...) is being compiled.
;; Warning: The variable |htPage| is not used.
; (DEFUN |typeCheckInputAreas| ...) is being compiled.
;; The variable |$bcParseOnly| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |parseAndEval1| ...) is being compiled.
;; The variable |$useNewParser| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |htEscapeString| ...) is being compiled.
;; The variable |$funnyQuote| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$funnyBacks| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/htsetvar.clisp.
; (DEFUN |htSetVars| ...) is being compiled.
;; The variable |$path| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$lastTree| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$setOptions| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |htShowIntegerPage| ...) is being compiled.
;; The variable |$htInitial| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$htFinal| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |htKill| ...) is being compiled.
;; Warning: The variable |htPage| is not used.
; (DEFUN |htDoNothing| ...) is being compiled.
;; Warning: The variable |htPage| is not used.
;; Warning: The variable |command| is not used.
; (DEFUN |htSetCache| ...) is being compiled.
;; The variable |$valueList| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/ht-root.clisp.
; (DEFUN |downlink| ...) is being compiled.
;; The variable |$saturn| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |htSystemVariables,gn| ...) is being compiled.
;; The variable |$levels| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$heading| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |htSystemVariables| ...) is being compiled.
;; The variable |$fullScreenSysVars| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$setOptions| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |htSetSystemVariable| ...) is being compiled.
;; Warning: The variable |htPage| is not used.
; (DEFUN |htGlossPage| ...) is being compiled.
;; The variable |$tick| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |htGlossSearch| ...) is being compiled.
;; Warning: The variable |junk| is not used.
; (DEFUN |mkUnixPattern| ...) is being compiled.
;; The variable |$wild| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/br-con.clisp.
; (DEFUN |conPageFastPath| ...) is being compiled.
;; The variable |$lowerCaseConTb| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |kxPage| ...) is being compiled.
;; Warning: The variable |htPage| is not used.
; (DEFUN |kiPage| ...) is being compiled.
;; The variable |$conformsAreDomains| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |junk| is not used.
; (DEFUN |kePage| ...) is being compiled.
;; Warning: The variable |junk| is not used.
; (DEFUN |ksPage| ...) is being compiled.
;; Warning: The variable |junk| is not used.
; (DEFUN |dbSearchOrder| ...) is being compiled.
;; The variable |$predvec| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |kcPage| ...) is being compiled.
;; The variable |$defaultPackageNamesHT| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |junk| is not used.
; (DEFUN |kcpPage| ...) is being compiled.
;; Warning: The variable |junk| is not used.
; (DEFUN |kcaPage| ...) is being compiled.
;; Warning: The variable |junk| is not used.
; (DEFUN |kcdPage| ...) is being compiled.
;; Warning: The variable |junk| is not used.
; (DEFUN |kcdoPage| ...) is being compiled.
;; Warning: The variable |junk| is not used.
; (DEFUN |kcaPage1| ...) is being compiled.
;; Warning: The variable |article| is not used.
; (DEFUN |kccPage| ...) is being compiled.
;; Warning: The variable |junk| is not used.
; (DEFUN |kcdePage| ...) is being compiled.
;; Warning: The variable |junk| is not used.
; (DEFUN |kcuPage| ...) is being compiled.
;; Warning: The variable |junk| is not used.
; (DEFUN |kcnPage| ...) is being compiled.
;; The variable |conname| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |junk| is not used.
; (DEFUN |conOpPage| ...) is being compiled.
;; Warning: The variable |conform| is not used.
; (DEFUN |conOpPage1| ...) is being compiled.
;; The variable |$Primitives| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dbConstructorDoc,hn| ...) is being compiled.
;; The variable |$sig| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$args| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dbConstructorDoc,gn| ...) is being compiled.
;; The variable |$op| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dbDocTable| ...) is being compiled.
;; The variable |$docTableHash| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dbAddDocTable| ...) is being compiled.
;; The variable |$docTable| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dbGetDocTable,hn| ...) is being compiled.
;; The variable |$which| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$conform| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |kTestPred| ...) is being compiled.
;; The variable |$domain| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dbAddChainDomain| ...) is being compiled.
;; The variable |$infovec| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dbPresentCons| ...) is being compiled.
;; The variable |$saturn| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$includeUnexposed?| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$exposedOnlyIfTrue| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dbConsExposureMessage| ...) is being compiled.
;; The variable |$atLeastOneUnexposed| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dbShowConsDoc1| ...) is being compiled.
;; The variable |$TriangleVariableList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dbSelectCon| ...) is being compiled.
;; Warning: The variable |which| is not used.
; (DEFUN |isAsharpFileName?| ...) is being compiled.
;; Warning: The variable |con| is not used.

============================================================================

Compiling /research2/test0819/int/interp/br-data.clisp.
; (DEFUN |lefts| ...) is being compiled.
;; The variable *HASCATEGORY-HASH* is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |buildLibdb| ...) is being compiled.
;; The variable |$machineType| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |buildLibdbConEntry| ...) is being compiled.
;; The variable |$conname| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$conform| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$exposed?| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$doc| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$kind| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |libConstructorSig| ...) is being compiled.
;; The variable |$TriangleVariableList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |writedb| ...) is being compiled.
;; The variable |$outStream| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |libdbTrim| ...) is being compiled.
;; The variable |$Newline| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dbReadComments| ...) is being compiled.
;; Warning: Type mismatch was found in (THE BOOLEAN
                                         (SPADLET |k| (MAXINDEX |x|))).
; (DEFUN |dbSplitLibdb| ...) is being compiled.
;; The variable |$tick| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |getGlossLines| ...) is being compiled.
;; The variable |$charBlank| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |mkUsersHashTable| ...) is being compiled.
;; The variable |$usersTb| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |mkDependentsHashTable| ...) is being compiled.
;; The variable |$depTb| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |getParentsFor| ...) is being compiled.
;; Warning: The variable |x| is not used.
; (DEFUN |parentsOf| ...) is being compiled.
;; The variable |$parentsCache| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |getParentsForDomain| ...) is being compiled.
;; Warning: The variable |x| is not used.
; (DEFUN |ancestorsRecur| ...) is being compiled.
;; The variable |$done| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$lisplibParents| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |ancestorsAdd| ...) is being compiled.
;; The variable |$if| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |domainsOf| ...) is being compiled.
;; The variable |$hasArgList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |sublisFormal,sublisFormal1| ...) is being compiled.
;; The variable |$formals| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |buildDefaultPackageNamesHT| ...) is being compiled.
;; The variable |$defaultPackageNamesHT| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |extendLocalLibdb| ...) is being compiled.
;; The variable |$createLocalLibDb| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$newConstructorList| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/showimp.clisp.
; (DEFUN |showImp| ...) is being compiled.
;; The variable |$domainArgs| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/br-op1.clisp.
; (DEFUN |dbPresentOps| ...) is being compiled.
;; The variable |$conformsAreDomains| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$includeUnexposed?| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$exposedOnlyIfTrue| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$defaultPackageNamesHT| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dbShowOps| ...) is being compiled.
;; The variable |$groupChoice| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |reduceByGroup| ...) is being compiled.
;; The variable |$topicHash| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dbShowOp1| ...) is being compiled.
;; The variable |$opDescriptionThreshold| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$OpViewTable| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dbOpsExposureMessage| ...) is being compiled.
;; The variable |$atLeastOneUnexposed| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |fromHeading| ...) is being compiled.
;; The variable |$pn| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |conform2StringList| ...) is being compiled.
;; The variable |$lowerCaseConTb| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |x| is not used.
; (DEFUN |dbConform| ...) is being compiled.
;; The variable |$saturn| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dbGatherData| ...) is being compiled.
;; The variable |$dbDataFunctionAlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dbGatherDataImplementation,fn| ...) is being compiled.
;; Warning: The variable |u| is not used.
; (DEFUN |dbGatherDataImplementation| ...) is being compiled.
;; The variable |$domainArgs| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dbContrivedForm| ...) is being compiled.
;; The variable |$which| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dbGetOrigin| ...) is being compiled.
;; Warning: The variable |op| is not used.
; (DEFUN |dbGetCondition| ...) is being compiled.
;; Warning: The variable |op| is not used.
; (DEFUN |dbShowOpAllDomains| ...) is being compiled.
;; The variable *HASCATEGORY-HASH* is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dbGatherThenShow| ...) is being compiled.
;; Warning: The variable |htPage| is not used.
;; Warning: The variable |opAlist| is not used.
; (DEFUN |dbShowOpSignatures| ...) is being compiled.
;; Warning: The variable |htPage| is not used.
;; Warning: The variable |opAlist| is not used.
; (DEFUN |dbShowOpParameters| ...) is being compiled.
;; Warning: The variable |htPage| is not used.
;; Warning: The variable |opAlist| is not used.
; (DEFUN |dbShowOpDocumentation| ...) is being compiled.
;; Warning: The variable |data| is not used.
; (DEFUN |dbShowOperationLines| ...) is being compiled.
;; The variable |$attributeArgs| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dbExpandOpAlistIfNecessary| ...) is being compiled.
;; The variable |$docTableHash| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |needOrigins?| is not used.
; (DEFUN |evalDomainOpPred,evpred1| ...) is being compiled.
;; The variable |$predicateList| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/br-op2.clisp.
; (DEFUN |displayDomainOp| ...) is being compiled.
;; The variable |$saturn| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$includeUnexposed?| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$Primitives| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$TriangleVariableList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$sig| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$charFauxNewline| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$charNewline| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |htSayExplicitExports| ...) is being compiled.
;; The variable |$displayReturnValue| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |htSayArgument| ...) is being compiled.
;; The variable |$signature| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$conkind| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$conlength| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$generalSearch?| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$conargs| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dbGetFormFromDocumentation| ...) is being compiled.
;; Warning: Type mismatch was found in (THE BOOLEAN (SPADLET |k| 6)).
;; Warning: Type mismatch was found in (THE BOOLEAN (SPADLET |k| 3)).
;; The variable |$charRbrace| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dbChooseOperandName| ...) is being compiled.
;; The variable |$FunctionList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NumberList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$chooseDownCaseOfType| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$ElementList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$DomainList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |whoUsesMatch1?| ...) is being compiled.
;; The variable |$conname| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |koAttrs| ...) is being compiled.
;; The variable |$domain| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |koOps,fn| ...) is being compiled.
;; The variable |$packageItem| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |hashTable2Alist| ...) is being compiled.
;; The variable |$if| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |modemap2Sig| ...) is being compiled.
;; The variable |$badStack| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/br-search.clisp.
; (DEFUN |grepConstructDo| ...) is being compiled.
;; The variable |$orCount| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$localLibdb| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$newConstructorList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |grepForAbbrev| ...) is being compiled.
;; The variable |$lowerCaseConTb| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$includeUnexposed?| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$defaultPackageNamesHT| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |key| is not used.
; (DEFUN |grepf| ...) is being compiled.
;; The variable |$key| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |pmTransFilter| ...) is being compiled.
;; The variable |$browseMixedCase| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$charUnderscore| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |isFilterDelimiter?| ...) is being compiled.
;; The variable |$pmFilterDelimiters| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |mkGrepPattern1,addOptions| ...) is being compiled.
;; The variable |$options| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$wild1| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |conform2OutputForm| ...) is being compiled.
;; Warning: The variable |x| is not used.
; (DEFUN |genSearch1| ...) is being compiled.
;; The variable |$exposedOnlyIfTrue| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |genSearchSay| ...) is being compiled.
;; The variable |$browseCountThreshold| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dbGetName| ...) is being compiled.
;; The variable |$tick| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |sayDocMessage| ...) is being compiled.
;; The variable |$blank| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |oSearchGrep| ...) is being compiled.
;; Warning: The variable |key| is not used.
; (DEFUN |grepConstructorSearch| ...) is being compiled.
;; Warning: The variable |yes| is not used.
; (DEFUN |dbWordFrom| ...) is being compiled.
;; The variable |$dbDelimiters| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |grepSearchJump| ...) is being compiled.
;; Warning: The variable |yes| is not used.
; (DEFUN |generalSearchDo| ...) is being compiled.
;; The variable |$htPage| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |flag| is not used.
; (DEFUN |mkDetailedGrepPattern| ...) is being compiled.
;; The variable |$saturn| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |obey| ...) is being compiled.
;; The variable |$aixTestSaturn| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |grepSource| ...) is being compiled.
;; The variable $SPADROOT is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |mkGrepFile| ...) is being compiled.
;; The variable |$standard| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/br-util.clisp.
; (DEFUN |escapeSpecialIds| ...) is being compiled.
;; The variable |$htCharAlist| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$htSpecialChars| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |htPred2English,fnAttr| ...) is being compiled.
;; The variable |$emList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |htPred2English,gn| ...) is being compiled.
;; Warning: The variable |prec| is not used.
; (DEFUN |htPred2English,fn| ...) is being compiled.
;; The variable |$precList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dbConstructorKind| ...) is being compiled.
;; The variable |$defaultPackageNamesHT| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |bcConform1,say| ...) is being compiled.
;; The variable |$italics?| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |bcConform1,mapping| ...) is being compiled.
;; The variable |$saturn| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |bcConform1,hd| ...) is being compiled.
;; The variable |$FormalFunctionParameterList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$italicHead?| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$bcMultipleNames| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |bcConstructor| ...) is being compiled.
;; Warning: The variable |cname| is not used.
; (DEFUN |bcStar| ...) is being compiled.
;; The variable |$includeUnexposed?| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |errorPage| ...) is being compiled.
;; Warning: The variable |htPage| is not used.
; (DEFUN |htQueryPage| ...) is being compiled.
;; Warning: The variable |htPage| is not used.
; (DEFUN |dbKindString| ...) is being compiled.
;; The variable |$dbKindAlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dbName| ...) is being compiled.
;; The variable |$tick| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/topics.clisp.
; (DEFUN |mkTopicHashTable| ...) is being compiled.
;; The variable |$defaultsHash| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$topicsDefaults| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$conTopicHash| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$topicHash| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$groupAssoc| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$topicIndex| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |skipBlanks| ...) is being compiled.
;; The variable |$charBlank| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |topicCode| ...) is being compiled.
;; The variable |$topicSynonyms| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |td| ...) is being compiled.
;; The variable |$topicClasses| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/br-prof.clisp.
; (DEFUN |kciPage| ...) is being compiled.
;; Warning: The variable |junk| is not used.
; (DEFUN |dbShowInfoOp| ...) is being compiled.
;; The variable $ is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dbInfoChoose1| ...) is being compiled.
;; Warning: The variable |htPage| is not used.
; (DEFUN |dbInfoSigMatch| ...) is being compiled.
;; The variable |$conform| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/br-saturn.clisp.
; (DEFUN |on| ...) is being compiled.
;; The variable |$saturn| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$standard| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |ts| ...) is being compiled.
;; The variable |$saturnFileNumber| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |page| ...) is being compiled.
;; The variable |$curPage| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$saturnPage| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |bcHt| ...) is being compiled.
;; The variable |$newPage| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$htLineList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |writeSaturnPrefix| ...) is being compiled.
;; The variable |$saturnContextMenuLines| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$saturnContextMenuIndex| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |issueHTStandard| ...) is being compiled.
;; The variable |$MenuServer| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$SendLine| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |writeSaturn| ...) is being compiled.
;; The variable |$marg| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |saturnPRINTEXP| ...) is being compiled.
;; The variable |$browserOutputStream| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |getCallBack| ...) is being compiled.
;; The variable |$callTailList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |endHTPage| ...) is being compiled.
;; The variable |$EndOfPage| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |htMakeButtonSaturn| ...) is being compiled.
;; The variable |$kPageSaturnArguments| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |htInitPageNoScroll| ...) is being compiled.
;; The variable |$atLeastOneUnexposed| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |htpMakeEmptyPage| ...) is being compiled.
;; The variable |$activePageList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |kPage| ...) is being compiled.
;; The variable |$conformsAreDomains| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |saturnHasExamplePage| ...) is being compiled.
;; The variable |$exampleConstructors| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dbPresentCons| ...) is being compiled.
;; The variable |$includeUnexposed?| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$exposedOnlyIfTrue| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |addParameterTemplates| ...) is being compiled.
;; The variable |$conArgstrings| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |dbGatherThenShow| ...) is being compiled.
;; Warning: The variable |htPage| is not used.
;; Warning: The variable |opAlist| is not used.
; (DEFUN |displayDomainOp| ...) is being compiled.
;; The variable |$Primitives| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$TriangleVariableList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$sig| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$charFauxNewline| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$charNewline| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |mkTabularItem,fn| ...) is being compiled.
;; The variable |$saturnAmpersand| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compDefineCapsuleFunction| ...) is being compiled.
;; The variable |$FormalFunctionParameterList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$signatureOfForm| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$functionLocations| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$profileCompiler| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$functorStats| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |bcConform1,say| ...) is being compiled.
;; The variable |$italics?| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |bcConform1,hd| ...) is being compiled.
;; The variable |$italicHead?| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$bcMultipleNames| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |purgeLocalLibdb| ...) is being compiled.
;; The variable |$newConstructorList| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/intint.lisp.
; (DEFUN |intSetNeedToSignalSessionManager| ...) is being compiled.
;; The variable |$NeedToSignalSessionManager| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |intSetQuiet| ...) is being compiled.
;; The variable |$QuietCommand| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/interop.clisp.
; (DEFUN |DNameToSExpr1| ...) is being compiled.
;; The variable |DNameStringID| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |DNameToSExpr| ...) is being compiled.
;; The variable |DNameOtherID| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |SExprToDName| ...) is being compiled.
;; The variable |DNameApplyID| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |DNameTupleID| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |runOldAxiomFunctor| ...) is being compiled.
;; The variable |$oldAxiomPreCategoryDispatch| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |makeLazyOldAxiomDispatchDomain| ...) is being compiled.
;; The variable |$attributeDispatch| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$lazyOldAxiomDomainDispatch| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |makeOldAxiomDispatchDomain| ...) is being compiled.
;; The variable |$oldAxiomDomainDispatch| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |lazyOldAxiomDomainLookupExport| ...) is being compiled.
;; Warning: The variable |env| is not used.
; (DEFUN |lazyOldAxiomDomainHashCode| ...) is being compiled.
;; Warning: The variable |env| is not used.
; (DEFUN |lazyOldAxiomDomainDevaluate| ...) is being compiled.
;; Warning: The variable |env| is not used.
; (DEFUN |lazyOldAxiomAddChild| ...) is being compiled.
;; Warning: The variable |kid| is not used.
;; Warning: The variable |env| is not used.
; (DEFUN |oldAxiomPreCategoryBuild| ...) is being compiled.
;; The variable |$oldAxiomCategoryDispatch| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |env| is not used.
; (DEFUN |oldAxiomPreCategoryHashCode| ...) is being compiled.
;; Warning: The variable |env| is not used.
; (DEFUN |oldAxiomCategoryDefaultPackage| ...) is being compiled.
;; Warning: The variable |dom| is not used.
; (DEFUN |oldAxiomPreCategoryDevaluate| ...) is being compiled.
;; The variable T$ is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |env| is not used.
; (DEFUN |oldAxiomCategoryDevaluate| ...) is being compiled.
;; Warning: The variable |env| is not used.
; (DEFUN |oldAxiomCategoryLookupExport| ...) is being compiled.
;; Warning: The variable |box| is not used.
;; Warning: The variable |env| is not used.
; (DEFUN |oldAxiomCategoryParentCount| ...) is being compiled.
;; Warning: The variable |env| is not used.
; (DEFUN |oldAxiomCategoryNthParent| ...) is being compiled.
;; Warning: The variable |env| is not used.
; (DEFUN |oldAxiomCategoryHashCode| ...) is being compiled.
;; Warning: The variable |env| is not used.
; (DEFUN |attributeDevaluate| ...) is being compiled.
;; Warning: The variable |env| is not used.
; (DEFUN |attributeLookupExport| ...) is being compiled.
;; Warning: The variable |box| is not used.
;; Warning: The variable |env| is not used.
; (DEFUN |attributeHashCode| ...) is being compiled.
;; Warning: The variable |env| is not used.
; (DEFUN |attributeCategoryBuild| ...) is being compiled.
;; Warning: The variable |dom| is not used.
;; Warning: The variable |env| is not used.
; (DEFUN |attributeCategoryParentCount| ...) is being compiled.
;; Warning: The variable |attrObj| is not used.
;; Warning: The variable |env| is not used.
; (DEFUN |attributeNthParent| ...) is being compiled.
;; Warning: The variable |attrObj| is not used.
;; Warning: The variable |env| is not used.
; (DEFUN |oldAxiomDomainLookupExport| ...) is being compiled.
;; The variable |$hashOp1| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$hashOp0| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$hashOpApply| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$hashOpSet| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$hashSeg| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |env| is not used.
; (DEFUN |oldAxiomDomainHashCode| ...) is being compiled.
;; Warning: The variable |env| is not used.
; (DEFUN |oldAxiomDomainHasCategory| ...) is being compiled.
;; Warning: The variable |env| is not used.
; (DEFUN |oldAxiomDomainDevaluate| ...) is being compiled.
;; Warning: The variable |env| is not used.
; (DEFUN |oldAxiomAddChild| ...) is being compiled.
;; Warning: The variable |child| is not used.
;; Warning: The variable |env| is not used.
; (DEFUN |coerceConvertMmSelection| ...) is being compiled.
;; The variable |coerceConvertMmSelection;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/patches.lisp.
; (DEFUN CATCHALL ...) is being compiled.
;; Warning: The variable B is not used.
; (DEFUN CLEAR-HIGHLIGHT ...) is being compiled.
;; The variable |$specialCharacters| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN RESET-HIGHLIGHT ...) is being compiled.
;; The variable |$saveHighlight| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$saveSpecialchars| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |cd| ...) is being compiled.
;; The variable $CURRENT-DIRECTORY is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN TOPLEVEL ...) is being compiled.
;; Warning: The variable FOO is not used.
; (DEFUN /RF ...) is being compiled.
;; Warning: The variable FOO is not used.
; (DEFUN /RQ ...) is being compiled.
;; Warning: The variable FOO is not used.
; (DEFUN |/RQ,LIB| ...) is being compiled.
;; Warning: The variable FOO is not used.
; (DEFUN /RF-1 ...) is being compiled.
;; The variable /EDITFILE is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$useNewParser| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN /EF ...) is being compiled.
;; Warning: The variable FOO is not used.
; (DEFUN AKCL-VERSION ...) is being compiled.
;; The variable SYSTEM::*AKCL-VERSION* is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN SHAREDITEMS ...) is being compiled.
;; Warning: The variable X is not used.
; (DEFUN WHOCALLED ...) is being compiled.
;; Warning: The variable N is not used.
; (SHADOW 'MAP) is being compiled.
;; Warning: The package operation (SHADOW 'MAP) was in a bad place.
; (DEFUN |spadtestValueHook| ...) is being compiled.
;; Warning: The variable VAL is not used.
;; Warning: The variable TYPE is not used.
; (DEFUN |testError| ...) is being compiled.
;; Warning: The variable ERROTYPE is not used.
;; Warning: The variable ERROVALUE is not used.
; (DEFUN |bootFind| ...) is being compiled.
;; Warning: The variable WORD is not used.
; (DEFUN |fetchKeyedMsg| ...) is being compiled.
;; The variable |$defaultMsgDatabaseName| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |setViewportProcess| ...) is being compiled.
;; The variable |$ViewportProcessToWatch| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |waitForViewport| ...) is being compiled.
;; The variable |$MenuServer| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN PRINT-XDR-STREAM ...) is being compiled.
;; Warning: The variable Z is not used.
; (DEFUN |xdrOpen| ...) is being compiled.
;; Warning: The variable DIR is not used.
; (DEFUN |clearParserMacro| ...) is being compiled.
;; The variable |$pfMacros| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN /VERSIONCHECK ...) is being compiled.
;; The variable /MAJOR-VERSION is undefined.
;; The compiler will assume this variable is a global.

============================================================================


Compiling /research2/test0819/int/interp/hashcode.clisp.
; (DEFUN |hashType| ...) is being compiled.
;; The variable |$VoidHash| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$DomainsWithoutLisplibs| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |hashString| ...) is being compiled.
;; The variable |$hashModulus| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/as.clisp.
; (DEFUN |astran| ...) is being compiled.
;; The variable |$docHash| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$conHash| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$constantHash| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$newConlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |asyParents| ...) is being compiled.
;; The variable |$mmAlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |asMakeAlist| ...) is being compiled.
;; The variable |$parentsHash| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$opHash| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$docAlist| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$niladics| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$TriangleVariableList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$asFilename| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$asyPrint| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |asyDocumentation,fn| ...) is being compiled.
;; Warning: The variable |op| is not used.
; (DEFUN |asyExportAlist,fn| ...) is being compiled.
;; Warning: The variable |op| is not used.
; (DEFUN |asytranDeclaration| ...) is being compiled.
;; The variable |$asyFile| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$docHashLocal| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |asytranForm1| ...) is being compiled.
;; The variable |$hasPerCent| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |asyAbbreviation| ...) is being compiled.
;; Warning: The variable |n| is not used.
; (DEFUN |asyGetAbbrevFromComments,fn| ...) is being compiled.
;; Warning: The variable |op| is not used.
; (DEFUN |asyExtractAbbreviation| ...) is being compiled.
;; The variable |$stringNewline| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |asyTypeJoin| ...) is being compiled.
;; The variable |$kind| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |asyTypeJoinPartIf| ...) is being compiled.
;; The variable |$predlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |asyTypeJoinItem| ...) is being compiled.
;; The variable |$opStack| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$conStack| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |asyFindAttrs| ...) is being compiled.
;; The variable *ATTRIBUTES* is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |x| is not used.
; (DEFUN |asCategoryParts,exportsOf| ...) is being compiled.
;; The variable |$conslist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |asCategoryParts,build| ...) is being compiled.
;; The variable |$oplist| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$attrlist| is undefined.
;; The compiler will assume this variable is a global.

============================================================================


Compiling foam_l.lisp.
; (DEFMACRO |SFloRPlus| ...) is being compiled.
;; Warning: The variable R is not used.
;; Warning: The variable Y is not used.
;; Warning: The variable X is not used.
; (DEFMACRO |SFloRMinus| ...) is being compiled.
;; Warning: The variable R is not used.
;; Warning: The variable Y is not used.
;; Warning: The variable X is not used.
; (DEFMACRO |SFloRTimes| ...) is being compiled.
;; Warning: The variable R is not used.
;; Warning: The variable Y is not used.
;; Warning: The variable X is not used.
; (DEFMACRO |SFloRTimesPlus| ...) is being compiled.
;; Warning: The variable R is not used.
;; Warning: The variable Z is not used.
;; Warning: The variable Y is not used.
;; Warning: The variable X is not used.
; (DEFMACRO |SFloRDivide| ...) is being compiled.
;; Warning: The variable R is not used.
;; Warning: The variable Y is not used.
;; Warning: The variable X is not used.
; (DEFMACRO |SFloDissemble| ...) is being compiled.
;; Warning: The variable X is not used.
; (DEFMACRO |SFloAssemble| ...) is being compiled.
;; Warning: The variable Y is not used.
;; Warning: The variable X is not used.
;; Warning: The variable W is not used.
; (DEFMACRO |DFloRPlus| ...) is being compiled.
;; Warning: The variable R is not used.
;; Warning: The variable Y is not used.
;; Warning: The variable X is not used.
; (DEFMACRO |DFloRMinus| ...) is being compiled.
;; Warning: The variable R is not used.
;; Warning: The variable Y is not used.
;; Warning: The variable X is not used.
; (DEFMACRO |DFloRTimes| ...) is being compiled.
;; Warning: The variable R is not used.
;; Warning: The variable Y is not used.
;; Warning: The variable X is not used.
; (DEFMACRO |DFloRTimesPlus| ...) is being compiled.
;; Warning: The variable R is not used.
;; Warning: The variable Z is not used.
;; Warning: The variable Y is not used.
;; Warning: The variable X is not used.
; (DEFMACRO |DFloRDivide| ...) is being compiled.
;; Warning: The variable R is not used.
;; Warning: The variable Y is not used.
;; Warning: The variable X is not used.
; (DEFMACRO |DFloDissemble| ...) is being compiled.
;; Warning: The variable X is not used.
; (DEFMACRO |DFloAssemble| ...) is being compiled.
;; Warning: The variable Z is not used.
;; Warning: The variable Y is not used.
;; Warning: The variable X is not used.
;; Warning: The variable W is not used.
; (DEFUN |FormatNumber| ...) is being compiled.
;; The variable STR is undefined.
;; The compiler will assume this variable is a global.
; (DEFMACRO |RElt| ...) is being compiled.
;; Warning: The variable FIELD is not used.
; (DEFMACRO |SetRElt| ...) is being compiled.
;; Warning: The variable FIELD is not used.
; (DEFMACRO |EElt| ...) is being compiled.
;; Warning: The variable N is not used.
; (DEFMACRO |SetEElt| ...) is being compiled.
;; Warning: The variable N is not used.
; (DEFMACRO |Lex| ...) is being compiled.
;; Warning: The variable N is not used.
; (DEFMACRO |SetLex| ...) is being compiled.
;; Warning: The variable N is not used.
; (DEFMACRO |FoamFree| ...) is being compiled.
;; Warning: The variable O is not used.
; (DEFUN |fiSetDebugger| ...) is being compiled.
;; Warning: The variable X is not used.
;; Warning: The variable Y is not used.
; (DEFUN |fiGetDebugger| ...) is being compiled.
;; Warning: The variable X is not used.

============================================================================

Compiling /research2/test0819/int/interp/axext_l.lisp.
; (DEFUN H-INTEGER ...) is being compiled.
;; Warning: The variable E is not used.
; (DEFUN H-STRING ...) is being compiled.
;; Warning: The variable E is not used.
; (DEFUN H-ERROR ...) is being compiled.
;; Warning: The variable E is not used.

============================================================================


Compiling /research2/test0819/int/interp/ax.clisp.
; (DEFUN |spad2AxTranslatorAutoloadOnceTrigger| ...) is being compiled.
;; Warning: The variable |any| is not used.
; (DEFUN |setExtendedDomains| ...) is being compiled.
;; The variable |$extendedDomains| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |makeAxFile| ...) is being compiled.
;; The variable |$literals| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$baseForms| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |makeAxExportForm| ...) is being compiled.
;; Warning: The variable |filename| is not used.
; (DEFUN |stripType| ...) is being compiled.
;; The variable |$stripTypes| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |modemapToAx| ...) is being compiled.
;; The variable |$TriangleVariableList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |axFormatType| ...) is being compiled.
;; The variable |$pretendFlag| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |makeDefaultDef| ...) is being compiled.
;; The variable |$defaultFlag| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |getDefaultingOps| ...) is being compiled.
;; Warning: The variable |i| is not used.
; (DEFUN |get1defaultOp| ...) is being compiled.
;; The variable |$opList| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/nag-c02.clisp.
; (DEFUN |c02affSolve| ...) is being compiled.
;; The variable |$bcParseOnly| is undefined.
;; The compiler will assume this variable is a global.

============================================================================


Compiling /research2/test0819/int/interp/nag-c05.clisp.
; (DEFUN |c05nbfSolve| ...) is being compiled.
;; The variable |$bcParseOnly| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/nag-c06.clisp.
; (DEFUN |c06eafSolve| ...) is being compiled.
;; The variable |$bcParseOnly| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/nag-d01.clisp.
; (DEFUN |d01ajfGen| ...) is being compiled.
;; The variable |$bcParseOnly| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/nag-d02.clisp.
; (DEFUN |d02bbfSolve| ...) is being compiled.
;; The variable |$bcParseOnly| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/nag-d03.clisp.
; (DEFUN |d03edfSolve| ...) is being compiled.
;; The variable |$bcParseOnly| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/nag-e01.clisp.
; (DEFUN |e01bafSolve| ...) is being compiled.
;; The variable |$bcParseOnly| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/nag-e02.clisp.
; (DEFUN |e02adfSolve| ...) is being compiled.
;; The variable |$bcParseOnly| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/nag-e04.clisp.
; (DEFUN |e04dgfSolve| ...) is being compiled.
;; The variable |$bcParseOnly| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/nag-f01.clisp.
; (DEFUN |f01brfSolve| ...) is being compiled.
;; The variable |$bcParseOnly| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |f01qcfDefaultSolve| ...) is being compiled.
;; Warning: The variable |lda| is not used.
; (DEFUN |f01qdfDefaultSolve| ...) is being compiled.
;; Warning: The variable |lda| is not used.
;; Warning: The variable |ldb| is not used.
; (DEFUN |f01qefDefaultSolve| ...) is being compiled.
;; Warning: The variable |lda| is not used.
; (DEFUN |f01rdfDefaultSolve| ...) is being compiled.
;; Warning: The variable |lda| is not used.
;; Warning: The variable |ldb| is not used.
; (DEFUN |f01refDefaultSolve| ...) is being compiled.
;; Warning: The variable |lda| is not used.

============================================================================

Compiling /research2/test0819/int/interp/nag-f02.clisp.
; (DEFUN |f02aafSolve| ...) is being compiled.
;; The variable |$bcParseOnly| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |f02aafDefaultSolve| ...) is being compiled.
;; Warning: The variable |ia| is not used.
; (DEFUN |f02abfDefaultSolve| ...) is being compiled.
;; Warning: The variable |ia| is not used.
;; Warning: The variable |iv| is not used.
; (DEFUN |f02adfDefaultSolve| ...) is being compiled.
;; Warning: The variable |ia| is not used.
;; Warning: The variable |ib| is not used.
; (DEFUN |f02aefDefaultSolve| ...) is being compiled.
;; Warning: The variable |ia| is not used.
;; Warning: The variable |ib| is not used.
;; Warning: The variable |iv| is not used.
; (DEFUN |f02affDefaultSolve| ...) is being compiled.
;; Warning: The variable |ia| is not used.
; (DEFUN |f02agfDefaultSolve| ...) is being compiled.
;; Warning: The variable |ia| is not used.
;; Warning: The variable |ivr| is not used.
;; Warning: The variable |ivi| is not used.
; (DEFUN |f02ajfDefaultSolve| ...) is being compiled.
;; Warning: The variable |iar| is not used.
;; Warning: The variable |iai| is not used.
; (DEFUN |f02akfDefaultSolve| ...) is being compiled.
;; Warning: The variable |iar| is not used.
;; Warning: The variable |iai| is not used.
;; Warning: The variable |ivr| is not used.
;; Warning: The variable |ivi| is not used.
; (DEFUN |f02awfDefaultSolve| ...) is being compiled.
;; Warning: The variable |iar| is not used.
;; Warning: The variable |iai| is not used.
; (DEFUN |f02axfDefaultSolve| ...) is being compiled.
;; Warning: The variable |iar| is not used.
;; Warning: The variable |iai| is not used.
;; Warning: The variable |ivr| is not used.
;; Warning: The variable |ivi| is not used.
; (DEFUN |f02bbfDefaultSolve| ...) is being compiled.
;; Warning: The variable |ia| is not used.
;; Warning: The variable |iv| is not used.
; (DEFUN |f02bjfDefaultSolve| ...) is being compiled.
;; Warning: The variable |ia| is not used.
;; Warning: The variable |ib| is not used.
;; Warning: The variable |iv| is not used.

============================================================================

Compiling /research2/test0819/int/interp/nag-f04.clisp.
; (DEFUN |f04adfSolve| ...) is being compiled.
;; The variable |$bcParseOnly| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |f04atfDefaultSolve| ...) is being compiled.
;; Warning: The variable |iaa| is not used.
; (DEFUN |f04jgfDefaultSolve| ...) is being compiled.
;; Warning: The variable |nra| is not used.
;; Warning: The variable |lwork| is not used.

============================================================================

Compiling /research2/test0819/int/interp/nag-f07.clisp.
; (DEFUN |f07adfSolve| ...) is being compiled.
;; The variable |$bcParseOnly| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |f07adfDefaultSolve| ...) is being compiled.
;; Warning: The variable |lda| is not used.

============================================================================

Compiling /research2/test0819/int/interp/nag-s.clisp.
; (DEFUN |s17dcfGen| ...) is being compiled.
;; The variable |$bcParseOnly| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/wi1.clisp.
; (DEFUN |stackMessage| ...) is being compiled.
;; The variable |$compErrorMessageStack| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |put| ...) is being compiled.
;; The variable |$CapsuleModemapFrame| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compJoin| ...) is being compiled.
;; Warning: The variable |x| is not used.
; (DEFUN |compDefineLisplib| ...) is being compiled.
;; The variable |$compileDocumentation| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |comp0| ...) is being compiled.
;; The variable |$compStack| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compAtom| ...) is being compiled.
;; The variable |$localImportStack| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$globalImportStack| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compSymbol| ...) is being compiled.
;; The variable |$functorLocalParameters| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |setqSetelt| ...) is being compiled.
;; Warning: Calls to setqSetelt will be VERY SLOW. Recommend not to proclaim.  
;;The arg caused the problem. E
; (DEFUN |setqSingle| ...) is being compiled.
;; The variable |$profileCompiler| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$markFreeStack| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |setqMultiple,decompose| ...) is being compiled.
;; Warning: The variable |length| is not used.
; (DEFUN |setqMultipleExplicit| ...) is being compiled.
;; Warning: The variable |m| is not used.
; (DEFUN |canReturn| ...) is being compiled.
;; The variable |$convert2NewCompiler| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compBoolean| ...) is being compiled.
;; Warning: Calls to compBoolean will be VERY SLOW. Recommend not to proclaim.  
;;The arg caused the problem. Einit
; (DEFUN |compDefine| ...) is being compiled.
;; The variable |$originalBody| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compDefine1| ...) is being compiled.
;; The variable |$op| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compDefineCategory1| ...) is being compiled.
;; The variable |$lisplibCategory| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compDefineCategory2| ...) is being compiled.
;; The variable |$TriangleVariableList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$catAddForm| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$categoryTranForm| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$domainShell| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$convertingSpadFile| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |specialCases| is not used.
End of Pass 1.  
; (DEFUN |setqSetelt| ...) is being compiled.
;; Warning: 
;; setqSetelt Number of proclaimed args was 4. 
;;Its definition had 5.
; (DEFUN |compBoolean| ...) is being compiled.
;; Warning: 
;; compBoolean Number of proclaimed args was 3. 
;;Its definition had 4.
; (DEFUN |compSetq1|) is being compiled.
;; Warning: setqSetelt called with 5 args, expected 4 
; (DEFUN |compIf|) is being compiled.
;; Warning: compBoolean called with 4 args, expected 3 
; (DEFUN |compAnd|) is being compiled.
;; Warning: compBoolean called with 4 args, expected 3 
; (DEFUN |compOr|) is being compiled.
;; Warning: compBoolean called with 4 args, expected 3 
; (DEFUN |compNot|) is being compiled.
;; Warning: compBoolean called with 4 args, expected 3 

============================================================================

Compiling /research2/test0819/int/interp/wi2.clisp.
; (DEFUN |compDefineFunctor1| ...) is being compiled.
;; The variable |$functorSpecialCases| is undefined.
;; The compiler will assume this variable is a global.
;; The variable NRTPARSE is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$pairlis| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$mutableDomains| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$domainShell| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$insideCategoryPackageIfTrue| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$myFunctorBody| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$convert2NewCompiler| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$originalBody| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$lisplibFunctionLocations| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$lisplibCategoriesExtended| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$lisplibSlot1| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$lisplibMissingFunctions| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |makeFunctorArgumentParameters,augmentSig| ...) is being compiled.
;; The variable |$ConditionalOperators| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compDefineCapsuleFunction| ...) is being compiled.
;; The variable |$signatureOfForm| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$functionLocations| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$profileCompiler| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compCapsuleInner| ...) is being compiled.
;; The variable |$functorLocalParameters| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$addForm| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$signature| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$getDomainCode| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compImport| ...) is being compiled.
;; Warning: The variable |dom| is not used.
;; Warning: The variable |m| is not used.
; (DEFUN |applyMapping| ...) is being compiled.
;; The variable |$op| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compApplyModemap| ...) is being compiled.
;; The variable |$bindings| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NRTgetLocalIndex1| ...) is being compiled.
;; The variable |$NRTaddForm| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NRTdeltaList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NRTdeltaListComp| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NRTdeltaLength| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NRTbase| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |killBindingIfTrue| is not used.
; (DEFUN |optDeltaEntry| ...) is being compiled.
;; The variable |$killOptimizeIfTrue| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$optimizableConstructorNames| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |makeSimplePredicateOrNil| ...) is being compiled.
;; Warning: The variable |p| is not used.
; (DEFUN |mkUserConstructorAbbreviation| ...) is being compiled.
;; The variable |$AnalyzeOnly| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$abbreviationStack| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |compIterator| ...) is being compiled.
;; The variable |$until| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |doItSeq| ...) is being compiled.
;; The variable |$predl| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |doItLet1| ...) is being compiled.
;; The variable |$functorsUsed| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$packagesUsed| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$globalImportDefAlist| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NRTopt| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$LocalDomainAlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |doItExpression| ...) is being compiled.
;; The variable $ITEM is undefined.
;; The compiler will assume this variable is a global.
;; The variable $T1 is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |wiReplaceNode| ...) is being compiled.
;; The variable $NODE is undefined.
;; The compiler will assume this variable is a global.
;; The variable $NODE1 is undefined.
;; The compiler will assume this variable is a global.
;; The variable $NODE2 is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |replaceNodeBy| ...) is being compiled.
;; The variable |$nodeCopy| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/pspad1.clisp.
; (DEFUN |lisp2Boot| ...) is being compiled.
;; The variable |$fieldNames| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$autoLine| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$lineFragmentBuffer| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$bc| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$m| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$c| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$numberOfSpills| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$lineLength| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |formatOutput| ...) is being compiled.
;; The variable |$commentsToPrint| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |consLineBuffer| ...) is being compiled.
;; The variable |$lineBuffer| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |consBuffer| ...) is being compiled.
;; The variable |$rightBraceFlag| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$semicolonFlag| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |newLine| ...) is being compiled.
;; The variable |$newLineWritten| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |indent| ...) is being compiled.
;; The variable |$marginStack| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |formatMacroCheck| ...) is being compiled.
;; The variable |$globalMacroStack| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$localMacroStack| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |formatAtom| ...) is being compiled.
;; The variable |$renameAlist| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$escapeWords| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$underScore| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |formatUnion,fn| ...) is being compiled.
;; The variable |$count| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |formatApplication1| ...) is being compiled.
;; The variable |$formatForcePren| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |formatPrefixOp| ...) is being compiled.
;; The variable |$spadTightList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |formatDEF| ...) is being compiled.
;; The variable |$DEFdepth| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |formatMDEF| ...) is being compiled.
;; The variable |.| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$insideCAPSULE| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |insideCat| ...) is being compiled.
;; The variable |$noColonDeclaration| is undefined.
;; The compiler will assume this variable is a global.
End of Pass 1.  
; (DEFUN |format|) is being compiled.
;; Warning: error called with 0 args, expected 1 

============================================================================

Compiling /research2/test0819/int/interp/pspad2.clisp.
; (DEFUN |formatDeftran| ...) is being compiled.
;; The variable |$insideDEF| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |formatDeftranRepper| ...) is being compiled.
;; The variable |$pspadRelationAlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |formatCategory| ...) is being compiled.
;; Warning: The variable #:G155641 is not used.
; (DEFUN |formatColon| ...) is being compiled.
;; The variable |$insideTypeExpression| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$insideCAPSULE| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |formatCOND| ...) is being compiled.
;; The variable |$c| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$m| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |formatIfExit| ...) is being compiled.
;; The variable |$currentMarginStack| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$doNotResetMarginIfTrue| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |formatIf1| ...) is being compiled.
;; The variable |.| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$numberOfSpills| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |formatSCOND| ...) is being compiled.
;; The variable |$pilesAreOkHere| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |formatCOMMENT| ...) is being compiled.
;; The variable |$commentsToPrint| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |formatComments| ...) is being compiled.
;; The variable |$commentIndentation| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$insideEXPORTS| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$comments| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |consComments| ...) is being compiled.
;; The variable |$lineLength| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$charBlank| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |formatDoCommentLine| ...) is being compiled.
;; The variable |$lineBuffer| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |formatPileLine| ...) is being compiled.
;; The variable |$newLineWritten| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$rightBraceFlag| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |ident2PrintImage| ...) is being compiled.
;; The variable |$underScore| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |tryToFit| ...) is being compiled.
;; The variable |$back| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |s| is not used.
; (DEFUN |restoreState| ...) is being compiled.
;; The variable |$lineFragmentBuffer| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$marginStack| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$braceStack| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$DEFdepth| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$bc| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$autoLine| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$semicolonFlag| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$noColonDeclaration| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |formatSC| ...) is being compiled.
;; The variable |$pileStyle| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |wrapBraces| ...) is being compiled.
;; Warning: The variable |x| is not used.
;; Warning: The variable |z| is not used.
; (DEFUN |formatLB| ...) is being compiled.
;; The variable |$braceIndentation| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling /research2/test0819/int/interp/mark.clisp.
; (DEFUN WI ...) is being compiled.
;; Warning: The variable |a| is not used.
; (DEFUN |markCoerce| ...) is being compiled.
;; The variable |$partExpression| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |markCompAtom| ...) is being compiled.
;; The variable |$convert2NewCompiler| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |markAutoCoerceUp| ...) is being compiled.
;; Warning: The variable |x| is not used.
; (DEFUN |markLisp| ...) is being compiled.
;; Warning: The variable |m| is not used.
; (DEFUN |markLambda| ...) is being compiled.
;; The variable |$PerCentVariableList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |markMacro| ...) is being compiled.
;; The variable |$def| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$localMacroStack| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$globalMacroStack| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |markReduce| ...) is being compiled.
;; The variable |$funk| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |markImport| ...) is being compiled.
;; The variable |$localImportStack| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$localDeclareStack| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$globalImportStack| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$globalDeclareStack| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |markSetq| ...) is being compiled.
;; The variable |$domainLevelVariableList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$importStack| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$freeStack| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$markFreeStack| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |capsuleStack| ...) is being compiled.
;; The variable |$capsuleStack| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$predicateStack| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$predl| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$signatureOfForm| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$signatureStack| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable |name| is not used.
; (DEFUN |markChanges| ...) is being compiled.
;; The variable |$hoho| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |reduceImports1| ...) is being compiled.
;; The variable |$globalImportDefAlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |augmentBodyByLoopDecls| ...) is being compiled.
;; The variable |$localLoopVariables| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |markFindOriginalSignature| ...) is being compiled.
;; The variable |$originalTarget| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |markEncodeChanges| ...) is being compiled.
;; The variable |$markChoices| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |markRecord| ...) is being compiled.
;; The variable |$shout2| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$monitorCoerce| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$from| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$coerceList| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |markPath| ...) is being compiled.
;; The variable |$path| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$pathStack| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |markPath1| ...) is being compiled.
;; The variable |$shout1| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |markGetPath| ...) is being compiled.
;; The variable |$amb| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$pathErrorStack| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |markTryPaths| ...) is being compiled.
;; The variable |$x| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$y| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |markPaths| ...) is being compiled.
;; The variable |$shout| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |markSpliceInChanges| ...) is being compiled.
;; The variable |$cl| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$hohum| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |markInsertNextChange| ...) is being compiled.
;; The variable |$data| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |markInsertChanges| ...) is being compiled.
;; The variable $CHANGE is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$markPrimitiveNumbers| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |markFinish| ...) is being compiled.
;; The variable |$cs| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$ps| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$ss| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$os| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$gis| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$gds| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$gms| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$as| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$abbreviationStack| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$lms| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$map| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$macrosAlreadyPrinted| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$gs| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$fs| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$b| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$t| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |reFinish| ...) is being compiled.
;; The variable |$abbreviationsAlreadyPrinted| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |markFinish1| ...) is being compiled.
;; The variable |$categoryNameForDollar| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$extraDefinitions| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$categoryPart| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |getNumberTypesInScope| ...) is being compiled.
;; The variable |$markNumberTypes| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |mkNewCapsuleItem| ...) is being compiled.
;; The variable |$finalImports| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |markFinishItem| ...) is being compiled.
;; The variable |$f| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$ob| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |markCompare| ...) is being compiled.
;; The variable |$macroAlist| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |markPrint| ...) is being compiled.
;; The variable |$categoryTranForm| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$TriangleVariableList| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$catAddForm| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$originalBody| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$bootForm| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$bootLines| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |markSay| ...) is being compiled.
;; The variable |$outStream| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |markCheckForAttributes,fn| ...) is being compiled.
;; The variable |$knownAttributes| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |markInsertParts| ...) is being compiled.
;; The variable |$partNumber| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |markPartOp?| ...) is being compiled.
;; The variable |$partChoices| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$partSkips| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |changeToEqualEqual| ...) is being compiled.
;; The variable |$blank| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |markGetPaths| ...) is being compiled.
;; The variable |$newPaths| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |mkCheck| ...) is being compiled.
;; The variable |$badStack| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |combineDefinitions| ...) is being compiled.
;; The variable |$hash| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |buildNewDefinition| ...) is being compiled.
;; Warning: The variable |op| is not used.

No file g-boot.boot.toc.
[2]
Overfull \hbox (6.89076pt too wide) in paragraph at lines 18--21
[]\OT1/cmr/bx/n/10 NOTE WELL: IF YOU CHANGE THIS BOOT CODE YOU MUST
[3] [4] [5] [6] [7] [8] [9] [10] [11] [12]
Overfull \hbox (1574.98627pt too wide) in paragraph at lines 515--515
 []\OT1/cmtt/m/n/10 (DEFUN |nakedEXIT?| (|c|) (PROG (|a| |d|) (RETURN (SEQ (CON
D ((ATOM |c|) NIL) ((QUOTE T) (SPADLET |a| (CAR |c|)) (SPADLET |d| (CDR |c|)) (
COND ((IDENTP |a|) (COND ((BOOT-EQUAL |a| (QUOTE EXIT)) (QUOTE T)) ((BOOT-EQUAL
 |a| (QUOTE QUOTE)) NIL) ((MEMQ |a| (QUOTE (SEQ PROG LAMBDA MLAMBDA LAM))) NIL)
 ((QUOTE T) (|nakedEXIT?| |d|)))) ((QUOTE T) (OR (|nakedEXIT?| |a|) (|nakedEXIT
?| |d|))))))))))[]  

No file g-util.boot.toc.
[2]
Overfull \hbox (6.89076pt too wide) in paragraph at lines 18--21
[]\OT1/cmr/bx/n/10 NOTE WELL: IF YOU CHANGE THIS BOOT CODE YOU MUST
[3] [4] [5] [6] [7] [8] [9] [10] [11] [12] [13] [14]
Overfull \hbox (183.7484pt too wide) in paragraph at lines 598--598
 []\OT1/cmtt/m/n/10 $charSplitList := [$charComma,$charPeriod,char '_[, char '_
],$charLbrace, $charRbrace, char '_(, char '_), char '_$, char '_%][]  

Overfull \hbox (73.49936pt too wide) in paragraph at lines 600--600
 []\OT1/cmtt/m/n/10 $HTspadmacros := '("\spadtype" "\spadcommand" "\spadop" "\s
padfun" "\spadatt" "\spadsyscom" "\spad" "\s")[]  
[15]
Overfull \hbox (745.4935pt too wide) in paragraph at lines 648--648
 []\OT1/cmtt/m/n/10 (DEFUN |PPtoFile| (|x| |fname|) (PROG (|stream|) (RETURN (P
ROGN (SPADLET |stream| (DEFIOSTREAM (CONS (CONS (QUOTE MODE) (QUOTE OUTPUT)) (C
ONS (CONS (QUOTE FILE) |fname|) NIL)) 80 0)) (PRETTYPRINT |x| |stream|) (SHUT |
stream|) |x|))))[]  
[16]

No file parse.boot.toc.
[2]
Overfull \hbox (6.89076pt too wide) in paragraph at lines 18--21
[]\OT1/cmr/bx/n/10 NOTE WELL: IF YOU CHANGE THIS BOOT CODE YOU MUST

LaTeX Warning: Citation `1' on page 3 undefined on input line 30.


Overfull \hbox (12.93452pt too wide) in paragraph at lines 65--70
\OT1/cmtt/m/n/10 |parseHas| \OT1/cmr/m/n/10 on it's sym-bol prop-erty list. You
 can see this by call-ing \OT1/cmtt/m/n/10 (symbol-plist
[3]
Overfull \hbox (3.80544pt too wide) in paragraph at lines 73--77
[]\OT1/cmr/m/n/10 The \OT1/cmtt/m/n/10 |parseTran| \OT1/cmr/m/n/10 func-tion wa
lks the en-tire s-expression call-ing spe-cial parsers
[4] [5] [6] [7] [8] [9] [10] [11] [12] [13] [14]
Overfull \hbox (477.74583pt too wide) in paragraph at lines 583--583
 []\OT1/cmtt/m/n/10 (DEFUN |parseTransform| (|x|) (PROG (|$defOp|) (DECLARE (SP
ECIAL |$defOp|)) (RETURN (PROGN (SPADLET |$defOp| NIL) (SPADLET |x| (MSUBST (QU
OTE $) (QUOTE %) |x|)) (|parseTran| |x|)))))[]  

No file postpar.boot.toc.
[2]
Overfull \hbox (6.89076pt too wide) in paragraph at lines 18--21
[]\OT1/cmr/bx/n/10 NOTE WELL: IF YOU CHANGE THIS BOOT CODE YOU MUST
[3] [4] [5] [6] [7] [8] [9] [10] [11] [12] [13] [14]
Overfull \hbox (5801.19942pt too wide) in paragraph at lines 571--571
 []\OT1/cmtt/m/n/10 (DEFUN |postTransform| (|y|) (PROG (|x| |ISTMP#1| |ISTMP#2|
 |ISTMP#3| |ISTMP#4| |ISTMP#5| |t| |l| |u|) (RETURN (SEQ (PROGN (SPADLET |x| |y
|) (SPADLET |u| (|postTran| |x|)) (COND ((AND (PAIRP |u|) (EQ (QCAR |u|) (QUOTE
 |Tuple|)) (PROGN (SPADLET |ISTMP#1| (QCDR |u|)) (AND (PAIRP |ISTMP#1|) (PROGN 
(SPADLET |ISTMP#2| (REVERSE |ISTMP#1|)) (QUOTE T)) (PAIRP |ISTMP#2|) (PROGN (SP
ADLET |ISTMP#3| (QCAR |ISTMP#2|)) (AND (PAIRP |ISTMP#3|) (EQ (QCAR |ISTMP#3|) (
QUOTE |:|)) (PROGN (SPADLET |ISTMP#4| (QCDR |ISTMP#3|)) (AND (PAIRP |ISTMP#4|) 

make[3]: Entering directory `/research2/test0819/src/algebra'
Makefile:3002: warning: overriding commands for target `/research2/test0819/int/algebra/NEWTON.spad'
Makefile:2072: warning: ignoring old commands for target `/research2/test0819/int/algebra/NEWTON.spad'

============================================================================

Compiling ABELMON.lsp.
; (DEFUN |AbelianMonoid| ...) is being compiled.
;; The variable |AbelianMonoid;AL| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable #:G82597 is not used.

============================================================================

Compiling ABELSG.lsp.
; (DEFUN |AbelianSemiGroup| ...) is being compiled.
;; The variable |AbelianSemiGroup;AL| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable #:G82568 is not used.

============================================================================

Compiling ALAGG.lsp.
; (DEFUN |AssociationListAggregate| ...) is being compiled.
;; The variable |AssociationListAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AssociationListAggregate;| ...) is being compiled.
;; The variable |AssociationListAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling BOOLEAN.lsp.
; (DEFUN |BOOLEAN;test;2$;1| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |BOOLEAN;nt| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |BOOLEAN;true;$;3| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |BOOLEAN;false;$;4| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |BOOLEAN;not;2$;5| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |BOOLEAN;^;2$;6| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |BOOLEAN;~;2$;7| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |BOOLEAN;and;3$;8| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |BOOLEAN;/\\;3$;9| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |BOOLEAN;or;3$;10| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |BOOLEAN;\\/;3$;11| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |BOOLEAN;=;3$;15| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |BOOLEAN;implies;3$;16| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |BOOLEAN;<;3$;17| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |BOOLEAN;size;Nni;18| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |BOOLEAN;lookup;$Pi;20| ...) is being compiled.
;; Warning: The variable $ is not used.

============================================================================

Compiling CABMON.lsp.
; (DEFUN |CancellationAbelianMonoid| ...) is being compiled.
;; The variable |CancellationAbelianMonoid;AL| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable #:G82646 is not used.

============================================================================

Compiling CHAR.lsp.
; (DEFUN |CHAR;=;2$B;1| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |CHAR;<;2$B;2| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |CHAR;size;Nni;3| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |CHAR;ord;$I;7| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |CHAR;space;$;9| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |CHAR;quote;$;10| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |CHAR;escape;$;11| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |CHAR;latex;$S;19| ...) is being compiled.
;; Warning: The variable $ is not used.

============================================================================

Compiling CLAGG.lsp.
; (DEFUN |Collection| ...) is being compiled.
;; The variable |Collection;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |Collection;| ...) is being compiled.
;; The variable |Collection;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling COMRING.lsp.
; (DEFUN |CommutativeRing| ...) is being compiled.
;; The variable |CommutativeRing;AL| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable #:G82892 is not used.

============================================================================

Compiling DFLOAT.lsp.
; (DEFUN |DFLOAT;checkComplex| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;base;Pi;6| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;precision;Pi;9| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;max;$;11| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;min;$;12| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;Zero;$;14| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;One;$;15| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;exp1;$;16| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;pi;$;17| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;<;2$B;20| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;-;2$;21| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;+;3$;22| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;-;3$;23| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;*;3$;24| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;*;I2$;25| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;max;3$;26| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;min;3$;27| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;=;2$B;28| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;/;$I$;29| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;**;$I$;32| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;coerce;I$;34| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;exp;2$;35| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;sin;2$;38| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;cos;2$;39| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;tan;2$;40| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;cot;2$;41| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;sec;2$;42| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;csc;2$;43| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;atan;2$;46| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;acot;2$;48| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;sinh;2$;50| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;cosh;2$;51| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;tanh;2$;52| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;csch;2$;53| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;coth;2$;54| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;sech;2$;55| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;asinh;2$;56| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;acsch;2$;59| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;/;3$;62| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;negative?;$B;63| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;zero?;$B;64| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;hash;$I;65| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;recip;$U;66| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;differentiate;2$;67| ...) is being compiled.
;; Warning: The variable |x| is not used.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;wholePart;$I;70| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;float;2IPi$;71| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;convert;2$;72| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;atan;3$;75| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;retract;$I;78| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;retractIfCan;$U;79| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |DFLOAT;abs;2$;81| ...) is being compiled.
;; Warning: The variable $ is not used.

============================================================================

Compiling DIFRING.lsp.
; (DEFUN |DifferentialRing| ...) is being compiled.
;; The variable |DifferentialRing;AL| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable #:G84565 is not used.

============================================================================

Compiling DIVRING.lsp.
; (DEFUN |DivisionRing| ...) is being compiled.
;; The variable |DivisionRing;AL| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable #:G84035 is not used.

============================================================================

Compiling ENTIRER.lsp.
; (DEFUN |EntireRing| ...) is being compiled.
;; The variable |EntireRing;AL| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable #:G82841 is not used.

============================================================================

Compiling ES.lsp.
; (DEFUN |ExpressionSpace| ...) is being compiled.
;; The variable |ExpressionSpace;AL| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable #:G82344 is not used.

============================================================================

Compiling EUCDOM.lsp.
; (DEFUN |EuclideanDomain| ...) is being compiled.
;; The variable |EuclideanDomain;AL| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable #:G83585 is not used.

============================================================================

Compiling FFIELDC.lsp.
; (DEFUN |FiniteFieldCategory| ...) is being compiled.
;; The variable |FiniteFieldCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable #:G83129 is not used.

============================================================================

Compiling FFIELDC-.lsp.
; (DEFUN |FFIELDC-;differentiate;2S;1| ...) is being compiled.
;; Warning: The variable |x| is not used.

============================================================================

Compiling FPS.lsp.
; (DEFUN |FloatingPointSystem| ...) is being compiled.
;; The variable |FloatingPointSystem;AL| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable #:G105645 is not used.

============================================================================

Compiling GCDDOM.lsp.
; (DEFUN |GcdDomain| ...) is being compiled.
;; The variable |GcdDomain;AL| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable #:G83171 is not used.

============================================================================

Compiling HOAGG.lsp.
; (DEFUN |HomogeneousAggregate| ...) is being compiled.
;; The variable |HomogeneousAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |HomogeneousAggregate;| ...) is being compiled.
;; The variable |HomogeneousAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling ILIST.lsp.
; (DEFUN |ILIST;#;$Nni;1| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |ILIST;concat;S2$;2| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |ILIST;eq?;2$B;3| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |ILIST;first;$S;4| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |ILIST;elt;$firstS;5| ...) is being compiled.
;; Warning: The variable G101995 is not used.
;; Warning: The variable $ is not used.
; (DEFUN |ILIST;empty;$;6| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |ILIST;empty?;$B;7| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |ILIST;rest;2$;8| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |ILIST;elt;$rest$;9| ...) is being compiled.
;; Warning: The variable G102000 is not used.
;; Warning: The variable $ is not used.
; (DEFUN |ILIST;setelt;$first2S;11| ...) is being compiled.
;; Warning: The variable G102005 is not used.
; (DEFUN |ILIST;setelt;$rest2$;13| ...) is being compiled.
;; Warning: The variable G102010 is not used.
; (DEFUN |ILIST;construct;L$;14| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |ILIST;parts;$L;15| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |ILIST;reverse!;2$;16| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |ILIST;reverse;2$;17| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |ILIST;minIndex;$I;18| ...) is being compiled.
;; Warning: The variable |x| is not used.
; (DEFUN |ILIST;rest;$Nni$;19| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |ILIST;merge!;M3$;28| ...) is being compiled.
;; Warning: The variable $ is not used.

============================================================================

Compiling INS.lsp.
; (DEFUN |IntegerNumberSystem| ...) is being compiled.
;; The variable |IntegerNumberSystem;AL| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable #:G1068 is not used.

============================================================================

Compiling INS-.lsp.
; (DEFUN |INS-;characteristic;Nni;1| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INS-;differentiate;2S;2| ...) is being compiled.
;; Warning: The variable |x| is not used.
; (DEFUN |INS-;copy;2S;5| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INS-;rational?;SB;8| ...) is being compiled.
;; Warning: The variable |x| is not used.
;; Warning: The variable $ is not used.

============================================================================

Compiling INT.lsp.
; (DEFUN |INT;zero?;$B;6| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;Zero;$;7| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;One;$;8| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;base;$;9| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;copy;2$;10| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;inc;2$;11| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;dec;2$;12| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;hash;2$;13| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;negative?;$B;14| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;coerce;2$;16| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;convert;2$;17| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;length;2$;18| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;addmod;4$;19| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;submod;4$;20| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;mulmod;4$;21| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;convert;$Df;23| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;convert;$S;25| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;latex;$S;26| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;positiveRemainder;3$;27| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;reducedSystem;2M;28| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;reducedSystem;MVR;29| ...) is being compiled.
;; Warning: The variable |v| is not used.
;; Warning: The variable $ is not used.
; (DEFUN |INT;abs;2$;30| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;random;$;31| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;random;2$;32| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;=;2$B;33| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;<;2$B;34| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;-;2$;35| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;+;3$;36| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;-;3$;37| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;*;3$;38| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;*;3$;39| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;**;$Nni$;40| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;odd?;$B;41| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;max;3$;42| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;min;3$;43| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;divide;2$R;44| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;quo;3$;45| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;rem;3$;46| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;shift;3$;47| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;exquo;2$U;48| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;recip;$U;49| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;gcd;3$;50| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;unitNormal;$R;51| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |INT;unitCanonical;2$;52| ...) is being compiled.
;; Warning: The variable $ is not used.

============================================================================

Compiling INTDOM.lsp.
; (DEFUN |IntegralDomain| ...) is being compiled.
;; The variable |IntegralDomain;AL| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable #:G83060 is not used.

============================================================================

Compiling ISTRING.lsp.
; (DEFUN |ISTRING;new;NniC$;1| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |ISTRING;empty;$;2| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |ISTRING;empty?;$B;3| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |ISTRING;#;$Nni;4| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |ISTRING;=;2$B;5| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |ISTRING;<;2$B;6| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |ISTRING;concat;3$;7| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |ISTRING;copy;2$;8| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |ISTRING;minIndex;$I;11| ...) is being compiled.
;; Warning: The variable |s| is not used.
; (DEFUN |ISTRING;latex;$S;14| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |ISTRING;match;2$CNni;33| ...) is being compiled.
;; Warning: The variable $ is not used.

============================================================================

Compiling LIST.lsp.
; (DEFUN |LIST;nil;$;1| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |LIST;null;$B;2| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |LIST;cons;S2$;3| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |LIST;append;3$;4| ...) is being compiled.
;; Warning: The variable $ is not used.

============================================================================

Compiling LNAGG.lsp.
; (DEFUN |LinearAggregate| ...) is being compiled.
;; The variable |LinearAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |LinearAggregate;| ...) is being compiled.
;; The variable |LinearAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling LSAGG.lsp.
; (DEFUN |ListAggregate| ...) is being compiled.
;; The variable |ListAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |ListAggregate;| ...) is being compiled.
;; The variable |ListAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling MONOID.lsp.
; (DEFUN |Monoid| ...) is being compiled.
;; The variable |Monoid;AL| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable #:G82434 is not used.

============================================================================

Compiling MTSCAT.lsp.
; (DEFUN |MultivariateTaylorSeriesCategory| ...) is being compiled.
;; The variable |MultivariateTaylorSeriesCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |MultivariateTaylorSeriesCategory;| ...) is being compiled.
;; The variable |MultivariateTaylorSeriesCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling NNI.lsp.
; (DEFUN |NNI;sup;3$;1| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |NNI;shift;$I$;2| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |NNI;subtractIfCan;2$U;3| ...) is being compiled.
;; Warning: The variable $ is not used.

============================================================================

Compiling OINTDOM.lsp.
; (DEFUN |OrderedIntegralDomain| ...) is being compiled.
;; The variable |OrderedIntegralDomain;AL| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable #:G84531 is not used.

============================================================================

Compiling ORDRING.lsp.
; (DEFUN |OrderedRing| ...) is being compiled.
;; The variable |OrderedRing;AL| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable #:G84457 is not used.

============================================================================

Compiling OUTFORM.lsp.
; (DEFUN |OUTFORM;print;$V;1| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |OUTFORM;=;2$B;4| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |OUTFORM;coerce;2$;6| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |OUTFORM;outputForm;I$;7| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |OUTFORM;outputForm;S$;8| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |OUTFORM;outputForm;Df$;9| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |OUTFORM;sform| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |OUTFORM;eform| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |OUTFORM;iform| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |OUTFORM;width;$I;14| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |OUTFORM;height;$I;15| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |OUTFORM;subHeight;$I;16| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |OUTFORM;superHeight;$I;17| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |OUTFORM;height;I;18| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |OUTFORM;width;I;19| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |OUTFORM;infix?;$B;72| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |OUTFORM;elt;$L$;73| ...) is being compiled.
;; Warning: The variable $ is not used.

============================================================================

Compiling PRIMARR.lsp.
; (DEFUN |PRIMARR;#;$Nni;1| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |PRIMARR;minIndex;$I;2| ...) is being compiled.
;; Warning: The variable |x| is not used.
;; Warning: The variable $ is not used.
; (DEFUN |PRIMARR;empty;$;3| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |PRIMARR;qelt;$IS;5| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |PRIMARR;elt;$IS;6| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |PRIMARR;qsetelt!;$I2S;7| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |PRIMARR;setelt;$I2S;8| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |PRIMARR;fill!;$S$;9| ...) is being compiled.
;; Warning: The variable $ is not used.

============================================================================

Compiling POLYCAT.lsp.
; (DEFUN |PolynomialCategory| ...) is being compiled.
;; The variable |PolynomialCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |PolynomialCategory;| ...) is being compiled.
;; The variable |PolynomialCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling PSETCAT.lsp.
; (DEFUN |PolynomialSetCategory| ...) is being compiled.
;; The variable |PolynomialSetCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |PolynomialSetCategory;| ...) is being compiled.
;; The variable |PolynomialSetCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling PSETCAT-.lsp.
End of Pass 1.  
Warning: PSETCAT-;exactQuo has a duplicate definition in this file

============================================================================

Compiling QFCAT.lsp.
; (DEFUN |QuotientFieldCategory| ...) is being compiled.
;; The variable |QuotientFieldCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |QuotientFieldCategory;| ...) is being compiled.
;; The variable |QuotientFieldCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling RCAGG.lsp.
; (DEFUN |RecursiveAggregate| ...) is being compiled.
;; The variable |RecursiveAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |RecursiveAggregate;| ...) is being compiled.
;; The variable |RecursiveAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling RCAGG-.lsp.
; (DEFUN |RCAGG-;elt;AvalueS;1| ...) is being compiled.
;; Warning: The variable G84515 is not used.
; (DEFUN |RCAGG-;setelt;Avalue2S;2| ...) is being compiled.
;; Warning: The variable G84517 is not used.

============================================================================

Compiling REF.lsp.
; (DEFUN |REF;=;2$B;1| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |REF;ref;S$;2| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |REF;elt;$S;3| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |REF;setelt;$2S;4| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |REF;deref;$S;5| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |REF;setref;$2S;6| ...) is being compiled.
;; Warning: The variable $ is not used.

============================================================================

Compiling RING.lsp.
; (DEFUN |Ring| ...) is being compiled.
;; The variable |Ring;AL| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable #:G82789 is not used.

============================================================================

Compiling RNG.lsp.
; (DEFUN |Rng| ...) is being compiled.
;; The variable |Rng;AL| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable #:G82722 is not used.

============================================================================

Compiling RNS.lsp.
; (DEFUN |RealNumberSystem| ...) is being compiled.
;; The variable |RealNumberSystem;AL| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable #:G105478 is not used.

============================================================================

Compiling RNS-.lsp.
; (DEFUN |RNS-;characteristic;Nni;1| ...) is being compiled.
;; Warning: The variable $ is not used.

============================================================================

Compiling SETAGG.lsp.
; (DEFUN |SetAggregate| ...) is being compiled.
;; The variable |SetAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |SetAggregate;| ...) is being compiled.
;; The variable |SetAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling SETCAT.lsp.
; (DEFUN |SetCategory| ...) is being compiled.
;; The variable |SetCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable #:G82359 is not used.

============================================================================

Compiling SETCAT-.lsp.
; (DEFUN |SETCAT-;hash;SSi;1| ...) is being compiled.
;; Warning: The variable |s| is not used.
;; Warning: The variable $ is not used.
; (DEFUN |SETCAT-;latex;SS;2| ...) is being compiled.
;; Warning: The variable |s| is not used.
;; Warning: The variable $ is not used.

============================================================================

Compiling SINT.lsp.
; (DEFUN |SINT;reducedSystem;MM;6| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;convert;$I;8| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;Zero;$;10| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;One;$;11| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;base;$;12| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;max;$;13| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;min;$;14| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;=;2$B;15| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;~;2$;16| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;not;2$;17| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;/\\;3$;18| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;\\/;3$;19| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;Not;2$;20| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;And;3$;21| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;Or;3$;22| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;xor;3$;23| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;<;2$B;24| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;inc;2$;25| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;dec;2$;26| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;-;2$;27| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;+;3$;28| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;-;3$;29| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;*;3$;30| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;quo;3$;32| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;rem;3$;33| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;divide;2$R;34| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;gcd;3$;35| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;abs;2$;36| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;odd?;$B;37| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;zero?;$B;38| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;max;3$;39| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;min;3$;40| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;hash;2$;41| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;length;2$;42| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;shift;3$;43| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;mulmod;4$;44| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;addmod;4$;45| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;submod;4$;46| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;negative?;$B;47| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;reducedSystem;MVR;48| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;positiveRemainder;3$;49| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;coerce;I$;50| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;random;2$;52| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SINT;unitNormal;$R;53| ...) is being compiled.
;; Warning: The variable $ is not used.

============================================================================

Compiling STAGG-.lsp.
; (DEFUN |STAGG-;c2| ...) is being compiled.
;; Warning: The variable |r| is not used.

============================================================================

Compiling SYMBOL.lsp.
; (DEFUN |SYMBOL;convert;2$;7| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SYMBOL;coerce;S$;8| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SYMBOL;=;2$B;9| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SYMBOL;<;2$B;10| ...) is being compiled.
;; Warning: The variable $ is not used.
; (DEFUN |SYMBOL;scripted?;$B;30| ...) is being compiled.
;; Warning: The variable $ is not used.

============================================================================

Compiling TSETCAT.lsp.
; (DEFUN |TriangularSetCategory| ...) is being compiled.
;; The variable |TriangularSetCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |TriangularSetCategory;| ...) is being compiled.
;; The variable |TriangularSetCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling UFD.lsp.
; (DEFUN |UniqueFactorizationDomain| ...) is being compiled.
;; The variable |UniqueFactorizationDomain;AL| is undefined.
;; The compiler will assume this variable is a global.
;; Warning: The variable #:G83334 is not used.

============================================================================

Compiling ULSCAT.lsp.
; (DEFUN |UnivariateLaurentSeriesCategory| ...) is being compiled.
;; The variable |UnivariateLaurentSeriesCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |UnivariateLaurentSeriesCategory;| ...) is being compiled.
;; The variable |UnivariateLaurentSeriesCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling UPOLYC.lsp.
; (DEFUN |UnivariatePolynomialCategory| ...) is being compiled.
;; The variable |UnivariatePolynomialCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |UnivariatePolynomialCategory;| ...) is being compiled.
;; The variable |UnivariatePolynomialCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling UPOLYC-.lsp.
; (DEFUN |UPOLYC-;degree;SSaosNni;2| ...) is being compiled.
;; Warning: The variable |v| is not used.
; (DEFUN |UPOLYC-;eval;SSaos2S;6| ...) is being compiled.
;; Warning: The variable |v| is not used.
; (DEFUN |UPOLYC-;eval;SSaosRS;8| ...) is being compiled.
;; Warning: The variable |v| is not used.
; (DEFUN |UPOLYC-;minimumDegree;SSaosNni;11| ...) is being compiled.
;; Warning: The variable |v| is not used.
; (DEFUN |UPOLYC-;monomial;SSaosNniS;13| ...) is being compiled.
;; Warning: The variable |v| is not used.
; (DEFUN |UPOLYC-;coerce;SaosS;14| ...) is being compiled.
;; Warning: The variable |v| is not used.
; (DEFUN |UPOLYC-;content;SSaosS;30| ...) is being compiled.
;; Warning: The variable |v| is not used.
; (DEFUN |UPOLYC-;differentiate;SSaosS;38| ...) is being compiled.
;; Warning: The variable |v| is not used.

============================================================================

Compiling URAGG.lsp.
; (DEFUN |UnaryRecursiveAggregate| ...) is being compiled.
;; The variable |UnaryRecursiveAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |UnaryRecursiveAggregate;| ...) is being compiled.
;; The variable |UnaryRecursiveAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

Compiling URAGG-.lsp.
; (DEFUN |URAGG-;elt;AfirstS;1| ...) is being compiled.
;; Warning: The variable G84610 is not used.
; (DEFUN |URAGG-;elt;AlastS;2| ...) is being compiled.
;; Warning: The variable G84612 is not used.
; (DEFUN |URAGG-;elt;ArestA;3| ...) is being compiled.
;; Warning: The variable G84614 is not used.
; (DEFUN |URAGG-;setelt;Afirst2S;25| ...) is being compiled.
;; Warning: The variable G84713 is not used.
; (DEFUN |URAGG-;setelt;Alast2S;26| ...) is being compiled.
;; Warning: The variable G84715 is not used.
; (DEFUN |URAGG-;setelt;Arest2A;27| ...) is being compiled.
;; Warning: The variable G84717 is not used.

============================================================================

   finalizing nrlib AHYP 
; (DEFUN |ArcHyperbolicFunctionCategory| ...) is being compiled.
;; The variable |ArcHyperbolicFunctionCategory;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib ATTREG 
; (DEFUN |AttributeRegistry| ...) is being compiled.
;; The variable |AttributeRegistry;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib CFCAT 
; (DEFUN |CombinatorialFunctionCategory| ...) is being compiled.
;; The variable |CombinatorialFunctionCategory;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib ELTAB 
; (DEFUN |Eltable| ...) is being compiled.
;; The variable |Eltable;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |Eltable;| ...) is being compiled.
;; The variable |Eltable;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib KOERCE 
; (DEFUN |CoercibleTo| ...) is being compiled.
;; The variable |CoercibleTo;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |CoercibleTo;| ...) is being compiled.
;; The variable |CoercibleTo;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib KONVERT 
; (DEFUN |ConvertibleTo| ...) is being compiled.
;; The variable |ConvertibleTo;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |ConvertibleTo;| ...) is being compiled.
;; The variable |ConvertibleTo;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib OM 
; (DEFUN |OpenMath| ...) is being compiled.
;; The variable |OpenMath;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib PTRANFN 
; (DEFUN |PartialTranscendentalFunctions| ...) is being compiled.
;; The variable |PartialTranscendentalFunctions;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |PartialTranscendentalFunctions;| ...) is being compiled.
;; The variable |PartialTranscendentalFunctions;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib SPFCAT 
; (DEFUN |SpecialFunctionCategory| ...) is being compiled.
;; The variable |SpecialFunctionCategory;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib TYPE 
; (DEFUN |Type| ...) is being compiled.
;; The variable |Type;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib COMBOPC 
; (DEFUN |CombinatorialOpsCategory| ...) is being compiled.
;; The variable |CombinatorialOpsCategory;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FORTCAT 
; (DEFUN |FortranProgramCategory| ...) is being compiled.
;; The variable |FortranProgramCategory;AL| is undefined.
;; The compiler will assume this variable is a global.

--------------non extending category----------------------
.. InfiniteTuple #1 of cat 
(|Join| (|CoercibleTo| (|OutputForm|)) (CATEGORY |domain| (SIGNATURE |map| ($ (|Mapping| |#1| |#1|) $)) (SIGNATURE |filterWhile| ($ (|Mapping| (|Boolean|) |#1|) $)) (SIGNATURE |filterUntil| ($ (|Mapping| (|Boolean|) |#1|) $)) (SIGNATURE |select| ($ (|Mapping| (|Boolean|) |#1|) $)) (SIGNATURE |generate| ($ (|Mapping| |#1| |#1|) |#1|)) (SIGNATURE |construct| ((|Stream| |#1|) $))))   has no 
============================================================================

(|LazyStreamAggregate| |#1|)    finalizing nrlib ITUPLE 

============================================================================

   finalizing nrlib PATAB 
; (DEFUN |Patternable| ...) is being compiled.
;; The variable |Patternable;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |Patternable;| ...) is being compiled.
;; The variable |Patternable;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib PPCURVE 
; (DEFUN |PlottablePlaneCurveCategory| ...) is being compiled.
;; The variable |PlottablePlaneCurveCategory;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib PSCURVE 
; (DEFUN |PlottableSpaceCurveCategory| ...) is being compiled.
;; The variable |PlottableSpaceCurveCategory;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib REAL 
; (DEFUN |RealConstant| ...) is being compiled.
;; The variable |RealConstant;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib RETRACT 
; (DEFUN |RetractableTo| ...) is being compiled.
;; The variable |RetractableTo;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |RetractableTo;| ...) is being compiled.
;; The variable |RetractableTo;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib SEGCAT 
; (DEFUN |SegmentCategory| ...) is being compiled.
;; The variable |SegmentCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |SegmentCategory;| ...) is being compiled.
;; The variable |SegmentCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FMC 
; (DEFUN |FortranMatrixCategory| ...) is being compiled.
;; The variable |FortranMatrixCategory;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FMFUN 
; (DEFUN |FortranMatrixFunctionCategory| ...) is being compiled.
;; The variable |FortranMatrixFunctionCategory;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FORTFN 
; (DEFUN |FortranFunctionCategory| ...) is being compiled.
;; The variable |FortranFunctionCategory;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FVC 
; (DEFUN |FortranVectorCategory| ...) is being compiled.
;; The variable |FortranVectorCategory;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FVFUN 
; (DEFUN |FortranVectorFunctionCategory| ...) is being compiled.
;; The variable |FortranVectorFunctionCategory;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib SEGXCAT 
; (DEFUN |SegmentExpansionCategory| ...) is being compiled.
;; The variable |SegmentExpansionCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |SegmentExpansionCategory;| ...) is being compiled.
;; The variable |SegmentExpansionCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib AGG 
; (DEFUN |Aggregate| ...) is being compiled.
;; The variable |Aggregate;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib BASTYPE 
; (DEFUN |BasicType| ...) is being compiled.
;; The variable |BasicType;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib ELTAGG 
; (DEFUN |EltableAggregate| ...) is being compiled.
;; The variable |EltableAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |EltableAggregate;| ...) is being compiled.
;; The variable |EltableAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FAMONC 
; (DEFUN |FreeAbelianMonoidCategory| ...) is being compiled.
;; The variable |FreeAbelianMonoidCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |FreeAbelianMonoidCategory;| ...) is being compiled.
;; The variable |FreeAbelianMonoidCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FILECAT 
; (DEFUN |FileCategory| ...) is being compiled.
;; The variable |FileCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |FileCategory;| ...) is being compiled.
;; The variable |FileCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FINITE 
; (DEFUN |Finite| ...) is being compiled.
;; The variable |Finite;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FNCAT 
; (DEFUN |FileNameCategory| ...) is being compiled.
;; The variable |FileNameCategory;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib IDPC 
; (DEFUN |IndexedDirectProductCategory| ...) is being compiled.
;; The variable |IndexedDirectProductCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |IndexedDirectProductCategory;| ...) is being compiled.
;; The variable |IndexedDirectProductCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib IEVALAB 
; (DEFUN |InnerEvalable| ...) is being compiled.
;; The variable |InnerEvalable;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |InnerEvalable;| ...) is being compiled.
;; The variable |InnerEvalable;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib LMODULE 
; (DEFUN |LeftModule| ...) is being compiled.
;; The variable |LeftModule;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |LeftModule;| ...) is being compiled.
;; The variable |LeftModule;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib LOGIC 
; (DEFUN |Logic| ...) is being compiled.
;; The variable |Logic;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib MONAD 
; (DEFUN |Monad| ...) is being compiled.
;; The variable |Monad;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib NIPROB 
   Warnings: 
      [1] coerce:  nia has no value
      [2] coerce:  mdnia has no value
      [3] retract:  nia has no value
      [4] retract:  mdnia has no value

============================================================================

   finalizing nrlib NUMINT 
; (DEFUN |NumericalIntegrationCategory| ...) is being compiled.
;; The variable |NumericalIntegrationCategory;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib ODECAT 
; (DEFUN |OrdinaryDifferentialEquationsSolverCategory| ...) is being compiled.
;; The variable |OrdinaryDifferentialEquationsSolverCategory;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib OPTCAT 
; (DEFUN |NumericalOptimizationCategory| ...) is being compiled.
;; The variable |NumericalOptimizationCategory;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib OPTPROB 
   Warnings: 
      [1] coerce:  noa has no value
      [2] coerce:  lsa has no value
      [3] retract:  noa has no value
      [4] retract:  lsa has no value

============================================================================

   finalizing nrlib ORDSET 
; (DEFUN |OrderedSet| ...) is being compiled.
;; The variable |OrderedSet;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib PATMAB 
; (DEFUN |PatternMatchable| ...) is being compiled.
;; The variable |PatternMatchable;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |PatternMatchable;| ...) is being compiled.
;; The variable |PatternMatchable;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib PDECAT 
; (DEFUN |PartialDifferentialEquationsSolverCategory| ...) is being compiled.
;; The variable |PartialDifferentialEquationsSolverCategory;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib PDEPROB 
--->/research2/test0819/mnt/fedora5/../../src/algebra/PDEPROB.spad-->NumericalPDEProblem(constructor): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/PDEPROB.spad-->NumericalPDEProblem(): Missing Description

   REPSQ abbreviates package RepeatedSquaring 
(PUSH (QUOTE |RepeatedSquaring|) |$mutableDomains|)
Value = (|RepeatedSquaring|)

   REPDB abbreviates package RepeatedDoubling 
(PUSH (QUOTE |RepeatedDoubling|) |$mutableDomains|)
Value = (|RepeatedDoubling|)

============================================================================

   finalizing nrlib RMODULE 
; (DEFUN |RightModule| ...) is being compiled.
;; The variable |RightModule;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |RightModule;| ...) is being compiled.
;; The variable |RightModule;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib SEXCAT 
; (DEFUN |SExpressionCategory| ...) is being compiled.
;; The variable |SExpressionCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |SExpressionCategory;| ...) is being compiled.
;; The variable |SExpressionCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib SPACEC 
; (DEFUN |ThreeSpaceCategory| ...) is being compiled.
;; The variable |ThreeSpaceCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |ThreeSpaceCategory;| ...) is being compiled.
;; The variable |ThreeSpaceCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib STEP 
; (DEFUN |StepThrough| ...) is being compiled.
;; The variable |StepThrough;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib ATRIG 
; (DEFUN |ArcTrigonometricFunctionCategory| ...) is being compiled.
;; The variable |ArcTrigonometricFunctionCategory;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib BMODULE 
; (DEFUN |BiModule| ...) is being compiled.
;; The variable |BiModule;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |BiModule;| ...) is being compiled.
;; The variable |BiModule;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib CACHSET 
; (DEFUN |CachableSet| ...) is being compiled.
;; The variable |CachableSet;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib CHARNZ 
; (DEFUN |CharacteristicNonZero| ...) is being compiled.
;; The variable |CharacteristicNonZero;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib CHARZ 
; (DEFUN |CharacteristicZero| ...) is being compiled.
;; The variable |CharacteristicZero;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib DVARCAT 
; (DEFUN |DifferentialVariableCategory| ...) is being compiled.
;; The variable |DifferentialVariableCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |DifferentialVariableCategory;| ...) is being compiled.
;; The variable |DifferentialVariableCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib ELEMFUN 
; (DEFUN |ElementaryFunctionCategory| ...) is being compiled.
;; The variable |ElementaryFunctionCategory;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib EVALAB 
; (DEFUN |Evalable| ...) is being compiled.
;; The variable |Evalable;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |Evalable;| ...) is being compiled.
;; The variable |Evalable;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FEVALAB 
; (DEFUN |FullyEvalableOver| ...) is being compiled.
;; The variable |FullyEvalableOver;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |FullyEvalableOver;| ...) is being compiled.
;; The variable |FullyEvalableOver;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FPATMAB 
; (DEFUN |FullyPatternMatchable| ...) is being compiled.
;; The variable |FullyPatternMatchable;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |FullyPatternMatchable;| ...) is being compiled.
;; The variable |FullyPatternMatchable;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib GROUP 
; (DEFUN |Group| ...) is being compiled.
;; The variable |Group;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib IDPAM 
   Warnings: 
      [1] +:  res has no value
      [2] +:  endcell has no value

============================================================================

   finalizing nrlib IXAGG 
; (DEFUN |IndexedAggregate| ...) is being compiled.
;; The variable |IndexedAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |IndexedAggregate;| ...) is being compiled.
;; The variable |IndexedAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib LALG 
; (DEFUN |LeftAlgebra| ...) is being compiled.
;; The variable |LeftAlgebra;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |LeftAlgebra;| ...) is being compiled.
;; The variable |LeftAlgebra;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib LINEXP 
; (DEFUN |LinearlyExplicitRingOver| ...) is being compiled.
;; The variable |LinearlyExplicitRingOver;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |LinearlyExplicitRingOver;| ...) is being compiled.
;; The variable |LinearlyExplicitRingOver;CAT| is undefined.
;; The compiler will assume this variable is a global.

--------------non extending category----------------------
.. ModuleMonomial(#1,#2,#3) of cat 
(|Join| (|OrderedSet|) (CATEGORY |domain| (SIGNATURE |exponent| (|#2| $)) (SIGNATURE |index| (|#1| $)) (SIGNATURE |coerce| ($ (|Record| (|:| |index| |#1|) (|:| |exponent| |#2|)))) (SIGNATURE |coerce| ((|Record| (|:| |index| |#1|) (|:| |exponent| |#2|)) $)) (SIGNATURE |construct| ($ |#1| |#2|))))   has no 
============================================================================

(|RecordCategory| (|:| |index| |#1|) (|:| |exponent| |#2|))    finalizing nrlib MODMONOM 

============================================================================

   finalizing nrlib MONADWU- 
   Warnings: 
      [1] rightPower: signature of lhs not unique: SS(NonNegativeInteger) chosen
      [2] leftPower: signature of lhs not unique: SS(NonNegativeInteger) chosen

============================================================================

   finalizing nrlib MONADWU 
; (DEFUN |MonadWithUnit| ...) is being compiled.
;; The variable |MonadWithUnit;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib NARNG 
; (DEFUN |NonAssociativeRng| ...) is being compiled.
;; The variable |NonAssociativeRng;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib OASGP 
; (DEFUN |OrderedAbelianSemiGroup| ...) is being compiled.
;; The variable |OrderedAbelianSemiGroup;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib ORDFIN 
; (DEFUN |OrderedFinite| ...) is being compiled.
;; The variable |OrderedFinite;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib ORDMON 
; (DEFUN |OrderedMonoid| ...) is being compiled.
;; The variable |OrderedMonoid;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib PATMATCH 
   Warnings: 
      [1] ist: not known that (SetCategory) is of mode (CATEGORY package (SIGNATURE is? ((Boolean) Subject Pat)) (SIGNATURE is? ((Boolean) (List Subject) Pat)) (SIGNATURE Is ((PatternMatchListResult Base Subject (List Subject)) (List Subject) Pat)) (IF (has Subject (RetractableTo (Symbol))) (SIGNATURE Is ((List (Equation Subject)) Subject Pat)) (IF (has Subject (Ring)) (SIGNATURE Is ((List (Equation (Polynomial Subject))) Subject Pat)) (SIGNATURE Is ((PatternMatchResult Base Subject) Subject Pat)))))

============================================================================

   finalizing nrlib PERMCAT 
; (DEFUN |PermutationCategory| ...) is being compiled.
;; The variable |PermutationCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |PermutationCategory;| ...) is being compiled.
;; The variable |PermutationCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib PDRING 
; (DEFUN |PartialDifferentialRing| ...) is being compiled.
;; The variable |PartialDifferentialRing;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |PartialDifferentialRing;| ...) is being compiled.
;; The variable |PartialDifferentialRing;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib TRIGCAT 
; (DEFUN |TrigonometricFunctionCategory| ...) is being compiled.
;; The variable |TrigonometricFunctionCategory;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib BGAGG 
; (DEFUN |BagAggregate| ...) is being compiled.
;; The variable |BagAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |BagAggregate;| ...) is being compiled.
;; The variable |BagAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib BRAGG 
; (DEFUN |BinaryRecursiveAggregate| ...) is being compiled.
;; The variable |BinaryRecursiveAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |BinaryRecursiveAggregate;| ...) is being compiled.
;; The variable |BinaryRecursiveAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib DIFEXT 
; (DEFUN |DifferentialExtension| ...) is being compiled.
;; The variable |DifferentialExtension;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |DifferentialExtension;| ...) is being compiled.
;; The variable |DifferentialExtension;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib DLAGG 
; (DEFUN |DoublyLinkedAggregate| ...) is being compiled.
;; The variable |DoublyLinkedAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |DoublyLinkedAggregate;| ...) is being compiled.
;; The variable |DoublyLinkedAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib ELAGG 
; (DEFUN |ExtensibleLinearAggregate| ...) is being compiled.
;; The variable |ExtensibleLinearAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |ExtensibleLinearAggregate;| ...) is being compiled.
;; The variable |ExtensibleLinearAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib ES2 
   Warnings: 
      [1] map:  IN has no value
      [2] map:  x has no value

============================================================================

   finalizing nrlib GRMOD 
; (DEFUN |GradedModule| ...) is being compiled.
;; The variable |GradedModule;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |GradedModule;| ...) is being compiled.
;; The variable |GradedModule;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib HYPCAT 
; (DEFUN |HyperbolicFunctionCategory| ...) is being compiled.
;; The variable |HyperbolicFunctionCategory;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib MODRING 
   Warnings: 
      [1] coerce: signature of lhs not unique: R$ chosen

============================================================================

   finalizing nrlib MODULE 
; (DEFUN |Module| ...) is being compiled.
;; The variable |Module;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |Module;| ...) is being compiled.
;; The variable |Module;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib NASRING 
; (DEFUN |NonAssociativeRing| ...) is being compiled.
;; The variable |NonAssociativeRing;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib ZMOD 
; (DEFUN |IntegerMod;| ...) is being compiled.
;; The variable IDENTITY is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib ALGEBRA 
; (DEFUN |Algebra| ...) is being compiled.
;; The variable |Algebra;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |Algebra;| ...) is being compiled.
;; The variable |Algebra;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib BTCAT 
; (DEFUN |BinaryTreeCategory| ...) is being compiled.
;; The variable |BinaryTreeCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |BinaryTreeCategory;| ...) is being compiled.
;; The variable |BinaryTreeCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FMCAT 
; (DEFUN |FreeModuleCat| ...) is being compiled.
;; The variable |FreeModuleCat;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |FreeModuleCat;| ...) is being compiled.
;; The variable |FreeModuleCat;CAT| is undefined.
;; The compiler will assume this variable is a global.

--------------non extending category----------------------
.. InnerFreeAbelianMonoid(#1,#2,#3) of cat 
(|FreeAbelianMonoidCategory| |#1| |#2|)    has no  outputForm : (%,((OutputForm,OutputForm) -> OutputForm),((OutputForm,OutputForm) -> OutputForm),Integer) -> OutputForm 
============================================================================

   finalizing nrlib IFAMON 

============================================================================

   finalizing nrlib GRALG 
; (DEFUN |GradedAlgebra| ...) is being compiled.
;; The variable |GradedAlgebra;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |GradedAlgebra;| ...) is being compiled.
;; The variable |GradedAlgebra;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib OCAMON 
; (DEFUN |OrderedCancellationAbelianMonoid| ...) is being compiled.
;; The variable |OrderedCancellationAbelianMonoid;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib PRQAGG 
; (DEFUN |PriorityQueueAggregate| ...) is being compiled.
;; The variable |PriorityQueueAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |PriorityQueueAggregate;| ...) is being compiled.
;; The variable |PriorityQueueAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib QUAGG 
; (DEFUN |QueueAggregate| ...) is being compiled.
;; The variable |QueueAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |QueueAggregate;| ...) is being compiled.
;; The variable |QueueAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib SKAGG 
; (DEFUN |StackAggregate| ...) is being compiled.
;; The variable |StackAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |StackAggregate;| ...) is being compiled.
;; The variable |StackAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

--------------non extending category----------------------
.. BinarySearchTree #1 of cat 
(|Join| (|BinaryTreeCategory| |#1|) (CATEGORY |domain| (ATTRIBUTE |shallowlyMutable|) (ATTRIBUTE |finiteAggregate|) (SIGNATURE |binarySearchTree| ($ (|List| |#1|))) (SIGNATURE |insert!| ($ |#1| $)) (SIGNATURE |insertRoot!| ($ |#1| $)) (SIGNATURE |split| ((|Record| (|:| |less| $) (|:| |greater| $)) |#1| $))))    has no  binaryTree : #1 -> % 

--------------non extending category----------------------
.. BinaryTournament #1 of cat 
(|Join| (|BinaryTreeCategory| |#1|) (CATEGORY |domain| (ATTRIBUTE |shallowlyMutable|) (SIGNATURE |binaryTournament| ($ (|List| |#1|))) (SIGNATURE |insert!| ($ |#1| $))))    has no  binaryTree : #1 -> % 

============================================================================

   finalizing nrlib CARD 
   Warnings: 
      [1] **: signature of lhs not unique: $$$ chosen
      [2] **: :(NonNegativeInteger) -- should replace by pretend

============================================================================

   finalizing nrlib CARD 
--->/research2/test0819/mnt/fedora5/../../src/algebra/CARD.spad-->CardinalNumber((commutative (attribute *))): Improper first word in comments: a
"a domain \\spad{D} has \\spad{commutative(\"*\")} if it has an operation \\spad{\"*\": (D,{}D) -> D} which is commutative."

============================================================================

   finalizing nrlib DQAGG 
; (DEFUN |DequeueAggregate| ...) is being compiled.
;; The variable |DequeueAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |DequeueAggregate;| ...) is being compiled.
;; The variable |DequeueAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FACTFUNC 
   Warnings: 
      [1] nthRoot:  radi has no value

============================================================================

   finalizing nrlib FMTC 
; (DEFUN |FortranMachineTypeCategory| ...) is being compiled.
;; The variable |FortranMachineTypeCategory;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib MLO 
; (DEFUN |MonogenicLinearOperator| ...) is being compiled.
;; The variable |MonogenicLinearOperator;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |MonogenicLinearOperator;| ...) is being compiled.
;; The variable |MonogenicLinearOperator;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib NAALG 
; (DEFUN |NonAssociativeAlgebra| ...) is being compiled.
;; The variable |NonAssociativeAlgebra;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NonAssociativeAlgebra;| ...) is being compiled.
;; The variable |NonAssociativeAlgebra;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib NEWTON 
--->-->NewtonInterpolation((newton ((SparseUnivariatePolynomial F) (List F)))): Not documented!!!!

============================================================================

   finalizing nrlib OAGROUP 
; (DEFUN |OrderedAbelianGroup| ...) is being compiled.
;; The variable |OrderedAbelianGroup;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib OAMONS 
; (DEFUN |OrderedAbelianMonoidSup| ...) is being compiled.
;; The variable |OrderedAbelianMonoidSup;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib PID 
; (DEFUN |PrincipalIdealDomain| ...) is being compiled.
;; The variable |PrincipalIdealDomain;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib XALG 
; (DEFUN |XAlgebra| ...) is being compiled.
;; The variable |XAlgebra;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |XAlgebra;| ...) is being compiled.
;; The variable |XAlgebra;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib AMR 
; (DEFUN |AbelianMonoidRing| ...) is being compiled.
;; The variable |AbelianMonoidRing;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AbelianMonoidRing;| ...) is being compiled.
;; The variable |AbelianMonoidRing;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FAGROUP 
   Warnings: 
      [1] <:  exp has no value
      [2] <:  gen has no value

============================================================================

   finalizing nrlib FIELD- 
   Warnings: 
      [1] squareFree: not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE / (S S S)) (SIGNATURE inv (S S)) (SIGNATURE prime? ((Boolean) S)) (SIGNATURE squareFree ((Factored S) S)) (SIGNATURE factor ((Factored S) S)) (SIGNATURE divide ((Record (: quotient S) (: remainder S)) S S)) (SIGNATURE euclideanSize ((NonNegativeInteger) S)) (SIGNATURE gcd (S (List S))) (SIGNATURE gcd (S S S)) (SIGNATURE associates? ((Boolean) S S)) (SIGNATURE unitCanonical (S S)) (SIGNATURE unitNormal ((Record (: unit S) (: canonical S) (: associate S)) S)) (SIGNATURE exquo ((Union S failed) S S)))

============================================================================

   finalizing nrlib FIELD 
; (DEFUN |Field| ...) is being compiled.
;; The variable |Field;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FLAGG 
; (DEFUN |FiniteLinearAggregate| ...) is being compiled.
;; The variable |FiniteLinearAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |FiniteLinearAggregate;| ...) is being compiled.
;; The variable |FiniteLinearAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FLINEXP- 
   Warnings: 
      [1] reducedSystem: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix R)) (: vec (Vector R))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Matrix R) (Matrix S))))

============================================================================

   finalizing nrlib FLINEXP 
; (DEFUN |FullyLinearlyExplicitRingOver| ...) is being compiled.
;; The variable |FullyLinearlyExplicitRingOver;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |FullyLinearlyExplicitRingOver;| ...) is being compiled.
;; The variable |FullyLinearlyExplicitRingOver;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FRETRCT 
; (DEFUN |FullyRetractableTo| ...) is being compiled.
;; The variable |FullyRetractableTo;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |FullyRetractableTo;| ...) is being compiled.
;; The variable |FullyRetractableTo;CAT| is undefined.
;; The compiler will assume this variable is a global.

--------------non extending category----------------------
.. FourierSeries(#1,#2) of cat 
(|Join| (|Algebra| |#1|) (CATEGORY |domain| (IF (|has| |#2| (ATTRIBUTE |canonical|)) (IF (|has| |#1| (ATTRIBUTE |canonical|)) (ATTRIBUTE |canonical|) |noBranch|) |noBranch|) (SIGNATURE |coerce| ($ |#1|)) (SIGNATURE |coerce| ($ (|FourierComponent| |#2|))) (SIGNATURE |makeSin| ($ |#2| |#1|)) (SIGNATURE |makeCos| ($ |#2| |#1|))))   has no 
============================================================================

(|IndexedDirectProductCategory| |#1| (|FourierComponent| |#2|))    finalizing nrlib FSERIES 

============================================================================

   finalizing nrlib FT 
   Semantic Errors: 
      [1]  void is not a known type

============================================================================

   finalizing nrlib IDPAG 
   Warnings: 
      [1] -:  res has no value
      [2] -:  endcell has no value

--------------non extending category----------------------
.. LocalAlgebra(#1,#2,#3) of cat 
(|Join| (|Algebra| |#2|) (CATEGORY |domain| (IF (|has| |#1| (|OrderedRing|)) (ATTRIBUTE (|OrderedRing|)) |noBranch|) (SIGNATURE / ($ $ |#3|)) (SIGNATURE / ($ |#1| |#3|)) (SIGNATURE |numer| (|#1| $)) (SIGNATURE |denom| (|#3| $))))   has no 
============================================================================

(IF (|has| |#1| (|OrderedAbelianGroup|)) (ATTRIBUTE (|OrderedAbelianGroup|)) |noBranch|)    finalizing nrlib LA 

============================================================================

   finalizing nrlib OMLO 
   Warnings: 
      [1] op: :$ -- should replace by @
      [2] po: :P -- should replace by pretend
      [3] *: :P -- should replace by pretend
      [4] coerce: :P -- should replace by pretend

============================================================================

   finalizing nrlib PADICCT 
; (DEFUN |PAdicIntegerCategory| ...) is being compiled.
;; The variable |PAdicIntegerCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |PAdicIntegerCategory;| ...) is being compiled.
;; The variable |PAdicIntegerCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib RADCAT 
; (DEFUN |RadicalCategory| ...) is being compiled.
;; The variable |RadicalCategory;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib XFALG 
; (DEFUN |XFreeAlgebra| ...) is being compiled.
;; The variable |XFreeAlgebra;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |XFreeAlgebra;| ...) is being compiled.
;; The variable |XFreeAlgebra;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib A1AGG 
; (DEFUN |OneDimensionalArrayAggregate| ...) is being compiled.
;; The variable |OneDimensionalArrayAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |OneDimensionalArrayAggregate;| ...) is being compiled.
;; The variable |OneDimensionalArrayAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib ARR2CAT 
; (DEFUN |TwoDimensionalArrayCategory| ...) is being compiled.
;; The variable |TwoDimensionalArrayCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |TwoDimensionalArrayCategory;| ...) is being compiled.
;; The variable |TwoDimensionalArrayCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib ASP34 
   Semantic Errors: 
      [1] coerce:  code is BOTH a variable and a literal
 
   Warnings: 
      [1]  IFLAG has no value
      [2]  N has no value
      [3]  X has no value
      [4]  Y has no value
      [5]  LRWORK has no value
      [6]  LIWORK has no value
      [7]  RWORK has no value
      [8]  IWORK has no value
      [9] coerce:  I has no value
      [10] coerce:  J has no value
      [11] coerce:  W1 has no value
      [12] coerce:  W2 has no value
      [13] coerce:  MS has no value

--------------non extending category----------------------
.. BalancedBinaryTree #1 of cat 
(|Join| (|BinaryTreeCategory| |#1|) (CATEGORY |domain| (ATTRIBUTE |finiteAggregate|) (ATTRIBUTE |shallowlyMutable|) (SIGNATURE |balancedBinaryTree| ($ (|NonNegativeInteger|) |#1|)) (SIGNATURE |setleaves!| ($ $ (|List| |#1|))) (SIGNATURE |mapUp!| (|#1| $ (|Mapping| |#1| |#1| |#1|))) (SIGNATURE |mapUp!| ($ $ $ (|Mapping| |#1| |#1| |#1| |#1| |#1|))) (SIGNATURE |mapDown!| ($ $ |#1| (|Mapping| |#1| |#1| |#1|))) (SIGNATURE |mapDown!| ($ $ |#1| (|Mapping| (|List| |#1|) |#1| |#1| |#1|)))))    has no  binaryTree : #1 -> % 

============================================================================

   finalizing nrlib BFUNCT 
   Processing BasicFunctions for Browser database:
--->/research2/test0819/mnt/fedora5/../../src/algebra/BFUNCT.spad-->BasicFunctions(constructor): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/BFUNCT.spad-->BasicFunctions(): Missing Description

============================================================================

   finalizing nrlib BTREE 
   Warnings: 
      [1] empty: pretend$ -- should replace by @
      [2] node: :Rep -- should replace by pretend
      [3] setvalue!: :Rep -- should replace by pretend
      [4] setleft!: :Rep -- should replace by pretend
      [5] setright!: :(List (Tree S)) -- should replace by pretend

--------------non extending category----------------------
.. Dequeue #1 of cat 
(|Join| (|DequeueAggregate| |#1|) (CATEGORY |domain| (SIGNATURE |dequeue| ($ (|List| |#1|)))))    has no  queue : List #1 -> % 

--------------non extending category----------------------
.. DataList #1 of cat 
(|Join| (|ListAggregate| |#1|) (CATEGORY |domain| (SIGNATURE |coerce| ($ (|List| |#1|))) (SIGNATURE |coerce| ((|List| |#1|) $)) (SIGNATURE |datalist| ($ (|List| |#1|))) (SIGNATURE |elt| ($ $ "unique")) (SIGNATURE |elt| ($ $ "sort")) (SIGNATURE |elt| ((|NonNegativeInteger|) $ "count"))))    has no  nil : () -> % 

============================================================================

   finalizing nrlib DRAWCX 
--->/research2/test0819/mnt/fedora5/../../src/algebra/DRAWCX.spad-->DrawComplex(constructor): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/DRAWCX.spad-->DrawComplex(): Missing Description

--------------non extending category----------------------
.. d01gbfAnnaType of cat 
(|NumericalIntegrationCategory|)   has no 
============================================================================

(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib D01GBFA 

--------------non extending category----------------------
.. d02ejfAnnaType of cat 
(|OrdinaryDifferentialEquationsSolverCategory|)   has no 
============================================================================

(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib D02EJFA 

--------------non extending category----------------------
.. d03fafAnnaType of cat 
(|PartialDifferentialEquationsSolverCategory|)   has no 
============================================================================

(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib D03FAFA 

============================================================================

   finalizing nrlib FAMR 
; (DEFUN |FiniteAbelianMonoidRing| ...) is being compiled.
;; The variable |FiniteAbelianMonoidRing;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |FiniteAbelianMonoidRing;| ...) is being compiled.
;; The variable |FiniteAbelianMonoidRing;CAT| is undefined.
;; The compiler will assume this variable is a global.

   FLASORT abbreviates package FiniteLinearAggregateSort 
(PUSH (QUOTE |FiniteLinearAggregateSort|) |$mutableDomains|)
Value = (|FiniteLinearAggregateSort|)

--------------non extending category----------------------
.. FreeGroup #1 of cat 
(|Join| (|Group|) (|RetractableTo| |#1|) (CATEGORY |domain| (SIGNATURE * ($ |#1| $)) (SIGNATURE * ($ $ |#1|)) (SIGNATURE ** ($ |#1| (|Integer|))) (SIGNATURE |size| ((|NonNegativeInteger|) $)) (SIGNATURE |nthExpon| ((|Integer|) $ (|Integer|))) (SIGNATURE |nthFactor| (|#1| $ (|Integer|))) (SIGNATURE |mapExpon| ($ (|Mapping| (|Integer|) (|Integer|)) $)) (SIGNATURE |mapGen| ($ (|Mapping| |#1| |#1|) $)) (SIGNATURE |factors| ((|List| (|Record| (|:| |gen| |#1|) (|:| |exp| (|Integer|)))) $))))    has no  outputForm : (%,((OutputForm,OutputForm) -> OutputForm),((OutputForm,OutputForm) -> OutputForm),Integer) -> OutputForm 

============================================================================

   finalizing nrlib FM1 
   Warnings: 
      [1] ListOfTerms: :(List (Record (: k S) (: c R))) -- should replace by pretend

--------------non extending category----------------------
.. FreeModule1(#1,#2) of cat 
(|Join| (|FreeModuleCat| |#1| |#2|) (CATEGORY |domain| (SIGNATURE * ($ |#2| |#1|))))   has no 
============================================================================

(|IndexedDirectProductCategory| |#1| |#2|)    finalizing nrlib FM1 

============================================================================

   finalizing nrlib FPC 
; (DEFUN |FieldOfPrimeCharacteristic| ...) is being compiled.
;; The variable |FieldOfPrimeCharacteristic;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FMONOID 
   Warnings: 
      [1] overlap:  l has no value
      [2] divide:  l has no value
      [3] hclf:  h has no value
      [4] lquo:  gen has no value
      [5] lquo:  exp has no value

============================================================================

   finalizing nrlib FMONOID 
--------------non extending category----------------------
.. FreeMonoid #1 of cat 
(|Join| (|Monoid|) (|RetractableTo| |#1|) (CATEGORY |domain| (SIGNATURE * ($ |#1| $)) (SIGNATURE * ($ $ |#1|)) (SIGNATURE ** ($ |#1| (|NonNegativeInteger|))) (SIGNATURE |hclf| ($ $ $)) (SIGNATURE |hcrf| ($ $ $)) (SIGNATURE |lquo| ((|Union| $ "failed") $ $)) (SIGNATURE |rquo| ((|Union| $ "failed") $ $)) (SIGNATURE |divide| ((|Union| (|Record| (|:| |lm| $) (|:| |rm| $)) "failed") $ $)) (SIGNATURE |overlap| ((|Record| (|:| |lm| $) (|:| |mm| $) (|:| |rm| $)) $ $)) (SIGNATURE |size| ((|NonNegativeInteger|) $)) (SIGNATURE |factors| ((|List| (|Record| (|:| |gen| |#1|) (|:| |exp| (|NonNegativeInteger|)))) $)) (SIGNATURE |nthExpon| ((|NonNegativeInteger|) $ (|Integer|))) (SIGNATURE |nthFactor| (|#1| $ (|Integer|))) (SIGNATURE |mapExpon| ($ (|Mapping| (|NonNegativeInteger|) (|NonNegativeInteger|)) $)) (SIGNATURE |mapGen| ($ (|Mapping| |#1| |#1|) $)) (IF (|has| |#1| (|OrderedSet|)) (ATTRIBUTE (|OrderedSet|)) |noBranch|)))    has no  outputForm : (%,((OutputForm,OutputForm) -> OutputForm),((OutputForm,OutputForm) -> OutputForm),Integer) -> OutputForm 

============================================================================

   finalizing nrlib IPADIC 
   Warnings: 
      [1] padic: pretend$ -- should replace by @
      [2] =:  st has no value
      [3] intToPAdic:  digit has no value
      [4] intToPAdic:  carry has no value
      [5] intPlusPAdic:  digit has no value
      [6] intPlusPAdic:  carry has no value
      [7] intMinusPAdic:  digit has no value
      [8] intMinusPAdic:  carry has no value
      [9] plusAux:  digit has no value
      [10] plusAux:  carry has no value
      [11] minusAux:  digit has no value
      [12] minusAux:  carry has no value
      [13] intMult:  digit has no value
      [14] intMult:  carry has no value
      [15] timesAux:  digit has no value
      [16] timesAux:  carry has no value
      [17] coerce: pretend(Integer) -- should replace by @
      [18] coerce:  l has no value

--------------non extending category----------------------
.. LieExponentials(#1,#2,#3) of cat 
(|Join| (|Group|) (CATEGORY |domain| (SIGNATURE |exp| ($ (|LiePolynomial| |#1| |#2|))) (SIGNATURE |log| ((|LiePolynomial| |#1| |#2|) $)) (SIGNATURE |ListOfTerms| ((|List| (|Record| (|:| |k| (|PoincareBirkhoffWittLyndonBasis| |#1|)) (|:| |c| |#2|))) $)) (SIGNATURE |coerce| ((|XDistributedPolynomial| |#1| |#2|) $)) (SIGNATURE |coerce| ((|XPBWPolynomial| |#1| |#2|) $)) (SIGNATURE |mirror| ($ $)) (SIGNATURE |varList| ((|List| |#1|) $)) (SIGNATURE |LyndonBasis| ((|List| (|LiePolynomial| |#1| |#2|)) (|List| |#1|))) (SIGNATURE |LyndonCoordinates| ((|List| (|Record| (|:| |k| (|LyndonWord| |#1|)) (|:| |c| |#2|))) $)) (SIGNATURE |identification| ((|List| (|Equation| |#2|)) $ $))))   has no 
============================================================================

(|XPolynomialsCat| |#1| |#2|)    finalizing nrlib LEXP 

============================================================================

   finalizing nrlib LIECAT 
; (DEFUN |LieAlgebra| ...) is being compiled.
;; The variable |LieAlgebra;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |LieAlgebra;| ...) is being compiled.
;; The variable |LieAlgebra;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib LMOPS 
   Warnings: 
      [1] mapExpon:  ans has no value
      [2] outputForm: The conditional modes (List (OutputForm)) and $ conflict

============================================================================

   finalizing nrlib LZSTAGG 
; (DEFUN |LazyStreamAggregate| ...) is being compiled.
;; The variable |LazyStreamAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |LazyStreamAggregate;| ...) is being compiled.
;; The variable |LazyStreamAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib MOEBIUS 
   Semantic Errors: 
      [1]  a is BOTH a variable and a literal
      [2]  b is BOTH a variable and a literal
      [3]  c is BOTH a variable and a literal
      [4]  d is BOTH a variable and a literal
      [5] eval:  a is BOTH a variable and a literal
      [6] eval:  b is BOTH a variable and a literal
      [7] eval:  c is BOTH a variable and a literal
      [8] eval:  d is BOTH a variable and a literal
      [9] proportional?:  a is BOTH a variable and a literal
      [10] proportional?:  b is BOTH a variable and a literal
      [11] proportional?:  c is BOTH a variable and a literal
      [12] proportional?:  d is BOTH a variable and a literal
 
   Warnings: 
      [1] recip: signature of lhs not unique: $$ chosen

--------------non extending category----------------------
.. ModuleOperator(#1,#2) of cat 
(|Join| (|Ring|) (|RetractableTo| |#1|) (|RetractableTo| (|BasicOperator|)) (|Eltable| |#2| |#2|) (CATEGORY |domain| (IF (|has| |#1| (|CharacteristicZero|)) (ATTRIBUTE (|CharacteristicZero|)) |noBranch|) (IF (|has| |#1| (|CharacteristicNonZero|)) (ATTRIBUTE (|CharacteristicNonZero|)) |noBranch|) (IF (|has| |#1| (|CommutativeRing|)) (PROGN (ATTRIBUTE (|Algebra| |#1|)) (SIGNATURE |adjoint| ($ $)) (SIGNATURE |adjoint| ($ $ $)) (SIGNATURE |conjug| (|#1| |#1|))) |noBranch|) (SIGNATURE |evaluate| ($ $ (|Mapping| |#2| |#2|))) (SIGNATURE |evaluateInverse| ($ $ (|Mapping| |#2| |#2|))) (SIGNATURE ** ($ (|BasicOperator|) (|Integer|))) (SIGNATURE ** ($ $ (|Integer|))) (SIGNATURE |opeval| (|#2| (|BasicOperator|) |#2|)) (SIGNATURE |makeop| ($ |#1| (|FreeGroup| (|BasicOperator|))))))   has no 
============================================================================

(|Module| (|Integer|))    finalizing nrlib MODOP 

============================================================================

   finalizing nrlib MRING 
   Warnings: 
      [1] index:  ans has no value
      [2] retractIfCan:  coef has no value
      [3] retractIfCan:  monom has no value
      [4] recip:  monom has no value
      [5] recip:  coef has no value
      [6] coerce:  coef has no value
      [7] coerce:  monom has no value
      [8] =:  coef has no value
      [9] =:  monom has no value
      [10] sortAndAdd:  m has no value
      [11] sortAndAdd:  res has no value

--------------non extending category----------------------
.. OrderedFreeMonoid #1 of cat 
(|Join| (|OrderedMonoid|) (|RetractableTo| |#1|) (CATEGORY |domain| (SIGNATURE * ($ |#1| $)) (SIGNATURE * ($ $ |#1|)) (SIGNATURE ** ($ |#1| (|NonNegativeInteger|))) (SIGNATURE |first| (|#1| $)) (SIGNATURE |rest| ($ $)) (SIGNATURE |mirror| ($ $)) (SIGNATURE |lexico| ((|Boolean|) $ $)) (SIGNATURE |hclf| ($ $ $)) (SIGNATURE |hcrf| ($ $ $)) (SIGNATURE |lquo| ((|Union| $ "failed") $ $)) (SIGNATURE |rquo| ((|Union| $ "failed") $ $)) (SIGNATURE |lquo| ((|Union| $ "failed") $ |#1|)) (SIGNATURE |rquo| ((|Union| $ "failed") $ |#1|)) (SIGNATURE |div| ((|Union| (|Record| (|:| |lm| $) (|:| |rm| $)) "failed") $ $)) (SIGNATURE |overlap| ((|Record| (|:| |lm| $) (|:| |mm| $) (|:| |rm| $)) $ $)) (SIGNATURE |size| ((|NonNegativeInteger|) $)) (SIGNATURE |nthExpon| ((|NonNegativeInteger|) $ (|Integer|))) (SIGNATURE |nthFactor| (|#1| $ (|Integer|))) (SIGNATURE |factors| ((|List| (|Record| (|:| |gen| |#1|) (|:| |exp| (|NonNegativeInteger|)))) $)) (SIGNATURE |length| ((|NonNegativeInteger|) $)) (SIGNATURE |varList| ((|List| |#1|) $))))    has no  divide : (%,%) -> Union(Record(lm: %,rm: %),"failed") 

============================================================================

   finalizing nrlib ONECOMP 
; (DEFUN |OnePointCompletion;| ...) is being compiled.
;; The variable IDENTITY is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib ORDCOMP 
   Warnings: 
      [1] retract:  fin has no value
      [2] retractIfCan:  fin has no value
      [3] coerce:  fin has no value
      [4] coerce:  inf has no value
      [5] whatInfinity:  inf has no value
      [6] =:  inf has no value
      [7] =:  fin has no value
      [8] *:  inf has no value
      [9] *:  fin has no value
      [10] -:  inf has no value
      [11] -:  fin has no value
      [12] +:  inf has no value
      [13] +:  fin has no value
      [14] recip:  fin has no value
      [15] <:  inf has no value
      [16] <:  fin has no value

============================================================================

   finalizing nrlib ORDCOMP 
; (DEFUN |OrderedCompletion;| ...) is being compiled.
;; The variable IDENTITY is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib OREPCAT 
; (DEFUN |UnivariateSkewPolynomialCategory| ...) is being compiled.
;; The variable |UnivariateSkewPolynomialCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |UnivariateSkewPolynomialCategory;| ...) is being compiled.
;; The variable |UnivariateSkewPolynomialCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib PENDTREE 
   Warnings: 
      [1] ptree: pretend$ -- should replace by @
      [2] ptree: :Rep -- should replace by pretend
      [3] ptree: :$ -- should replace by @
      [4] =: :Rep -- should replace by pretend

============================================================================

   finalizing nrlib PFR 
   Warnings: 
      [1] LessThan: :(Boolean) -- should replace by pretend
      [2] multiplyFracTerms: :Rep -- should replace by pretend
      [3] multiplyFracTerms:  c has no value
      [4] compactFraction: :(NonNegativeInteger) -- should replace by pretend
      [5] compactFraction:  s has no value
      [6] compactFraction:  bf has no value

============================================================================

   finalizing nrlib PMDOWN 
   Warnings: 
      [1] patternMatch: not known that (SetCategory) is of mode (CATEGORY package (SIGNATURE fixPredicate ((Mapping (Boolean) A) (Mapping (Boolean) B))) (SIGNATURE patternMatch ((PatternMatchResult S B) A (Pattern S) (PatternMatchResult S B))))

============================================================================

   finalizing nrlib PRTITION 
   Warnings: 
      [1] coerce: signature of lhs not unique: (List (Integer))$ chosen
      [2] conjugate: pretendRep -- should replace by @
      [3] coerce: pretendRep -- should replace by @
      [4] pdct: pretendRep -- should replace by @

============================================================================

   finalizing nrlib PMLSAGG 
   Warnings: 
      [1] match: not known that (SetCategory) is of mode (CATEGORY package (SIGNATURE patternMatch ((PatternMatchListResult S R L) L (Pattern S) (PatternMatchListResult S R L))))

============================================================================

   finalizing nrlib PSCAT 
; (DEFUN |PowerSeriesCategory| ...) is being compiled.
;; The variable |PowerSeriesCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |PowerSeriesCategory;| ...) is being compiled.
;; The variable |PowerSeriesCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

--------------non extending category----------------------
.. QuadraticForm(#1,#2) of cat 
(|Join| (|AbelianGroup|) (CATEGORY |domain| (SIGNATURE |quadraticForm| ($ (|SquareMatrix| |#1| |#2|))) (SIGNATURE |matrix| ((|SquareMatrix| |#1| |#2|) $)) (SIGNATURE |elt| (|#2| $ (|DirectProduct| |#1| |#2|)))))   has no 
============================================================================

(|SquareMatrixCategory| |#1| |#2| (|DirectProduct| |#1| |#2|) (|DirectProduct| |#1| |#2|))    finalizing nrlib QFORM 

--------------non extending category----------------------
.. Queue #1 of cat 
(|Join| (|QueueAggregate| |#1|) (CATEGORY |domain| (SIGNATURE |queue| ($ (|List| |#1|)))))   has no 
============================================================================

(|StackAggregate| |#1|)    finalizing nrlib QUEUE 

============================================================================

   finalizing nrlib SEXOF 
   Warnings: 
      [1] convert: pretend$ -- should replace by @

============================================================================

   finalizing nrlib STTAYLOR 
   Warnings: 
      [1] powern:  order has no value

============================================================================

   finalizing nrlib TRANFUN 
; (DEFUN |TranscendentalFunctionCategory| ...) is being compiled.
;; The variable |TranscendentalFunctionCategory;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib VSPACE 
; (DEFUN |VectorSpace| ...) is being compiled.
;; The variable |VectorSpace;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |VectorSpace;| ...) is being compiled.
;; The variable |VectorSpace;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib XPOLYC 
; (DEFUN |XPolynomialsCat| ...) is being compiled.
;; The variable |XPolynomialsCat;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |XPolynomialsCat;| ...) is being compiled.
;; The variable |XPolynomialsCat;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib XPR 
   Warnings: 
      [1] quasiRegular?:  k has no value
      [2] *:  k has no value
      [3] *:  c has no value

--------------non extending category----------------------
.. XPolynomialRing(#1,#2) of cat 
(|Join| (|Ring|) (|XAlgebra| |#1|) (|FreeModuleCat| |#1| |#2|) (CATEGORY |domain| (SIGNATURE * ($ $ |#1|)) (SIGNATURE |#| ((|NonNegativeInteger|) $)) (SIGNATURE |coerce| ($ |#2|)) (SIGNATURE |maxdeg| (|#2| $)) (SIGNATURE |mindeg| (|#2| $)) (SIGNATURE |reductum| ($ $)) (SIGNATURE |coef| (|#1| $ |#2|)) (SIGNATURE |constant?| ((|Boolean|) $)) (SIGNATURE |constant| (|#1| $)) (SIGNATURE |quasiRegular?| ((|Boolean|) $)) (SIGNATURE |quasiRegular| ($ $)) (SIGNATURE |map| ($ (|Mapping| |#1| |#1|) $)) (IF (|has| |#1| (|Field|)) (SIGNATURE / ($ $ |#1|)) |noBranch|) (IF (|has| |#1| (ATTRIBUTE |noZeroDivisors|)) (ATTRIBUTE |noZeroDivisors|) |noBranch|) (IF (|has| |#1| (ATTRIBUTE |unitsKnown|)) (ATTRIBUTE |unitsKnown|) |noBranch|) (IF (|has| |#1| (ATTRIBUTE |canonicalUnitNormal|)) (ATTRIBUTE |canonicalUnitNormal|) |noBranch|)))    has no  ?*? : (#2,#1) -> % 

============================================================================

   finalizing nrlib COMBINAT 
   Warnings: 
      [1] binomial:  s has no value
      [2] binomial:  b has no value

--------------non extending category----------------------
.. d01fcfAnnaType of cat 
(|NumericalIntegrationCategory|)   has no 
============================================================================

(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib D01FCFA 

--------------non extending category----------------------
.. e04mbfAnnaType of cat 
(|NumericalOptimizationCategory|)   has no 
============================================================================

(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib E04MBFA 

============================================================================

   finalizing nrlib FLALG 
; (DEFUN |FreeLieAlgebra| ...) is being compiled.
;; The variable |FreeLieAlgebra;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |FreeLieAlgebra;| ...) is being compiled.
;; The variable |FreeLieAlgebra;CAT| is undefined.
;; The compiler will assume this variable is a global.

--------------non extending category----------------------
.. Heap #1 of cat 
(|Join| (|PriorityQueueAggregate| |#1|) (CATEGORY |domain| (SIGNATURE |heap| ($ (|List| |#1|)))))   has no 
============================================================================

(|OneDimensionalArrayAggregate| |#1|)    finalizing nrlib HEAP 

============================================================================

   finalizing nrlib IFARRAY 
   Warnings: 
      [1] remove!:  k has no value
      [2] select!:  k has no value

============================================================================

   finalizing nrlib INTCAT 
; (DEFUN |IntervalCategory| ...) is being compiled.
;; The variable |IntervalCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |IntervalCategory;| ...) is being compiled.
;; The variable |IntervalCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib INTHEORY 
   Warnings: 
      [1] fibonacci:  f2 has no value
      [2] jacobi:  j has no value
      [3] eulerPhi: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE bernoulli ((Fraction (Integer)) (Integer))) (SIGNATURE chineseRemainder ((Integer) (Integer) (Integer) (Integer) (Integer))) (SIGNATURE divisors ((List (Integer)) (Integer))) (SIGNATURE euler ((Integer) (Integer))) (SIGNATURE eulerPhi ((Integer) (Integer))) (SIGNATURE fibonacci ((Integer) (Integer))) (SIGNATURE harmonic ((Fraction (Integer)) (Integer))) (SIGNATURE jacobi ((Integer) (Integer) (Integer))) (SIGNATURE legendre ((Integer) (Integer) (Integer))) (SIGNATURE moebiusMu ((Integer) (Integer))) (SIGNATURE numberOfDivisors ((Integer) (Integer))) (SIGNATURE sumOfDivisors ((Integer) (Integer))) (SIGNATURE sumOfKthPowerDivisors ((Integer) (Integer) (NonNegativeInteger))))

============================================================================

   finalizing nrlib LFCAT 
; (DEFUN |LiouvillianFunctionCategory| ...) is being compiled.
;; The variable |LiouvillianFunctionCategory;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib LODOCAT 
; (DEFUN |LinearOrdinaryDifferentialOperatorCategory| ...) is being compiled.
;; The variable |LinearOrdinaryDifferentialOperatorCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |LinearOrdinaryDifferentialOperatorCategory;| ...) is being compiled.
;; The variable |LinearOrdinaryDifferentialOperatorCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib LWORD 
   Warnings: 
      [1] factor1:  d has no value
      [2] LyndonWordsList1: :(Integer) -- should replace by pretend
      [3] LyndonWordsList1:  lbase1 has no value

--------------non extending category----------------------
.. LyndonWord #1 of cat 
(|Join| (|OrderedSet|) (|RetractableTo| |#1|) (CATEGORY |domain| (SIGNATURE |retractable?| ((|Boolean|) $)) (SIGNATURE |left| ($ $)) (SIGNATURE |right| ($ $)) (SIGNATURE |length| ((|PositiveInteger|) $)) (SIGNATURE |lexico| ((|Boolean|) $ $)) (SIGNATURE |coerce| ((|OrderedFreeMonoid| |#1|) $)) (SIGNATURE |coerce| ((|Magma| |#1|) $)) (SIGNATURE |factor| ((|List| $) (|OrderedFreeMonoid| |#1|))) (SIGNATURE |lyndon?| ((|Boolean|) (|OrderedFreeMonoid| |#1|))) (SIGNATURE |lyndon| ($ (|OrderedFreeMonoid| |#1|))) (SIGNATURE |lyndonIfCan| ((|Union| $ "failed") (|OrderedFreeMonoid| |#1|))) (SIGNATURE |varList| ((|List| |#1|) $)) (SIGNATURE |LyndonWordsList1| ((|OneDimensionalArray| (|List| $)) (|List| |#1|) (|PositiveInteger|))) (SIGNATURE |LyndonWordsList| ((|List| $) (|List| |#1|) (|PositiveInteger|)))))    has no  ?*? : (%,%) -> % 

============================================================================

   finalizing nrlib LWORD 
--->/research2/test0819/mnt/fedora5/../../src/algebra/LWORD.spad-->LyndonWord(): Spurious comments: \spad{=>} right(\spad{l}) \spad{>=} \spad{u}

============================================================================

   finalizing nrlib MATCAT 
; (DEFUN |MatrixCategory| ...) is being compiled.
;; The variable |MatrixCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |MatrixCategory;| ...) is being compiled.
;; The variable |MatrixCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

--------------non extending category----------------------
.. SparseUnivariateSkewPolynomial(#1,#2,#3) of cat 
(|Join| (|UnivariateSkewPolynomialCategory| |#1|) (CATEGORY |domain| (SIGNATURE |outputForm| ((|OutputForm|) $ (|OutputForm|)))))   has no 
============================================================================

(|UnivariatePolynomialCategory| |#1|)    finalizing nrlib ORESUP 
   Processing SparseUnivariateSkewPolynomial for Browser database:

--------------non extending category----------------------
.. UnivariateSkewPolynomial(#1,#2,#3,#4) of cat 
(|Join| (|UnivariateSkewPolynomialCategory| |#2|) (CATEGORY |domain| (SIGNATURE |coerce| ($ (|Variable| |#1|)))))    has no  outputForm : (%,OutputForm) -> OutputForm 

============================================================================

   finalizing nrlib PLOT3D 
   Warnings: 
      [1] select:  fp has no value
      [2] rangeRefine:  c has no value
      [3] rangeRefine:  q has no value
      [4] rangeRefine:  NUMFUNEVALS has no value
      [5] refine:  curves has no value
      [6] plot:  curves has no value

============================================================================

   finalizing nrlib PLOT3D 
; (DEFUN |PLOT3D;select| ...) is being compiled.
;; The variable |$NaNvalue| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |PLOT3D;myTrap| ...) is being compiled.
;; The variable |$numericFailure| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib PR 
   Warnings: 
      [1] times!:  endcell has no value
      [2] times!:  res has no value
      [3] addm!:  newcell has no value
      [4] addm!:  res has no value
      [5] addm!:  endcell has no value
      [6] **: pretend(NonNegativeInteger) -- should replace by @
      [7] ^: pretend(NonNegativeInteger) -- should replace by @
      [8] unitNormal:  lcf has no value
      [9] unitCanonical:  lcf has no value
      [10] fmecg:  rout has no value

--------------non extending category----------------------
.. PolynomialRing(#1,#2) of cat 
(|Join| (|FiniteAbelianMonoidRing| |#1| |#2|) (CATEGORY |domain| (IF (|has| |#1| (|IntegralDomain|)) (IF (|has| |#2| (|CancellationAbelianMonoid|)) (SIGNATURE |fmecg| ($ $ |#2| |#1| $)) |noBranch|) |noBranch|) (IF (|has| |#1| (ATTRIBUTE |canonicalUnitNormal|)) (ATTRIBUTE |canonicalUnitNormal|) |noBranch|)))   has no 
============================================================================

(|IndexedDirectProductCategory| |#1| |#2|)    finalizing nrlib PR 

============================================================================

   finalizing nrlib REDORDER 
   Processing ReductionOfOrder for Browser database:
--------(ReduceOrder (L L F))---------
--------(ReduceOrder ((Record (: eq L) (: op (List F))) L (List F)))---------
--->/research2/test0819/mnt/fedora5/../../src/algebra/REDORDER.spad-->ReductionOfOrder((ReduceOrder ((Record (: eq L) (: op (List F))) L (List F)))): Mismatch: left pren matches right brace
--->/research2/test0819/mnt/fedora5/../../src/algebra/REDORDER.spad-->ReductionOfOrder((ReduceOrder ((Record (: eq L) (: op (List F))) L (List F)))): Missing right brace
"\\spad{ReduceOrder(op,{} [f1,{}...,{}fk])} returns \\spad{[op1,{}[g1,{}...,{}gk]]} such that for any solution \\spad{z} of \\spad{op1 z = 0},{} \\spad{y = gk \\int(g_{k-1} \\int(... \\int(g1 \\int z)...)} is a solution of \\spad{op y = 0}. Each \\spad{\\spad{fi}} must satisfy \\spad{op \\spad{fi} = 0}."

============================================================================

   finalizing nrlib SRAGG- 
--->/research2/test0819/mnt/fedora5/../../src/algebra/SRAGG.spad-->StringAggregate&((leftTrim (% % (CharacterClass)))): Mismatch: left brace matches right pren
--->/research2/test0819/mnt/fedora5/../../src/algebra/SRAGG.spad-->StringAggregate&((leftTrim (% % (CharacterClass)))): Missing left brace
"\\spad{leftTrim(s,{}cc)} returns \\spad{s} with all leading characters in \\spad{cc} deleted. For example,{} \\axiom{leftTrim(\"(abc)\",{} charClass \"()\")} returns \\axiom{\"abc)\"}."
--------(rightTrim (% % (Character)))---------
--------(rightTrim (% % (CharacterClass)))---------
--->/research2/test0819/mnt/fedora5/../../src/algebra/SRAGG.spad-->StringAggregate&((rightTrim (% % (CharacterClass)))): Mismatch: left pren matches right brace
--->/research2/test0819/mnt/fedora5/../../src/algebra/SRAGG.spad-->StringAggregate&((rightTrim (% % (CharacterClass)))): Missing right brace
"\\spad{rightTrim(s,{}cc)} returns \\spad{s} with all trailing occurences of characters in \\spad{cc} deleted. For example,{} \\axiom{rightTrim(\"(abc)\",{} charClass \"()\")} returns \\axiom{\"(abc\"}."

============================================================================

   finalizing nrlib SRAGG 
--->/research2/test0819/mnt/fedora5/../../src/algebra/SRAGG.spad-->StringAggregate((leftTrim (% % (CharacterClass)))): Mismatch: left brace matches right pren
--->/research2/test0819/mnt/fedora5/../../src/algebra/SRAGG.spad-->StringAggregate((leftTrim (% % (CharacterClass)))): Missing left brace
"\\spad{leftTrim(s,{}cc)} returns \\spad{s} with all leading characters in \\spad{cc} deleted. For example,{} \\axiom{leftTrim(\"(abc)\",{} charClass \"()\")} returns \\axiom{\"abc)\"}."
--------(rightTrim (% % (Character)))---------
--------(rightTrim (% % (CharacterClass)))---------
--->/research2/test0819/mnt/fedora5/../../src/algebra/SRAGG.spad-->StringAggregate((rightTrim (% % (CharacterClass)))): Mismatch: left pren matches right brace
--->/research2/test0819/mnt/fedora5/../../src/algebra/SRAGG.spad-->StringAggregate((rightTrim (% % (CharacterClass)))): Missing right brace
"\\spad{rightTrim(s,{}cc)} returns \\spad{s} with all trailing occurences of characters in \\spad{cc} deleted. For example,{} \\axiom{rightTrim(\"(abc)\",{} charClass \"()\")} returns \\axiom{\"(abc\"}."

============================================================================

   finalizing nrlib SRAGG 
; (DEFUN |StringAggregate| ...) is being compiled.
;; The variable |StringAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib STREAM 
   Warnings: 
      [1] pretendS -- should replace by @
      [2] showAllElements: not known that (LazyStreamAggregate S) is of mode (CATEGORY domain (SIGNATURE repeating? ((Boolean) (List S) $)))
      [3] remove: signature of lhs not unique: $(Mapping (Boolean) S)$ chosen
      [4] lazyEval: :(Mapping $) -- should replace by pretend
      [5] expand!:  d has no value

============================================================================

   finalizing nrlib STREAM 
; (DEFUN |STREAM;showAll?;B;12| ...) is being compiled.
;; The variable |$streamsShowAll| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |Stream;| ...) is being compiled.
;; The variable |$NullStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NonNullStream| is undefined.
;; The compiler will assume this variable is a global.

--------------non extending category----------------------
.. TaylorSeries #1 of cat 
(|Join| (|MultivariateTaylorSeriesCategory| |#1| (|Symbol|)) (CATEGORY |domain| (SIGNATURE |coefficient| ((|Polynomial| |#1|) $ (|NonNegativeInteger|))) (SIGNATURE |coerce| ($ (|Symbol|))) (SIGNATURE |coerce| ($ (|Polynomial| |#1|))) (IF (|has| |#1| (|Algebra| (|Fraction| (|Integer|)))) (PROGN (SIGNATURE |integrate| ($ $ (|Symbol|) |#1|)) (SIGNATURE |fintegrate| ($ (|Mapping| $) (|Symbol|) |#1|))) |noBranch|)))    has no  ?*? : (Polynomial #1,%) -> % 

============================================================================

   finalizing nrlib UPSCAT 
; (DEFUN |UnivariatePowerSeriesCategory| ...) is being compiled.
;; The variable |UnivariatePowerSeriesCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |UnivariatePowerSeriesCategory;| ...) is being compiled.
;; The variable |UnivariatePowerSeriesCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib VECTCAT- 
--->/research2/test0819/mnt/fedora5/../../src/algebra/VECTCAT.spad-->VectorCategory&((cross (% % %))): Improper first word in comments: vectorProduct
"vectorProduct(\\spad{u},{}\\spad{v}) constructs the cross product of \\spad{u} and \\spad{v}. Error: if \\spad{u} and \\spad{v} are not of length 3."

============================================================================

   finalizing nrlib VECTCAT 
--->/research2/test0819/mnt/fedora5/../../src/algebra/VECTCAT.spad-->VectorCategory((cross (% % %))): Improper first word in comments: vectorProduct
"vectorProduct(\\spad{u},{}\\spad{v}) constructs the cross product of \\spad{u} and \\spad{v}. Error: if \\spad{u} and \\spad{v} are not of length 3."

============================================================================

   finalizing nrlib VECTCAT 
; (DEFUN |VectorCategory| ...) is being compiled.
;; The variable |VectorCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |VectorCategory;| ...) is being compiled.
;; The variable |VectorCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

--------------non extending category----------------------
.. XDistributedPolynomial(#1,#2) of cat 
(|Join| (|FreeModuleCat| |#2| (|OrderedFreeMonoid| |#1|)) (|XPolynomialsCat| |#1| |#2|))    has no  #? : % -> NonNegativeInteger 

============================================================================

   finalizing nrlib XF 
; (DEFUN |ExtensionField| ...) is being compiled.
;; The variable |ExtensionField;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |ExtensionField;| ...) is being compiled.
;; The variable |ExtensionField;CAT| is undefined.
;; The compiler will assume this variable is a global.

--------------non extending category----------------------
.. XPBWPolynomial(#1,#2) of cat 
(|Join| (|XPolynomialsCat| |#1| |#2|) (|FreeModuleCat| |#2| (|PoincareBirkhoffWittLyndonBasis| |#1|)) (CATEGORY |domain| (SIGNATURE |coerce| ($ (|LiePolynomial| |#1| |#2|))) (SIGNATURE |coerce| ((|XDistributedPolynomial| |#1| |#2|) $)) (SIGNATURE |coerce| ((|XRecursivePolynomial| |#1| |#2|) $)) (SIGNATURE |LiePolyIfCan| ((|Union| (|LiePolynomial| |#1| |#2|) "failed") $)) (SIGNATURE |product| ($ $ $ (|NonNegativeInteger|))) (IF (|has| |#2| (|Module| (|Fraction| (|Integer|)))) (PROGN (SIGNATURE |exp| ($ $ (|NonNegativeInteger|))) (SIGNATURE |log| ($ $ (|NonNegativeInteger|)))) |noBranch|)))    has no  ?*? : (PoincareBirkhoffWittLyndonBasis #1,#2) -> % 

--->/research2/test0819/mnt/fedora5/../../src/algebra/XRPOLY.spad-->XRecursivePolynomial(): Spurious comments: a ajouter

--------------non extending category----------------------
.. Bits of cat 
(|Join| (|BitAggregate|) (CATEGORY |domain| (SIGNATURE |bits| ($ (|NonNegativeInteger|) (|Boolean|)))))    has no  Not : % -> % 

--------------non extending category----------------------
.. LiePolynomial(#1,#2) of cat 
(|Join| (|FreeLieAlgebra| |#1| |#2|) (|FreeModuleCat| |#2| (|LyndonWord| |#1|)) (CATEGORY |domain| (SIGNATURE |LiePolyIfCan| ((|Union| $ "failed") (|XDistributedPolynomial| |#1| |#2|))) (SIGNATURE |construct| ($ (|LyndonWord| |#1|) (|LyndonWord| |#1|))) (SIGNATURE |construct| ($ (|LyndonWord| |#1|) $)) (SIGNATURE |construct| ($ $ (|LyndonWord| |#1|)))))    has no  ?*? : (LyndonWord #1,#2) -> % 

============================================================================

   finalizing nrlib PTCAT 
; (DEFUN |PointCategory| ...) is being compiled.
;; The variable |PointCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |PointCategory;| ...) is being compiled.
;; The variable |PointCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib STRICAT 
; (DEFUN |StringCategory| ...) is being compiled.
;; The variable |StringCategory;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib CARTEN 
   Warnings: 
      [1] index2int:  n has no value
      [2] permsign!:  nTrans has no value
      [3] elt:  n has no value

============================================================================

   finalizing nrlib CLIP 
   Warnings: 
      [1] discardAndSplit:  ans has no value
      [2] clip:  yMax has no value
      [3] clip:  yMin has no value

--------------non extending category----------------------
.. Database #1 of cat 
(|Join| (|SetCategory|) (CATEGORY |domain| (SIGNATURE |elt| ($ $ (|QueryEquation|))) (SIGNATURE |elt| ((|DataList| (|String|)) $ (|Symbol|))) (SIGNATURE + ($ $ $)) (SIGNATURE - ($ $ $)) (SIGNATURE |coerce| ($ (|List| |#1|))) (SIGNATURE |display| ((|Void|) $)) (SIGNATURE |fullDisplay| ((|Void|) $)) (SIGNATURE |fullDisplay| ((|Void|) $ (|PositiveInteger|) (|PositiveInteger|)))))   has no 
============================================================================

(|ListAggregate| |#1|)    finalizing nrlib DBASE 

--------------non extending category----------------------
.. DenavitHartenbergMatrix #1 of cat 
(|Join| (|MatrixCategory| |#1| (|Vector| |#1|) (|Vector| |#1|)) (CATEGORY |domain| (SIGNATURE * ((|Point| |#1|) $ (|Point| |#1|))) (SIGNATURE |identity| ($)) (SIGNATURE |rotatex| ($ |#1|)) (SIGNATURE |rotatey| ($ |#1|)) (SIGNATURE |rotatez| ($ |#1|)) (SIGNATURE |scale| ($ |#1| |#1| |#1|)) (SIGNATURE |translate| ($ |#1| |#1| |#1|))))    has no  diagonalMatrix : Vector #1 -> % 

============================================================================

   finalizing nrlib DIOSP 
   Warnings: 
      [1] dioSolve:  c has no value

============================================================================

   finalizing nrlib DIRPCAT- 
   Warnings: 
      [1] reducedSystem: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE coerce (S (Integer))) (SIGNATURE coerce ((OutputForm) S)) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix S) (Vector S))) (SIGNATURE coerce (S R)) (SIGNATURE differentiate (S S (Mapping R R))) (SIGNATURE differentiate (S S (Mapping R R) (NonNegativeInteger))) (SIGNATURE reducedSystem ((Matrix R) (Matrix S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix R)) (: vec (Vector R))) (Matrix S) (Vector S))) (SIGNATURE size ((NonNegativeInteger))) (SIGNATURE / (S S R)) (SIGNATURE dimension ((CardinalNumber))) (SIGNATURE coerce ((Vector R) S)))

============================================================================

   finalizing nrlib DIRPCAT 
; (DEFUN |DirectProductCategory| ...) is being compiled.
;; The variable |DirectProductCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |DirectProductCategory;| ...) is being compiled.
;; The variable |DirectProductCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

--------------non extending category----------------------
.. d02bbfAnnaType of cat 
(|OrdinaryDifferentialEquationsSolverCategory|)   has no 
============================================================================

(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib D02BBFA 
   Processing d02bbfAnnaType for Browser database:

--------------non extending category----------------------
.. d02bhfAnnaType of cat 
(|OrdinaryDifferentialEquationsSolverCategory|)   has no 
============================================================================

(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib D02BHFA 

============================================================================

   finalizing nrlib D02CJFA 
   Warnings: 
      [1] ODESolve:  i has no value

--------------non extending category----------------------
.. d02cjfAnnaType of cat 
(|OrdinaryDifferentialEquationsSolverCategory|)   has no 
============================================================================

(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib D02CJFA 

============================================================================

   finalizing nrlib FAXF- 
   Warnings: 
      [1] extensionDegree: signature of lhs not unique: (PositiveInteger) chosen
      [2] minimalPolynomial: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE charthRoot ((Union S failed) S)) (SIGNATURE size ((NonNegativeInteger))) (SIGNATURE charthRoot (S S)) (SIGNATURE linearAssociatedLog ((Union (SparseUnivariatePolynomial F) failed) S S)) (SIGNATURE linearAssociatedLog ((SparseUnivariatePolynomial F) S)) (SIGNATURE linearAssociatedOrder ((SparseUnivariatePolynomial F) S)) (SIGNATURE linearAssociatedExp (S S (SparseUnivariatePolynomial F))) (SIGNATURE normal? ((Boolean) S)) (SIGNATURE createNormalElement (S)) (SIGNATURE trace (S S (PositiveInteger))) (SIGNATURE norm (S S (PositiveInteger))) (SIGNATURE minimalPolynomial ((SparseUnivariatePolynomial S) S (PositiveInteger))) (SIGNATURE trace (F S)) (SIGNATURE norm (F S)) (SIGNATURE degree ((PositiveInteger) S)) (SIGNATURE extensionDegree ((PositiveInteger))) (SIGNATURE minimalPolynomial ((SparseUnivariatePolynomial F) S)) (SIGNATURE represents (S (Vector F))) (SIGNATURE coordinates ((Matrix F) (Vector S))) (SIGNATURE coordinates ((Vector F) S)) (SIGNATURE transcendenceDegree ((NonNegativeInteger))) (SIGNATURE extensionDegree ((OnePointCompletion (PositiveInteger)))) (SIGNATURE degree ((OnePointCompletion (PositiveInteger)) S)) (SIGNATURE transcendent? ((Boolean) S)) (SIGNATURE algebraic? ((Boolean) S)) (SIGNATURE dimension ((CardinalNumber))))
      [3] degree: signature of lhs not unique: (PositiveInteger)S chosen

============================================================================

   finalizing nrlib FAXF 
; (DEFUN |FiniteAlgebraicExtensionField| ...) is being compiled.
;; The variable |FiniteAlgebraicExtensionField;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |FiniteAlgebraicExtensionField;| ...) is being compiled.
;; The variable |FiniteAlgebraicExtensionField;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FFPOLY2 
   Warnings: 
      [1] rootOfIrreduciblePoly:  basispointer has no value
      [2] rootOfIrreduciblePoly:  beta has no value

============================================================================

   finalizing nrlib FNLA 
   Warnings: 
      [1] have:  hi has no value

--------------non extending category----------------------
.. FreeNilpotentLie(#1,#2,#3) of cat 
(|Join| (|NonAssociativeAlgebra| |#3|) (CATEGORY |domain| (SIGNATURE |dimension| ((|NonNegativeInteger|))) (SIGNATURE |deepExpand| ((|OutputForm|) $)) (SIGNATURE |shallowExpand| ((|OutputForm|) $)) (SIGNATURE |generator| ($ (|NonNegativeInteger|)))))   has no 
============================================================================

(|IndexedDirectProductCategory| |#3| (|OrdSetInts|))    finalizing nrlib FNLA 

============================================================================

   finalizing nrlib IRSN 
   Warnings: 
      [1] aIdInverse: :(NonNegativeInteger) -- should replace by @
      [2] signum:  s has no value
      [3] signum:  z has no value
      [4] testPermutation:  n has no value
      [5] testPermutation:  ok has no value

============================================================================

   finalizing nrlib MHROWRED 
   Warnings: 
      [1] non0:  allZero has no value
      [2] non0:  ans has no value
      [3] mkMat:  STEP has no value
      [4] mkMat:  i has no value
      [5] diagSubMatrix:  IN has no value
      [6] diagSubMatrix:  r has no value
      [7] diagSubMatrix:  STEP has no value
      [8] diagSubMatrix:  z has no value
      [9] rowEchelonLocal:  pivord has no value

============================================================================

   finalizing nrlib NUMQUAD 
   Warnings: 
      [1] romberg:  change has no value
      [2] simpson:  change has no value
      [3] trapezoidal:  change has no value
      [4] rombergo:  change has no value
      [5] simpsono:  change has no value
      [6] trapezoidalo:  change has no value

============================================================================

   finalizing nrlib ODESYS 
   Warnings: 
      [1] backsolve:  part has no value

============================================================================

   finalizing nrlib PERMAN 
   Warnings: 
      [1] permanent3:  a has no value
      [2] permanent: :(Integer) -- should replace by pretend
      [3] permanent: :(PositiveInteger) -- should replace by pretend
      [4] permanent:  a has no value
      [5] permanent2: :(Integer) -- should replace by pretend
      [6] permanent2: :(PositiveInteger) -- should replace by pretend
      [7] permanent2: :(NonNegativeInteger) -- should replace by pretend
      [8] permanent2:  a has no value

============================================================================

   finalizing nrlib PERMAN 
   Processing Permanent for Browser database:
--->/research2/test0819/mnt/fedora5/../../src/algebra/PERMAN.spad-->Permanent((commutative (attribute *))): Not documented!!!!
--------(permanent (R SM))---------
--->/research2/test0819/mnt/fedora5/../../src/algebra/PERMAN.spad-->Permanent((permanent (R SM))): Mismatch: left pren matches right brace
--->/research2/test0819/mnt/fedora5/../../src/algebra/PERMAN.spad-->Permanent((permanent (R SM))): Mismatch: left brace matches right pren
"\\spad{permanent(x)} computes the permanent of a square matrix \\spad{x}. The {\\em permanent} is equivalent to the \\spadfun{determinant} except that coefficients have no change of sign. This function is much more difficult to compute than the {\\em determinant}. The formula used is by \\spad{H}.\\spad{J}. Ryser,{} improved by [Nijenhuis and Wilf,{} \\spad{Ch}. 19]. Note: permanent(\\spad{x}) choose one of three algorithms,{} depending on the underlying ring \\spad{R} and on \\spad{n},{} the number of rows (and columns) of \\spad{x:}\\begin{items} \\item 1. if 2 has an inverse in \\spad{R} we can use the algorithm of \\indented{3}{[Nijenhuis and Wilf,{} \\spad{ch}.19,{}\\spad{p}.158]; if 2 has no inverse,{}} \\indented{3}{some modifications are necessary:} \\item 2. if {\\em n > 6} and \\spad{R} is an integral domain with characteristic \\indented{3}{different from 2 (the algorithm works if and only 2 is not a} \\indented{3}{zero-divisor of \\spad{R} and {\\em characteristic()\\$R ^= 2},{}} \\indented{3}{but how to check that for any given \\spad{R} ?),{}} \\indented{3}{the local function {\\em permanent2} is called;} \\item 3. else,{} the local function {\\em permanent3} is called \\indented{3}{(works for all commutative rings \\spad{R}).} \\end{items}"

============================================================================

   finalizing nrlib PFECAT- 
   Warnings: 
      [1] gcdPolynomial: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE charthRoot ((Union S failed) S)) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))))
      [2] charthRoot: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE charthRoot ((Union S failed) S)) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))))
      [3] solveLinearPolynomialEquation: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE charthRoot ((Union S failed) S)) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))))

============================================================================

   finalizing nrlib PFECAT 
; (DEFUN |PolynomialFactorizationExplicit| ...) is being compiled.
;; The variable |PolynomialFactorizationExplicit;AL| is undefined.
;; The compiler will assume this variable is a global.

--------------non extending category----------------------
.. Point #1 of cat 
(|PointCategory| |#1|)    has no  vector : List #1 -> % 
============================================================================

   finalizing nrlib POINT 

============================================================================

   finalizing nrlib PSEUDLIN 
   Warnings: 
      [1] normalForm0:  B has no value
      [2] normalForm0:  Binv has no value

============================================================================

   finalizing nrlib REP2 
   Warnings: 
      [1] cyclicSubmodule:  basis has no value
      [2] standardBasisOfCyclicSubmodule:  standardBasis has no value
      [3] splitInternal:  submoduleRepresentation has no value
      [4] splitInternal:  factormoduleRepresentation has no value
      [5] areEquivalent?:  x0 has no value
      [6] areEquivalent?:  x1 has no value
      [7] areEquivalent?:  foundResult has no value
      [8] areEquivalent?:  result has no value
      [9] areEquivalent?:  transitionM has no value
      [10] isAbsolutelyIrreducible?:  result has no value
      [11] meatAxe: :(PositiveInteger) -- should replace by pretend
      [12] meatAxe:  x has no value
      [13] meatAxe:  foundResult has no value
      [14] meatAxe:  result has no value
      [15] meatAxe: signature of lhs not unique: (List (List (Matrix R)))(List (Matrix R))(Boolean) chosen

============================================================================

   finalizing nrlib SETMN 
   Warnings: 
      [1] elements:  l has no value
      [2] replaceKthElement:  found has no value
      [3] replaceKthElement:  i has no value

============================================================================

   finalizing nrlib STRING 
   Warnings: 
      [1] OMwrite: pretend(String) -- should replace by @

--------------non extending category----------------------
.. String of cat 
(|StringCategory|)    has no  hash : % -> Integer 

============================================================================

   finalizing nrlib STRING 
--->/research2/test0819/mnt/fedora5/../../src/algebra/STRING.spad-->String(): Missing Description

============================================================================

   finalizing nrlib ASP1 
   Warnings: 
      [1]  X has no value

============================================================================

   finalizing nrlib ASP10 
   Warnings: 
      [1]  P has no value
      [2]  Q has no value
      [3]  DQDL has no value
      [4]  X has no value
      [5]  ELAM has no value
      [6]  JINT has no value

============================================================================

   finalizing nrlib ASP24 
   Warnings: 
      [1]  N has no value
      [2]  XC has no value
      [3]  FC has no value
      [4] coerce:  FC has no value

============================================================================

   finalizing nrlib ASP4 
   Warnings: 
      [1]  NDIM has no value
      [2]  X has no value

============================================================================

   finalizing nrlib ASP50 
   Warnings: 
      [1]  M has no value
      [2]  N has no value
      [3]  XC has no value
      [4]  FVECC has no value
      [5]  I has no value
      [6] coerce:  FVECC has no value

============================================================================

   finalizing nrlib ASP6 
   Warnings: 
      [1]  N has no value
      [2]  X has no value
      [3]  FVEC has no value
      [4]  IFLAG has no value
      [5] coerce:  FVEC has no value

============================================================================

   finalizing nrlib ASP73 
   Warnings: 
      [1]  X has no value
      [2]  Y has no value
      [3]  ALPHA has no value
      [4]  BETA has no value
      [5]  GAMMA has no value
      [6]  DELTA has no value
      [7]  EPSOLN has no value
      [8]  PHI has no value
      [9]  PSI has no value

============================================================================

   finalizing nrlib BALFACT 
   Warnings: 
      [1] balancedFactorisation: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE balancedFactorisation ((Factored UP) UP UP)) (SIGNATURE balancedFactorisation ((Factored UP) UP (List UP))))

--------------non extending category----------------------
.. BinaryExpansion of cat 
(|Join| (|QuotientFieldCategory| (|Integer|)) (CATEGORY |domain| (SIGNATURE |coerce| ((|Fraction| (|Integer|)) $)) (SIGNATURE |coerce| ((|RadixExpansion| 2) $)) (SIGNATURE |fractionPart| ((|Fraction| (|Integer|)) $)) (SIGNATURE |binary| ($ (|Fraction| (|Integer|))))))    has no  wholeRagits : % -> List Integer 

============================================================================

   finalizing nrlib BOUNDZRO 
   Warnings: 
      [1] bringDown: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE integerBound ((Integer) UP)))
      [2] qbound:  bound has no value

============================================================================

   finalizing nrlib CHVAR 
   Warnings: 
      [1] eval: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE mkIntegral ((Record (: coef (Fraction UP)) (: poly UPUP)) UPUP)) (SIGNATURE radPoly ((Union (Record (: radicand (Fraction UP)) (: deg (NonNegativeInteger))) failed) UPUP)) (SIGNATURE rootPoly ((Record (: exponent (NonNegativeInteger)) (: coef (Fraction UP)) (: radicand UP)) (Fraction UP) (NonNegativeInteger))) (SIGNATURE goodPoint (F UPUP UPUP)) (SIGNATURE eval (UPUP UPUP (Fraction UP) (Fraction UP))) (SIGNATURE chvar ((Record (: func UPUP) (: poly UPUP) (: c1 (Fraction UP)) (: c2 (Fraction UP)) (: deg (NonNegativeInteger))) UPUP UPUP)))
      [2] rootPoly: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE mkIntegral ((Record (: coef (Fraction UP)) (: poly UPUP)) UPUP)) (SIGNATURE radPoly ((Union (Record (: radicand (Fraction UP)) (: deg (NonNegativeInteger))) failed) UPUP)) (SIGNATURE rootPoly ((Record (: exponent (NonNegativeInteger)) (: coef (Fraction UP)) (: radicand UP)) (Fraction UP) (NonNegativeInteger))) (SIGNATURE goodPoint (F UPUP UPUP)) (SIGNATURE eval (UPUP UPUP (Fraction UP) (Fraction UP))) (SIGNATURE chvar ((Record (: func UPUP) (: poly UPUP) (: c1 (Fraction UP)) (: c2 (Fraction UP)) (: deg (NonNegativeInteger))) UPUP UPUP)))

============================================================================

   finalizing nrlib CONTFRAC 
   Warnings: 
      [1] =:  whole has no value
      [2] =:  den has no value
      [3] partialQuotients:  whole has no value
      [4] extend:  fract has no value
      [5] complete:  fract has no value
      [6] iGenApproximants:  num has no value
      [7] iGenApproximants:  den has no value
      [8] iGenConvergents:  num has no value
      [9] iGenConvergents:  den has no value
      [10] coerce:  l has no value

============================================================================

   finalizing nrlib CONTFRAC 
; (DEFUN |CONTFRAC;showAll?| ...) is being compiled.
;; The variable |$streamsShowAll| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib CYCLOTOM 
   Warnings: 
      [1] cyclotomic:  l has no value

============================================================================

   finalizing nrlib DDFACT 
   Warnings: 
      [1] notSqFr: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE factor ((Factored FP) FP)) (SIGNATURE factorSquareFree ((Factored FP) FP)) (SIGNATURE distdfact ((Record (: cont F) (: factors (List (Record (: irr FP) (: pow (Integer)))))) FP (Boolean))) (SIGNATURE separateDegrees ((List (Record (: deg (NonNegativeInteger)) (: prod FP))) FP)) (SIGNATURE separateFactors ((List FP) (List (Record (: deg (NonNegativeInteger)) (: prod FP))))) (SIGNATURE exptMod (FP FP (NonNegativeInteger) FP)) (SIGNATURE trace2PowMod (FP FP (NonNegativeInteger) FP)) (SIGNATURE tracePowMod (FP FP (NonNegativeInteger) FP)) (SIGNATURE irreducible? ((Boolean) FP)))
      [2] exptMod: :FP -- should replace by pretend
      [3] ddffact1:  ddfact has no value
      [4] separateFactors:  n1 has no value
      [5] separateFactors:  ris has no value
      [6] separateFactors:  newaux has no value
      [7] distdfact:  factlist has no value

--------------non extending category----------------------
.. DecimalExpansion of cat 
(|Join| (|QuotientFieldCategory| (|Integer|)) (CATEGORY |domain| (SIGNATURE |coerce| ((|Fraction| (|Integer|)) $)) (SIGNATURE |coerce| ((|RadixExpansion| 10) $)) (SIGNATURE |fractionPart| ((|Fraction| (|Integer|)) $)) (SIGNATURE |decimal| ($ (|Fraction| (|Integer|))))))    has no  wholeRagits : % -> List Integer 

============================================================================

   finalizing nrlib DIOPS 
; (DEFUN |DictionaryOperations| ...) is being compiled.
;; The variable |DictionaryOperations;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |DictionaryOperations;| ...) is being compiled.
;; The variable |DictionaryOperations;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib DIRPROD 
   Warnings: 
      [1] Zero: pretend$ -- should replace by @
      [2] One: pretend$ -- should replace by @
      [3] subtractIfCan: pretend$ -- should replace by @
      [4] recip: pretend$ -- should replace by @
      [5] unitVector: pretend$ -- should replace by @
 
--------------non extending category----------------------
.. DirectProduct(#1,#2) of cat 
(|DirectProductCategory| |#1| |#2|)   has no 
============================================================================

(|VectorCategory| |#2|)    finalizing nrlib DIRPROD 

============================================================================

   finalizing nrlib DIRPROD 
; (DEFUN |DirectProduct;| ...) is being compiled.
;; The variable IDENTITY is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib DISPLAY 
   Warnings: 
      [1] sayLength:  sum has no value

============================================================================

   finalizing nrlib DPOLCAT- 
   Warnings: 
      [1] degree:  d has no value
      [2] weights:  ws has no value
      [3] initial: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE coerce (A A)) (SIGNATURE coerce (A (Fraction (Integer)))) (SIGNATURE eval (A A (List S) (List R))) (SIGNATURE eval (A A S R)) (SIGNATURE eval (A A (List S) (List A))) (SIGNATURE eval (A A S A)) (SIGNATURE makeVariable ((Mapping A (NonNegativeInteger)) A)) (SIGNATURE separant (A A)) (SIGNATURE initial (A A)) (SIGNATURE leader (V A)) (SIGNATURE isobaric? ((Boolean) A)) (SIGNATURE weight ((NonNegativeInteger) A S)) (SIGNATURE weights ((List (NonNegativeInteger)) A S)) (SIGNATURE weight ((NonNegativeInteger) A)) (SIGNATURE weights ((List (NonNegativeInteger)) A)) (SIGNATURE degree ((NonNegativeInteger) A S)) (SIGNATURE order ((NonNegativeInteger) A)) (SIGNATURE order ((NonNegativeInteger) A S)) (SIGNATURE differentialVariables ((List S) A)) (SIGNATURE makeVariable ((Mapping A (NonNegativeInteger)) S)) (SIGNATURE retractIfCan ((Union S failed) A)) (SIGNATURE coerce (A S)) (SIGNATURE differentiate (A A (Mapping R R))) (SIGNATURE differentiate (A A (Mapping R R) (NonNegativeInteger))) (SIGNATURE differentiate (A A (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE differentiate (A A (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (A A (List (Symbol)))) (SIGNATURE differentiate (A A (Symbol))) (SIGNATURE differentiate (A A (NonNegativeInteger))) (SIGNATURE differentiate (A A)) (SIGNATURE degree ((List (NonNegativeInteger)) A (List V))) (SIGNATURE degree ((NonNegativeInteger) A V)) (SIGNATURE retractIfCan ((Union V failed) A)) (SIGNATURE coerce (A V)) (SIGNATURE eval (A A (List V) (List A))) (SIGNATURE eval (A A V A)) (SIGNATURE eval (A A (List V) (List R))) (SIGNATURE eval (A A V R)) (SIGNATURE eval (A A (List A) (List A))) (SIGNATURE eval (A A A A)) (SIGNATURE eval (A A (Equation A))) (SIGNATURE eval (A A (List (Equation A)))) (SIGNATURE degree (E A)) (SIGNATURE retractIfCan ((Union (Integer) failed) A)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) A)) (SIGNATURE coerce (A R)) (SIGNATURE retractIfCan ((Union R failed) A)) (SIGNATURE differentiate (A A (List V) (List (NonNegativeInteger)))) (SIGNATURE differentiate (A A V (NonNegativeInteger))) (SIGNATURE differentiate (A A (List V))) (SIGNATURE differentiate (A A V)) (SIGNATURE coerce (A (Integer))) (SIGNATURE coerce ((OutputForm) A)))
      [4] eval:  IN has no value
      [5] eval:  s has no value
      [6] eval:  e has no value
 

============================================================================

   finalizing nrlib DPOLCAT 
; (DEFUN |DifferentialPolynomialCategory| ...) is being compiled.
;; The variable |DifferentialPolynomialCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |DifferentialPolynomialCategory;| ...) is being compiled.
;; The variable |DifferentialPolynomialCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

--------------non extending category----------------------
.. d01ajfAnnaType of cat 
(|NumericalIntegrationCategory|)   has no 
============================================================================

(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib D01AJFA 

--------------non extending category----------------------
.. d01akfAnnaType of cat 
(|NumericalIntegrationCategory|)   has no 
============================================================================

(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib D01AKFA 

--------------non extending category----------------------
.. d01alfAnnaType of cat 
(|NumericalIntegrationCategory|)   has no 
============================================================================

(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib D01ALFA 

--------------non extending category----------------------
.. d01amfAnnaType of cat 
(|NumericalIntegrationCategory|)   has no 
============================================================================

(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib D01AMFA 

--------------non extending category----------------------
.. d01apfAnnaType of cat 
(|NumericalIntegrationCategory|)   has no 
============================================================================

(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib D01APFA 

--------------non extending category----------------------
.. d01aqfAnnaType of cat 
(|NumericalIntegrationCategory|)   has no 
============================================================================

(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib D01AQFA 

============================================================================

   finalizing nrlib EQ 
extension of ##1 to (Polynomial (Integer)) ignored

============================================================================

   finalizing nrlib EQ 
   Semantic Errors: 
      [1] factorAndSplit:  rcf has two modes: 
 
   Warnings: 
      [1] factorAndSplit: not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE factorAndSplit ((List $) $)))
      [2] factorAndSplit: not known that (IntegralDomain) is of mode (CATEGORY S (SIGNATURE factor ((Factored S) S)))

============================================================================

   finalizing nrlib EQ 
; (DEFUN |Equation;| ...) is being compiled.
;; The variable IDENTITY is undefined.
;; The compiler will assume this variable is a global.

--------------non extending category----------------------
.. e04dgfAnnaType of cat 
(|NumericalOptimizationCategory|)   has no 
============================================================================

(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib E04DGFA 

--------------non extending category----------------------
.. e04fdfAnnaType of cat 
(|NumericalOptimizationCategory|)   has no 
============================================================================

(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib E04FDFA 

--------------non extending category----------------------
.. e04gcfAnnaType of cat 
(|NumericalOptimizationCategory|)   has no 
============================================================================

(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib E04GCFA 

--------------non extending category----------------------
.. e04jafAnnaType of cat 
(|NumericalOptimizationCategory|)   has no 
============================================================================

(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib E04JAFA 

============================================================================

   finalizing nrlib FFHOM 
   Warnings: 
      [1] compare:  equal has no value
      [2] initialize:  mat has no value
      [3] unknown Functor code (error FFHOM: one extension degree must divide the other one)

============================================================================

   finalizing nrlib FFPOLY 
   Warnings: 
      [1] leastAffineMultiple:  coeffVector has no value
      [2] primitive?: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE primitive? ((Boolean) (SparseUnivariatePolynomial GF))) (SIGNATURE normal? ((Boolean) (SparseUnivariatePolynomial GF))) (SIGNATURE numberOfIrreduciblePoly ((PositiveInteger) (PositiveInteger))) (SIGNATURE numberOfPrimitivePoly ((PositiveInteger) (PositiveInteger))) (SIGNATURE numberOfNormalPoly ((PositiveInteger) (PositiveInteger))) (SIGNATURE createIrreduciblePoly ((SparseUnivariatePolynomial GF) (PositiveInteger))) (SIGNATURE createPrimitivePoly ((SparseUnivariatePolynomial GF) (PositiveInteger))) (SIGNATURE createNormalPoly ((SparseUnivariatePolynomial GF) (PositiveInteger))) (SIGNATURE createNormalPrimitivePoly ((SparseUnivariatePolynomial GF) (PositiveInteger))) (SIGNATURE createPrimitiveNormalPoly ((SparseUnivariatePolynomial GF) (PositiveInteger))) (SIGNATURE nextIrreduciblePoly ((Union (SparseUnivariatePolynomial GF) failed) (SparseUnivariatePolynomial GF))) (SIGNATURE nextPrimitivePoly ((Union (SparseUnivariatePolynomial GF) failed) (SparseUnivariatePolynomial GF))) (SIGNATURE nextNormalPoly ((Union (SparseUnivariatePolynomial GF) failed) (SparseUnivariatePolynomial GF))) (SIGNATURE nextNormalPrimitivePoly ((Union (SparseUnivariatePolynomial GF) failed) (SparseUnivariatePolynomial GF))) (SIGNATURE nextPrimitiveNormalPoly ((Union (SparseUnivariatePolynomial GF) failed) (SparseUnivariatePolynomial GF))) (SIGNATURE random ((SparseUnivariatePolynomial GF) (PositiveInteger))) (SIGNATURE random ((SparseUnivariatePolynomial GF) (PositiveInteger) (PositiveInteger))) (SIGNATURE leastAffineMultiple ((SparseUnivariatePolynomial GF) (SparseUnivariatePolynomial GF))) (SIGNATURE reducedQPowers ((PrimitiveArray (SparseUnivariatePolynomial GF)) (SparseUnivariatePolynomial GF))))
      [3] nextSubset:  restOfs has no value
      [4] nextSubset:  noGap has no value
      [5] nextSubset:  i has no value
      [6] nextIrreduciblePoly:  fcopy has no value
      [7] nextIrreduciblePoly:  s has no value
      [8] nextPrimitivePoly:  fcopy has no value
      [9] nextPrimitivePoly:  term has no value
      [10] nextPrimitivePoly:  noGenerator has no value
      [11] nextPrimitivePoly:  c has no value
      [12] nextPrimitivePoly:  weight has no value
      [13] nextPrimitivePoly:  s has no value
      [14] nextPrimitivePoly:  l has no value
      [15] nextNormalPoly:  fcopy has no value
      [16] nextNormalPoly:  l has no value
      [17] nextNormalPoly:  a has no value
      [18] nextNormalPoly:  s has no value
      [19] nextNormalPrimitivePoly:  fcopy has no value
      [20] nextNormalPrimitivePoly:  term has no value
      [21] nextNormalPrimitivePoly:  noGenerator has no value
      [22] nextNormalPrimitivePoly:  c has no value
      [23] nextNormalPrimitivePoly:  la has no value
      [24] nextNormalPrimitivePoly:  a has no value
      [25] nextNormalPrimitivePoly:  middlelookuplist has no value
      [26] nextNormalPrimitivePoly:  middlepol has no value
      [27] nextNormalPrimitivePoly:  weight has no value
      [28] nextNormalPrimitivePoly:  s has no value
      [29] nextNormalPrimitivePoly:  lc has no value
      [30] random:  polRepr has no value

============================================================================

   finalizing nrlib FGLMICPK 
   Warnings: 
      [1] zeroDim?: not known that (Ring) is of mode (CATEGORY package (SIGNATURE zeroDimensional? ((Boolean) (List (Polynomial R)))) (SIGNATURE fglmIfCan ((Union (List (Polynomial R)) failed) (List (Polynomial R)))) (SIGNATURE groebner ((List (Polynomial R)) (List (Polynomial R)))))
      [2] zeroDim?:  lv has no value

============================================================================

   finalizing nrlib FINAALG 
; (DEFUN |FiniteRankNonAssociativeAlgebra| ...) is being compiled.
;; The variable |FiniteRankNonAssociativeAlgebra;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |FiniteRankNonAssociativeAlgebra;| ...) is being compiled.
;; The variable |FiniteRankNonAssociativeAlgebra;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FINRALG 
; (DEFUN |FiniteRankAlgebra| ...) is being compiled.
;; The variable |FiniteRankAlgebra;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |FiniteRankAlgebra;| ...) is being compiled.
;; The variable |FiniteRankAlgebra;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FFF 
   Warnings: 
      [1] createLowComplexityTable:  k has no value
      [2] createLowComplexityTable:  t1 has no value
      [3] createLowComplexityTable:  a has no value
      [4] createLowComplexityTable: pretend(NonNegativeInteger) -- should replace by @
      [5] createLowComplexityTable:  l has no value
      [6] createMultiplicationTable:  l has no value

   FOP abbreviates package FortranOutputStackPackage 
(SPADLET |$noSubsumption| NIL)

============================================================================

   finalizing nrlib FORMULA 
   Warnings: 
      [1] display: pretend(Integer) -- should replace by @
      [2] coerce: pretend(Integer) -- should replace by @
      [3] stringify: pretend(String) -- should replace by @
      [4] splitLong1:  l has no value
      [5] splitLong1:  ls has no value
      [6] splitLong1:  s has no value
      [7] formatSpecial:  form has no value
      [8] formatPlex:  s has no value
      [9] formatFormula: pretend(Boolean) -- should replace by @
      [10] formatFormula: :(Integer) -- should replace by pretend

   FORT abbreviates package FortranPackage 
(SPADLET |$noSubsumption| (QUOTE T))

============================================================================

   finalizing nrlib FORT 
   Warnings: 
      [1] linkToFortran:  fst has no value

============================================================================

   finalizing nrlib FRAC 
   Warnings: 
      [1] OMwrite: pretend(String) -- should replace by @
      [2] factorPolynomial:  den1 has no value
      [3] factorSquareFreePolynomial:  den1 has no value

--------------non extending category----------------------
.. Fraction #1 of cat 
(|Join| (|QuotientFieldCategory| |#1|) (CATEGORY |package| (IF (|has| |#1| (|IntegerNumberSystem|)) (IF (|has| |#1| (|OpenMath|)) (ATTRIBUTE (|OpenMath|)) |noBranch|) |noBranch|) (IF (|has| |#1| (ATTRIBUTE |canonical|)) (IF (|has| |#1| (|GcdDomain|)) (IF (|has| |#1| (ATTRIBUTE |canonicalUnitNormal|)) (ATTRIBUTE |canonical|) |noBranch|) |noBranch|) |noBranch|)))   has no 
============================================================================

(IF (|has| |#1| (|OrderedRing|)) (ATTRIBUTE (|OrderedRing|)) |noBranch|)    finalizing nrlib FRAC 

============================================================================

   finalizing nrlib FTEM 
   Warnings: 
      [1] processTemplate:  active has no value

--------------non extending category----------------------
.. FortranTemplate of cat 
(|Join| (|FileCategory| (|FileName|) (|String|)) (CATEGORY |package| (SIGNATURE |processTemplate| ((|FileName|) (|FileName|) (|FileName|))) (SIGNATURE |processTemplate| ((|FileName|) (|FileName|))) (SIGNATURE |fortranLiteralLine| ((|Void|) (|String|))) (SIGNATURE |fortranLiteral| ((|Void|) (|String|))) (SIGNATURE |fortranCarriageReturn| ((|Void|)))))    has no  writeLine! : (%,String) -> String 

============================================================================

   finalizing nrlib FTEM 
; (DEFUN |FTEM;processTemplate;2Fn;7| ...) is being compiled.
;; The variable |$fortranOutputFile| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib GENMFACT 
   Warnings: 
      [1] factor: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE factor ((Factored P) P)))

============================================================================

   finalizing nrlib GENPGCD 
   Warnings: 
      [1] gcdPolynomial:  canonical has no value
      [2] gcdSameVariables: not known that (Ring) is of mode (CATEGORY package (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial P) (SparseUnivariatePolynomial P) (SparseUnivariatePolynomial P))) (SIGNATURE randomR (R)))
      [3] gcdSameVariables:  up1 has no value
      [4] gcdSameVariables:  up2 has no value
      [5] lift: not known that (Ring) is of mode (CATEGORY package (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial P) (SparseUnivariatePolynomial P) (SparseUnivariatePolynomial P))) (SIGNATURE randomR (R)))

============================================================================

   finalizing nrlib GALFACTU 
   Warnings: 
      [1] singleFactorBound: not known that (Ring) is of mode (CATEGORY F (SIGNATURE Gamma (F F)))

============================================================================

   finalizing nrlib GBF 
   Warnings: 
      [1] createGroebnerBases:  nP has no value
      [2] createGroebnerBases:  allReducedFactors has no value
      [3] factorGroebnerBasis:  fctr has no value
      [4] groebnerFactorize: signature of lhs not unique: (List (List Dpol))(List Dpol)(List Dpol) chosen

============================================================================

   finalizing nrlib GBINTERN 
   Warnings: 
      [1] redPo:  m has no value

============================================================================

   finalizing nrlib GHENSEL 
   Warnings: 
      [1] genFact:  auxfl has no value
      [2] HenselLift:  constp has no value
      [3] HenselLift:  fln has no value
      [4] completeHensel:  factlist has no value
      [5] completeHensel:  finallist has no value
      [6] completeHensel:  aux has no value
      [7] completeHensel:  auxfl has no value

(|Module| |#6|)    extends 
(|BiModule| |#6| |#6|)    but not 
(|BiModule| |#2| |#2|) --------------non extending category----------------------
.. GeneralModulePolynomial(#1,#2,#3,#4,#5,#6) of cat 
(|Join| (|Module| |#6|) (|Module| |#2|) (CATEGORY |domain| (SIGNATURE |leadingCoefficient| (|#2| $)) (SIGNATURE |leadingMonomial| ((|ModuleMonomial| |#3| |#4| |#5|) $)) (SIGNATURE |leadingExponent| (|#4| $)) (SIGNATURE |leadingIndex| (|#3| $)) (SIGNATURE |reductum| ($ $)) (SIGNATURE |monomial| ($ |#2| (|ModuleMonomial| |#3| |#4| |#5|))) (SIGNATURE |unitVector| ($ |#3|)) (SIGNATURE |build| ($ |#2| |#3| |#4|)) (SIGNATURE |multMonom| ($ |#2| |#4| $)) (SIGNATURE * ($ |#6| $))))   has no 
============================================================================

(|IndexedDirectProductCategory| |#2| (|ModuleMonomial| |#3| |#4| |#5|))    finalizing nrlib GMODPOL 

============================================================================

   finalizing nrlib GRIMAGE 
   Warnings: 
      [1] makeGraphImage: signature of lhs not unique: $(List (List (Point (DoubleFloat)))) chosen

============================================================================

   finalizing nrlib GRIMAGE 
--->/research2/test0819/mnt/fedora5/../../src/algebra/GRIMAGE.spad-->GraphImage((figureUnits (UNITSF (L (L P))))): Not documented!!!!

============================================================================

   finalizing nrlib GROEBSOL 
   Warnings: 
      [1] testPower: not known that (Ring) is of mode (CATEGORY package (SIGNATURE groebSolve ((List (List (DistributedMultivariatePolynomial lv F))) (List (DistributedMultivariatePolynomial lv F)) (List (OrderedVariableList lv)))) (SIGNATURE testDim ((Union (List (HomogeneousDistributedMultivariatePolynomial lv F)) failed) (List (HomogeneousDistributedMultivariatePolynomial lv F)) (List (OrderedVariableList lv)))) (SIGNATURE genericPosition ((Record (: dpolys (List (DistributedMultivariatePolynomial lv F))) (: coords (List (Integer)))) (List (DistributedMultivariatePolynomial lv F)) (List (OrderedVariableList lv)))))
      [2] testGenPos:  newlpol has no value
      [3] groebSolve:  result has no value

--------------non extending category----------------------
.. HexadecimalExpansion of cat 
(|Join| (|QuotientFieldCategory| (|Integer|)) (CATEGORY |domain| (SIGNATURE |coerce| ((|Fraction| (|Integer|)) $)) (SIGNATURE |coerce| ((|RadixExpansion| 16) $)) (SIGNATURE |fractionPart| ((|Fraction| (|Integer|)) $)) (SIGNATURE |hex| ($ (|Fraction| (|Integer|))))))    has no  wholeRagits : % -> List Integer 

============================================================================

   finalizing nrlib HEUGCD 
   Warnings: 
      [1] localgcd:  flag has no value
      [2] localgcd:  result has no value
      [3] internal:  Cgcd has no value
      [4] internal:  contgcd has no value
      [5] internal:  ans has no value

============================================================================

   finalizing nrlib ICARD 
   Warnings: 
      [1] elt: pretend(String) -- should replace by @

============================================================================

   finalizing nrlib IDECOMP 
   Warnings: 
      [1] internalForm: not known that (PolynomialCategory (Fraction (Integer)) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl)) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [2] internalForm: not known that (PolynomialCategory (Fraction (Polynomial (Integer))) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl)) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [3] externalForm: not known that (PolynomialCategory (Fraction (Polynomial (Integer))) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl)) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [4] externalForm: not known that (PolynomialCategory (Fraction (Integer)) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl)) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [5] zeroRadComp: not known that (PolynomialCategory (Fraction (Polynomial (Integer))) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl)) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [6] zeroRadComp: not known that (Ring) is of mode (CATEGORY package (SIGNATURE zeroDimPrime? ((Boolean) (PolynomialIdeals (Fraction (Integer)) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl) (DistributedMultivariatePolynomial vl (Fraction (Integer)))))) (SIGNATURE zeroDimPrimary? ((Boolean) (PolynomialIdeals (Fraction (Integer)) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl) (DistributedMultivariatePolynomial vl (Fraction (Integer)))))) (SIGNATURE prime? ((Boolean) (PolynomialIdeals (Fraction (Integer)) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl) (DistributedMultivariatePolynomial vl (Fraction (Integer)))))) (SIGNATURE radical ((PolynomialIdeals (Fraction (Integer)) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl) (DistributedMultivariatePolynomial vl (Fraction (Integer)))) (PolynomialIdeals (Fraction (Integer)) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl) (DistributedMultivariatePolynomial vl (Fraction (Integer)))))) (SIGNATURE primaryDecomp ((List (PolynomialIdeals (Fraction (Integer)) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl) (DistributedMultivariatePolynomial vl (Fraction (Integer))))) (PolynomialIdeals (Fraction (Integer)) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl) (DistributedMultivariatePolynomial vl (Fraction (Integer)))))) (SIGNATURE contract ((PolynomialIdeals (Fraction (Integer)) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl) (DistributedMultivariatePolynomial vl (Fraction (Integer)))) (PolynomialIdeals (Fraction (Integer)) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl) (DistributedMultivariatePolynomial vl (Fraction (Integer)))) (List (OrderedVariableList vl)))))
      [7] findvar:  lmonicvar has no value
      [8] zeroPrimDecomp: not known that (PolynomialCategory (Fraction (Polynomial (Integer))) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl)) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [9] testPower: :(Integer) -- should replace by pretend
      [10] primaryDecomp: not known that (PolynomialCategory (Fraction (Integer)) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl)) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [11] contract:  IN has no value
      [12] contract:  vv has no value
      [13] contract: not known that (PolynomialCategory (Fraction (Integer)) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl)) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))

============================================================================

   finalizing nrlib IIARRAY2 
   Warnings: 
      [1] latex:  s has no value

============================================================================

   finalizing nrlib IMATLIN 
   Warnings: 
      [1] nullSpace:  basis has no value
      [2] determinant:  ans has no value
      [3] generalizedInverse: not known that (MatrixCategory FSUP VFSUP VFSUP) is of mode (CATEGORY domain (SIGNATURE diagonalMatrix ($ (Vector FSUP))) (IF (has FSUP (ConvertibleTo (InputForm))) (ATTRIBUTE (ConvertibleTo (InputForm))) noBranch) (IF (has FSUP (Field)) (SIGNATURE inverse ((Union $ failed) $)) noBranch))

============================================================================

   finalizing nrlib IMATQF 
   Warnings: 
      [1] nullSpace: not known that (FiniteLinearAggregate QF) is of mode (CATEGORY Col2 (ATTRIBUTE shallowlyMutable))

============================================================================

   finalizing nrlib INMODGCD 
--->/research2/test0819/mnt/fedora5/../../src/algebra/INMODGCD.spad-->InnerModularGcd(constructor): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/INMODGCD.spad-->InnerModularGcd(): Missing Description

============================================================================

   finalizing nrlib INNMFACT 
   Warnings: 
      [1] supFactor:  factorlist has no value
      [2] supFactor:  irr has no value
      [3] supFactor:  pow has no value
      [4] varChoose: not known that (Ring) is of mode (CATEGORY package (SIGNATURE factor ((Factored P) P (Mapping (Factored (SparseUnivariatePolynomial R)) (SparseUnivariatePolynomial R)))) (SIGNATURE factor ((Factored (SparseUnivariatePolynomial P)) (SparseUnivariatePolynomial P) (Mapping (Factored (SparseUnivariatePolynomial R)) (SparseUnivariatePolynomial R)))))
      [5] intChoose:  unifact has no value
      [6] intChoose:  int has no value
      [7] simplify:  pol1 has no value
      [8] simplify:  factorlist has no value
      [9] intfact:  unifact has no value
      [10] intfact:  lpol has no value
      [11] intfact:  factfin has no value
      [12] mFactor: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE factor ((Factored P) P (Mapping (Factored (SparseUnivariatePolynomial R)) (SparseUnivariatePolynomial R)))) (SIGNATURE factor ((Factored (SparseUnivariatePolynomial P)) (SparseUnivariatePolynomial P) (Mapping (Factored (SparseUnivariatePolynomial R)) (SparseUnivariatePolynomial R)))))
      [13] mFactor:  flead has no value
      [14] mFactor:  irr has no value
      [15] mFactor:  pow has no value
      [16] mFactor:  x has no value
      [17] mFactor:  ffactor has no value
      [18] mFactor:  lvar has no value
      [19] mFactor:  factorlist has no value

============================================================================

   finalizing nrlib INTSLPE 
   Warnings: 
      [1] solveLinearPolynomialEquation:  slpePrime has no value
      [2] solveLinearPolynomialEquation:  oldtable has no value

============================================================================

   finalizing nrlib INTTR 
   Warnings: 
      [1] expintegratepoly:  coef0 has no value
      [2] explimintfrac:  logand has no value
      [3] explimintfrac:  coeff has no value

============================================================================

   finalizing nrlib ISUMP 
   Warnings: 
      [1] sum: not known that (Ring) is of mode (CATEGORY package (SIGNATURE sum ((Record (: num P) (: den (Integer))) P V (Segment P))) (SIGNATURE sum ((Record (: num P) (: den (Integer))) P V)))

============================================================================

   finalizing nrlib LAUPOL 
   Warnings: 
      [1] not known that (Ring) is of mode (CATEGORY domain (SIGNATURE separate ((Record (: polyPart $) (: fracPart (Fraction UP))) (Fraction UP))))

============================================================================

   finalizing nrlib LEADCDET 
   Warnings: 
      [1] distFact:  c has no value

============================================================================

   finalizing nrlib LGROBP 
   Warnings: 
      [1] totolex:  result has no value
      [2] minPol: :(NonNegativeInteger) -- should replace by pretend
      [3] intcompBasis:  part has no value
      [4] linGenPos: :(PositiveInteger) -- should replace by pretend
      [5] linGenPos:  result has no value
      [6] groebgen: :(NonNegativeInteger) -- should replace by pretend
      [7] groebgen: not known that (Ring) is of mode (CATEGORY package (SIGNATURE linGenPos ((Record (: gblist (List (DistributedMultivariatePolynomial lv F))) (: gvlist (List (Integer)))) (List (HomogeneousDistributedMultivariatePolynomial lv F)))) (SIGNATURE groebgen ((Record (: glbase (List (DistributedMultivariatePolynomial lv F))) (: glval (List (Integer)))) (List (DistributedMultivariatePolynomial lv F)))) (SIGNATURE totolex ((List (DistributedMultivariatePolynomial lv F)) (List (HomogeneousDistributedMultivariatePolynomial lv F)))) (SIGNATURE minPol ((HomogeneousDistributedMultivariatePolynomial lv F) (List (HomogeneousDistributedMultivariatePolynomial lv F)) (List (HomogeneousDistributedMultivariatePolynomial lv F)) (OrderedVariableList lv))) (SIGNATURE minPol ((HomogeneousDistributedMultivariatePolynomial lv F) (List (HomogeneousDistributedMultivariatePolynomial lv F)) (OrderedVariableList lv))) (SIGNATURE computeBasis ((List (HomogeneousDistributedMultivariatePolynomial lv F)) (List (HomogeneousDistributedMultivariatePolynomial lv F)))) (SIGNATURE coord ((Vector F) (HomogeneousDistributedMultivariatePolynomial lv F) (List (HomogeneousDistributedMultivariatePolynomial lv F)))) (SIGNATURE anticoord ((DistributedMultivariatePolynomial lv F) (List F) (DistributedMultivariatePolynomial lv F) (List (DistributedMultivariatePolynomial lv F)))) (SIGNATURE intcompBasis ((List (HomogeneousDistributedMultivariatePolynomial lv F)) (OrderedVariableList lv) (List (HomogeneousDistributedMultivariatePolynomial lv F)) (List (HomogeneousDistributedMultivariatePolynomial lv F)))) (SIGNATURE choosemon ((DistributedMultivariatePolynomial lv F) (DistributedMultivariatePolynomial lv F) (List (DistributedMultivariatePolynomial lv F)))) (SIGNATURE transform ((HomogeneousDistributedMultivariatePolynomial lv F) (DistributedMultivariatePolynomial lv F))))

============================================================================

   finalizing nrlib LINDEP 
   Warnings: 
      [1] linearlyDependent?: not known that (Ring) is of mode (CATEGORY package (SIGNATURE linearlyDependent? ((Boolean) (Vector R))) (SIGNATURE linearDependence ((Union (Vector S) failed) (Vector R))) (IF (has S (Field)) (SIGNATURE solveLinear ((Union (Vector S) failed) (Vector R) R)) (SIGNATURE solveLinear ((Union (Vector (Fraction S)) failed) (Vector R) R))))

============================================================================

   finalizing nrlib LPEFRAC 
   Warnings: 
      [1] solveLinearPolynomialEquationByFractions: not known that (Ring) is of mode (CATEGORY package (SIGNATURE solveLinearPolynomialEquationByFractions ((Union (List (SparseUnivariatePolynomial R)) failed) (List (SparseUnivariatePolynomial R)) (SparseUnivariatePolynomial R))))

============================================================================

   finalizing nrlib LSPP 
   Warnings: 
      [1] poly2vect: not known that (Ring) is of mode (CATEGORY package (SIGNATURE linSolve ((Record (: particular (Union (Vector (Fraction P)) failed)) (: basis (List (Vector (Fraction P))))) (List P) (List OV))))

============================================================================

   finalizing nrlib MATLIN 
   Warnings: 
      [1] minorDet:  ans has no value
      [2] rowEchelon:  xnj has no value

============================================================================

   finalizing nrlib MDDFACT 
   Semantic Errors: 
      [1] ddfactor:  degree is BOTH a variable and a literal
      [2] ddfact:  degree is BOTH a variable and a literal
      [3] ddFact:  degree is BOTH a variable and a literal
      [4] sepfact:  degree is BOTH a variable and a literal
      [5] separateFactors:  degree is BOTH a variable and a literal
      [6] sepFact1:  degree is BOTH a variable and a literal
 
   Warnings: 
      [1] ddfact:  ans has no value
      [2] ddfact: :(Integer) -- should replace by @
      [3] sepFact1:  ans has no value
      [4] sepFact1:  stack has no value
      [5] probSplit: :(NonNegativeInteger) -- should replace by pretend

============================================================================

   finalizing nrlib MFINFACT 
   Warnings: 
      [1] pretendOV -- should replace by @
      [2] supFactor: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE factor ((Factored PG) PG)) (SIGNATURE factor ((Factored (SparseUnivariatePolynomial PG)) (SparseUnivariatePolynomial PG))))
      [3] mFactor:  irr has no value
      [4] mFactor:  pow has no value
      [5] mFactor: not known that (Ring) is of mode (CATEGORY package (SIGNATURE factor ((Factored PG) PG)) (SIGNATURE factor ((Factored (SparseUnivariatePolynomial PG)) (SparseUnivariatePolynomial PG))))
      [6] mFactor:  ffactor has no value
      [7] mFactor:  factorlist has no value
      [8] intfact:  unifact has no value
      [9] intfact:  lpol has no value
      [10] intfact:  factfin has no value
      [11] intChoose:  newm has no value
      [12] intChoose:  unifact has no value
      [13] intChoose:  int has no value
      [14] simplify:  pol1 has no value
      [15] simplify:  factorlist has no value
 
============================================================================

   finalizing nrlib MLIFT 
   Warnings: 
      [1] Use: import (GenExEuclid R (SparseUnivariatePolynomial R))
      [2] Use: import (NPCoef (SparseUnivariatePolynomial R) E OV R P)
      [3] Use: import (IntegerCombinatoricFunctions (Integer))
      [4] lifting:  nplist has no value
      [5] normalDerivM: not known that (Ring) is of mode (CATEGORY package (SIGNATURE corrPoly ((Union (List (SparseUnivariatePolynomial P)) failed) (SparseUnivariatePolynomial P) (List OV) (List R) (List (NonNegativeInteger)) (List (SparseUnivariatePolynomial P)) (Vector (List (SparseUnivariatePolynomial R))) R)) (SIGNATURE lifting ((Union (List (SparseUnivariatePolynomial P)) failed) (SparseUnivariatePolynomial P) (List OV) (List (SparseUnivariatePolynomial R)) (List R) (List P) (List (NonNegativeInteger)) R)) (SIGNATURE lifting1 ((Union (List (SparseUnivariatePolynomial P)) failed) (SparseUnivariatePolynomial P) (List OV) (List (SparseUnivariatePolynomial P)) (List R) (List P) (List (List (Record (: expt (NonNegativeInteger)) (: pcoef P)))) (List (NonNegativeInteger)) (Vector (List (SparseUnivariatePolynomial R))) R)))

   MODMON abbreviates domain ModMonic 
(PUSH (QUOTE |ModMonic|) |$mutableDomains|)

============================================================================

   finalizing nrlib MODMON 
   Warnings: 
      [1] :(NonNegativeInteger) -- should replace by pretend
      [2] lift: pretendRep -- should replace by @
      [3] not known that (SetCategory) is of mode (CATEGORY domain (SIGNATURE frobenius ($ $)))
      [4] not known that (Ring) is of mode (CATEGORY domain (SIGNATURE frobenius ($ $)))
      [5] not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE frobenius ($ $)))

============================================================================

   finalizing nrlib MONOTOOL 
   Warnings: 
      [1] splitSquarefree: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE split ((Record (: normal UP) (: special UP)) UP (Mapping UP UP))) (SIGNATURE splitSquarefree ((Record (: normal (Factored UP)) (: special (Factored UP))) UP (Mapping UP UP))) (SIGNATURE normalDenom (UP (Fraction UP) (Mapping UP UP))) (SIGNATURE decompose ((Record (: poly UP) (: normal (Fraction UP)) (: special (Fraction UP))) (Fraction UP) (Mapping UP UP))))
      [2] splitSquarefree:  s has no value

============================================================================

   finalizing nrlib MPCPF 
   Warnings: 
      [1] factor: not known that (SIGNATURE variable ((Union $ failed) (Symbol))) is of mode (CATEGORY domain (SIGNATURE new ($)) (SIGNATURE new ($ $)) (SIGNATURE resetNew ((Void))) (SIGNATURE coerce ($ (String))) (SIGNATURE name ($ $)) (SIGNATURE scripted? ((Boolean) $)) (SIGNATURE scripts ((Record (: sub (List (OutputForm))) (: sup (List (OutputForm))) (: presup (List (OutputForm))) (: presub (List (OutputForm))) (: args (List (OutputForm)))) $)) (SIGNATURE script ($ $ (List (List (OutputForm))))) (SIGNATURE script ($ $ (Record (: sub (List (OutputForm))) (: sup (List (OutputForm))) (: presup (List (OutputForm))) (: presub (List (OutputForm))) (: args (List (OutputForm)))))) (SIGNATURE subscript ($ $ (List (OutputForm)))) (SIGNATURE superscript ($ $ (List (OutputForm)))) (SIGNATURE argscript ($ $ (List (OutputForm)))) (SIGNATURE elt ($ $ (List (OutputForm)))) (SIGNATURE string ((String) $)) (SIGNATURE list ((List $) $)) (SIGNATURE sample ($) constant))

============================================================================

   finalizing nrlib MPC3 
   Warnings: 
      [1] map: not known that (Ring) is of mode (CATEGORY package (SIGNATURE map (PR2 (Mapping Vars2 Vars1) PR1)))

============================================================================

   finalizing nrlib MPRFF 
   Warnings: 
      [1] factor: not known that (PolynomialCategory (Fraction (Integer)) (IndexedExponents (Symbol)) (Symbol)) is of mode (CATEGORY domain (IF (has R (Algebra (Fraction (Integer)))) (SIGNATURE integrate ($ $ (Symbol))) noBranch))
      [2] factor: pretend(Factored (Polynomial R)) -- should replace by @
      [3] factor:  flist has no value
      [4] pushdown: not known that (Ring) is of mode (CATEGORY package (SIGNATURE totalfract ((Record (: sup (Polynomial R)) (: inf (Polynomial R))) PRF)) (SIGNATURE pushdown (PRF PRF OV)) (SIGNATURE pushdterm (PRF (SparseUnivariatePolynomial PRF) OV)) (SIGNATURE pushup (PRF PRF OV)) (SIGNATURE pushucoef (PRF (SparseUnivariatePolynomial (Polynomial R)) OV)) (SIGNATURE pushuconst (PRF (Fraction (Polynomial R)) OV)) (SIGNATURE factor ((Factored PRF) PRF)))

============================================================================

   finalizing nrlib MULTSQFR 
   Semantic Errors: 
      [1] squareFree:  ff has two modes: 
 
   Warnings: 
      [1] nsqfree:  lcf has no value
      [2] nsqfree:  leadpol has no value
      [3] nsqfree:  sqlc has no value
      [4] nsqfree: :(NonNegativeInteger) -- should replace by pretend
      [5] nsqfree:  sqlead has no value
      [6] nsqfree:  unitsq has no value
      [7] nsqfree:  sqdec has no value
      [8] squareFree: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE squareFree ((Factored P) P)) (SIGNATURE squareFree ((Factored (SparseUnivariatePolynomial P)) (SparseUnivariatePolynomial P))) (SIGNATURE squareFreePrim ((Factored P) P)) (SIGNATURE compdegd ((Integer) (List (Record (: factor (SparseUnivariatePolynomial R)) (: exponent (Integer)))))) (SIGNATURE univcase ((Factored P) P OV)) (SIGNATURE consnewpol ((Record (: pol (SparseUnivariatePolynomial P)) (: polval (SparseUnivariatePolynomial R))) (SparseUnivariatePolynomial P) (SparseUnivariatePolynomial R) (Integer))) (SIGNATURE nsqfree ((Record (: unitPart P) (: suPart (List (Record (: factor (SparseUnivariatePolynomial P)) (: exponent (Integer)))))) (SparseUnivariatePolynomial P) (List OV) (List (List R)))) (SIGNATURE intChoose ((Record (: upol (SparseUnivariatePolynomial R)) (: Lval (List R)) (: Lfact (List (Record (: factor (SparseUnivariatePolynomial R)) (: exponent (Integer))))) (: ctpol R)) (SparseUnivariatePolynomial P) (List OV) (List (List R)))) (SIGNATURE coefChoose (P (Integer) (Factored P))) (SIGNATURE check ((Boolean) (List (Record (: factor (SparseUnivariatePolynomial R)) (: exponent (Integer)))) (List (Record (: factor (SparseUnivariatePolynomial R)) (: exponent (Integer)))))) (SIGNATURE lift ((Union (List (SparseUnivariatePolynomial P)) failed) (SparseUnivariatePolynomial P) (SparseUnivariatePolynomial R) (SparseUnivariatePolynomial R) P (List OV) (List (NonNegativeInteger)) (List R))) (SIGNATURE myDegree ((List (NonNegativeInteger)) (SparseUnivariatePolynomial P) (List OV) (NonNegativeInteger))) (SIGNATURE normDeriv2 ((SparseUnivariatePolynomial R) (SparseUnivariatePolynomial R) (Integer))))
      [9] squareFree:  fctr has no value
      [10] squareFree:  xpnt has no value
      [11] squareFree:  p has no value
      [12] squareFree:  result1 has no value
      [13] squareFree:  lvar has no value
      [14] squareFree: not known that (Ring) is of mode (CATEGORY package (SIGNATURE squareFree ((Factored P) P)) (SIGNATURE squareFree ((Factored (SparseUnivariatePolynomial P)) (SparseUnivariatePolynomial P))) (SIGNATURE squareFreePrim ((Factored P) P)) (SIGNATURE compdegd ((Integer) (List (Record (: factor (SparseUnivariatePolynomial R)) (: exponent (Integer)))))) (SIGNATURE univcase ((Factored P) P OV)) (SIGNATURE consnewpol ((Record (: pol (SparseUnivariatePolynomial P)) (: polval (SparseUnivariatePolynomial R))) (SparseUnivariatePolynomial P) (SparseUnivariatePolynomial R) (Integer))) (SIGNATURE nsqfree ((Record (: unitPart P) (: suPart (List (Record (: factor (SparseUnivariatePolynomial P)) (: exponent (Integer)))))) (SparseUnivariatePolynomial P) (List OV) (List (List R)))) (SIGNATURE intChoose ((Record (: upol (SparseUnivariatePolynomial R)) (: Lval (List R)) (: Lfact (List (Record (: factor (SparseUnivariatePolynomial R)) (: exponent (Integer))))) (: ctpol R)) (SparseUnivariatePolynomial P) (List OV) (List (List R)))) (SIGNATURE coefChoose (P (Integer) (Factored P))) (SIGNATURE check ((Boolean) (List (Record (: factor (SparseUnivariatePolynomial R)) (: exponent (Integer)))) (List (Record (: factor (SparseUnivariatePolynomial R)) (: exponent (Integer)))))) (SIGNATURE lift ((Union (List (SparseUnivariatePolynomial P)) failed) (SparseUnivariatePolynomial P) (SparseUnivariatePolynomial R) (SparseUnivariatePolynomial R) P (List OV) (List (NonNegativeInteger)) (List R))) (SIGNATURE myDegree ((List (NonNegativeInteger)) (SparseUnivariatePolynomial P) (List OV) (NonNegativeInteger))) (SIGNATURE normDeriv2 ((SparseUnivariatePolynomial R) (SparseUnivariatePolynomial R) (Integer))))
      [15] intChoose: :R -- should replace by @
      [16] intChoose:  d1 has no value
      [17] coefChoose:  lcoef has no value
      [18] lift:  leadlist has no value
      [19] lift:  p0 has no value
      [20] lift:  p1 has no value

============================================================================

   finalizing nrlib NPCOEF 
   Warnings: 
      [1] npcoef: :(NonNegativeInteger) -- should replace by pretend
      [2] npcoef:  ndet has no value
      [3] npcoef:  detufact has no value
      [4] npcoef:  ltodel has no value
      [5] npcoef:  detcoef has no value
      [6] check: :(NonNegativeInteger) -- should replace by pretend
      [7] check:  doit has no value
      [8] check:  cfu has no value
      [9] check:  poselt has no value
      [10] check:  pp has no value
      [11] buildtable:  table has no value
      [12] modify: :(NonNegativeInteger) -- should replace by pretend
      [13] modify:  lterase has no value

============================================================================

   finalizing nrlib NSUP 
   Warnings: 
      [1] subResultantGcd: not known that (UnivariatePolynomialCategory R) is of mode (CATEGORY domain (SIGNATURE halfExtendedResultant2 ((Record (: resultant R) (: coef2 $)) $ $)))

--------------non extending category----------------------
.. NewSparseUnivariatePolynomial #1 of cat 
(|Join| (|UnivariatePolynomialCategory| |#1|) (|CoercibleTo| (|SparseUnivariatePolynomial| |#1|)) (|RetractableTo| (|SparseUnivariatePolynomial| |#1|)) (CATEGORY |domain| (SIGNATURE |fmecg| ($ $ (|NonNegativeInteger|) |#1| $)) (SIGNATURE |monicModulo| ($ $ $)) (SIGNATURE |lazyResidueClass| ((|Record| (|:| |polnum| $) (|:| |polden| |#1|) (|:| |power| (|NonNegativeInteger|))) $ $)) (SIGNATURE |lazyPseudoRemainder| ($ $ $)) (SIGNATURE |lazyPseudoDivide| ((|Record| (|:| |coef| |#1|) (|:| |gap| (|NonNegativeInteger|)) (|:| |quotient| $) (|:| |remainder| $)) $ $)) (SIGNATURE |lazyPseudoQuotient| ($ $ $)) (IF (|has| |#1| (|IntegralDomain|)) (PROGN (SIGNATURE |subResultantsChain| ((|List| $) $ $)) (SIGNATURE |lastSubResultant| ($ $ $)) (SIGNATURE |extendedSubResultantGcd| ((|Record| (|:| |gcd| $) (|:| |coef1| $) (|:| |coef2| $)) $ $)) (SIGNATURE |halfExtendedSubResultantGcd1| ((|Record| (|:| |gcd| $) (|:| |coef1| $)) $ $)) (SIGNATURE |halfExtendedSubResultantGcd2| ((|Record| (|:| |gcd| $) (|:| |coef2| $)) $ $)) (SIGNATURE |extendedResultant| ((|Record| (|:| |resultant| |#1|) (|:| |coef1| $) (|:| |coef2| $)) $ $)) (SIGNATURE |halfExtendedResultant1| ((|Record| (|:| |resultant| |#1|) (|:| |coef1| $)) $ $)) (SIGNATURE |halfExtendedResultant2| ((|Record| (|:| |resultant| |#1|) (|:| |coef2| $)) $ $))) |noBranch|)))    has no  outputForm : (%,OutputForm) -> OutputForm 

============================================================================

   finalizing nrlib ODEPRIM 
   Warnings: 
      [1] indicialEquations:  eq has no value
      [2] NPmulambda:  lamb has no value
      [3] NPmulambda:  lf has no value

============================================================================

   finalizing nrlib ODEPRRIC 
   Warnings: 
      [1] leadingDenomRicDE:  ind has no value
      [2] constantCoefficientOperator:  ans has no value
      [3] innermax:  ans has no value
      [4] leadingCoefficientRicDE:  ind has no value
      [5] innerlb:  lb has no value

============================================================================

   finalizing nrlib OMPKG 
   Warnings: 
      [1] OMreadStr: pretend(String) -- should replace by @
      [2] OMlistCDs: pretend(List (String)) -- should replace by @
      [3] OMlistSymbols: pretend(List (String)) -- should replace by @

============================================================================

   finalizing nrlib OMSERVER 
--->/research2/test0819/mnt/fedora5/../../src/algebra/OMSERVER.spad-->OpenMathServerPackage((OMsend ((Void) (OpenMathConnection) (Any)))): Unexpected HT command: \aciom
"\\spad{OMsend(c,{}u)} attempts to output \\axiom{\\spad{u}} on \\aciom{\\spad{c}} in OpenMath."

============================================================================

   finalizing nrlib PADICRC 
   Warnings: 
      [1] coerce:  l has no value

============================================================================

   finalizing nrlib PF 
   Warnings: 
      [1] unknown Functor code (error Argument to prime field must be a prime)

============================================================================

   finalizing nrlib PFBR 
   Warnings: 
      [1] hensel: not known that (Ring) is of mode (CATEGORY package (SIGNATURE solveLinearPolynomialEquationByRecursion ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorByRecursion ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreeByRecursion ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE randomR (R)) (SIGNATURE bivariateSLPEBR ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S) VarSet)) (SIGNATURE factorSFBRlcUnit ((Factored (SparseUnivariatePolynomial S)) (List VarSet) (SparseUnivariatePolynomial S))))
      [2] hensel:  foundFactors has no value
      [3] factorSFBRlcUnitInner: not known that (Ring) is of mode (CATEGORY package (SIGNATURE solveLinearPolynomialEquationByRecursion ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorByRecursion ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreeByRecursion ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE randomR (R)) (SIGNATURE bivariateSLPEBR ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S) VarSet)) (SIGNATURE factorSFBRlcUnit ((Factored (SparseUnivariatePolynomial S)) (List VarSet) (SparseUnivariatePolynomial S))))
      [4] factorSFBRlcUnitInner:  fctr has no value
      [5] chooseFSQViableSubstitutions:  ppR has no value
      [6] chooseSLPEViableSubstitutions:  lpolysR has no value
      [7] raise: :R -- should replace by pretend
      [8] raise: :R -- should replace by @
      [9] factorByRecursion: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE solveLinearPolynomialEquationByRecursion ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorByRecursion ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreeByRecursion ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE randomR (R)) (SIGNATURE bivariateSLPEBR ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S) VarSet)) (SIGNATURE factorSFBRlcUnit ((Factored (SparseUnivariatePolynomial S)) (List VarSet) (SparseUnivariatePolynomial S))))
      [10] factorByRecursion: :S -- should replace by @
      [11] factorSquareFreeByRecursion:  lcppPow has no value

============================================================================

   finalizing nrlib PFBRU 
   Warnings: 
      [1] solveLinearPolynomialEquationByRecursion: not known that (Ring) is of mode (CATEGORY package (SIGNATURE solveLinearPolynomialEquationByRecursion ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorByRecursion ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreeByRecursion ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE randomR (R)) (SIGNATURE factorSFBRlcUnit ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))))
      [2] solveLinearPolynomialEquationByRecursion:  answer has no value
      [3] hensel:  foundFactors has no value
      [4] chooseFSQViableSubstitutions:  ppR has no value
      [5] raise: :R -- should replace by pretend
      [6] raise: :R -- should replace by @
      [7] factorSFBRlcUnitInner: not known that (Ring) is of mode (CATEGORY package (SIGNATURE solveLinearPolynomialEquationByRecursion ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorByRecursion ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreeByRecursion ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE randomR (R)) (SIGNATURE factorSFBRlcUnit ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))))
      [8] factorSFBRlcUnitInner:  fctr has no value
      [9] factorByRecursion: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE solveLinearPolynomialEquationByRecursion ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorByRecursion ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreeByRecursion ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE randomR (R)) (SIGNATURE factorSFBRlcUnit ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))))
      [10] factorByRecursion: :S -- should replace by pretend
      [11] factorByRecursion: :S -- should replace by @
      [12] factorSquareFreeByRecursion:  lcppPow has no value
 
============================================================================

   finalizing nrlib PGCD 
   Warnings: 
      [1] localgcd:  s has no value
      [2] gcdTermList: not known that (Ring) is of mode (CATEGORY package (SIGNATURE gcd (P P P)) (SIGNATURE gcd (P (List P))) (SIGNATURE gcd ((SparseUnivariatePolynomial P) (SparseUnivariatePolynomial P) (SparseUnivariatePolynomial P))) (SIGNATURE gcd ((SparseUnivariatePolynomial P) (List (SparseUnivariatePolynomial P)))) (SIGNATURE gcdPrimitive (P P P)) (SIGNATURE gcdPrimitive ((SparseUnivariatePolynomial P) (SparseUnivariatePolynomial P) (SparseUnivariatePolynomial P))) (SIGNATURE gcdPrimitive (P (List P))))
      [3] lift:  p0 has no value

============================================================================

   finalizing nrlib PLEQN 
   Warnings: 
      [1] regime:  wcd has no value
      [2] regime:  yzero has no value
      [3] bsolve:  rksoln has no value
      [4] bsolve:  lrec3 has no value
      [5] ParCondList:  covered has no value
      [6] ParCondList:  zro has no value
      [7] ParCondList:  npc has no value
      [8] ParCondList:  done has no value
      [9] ParCondList:  rcl has no value
      [10] pr2dmp: pretendGR -- should replace by @
      [11] sqfree: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE psolve ((List (Record (: eqzro (List GR)) (: neqzro (List GR)) (: wcond (List (Polynomial R))) (: bsoln (Record (: partsol (Vector (Fraction (Polynomial R)))) (: basis (List (Vector (Fraction (Polynomial R))))))))) (Matrix GR) (List GR))) (SIGNATURE psolve ((List (Record (: eqzro (List GR)) (: neqzro (List GR)) (: wcond (List (Polynomial R))) (: bsoln (Record (: partsol (Vector (Fraction (Polynomial R)))) (: basis (List (Vector (Fraction (Polynomial R))))))))) (Matrix GR) (List (Symbol)))) (SIGNATURE psolve ((List (Record (: eqzro (List GR)) (: neqzro (List GR)) (: wcond (List (Polynomial R))) (: bsoln (Record (: partsol (Vector (Fraction (Polynomial R)))) (: basis (List (Vector (Fraction (Polynomial R))))))))) (Matrix GR))) (SIGNATURE psolve ((List (Record (: eqzro (List GR)) (: neqzro (List GR)) (: wcond (List (Polynomial R))) (: bsoln (Record (: partsol (Vector (Fraction (Polynomial R)))) (: basis (List (Vector (Fraction (Polynomial R))))))))) (Matrix GR) (List GR) (PositiveInteger))) (SIGNATURE psolve ((List (Record (: eqzro (List GR)) (: neqzro (List GR)) (: wcond (List (Polynomial R))) (: bsoln (Record (: partsol (Vector (Fraction (Polynomial R)))) (: basis (List (Vector (Fraction (Polynomial R))))))))) (Matrix GR) (List (Symbol)) (PositiveInteger))) (SIGNATURE psolve ((List (Record (: eqzro (List GR)) (: neqzro (List GR)) (: wcond (List (Polynomial R))) (: bsoln (Record (: partsol (Vector (Fraction (Polynomial R)))) (: basis (List (Vector (Fraction (Polynomial R))))))))) (Matrix GR) (PositiveInteger))) (SIGNATURE psolve ((Integer) (Matrix GR) (List GR) (String))) (SIGNATURE psolve ((Integer) (Matrix GR) (List (Symbol)) (String))) (SIGNATURE psolve ((Integer) (Matrix GR) (String))) (SIGNATURE psolve ((Integer) (Matrix GR) (List GR) (PositiveInteger) (String))) (SIGNATURE psolve ((Integer) (Matrix GR) (List (Symbol)) (PositiveInteger) (String))) (SIGNATURE psolve ((Integer) (Matrix GR) (PositiveInteger) (String))) (SIGNATURE wrregime ((Integer) (List (Record (: eqzro (List GR)) (: neqzro (List GR)) (: wcond (List (Polynomial R))) (: bsoln (Record (: partsol (Vector (Fraction (Polynomial R)))) (: basis (List (Vector (Fraction (Polynomial R))))))))) (String))) (SIGNATURE rdregime ((List (Record (: eqzro (List GR)) (: neqzro (List GR)) (: wcond (List (Polynomial R))) (: bsoln (Record (: partsol (Vector (Fraction (Polynomial R)))) (: basis (List (Vector (Fraction (Polynomial R))))))))) (String))) (SIGNATURE bsolve ((Record (: rgl (List (Record (: eqzro (List GR)) (: neqzro (List GR)) (: wcond (List (Polynomial R))) (: bsoln (Record (: partsol (Vector (Fraction (Polynomial R)))) (: basis (List (Vector (Fraction (Polynomial R)))))))))) (: rgsz (Integer))) (Matrix GR) (List (Fraction (Polynomial R))) (NonNegativeInteger) (String) (Integer))) (SIGNATURE dmp2rfi ((Fraction (Polynomial R)) GR)) (SIGNATURE dmp2rfi ((Matrix (Fraction (Polynomial R))) (Matrix GR))) (SIGNATURE dmp2rfi ((List (Fraction (Polynomial R))) (List GR))) (SIGNATURE se2rfi ((List (Fraction (Polynomial R))) (List (Symbol)))) (SIGNATURE pr2dmp (GR (Polynomial R))) (SIGNATURE hasoln ((Record (: sysok (Boolean)) (: z0 (List GR)) (: n0 (List GR))) (List GR) (List GR))) (SIGNATURE ParCondList ((List (Record (: rank (NonNegativeInteger)) (: eqns (List (Record (: det GR) (: rows (List (Integer))) (: cols (List (Integer)))))) (: fgb (List GR)))) (Matrix GR) (NonNegativeInteger))) (SIGNATURE redpps ((Record (: partsol (Vector (Fraction (Polynomial R)))) (: basis (List (Vector (Fraction (Polynomial R)))))) (Record (: partsol (Vector (Fraction (Polynomial R)))) (: basis (List (Vector (Fraction (Polynomial R)))))) (List GR))) (SIGNATURE B1solve ((Record (: partsol (Vector (Fraction (Polynomial R)))) (: basis (List (Vector (Fraction (Polynomial R)))))) (Record (: mat (Matrix (Fraction (Polynomial R)))) (: vec (List (Fraction (Polynomial R)))) (: rank (NonNegativeInteger)) (: rows (List (Integer))) (: cols (List (Integer)))))) (SIGNATURE factorset ((List GR) GR)) (SIGNATURE maxrank ((NonNegativeInteger) (List (Record (: rank (NonNegativeInteger)) (: eqns (List (Record (: det GR) (: rows (List (Integer))) (: cols (List (Integer)))))) (: fgb (List GR)))))) (SIGNATURE minrank ((NonNegativeInteger) (List (Record (: rank (NonNegativeInteger)) (: eqns (List (Record (: det GR) (: rows (List (Integer))) (: cols (List (Integer)))))) (: fgb (List GR)))))) (SIGNATURE minset ((List (List GR)) (List (List GR)))) (SIGNATURE nextSublist ((List (List (Integer))) (Integer) (Integer))) (SIGNATURE overset? ((Boolean) (List GR) (List (List GR)))) (SIGNATURE ParCond ((List (Record (: det GR) (: rows (List (Integer))) (: cols (List (Integer))))) (Matrix GR) (NonNegativeInteger))) (SIGNATURE redmat ((Matrix GR) (Matrix GR) (List GR))) (SIGNATURE regime ((Record (: eqzro (List GR)) (: neqzro (List GR)) (: wcond (List (Polynomial R))) (: bsoln (Record (: partsol (Vector (Fraction (Polynomial R)))) (: basis (List (Vector (Fraction (Polynomial R)))))))) (Record (: det GR) (: rows (List (Integer))) (: cols (List (Integer)))) (Matrix GR) (List (Fraction (Polynomial R))) (List (List GR)) (NonNegativeInteger) (NonNegativeInteger) (Integer))) (SIGNATURE sqfree (GR GR)) (SIGNATURE inconsistent? ((Boolean) (List GR))) (SIGNATURE inconsistent? ((Boolean) (List (Polynomial R)))))
      [12] ParCond:  found has no value
      [13] ParCond:  DetEqn has no value

============================================================================

   finalizing nrlib PLEQN 
--->/research2/test0819/mnt/fedora5/../../src/algebra/PLEQN.spad-->ParametricLinearEquations((inconsistent? ((Boolean) (L GR)))): Improper first word in comments: inconsistant?
"inconsistant?(\\spad{pl}) returns \\spad{true} if the system of equations \\spad{p} = 0 for \\spad{p} in \\spad{pl} is inconsistent. It is assumed that \\spad{pl} is a groebner basis."
--------(inconsistent? ((Boolean) (L PR)))---------
--->/research2/test0819/mnt/fedora5/../../src/algebra/PLEQN.spad-->ParametricLinearEquations((inconsistent? ((Boolean) (L PR)))): Improper first word in comments: inconsistant?
"inconsistant?(\\spad{pl}) returns \\spad{true} if the system of equations \\spad{p} = 0 for \\spad{p} in \\spad{pl} is inconsistent. It is assumed that \\spad{pl} is a groebner basis."

============================================================================

   finalizing nrlib PNTHEORY 
   Warnings: 
      [1] cyclotomic:  s has no value
      [2] cyclotomic:  c has no value

============================================================================

   finalizing nrlib POLUTIL 
   Warnings: 
      [1] sylvesterSequence:  res has no value
      [2] sturmVariationsOf:  ll has no value

============================================================================

   finalizing nrlib POLYCATQ 
   Warnings: 
      [1] isPower:  var has no value
      [2] P2UP: not known that (Ring) is of mode (CATEGORY package (SIGNATURE variables ((List V) F)) (SIGNATURE mainVariable ((Union V failed) F)) (SIGNATURE univariate ((Fraction (SparseUnivariatePolynomial F)) F V)) (SIGNATURE multivariate (F (Fraction (SparseUnivariatePolynomial F)) V)) (SIGNATURE univariate ((SparseUnivariatePolynomial F) F V (SparseUnivariatePolynomial F))) (SIGNATURE isPlus ((Union (List F) failed) F)) (SIGNATURE isTimes ((Union (List F) failed) F)) (SIGNATURE isExpt ((Union (Record (: var V) (: exponent (Integer))) failed) F)) (SIGNATURE isPower ((Union (Record (: val F) (: exponent (Integer))) failed) F)))

============================================================================

   finalizing nrlib POLYCATQ 
   Processing PolynomialCategoryQuotientFunctions for Browser database:
--->/research2/test0819/mnt/fedora5/../../src/algebra/POLYCATQ.spad-->PolynomialCategoryQuotientFunctions((coerce (% P))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/POLYCATQ.spad-->PolynomialCategoryQuotientFunctions((numer (P %))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/POLYCATQ.spad-->PolynomialCategoryQuotientFunctions((denom (P %))): Not documented!!!!

============================================================================

   finalizing nrlib POLYLIFT 
   Warnings: 
      [1] map: not known that (Ring) is of mode (CATEGORY package (SIGNATURE map (S (Mapping S Vars) (Mapping S R) P)))

============================================================================

   finalizing nrlib POLYLIFT 
--->/research2/test0819/mnt/fedora5/../../src/algebra/POLYLIFT.spad-->PolynomialCategoryLifting((+ (% % %))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/POLYLIFT.spad-->PolynomialCategoryLifting((* (% % %))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/POLYLIFT.spad-->PolynomialCategoryLifting((** (% % (NonNegativeInteger)))): Not documented!!!!

============================================================================

   finalizing nrlib POLYROOT 
   Warnings: 
      [1] zroot: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE rroot ((Record (: exponent (NonNegativeInteger)) (: coef F) (: radicand F)) R (NonNegativeInteger))) (SIGNATURE qroot ((Record (: exponent (NonNegativeInteger)) (: coef F) (: radicand F)) (Fraction (Integer)) (NonNegativeInteger))) (IF (has R (GcdDomain)) (SIGNATURE froot ((Record (: exponent (NonNegativeInteger)) (: coef F) (: radicand F)) F (NonNegativeInteger))) noBranch) (SIGNATURE nthr ((Record (: exponent (NonNegativeInteger)) (: coef P) (: radicand (List P))) P (NonNegativeInteger))))

============================================================================

   finalizing nrlib POLY2UP 
   Warnings: 
      [1] univariate: not known that (Ring) is of mode (CATEGORY package (SIGNATURE univariate ((UnivariatePolynomial x (Polynomial R)) (Polynomial R) (Variable x))))

============================================================================

   finalizing nrlib PRS 
   Warnings: 
      [1] resultantnaif:  a has no value
      [2] resultantEuclideannaif:  a has no value
      [3] semiResultantEuclideannaif:  a has no value
      [4] chainSubResultants:  L has no value
      [5] schema:  L has no value

============================================================================

   finalizing nrlib PSQFR 
   Warnings: 
      [1] pPolRoot: not known that (Ring) is of mode (CATEGORY package (SIGNATURE squareFree ((Factored P) P)))
      [2] pthPower:  isSq has no value
      [3] pthPower:  fctr has no value
      [4] pthPower:  xpnt has no value
      [5] finSqFr: :(NonNegativeInteger) -- should replace by pretend
      [6] finSqFr:  cont1 has no value

============================================================================

   finalizing nrlib PUSHVAR 
   Warnings: 
      [1] map: not known that (Ring) is of mode (CATEGORY package (SIGNATURE pushdown (PPR PPR OV)) (SIGNATURE pushdown (PPR PPR (List OV))) (SIGNATURE pushup (PPR PPR OV)) (SIGNATURE pushup (PPR PPR (List OV))) (SIGNATURE map (PPR (Mapping PPR (Polynomial R)) PPR)))

============================================================================

   finalizing nrlib QALGSET 
   Warnings: 
      [1] npoly: not known that (OrderedAbelianMonoid) is of mode (CATEGORY domain (IF (has (NonNegativeInteger) (Finite)) (IF (has Expon (Finite)) (ATTRIBUTE (Finite)) noBranch) noBranch) (IF (has (NonNegativeInteger) (Monoid)) (IF (has Expon (Monoid)) (ATTRIBUTE (Monoid)) noBranch) noBranch) (IF (has (NonNegativeInteger) (AbelianMonoid)) (IF (has Expon (AbelianMonoid)) (ATTRIBUTE (AbelianMonoid)) noBranch) noBranch) (IF (has (NonNegativeInteger) (CancellationAbelianMonoid)) (IF (has Expon (CancellationAbelianMonoid)) (ATTRIBUTE (CancellationAbelianMonoid)) noBranch) noBranch) (IF (has (NonNegativeInteger) (Group)) (IF (has Expon (Group)) (ATTRIBUTE (Group)) noBranch) noBranch) (IF (has (NonNegativeInteger) (AbelianGroup)) (IF (has Expon (AbelianGroup)) (ATTRIBUTE (AbelianGroup)) noBranch) noBranch) (IF (has (NonNegativeInteger) (OrderedAbelianMonoidSup)) (IF (has Expon (OrderedAbelianMonoidSup)) (ATTRIBUTE (OrderedAbelianMonoidSup)) noBranch) noBranch) (IF (has (NonNegativeInteger) (OrderedSet)) (IF (has Expon (OrderedSet)) (ATTRIBUTE (OrderedSet)) noBranch) noBranch) (SIGNATURE makeprod ($ (NonNegativeInteger) Expon)) (SIGNATURE selectfirst ((NonNegativeInteger) $)) (SIGNATURE selectsecond (Expon $)))
      [2] idealSimplify: not known that (OrderedAbelianMonoid) is of mode (CATEGORY domain (IF (has (NonNegativeInteger) (Finite)) (IF (has Expon (Finite)) (ATTRIBUTE (Finite)) noBranch) noBranch) (IF (has (NonNegativeInteger) (Monoid)) (IF (has Expon (Monoid)) (ATTRIBUTE (Monoid)) noBranch) noBranch) (IF (has (NonNegativeInteger) (AbelianMonoid)) (IF (has Expon (AbelianMonoid)) (ATTRIBUTE (AbelianMonoid)) noBranch) noBranch) (IF (has (NonNegativeInteger) (CancellationAbelianMonoid)) (IF (has Expon (CancellationAbelianMonoid)) (ATTRIBUTE (CancellationAbelianMonoid)) noBranch) noBranch) (IF (has (NonNegativeInteger) (Group)) (IF (has Expon (Group)) (ATTRIBUTE (Group)) noBranch) noBranch) (IF (has (NonNegativeInteger) (AbelianGroup)) (IF (has Expon (AbelianGroup)) (ATTRIBUTE (AbelianGroup)) noBranch) noBranch) (IF (has (NonNegativeInteger) (OrderedAbelianMonoidSup)) (IF (has Expon (OrderedAbelianMonoidSup)) (ATTRIBUTE (OrderedAbelianMonoidSup)) noBranch) noBranch) (IF (has (NonNegativeInteger) (OrderedSet)) (IF (has Expon (OrderedSet)) (ATTRIBUTE (OrderedSet)) noBranch) noBranch) (SIGNATURE makeprod ($ (NonNegativeInteger) Expon)) (SIGNATURE selectfirst ((NonNegativeInteger) $)) (SIGNATURE selectsecond (Expon $)))
      [3] idealSimplify: not known that (OrderedAbelianMonoidSup) is of mode (CATEGORY domain (IF (has (NonNegativeInteger) (Finite)) (IF (has Expon (Finite)) (ATTRIBUTE (Finite)) noBranch) noBranch) (IF (has (NonNegativeInteger) (Monoid)) (IF (has Expon (Monoid)) (ATTRIBUTE (Monoid)) noBranch) noBranch) (IF (has (NonNegativeInteger) (AbelianMonoid)) (IF (has Expon (AbelianMonoid)) (ATTRIBUTE (AbelianMonoid)) noBranch) noBranch) (IF (has (NonNegativeInteger) (CancellationAbelianMonoid)) (IF (has Expon (CancellationAbelianMonoid)) (ATTRIBUTE (CancellationAbelianMonoid)) noBranch) noBranch) (IF (has (NonNegativeInteger) (Group)) (IF (has Expon (Group)) (ATTRIBUTE (Group)) noBranch) noBranch) (IF (has (NonNegativeInteger) (AbelianGroup)) (IF (has Expon (AbelianGroup)) (ATTRIBUTE (AbelianGroup)) noBranch) noBranch) (IF (has (NonNegativeInteger) (OrderedAbelianMonoidSup)) (IF (has Expon (OrderedAbelianMonoidSup)) (ATTRIBUTE (OrderedAbelianMonoidSup)) noBranch) noBranch) (IF (has (NonNegativeInteger) (OrderedSet)) (IF (has Expon (OrderedSet)) (ATTRIBUTE (OrderedSet)) noBranch) noBranch) (SIGNATURE makeprod ($ (NonNegativeInteger) Expon)) (SIGNATURE selectfirst ((NonNegativeInteger) $)) (SIGNATURE selectsecond (Expon $)))
      [4] idealSimplify: not known that (PolynomialCategory R (Product (NonNegativeInteger) Expon) Var) is of mode (CATEGORY domain (IF (has R (IntegralDomain)) (IF (has (Product (NonNegativeInteger) Expon) (CancellationAbelianMonoid)) (SIGNATURE fmecg ($ $ (Product (NonNegativeInteger) Expon) R $)) noBranch) noBranch) (IF (has R (ATTRIBUTE canonicalUnitNormal)) (ATTRIBUTE canonicalUnitNormal) noBranch))
      [5] idealSimplify:  gb has no value

============================================================================

   finalizing nrlib RADIX 
   Warnings: 
      [1] fractionPart: signature of lhs not unique: (Fraction (Integer))$ chosen
      [2] coerce:  le has no value
      [3] radixFrac:  c has no value
      [4] unknown Functor code (error Radix base must be at least 2)

============================================================================

   finalizing nrlib RATFACT 
--->/research2/test0819/mnt/fedora5/../../src/algebra/RATFACT.spad-->RationalFactorize(constructor): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/RATFACT.spad-->RationalFactorize(): Missing Description

============================================================================

   finalizing nrlib RCFIELD- 
   Warnings: 
      [1] rootOf: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE sqrt (S (Integer))) (SIGNATURE sqrt (S (Fraction (Integer)))) (SIGNATURE sqrt (S S (NonNegativeInteger))) (SIGNATURE allRootsOf ((List S) (Polynomial (Integer)))) (SIGNATURE allRootsOf ((List S) (Polynomial (Fraction (Integer))))) (SIGNATURE allRootsOf ((List S) (Polynomial S))) (SIGNATURE allRootsOf ((List S) (SparseUnivariatePolynomial (Integer)))) (SIGNATURE allRootsOf ((List S) (SparseUnivariatePolynomial (Fraction (Integer))))) (SIGNATURE allRootsOf ((List S) (SparseUnivariatePolynomial S))) (SIGNATURE rootOf ((Union S failed) (SparseUnivariatePolynomial S) (PositiveInteger))) (SIGNATURE rootOf ((Union S failed) (SparseUnivariatePolynomial S) (PositiveInteger) (OutputForm))) (SIGNATURE ** (S S (Fraction (Integer)))) (SIGNATURE nthRoot (S S (Integer))) (SIGNATURE sqrt (S S)) (SIGNATURE ** (S S (Integer))) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE ** (S S (NonNegativeInteger))) (SIGNATURE ** (S S (PositiveInteger))))
      [2] allRootsOf: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE sqrt (S (Integer))) (SIGNATURE sqrt (S (Fraction (Integer)))) (SIGNATURE sqrt (S S (NonNegativeInteger))) (SIGNATURE allRootsOf ((List S) (Polynomial (Integer)))) (SIGNATURE allRootsOf ((List S) (Polynomial (Fraction (Integer))))) (SIGNATURE allRootsOf ((List S) (Polynomial S))) (SIGNATURE allRootsOf ((List S) (SparseUnivariatePolynomial (Integer)))) (SIGNATURE allRootsOf ((List S) (SparseUnivariatePolynomial (Fraction (Integer))))) (SIGNATURE allRootsOf ((List S) (SparseUnivariatePolynomial S))) (SIGNATURE rootOf ((Union S failed) (SparseUnivariatePolynomial S) (PositiveInteger))) (SIGNATURE rootOf ((Union S failed) (SparseUnivariatePolynomial S) (PositiveInteger) (OutputForm))) (SIGNATURE ** (S S (Fraction (Integer)))) (SIGNATURE nthRoot (S S (Integer))) (SIGNATURE sqrt (S S)) (SIGNATURE ** (S S (Integer))) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE ** (S S (NonNegativeInteger))) (SIGNATURE ** (S S (PositiveInteger))))

============================================================================

   finalizing nrlib RCFIELD 
; (DEFUN |RealClosedField| ...) is being compiled.
;; The variable |RealClosedField;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib RDETR 
   Warnings: 
      [1] polyRDE:  eq has no value
      [2] SPDEnocancel1:  q has no value
      [3] SPDEnocancel2:  q has no value

============================================================================

   finalizing nrlib REAL0 
   Warnings: 
      [1] makeSqfr: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE realZeros ((List (Record (: left (Fraction (Integer))) (: right (Fraction (Integer))))) Pol)) (SIGNATURE realZeros ((List (Record (: left (Fraction (Integer))) (: right (Fraction (Integer))))) Pol (Record (: left (Fraction (Integer))) (: right (Fraction (Integer)))))) (SIGNATURE realZeros ((List (Record (: left (Fraction (Integer))) (: right (Fraction (Integer))))) Pol (Fraction (Integer)))) (SIGNATURE realZeros ((List (Record (: left (Fraction (Integer))) (: right (Fraction (Integer))))) Pol (Record (: left (Fraction (Integer))) (: right (Fraction (Integer)))) (Fraction (Integer)))) (SIGNATURE refine ((Record (: left (Fraction (Integer))) (: right (Fraction (Integer)))) Pol (Record (: left (Fraction (Integer))) (: right (Fraction (Integer)))) (Fraction (Integer)))) (SIGNATURE refine ((Union (Record (: left (Fraction (Integer))) (: right (Fraction (Integer)))) failed) Pol (Record (: left (Fraction (Integer))) (: right (Fraction (Integer)))) (Record (: left (Fraction (Integer))) (: right (Fraction (Integer)))))) (SIGNATURE midpoint ((Fraction (Integer)) (Record (: left (Fraction (Integer))) (: right (Fraction (Integer)))))) (SIGNATURE midpoints ((List (Fraction (Integer))) (List (Record (: left (Fraction (Integer))) (: right (Fraction (Integer))))))))
      [2] Zero1:  G has no value
      [3] rootBound:  i has no value
      [4] transMultInv: :(NonNegativeInteger) -- should replace by pretend
      [5] var:  i has no value

============================================================================

   finalizing nrlib REALSOLV 
--->/research2/test0819/mnt/fedora5/../../src/algebra/REALSOLV.spad-->RealSolvePackage(constructor): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/REALSOLV.spad-->RealSolvePackage(): Missing Description

============================================================================

   finalizing nrlib RESRING 
   Warnings: 
      [1] unknown Functor code (error the residue ring is the zero ring)

============================================================================

   finalizing nrlib RETSOL 
   Warnings: 
      [1] PQIfCan: not known that (Ring) is of mode (CATEGORY package (SIGNATURE solveRetract ((List (List (Equation (Fraction (Polynomial R))))) (List (Polynomial R)) (List (Symbol)))))

============================================================================

   finalizing nrlib RFFACTOR 
   Warnings: 
      [1] factorFraction: not known that (PolynomialCategory (Fraction (Integer)) (IndexedExponents (Symbol)) (Symbol)) is of mode (CATEGORY domain (IF (has R (Algebra (Fraction (Integer)))) (SIGNATURE integrate ($ $ (Symbol))) noBranch))

============================================================================

   finalizing nrlib RMATCAT 
; (DEFUN |RectangularMatrixCategory| ...) is being compiled.
;; The variable |RectangularMatrixCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |RectangularMatrixCategory;| ...) is being compiled.
;; The variable |RectangularMatrixCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib RRCC 
; (DEFUN |RealRootCharacterizationCategory| ...) is being compiled.
;; The variable |RealRootCharacterizationCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |RealRootCharacterizationCategory;| ...) is being compiled.
;; The variable |RealRootCharacterizationCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib SHP 
   Warnings: 
      [1] subresultantSequenceNext: :(List (UnivariatePolynomial x R)) -- should replace by @
      [2] subresultantSequenceInner: :(UnivariatePolynomial x R) -- should replace by @
      [3] subresultantSequenceInner: :(List (UnivariatePolynomial x R)) -- should replace by @
      [4] subresultantSequence: :(List (UnivariatePolynomial x R)) -- should replace by @
      [5] polsth1: :(List (UnivariatePolynomial x R)) -- should replace by @
      [6] polsth1:  Listf has no value
      [7] polsth2: :(List (UnivariatePolynomial x R)) -- should replace by @
      [8] polsth3: :(List (UnivariatePolynomial x R)) -- should replace by @
      [9] wfunctaux: :(List R) -- should replace by @
      [10] wfunctaux: :(NonNegativeInteger) -- should replace by @
      [11] wfunct: :(List R) -- should replace by @
      [12] SturmHabicht: :(UnivariatePolynomial x R) -- should replace by @
      [13] SturmHabichtMultiple: :(UnivariatePolynomial x R) -- should replace by @
      [14] SturmHabichtMultiple: not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE countRealRootsMultiple ((Integer) (UnivariatePolynomial x R))))

============================================================================

   finalizing nrlib SIGNRF 
   Warnings: 
      [1] psign: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE sign ((Union (Integer) failed) (Fraction (Polynomial R)))) (SIGNATURE sign ((Union (Integer) failed) (Fraction (Polynomial R)) (Symbol) (OrderedCompletion (Fraction (Polynomial R))))) (SIGNATURE sign ((Union (Integer) failed) (Fraction (Polynomial R)) (Symbol) (Fraction (Polynomial R)) (String))))

============================================================================

   finalizing nrlib SMP 
   Warnings: 
      [1] ^: pretend(NonNegativeInteger) -- should replace by @
      [2] **: pretend(NonNegativeInteger) -- should replace by @
      [3] exquo: The conditional modes (SparseUnivariatePolynomial $) and D conflict
      [4] eval:  IN has no value
      [5] eval:  val has no value

============================================================================

   finalizing nrlib SOLVEFOR 
   Warnings: 
      [1] intsolve: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE solve ((List F) UP)) (SIGNATURE particularSolution (F UP)) (SIGNATURE mapSolve ((Record (: solns (List F)) (: maps (List (Record (: arg F) (: res F))))) UP (Mapping F F))) (SIGNATURE linear ((List F) UP)) (SIGNATURE quadratic ((List F) UP)) (SIGNATURE cubic ((List F) UP)) (SIGNATURE quartic ((List F) UP)) (SIGNATURE linear ((List F) F F)) (SIGNATURE quadratic ((List F) F F F)) (SIGNATURE cubic ((List F) F F F F)) (SIGNATURE quartic ((List F) F F F F F)) (SIGNATURE aLinear (F F F)) (SIGNATURE aQuadratic (F F F F)) (SIGNATURE aCubic (F F F F F)) (SIGNATURE aQuartic (F F F F F F)))

============================================================================

   finalizing nrlib SOLVEFOR 
--->/research2/test0819/mnt/fedora5/../../src/algebra/SOLVEFOR.spad-->PolynomialSolveByFormulas((** (% % (Fraction (Integer))))): Not documented!!!!

============================================================================

   finalizing nrlib SPLTREE 
   compiling exported eq? : ($,$) -> Boolean
      SPLTREE;eq?;2$B;20 is replaced by errorin eq? from SPLTREE : la vache qui rit est-elle folle? 

============================================================================

   finalizing nrlib SPLTREE 
   Warnings: 
      [1] splitNodeOf!:  la has no value

============================================================================

   finalizing nrlib STTFNC 
   compiling exported acos : Stream Coef -> Stream Coef
      STTFNC;acos;2S;12 is replaced by erroracos: acos undefined on this coefficient domain 
   compiling exported acot : Stream Coef -> Stream Coef
      STTFNC;acot;2S;13 is replaced by erroracot: acot undefined on this coefficient domain 
   compiling exported asec : Stream Coef -> Stream Coef
      STTFNC;asec;2S;14 is replaced by errorasec: asec undefined on this coefficient domain 
   compiling exported acsc : Stream Coef -> Stream Coef
      STTFNC;acsc;2S;15 is replaced by erroracsc: acsc undefined on this coefficient domain 
   compiling exported acosh : Stream Coef -> Stream Coef
      STTFNC;acosh;2S;24 is replaced by erroracosh: acosh undefined on this coefficient domain 
   compiling exported acoth : Stream Coef -> Stream Coef
      STTFNC;acoth;2S;25 is replaced by erroracoth: acoth undefined on this coefficient domain 
   compiling exported asech : Stream Coef -> Stream Coef
      STTFNC;asech;2S;26 is replaced by errorasech: asech undefined on this coefficient domain 
   compiling exported acsch : Stream Coef -> Stream Coef
      STTFNC;acsch;2S;27 is replaced by erroracsch: acsch undefined on this coefficient domain 

============================================================================

   finalizing nrlib SUP 
   Warnings: 
      [1] **: pretend(NonNegativeInteger) -- should replace by @
      [2] ^: pretend(NonNegativeInteger) -- should replace by @
      [3] **:  y has no value
      [4] pomopo!:  rout has no value
      [5] exquo: signature of lhs not unique: (Union $ failed)$$ chosen
      [6] fmecg:  rout has no value
      [7] pseudoRemainder: :(Integer) -- should replace by pretend
      [8] pseudoRemainder: :(NonNegativeInteger) -- should replace by pretend
      [9] elt: :(NonNegativeInteger) -- should replace by pretend

--------------non extending category----------------------
.. SparseUnivariatePolynomial #1 of cat 
(|Join| (|UnivariatePolynomialCategory| |#1|) (CATEGORY |domain| (SIGNATURE |outputForm| ((|OutputForm|) $ (|OutputForm|))) (SIGNATURE |fmecg| ($ $ (|NonNegativeInteger|) |#1| $))))   has no 
============================================================================

(IF (|has| |#1| (|IntegralDomain|)) (IF (|has| (|NonNegativeInteger|) (|CancellationAbelianMonoid|)) (SIGNATURE |fmecg| ($ $ (|NonNegativeInteger|) |#1| $)) |noBranch|) |noBranch|)    finalizing nrlib SUP 

============================================================================

   finalizing nrlib SUPFRACF 
   Warnings: 
      [1] squareFree: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE factor ((Factored (SparseUnivariatePolynomial (Fraction P))) (SparseUnivariatePolynomial (Fraction P)))) (SIGNATURE squareFree ((Factored (SparseUnivariatePolynomial (Fraction P))) (SparseUnivariatePolynomial (Fraction P)))))

============================================================================

   finalizing nrlib TEX 
   Warnings: 
      [1] display: pretend(Integer) -- should replace by @
      [2] coerce: pretend(Integer) -- should replace by @
      [3] stringify: pretend(String) -- should replace by @
      [4] splitLong1:  l has no value
      [5] splitLong1:  ls has no value
      [6] splitLong1:  s has no value
      [7] formatSpecial:  form has no value
      [8] formatSpecial:  prescript has no value
      [9] formatPlex:  s has no value
      [10] formatTex: pretend(Boolean) -- should replace by @

============================================================================

   finalizing nrlib TEXTFILE 
   Warnings: 
      [1] endOfFile?: pretend(Boolean) -- should replace by @

============================================================================

   finalizing nrlib TREE 
   Warnings: 
      [1] children:  node has no value
      [2] setchildren!:  node has no value
      [3] setchildren!: pretend$ -- should replace by @
      [4] setvalue!:  node has no value
      [5] count: signature of lhs not unique: (NonNegativeInteger)S$ chosen
      [6] value:  node has no value
      [7] node?:  t has no value
      [8] multipleOverbar: The conditional modes (String) and S conflict
 
============================================================================

   finalizing nrlib TWOFACT 
   Warnings: 
      [1] generalSqFr: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE generalTwoFactor ((Factored (SparseUnivariatePolynomial (SparseUnivariatePolynomial F))) (SparseUnivariatePolynomial (SparseUnivariatePolynomial F)))) (SIGNATURE generalSqFr ((Factored (SparseUnivariatePolynomial (SparseUnivariatePolynomial F))) (SparseUnivariatePolynomial (SparseUnivariatePolynomial F)))) (SIGNATURE twoFactor ((Factored (SparseUnivariatePolynomial (SparseUnivariatePolynomial F))) (SparseUnivariatePolynomial (SparseUnivariatePolynomial F)) (Integer))))
      [2] generalSqFr:  flg has no value
      [3] generalSqFr:  xpnt has no value
      [4] generalSqFr: :(NonNegativeInteger) -- should replace by pretend
      [5] generalSqFr:  fctr has no value
      [6] generalTwoFactor:  flg has no value
      [7] generalTwoFactor:  fctr has no value
      [8] generalTwoFactor:  xpnt has no value
      [9] generalTwoFactor:  ll has no value
      [10] generalTwoFactor:  unitPart has no value
      [11] twoFactor:  n has no value
      [12] twoFactor:  look has no value
      [13] twoFactor:  umv has no value
      [14] twoFactor:  umex has no value

============================================================================

   finalizing nrlib UNIFACT 
   Warnings: 
      [1] eisenstein: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE factor ((Factored ZP) ZP)) (SIGNATURE factorSquareFree ((Factored ZP) ZP)) (SIGNATURE henselFact ((Record (: contp (Integer)) (: factors (List (Record (: irr ZP) (: pow (Integer)))))) ZP (Boolean))))
      [2] bound: :(NonNegativeInteger) -- should replace by pretend
      [3] bound:  cbound has no value
      [4] numFactors: pretend(Integer) -- should replace by @
      [5] numFactors:  ans has no value
      [6] choose:  qSave has no value
      [7] choose:  ddSave has no value
      [8] quadratic:  beta has no value
      [9] quadratic:  alpha has no value
      [10] subMinusX: :ZP -- should replace by pretend
      [11] henselFact:  c has no value
      [12] henselFact:  factorlist has no value
      [13] henselFact: :(List ZP) -- should replace by pretend

--------------non extending category----------------------
.. UnivariatePolynomial(#1,#2) of cat 
(|Join| (|UnivariatePolynomialCategory| |#2|) (CATEGORY |domain| (SIGNATURE |coerce| ($ (|Variable| |#1|))) (SIGNATURE |fmecg| ($ $ (|NonNegativeInteger|) |#2| $))))    has no  outputForm : (%,OutputForm) -> OutputForm 

============================================================================

   finalizing nrlib UPDECOMP 
   Warnings: 
      [1] leftFactorIfCan:  g has no value

============================================================================

   finalizing nrlib UPXSCAT 
; (DEFUN |UnivariatePuiseuxSeriesCategory| ...) is being compiled.
;; The variable |UnivariatePuiseuxSeriesCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |UnivariatePuiseuxSeriesCategory;| ...) is being compiled.
;; The variable |UnivariatePuiseuxSeriesCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib UPSQFREE 
   Warnings: 
      [1] BumInSepFFE: :(NonNegativeInteger) -- should replace by @
      [2] squareFree:  lffe has no value
      [3] squareFree:  dunit has no value
 

============================================================================

   finalizing nrlib VIEWDEF 
   Warnings: 
      [1] viewWriteDefault:  thingsToWrite has no value

============================================================================

   finalizing nrlib WEIER 
   Warnings: 
      [1] transback: :(Stream (Stream (Polynomial R))) -- should replace by pretend
      [2] transback: :(TaylorSeries R) -- should replace by pretend
      [3] transback: :(Stream (TaylorSeries R)) -- should replace by pretend
      [4] clikeUniv: not known that (Ring) is of mode (CATEGORY package (SIGNATURE crest ((Mapping (Stream (Polynomial R)) (Stream (Polynomial R))) (NonNegativeInteger))) (SIGNATURE cfirst ((Mapping (Stream (Polynomial R)) (Stream (Polynomial R))) (NonNegativeInteger))) (SIGNATURE sts2stst ((Stream (Stream (Polynomial R))) (Symbol) (Stream (Polynomial R)))) (SIGNATURE clikeUniv ((Mapping (SparseUnivariatePolynomial (Polynomial R)) (Polynomial R)) (Symbol))) (SIGNATURE weierstrass ((List (TaylorSeries R)) (Symbol) (TaylorSeries R))) (SIGNATURE qqq ((Mapping (Stream (TaylorSeries R)) (Stream (TaylorSeries R))) (NonNegativeInteger) (TaylorSeries R) (Stream (TaylorSeries R)))))
      [5] streamlikeUniv: :(NonNegativeInteger) -- should replace by pretend
      [6] sts2stst: :(Stream (NonNegativeInteger)) -- should replace by pretend
      [7] weier: :(TaylorSeries R) -- should replace by pretend
      [8] wei: :(Stream (Polynomial R)) -- should replace by pretend

============================================================================

   finalizing nrlib WP 
   Warnings: 
      [1] innercoerce:  ans has no value
      [2] unknown Functor code (error incompatible length lists in WeightedPolynomial)

============================================================================

   finalizing nrlib WP 
--->/research2/test0819/mnt/fedora5/../../src/algebra/WP.spad-->WeightedPolynomials((coerce (P $))): Improper first word in comments: convert
"convert back into a \\spad{\"P\"},{} ignoring weights"

============================================================================

   finalizing nrlib DIAGG 
; (DEFUN |Dictionary| ...) is being compiled.
;; The variable |Dictionary;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |Dictionary;| ...) is being compiled.
;; The variable |Dictionary;CAT| is undefined.
;; The compiler will assume this variable is a global.

--------------non extending category----------------------
.. ExponentialOfUnivariatePuiseuxSeries(#1,#2,#3) of cat 
(|Join| (|UnivariatePuiseuxSeriesCategory| |#1|) (|OrderedAbelianMonoid|) (CATEGORY |domain| (SIGNATURE |exponential| ($ (|UnivariatePuiseuxSeries| |#1| |#2| |#3|))) (SIGNATURE |exponent| ((|UnivariatePuiseuxSeries| |#1| |#2| |#3|) $)) (SIGNATURE |exponentialOrder| ((|Fraction| (|Integer|)) $))))   has no 
============================================================================

(|UnivariatePuiseuxSeriesConstructorCategory| |#1| (|UnivariateLaurentSeries| |#1| |#2| |#3|))    finalizing nrlib EXPUPXS 

============================================================================

   finalizing nrlib FRAMALG- 
   Warnings: 
      [1] coordinates: signature of lhs not unique: (Matrix R)(Vector S) chosen

============================================================================

   finalizing nrlib FRAMALG 
; (DEFUN |FramedAlgebra| ...) is being compiled.
;; The variable |FramedAlgebra;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |FramedAlgebra;| ...) is being compiled.
;; The variable |FramedAlgebra;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib MDAGG 
; (DEFUN |MultiDictionary| ...) is being compiled.
;; The variable |MultiDictionary;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |MultiDictionary;| ...) is being compiled.
;; The variable |MultiDictionary;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib PLOT 
   Warnings: 
      [1] listBranches:  newl has no value
      [2] listBranches:  outList has no value
      [3] rangeRefine:  c has no value
      [4] rangeRefine:  q has no value
      [5] rangeRefine:  NUMFUNEVALS has no value
      [6] refine:  curves has no value
      [7] plot:  curves has no value
      [8] plot:  t has no value
      [9] coerce:  l has no value
 
============================================================================

   finalizing nrlib PLOT 
; (DEFUN |PLOT;myTrap| ...) is being compiled.
;; The variable |$numericFailure| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$NaNvalue| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib ROIRC 
--->/research2/test0819/mnt/fedora5/../../src/algebra/ROIRC.spad-->RightOpenIntervalRootCharacterization((size (TheField $))): Improper first word in comments: The
"The size of the isolating interval"

============================================================================

   finalizing nrlib SMATCAT- 
   Warnings: 
      [1] equation2R: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE ** (S S (Integer))) (SIGNATURE diagonalProduct (R S)) (SIGNATURE trace (R S)) (SIGNATURE diagonal (Row S)) (SIGNATURE reducedSystem ((Matrix R) (Matrix S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix R)) (: vec (Vector R))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix S))) (SIGNATURE retract (R S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE coerce (S R)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Integer) S)) (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE differentiate (S S (Mapping R R) (NonNegativeInteger))) (SIGNATURE differentiate (S S (Mapping R R))) (SIGNATURE coerce (S (Integer))) (SIGNATURE ** (S S (NonNegativeInteger))) (SIGNATURE ** (S S (PositiveInteger))) (SIGNATURE coerce ((OutputForm) S)))

============================================================================

   finalizing nrlib SMATCAT 
; (DEFUN |SquareMatrixCategory| ...) is being compiled.
;; The variable |SquareMatrixCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |SquareMatrixCategory;| ...) is being compiled.
;; The variable |SquareMatrixCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib UPXSCCA 
; (DEFUN |UnivariatePuiseuxSeriesConstructorCategory| ...) is being compiled.
;; The variable |UnivariatePuiseuxSeriesConstructorCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |UnivariatePuiseuxSeriesConstructorCategory;| ...) is being compiled.
;; The variable |UnivariatePuiseuxSeriesConstructorCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FFINTBAS 
   Warnings: 
      [1] squaredFactors: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE integralBasis ((Record (: basis (Matrix R)) (: basisDen R) (: basisInv (Matrix R))))) (SIGNATURE localIntegralBasis ((Record (: basis (Matrix R)) (: basisDen R) (: basisInv (Matrix R))) R)))

============================================================================

   finalizing nrlib FSAGG 
; (DEFUN |FiniteSetAggregate| ...) is being compiled.
;; The variable |FiniteSetAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |FiniteSetAggregate;| ...) is being compiled.
;; The variable |FiniteSetAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib KDAGG 
; (DEFUN |KeyedDictionary| ...) is being compiled.
;; The variable |KeyedDictionary;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |KeyedDictionary;| ...) is being compiled.
;; The variable |KeyedDictionary;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib MSETAGG 
; (DEFUN |MultisetAggregate| ...) is being compiled.
;; The variable |MultisetAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |MultisetAggregate;| ...) is being compiled.
;; The variable |MultisetAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib MONOGEN 
; (DEFUN |MonogenicAlgebra| ...) is being compiled.
;; The variable |MonogenicAlgebra;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |MonogenicAlgebra;| ...) is being compiled.
;; The variable |MonogenicAlgebra;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib NFINTBAS 
   Warnings: 
      [1] wildPrimes:  ans has no value
      [2] tameProduct:  ans has no value
      [3] integralBasis:  runningRbden has no value
      [4] iWildLocalIntegralBasis:  rbden has no value

============================================================================

   finalizing nrlib SPACE3 
   Warnings: 
      [1] coerce:  llliPt has no value

============================================================================

   finalizing nrlib CCLASS 
   Warnings: 
      [1] remove!: signature of lhs not unique: $(Character)$ chosen

============================================================================

   finalizing nrlib GALFACT 
   Warnings: 
      [1] eisensteinIrreducible?: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE makeFR ((Factored UP) (Record (: contp (Integer)) (: factors (List (Record (: irr UP) (: pow (Integer)))))))) (SIGNATURE degreePartition ((Multiset (NonNegativeInteger)) (List (Record (: factor UP) (: degree (Integer)))))) (SIGNATURE musserTrials ((PositiveInteger))) (SIGNATURE musserTrials ((PositiveInteger) (PositiveInteger))) (SIGNATURE stopMusserTrials ((PositiveInteger))) (SIGNATURE stopMusserTrials ((PositiveInteger) (PositiveInteger))) (SIGNATURE numberOfFactors ((NonNegativeInteger) (List (Record (: factor UP) (: degree (Integer)))))) (SIGNATURE modularFactor ((Record (: prime (Integer)) (: factors (List UP))) UP)) (SIGNATURE useSingleFactorBound? ((Boolean))) (SIGNATURE useSingleFactorBound ((Boolean) (Boolean))) (SIGNATURE useEisensteinCriterion? ((Boolean))) (SIGNATURE useEisensteinCriterion ((Boolean) (Boolean))) (SIGNATURE eisensteinIrreducible? ((Boolean) UP)) (SIGNATURE tryFunctionalDecomposition? ((Boolean))) (SIGNATURE tryFunctionalDecomposition ((Boolean) (Boolean))) (SIGNATURE factor ((Factored UP) UP)) (SIGNATURE factor ((Factored UP) UP (NonNegativeInteger))) (SIGNATURE factor ((Factored UP) UP (List (NonNegativeInteger)))) (SIGNATURE factor ((Factored UP) UP (List (NonNegativeInteger)) (NonNegativeInteger))) (SIGNATURE factor ((Factored UP) UP (NonNegativeInteger) (NonNegativeInteger))) (SIGNATURE factorSquareFree ((Factored UP) UP)) (SIGNATURE factorSquareFree ((Factored UP) UP (NonNegativeInteger))) (SIGNATURE factorSquareFree ((Factored UP) UP (List (NonNegativeInteger)))) (SIGNATURE factorSquareFree ((Factored UP) UP (List (NonNegativeInteger)) (NonNegativeInteger))) (SIGNATURE factorSquareFree ((Factored UP) UP (NonNegativeInteger) (NonNegativeInteger))) (SIGNATURE factorOfDegree ((Union UP failed) (PositiveInteger) UP)) (SIGNATURE factorOfDegree ((Union UP failed) (PositiveInteger) UP (NonNegativeInteger))) (SIGNATURE factorOfDegree ((Union UP failed) (PositiveInteger) UP (List (NonNegativeInteger)))) (SIGNATURE factorOfDegree ((Union UP failed) (PositiveInteger) UP (List (NonNegativeInteger)) (NonNegativeInteger))) (SIGNATURE factorOfDegree ((Union UP failed) (PositiveInteger) UP (List (NonNegativeInteger)) (NonNegativeInteger) (Boolean))) (SIGNATURE henselFact ((Record (: contp (Integer)) (: factors (List (Record (: irr UP) (: pow (Integer)))))) UP (Boolean))) (SIGNATURE btwFact ((Record (: contp (Integer)) (: factors (List (Record (: irr UP) (: pow (Integer)))))) UP (Boolean) (Set (NonNegativeInteger)) (NonNegativeInteger))))
      [2] modularFactor:  s has no value
      [3] completeFactor:  g0 has no value
      [4] completeFactor:  degg has no value
      [5] completeFactor:  g has no value
      [6] completeFactor:  ltrue has no value
      [7] completeFactor:  level has no value
      [8] divideSet:  l has no value
      [9] btwFactor:  reverse? has no value
      [10] btwFactor:  negativelc? has no value
      [11] btwFactor:  lf has no value
      [12] henselFact:  c has no value
      [13] henselFact:  factorlist has no value
      [14] btwFact:  c has no value
      [15] btwFact:  factorlist has no value
 

============================================================================

   finalizing nrlib IALGFACT 
   Warnings: 
      [1] factor: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE factor ((Factored AlPol) AlPol (Mapping (Factored UP) UP))))

============================================================================

   finalizing nrlib MMLFORM 
   Warnings: 
      [1] exprex:  s has no value
      [2] formatSub:  j has no value
      [3] formatSub:  s has no value
      [4] formatSub1:  s has no value
      [5] formatPlex:  s has no value

============================================================================

   finalizing nrlib OMSAGG 
; (DEFUN |OrderedMultisetAggregate| ...) is being compiled.
;; The variable |OrderedMultisetAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |OrderedMultisetAggregate;| ...) is being compiled.
;; The variable |OrderedMultisetAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib PERM 
   Warnings: 
      [1] rotateCycle:  minpos has no value
      [2] coerceToCycle:  nextCycle has no value
      [3] coercePreimagesImages:  preImage has no value
      [4] coercePreimagesImages:  image has no value

============================================================================

   finalizing nrlib PERMGRP 
   Warnings: 
      [1] shortenWord:  newlw has no value
      [2] orbitInternal:  pos has no value
      [3] orbitInternal:  orbitList has no value
      [4] bsgs1:  j has no value
      [5] bsgs1:  out has no value
      [6] bsgs1:  outword has no value
      [7] bsgs1:  baseOfGroup has no value
      [8] reduceGenerators:  wordlist has no value
      [9] bsgs:  gpbase has no value
      [10] bsgs:  baseOfGroup has no value
      [11] bsgs:  wordProblem has no value
      [12] bsgs:  wordlist has no value
      [13] bsgs:  gporb has no value
      [14] bsgs:  noresult has no value
      [15] bsgs:  newBasePoint has no value
      [16] bsgs:  basePoint has no value
      [17] memberInternal:  supp has no value
      [18] memberInternal:  sgs has no value
      [19] memberInternal:  baseOfGroup has no value
      [20] memberInternal:  gporb has no value
      [21] coerce: :(Symbol) -- should replace by pretend

============================================================================

   finalizing nrlib PWFFINTB 
   Warnings: 
      [1] listSquaredFactors:  ans has no value

============================================================================

   finalizing nrlib SAE 
   Warnings: 
      [1] lift: pretendRep -- should replace by @
      [2] index:  ans has no value
      [3] unknown Functor code (error Modulus cannot be made monic)

============================================================================

   finalizing nrlib SGCF 
   Warnings: 
      [1] unrankImproperPartitions0:  l has no value
      [2] unrankImproperPartitions1:  nonZeros has no value
      [3] subSet:  l has no value
      [4] nextLatticePermutation:  ready has no value
      [5] listYoungTableaus:  lattice has no value

============================================================================

   finalizing nrlib TBAGG- 
   Warnings: 
      [1] map!: signature of lhs not unique: S(Mapping Entry Entry)S chosen

============================================================================

   finalizing nrlib TBAGG 
; (DEFUN |TableAggregate| ...) is being compiled.
;; The variable |TableAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |TableAggregate;| ...) is being compiled.
;; The variable |TableAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib VIEW3D 
   Warnings: 
      [1] viewpoint:  Theta has no value
 
============================================================================

   finalizing nrlib VIEW3D 
--->/research2/test0819/mnt/fedora5/../../src/algebra/VIEW3D.spad-->ThreeDimensionalViewport(constructor): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/VIEW3D.spad-->ThreeDimensionalViewport(): Missing Description

============================================================================

   finalizing nrlib ALIST 
   Warnings: 
      [1] latex:  s has no value
      [2] remove!:  key has no value

============================================================================

   finalizing nrlib HASHTBL 
   Warnings: 
      [1] remove!: pretendEntry -- should replace by @
      [2] search: pretendEntry -- should replace by @

============================================================================

   finalizing nrlib INTPACK 
   Warnings: 
      [1] preAnalysis:  nia has no value
      [2] measureSpecific:  nia has no value
      [3] measureSpecific:  mdnia has no value
      [4] integrateSpecific:  nia has no value
      [5] integrateSpecific:  mdnia has no value
      [6] recoverAfterFail:  nia has no value
      [7] integrateArgs:  mdnia has no value
      [8] integrateArgs:  nia has no value

============================================================================

   finalizing nrlib INTPACK 
--->/research2/test0819/mnt/fedora5/../../src/algebra/INTPACK.spad-->AnnaNumericalIntegrationPackage(constructor): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/INTPACK.spad-->AnnaNumericalIntegrationPackage(): Missing Description

============================================================================

   finalizing nrlib IPF 
   Warnings: 
      [1] tableForDiscreteLogarithm: pretend(Table (PositiveInteger) (NonNegativeInteger)) -- should replace by @
      [2] initializeLog:  n has no value
      [3] coordinates: signature of lhs not unique: (Vector $)$ chosen
      [4] charthRoot: signature of lhs not unique: $$ chosen

============================================================================

   finalizing nrlib ACF- 
   Warnings: 
      [1] zeroOf: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE zerosOf ((List S) (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE zerosOf ((List S) (SparseUnivariatePolynomial S))) (SIGNATURE zerosOf ((List S) (Polynomial S))) (SIGNATURE zeroOf (S (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE zeroOf (S (SparseUnivariatePolynomial S))) (SIGNATURE zeroOf (S (Polynomial S))) (SIGNATURE rootsOf ((List S) (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE rootsOf ((List S) (SparseUnivariatePolynomial S))) (SIGNATURE rootsOf ((List S) (Polynomial S))) (SIGNATURE rootOf (S (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE rootOf (S (SparseUnivariatePolynomial S))) (SIGNATURE rootOf (S (Polynomial S))))

============================================================================

   finalizing nrlib ACF 
; (DEFUN |AlgebraicallyClosedField| ...) is being compiled.
;; The variable |AlgebraicallyClosedField;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib ACPLOT 
   Warnings: 
      [1] listPtsOnHorizBdry:  pointList has no value
      [2] listPtsOnVertBdry:  pointList has no value
      [3] listPtsInRect:  pointList has no value
      [4] makeOneVarSketch:  sketchRoots has no value
      [5] makeOneVarSketch:  lf has no value
      [6] makeOneVarSketch:  rt has no value
      [7] makeOneVarSketch:  bt has no value
      [8] makeOneVarSketch:  tp has no value
      [9] makeLineSketch:  branch has no value
      [10] makeLineSketch:  lf has no value
      [11] makeLineSketch:  rt has no value
      [12] makeLineSketch:  bt has no value
      [13] makeLineSketch:  tp has no value
      [14] makeRatFcnSketch:  outList has no value
      [15] makeRatFcnSketch:  lf has no value
      [16] makeRatFcnSketch:  rt has no value
      [17] makeRatFcnSketch:  bt has no value
      [18] makeRatFcnSketch:  tp has no value
      [19] makeRatFcnSketch:  topList has no value
      [20] makeRatFcnSketch:  botList has no value
      [21] listPtsOnLoop:  pointList has no value
      [22] computeNextPt:  xPointList has no value
      [23] computeNextPt:  yPointList has no value

--------------non extending category----------------------
.. AntiSymm(#1,#2) of cat 
(|Join| (|LeftAlgebra| |#1|) (|RetractableTo| |#1|) (CATEGORY |domain| (SIGNATURE |leadingCoefficient| (|#1| $)) (SIGNATURE |leadingBasisTerm| ($ $)) (SIGNATURE |reductum| ($ $)) (SIGNATURE |coefficient| (|#1| $ $)) (SIGNATURE |generator| ($ (|NonNegativeInteger|))) (SIGNATURE |exp| ($ (|List| (|Integer|)))) (SIGNATURE |homogeneous?| ((|Boolean|) $)) (SIGNATURE |retractable?| ((|Boolean|) $)) (SIGNATURE |degree| ((|NonNegativeInteger|) $)) (SIGNATURE |map| ($ (|Mapping| |#1| |#1|) $))))   has no 
============================================================================

(|BiModule| |#1| |#1|)    finalizing nrlib ANTISYM 

============================================================================

   finalizing nrlib ANTISYM 
   Warnings: 
      [1] retractable?:  k has no value
      [2] retractIfCan:  k has no value
      [3] *:  k has no value
      [4] *:  c has no value
      [5] *:  z has no value
      [6] coerce:  c has no value
      [7] coerce:  k has no value

============================================================================

   finalizing nrlib ASP12 
   Warnings: 
      [1]  MAXIT has no value
      [2]  IFLAG has no value
      [3]  ELAM has no value
      [4]  FINFO has no value

============================================================================

   finalizing nrlib ASP27 
   Warnings: 
      [1]  IFLAG has no value
      [2]  N has no value
      [3]  LRWORK has no value
      [4]  LIWORK has no value
      [5]  Z has no value
      [6]  W has no value
      [7]  RWORK has no value
      [8]  IWORK has no value

============================================================================

   finalizing nrlib ASP28 
   Warnings: 
      [1]  IFLAG has no value
      [2]  N has no value
      [3]  LRWORK has no value
      [4]  LIWORK has no value
      [5]  Z has no value
      [6]  W has no value
      [7]  RWORK has no value
      [8]  IWORK has no value

============================================================================

   finalizing nrlib ASP33 
   Warnings: 
      [1]  JINT has no value
      [2]  X has no value
      [3]  V has no value

============================================================================

   finalizing nrlib ASP49 
   Warnings: 
      [1]  MODE has no value
      [2]  N has no value
      [3]  X has no value
      [4]  OBJF has no value
      [5]  OBJGRD has no value
      [6]  NSTATE has no value
      [7]  IUSER has no value
      [8]  USER has no value

============================================================================

   finalizing nrlib ASP55 
   Warnings: 
      [1]  MODE has no value
      [2]  NCNLN has no value
      [3]  N has no value
      [4]  NROWJ has no value
      [5]  NEEDC has no value
      [6]  X has no value
      [7]  C has no value
      [8]  CJAC has no value
      [9]  NSTATE has no value
      [10]  IUSER has no value
      [11]  USER has no value
      [12] makeCond:  NEEDC has no value

============================================================================

   finalizing nrlib ASP7 
   Warnings: 
      [1]  X has no value
      [2]  Y has no value
      [3]  F has no value
      [4] coerce:  F has no value

============================================================================

   finalizing nrlib ASP78 
   Warnings: 
      [1]  X has no value
      [2]  G has no value
      [3] coerce:  G has no value

============================================================================

   finalizing nrlib ASP8 
   Semantic Errors: 
      [1] coerce:  code is BOTH a variable and a literal
 
   Warnings: 
      [1]  COUNT has no value
      [2]  XSOL has no value
      [3]  N has no value
      [4]  Y has no value
      [5]  FORWRD has no value
      [6]  RESULT has no value
      [7]  M has no value
      [8] coerce:  POINTS has no value
      [9] coerce:  X02ALF has no value
      [10] coerce:  RESULT has no value
      [11] coerce:  COUNT has no value
      [12] coerce:  XSOL has no value
 
============================================================================

   finalizing nrlib ASP9 
   Semantic Errors: 
      [1] coerce:  code is BOTH a variable and a literal
 
   Warnings: 
      [1]  X has no value
      [2]  Y has no value
      [3] coerce:  CHDUM1 has no value
      [4] coerce:  CD02EJ has no value
      [5] coerce:  AD02CJ has no value
      [6] coerce:  GOPT1 has no value
      [7] coerce:  GOPT2 has no value

============================================================================

   finalizing nrlib COMPCAT- 
   Warnings: 
      [1] solveLinearPolynomialEquation: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE coerce (S S)) (SIGNATURE exquo ((Union S failed) S S)) (SIGNATURE unitNormal ((Record (: unit S) (: canonical S) (: associate S)) S)) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE euclideanSize ((NonNegativeInteger) S)) (SIGNATURE divide ((Record (: quotient S) (: remainder S)) S S)) (SIGNATURE quo (S S S)) (SIGNATURE rem (S S S)) (SIGNATURE inv (S S)) (SIGNATURE ** (S S (Integer))) (SIGNATURE * (S S (Fraction (Integer)))) (SIGNATURE * (S (Fraction (Integer)) S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE < ((Boolean) S S)) (SIGNATURE convert ((InputForm) S)) (SIGNATURE convert ((Complex (DoubleFloat)) S)) (SIGNATURE convert ((Complex (Float)) S)) (SIGNATURE tan (S S)) (SIGNATURE sin (S S)) (SIGNATURE cos (S S)) (SIGNATURE acos (S S)) (SIGNATURE asin (S S)) (SIGNATURE atan (S S)) (SIGNATURE cosh (S S)) (SIGNATURE sinh (S S)) (SIGNATURE tanh (S S)) (SIGNATURE acosh (S S)) (SIGNATURE asinh (S S)) (SIGNATURE atanh (S S)) (SIGNATURE log (S S)) (SIGNATURE exp (S S)) (SIGNATURE ** (S S S)) (SIGNATURE pi (S)) (SIGNATURE ** (S S (Fraction (Integer)))) (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE rationalIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE rational ((Fraction (Integer)) S)) (SIGNATURE rational? ((Boolean) S)) (SIGNATURE polarCoordinates ((Record (: r R) (: phi R)) S)) (SIGNATURE argument (R S)) (SIGNATURE abs (S S)) (SIGNATURE exquo ((Union S failed) S R)) (SIGNATURE conjugate (S S)) (SIGNATURE imaginary (S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE patternMatch ((PatternMatchResult (Float) S) S (Pattern (Float)) (PatternMatchResult (Float) S))) (SIGNATURE patternMatch ((PatternMatchResult (Integer) S) S (Pattern (Integer)) (PatternMatchResult (Integer) S))) (SIGNATURE map (S (Mapping R R) S)) (SIGNATURE differentiate (S S (Mapping R R))) (SIGNATURE differentiate (S S (Mapping R R) (NonNegativeInteger))) (SIGNATURE reduce ((Union S failed) (Fraction (SparseUnivariatePolynomial R)))) (SIGNATURE lift ((SparseUnivariatePolynomial R) S)) (SIGNATURE convert (S (SparseUnivariatePolynomial R))) (SIGNATURE reduce (S (SparseUnivariatePolynomial R))) (SIGNATURE definingPolynomial ((SparseUnivariatePolynomial R))) (SIGNATURE reducedSystem ((Matrix R) (Matrix S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix R)) (: vec (Vector R))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix S))) (SIGNATURE retract (R S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Integer) S)) (SIGNATURE convert ((SparseUnivariatePolynomial R) S)) (SIGNATURE discriminant (R)) (SIGNATURE convert (S (Vector R))) (SIGNATURE convert ((Vector R) S)) (SIGNATURE coordinates ((Matrix R) (Vector S))) (SIGNATURE coordinates ((Vector R) S)) (SIGNATURE minimalPolynomial ((SparseUnivariatePolynomial R) S)) (SIGNATURE characteristicPolynomial ((SparseUnivariatePolynomial R) S)) (SIGNATURE discriminant (R (Vector S))) (SIGNATURE coordinates ((Matrix R) (Vector S) (Vector S))) (SIGNATURE coordinates ((Vector R) S (Vector S))) (SIGNATURE norm (R S)) (SIGNATURE trace (R S)) (SIGNATURE rank ((PositiveInteger))) (SIGNATURE coerce (S R)) (SIGNATURE * (S R S)) (SIGNATURE * (S S R)) (SIGNATURE coerce (S (Integer))) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE ** (S S (NonNegativeInteger))) (SIGNATURE recip ((Union S failed) S)) (SIGNATURE * (S S S)) (SIGNATURE ** (S S (PositiveInteger))) (SIGNATURE * (S (Integer) S)) (SIGNATURE - (S S S)) (SIGNATURE - (S S)) (SIGNATURE * (S (NonNegativeInteger) S)) (SIGNATURE * (S (PositiveInteger) S)) (SIGNATURE + (S S S)) (SIGNATURE coerce ((OutputForm) S)) (SIGNATURE = ((Boolean) S S)))
      [2] factorPolynomial: not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE coerce (S S)) (SIGNATURE exquo ((Union S failed) S S)) (SIGNATURE unitNormal ((Record (: unit S) (: canonical S) (: associate S)) S)) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE euclideanSize ((NonNegativeInteger) S)) (SIGNATURE divide ((Record (: quotient S) (: remainder S)) S S)) (SIGNATURE quo (S S S)) (SIGNATURE rem (S S S)) (SIGNATURE inv (S S)) (SIGNATURE ** (S S (Integer))) (SIGNATURE * (S S (Fraction (Integer)))) (SIGNATURE * (S (Fraction (Integer)) S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE < ((Boolean) S S)) (SIGNATURE convert ((InputForm) S)) (SIGNATURE convert ((Complex (DoubleFloat)) S)) (SIGNATURE convert ((Complex (Float)) S)) (SIGNATURE tan (S S)) (SIGNATURE sin (S S)) (SIGNATURE cos (S S)) (SIGNATURE acos (S S)) (SIGNATURE asin (S S)) (SIGNATURE atan (S S)) (SIGNATURE cosh (S S)) (SIGNATURE sinh (S S)) (SIGNATURE tanh (S S)) (SIGNATURE acosh (S S)) (SIGNATURE asinh (S S)) (SIGNATURE atanh (S S)) (SIGNATURE log (S S)) (SIGNATURE exp (S S)) (SIGNATURE ** (S S S)) (SIGNATURE pi (S)) (SIGNATURE ** (S S (Fraction (Integer)))) (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE rationalIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE rational ((Fraction (Integer)) S)) (SIGNATURE rational? ((Boolean) S)) (SIGNATURE polarCoordinates ((Record (: r R) (: phi R)) S)) (SIGNATURE argument (R S)) (SIGNATURE abs (S S)) (SIGNATURE exquo ((Union S failed) S R)) (SIGNATURE conjugate (S S)) (SIGNATURE imaginary (S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE patternMatch ((PatternMatchResult (Float) S) S (Pattern (Float)) (PatternMatchResult (Float) S))) (SIGNATURE patternMatch ((PatternMatchResult (Integer) S) S (Pattern (Integer)) (PatternMatchResult (Integer) S))) (SIGNATURE map (S (Mapping R R) S)) (SIGNATURE differentiate (S S (Mapping R R))) (SIGNATURE differentiate (S S (Mapping R R) (NonNegativeInteger))) (SIGNATURE reduce ((Union S failed) (Fraction (SparseUnivariatePolynomial R)))) (SIGNATURE lift ((SparseUnivariatePolynomial R) S)) (SIGNATURE convert (S (SparseUnivariatePolynomial R))) (SIGNATURE reduce (S (SparseUnivariatePolynomial R))) (SIGNATURE definingPolynomial ((SparseUnivariatePolynomial R))) (SIGNATURE reducedSystem ((Matrix R) (Matrix S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix R)) (: vec (Vector R))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix S))) (SIGNATURE retract (R S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Integer) S)) (SIGNATURE convert ((SparseUnivariatePolynomial R) S)) (SIGNATURE discriminant (R)) (SIGNATURE convert (S (Vector R))) (SIGNATURE convert ((Vector R) S)) (SIGNATURE coordinates ((Matrix R) (Vector S))) (SIGNATURE coordinates ((Vector R) S)) (SIGNATURE minimalPolynomial ((SparseUnivariatePolynomial R) S)) (SIGNATURE characteristicPolynomial ((SparseUnivariatePolynomial R) S)) (SIGNATURE discriminant (R (Vector S))) (SIGNATURE coordinates ((Matrix R) (Vector S) (Vector S))) (SIGNATURE coordinates ((Vector R) S (Vector S))) (SIGNATURE norm (R S)) (SIGNATURE trace (R S)) (SIGNATURE rank ((PositiveInteger))) (SIGNATURE coerce (S R)) (SIGNATURE * (S R S)) (SIGNATURE * (S S R)) (SIGNATURE coerce (S (Integer))) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE ** (S S (NonNegativeInteger))) (SIGNATURE recip ((Union S failed) S)) (SIGNATURE * (S S S)) (SIGNATURE ** (S S (PositiveInteger))) (SIGNATURE * (S (Integer) S)) (SIGNATURE - (S S S)) (SIGNATURE - (S S)) (SIGNATURE * (S (NonNegativeInteger) S)) (SIGNATURE * (S (PositiveInteger) S)) (SIGNATURE + (S S S)) (SIGNATURE coerce ((OutputForm) S)) (SIGNATURE = ((Boolean) S S)))
      [3] factorPolynomial: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE coerce (S S)) (SIGNATURE exquo ((Union S failed) S S)) (SIGNATURE unitNormal ((Record (: unit S) (: canonical S) (: associate S)) S)) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE euclideanSize ((NonNegativeInteger) S)) (SIGNATURE divide ((Record (: quotient S) (: remainder S)) S S)) (SIGNATURE quo (S S S)) (SIGNATURE rem (S S S)) (SIGNATURE inv (S S)) (SIGNATURE ** (S S (Integer))) (SIGNATURE * (S S (Fraction (Integer)))) (SIGNATURE * (S (Fraction (Integer)) S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE < ((Boolean) S S)) (SIGNATURE convert ((InputForm) S)) (SIGNATURE convert ((Complex (DoubleFloat)) S)) (SIGNATURE convert ((Complex (Float)) S)) (SIGNATURE tan (S S)) (SIGNATURE sin (S S)) (SIGNATURE cos (S S)) (SIGNATURE acos (S S)) (SIGNATURE asin (S S)) (SIGNATURE atan (S S)) (SIGNATURE cosh (S S)) (SIGNATURE sinh (S S)) (SIGNATURE tanh (S S)) (SIGNATURE acosh (S S)) (SIGNATURE asinh (S S)) (SIGNATURE atanh (S S)) (SIGNATURE log (S S)) (SIGNATURE exp (S S)) (SIGNATURE ** (S S S)) (SIGNATURE pi (S)) (SIGNATURE ** (S S (Fraction (Integer)))) (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE rationalIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE rational ((Fraction (Integer)) S)) (SIGNATURE rational? ((Boolean) S)) (SIGNATURE polarCoordinates ((Record (: r R) (: phi R)) S)) (SIGNATURE argument (R S)) (SIGNATURE abs (S S)) (SIGNATURE exquo ((Union S failed) S R)) (SIGNATURE conjugate (S S)) (SIGNATURE imaginary (S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE patternMatch ((PatternMatchResult (Float) S) S (Pattern (Float)) (PatternMatchResult (Float) S))) (SIGNATURE patternMatch ((PatternMatchResult (Integer) S) S (Pattern (Integer)) (PatternMatchResult (Integer) S))) (SIGNATURE map (S (Mapping R R) S)) (SIGNATURE differentiate (S S (Mapping R R))) (SIGNATURE differentiate (S S (Mapping R R) (NonNegativeInteger))) (SIGNATURE reduce ((Union S failed) (Fraction (SparseUnivariatePolynomial R)))) (SIGNATURE lift ((SparseUnivariatePolynomial R) S)) (SIGNATURE convert (S (SparseUnivariatePolynomial R))) (SIGNATURE reduce (S (SparseUnivariatePolynomial R))) (SIGNATURE definingPolynomial ((SparseUnivariatePolynomial R))) (SIGNATURE reducedSystem ((Matrix R) (Matrix S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix R)) (: vec (Vector R))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix S))) (SIGNATURE retract (R S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Integer) S)) (SIGNATURE convert ((SparseUnivariatePolynomial R) S)) (SIGNATURE discriminant (R)) (SIGNATURE convert (S (Vector R))) (SIGNATURE convert ((Vector R) S)) (SIGNATURE coordinates ((Matrix R) (Vector S))) (SIGNATURE coordinates ((Vector R) S)) (SIGNATURE minimalPolynomial ((SparseUnivariatePolynomial R) S)) (SIGNATURE characteristicPolynomial ((SparseUnivariatePolynomial R) S)) (SIGNATURE discriminant (R (Vector S))) (SIGNATURE coordinates ((Matrix R) (Vector S) (Vector S))) (SIGNATURE coordinates ((Vector R) S (Vector S))) (SIGNATURE norm (R S)) (SIGNATURE trace (R S)) (SIGNATURE rank ((PositiveInteger))) (SIGNATURE coerce (S R)) (SIGNATURE * (S R S)) (SIGNATURE * (S S R)) (SIGNATURE coerce (S (Integer))) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE ** (S S (NonNegativeInteger))) (SIGNATURE recip ((Union S failed) S)) (SIGNATURE * (S S S)) (SIGNATURE ** (S S (PositiveInteger))) (SIGNATURE * (S (Integer) S)) (SIGNATURE - (S S S)) (SIGNATURE - (S S)) (SIGNATURE * (S (NonNegativeInteger) S)) (SIGNATURE * (S (PositiveInteger) S)) (SIGNATURE + (S S S)) (SIGNATURE coerce ((OutputForm) S)) (SIGNATURE = ((Boolean) S S)))
      [4] reducedSystem: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE coerce (S S)) (SIGNATURE exquo ((Union S failed) S S)) (SIGNATURE unitNormal ((Record (: unit S) (: canonical S) (: associate S)) S)) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE euclideanSize ((NonNegativeInteger) S)) (SIGNATURE divide ((Record (: quotient S) (: remainder S)) S S)) (SIGNATURE quo (S S S)) (SIGNATURE rem (S S S)) (SIGNATURE inv (S S)) (SIGNATURE ** (S S (Integer))) (SIGNATURE * (S S (Fraction (Integer)))) (SIGNATURE * (S (Fraction (Integer)) S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE < ((Boolean) S S)) (SIGNATURE convert ((InputForm) S)) (SIGNATURE convert ((Complex (DoubleFloat)) S)) (SIGNATURE convert ((Complex (Float)) S)) (SIGNATURE tan (S S)) (SIGNATURE sin (S S)) (SIGNATURE cos (S S)) (SIGNATURE acos (S S)) (SIGNATURE asin (S S)) (SIGNATURE atan (S S)) (SIGNATURE cosh (S S)) (SIGNATURE sinh (S S)) (SIGNATURE tanh (S S)) (SIGNATURE acosh (S S)) (SIGNATURE asinh (S S)) (SIGNATURE atanh (S S)) (SIGNATURE log (S S)) (SIGNATURE exp (S S)) (SIGNATURE ** (S S S)) (SIGNATURE pi (S)) (SIGNATURE ** (S S (Fraction (Integer)))) (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE rationalIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE rational ((Fraction (Integer)) S)) (SIGNATURE rational? ((Boolean) S)) (SIGNATURE polarCoordinates ((Record (: r R) (: phi R)) S)) (SIGNATURE argument (R S)) (SIGNATURE abs (S S)) (SIGNATURE exquo ((Union S failed) S R)) (SIGNATURE conjugate (S S)) (SIGNATURE imaginary (S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE patternMatch ((PatternMatchResult (Float) S) S (Pattern (Float)) (PatternMatchResult (Float) S))) (SIGNATURE patternMatch ((PatternMatchResult (Integer) S) S (Pattern (Integer)) (PatternMatchResult (Integer) S))) (SIGNATURE map (S (Mapping R R) S)) (SIGNATURE differentiate (S S (Mapping R R))) (SIGNATURE differentiate (S S (Mapping R R) (NonNegativeInteger))) (SIGNATURE reduce ((Union S failed) (Fraction (SparseUnivariatePolynomial R)))) (SIGNATURE lift ((SparseUnivariatePolynomial R) S)) (SIGNATURE convert (S (SparseUnivariatePolynomial R))) (SIGNATURE reduce (S (SparseUnivariatePolynomial R))) (SIGNATURE definingPolynomial ((SparseUnivariatePolynomial R))) (SIGNATURE reducedSystem ((Matrix R) (Matrix S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix R)) (: vec (Vector R))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix S))) (SIGNATURE retract (R S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Integer) S)) (SIGNATURE convert ((SparseUnivariatePolynomial R) S)) (SIGNATURE discriminant (R)) (SIGNATURE convert (S (Vector R))) (SIGNATURE convert ((Vector R) S)) (SIGNATURE coordinates ((Matrix R) (Vector S))) (SIGNATURE coordinates ((Vector R) S)) (SIGNATURE minimalPolynomial ((SparseUnivariatePolynomial R) S)) (SIGNATURE characteristicPolynomial ((SparseUnivariatePolynomial R) S)) (SIGNATURE discriminant (R (Vector S))) (SIGNATURE coordinates ((Matrix R) (Vector S) (Vector S))) (SIGNATURE coordinates ((Vector R) S (Vector S))) (SIGNATURE norm (R S)) (SIGNATURE trace (R S)) (SIGNATURE rank ((PositiveInteger))) (SIGNATURE coerce (S R)) (SIGNATURE * (S R S)) (SIGNATURE * (S S R)) (SIGNATURE coerce (S (Integer))) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE ** (S S (NonNegativeInteger))) (SIGNATURE recip ((Union S failed) S)) (SIGNATURE * (S S S)) (SIGNATURE ** (S S (PositiveInteger))) (SIGNATURE * (S (Integer) S)) (SIGNATURE - (S S S)) (SIGNATURE - (S S)) (SIGNATURE * (S (NonNegativeInteger) S)) (SIGNATURE * (S (PositiveInteger) S)) (SIGNATURE + (S S S)) (SIGNATURE coerce ((OutputForm) S)) (SIGNATURE = ((Boolean) S S)))
      [5] patternMatch: not known that (SetCategory) is of mode (CATEGORY domain (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE coerce (S S)) (SIGNATURE exquo ((Union S failed) S S)) (SIGNATURE unitNormal ((Record (: unit S) (: canonical S) (: associate S)) S)) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE euclideanSize ((NonNegativeInteger) S)) (SIGNATURE divide ((Record (: quotient S) (: remainder S)) S S)) (SIGNATURE quo (S S S)) (SIGNATURE rem (S S S)) (SIGNATURE inv (S S)) (SIGNATURE ** (S S (Integer))) (SIGNATURE * (S S (Fraction (Integer)))) (SIGNATURE * (S (Fraction (Integer)) S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE < ((Boolean) S S)) (SIGNATURE convert ((InputForm) S)) (SIGNATURE convert ((Complex (DoubleFloat)) S)) (SIGNATURE convert ((Complex (Float)) S)) (SIGNATURE tan (S S)) (SIGNATURE sin (S S)) (SIGNATURE cos (S S)) (SIGNATURE acos (S S)) (SIGNATURE asin (S S)) (SIGNATURE atan (S S)) (SIGNATURE cosh (S S)) (SIGNATURE sinh (S S)) (SIGNATURE tanh (S S)) (SIGNATURE acosh (S S)) (SIGNATURE asinh (S S)) (SIGNATURE atanh (S S)) (SIGNATURE log (S S)) (SIGNATURE exp (S S)) (SIGNATURE ** (S S S)) (SIGNATURE pi (S)) (SIGNATURE ** (S S (Fraction (Integer)))) (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE rationalIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE rational ((Fraction (Integer)) S)) (SIGNATURE rational? ((Boolean) S)) (SIGNATURE polarCoordinates ((Record (: r R) (: phi R)) S)) (SIGNATURE argument (R S)) (SIGNATURE abs (S S)) (SIGNATURE exquo ((Union S failed) S R)) (SIGNATURE conjugate (S S)) (SIGNATURE imaginary (S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE patternMatch ((PatternMatchResult (Float) S) S (Pattern (Float)) (PatternMatchResult (Float) S))) (SIGNATURE patternMatch ((PatternMatchResult (Integer) S) S (Pattern (Integer)) (PatternMatchResult (Integer) S))) (SIGNATURE map (S (Mapping R R) S)) (SIGNATURE differentiate (S S (Mapping R R))) (SIGNATURE differentiate (S S (Mapping R R) (NonNegativeInteger))) (SIGNATURE reduce ((Union S failed) (Fraction (SparseUnivariatePolynomial R)))) (SIGNATURE lift ((SparseUnivariatePolynomial R) S)) (SIGNATURE convert (S (SparseUnivariatePolynomial R))) (SIGNATURE reduce (S (SparseUnivariatePolynomial R))) (SIGNATURE definingPolynomial ((SparseUnivariatePolynomial R))) (SIGNATURE reducedSystem ((Matrix R) (Matrix S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix R)) (: vec (Vector R))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix S))) (SIGNATURE retract (R S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Integer) S)) (SIGNATURE convert ((SparseUnivariatePolynomial R) S)) (SIGNATURE discriminant (R)) (SIGNATURE convert (S (Vector R))) (SIGNATURE convert ((Vector R) S)) (SIGNATURE coordinates ((Matrix R) (Vector S))) (SIGNATURE coordinates ((Vector R) S)) (SIGNATURE minimalPolynomial ((SparseUnivariatePolynomial R) S)) (SIGNATURE characteristicPolynomial ((SparseUnivariatePolynomial R) S)) (SIGNATURE discriminant (R (Vector S))) (SIGNATURE coordinates ((Matrix R) (Vector S) (Vector S))) (SIGNATURE coordinates ((Vector R) S (Vector S))) (SIGNATURE norm (R S)) (SIGNATURE trace (R S)) (SIGNATURE rank ((PositiveInteger))) (SIGNATURE coerce (S R)) (SIGNATURE * (S R S)) (SIGNATURE * (S S R)) (SIGNATURE coerce (S (Integer))) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE ** (S S (NonNegativeInteger))) (SIGNATURE recip ((Union S failed) S)) (SIGNATURE * (S S S)) (SIGNATURE ** (S S (PositiveInteger))) (SIGNATURE * (S (Integer) S)) (SIGNATURE - (S S S)) (SIGNATURE - (S S)) (SIGNATURE * (S (NonNegativeInteger) S)) (SIGNATURE * (S (PositiveInteger) S)) (SIGNATURE + (S S S)) (SIGNATURE coerce ((OutputForm) S)) (SIGNATURE = ((Boolean) S S)))

============================================================================

   finalizing nrlib COMPCAT 
; (DEFUN |ComplexCategory| ...) is being compiled.
;; The variable |ComplexCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |ComplexCategory;| ...) is being compiled.
;; The variable |ComplexCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib DRAWCFUN 
   Warnings: 
      [1] drawPlot:  brans has no value
      [2] drawPlot:  xValues has no value
      [3] drawPlot:  yValues has no value
      [4] draw:  fcn has no value
      [5] makeObject:  fcn has no value
      [6] makeObject:  pointsColored? has no value
      [7] makeObject:  col2 has no value
      [8] makeObject:  col3 has no value

============================================================================

   finalizing nrlib DRAWCFUN 
; (DEFUN |DRAWCFUN;myTrap1| ...) is being compiled.
;; The variable |$numericFailure| is undefined.
;; The compiler will assume this variable is a global.

--------------non extending category----------------------
.. d01anfAnnaType of cat 
(|NumericalIntegrationCategory|)   has no 
============================================================================

(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib D01ANFA 

--------------non extending category----------------------
.. d01asfAnnaType of cat 
(|NumericalIntegrationCategory|)   has no 
============================================================================

(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib D01ASFA 

============================================================================

   finalizing nrlib D03AGNT 
--->/research2/test0819/mnt/fedora5/../../src/algebra/D03AGNT.spad-->d03AgentsPackage(constructor): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/D03AGNT.spad-->d03AgentsPackage(): Missing Description

============================================================================

   finalizing nrlib EP 
   Warnings: 
      [1] not known that (SIGNATURE variable ((Union $ failed) (Symbol))) is of mode (CATEGORY domain (SIGNATURE new ($)) (SIGNATURE new ($ $)) (SIGNATURE resetNew ((Void))) (SIGNATURE coerce ($ (String))) (SIGNATURE name ($ $)) (SIGNATURE scripted? ((Boolean) $)) (SIGNATURE scripts ((Record (: sub (List (OutputForm))) (: sup (List (OutputForm))) (: presup (List (OutputForm))) (: presub (List (OutputForm))) (: args (List (OutputForm)))) $)) (SIGNATURE script ($ $ (List (List (OutputForm))))) (SIGNATURE script ($ $ (Record (: sub (List (OutputForm))) (: sup (List (OutputForm))) (: presup (List (OutputForm))) (: presub (List (OutputForm))) (: args (List (OutputForm)))))) (SIGNATURE subscript ($ $ (List (OutputForm)))) (SIGNATURE superscript ($ $ (List (OutputForm)))) (SIGNATURE argscript ($ $ (List (OutputForm)))) (SIGNATURE elt ($ $ (List (OutputForm)))) (SIGNATURE string ((String) $)) (SIGNATURE list ((List $) $)) (SIGNATURE sample ($) constant))
      [2] charpol: :(PositiveInteger) -- should replace by pretend
      [3] eigenvalues:  lrat has no value
      [4] eigenvalues:  lsym has no value
      [5] intAlgEig: not known that (Ring) is of mode (CATEGORY package (SIGNATURE characteristicPolynomial ((Polynomial R) (Matrix (Fraction (Polynomial R))) (Symbol))) (SIGNATURE characteristicPolynomial ((Polynomial R) (Matrix (Fraction (Polynomial R))))) (SIGNATURE eigenvalues ((List (Union (Fraction (Polynomial R)) (SuchThat (Symbol) (Polynomial R)))) (Matrix (Fraction (Polynomial R))))) (SIGNATURE eigenvector ((List (Matrix (Fraction (Polynomial R)))) (Union (Fraction (Polynomial R)) (SuchThat (Symbol) (Polynomial R))) (Matrix (Fraction (Polynomial R))))) (SIGNATURE generalizedEigenvector ((List (Matrix (Fraction (Polynomial R)))) (Union (Fraction (Polynomial R)) (SuchThat (Symbol) (Polynomial R))) (Matrix (Fraction (Polynomial R))) (NonNegativeInteger) (NonNegativeInteger))) (SIGNATURE generalizedEigenvector ((List (Matrix (Fraction (Polynomial R)))) (Record (: eigval (Union (Fraction (Polynomial R)) (SuchThat (Symbol) (Polynomial R)))) (: eigmult (NonNegativeInteger)) (: eigvec (List (Matrix (Fraction (Polynomial R)))))) (Matrix (Fraction (Polynomial R))))) (SIGNATURE generalizedEigenvectors ((List (Record (: eigval (Union (Fraction (Polynomial R)) (SuchThat (Symbol) (Polynomial R)))) (: geneigvec (List (Matrix (Fraction (Polynomial R))))))) (Matrix (Fraction (Polynomial R))))) (SIGNATURE eigenvectors ((List (Record (: eigval (Union (Fraction (Polynomial R)) (SuchThat (Symbol) (Polynomial R)))) (: eigmult (NonNegativeInteger)) (: eigvec (List (Matrix (Fraction (Polynomial R))))))) (Matrix (Fraction (Polynomial R))))))
      [6] eigenvectors:  ratSol has no value
      [7] eigenvectors:  algSol has no value

============================================================================

   finalizing nrlib E04AGNT 
   Warnings: 
      [1] optAttributes:  noa has no value
      [2] optAttributes:  lsa has no value
      [3] optAttributes:  s has no value

============================================================================

   finalizing nrlib E04AGNT 
--->/research2/test0819/mnt/fedora5/../../src/algebra/E04AGNT.spad-->e04AgentsPackage(constructor): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/E04AGNT.spad-->e04AgentsPackage(): Missing Description

--------------non extending category----------------------
.. FortranExpression(#1,#2,#3) of cat 
(|Join| (|ExpressionSpace|) (|Algebra| |#3|) (|RetractableTo| |#3|) (|PartialDifferentialRing| (|Symbol|)) (CATEGORY |domain| (SIGNATURE |retract| ($ (|Expression| |#3|))) (SIGNATURE |retractIfCan| ((|Union| $ "failed") (|Expression| |#3|))) (SIGNATURE |retract| ($ (|Symbol|))) (SIGNATURE |retractIfCan| ((|Union| $ "failed") (|Symbol|))) (SIGNATURE |coerce| ((|Expression| |#3|) $)) (IF (|has| |#3| (|RetractableTo| (|Integer|))) (PROGN (SIGNATURE |retract| ($ (|Expression| (|Integer|)))) (SIGNATURE |retractIfCan| ((|Union| $ "failed") (|Expression| (|Integer|)))) (SIGNATURE |retract| ($ (|Fraction| (|Polynomial| (|Integer|))))) (SIGNATURE |retractIfCan| ((|Union| $ "failed") (|Fraction| (|Polynomial| (|Integer|))))) (SIGNATURE |retract| ($ (|Polynomial| (|Integer|)))) (SIGNATURE |retractIfCan| ((|Union| $ "failed") (|Polynomial| (|Integer|))))) |noBranch|) (IF (|has| |#3| (|RetractableTo| (|Float|))) (PROGN (SIGNATURE |retract| ($ (|Expression| (|Float|)))) (SIGNATURE |retractIfCan| ((|Union| $ "failed") (|Expression| (|Float|)))) (SIGNATURE |retract| ($ (|Fraction| (|Polynomial| (|Float|))))) (SIGNATURE |retractIfCan| ((|Union| $ "failed") (|Fraction| (|Polynomial| (|Float|))))) (SIGNATURE |retract| ($ (|Polynomial| (|Float|)))) (SIGNATURE |retractIfCan| ((|Union| $ "failed") (|Polynomial| (|Float|))))) |noBranch|) (SIGNATURE |abs| ($ $)) (SIGNATURE |sqrt| ($ $)) (SIGNATURE |exp| ($ $)) (SIGNATURE |log| ($ $)) (SIGNATURE |log10| ($ $)) (SIGNATURE |sin| ($ $)) (SIGNATURE |cos| ($ $)) (SIGNATURE |tan| ($ $)) (SIGNATURE |asin| ($ $)) (SIGNATURE |acos| ($ $)) (SIGNATURE |atan| ($ $)) (SIGNATURE |sinh| ($ $)) (SIGNATURE |cosh| ($ $)) (SIGNATURE |tanh| ($ $)) (SIGNATURE |pi| ($)) (SIGNATURE |variables| ((|List| (|Symbol|)) $)) (SIGNATURE |useNagFunctions| ((|Boolean|))) (SIGNATURE |useNagFunctions| ((|Boolean|) (|Boolean|)))))   has no 
============================================================================

(|FunctionSpace| |#3|)    finalizing nrlib FEXPR 

============================================================================

   finalizing nrlib FEXPR 
   Warnings: 
      [1] checkSymbols:  IN has no value
      [2] checkForNagOperators:  X01AAF has no value
      [3] pi:  X01AAF has no value

============================================================================

   finalizing nrlib FFCAT- 
   Warnings: 
      [1] rationalPoint?: not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE rationalPoints ((List (List F)))) (SIGNATURE nonSingularModel ((List (Polynomial F)) (Symbol))) (SIGNATURE algSplitSimple ((Record (: num S) (: den UP) (: derivden UP) (: gd UP)) S (Mapping UP UP))) (SIGNATURE hyperelliptic ((Union UP failed))) (SIGNATURE elliptic ((Union UP failed))) (SIGNATURE elt (F S F F)) (SIGNATURE primitivePart (S S)) (SIGNATURE represents (S (Vector UP) UP)) (SIGNATURE differentiate (S S (Mapping UP UP))) (SIGNATURE integral? ((Boolean) S UP)) (SIGNATURE integral? ((Boolean) S F)) (SIGNATURE yCoordinates ((Record (: num (Vector UP)) (: den UP)) S)) (SIGNATURE reduceBasisAtInfinity ((Vector S) (Vector S))) (SIGNATURE normalizeAtInfinity ((Vector S) (Vector S))) (SIGNATURE complementaryBasis ((Vector S) (Vector S))) (SIGNATURE integral? ((Boolean) S)) (SIGNATURE integralAtInfinity? ((Boolean) S)) (SIGNATURE rationalPoint? ((Boolean) F F)) (SIGNATURE absolutelyIrreducible? ((Boolean))) (SIGNATURE genus ((NonNegativeInteger))) (SIGNATURE numberOfComponents ((NonNegativeInteger))) (SIGNATURE differentiate (S S (Mapping (Fraction UP) (Fraction UP)))) (SIGNATURE differentiate (S S (Mapping (Fraction UP) (Fraction UP)) (NonNegativeInteger))) (SIGNATURE represents (S (Vector (Fraction UP)))) (SIGNATURE represents (S (Vector (Fraction UP)) (Vector S))))
      [2] primitivePart:  STEP has no value
      [3] primitivePart:  i has no value
      [4] repOrder:  nostart has no value
      [5] kmin:  nostart has no value
      [6] kmin:  k has no value
      [7] integral?:  den has no value

============================================================================

   finalizing nrlib FFCAT 
; (DEFUN |FunctionFieldCategory| ...) is being compiled.
;; The variable |FunctionFieldCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |FunctionFieldCategory;| ...) is being compiled.
;; The variable |FunctionFieldCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FFCGP 
   Warnings: 
      [1] pretend(NonNegativeInteger) -- should replace by @
      [2] +: pretend(SingleInteger) -- should replace by @
      [3] +: pretendRep -- should replace by @
      [4] retractIfCan: pretendRep -- should replace by @
      [5] inGroundField?: pretendRep -- should replace by @
      [6] -: pretendRep -- should replace by @
      [7] extensionDegree: signature of lhs not unique: (PositiveInteger) chosen
      [8] unknown Functor code (error field too large for this representation)

============================================================================

   finalizing nrlib FFNBP 
   Warnings: 
      [1] degree: signature of lhs not unique: (PositiveInteger)$ chosen
      [2] coerce:  l has no value
      [3] initializeLog:  n has no value
      [4] extensionDegree: signature of lhs not unique: (PositiveInteger) chosen

============================================================================

   finalizing nrlib FFP 
   Warnings: 
      [1] degree: signature of lhs not unique: (PositiveInteger)$ chosen
      [2] tableForDiscreteLogarithm: pretend(Table (PositiveInteger) (NonNegativeInteger)) -- should replace by @
      [3] initializeLog:  n has no value
      [4] extensionDegree: signature of lhs not unique: (PositiveInteger) chosen

============================================================================

   finalizing nrlib FLOAT 
   Warnings: 
      [1] OMwrite: pretend(String) -- should replace by @
      [2] cos:  s has no value
      [3] exp:  e1 has no value
      [4] exp1:  E has no value
      [5] normalize:  e has no value
      [6] power:  y has no value
      [7] power10:  y has no value

============================================================================

   finalizing nrlib FPARFRAC 
   Warnings: 
      [1] fullPartialFraction: not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE + ($ UP $)) (SIGNATURE fullPartialFraction ($ (Fraction UP))) (SIGNATURE polyPart (UP $)) (SIGNATURE fracPart ((List (Record (: exponent (NonNegativeInteger)) (: center UP) (: num UP))) $)) (SIGNATURE construct ($ (List (Record (: exponent (NonNegativeInteger)) (: center UP) (: num UP))))) (SIGNATURE differentiate ($ $)) (SIGNATURE D ($ $)) (SIGNATURE differentiate ($ $ (NonNegativeInteger))) (SIGNATURE D ($ $ (NonNegativeInteger))))
      [2] fullParFrac:  ans has no value

============================================================================

   finalizing nrlib FPARFRAC 
--->/research2/test0819/mnt/fedora5/../../src/algebra/FPARFRAC.spad-->FullPartialFractionExpansion((fullPartialFraction ($ RF))): Unexpected HT command: \sum_
--->/research2/test0819/mnt/fedora5/../../src/algebra/FPARFRAC.spad-->FullPartialFractionExpansion((fullPartialFraction ($ RF))): Unexpected HT command: \sum_
"\\spad{fullPartialFraction(f)} returns \\spad{[p,{} [[j,{} Dj,{} Hj]...]]} such that \\spad{f = p(x) + \\sum_{[j,{}Dj,{}Hj] in l} \\sum_{Dj(a)=0} Hj(a)/(x - a)\\^j}."

============================================================================

   finalizing nrlib FR 
   Warnings: 
      [1] zero?:  fctr has no value
      [2] eval:  IN has no value
      [3] eval:  e has no value
      [4] convert:  fctr has no value
      [5] convert:  xpnt has no value
      [6] exquo:  associate has no value
      [7] exquo:  goodQuotient has no value

============================================================================

   finalizing nrlib FRNAALG- 
   Warnings: 
      [1] leftRankPolynomial:  xx has no value
      [2] rightRankPolynomial:  xx has no value
      [3] coordinates: signature of lhs not unique: (Matrix R)(Vector S) chosen

============================================================================

   finalizing nrlib FRNAALG- 
; (DEFUN |FRNAALG-;leftRankPolynomial;Sup;1| ...) is being compiled.
;; The variable |xx| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FRNAALG 
; (DEFUN |FramedNonAssociativeAlgebra| ...) is being compiled.
;; The variable |FramedNonAssociativeAlgebra;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |FramedNonAssociativeAlgebra;| ...) is being compiled.
;; The variable |FramedNonAssociativeAlgebra;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FS- 
   Warnings: 
      [1] coerce: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE * (S (PositiveInteger) S)) (SIGNATURE * (S (NonNegativeInteger) S)) (SIGNATURE * (S (Integer) S)) (SIGNATURE * (S S S)) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE coerce (S (Integer))) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE convert ((InputForm) S)) (SIGNATURE retract ((Polynomial R) S)) (SIGNATURE retractIfCan ((Union (Polynomial R) failed) S)) (SIGNATURE coerce (S (Polynomial R))) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE * (S S R)) (SIGNATURE * (S R S)) (SIGNATURE coerce (S S)) (SIGNATURE * (S S (Fraction (Integer)))) (SIGNATURE * (S (Fraction (Integer)) S)) (SIGNATURE retract ((Fraction (Polynomial R)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Polynomial R)) failed) S)) (SIGNATURE coerce (S (Fraction (Polynomial R)))) (SIGNATURE univariate ((Fraction (SparseUnivariatePolynomial S)) S (Kernel S))) (SIGNATURE coerce (S (Fraction (Polynomial (Fraction R))))) (SIGNATURE coerce (S (Polynomial (Fraction R)))) (SIGNATURE coerce (S (Fraction R))) (SIGNATURE denominator (S S)) (SIGNATURE convert (S (Factored S))) (SIGNATURE eval (S S (Symbol) (NonNegativeInteger) (Mapping S S))) (SIGNATURE eval (S S (Symbol) (NonNegativeInteger) (Mapping S (List S)))) (SIGNATURE eval (S S (List (Symbol)) (List (NonNegativeInteger)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (Symbol)) (List (NonNegativeInteger)) (List (Mapping S S)))) (SIGNATURE isPower ((Union (Record (: val S) (: exponent (Integer))) failed) S)) (SIGNATURE isExpt ((Union (Record (: var (Kernel S)) (: exponent (Integer))) failed) S (Symbol))) (SIGNATURE isExpt ((Union (Record (: var (Kernel S)) (: exponent (Integer))) failed) S (BasicOperator))) (SIGNATURE numerator (S S)) (SIGNATURE coerce (S (SparseMultivariatePolynomial R (Kernel S)))) (SIGNATURE isMult ((Union (Record (: coef (Integer)) (: var (Kernel S))) failed) S)) (SIGNATURE isPlus ((Union (List S) failed) S)) (SIGNATURE isExpt ((Union (Record (: var (Kernel S)) (: exponent (Integer))) failed) S)) (SIGNATURE isTimes ((Union (List S) failed) S)) (SIGNATURE eval (S S (List (BasicOperator)) (List S) (Symbol))) (SIGNATURE eval (S S (BasicOperator) S (Symbol))) (SIGNATURE eval (S S)) (SIGNATURE eval (S S (List (Symbol)))) (SIGNATURE eval (S S (Symbol))) (SIGNATURE applyQuote (S (Symbol) (List S))) (SIGNATURE applyQuote (S (Symbol) S S S S)) (SIGNATURE applyQuote (S (Symbol) S S S)) (SIGNATURE applyQuote (S (Symbol) S S)) (SIGNATURE applyQuote (S (Symbol) S)) (SIGNATURE variables ((List (Symbol)) S)) (SIGNATURE ground (R S)) (SIGNATURE ground? ((Boolean) S)) (SIGNATURE retract (R S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE coerce (S R)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Integer) S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE retract ((Symbol) S)) (SIGNATURE retractIfCan ((Union (Symbol) failed) S)) (SIGNATURE coerce (S (Symbol))) (SIGNATURE eval (S S (BasicOperator) (Mapping S S))) (SIGNATURE eval (S S (BasicOperator) (Mapping S (List S)))) (SIGNATURE eval (S S (List (BasicOperator)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (BasicOperator)) (List (Mapping S S)))) (SIGNATURE eval (S S (Symbol) (Mapping S S))) (SIGNATURE eval (S S (Symbol) (Mapping S (List S)))) (SIGNATURE eval (S S (List (Symbol)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (Symbol)) (List (Mapping S S)))) (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE kernels ((List (Kernel S)) S)) (SIGNATURE mainKernel ((Union (Kernel S) failed) S)) (SIGNATURE subst (S S (List (Kernel S)) (List S))) (SIGNATURE subst (S S (List (Equation S)))) (SIGNATURE subst (S S (Equation S))) (SIGNATURE elt (S (BasicOperator) (List S))) (SIGNATURE elt (S (BasicOperator) S S S S)) (SIGNATURE elt (S (BasicOperator) S S S)) (SIGNATURE elt (S (BasicOperator) S S)) (SIGNATURE elt (S (BasicOperator) S)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE eval (S S (List (Kernel S)) (List S))) (SIGNATURE eval (S S (Kernel S) S)) (SIGNATURE retract ((Kernel S) S)) (SIGNATURE retractIfCan ((Union (Kernel S) failed) S)) (SIGNATURE coerce (S (Kernel S))) (SIGNATURE coerce ((OutputForm) S)))
      [2] subs:  IN has no value
      [3] subs:  x has no value
      [4] variables: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE * (S (PositiveInteger) S)) (SIGNATURE * (S (NonNegativeInteger) S)) (SIGNATURE * (S (Integer) S)) (SIGNATURE * (S S S)) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE coerce (S (Integer))) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE convert ((InputForm) S)) (SIGNATURE retract ((Polynomial R) S)) (SIGNATURE retractIfCan ((Union (Polynomial R) failed) S)) (SIGNATURE coerce (S (Polynomial R))) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE * (S S R)) (SIGNATURE * (S R S)) (SIGNATURE coerce (S S)) (SIGNATURE * (S S (Fraction (Integer)))) (SIGNATURE * (S (Fraction (Integer)) S)) (SIGNATURE retract ((Fraction (Polynomial R)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Polynomial R)) failed) S)) (SIGNATURE coerce (S (Fraction (Polynomial R)))) (SIGNATURE univariate ((Fraction (SparseUnivariatePolynomial S)) S (Kernel S))) (SIGNATURE coerce (S (Fraction (Polynomial (Fraction R))))) (SIGNATURE coerce (S (Polynomial (Fraction R)))) (SIGNATURE coerce (S (Fraction R))) (SIGNATURE denominator (S S)) (SIGNATURE convert (S (Factored S))) (SIGNATURE eval (S S (Symbol) (NonNegativeInteger) (Mapping S S))) (SIGNATURE eval (S S (Symbol) (NonNegativeInteger) (Mapping S (List S)))) (SIGNATURE eval (S S (List (Symbol)) (List (NonNegativeInteger)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (Symbol)) (List (NonNegativeInteger)) (List (Mapping S S)))) (SIGNATURE isPower ((Union (Record (: val S) (: exponent (Integer))) failed) S)) (SIGNATURE isExpt ((Union (Record (: var (Kernel S)) (: exponent (Integer))) failed) S (Symbol))) (SIGNATURE isExpt ((Union (Record (: var (Kernel S)) (: exponent (Integer))) failed) S (BasicOperator))) (SIGNATURE numerator (S S)) (SIGNATURE coerce (S (SparseMultivariatePolynomial R (Kernel S)))) (SIGNATURE isMult ((Union (Record (: coef (Integer)) (: var (Kernel S))) failed) S)) (SIGNATURE isPlus ((Union (List S) failed) S)) (SIGNATURE isExpt ((Union (Record (: var (Kernel S)) (: exponent (Integer))) failed) S)) (SIGNATURE isTimes ((Union (List S) failed) S)) (SIGNATURE eval (S S (List (BasicOperator)) (List S) (Symbol))) (SIGNATURE eval (S S (BasicOperator) S (Symbol))) (SIGNATURE eval (S S)) (SIGNATURE eval (S S (List (Symbol)))) (SIGNATURE eval (S S (Symbol))) (SIGNATURE applyQuote (S (Symbol) (List S))) (SIGNATURE applyQuote (S (Symbol) S S S S)) (SIGNATURE applyQuote (S (Symbol) S S S)) (SIGNATURE applyQuote (S (Symbol) S S)) (SIGNATURE applyQuote (S (Symbol) S)) (SIGNATURE variables ((List (Symbol)) S)) (SIGNATURE ground (R S)) (SIGNATURE ground? ((Boolean) S)) (SIGNATURE retract (R S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE coerce (S R)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Integer) S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE retract ((Symbol) S)) (SIGNATURE retractIfCan ((Union (Symbol) failed) S)) (SIGNATURE coerce (S (Symbol))) (SIGNATURE eval (S S (BasicOperator) (Mapping S S))) (SIGNATURE eval (S S (BasicOperator) (Mapping S (List S)))) (SIGNATURE eval (S S (List (BasicOperator)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (BasicOperator)) (List (Mapping S S)))) (SIGNATURE eval (S S (Symbol) (Mapping S S))) (SIGNATURE eval (S S (Symbol) (Mapping S (List S)))) (SIGNATURE eval (S S (List (Symbol)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (Symbol)) (List (Mapping S S)))) (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE kernels ((List (Kernel S)) S)) (SIGNATURE mainKernel ((Union (Kernel S) failed) S)) (SIGNATURE subst (S S (List (Kernel S)) (List S))) (SIGNATURE subst (S S (List (Equation S)))) (SIGNATURE subst (S S (Equation S))) (SIGNATURE elt (S (BasicOperator) (List S))) (SIGNATURE elt (S (BasicOperator) S S S S)) (SIGNATURE elt (S (BasicOperator) S S S)) (SIGNATURE elt (S (BasicOperator) S S)) (SIGNATURE elt (S (BasicOperator) S)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE eval (S S (List (Kernel S)) (List S))) (SIGNATURE eval (S S (Kernel S) S)) (SIGNATURE retract ((Kernel S) S)) (SIGNATURE retractIfCan ((Union (Kernel S) failed) S)) (SIGNATURE coerce (S (Kernel S))) (SIGNATURE coerce ((OutputForm) S)))
      [5] eval:  IN has no value
      [6] eval:  f has no value
      [7] smprep:  IN has no value
      [8] smprep:  a has no value
      [9] smprep: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE * (S (PositiveInteger) S)) (SIGNATURE * (S (NonNegativeInteger) S)) (SIGNATURE * (S (Integer) S)) (SIGNATURE * (S S S)) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE coerce (S (Integer))) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE convert ((InputForm) S)) (SIGNATURE retract ((Polynomial R) S)) (SIGNATURE retractIfCan ((Union (Polynomial R) failed) S)) (SIGNATURE coerce (S (Polynomial R))) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE * (S S R)) (SIGNATURE * (S R S)) (SIGNATURE coerce (S S)) (SIGNATURE * (S S (Fraction (Integer)))) (SIGNATURE * (S (Fraction (Integer)) S)) (SIGNATURE retract ((Fraction (Polynomial R)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Polynomial R)) failed) S)) (SIGNATURE coerce (S (Fraction (Polynomial R)))) (SIGNATURE univariate ((Fraction (SparseUnivariatePolynomial S)) S (Kernel S))) (SIGNATURE coerce (S (Fraction (Polynomial (Fraction R))))) (SIGNATURE coerce (S (Polynomial (Fraction R)))) (SIGNATURE coerce (S (Fraction R))) (SIGNATURE denominator (S S)) (SIGNATURE convert (S (Factored S))) (SIGNATURE eval (S S (Symbol) (NonNegativeInteger) (Mapping S S))) (SIGNATURE eval (S S (Symbol) (NonNegativeInteger) (Mapping S (List S)))) (SIGNATURE eval (S S (List (Symbol)) (List (NonNegativeInteger)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (Symbol)) (List (NonNegativeInteger)) (List (Mapping S S)))) (SIGNATURE isPower ((Union (Record (: val S) (: exponent (Integer))) failed) S)) (SIGNATURE isExpt ((Union (Record (: var (Kernel S)) (: exponent (Integer))) failed) S (Symbol))) (SIGNATURE isExpt ((Union (Record (: var (Kernel S)) (: exponent (Integer))) failed) S (BasicOperator))) (SIGNATURE numerator (S S)) (SIGNATURE coerce (S (SparseMultivariatePolynomial R (Kernel S)))) (SIGNATURE isMult ((Union (Record (: coef (Integer)) (: var (Kernel S))) failed) S)) (SIGNATURE isPlus ((Union (List S) failed) S)) (SIGNATURE isExpt ((Union (Record (: var (Kernel S)) (: exponent (Integer))) failed) S)) (SIGNATURE isTimes ((Union (List S) failed) S)) (SIGNATURE eval (S S (List (BasicOperator)) (List S) (Symbol))) (SIGNATURE eval (S S (BasicOperator) S (Symbol))) (SIGNATURE eval (S S)) (SIGNATURE eval (S S (List (Symbol)))) (SIGNATURE eval (S S (Symbol))) (SIGNATURE applyQuote (S (Symbol) (List S))) (SIGNATURE applyQuote (S (Symbol) S S S S)) (SIGNATURE applyQuote (S (Symbol) S S S)) (SIGNATURE applyQuote (S (Symbol) S S)) (SIGNATURE applyQuote (S (Symbol) S)) (SIGNATURE variables ((List (Symbol)) S)) (SIGNATURE ground (R S)) (SIGNATURE ground? ((Boolean) S)) (SIGNATURE retract (R S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE coerce (S R)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Integer) S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE retract ((Symbol) S)) (SIGNATURE retractIfCan ((Union (Symbol) failed) S)) (SIGNATURE coerce (S (Symbol))) (SIGNATURE eval (S S (BasicOperator) (Mapping S S))) (SIGNATURE eval (S S (BasicOperator) (Mapping S (List S)))) (SIGNATURE eval (S S (List (BasicOperator)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (BasicOperator)) (List (Mapping S S)))) (SIGNATURE eval (S S (Symbol) (Mapping S S))) (SIGNATURE eval (S S (Symbol) (Mapping S (List S)))) (SIGNATURE eval (S S (List (Symbol)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (Symbol)) (List (Mapping S S)))) (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE kernels ((List (Kernel S)) S)) (SIGNATURE mainKernel ((Union (Kernel S) failed) S)) (SIGNATURE subst (S S (List (Kernel S)) (List S))) (SIGNATURE subst (S S (List (Equation S)))) (SIGNATURE subst (S S (Equation S))) (SIGNATURE elt (S (BasicOperator) (List S))) (SIGNATURE elt (S (BasicOperator) S S S S)) (SIGNATURE elt (S (BasicOperator) S S S)) (SIGNATURE elt (S (BasicOperator) S S)) (SIGNATURE elt (S (BasicOperator) S)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE eval (S S (List (Kernel S)) (List S))) (SIGNATURE eval (S S (Kernel S) S)) (SIGNATURE retract ((Kernel S) S)) (SIGNATURE retractIfCan ((Union (Kernel S) failed) S)) (SIGNATURE coerce (S (Kernel S))) (SIGNATURE coerce ((OutputForm) S)))
      [10] diffdiff0:  ans has no value
      [11] diffEval:  k has no value
      [12] univariate: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE * (S (PositiveInteger) S)) (SIGNATURE * (S (NonNegativeInteger) S)) (SIGNATURE * (S (Integer) S)) (SIGNATURE * (S S S)) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE coerce (S (Integer))) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE convert ((InputForm) S)) (SIGNATURE retract ((Polynomial R) S)) (SIGNATURE retractIfCan ((Union (Polynomial R) failed) S)) (SIGNATURE coerce (S (Polynomial R))) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE * (S S R)) (SIGNATURE * (S R S)) (SIGNATURE coerce (S S)) (SIGNATURE * (S S (Fraction (Integer)))) (SIGNATURE * (S (Fraction (Integer)) S)) (SIGNATURE retract ((Fraction (Polynomial R)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Polynomial R)) failed) S)) (SIGNATURE coerce (S (Fraction (Polynomial R)))) (SIGNATURE univariate ((Fraction (SparseUnivariatePolynomial S)) S (Kernel S))) (SIGNATURE coerce (S (Fraction (Polynomial (Fraction R))))) (SIGNATURE coerce (S (Polynomial (Fraction R)))) (SIGNATURE coerce (S (Fraction R))) (SIGNATURE denominator (S S)) (SIGNATURE convert (S (Factored S))) (SIGNATURE eval (S S (Symbol) (NonNegativeInteger) (Mapping S S))) (SIGNATURE eval (S S (Symbol) (NonNegativeInteger) (Mapping S (List S)))) (SIGNATURE eval (S S (List (Symbol)) (List (NonNegativeInteger)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (Symbol)) (List (NonNegativeInteger)) (List (Mapping S S)))) (SIGNATURE isPower ((Union (Record (: val S) (: exponent (Integer))) failed) S)) (SIGNATURE isExpt ((Union (Record (: var (Kernel S)) (: exponent (Integer))) failed) S (Symbol))) (SIGNATURE isExpt ((Union (Record (: var (Kernel S)) (: exponent (Integer))) failed) S (BasicOperator))) (SIGNATURE numerator (S S)) (SIGNATURE coerce (S (SparseMultivariatePolynomial R (Kernel S)))) (SIGNATURE isMult ((Union (Record (: coef (Integer)) (: var (Kernel S))) failed) S)) (SIGNATURE isPlus ((Union (List S) failed) S)) (SIGNATURE isExpt ((Union (Record (: var (Kernel S)) (: exponent (Integer))) failed) S)) (SIGNATURE isTimes ((Union (List S) failed) S)) (SIGNATURE eval (S S (List (BasicOperator)) (List S) (Symbol))) (SIGNATURE eval (S S (BasicOperator) S (Symbol))) (SIGNATURE eval (S S)) (SIGNATURE eval (S S (List (Symbol)))) (SIGNATURE eval (S S (Symbol))) (SIGNATURE applyQuote (S (Symbol) (List S))) (SIGNATURE applyQuote (S (Symbol) S S S S)) (SIGNATURE applyQuote (S (Symbol) S S S)) (SIGNATURE applyQuote (S (Symbol) S S)) (SIGNATURE applyQuote (S (Symbol) S)) (SIGNATURE variables ((List (Symbol)) S)) (SIGNATURE ground (R S)) (SIGNATURE ground? ((Boolean) S)) (SIGNATURE retract (R S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE coerce (S R)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Integer) S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE retract ((Symbol) S)) (SIGNATURE retractIfCan ((Union (Symbol) failed) S)) (SIGNATURE coerce (S (Symbol))) (SIGNATURE eval (S S (BasicOperator) (Mapping S S))) (SIGNATURE eval (S S (BasicOperator) (Mapping S (List S)))) (SIGNATURE eval (S S (List (BasicOperator)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (BasicOperator)) (List (Mapping S S)))) (SIGNATURE eval (S S (Symbol) (Mapping S S))) (SIGNATURE eval (S S (Symbol) (Mapping S (List S)))) (SIGNATURE eval (S S (List (Symbol)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (Symbol)) (List (Mapping S S)))) (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE kernels ((List (Kernel S)) S)) (SIGNATURE mainKernel ((Union (Kernel S) failed) S)) (SIGNATURE subst (S S (List (Kernel S)) (List S))) (SIGNATURE subst (S S (List (Equation S)))) (SIGNATURE subst (S S (Equation S))) (SIGNATURE elt (S (BasicOperator) (List S))) (SIGNATURE elt (S (BasicOperator) S S S S)) (SIGNATURE elt (S (BasicOperator) S S S)) (SIGNATURE elt (S (BasicOperator) S S)) (SIGNATURE elt (S (BasicOperator) S)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE eval (S S (List (Kernel S)) (List S))) (SIGNATURE eval (S S (Kernel S) S)) (SIGNATURE retract ((Kernel S) S)) (SIGNATURE retractIfCan ((Union (Kernel S) failed) S)) (SIGNATURE coerce (S (Kernel S))) (SIGNATURE coerce ((OutputForm) S)))
      [13] convert: not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE * (S (PositiveInteger) S)) (SIGNATURE * (S (NonNegativeInteger) S)) (SIGNATURE * (S (Integer) S)) (SIGNATURE * (S S S)) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE coerce (S (Integer))) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE convert ((InputForm) S)) (SIGNATURE retract ((Polynomial R) S)) (SIGNATURE retractIfCan ((Union (Polynomial R) failed) S)) (SIGNATURE coerce (S (Polynomial R))) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE * (S S R)) (SIGNATURE * (S R S)) (SIGNATURE coerce (S S)) (SIGNATURE * (S S (Fraction (Integer)))) (SIGNATURE * (S (Fraction (Integer)) S)) (SIGNATURE retract ((Fraction (Polynomial R)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Polynomial R)) failed) S)) (SIGNATURE coerce (S (Fraction (Polynomial R)))) (SIGNATURE univariate ((Fraction (SparseUnivariatePolynomial S)) S (Kernel S))) (SIGNATURE coerce (S (Fraction (Polynomial (Fraction R))))) (SIGNATURE coerce (S (Polynomial (Fraction R)))) (SIGNATURE coerce (S (Fraction R))) (SIGNATURE denominator (S S)) (SIGNATURE convert (S (Factored S))) (SIGNATURE eval (S S (Symbol) (NonNegativeInteger) (Mapping S S))) (SIGNATURE eval (S S (Symbol) (NonNegativeInteger) (Mapping S (List S)))) (SIGNATURE eval (S S (List (Symbol)) (List (NonNegativeInteger)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (Symbol)) (List (NonNegativeInteger)) (List (Mapping S S)))) (SIGNATURE isPower ((Union (Record (: val S) (: exponent (Integer))) failed) S)) (SIGNATURE isExpt ((Union (Record (: var (Kernel S)) (: exponent (Integer))) failed) S (Symbol))) (SIGNATURE isExpt ((Union (Record (: var (Kernel S)) (: exponent (Integer))) failed) S (BasicOperator))) (SIGNATURE numerator (S S)) (SIGNATURE coerce (S (SparseMultivariatePolynomial R (Kernel S)))) (SIGNATURE isMult ((Union (Record (: coef (Integer)) (: var (Kernel S))) failed) S)) (SIGNATURE isPlus ((Union (List S) failed) S)) (SIGNATURE isExpt ((Union (Record (: var (Kernel S)) (: exponent (Integer))) failed) S)) (SIGNATURE isTimes ((Union (List S) failed) S)) (SIGNATURE eval (S S (List (BasicOperator)) (List S) (Symbol))) (SIGNATURE eval (S S (BasicOperator) S (Symbol))) (SIGNATURE eval (S S)) (SIGNATURE eval (S S (List (Symbol)))) (SIGNATURE eval (S S (Symbol))) (SIGNATURE applyQuote (S (Symbol) (List S))) (SIGNATURE applyQuote (S (Symbol) S S S S)) (SIGNATURE applyQuote (S (Symbol) S S S)) (SIGNATURE applyQuote (S (Symbol) S S)) (SIGNATURE applyQuote (S (Symbol) S)) (SIGNATURE variables ((List (Symbol)) S)) (SIGNATURE ground (R S)) (SIGNATURE ground? ((Boolean) S)) (SIGNATURE retract (R S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE coerce (S R)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Integer) S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE retract ((Symbol) S)) (SIGNATURE retractIfCan ((Union (Symbol) failed) S)) (SIGNATURE coerce (S (Symbol))) (SIGNATURE eval (S S (BasicOperator) (Mapping S S))) (SIGNATURE eval (S S (BasicOperator) (Mapping S (List S)))) (SIGNATURE eval (S S (List (BasicOperator)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (BasicOperator)) (List (Mapping S S)))) (SIGNATURE eval (S S (Symbol) (Mapping S S))) (SIGNATURE eval (S S (Symbol) (Mapping S (List S)))) (SIGNATURE eval (S S (List (Symbol)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (Symbol)) (List (Mapping S S)))) (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE kernels ((List (Kernel S)) S)) (SIGNATURE mainKernel ((Union (Kernel S) failed) S)) (SIGNATURE subst (S S (List (Kernel S)) (List S))) (SIGNATURE subst (S S (List (Equation S)))) (SIGNATURE subst (S S (Equation S))) (SIGNATURE elt (S (BasicOperator) (List S))) (SIGNATURE elt (S (BasicOperator) S S S S)) (SIGNATURE elt (S (BasicOperator) S S S)) (SIGNATURE elt (S (BasicOperator) S S)) (SIGNATURE elt (S (BasicOperator) S)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE eval (S S (List (Kernel S)) (List S))) (SIGNATURE eval (S S (Kernel S) S)) (SIGNATURE retract ((Kernel S) S)) (SIGNATURE retractIfCan ((Union (Kernel S) failed) S)) (SIGNATURE coerce (S (Kernel S))) (SIGNATURE coerce ((OutputForm) S)))

============================================================================

   finalizing nrlib FS 
; (DEFUN |FunctionSpace| ...) is being compiled.
;; The variable |FunctionSpace;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |FunctionSpace;| ...) is being compiled.
;; The variable |FunctionSpace;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FST 
   Warnings: 
      [1] coerce:  REAL has no value
      [2] coerce:  INTEGER has no value
      [3] coerce:  COMPLEX has no value
      [4] coerce:  CHARACTER has no value
      [5] coerce:  LOGICAL has no value
      [6] coerce:  real has no value
      [7] coerce:  integer has no value
      [8] coerce:  complex has no value
      [9] coerce:  character has no value
      [10] coerce:  logical has no value
      [11] coerce:  upperDoubleCOmplexSymbol has no value
 

============================================================================

   finalizing nrlib GDMP 
   Warnings: 
      [1] zero?: :Rep -- should replace by pretend
      [2] listCoef: :Rep -- should replace by pretend
      [3] numberOfMonomials: :Rep -- should replace by pretend
      [4] monomial?: :Rep -- should replace by pretend
      [5] maxNorm:  m has no value
      [6] variables: :(PositiveInteger) -- should replace by pretend
      [7] univariate:  deg has no value
      [8] coerce:  l has no value

--------------non extending category----------------------
.. GeneralDistributedMultivariatePolynomial(#1,#2,#3) of cat 
(|Join| (|PolynomialCategory| |#2| |#3| (|OrderedVariableList| |#1|)) (CATEGORY |domain| (SIGNATURE |reorder| ($ $ (|List| (|Integer|))))))   has no 
============================================================================

(IF (|has| |#2| (|IntegralDomain|)) (IF (|has| |#3| (|CancellationAbelianMonoid|)) (SIGNATURE |fmecg| ($ $ |#3| |#2| $)) |noBranch|) |noBranch|)    finalizing nrlib GDMP 

--------------non extending category----------------------
.. Pi of cat 
(|Join| (|Field|) (|CharacteristicZero|) (|RetractableTo| (|Integer|)) (|RetractableTo| (|Fraction| (|Integer|))) (|RealConstant|) (|CoercibleTo| (|DoubleFloat|)) (|CoercibleTo| (|Float|)) (|ConvertibleTo| (|Fraction| (|SparseUnivariatePolynomial| (|Integer|)))) (|ConvertibleTo| (|InputForm|)) (CATEGORY |domain| (SIGNATURE |pi| ($))))   has no 
============================================================================

(|QuotientFieldCategory| (|SparseUnivariatePolynomial| (|Integer|)))    finalizing nrlib HACKPI 

============================================================================

   finalizing nrlib HACKPI 
   Warnings: 
      [1] pi: pretend$ -- should replace by @

============================================================================

   finalizing nrlib IDEAL 
   Warnings: 
      [1] not known that (OrderedAbelianMonoidSup) is of mode (CATEGORY domain (IF (has (NonNegativeInteger) (Finite)) (IF (has Expon (Finite)) (ATTRIBUTE (Finite)) noBranch) noBranch) (IF (has (NonNegativeInteger) (Monoid)) (IF (has Expon (Monoid)) (ATTRIBUTE (Monoid)) noBranch) noBranch) (IF (has (NonNegativeInteger) (AbelianMonoid)) (IF (has Expon (AbelianMonoid)) (ATTRIBUTE (AbelianMonoid)) noBranch) noBranch) (IF (has (NonNegativeInteger) (CancellationAbelianMonoid)) (IF (has Expon (CancellationAbelianMonoid)) (ATTRIBUTE (CancellationAbelianMonoid)) noBranch) noBranch) (IF (has (NonNegativeInteger) (Group)) (IF (has Expon (Group)) (ATTRIBUTE (Group)) noBranch) noBranch) (IF (has (NonNegativeInteger) (AbelianGroup)) (IF (has Expon (AbelianGroup)) (ATTRIBUTE (AbelianGroup)) noBranch) noBranch) (IF (has (NonNegativeInteger) (OrderedAbelianMonoidSup)) (IF (has Expon (OrderedAbelianMonoidSup)) (ATTRIBUTE (OrderedAbelianMonoidSup)) noBranch) noBranch) (IF (has (NonNegativeInteger) (OrderedSet)) (IF (has Expon (OrderedSet)) (ATTRIBUTE (OrderedSet)) noBranch) noBranch) (SIGNATURE makeprod ($ (NonNegativeInteger) Expon)) (SIGNATURE selectfirst ((NonNegativeInteger) $)) (SIGNATURE selectsecond (Expon $)))
      [2] leadterm: not known that (Ring) is of mode (CATEGORY package (SIGNATURE * ($ $ $)) (SIGNATURE ** ($ $ (NonNegativeInteger))) (SIGNATURE + ($ $ $)) (SIGNATURE one? ((Boolean) $)) (SIGNATURE zero? ((Boolean) $)) (SIGNATURE element? ((Boolean) DPoly $)) (SIGNATURE in? ((Boolean) $ $)) (SIGNATURE inRadical? ((Boolean) DPoly $)) (SIGNATURE zeroDim? ((Boolean) $ (List VarSet))) (SIGNATURE zeroDim? ((Boolean) $)) (SIGNATURE intersect ($ $ $)) (SIGNATURE intersect ($ (List $))) (SIGNATURE quotient ($ $ $)) (SIGNATURE quotient ($ $ DPoly)) (SIGNATURE groebner ($ $)) (SIGNATURE generalPosition ((Record (: mval (Matrix F)) (: invmval (Matrix F)) (: genIdeal $)) $ (List VarSet))) (SIGNATURE backOldPos ($ (Record (: mval (Matrix F)) (: invmval (Matrix F)) (: genIdeal $)))) (SIGNATURE dimension ((Integer) $ (List VarSet))) (SIGNATURE dimension ((Integer) $)) (SIGNATURE leadingIdeal ($ $)) (SIGNATURE ideal ($ (List DPoly))) (SIGNATURE groebnerIdeal ($ (List DPoly))) (SIGNATURE groebner? ((Boolean) $)) (SIGNATURE generators ((List DPoly) $)) (SIGNATURE coerce ($ (List DPoly))) (SIGNATURE saturate ($ $ DPoly)) (SIGNATURE saturate ($ $ DPoly (List VarSet))) (IF (has VarSet (ConvertibleTo (Symbol))) (SIGNATURE relationsIdeal ((SuchThat (List (Polynomial F)) (List (Equation (Polynomial F)))) (List DPoly))) noBranch))
      [3] contractGrob: not known that (PolynomialCategory F newExpon VarSet) is of mode (CATEGORY domain (IF (has F (IntegralDomain)) (IF (has newExpon (CancellationAbelianMonoid)) (SIGNATURE fmecg ($ $ newExpon F $)) noBranch) noBranch) (IF (has F (ATTRIBUTE canonicalUnitNormal)) (ATTRIBUTE canonicalUnitNormal) noBranch))
      [4] monomDim:  monvar has no value
      [5] **: :(NonNegativeInteger) -- should replace by pretend
      [6] relationsIdeal: not known that (OrderedAbelianMonoid) is of mode (CATEGORY domain (IF (has Expon (Finite)) (IF (has DirP (Finite)) (ATTRIBUTE (Finite)) noBranch) noBranch) (IF (has Expon (Monoid)) (IF (has DirP (Monoid)) (ATTRIBUTE (Monoid)) noBranch) noBranch) (IF (has Expon (AbelianMonoid)) (IF (has DirP (AbelianMonoid)) (ATTRIBUTE (AbelianMonoid)) noBranch) noBranch) (IF (has Expon (CancellationAbelianMonoid)) (IF (has DirP (CancellationAbelianMonoid)) (ATTRIBUTE (CancellationAbelianMonoid)) noBranch) noBranch) (IF (has Expon (Group)) (IF (has DirP (Group)) (ATTRIBUTE (Group)) noBranch) noBranch) (IF (has Expon (AbelianGroup)) (IF (has DirP (AbelianGroup)) (ATTRIBUTE (AbelianGroup)) noBranch) noBranch) (IF (has Expon (OrderedAbelianMonoidSup)) (IF (has DirP (OrderedAbelianMonoidSup)) (ATTRIBUTE (OrderedAbelianMonoidSup)) noBranch) noBranch) (IF (has Expon (OrderedSet)) (IF (has DirP (OrderedSet)) (ATTRIBUTE (OrderedSet)) noBranch) noBranch) (SIGNATURE makeprod ($ Expon DirP)) (SIGNATURE selectfirst (Expon $)) (SIGNATURE selectsecond (DirP $)))
      [7] relationsIdeal: not known that (OrderedAbelianMonoidSup) is of mode (CATEGORY domain (IF (has Expon (Finite)) (IF (has DirP (Finite)) (ATTRIBUTE (Finite)) noBranch) noBranch) (IF (has Expon (Monoid)) (IF (has DirP (Monoid)) (ATTRIBUTE (Monoid)) noBranch) noBranch) (IF (has Expon (AbelianMonoid)) (IF (has DirP (AbelianMonoid)) (ATTRIBUTE (AbelianMonoid)) noBranch) noBranch) (IF (has Expon (CancellationAbelianMonoid)) (IF (has DirP (CancellationAbelianMonoid)) (ATTRIBUTE (CancellationAbelianMonoid)) noBranch) noBranch) (IF (has Expon (Group)) (IF (has DirP (Group)) (ATTRIBUTE (Group)) noBranch) noBranch) (IF (has Expon (AbelianGroup)) (IF (has DirP (AbelianGroup)) (ATTRIBUTE (AbelianGroup)) noBranch) noBranch) (IF (has Expon (OrderedAbelianMonoidSup)) (IF (has DirP (OrderedAbelianMonoidSup)) (ATTRIBUTE (OrderedAbelianMonoidSup)) noBranch) noBranch) (IF (has Expon (OrderedSet)) (IF (has DirP (OrderedSet)) (ATTRIBUTE (OrderedSet)) noBranch) noBranch) (SIGNATURE makeprod ($ Expon DirP)) (SIGNATURE selectfirst (Expon $)) (SIGNATURE selectsecond (DirP $)))
      [8] relationsIdeal: not known that (PolynomialCategory F nExponent VarSet1) is of mode (CATEGORY domain (IF (has F (IntegralDomain)) (IF (has nExponent (CancellationAbelianMonoid)) (SIGNATURE fmecg ($ $ nExponent F $)) noBranch) noBranch) (IF (has F (ATTRIBUTE canonicalUnitNormal)) (ATTRIBUTE canonicalUnitNormal) noBranch))
      [9] relationsIdeal: :(Vector (NonNegativeInteger)) -- should replace by pretend
      [10] relationsIdeal: The conditional modes (Polynomial F) and nPoly conflict

============================================================================

   finalizing nrlib INFORM 
   Warnings: 
      [1] conv: pretend$ -- should replace by @

============================================================================

   finalizing nrlib IR 
   Warnings: 
      [1] nesimp:  IN has no value
      [2] nesimp:  ne has no value

============================================================================

   finalizing nrlib ISUPS 
   Warnings: 
      [1] cSin:  %sin has no value
      [2] cCos:  %cos has no value
      [3] sinhcosh:  %sin has no value
      [4] sinhcosh:  %cos has no value
      [5] cSinh:  %sinh has no value
      [6] cCosh:  %cosh has no value

--------------non extending category----------------------
.. Library of cat 
(|Join| (|TableAggregate| (|String|) (|Any|)) (CATEGORY |domain| (SIGNATURE |library| ($ (|FileName|))) (SIGNATURE |pack!| ($ $)) (SIGNATURE |elt| ((|Any|) $ (|Symbol|))) (SIGNATURE |setelt| ((|Any|) $ (|Symbol|) (|Any|))) (SIGNATURE |close!| ($ $))))   has no 
============================================================================

(|FileCategory| (|FileName|) (|Record| (|:| |key| (|String|)) (|:| |entry| (|Any|))))    finalizing nrlib LIB 

============================================================================

   finalizing nrlib LMDICT 
--->/research2/test0819/mnt/fedora5/../../src/algebra/LMDICT.spad-->ListMultiDictionary(constructor): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/LMDICT.spad-->ListMultiDictionary(): Missing Description

============================================================================

   finalizing nrlib LODOOPS 
   Warnings: 
      [1] killer: not known that (Ring) is of mode (CATEGORY package (SIGNATURE symmetricProduct (L L L (Mapping A A))) (SIGNATURE symmetricPower (L L (NonNegativeInteger) (Mapping A A))) (SIGNATURE directSum (L L L (Mapping A A))))

============================================================================

   finalizing nrlib MATRIX 
   Warnings: 
      [1] positivePower: pretend(Matrix R) -- should replace by @
      [2] determinant: not known that (CommutativeRing) is of mode (CATEGORY R (ATTRIBUTE (commutative *)))

============================================================================

   finalizing nrlib MKFLCFN 
   Warnings: 
      [1] mkLisp: pretend(InputForm) -- should replace by @

============================================================================

   finalizing nrlib MKFLCFN 
; (DEFUN |MKFLCFN;mkDefun| ...) is being compiled.
;; The variable |$compileDontDefineFunctions| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib MSET 
   Warnings: 
      [1] intersect:  n has no value
      [2] difference:  n has no value

============================================================================

   finalizing nrlib M3D 
   Warnings: 
      [1] matrixConcat3D:  retVal has no value

--------------non extending category----------------------
.. ThreeDimensionalMatrix #1 of cat 
(|Join| (|HomogeneousAggregate| |#1|) (CATEGORY |domain| (IF (|has| |#1| (|Ring|)) (PROGN (SIGNATURE |zeroMatrix| ($ (|NonNegativeInteger|) (|NonNegativeInteger|) (|NonNegativeInteger|))) (SIGNATURE |identityMatrix| ($ (|NonNegativeInteger|))) (SIGNATURE |plus| ($ $ $))) |noBranch|) (SIGNATURE |construct| ($ (|List| (|List| (|List| |#1|))))) (SIGNATURE |elt| (|#1| $ (|NonNegativeInteger|) (|NonNegativeInteger|) (|NonNegativeInteger|))) (SIGNATURE |setelt!| (|#1| $ (|NonNegativeInteger|) (|NonNegativeInteger|) (|NonNegativeInteger|) |#1|)) (SIGNATURE |coerce| ($ (|PrimitiveArray| (|PrimitiveArray| (|PrimitiveArray| |#1|))))) (SIGNATURE |coerce| ((|PrimitiveArray| (|PrimitiveArray| (|PrimitiveArray| |#1|))) $)) (SIGNATURE |matrixConcat3D| ($ (|Symbol|) $ $)) (SIGNATURE |matrixDimensions| ((|Vector| (|NonNegativeInteger|)) $))))   has no 
============================================================================

(|OneDimensionalArrayAggregate| (|PrimitiveArray| (|PrimitiveArray| |#1|)))    finalizing nrlib M3D 

============================================================================

   finalizing nrlib NAGC02 
   Warnings: 
      [1] c02aff: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [2] c02agf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @

============================================================================

   finalizing nrlib NAGC05 
   Warnings: 
      [1] c05adf:  fn has no value
      [2] c05adf:  fp has no value
      [3] c05adf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [4] c05nbf:  fn has no value
      [5] c05nbf:  fp has no value
      [6] c05nbf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [7] c05pbf:  fn has no value
      [8] c05pbf:  fp has no value
      [9] c05pbf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @

============================================================================

   finalizing nrlib NAGC06 
   Warnings: 
      [1] c06eaf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [2] c06ebf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [3] c06ecf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [4] c06ekf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [5] c06fpf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [6] c06fqf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [7] c06frf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [8] c06fuf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [9] c06gbf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [10] c06gcf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [11] c06gqf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [12] c06gsf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @

============================================================================

   finalizing nrlib NAGD03 
   Warnings: 
      [1] d03edf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [2] d03eef:  fn has no value
      [3] d03eef:  fp has no value
      [4] d03eef: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [5] d03faf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @

============================================================================

   finalizing nrlib NAGE01 
   Warnings: 
      [1] e01baf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [2] e01bef: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [3] e01bff: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [4] e01bgf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [5] e01bhf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [6] e01daf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [7] e01saf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [8] e01sbf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [9] e01sef: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [10] e01sff: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @

============================================================================

   finalizing nrlib NAGE02 
   Warnings: 
      [1] e02adf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [2] e02aef: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [3] e02agf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [4] e02ahf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [5] e02ajf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [6] e02akf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [7] e02baf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [8] e02bbf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [9] e02bcf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [10] e02bdf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [11] e02bef: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [12] e02daf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [13] e02dcf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [14] e02ddf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [15] e02def: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [16] e02dff: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [17] e02gaf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [18] e02zaf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @

============================================================================

   finalizing nrlib NAGE04 
   Warnings: 
      [1] e04dgf:  fn has no value
      [2] e04dgf:  fp has no value
      [3] e04dgf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [4] e04fdf:  fn has no value
      [5] e04fdf:  fp has no value
      [6] e04fdf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [7] e04gcf:  fn has no value
      [8] e04gcf:  fp has no value
      [9] e04gcf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [10] e04jaf:  fn has no value
      [11] e04jaf:  fp has no value
      [12] e04jaf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [13] e04mbf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [14] e04naf:  fn has no value
      [15] e04naf:  fp has no value
      [16] e04naf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [17] e04ucf:  fn has no value
      [18] e04ucf:  fp has no value
      [19] e04ucf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [20] e04ycf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @

============================================================================

   finalizing nrlib NAGF07 
   Warnings: 
      [1] f07adf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [2] f07aef: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [3] f07fdf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [4] f07fef: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @

============================================================================

   finalizing nrlib NAGS 
   Warnings: 
      [1] s01eaf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [2] s13aaf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [3] s13acf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [4] s13adf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [5] s14aaf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [6] s14abf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [7] s14baf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [8] s15adf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [9] s15aef: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [10] s17acf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [11] s17adf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [12] s17aef: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [13] s17aff: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [14] s17agf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [15] s17ahf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [16] s17ajf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [17] s17akf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [18] s17dcf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [19] s17def: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [20] s17dgf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [21] s17dhf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [22] s17dlf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [23] s18acf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [24] s18adf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [25] s18aef: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [26] s18aff: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [27] s18dcf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [28] s18def: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [29] s19aaf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [30] s19abf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [31] s19acf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [32] s19adf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [33] s20acf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [34] s20adf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [35] s21baf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [36] s21bbf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [37] s21bcf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [38] s21bdf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @

============================================================================

   finalizing nrlib NAGSP 
   Warnings: 
      [1] getUniqueId:  uniqueId has no value

============================================================================

   finalizing nrlib NAGSP 
; (DEFUN |NAGSP;checkPrecision;B;1| ...) is being compiled.
;; The variable |$fortranPrecision| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$nagEnforceDouble| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$nagMessages| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NAGSP;fortranCompilerName;S;4| ...) is being compiled.
;; The variable |$fortranCompilerName| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NAGSP;fortranLinkerArgs;S;5| ...) is being compiled.
;; The variable |$fortranLibraries| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib NUMFMT 
   Warnings: 
      [1] ScanRoman:  nprens has no value

============================================================================

   finalizing nrlib OC 
; (DEFUN |OctonionCategory| ...) is being compiled.
;; The variable |OctonionCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |OctonionCategory;| ...) is being compiled.
;; The variable |OctonionCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib ODEPACK 
--->/research2/test0819/mnt/fedora5/../../src/algebra/ODEPACK.spad-->AnnaOrdinaryDifferentialEquationPackage(constructor): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/ODEPACK.spad-->AnnaOrdinaryDifferentialEquationPackage(): Missing Description

============================================================================

   finalizing nrlib ODERAT 
   Warnings: 
      [1] ratDsolve1: not known that (Ring) is of mode (CATEGORY package (SIGNATURE ratDsolve ((Record (: particular (Union (Fraction UP) failed)) (: basis (List (Fraction UP)))) (LinearOrdinaryDifferentialOperator1 (Fraction UP)) (Fraction UP))) (SIGNATURE ratDsolve ((Record (: basis (List (Fraction UP))) (: mat (Matrix F))) (LinearOrdinaryDifferentialOperator1 (Fraction UP)) (List (Fraction UP)))) (SIGNATURE ratDsolve ((Record (: particular (Union (Fraction UP) failed)) (: basis (List (Fraction UP)))) (LinearOrdinaryDifferentialOperator2 UP (Fraction UP)) (Fraction UP))) (SIGNATURE ratDsolve ((Record (: basis (List (Fraction UP))) (: mat (Matrix F))) (LinearOrdinaryDifferentialOperator2 UP (Fraction UP)) (List (Fraction UP)))) (SIGNATURE indicialEquationAtInfinity (UP (LinearOrdinaryDifferentialOperator1 (Fraction UP)))) (SIGNATURE indicialEquationAtInfinity (UP (LinearOrdinaryDifferentialOperator2 UP (Fraction UP)))))
      [2] ratDsolve0:  b has no value
      [3] infMuLambda:  lamb has no value
      [4] infMuLambda:  lf has no value

============================================================================

   finalizing nrlib OPTPACK 
   Warnings: 
      [1] constant:  noa has no value
      [2] measureSpecific:  noa has no value
      [3] measureSpecific:  lsa has no value
      [4] optimizeSpecific:  noa has no value
      [5] optimizeSpecific:  lsa has no value
      [6] goodnessOfFit:  lsa has no value
      [7] goodnessOfFit:  method has no value
      [8] goodnessOfFit:  nameOfRoutine has no value
      [9] goodnessOfFit:  w has no value
      [10] goodnessOfFit:  objf has no value

============================================================================

   finalizing nrlib OPTPACK 
--->/research2/test0819/mnt/fedora5/../../src/algebra/OPTPACK.spad-->AnnaNumericalOptimizationPackage(constructor): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/OPTPACK.spad-->AnnaNumericalOptimizationPackage(): Missing Description

============================================================================

   finalizing nrlib PATTERN 
   Warnings: 
      [1] quoted?:  sym has no value
      [2] generic?:  sym has no value
      [3] multiple?:  sym has no value
      [4] optional?:  sym has no value
      [5] =: pretend(Boolean) -- should replace by @
      [6] isOp:  ker has no value
      [7] variables:  exp has no value
      [8] variables:  qot has no value
      [9] variables:  ker has no value
      [10] PAT2O:  ret has no value
      [11] PAT2O:  sym has no value
      [12] PAT2O:  exp has no value
      [13] PAT2O:  qot has no value
      [14] PAT2O:  ker has no value
      [15] patcopy:  ret has no value
      [16] patcopy:  sym has no value
      [17] patcopy:  ker has no value
      [18] patcopy:  qot has no value
      [19] patcopy:  exp has no value
      [20] pateq?:  ret has no value
      [21] pateq?:  qot has no value
      [22] pateq?:  sym has no value
      [23] pateq?:  ker has no value
      [24] pateq?:  exp has no value

============================================================================

   finalizing nrlib PATTERN 
; (DEFUN |Pattern;| ...) is being compiled.
;; The variable IDENTITY is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib PMKERNEL 
   Warnings: 
      [1] patternMatchArg: not known that (SetCategory) is of mode (CATEGORY package (SIGNATURE patternMatch ((PatternMatchResult S E) (Kernel E) (Pattern S) (PatternMatchResult S E))))
      [2] patternMatchInner: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE patternMatch ((PatternMatchResult S E) (Kernel E) (Pattern S) (PatternMatchResult S E))))

============================================================================

   finalizing nrlib PRIMELT 
   Warnings: 
      [1] triangularLinearIfCan: not known that (Ring) is of mode (CATEGORY package (SIGNATURE primitiveElement ((Record (: coef1 (Integer)) (: coef2 (Integer)) (: prim (SparseUnivariatePolynomial F))) (Polynomial F) (Symbol) (Polynomial F) (Symbol))) (SIGNATURE primitiveElement ((Record (: coef (List (Integer))) (: poly (List (SparseUnivariatePolynomial F))) (: prim (SparseUnivariatePolynomial F))) (List (Polynomial F)) (List (Symbol)))) (SIGNATURE primitiveElement ((Record (: coef (List (Integer))) (: poly (List (SparseUnivariatePolynomial F))) (: prim (SparseUnivariatePolynomial F))) (List (Polynomial F)) (List (Symbol)) (Symbol))))

============================================================================

   finalizing nrlib QALGSET2 
   Warnings: 
      [1] npoly: not known that (PolynomialCategory (Fraction (Integer)) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl)) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [2] radicalSimplify: not known that (PolynomialCategory (Fraction (Integer)) (DirectProduct nv (NonNegativeInteger)) (OrderedVariableList vl)) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [3] radicalSimplify:  gb has no value

============================================================================

   finalizing nrlib REP1 
   Warnings: 
      [1] antisymmetricTensors: not known that (Ring) is of mode (CATEGORY R (ATTRIBUTE (commutative *)))

--------------non extending category----------------------
.. Result of cat 
(|Join| (|TableAggregate| (|Symbol|) (|Any|)) (CATEGORY |package| (SIGNATURE |showScalarValues| ((|Boolean|) (|Boolean|))) (SIGNATURE |showArrayValues| ((|Boolean|) (|Boolean|))) (ATTRIBUTE |finiteAggregate|)))   has no 
============================================================================

(ATTRIBUTE |finiteAggregate|)    finalizing nrlib RESULT 

============================================================================

   finalizing nrlib QUATCAT 
; (DEFUN |QuaternionCategory| ...) is being compiled.
;; The variable |QuaternionCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |QuaternionCategory;| ...) is being compiled.
;; The variable |QuaternionCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib RFFACT 
   Warnings: 
      [1] likuniv: not known that (Ring) is of mode (CATEGORY package (SIGNATURE factor ((Factored UP) UP)))

--------------non extending category----------------------
.. RectangularMatrix(#1,#2,#3) of cat 
(|Join| (|RectangularMatrixCategory| |#1| |#2| |#3| (|DirectProduct| |#2| |#3|) (|DirectProduct| |#1| |#3|)) (|CoercibleTo| (|Matrix| |#3|)) (CATEGORY |domain| (IF (|has| |#3| (|Field|)) (ATTRIBUTE (|VectorSpace| |#3|)) |noBranch|) (IF (|has| |#3| (|ConvertibleTo| (|InputForm|))) (ATTRIBUTE (|ConvertibleTo| (|InputForm|))) |noBranch|) (SIGNATURE |rectangularMatrix| ($ (|Matrix| |#3|))) (SIGNATURE |coerce| ((|Matrix| |#3|) $))))   has no 
============================================================================

(|MatrixCategory| |#3| (|Vector| |#3|) (|Vector| |#3|))    finalizing nrlib RMATRIX 

(|RealConstant|)    extends 
(|ConvertibleTo| (|DoubleFloat|))    but not 
(|ConvertibleTo| (|String|)) --------------non extending category----------------------
.. RomanNumeral of cat 
(|Join| (|IntegerNumberSystem|) (CATEGORY |domain| (ATTRIBUTE |canonical|) (ATTRIBUTE |canonicalsClosed|) (ATTRIBUTE |noetherian|) (SIGNATURE |convert| ($ (|Symbol|))) (SIGNATURE |roman| ($ (|Symbol|))) (SIGNATURE |roman| ($ (|Integer|)))))   has no 
============================================================================

(|ConvertibleTo| (|String|))    finalizing nrlib ROMAN 

--------------non extending category----------------------
.. RoutinesTable of cat 
(|Join| (|TableAggregate| (|Symbol|) (|Any|)) (CATEGORY |domain| (SIGNATURE |concat| ($ $ $)) (SIGNATURE |routines| ($)) (SIGNATURE |selectIntegrationRoutines| ($ $)) (SIGNATURE |selectOptimizationRoutines| ($ $)) (SIGNATURE |selectPDERoutines| ($ $)) (SIGNATURE |selectODEIVPRoutines| ($ $)) (SIGNATURE |selectFiniteRoutines| ($ $)) (SIGNATURE |selectSumOfSquaresRoutines| ($ $)) (SIGNATURE |selectNonFiniteRoutines| ($ $)) (SIGNATURE |selectMultiDimensionalRoutines| ($ $)) (SIGNATURE |changeThreshhold| ($ $ (|Symbol|) (|Float|))) (SIGNATURE |changeMeasure| ($ $ (|Symbol|) (|Float|))) (SIGNATURE |getMeasure| ((|Float|) $ (|Symbol|))) (SIGNATURE |getExplanations| ((|List| (|String|)) $ (|String|))) (SIGNATURE |deleteRoutine!| ($ $ (|Symbol|))) (SIGNATURE |showTheRoutinesTable| ($)) (SIGNATURE |recoverAfterFail| ((|Union| (|String|) "failed") $ (|String|) (|Integer|))) (ATTRIBUTE |finiteAggregate|)))    has no  showScalarValues : Boolean -> Boolean 

============================================================================

   finalizing nrlib RPOLCAT- 
   Warnings: 
      [1] mainCoefficients: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE coerce (S S)) (SIGNATURE gcd (S S S)) (SIGNATURE gcd (S (List S))) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE coerce ((Polynomial R) S)) (SIGNATURE convert ((Polynomial R) S)) (SIGNATURE convert ((String) S)) (SIGNATURE mainSquareFreePart (S S)) (SIGNATURE mainPrimitivePart (S S)) (SIGNATURE mainContent (S S)) (SIGNATURE primitivePart! (S S)) (SIGNATURE gcd (R R S)) (SIGNATURE exactQuotient! (S S S)) (SIGNATURE exactQuotient (S S S)) (SIGNATURE exactQuotient! (S S R)) (SIGNATURE exactQuotient (S S R)) (SIGNATURE primPartElseUnitCanonical! (S S)) (SIGNATURE primPartElseUnitCanonical (S S)) (SIGNATURE convert (S (Polynomial R))) (SIGNATURE retract (S (Polynomial R))) (SIGNATURE retractIfCan ((Union S failed) (Polynomial R))) (SIGNATURE convert (S (Polynomial (Integer)))) (SIGNATURE retract (S (Polynomial (Integer)))) (SIGNATURE retractIfCan ((Union S failed) (Polynomial (Integer)))) (SIGNATURE convert (S (Polynomial (Fraction (Integer))))) (SIGNATURE retract (S (Polynomial (Fraction (Integer))))) (SIGNATURE retractIfCan ((Union S failed) (Polynomial (Fraction (Integer))))) (SIGNATURE initiallyReduce (S S S)) (SIGNATURE headReduce (S S S)) (SIGNATURE lazyResidueClass ((Record (: polnum S) (: polden S) (: power (NonNegativeInteger))) S S)) (SIGNATURE monicModulo (S S S)) (SIGNATURE pseudoDivide ((Record (: quotient S) (: remainder S)) S S)) (SIGNATURE lazyPseudoDivide ((Record (: coef S) (: gap (NonNegativeInteger)) (: quotient S) (: remainder S)) S S V)) (SIGNATURE lazyPseudoDivide ((Record (: coef S) (: gap (NonNegativeInteger)) (: quotient S) (: remainder S)) S S)) (SIGNATURE lazyPremWithDefault ((Record (: coef S) (: gap (NonNegativeInteger)) (: remainder S)) S S V)) (SIGNATURE lazyPremWithDefault ((Record (: coef S) (: gap (NonNegativeInteger)) (: remainder S)) S S)) (SIGNATURE lazyPquo (S S S V)) (SIGNATURE lazyPrem (S S S V)) (SIGNATURE lazyPquo (S S S)) (SIGNATURE lazyPrem (S S S)) (SIGNATURE pquo (S S S V)) (SIGNATURE prem (S S S V)) (SIGNATURE pquo (S S S)) (SIGNATURE prem (S S S)) (SIGNATURE normalized? ((Boolean) S (List S))) (SIGNATURE normalized? ((Boolean) S S)) (SIGNATURE initiallyReduced? ((Boolean) S (List S))) (SIGNATURE initiallyReduced? ((Boolean) S S)) (SIGNATURE headReduced? ((Boolean) S (List S))) (SIGNATURE headReduced? ((Boolean) S S)) (SIGNATURE reduced? ((Boolean) S (List S))) (SIGNATURE reduced? ((Boolean) S S)) (SIGNATURE supRittWu? ((Boolean) S S)) (SIGNATURE infRittWu? ((Boolean) S S)) (SIGNATURE RittWuCompare ((Union (Boolean) failed) S S)) (SIGNATURE mainMonomials ((List S) S)) (SIGNATURE mainCoefficients ((List S) S)) (SIGNATURE leastMonomial (S S)) (SIGNATURE mainMonomial (S S)) (SIGNATURE quasiMonic? ((Boolean) S)) (SIGNATURE monic? ((Boolean) S)) (SIGNATURE reductum (S S V)) (SIGNATURE leadingCoefficient (S S V)) (SIGNATURE deepestInitial (S S)) (SIGNATURE iteratedInitials ((List S) S)) (SIGNATURE deepestTail (S S)) (SIGNATURE tail (S S)) (SIGNATURE head (S S)) (SIGNATURE init (S S)) (SIGNATURE mdeg ((NonNegativeInteger) S)) (SIGNATURE mvar (V S)) (SIGNATURE convert ((InputForm) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE retract (V S)) (SIGNATURE retractIfCan ((Union V failed) S)) (SIGNATURE coerce (S V)) (SIGNATURE leadingCoefficient (R S)) (SIGNATURE reductum (S S)) (SIGNATURE retract ((Integer) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE coerce (S R)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retract (R S)) (SIGNATURE coerce (S (Integer))) (SIGNATURE coerce ((OutputForm) S)))
      [2] convert:  stpol has no value

============================================================================

   finalizing nrlib RPOLCAT- 
Warning: RPOLCAT-;exactQuo has a duplicate definition in this file
Warning: RPOLCAT-;ZToR has a duplicate definition in this file
Warning: RPOLCAT-;PZToPR has a duplicate definition in this file

============================================================================

   finalizing nrlib RPOLCAT 
; (DEFUN |RecursivePolynomialCategory| ...) is being compiled.
;; The variable |RecursivePolynomialCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |RecursivePolynomialCategory;| ...) is being compiled.
;; The variable |RecursivePolynomialCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib SAOS 
--->/research2/test0819/mnt/fedora5/../../src/algebra/SAOS.spad-->SingletonAsOrderedSet((create (%))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/SAOS.spad-->SingletonAsOrderedSet((convert ((Symbol) %))): Not documented!!!!

--------------non extending category----------------------
.. SquareMatrix(#1,#2) of cat 
(|Join| (|SquareMatrixCategory| |#1| |#2| (|DirectProduct| |#1| |#2|) (|DirectProduct| |#1| |#2|)) (|CoercibleTo| (|Matrix| |#2|)) (CATEGORY |domain| (SIGNATURE |transpose| ($ $)) (SIGNATURE |squareMatrix| ($ (|Matrix| |#2|))) (SIGNATURE |coerce| ((|Matrix| |#2|) $)) (IF (|has| |#2| (ATTRIBUTE (|commutative| "*"))) (ATTRIBUTE |central|) |noBranch|) (IF (|has| |#2| (ATTRIBUTE (|commutative| "*"))) (IF (|has| |#2| (ATTRIBUTE |unitsKnown|)) (ATTRIBUTE |unitsKnown|) |noBranch|) |noBranch|) (IF (|has| |#2| (|ConvertibleTo| (|InputForm|))) (ATTRIBUTE (|ConvertibleTo| (|InputForm|))) |noBranch|)))   has no 
============================================================================

(|MatrixCategory| |#2| (|Vector| |#2|) (|Vector| |#2|))    finalizing nrlib SQMATRIX 

============================================================================

   finalizing nrlib SWITCH 
   Warnings: 
      [1]  NULL has no value

============================================================================

   finalizing nrlib SYMS 
   Semantic Errors: 
      [1]  Domain is not a known type
      [2]  void is not a known type

============================================================================

   finalizing nrlib SYMTAB 
   Warnings: 
      [1] typeList:  fst has no value
      [2] typeList2:  fst has no value
      [3] newTypeLists:  fst has no value
      [4] oForm2:  S has no value
      [5] oForm2:  P has no value
      [6] oForm:  bounds has no value

============================================================================

   finalizing nrlib SYSSOLP 
   Warnings: 
      [1] makeEq: not known that (Ring) is of mode (CATEGORY package (SIGNATURE solve ((List (List (Equation (Fraction (Polynomial R))))) (List (Fraction (Polynomial R))) (List (Symbol)))) (SIGNATURE solve ((List (List (Equation (Fraction (Polynomial R))))) (List (Equation (Fraction (Polynomial R)))) (List (Symbol)))) (SIGNATURE solve ((List (List (Equation (Fraction (Polynomial R))))) (List (Fraction (Polynomial R))))) (SIGNATURE solve ((List (List (Equation (Fraction (Polynomial R))))) (List (Equation (Fraction (Polynomial R)))))) (SIGNATURE solve ((List (Equation (Fraction (Polynomial R)))) (Fraction (Polynomial R)) (Symbol))) (SIGNATURE solve ((List (Equation (Fraction (Polynomial R)))) (Equation (Fraction (Polynomial R))) (Symbol))) (SIGNATURE solve ((List (Equation (Fraction (Polynomial R)))) (Fraction (Polynomial R)))) (SIGNATURE solve ((List (Equation (Fraction (Polynomial R)))) (Equation (Fraction (Polynomial R))))) (SIGNATURE triangularSystems ((List (List (Polynomial R))) (List (Fraction (Polynomial R))) (List (Symbol)))))
      [2] triangularSystems: not known that (SIGNATURE variable ((Union $ failed) (Symbol))) is of mode (CATEGORY domain (SIGNATURE new ($)) (SIGNATURE new ($ $)) (SIGNATURE resetNew ((Void))) (SIGNATURE coerce ($ (String))) (SIGNATURE name ($ $)) (SIGNATURE scripted? ((Boolean) $)) (SIGNATURE scripts ((Record (: sub (List (OutputForm))) (: sup (List (OutputForm))) (: presup (List (OutputForm))) (: presub (List (OutputForm))) (: args (List (OutputForm)))) $)) (SIGNATURE script ($ $ (List (List (OutputForm))))) (SIGNATURE script ($ $ (Record (: sub (List (OutputForm))) (: sup (List (OutputForm))) (: presup (List (OutputForm))) (: presub (List (OutputForm))) (: args (List (OutputForm)))))) (SIGNATURE subscript ($ $ (List (OutputForm)))) (SIGNATURE superscript ($ $ (List (OutputForm)))) (SIGNATURE argscript ($ $ (List (OutputForm)))) (SIGNATURE elt ($ $ (List (OutputForm)))) (SIGNATURE string ((String) $)) (SIGNATURE list ((List $) $)) (SIGNATURE sample ($) constant))
      [3] triangularSystems: not known that (PolynomialCategory (Polynomial R) DP OV) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [4] triangularSystems: not known that (PolynomialCategory (Polynomial R) (DirectProduct (# lv) (NonNegativeInteger)) OV) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [5] triangularSystems: not known that (PolynomialCategory (Polynomial R) (DirectProduct (call LENGTH lv) (NonNegativeInteger)) OV) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))

============================================================================

   finalizing nrlib SYSSOLP 
--->/research2/test0819/mnt/fedora5/../../src/algebra/SYSSOLP.spad-->SystemSolvePackage(constructor): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/SYSSOLP.spad-->SystemSolvePackage(): Missing Description

============================================================================

   finalizing nrlib UTSCAT- 
   Warnings: 
      [1] coerce:  l has no value

============================================================================

   finalizing nrlib UTSCAT 
; (DEFUN |UnivariateTaylorSeriesCategory| ...) is being compiled.
;; The variable |UnivariateTaylorSeriesCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |UnivariateTaylorSeriesCategory;| ...) is being compiled.
;; The variable |UnivariateTaylorSeriesCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib WFFINTBS 
   Warnings: 
      [1] listSquaredFactors:  ans has no value
      [2] iLocalIntegralBasis:  rbden has no value
      [3] integralBasis:  runningRbden has no value

============================================================================

   finalizing nrlib ACFS- 
   Warnings: 
      [1] zeroOf: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE zerosOf ((List S) S (Symbol))) (SIGNATURE zeroOf (S S (Symbol))) (SIGNATURE zerosOf ((List S) S)) (SIGNATURE zeroOf (S S)) (SIGNATURE rootsOf ((List S) S (Symbol))) (SIGNATURE rootOf (S S (Symbol))) (SIGNATURE rootsOf ((List S) S)) (SIGNATURE rootOf (S S)) (SIGNATURE zerosOf ((List S) (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE zerosOf ((List S) (SparseUnivariatePolynomial S))) (SIGNATURE zerosOf ((List S) (Polynomial S))) (SIGNATURE zeroOf (S (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE zeroOf (S (SparseUnivariatePolynomial S))) (SIGNATURE zeroOf (S (Polynomial S))) (SIGNATURE rootsOf ((List S) (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE rootsOf ((List S) (SparseUnivariatePolynomial S))) (SIGNATURE rootsOf ((List S) (Polynomial S))) (SIGNATURE rootOf (S (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE rootOf (S (SparseUnivariatePolynomial S))) (SIGNATURE rootOf (S (Polynomial S))))
      [2] zeroOf: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE zerosOf ((List S) S (Symbol))) (SIGNATURE zeroOf (S S (Symbol))) (SIGNATURE zerosOf ((List S) S)) (SIGNATURE zeroOf (S S)) (SIGNATURE rootsOf ((List S) S (Symbol))) (SIGNATURE rootOf (S S (Symbol))) (SIGNATURE rootsOf ((List S) S)) (SIGNATURE rootOf (S S)) (SIGNATURE zerosOf ((List S) (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE zerosOf ((List S) (SparseUnivariatePolynomial S))) (SIGNATURE zerosOf ((List S) (Polynomial S))) (SIGNATURE zeroOf (S (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE zeroOf (S (SparseUnivariatePolynomial S))) (SIGNATURE zeroOf (S (Polynomial S))) (SIGNATURE rootsOf ((List S) (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE rootsOf ((List S) (SparseUnivariatePolynomial S))) (SIGNATURE rootsOf ((List S) (Polynomial S))) (SIGNATURE rootOf (S (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE rootOf (S (SparseUnivariatePolynomial S))) (SIGNATURE rootOf (S (Polynomial S))))
      [3] not known that (Ring) is of mode (CATEGORY domain (SIGNATURE zerosOf ((List S) S (Symbol))) (SIGNATURE zeroOf (S S (Symbol))) (SIGNATURE zerosOf ((List S) S)) (SIGNATURE zeroOf (S S)) (SIGNATURE rootsOf ((List S) S (Symbol))) (SIGNATURE rootOf (S S (Symbol))) (SIGNATURE rootsOf ((List S) S)) (SIGNATURE rootOf (S S)) (SIGNATURE zerosOf ((List S) (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE zerosOf ((List S) (SparseUnivariatePolynomial S))) (SIGNATURE zerosOf ((List S) (Polynomial S))) (SIGNATURE zeroOf (S (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE zeroOf (S (SparseUnivariatePolynomial S))) (SIGNATURE zeroOf (S (Polynomial S))) (SIGNATURE rootsOf ((List S) (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE rootsOf ((List S) (SparseUnivariatePolynomial S))) (SIGNATURE rootsOf ((List S) (Polynomial S))) (SIGNATURE rootOf (S (SparseUnivariatePolynomial S) (Symbol))) (SIGNATURE rootOf (S (SparseUnivariatePolynomial S))) (SIGNATURE rootOf (S (Polynomial S))))

============================================================================

   finalizing nrlib ACFS 
; (DEFUN |AlgebraicallyClosedFunctionSpace| ...) is being compiled.
;; The variable |AlgebraicallyClosedFunctionSpace;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AlgebraicallyClosedFunctionSpace;| ...) is being compiled.
;; The variable |AlgebraicallyClosedFunctionSpace;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib AF 
   Warnings: 
      [1] rootOf: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE rootOf (F (SparseUnivariatePolynomial F) (Symbol))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE inrootof (F (SparseUnivariatePolynomial F) F)) (SIGNATURE droot ((OutputForm) (List F))) (IF (has R (RetractableTo (Integer))) (PROGN (SIGNATURE ** (F F (Fraction (Integer)))) (SIGNATURE minPoly ((SparseUnivariatePolynomial F) (Kernel F))) (SIGNATURE definingPolynomial (F F)) (SIGNATURE iroot (F R (Integer)))) noBranch))
      [2] rootOf: not known that (Ring) is of mode (CATEGORY package (SIGNATURE rootOf (F (SparseUnivariatePolynomial F) (Symbol))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE inrootof (F (SparseUnivariatePolynomial F) F)) (SIGNATURE droot ((OutputForm) (List F))) (IF (has R (RetractableTo (Integer))) (PROGN (SIGNATURE ** (F F (Fraction (Integer)))) (SIGNATURE minPoly ((SparseUnivariatePolynomial F) (Kernel F))) (SIGNATURE definingPolynomial (F F)) (SIGNATURE iroot (F R (Integer)))) noBranch))
      [3] inrootof: not known that (Ring) is of mode (CATEGORY package (SIGNATURE rootOf (F (SparseUnivariatePolynomial F) (Symbol))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE inrootof (F (SparseUnivariatePolynomial F) F)) (SIGNATURE droot ((OutputForm) (List F))) (IF (has R (RetractableTo (Integer))) (PROGN (SIGNATURE ** (F F (Fraction (Integer)))) (SIGNATURE minPoly ((SparseUnivariatePolynomial F) (Kernel F))) (SIGNATURE definingPolynomial (F F)) (SIGNATURE iroot (F R (Integer)))) noBranch))
      [4] hackroot: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE iroot (F R (Integer))))
      [5] inroot0:  rn has no value
      [6] inroot0:  coef has no value
      [7] inroot0:  radicand has no value
      [8] inroot0:  exponent has no value
      [9] inroot0:  rd has no value

============================================================================

   finalizing nrlib ALGFACT 
   Warnings: 
      [1] allk: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE factor ((Factored UP) UP (List (AlgebraicNumber)))) (SIGNATURE factor ((Factored UP) UP)) (SIGNATURE split ((Factored UP) UP)) (SIGNATURE doublyTransitive? ((Boolean) UP)))
      [2] extend: not known that (Ring) is of mode (CATEGORY package (SIGNATURE factor ((Factored UP) UP (List (AlgebraicNumber)))) (SIGNATURE factor ((Factored UP) UP)) (SIGNATURE split ((Factored UP) UP)) (SIGNATURE doublyTransitive? ((Boolean) UP)))
      [3] fact: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE factor ((Factored UP) UP (List (AlgebraicNumber)))) (SIGNATURE factor ((Factored UP) UP)) (SIGNATURE split ((Factored UP) UP)) (SIGNATURE doublyTransitive? ((Boolean) UP)))
      [4] fact: not known that (SIGNATURE coerce ($ (SparseMultivariatePolynomial (Integer) (Kernel (AlgebraicNumber))))) is of mode (CATEGORY domain (SIGNATURE coerce ($ (SparseMultivariatePolynomial (Integer) (Kernel $)))) (SIGNATURE numer ((SparseMultivariatePolynomial (Integer) (Kernel $)) $)) (SIGNATURE denom ((SparseMultivariatePolynomial (Integer) (Kernel $)) $)) (SIGNATURE reduce ($ $)) (SIGNATURE norm ((SparseUnivariatePolynomial $) (SparseUnivariatePolynomial $) (Kernel $))) (SIGNATURE norm ((SparseUnivariatePolynomial $) (SparseUnivariatePolynomial $) (List (Kernel $)))) (SIGNATURE norm ($ $ (Kernel $))) (SIGNATURE norm ($ $ (List (Kernel $)))))
      [5] fact: not known that (SIGNATURE numer ((SparseMultivariatePolynomial (Integer) (Kernel (AlgebraicNumber))) $)) is of mode (CATEGORY domain (SIGNATURE coerce ($ (SparseMultivariatePolynomial (Integer) (Kernel $)))) (SIGNATURE numer ((SparseMultivariatePolynomial (Integer) (Kernel $)) $)) (SIGNATURE denom ((SparseMultivariatePolynomial (Integer) (Kernel $)) $)) (SIGNATURE reduce ($ $)) (SIGNATURE norm ((SparseUnivariatePolynomial $) (SparseUnivariatePolynomial $) (Kernel $))) (SIGNATURE norm ((SparseUnivariatePolynomial $) (SparseUnivariatePolynomial $) (List (Kernel $)))) (SIGNATURE norm ($ $ (Kernel $))) (SIGNATURE norm ($ $ (List (Kernel $)))))
      [6] fact: not known that (SIGNATURE denom ((SparseMultivariatePolynomial (Integer) (Kernel (AlgebraicNumber))) $)) is of mode (CATEGORY domain (SIGNATURE coerce ($ (SparseMultivariatePolynomial (Integer) (Kernel $)))) (SIGNATURE numer ((SparseMultivariatePolynomial (Integer) (Kernel $)) $)) (SIGNATURE denom ((SparseMultivariatePolynomial (Integer) (Kernel $)) $)) (SIGNATURE reduce ($ $)) (SIGNATURE norm ((SparseUnivariatePolynomial $) (SparseUnivariatePolynomial $) (Kernel $))) (SIGNATURE norm ((SparseUnivariatePolynomial $) (SparseUnivariatePolynomial $) (List (Kernel $)))) (SIGNATURE norm ($ $ (Kernel $))) (SIGNATURE norm ($ $ (List (Kernel $)))))

============================================================================

   finalizing nrlib ALGMANIP 
   Warnings: 
      [1] ratDenom: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE rootSplit (F F)) (SIGNATURE ratDenom (F F)) (SIGNATURE ratDenom (F F F)) (SIGNATURE ratDenom (F F (List F))) (SIGNATURE ratDenom (F F (List (Kernel F)))) (SIGNATURE ratPoly ((SparseUnivariatePolynomial F) F)) (IF (has R (OrderedSet)) (IF (has R (GcdDomain)) (IF (has R (RetractableTo (Integer))) (IF (has F (FunctionSpace R)) (PROGN (SIGNATURE rootPower (F F)) (SIGNATURE rootProduct (F F)) (SIGNATURE rootSimp (F F)) (SIGNATURE rootKerSimp (F (BasicOperator) F (NonNegativeInteger)))) noBranch) noBranch) noBranch) noBranch))
      [2] ratPoly: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE rootSplit (F F)) (SIGNATURE ratDenom (F F)) (SIGNATURE ratDenom (F F F)) (SIGNATURE ratDenom (F F (List F))) (SIGNATURE ratDenom (F F (List (Kernel F)))) (SIGNATURE ratPoly ((SparseUnivariatePolynomial F) F)) (IF (has R (OrderedSet)) (IF (has R (GcdDomain)) (IF (has R (RetractableTo (Integer))) (IF (has F (FunctionSpace R)) (PROGN (SIGNATURE rootPower (F F)) (SIGNATURE rootProduct (F F)) (SIGNATURE rootSimp (F F)) (SIGNATURE rootKerSimp (F (BasicOperator) F (NonNegativeInteger)))) noBranch) noBranch) noBranch) noBranch))
      [3] ratPoly: not known that (SIGNATURE coerce ($ (SparseMultivariatePolynomial R (Kernel F)))) is of mode (CATEGORY domain (SIGNATURE numer ((SparseMultivariatePolynomial R (Kernel $)) $)) (SIGNATURE denom ((SparseMultivariatePolynomial R (Kernel $)) $)) (SIGNATURE coerce ($ (SparseMultivariatePolynomial R (Kernel $)))))
      [4] ratPoly: not known that (SIGNATURE numer ((SparseMultivariatePolynomial R (Kernel F)) $)) is of mode (CATEGORY domain (SIGNATURE numer ((SparseMultivariatePolynomial R (Kernel $)) $)) (SIGNATURE denom ((SparseMultivariatePolynomial R (Kernel $)) $)) (SIGNATURE coerce ($ (SparseMultivariatePolynomial R (Kernel $)))))
      [5] ratPoly: not known that (SIGNATURE denom ((SparseMultivariatePolynomial R (Kernel F)) $)) is of mode (CATEGORY domain (SIGNATURE numer ((SparseMultivariatePolynomial R (Kernel $)) $)) (SIGNATURE denom ((SparseMultivariatePolynomial R (Kernel $)) $)) (SIGNATURE coerce ($ (SparseMultivariatePolynomial R (Kernel $)))))
      [6] innerRF: not known that (Ring) is of mode (CATEGORY package (SIGNATURE rootSplit (F F)) (SIGNATURE ratDenom (F F)) (SIGNATURE ratDenom (F F F)) (SIGNATURE ratDenom (F F (List F))) (SIGNATURE ratDenom (F F (List (Kernel F)))) (SIGNATURE ratPoly ((SparseUnivariatePolynomial F) F)) (IF (has R (OrderedSet)) (IF (has R (GcdDomain)) (IF (has R (RetractableTo (Integer))) (IF (has F (FunctionSpace R)) (PROGN (SIGNATURE rootPower (F F)) (SIGNATURE rootProduct (F F)) (SIGNATURE rootSimp (F F)) (SIGNATURE rootKerSimp (F (BasicOperator) F (NonNegativeInteger)))) noBranch) noBranch) noBranch) noBranch))

============================================================================

   finalizing nrlib ALGSC 
   Warnings: 
      [1] elt: :Rep -- should replace by pretend
      [2] coerce:  le has no value

--------------non extending category----------------------
.. AlgebraGivenByStructuralConstants(#1,#2,#3,#4) of cat 
(|Join| (|FramedNonAssociativeAlgebra| |#1|) (|LeftModule| (|SquareMatrix| |#2| |#1|)) (CATEGORY |domain| (SIGNATURE |coerce| ($ (|Vector| |#1|)))))   has no 
============================================================================

(|DirectProductCategory| |#2| |#1|)    finalizing nrlib ALGSC 

(|RealConstant|)    extends 
(|ConvertibleTo| (|DoubleFloat|))    but not 
(|ConvertibleTo| (|Complex| (|Float|))) --------------non extending category----------------------
.. AlgebraicNumber of cat 
(|Join| (|ExpressionSpace|) (|AlgebraicallyClosedField|) (|RetractableTo| (|Integer|)) (|RetractableTo| (|Fraction| (|Integer|))) (|LinearlyExplicitRingOver| (|Integer|)) (|RealConstant|) (|LinearlyExplicitRingOver| (|Fraction| (|Integer|))) (|CharacteristicZero|) (|ConvertibleTo| (|Complex| (|Float|))) (|DifferentialRing|) (CATEGORY |domain| (SIGNATURE |coerce| ($ (|SparseMultivariatePolynomial| (|Integer|) (|Kernel| $)))) (SIGNATURE |numer| ((|SparseMultivariatePolynomial| (|Integer|) (|Kernel| $)) $)) (SIGNATURE |denom| ((|SparseMultivariatePolynomial| (|Integer|) (|Kernel| $)) $)) (SIGNATURE |reduce| ($ $)) (SIGNATURE |norm| ((|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $) (|Kernel| $))) (SIGNATURE |norm| ((|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $) (|List| (|Kernel| $)))) (SIGNATURE |norm| ($ $ (|Kernel| $))) (SIGNATURE |norm| ($ $ (|List| (|Kernel| $))))))    has no  trueEqual : (%,%) -> Boolean 
============================================================================

   finalizing nrlib AN 

============================================================================

   finalizing nrlib APPRULE 
   Warnings: 
      [1] splitRules: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE applyRules (F (List (RewriteRule Base R F)) F)) (SIGNATURE applyRules (F (List (RewriteRule Base R F)) F (PositiveInteger))) (SIGNATURE localUnquote (F F (List (Symbol)))))
      [2] rewrite: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE applyRules (F (List (RewriteRule Base R F)) F)) (SIGNATURE applyRules (F (List (RewriteRule Base R F)) F (PositiveInteger))) (SIGNATURE localUnquote (F F (List (Symbol)))))
      [3] isitwithpred: not known that (SetCategory) is of mode (CATEGORY package (SIGNATURE applyRules (F (List (RewriteRule Base R F)) F)) (SIGNATURE applyRules (F (List (RewriteRule Base R F)) F (PositiveInteger))) (SIGNATURE localUnquote (F F (List (Symbol)))))

============================================================================

   finalizing nrlib ASP19 
   Warnings: 
      [1]  M has no value
      [2]  N has no value
      [3]  LJC has no value
      [4]  XC has no value
      [5]  FVECC has no value
      [6]  FJACC has no value
      [7] localAssign1: not known that (FiniteLinearAggregate (FortranExpression (construct) (construct (QUOTE XC)) (MachineFloat))) is of mode (CATEGORY domain (SIGNATURE vector ($ (List (FortranExpression  (LIST (QUOTE XC)) (MachineFloat))))))
      [8] coerce:  FJACC has no value

============================================================================

   finalizing nrlib ASP20 
   Warnings: 
      [1]  N has no value
      [2]  NROWH has no value
      [3]  NCOLH has no value
      [4]  JTHCOL has no value
      [5]  HESS has no value
      [6]  X has no value
      [7]  HX has no value

============================================================================

   finalizing nrlib ASP30 
   Semantic Errors: 
      [1] coerce:  code is BOTH a variable and a literal
 
   Warnings: 
      [1]  MODE has no value
      [2]  M has no value
      [3]  N has no value
      [4]  LRWORK has no value
      [5]  LIWORK has no value
      [6]  X has no value
      [7]  Y has no value
      [8]  RWORK has no value
      [9]  IWORK has no value
      [10]  IFAIL has no value
      [11] coerce:  A has no value
 

============================================================================

   finalizing nrlib ASP31 
   Semantic Errors: 
      [1] coerce:  code is BOTH a variable and a literal
 
   Warnings: 
      [1]  X has no value
      [2]  Y has no value
      [3] localAssign: not known that (FiniteLinearAggregate (FortranExpression (construct (QUOTE X)) (construct (QUOTE Y)) (MachineFloat))) is of mode (CATEGORY domain (SIGNATURE vector ($ (List (FortranExpression (LIST (QUOTE X)) (LIST (QUOTE Y)) (MachineFloat))))))
      [4] coerce:  PW has no value

============================================================================

   finalizing nrlib ASP35 
   Warnings: 
      [1]  N has no value
      [2]  X has no value
      [3]  FVEC has no value
      [4]  LDFJAC has no value
      [5]  FJAC has no value
      [6]  IFLAG has no value
      [7] localAssign1: not known that (FiniteLinearAggregate (FortranExpression (construct) (construct (QUOTE X)) (MachineFloat))) is of mode (CATEGORY domain (SIGNATURE vector ($ (List (FortranExpression  (LIST (QUOTE X)) (MachineFloat))))))

============================================================================

   finalizing nrlib ASP41 
   Warnings: 
      [1]  N has no value
      [2]  X has no value
      [3]  EPS has no value
      [4]  Y has no value
      [5]  F has no value
      [6] localAssign1: not known that (FiniteLinearAggregate (FortranExpression (construct (QUOTE X) (QUOTE EPS)) (construct (QUOTE Y)) (MachineFloat))) is of mode (CATEGORY domain (SIGNATURE vector ($ (List (FortranExpression (LIST (QUOTE X) (QUOTE EPS)) (LIST (QUOTE Y)) (MachineFloat))))))
      [7] makeCodeThree:  EPS has no value

============================================================================

   finalizing nrlib ASP42 
   Warnings: 
      [1]  EPS has no value
      [2]  N has no value
      [3]  YA has no value
      [4]  YB has no value
      [5]  BC has no value
      [6]  AJ has no value
      [7]  BJ has no value
      [8]  BCEP has no value
      [9] localAssign1: not known that (FiniteLinearAggregate (FortranExpression (construct (QUOTE EPS)) (construct (QUOTE YA) (QUOTE YB)) (MachineFloat))) is of mode (CATEGORY domain (SIGNATURE vector ($ (List (FortranExpression (LIST (QUOTE EPS)) (LIST (QUOTE YA) (QUOTE YB)) (MachineFloat))))))
      [10] makeCodeThree:  EPS has no value

============================================================================

   finalizing nrlib ASP74 
   Warnings: 
      [1]  X has no value
      [2]  Y has no value
      [3]  A has no value
      [4]  B has no value
      [5]  C has no value
      [6]  IBND has no value

============================================================================

   finalizing nrlib ASP77 
   Warnings: 
      [1]  X has no value
      [2] localAssign: not known that (FiniteLinearAggregate (FortranExpression (construct (QUOTE X)) (construct) (MachineFloat))) is of mode (CATEGORY domain (SIGNATURE vector ($ (List (FortranExpression (LIST (QUOTE X))  (MachineFloat))))))
      [3] coerce:  F has no value

============================================================================

   finalizing nrlib ASP80 
   Warnings: 
      [1]  XL has no value
      [2]  XR has no value
      [3]  ELAM has no value
      [4]  YL has no value
      [5]  YR has no value

============================================================================

   finalizing nrlib CINTSLPE 
   Warnings: 
      [1] solveLinearPolynomialEquation:  slpePrime has no value
      [2] solveLinearPolynomialEquation:  oldtable has no value

============================================================================

   finalizing nrlib COMPFACT 
   Warnings: 
      [1] conv:  pris has no value
      [2] conv:  dris has no value
      [3] backConv:  fctr has no value
      [4] backConv:  xpnt has no value
      [5] backConv:  flg has no value

============================================================================

   finalizing nrlib COMPLEX 
   Warnings: 
      [1] OMwrite: pretend(String) -- should replace by @

============================================================================

   finalizing nrlib CMPLXRT 
--->/research2/test0819/mnt/fedora5/../../src/algebra/CMPLXRT.spad-->ComplexRootPackage(constructor): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/CMPLXRT.spad-->ComplexRootPackage(): Missing Description

============================================================================

   finalizing nrlib CPMATCH 
   Warnings: 
      [1] patternMatch: not known that (SetCategory) is of mode (CATEGORY $ (SIGNATURE patternMatch ((PatternMatchResult R CS) CS (Pattern R) (PatternMatchResult R CS))))

============================================================================

   finalizing nrlib CRFP 
   Warnings: 
      [1] pleskenSplit:  split has no value
      [2] startPolynomial:  centerIsRoot has no value
      [3] startPolynomial:  fp has no value
      [4] factor:  result has no value

============================================================================

   finalizing nrlib CTRIGMNP 
   Warnings: 
      [1] complexForm: not known that (RadicalCategory) is of mode (CATEGORY domain (IF (has R (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace R)) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has R (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has R (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [2] complexForm: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (IF (has R (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace R)) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has R (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has R (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [3] real?: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE complexNormalize (F F)) (SIGNATURE complexNormalize (F F (Symbol))) (SIGNATURE complexElementary (F F)) (SIGNATURE complexElementary (F F (Symbol))) (SIGNATURE real ((Expression R) F)) (SIGNATURE imag ((Expression R) F)) (SIGNATURE real? ((Boolean) F)) (SIGNATURE trigs (F F)) (SIGNATURE complexForm ((Complex (Expression R)) F)))
      [4] complexElementary: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE complexNormalize (F F)) (SIGNATURE complexNormalize (F F (Symbol))) (SIGNATURE complexElementary (F F)) (SIGNATURE complexElementary (F F (Symbol))) (SIGNATURE real ((Expression R) F)) (SIGNATURE imag ((Expression R) F)) (SIGNATURE real? ((Boolean) F)) (SIGNATURE trigs (F F)) (SIGNATURE complexForm ((Complex (Expression R)) F)))

============================================================================

   finalizing nrlib D01WGTS 
   Warnings: 
      [1] exprIsLogarithmicWeight: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE exprHasWeightCosWXorSinWX ((Union (Record (: op (BasicOperator)) (: w (DoubleFloat))) failed) (Record (: var (Symbol)) (: fn (Expression (DoubleFloat))) (: range (Segment (OrderedCompletion (DoubleFloat)))) (: abserr (DoubleFloat)) (: relerr (DoubleFloat))))) (SIGNATURE exprHasAlgebraicWeight ((Union (List (DoubleFloat)) failed) (Record (: var (Symbol)) (: fn (Expression (DoubleFloat))) (: range (Segment (OrderedCompletion (DoubleFloat)))) (: abserr (DoubleFloat)) (: relerr (DoubleFloat))))) (SIGNATURE exprHasLogarithmicWeights ((Integer) (Record (: var (Symbol)) (: fn (Expression (DoubleFloat))) (: range (Segment (OrderedCompletion (DoubleFloat)))) (: abserr (DoubleFloat)) (: relerr (DoubleFloat))))))
      [2] functionIsQuotient: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE exprHasWeightCosWXorSinWX ((Union (Record (: op (BasicOperator)) (: w (DoubleFloat))) failed) (Record (: var (Symbol)) (: fn (Expression (DoubleFloat))) (: range (Segment (OrderedCompletion (DoubleFloat)))) (: abserr (DoubleFloat)) (: relerr (DoubleFloat))))) (SIGNATURE exprHasAlgebraicWeight ((Union (List (DoubleFloat)) failed) (Record (: var (Symbol)) (: fn (Expression (DoubleFloat))) (: range (Segment (OrderedCompletion (DoubleFloat)))) (: abserr (DoubleFloat)) (: relerr (DoubleFloat))))) (SIGNATURE exprHasLogarithmicWeights ((Integer) (Record (: var (Symbol)) (: fn (Expression (DoubleFloat))) (: range (Segment (OrderedCompletion (DoubleFloat)))) (: abserr (DoubleFloat)) (: relerr (DoubleFloat))))))

============================================================================

   finalizing nrlib D02AGNT 
   Warnings: 
      [1] stiffnessAndStabilityFactor:  b has no value
      [2] stiffnessAndStabilityFactor:  e has no value
      [3] stiffnessAndStabilityOfODE:  Y has no value

--------------non extending category----------------------
.. d03eefAnnaType of cat 
(|PartialDifferentialEquationsSolverCategory|)   has no 
============================================================================

(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib D03EEFA 

--------------non extending category----------------------
.. DeRhamComplex(#1,#2) of cat 
(|Join| (|LeftAlgebra| (|Expression| |#1|)) (|RetractableTo| (|Expression| |#1|)) (CATEGORY |domain| (SIGNATURE |leadingCoefficient| ((|Expression| |#1|) $)) (SIGNATURE |leadingBasisTerm| ($ $)) (SIGNATURE |reductum| ($ $)) (SIGNATURE |coefficient| ((|Expression| |#1|) $ $)) (SIGNATURE |generator| ($ (|NonNegativeInteger|))) (SIGNATURE |homogeneous?| ((|Boolean|) $)) (SIGNATURE |retractable?| ((|Boolean|) $)) (SIGNATURE |degree| ((|Integer|) $)) (SIGNATURE |map| ($ (|Mapping| (|Expression| |#1|) (|Expression| |#1|)) $)) (SIGNATURE |totalDifferential| ($ (|Expression| |#1|))) (SIGNATURE |exteriorDifferential| ($ $))))    has no  exp : List Integer -> % 
============================================================================

   finalizing nrlib DERHAM 

============================================================================

   finalizing nrlib DRAWCURV 
   Warnings: 
      [1] draw:  xRangeFloat has no value
      [2] draw:  yRangeFloat has no value
      [3] draw:  floatRanges has no value

--------------non extending category----------------------
.. e04nafAnnaType of cat 
(|NumericalOptimizationCategory|)   has no 
============================================================================

(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib E04NAFA 

--------------non extending category----------------------
.. e04ucfAnnaType of cat 
(|NumericalOptimizationCategory|)   has no 
============================================================================

(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib E04UCFA 

============================================================================

   finalizing nrlib EF 
   Warnings: 
      [1] pi:  Pie has no value
      [2] iisqrt1:  isqrt1 has no value
      [3] iisqrt2:  isqrt2 has no value
      [4] iisqrt3:  isqrt3 has no value
      [5] kernel: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE exp (F F)) (SIGNATURE log (F F)) (SIGNATURE sin (F F)) (SIGNATURE cos (F F)) (SIGNATURE tan (F F)) (SIGNATURE cot (F F)) (SIGNATURE sec (F F)) (SIGNATURE csc (F F)) (SIGNATURE asin (F F)) (SIGNATURE acos (F F)) (SIGNATURE atan (F F)) (SIGNATURE acot (F F)) (SIGNATURE asec (F F)) (SIGNATURE acsc (F F)) (SIGNATURE sinh (F F)) (SIGNATURE cosh (F F)) (SIGNATURE tanh (F F)) (SIGNATURE coth (F F)) (SIGNATURE sech (F F)) (SIGNATURE csch (F F)) (SIGNATURE asinh (F F)) (SIGNATURE acosh (F F)) (SIGNATURE atanh (F F)) (SIGNATURE acoth (F F)) (SIGNATURE asech (F F)) (SIGNATURE acsch (F F)) (SIGNATURE pi (F)) (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE iisqrt2 (F)) (SIGNATURE iisqrt3 (F)) (SIGNATURE iiexp (F F)) (SIGNATURE iilog (F F)) (SIGNATURE iisin (F F)) (SIGNATURE iicos (F F)) (SIGNATURE iitan (F F)) (SIGNATURE iicot (F F)) (SIGNATURE iisec (F F)) (SIGNATURE iicsc (F F)) (SIGNATURE iiasin (F F)) (SIGNATURE iiacos (F F)) (SIGNATURE iiatan (F F)) (SIGNATURE iiacot (F F)) (SIGNATURE iiasec (F F)) (SIGNATURE iiacsc (F F)) (SIGNATURE iisinh (F F)) (SIGNATURE iicosh (F F)) (SIGNATURE iitanh (F F)) (SIGNATURE iicoth (F F)) (SIGNATURE iisech (F F)) (SIGNATURE iicsch (F F)) (SIGNATURE iiasinh (F F)) (SIGNATURE iiacosh (F F)) (SIGNATURE iiatanh (F F)) (SIGNATURE iiacoth (F F)) (SIGNATURE iiasech (F F)) (SIGNATURE iiacsch (F F)) (SIGNATURE specialTrigs ((Union F failed) F (List (Record (: func F) (: pole (Boolean)))))) (SIGNATURE localReal? ((Boolean) F)))
      [6] ilog: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE exp (F F)) (SIGNATURE log (F F)) (SIGNATURE sin (F F)) (SIGNATURE cos (F F)) (SIGNATURE tan (F F)) (SIGNATURE cot (F F)) (SIGNATURE sec (F F)) (SIGNATURE csc (F F)) (SIGNATURE asin (F F)) (SIGNATURE acos (F F)) (SIGNATURE atan (F F)) (SIGNATURE acot (F F)) (SIGNATURE asec (F F)) (SIGNATURE acsc (F F)) (SIGNATURE sinh (F F)) (SIGNATURE cosh (F F)) (SIGNATURE tanh (F F)) (SIGNATURE coth (F F)) (SIGNATURE sech (F F)) (SIGNATURE csch (F F)) (SIGNATURE asinh (F F)) (SIGNATURE acosh (F F)) (SIGNATURE atanh (F F)) (SIGNATURE acoth (F F)) (SIGNATURE asech (F F)) (SIGNATURE acsch (F F)) (SIGNATURE pi (F)) (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE iisqrt2 (F)) (SIGNATURE iisqrt3 (F)) (SIGNATURE iiexp (F F)) (SIGNATURE iilog (F F)) (SIGNATURE iisin (F F)) (SIGNATURE iicos (F F)) (SIGNATURE iitan (F F)) (SIGNATURE iicot (F F)) (SIGNATURE iisec (F F)) (SIGNATURE iicsc (F F)) (SIGNATURE iiasin (F F)) (SIGNATURE iiacos (F F)) (SIGNATURE iiatan (F F)) (SIGNATURE iiacot (F F)) (SIGNATURE iiasec (F F)) (SIGNATURE iiacsc (F F)) (SIGNATURE iisinh (F F)) (SIGNATURE iicosh (F F)) (SIGNATURE iitanh (F F)) (SIGNATURE iicoth (F F)) (SIGNATURE iisech (F F)) (SIGNATURE iicsch (F F)) (SIGNATURE iiasinh (F F)) (SIGNATURE iiacosh (F F)) (SIGNATURE iiatanh (F F)) (SIGNATURE iiacoth (F F)) (SIGNATURE iiasech (F F)) (SIGNATURE iiacsch (F F)) (SIGNATURE specialTrigs ((Union F failed) F (List (Record (: func F) (: pole (Boolean)))))) (SIGNATURE localReal? ((Boolean) F)))

============================================================================

   finalizing nrlib EFSTRUC 
   Warnings: 
      [1] realElem: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE normalize (F F)) (SIGNATURE normalize (F F (Symbol))) (SIGNATURE rischNormalize ((Record (: func F) (: kers (List (Kernel F))) (: vals (List F))) F (Symbol))) (SIGNATURE realElementary (F F)) (SIGNATURE realElementary (F F (Symbol))) (SIGNATURE validExponential ((Union F failed) (List (Kernel F)) F (Symbol))) (SIGNATURE rootNormalize (F F (Kernel F))) (SIGNATURE tanQ (F (Fraction (Integer)) F)))
      [2] rtNormalize:  func has no value
      [3] tanQ: not known that (Ring) is of mode (CATEGORY package (SIGNATURE normalize (F F)) (SIGNATURE normalize (F F (Symbol))) (SIGNATURE rischNormalize ((Record (: func F) (: kers (List (Kernel F))) (: vals (List F))) F (Symbol))) (SIGNATURE realElementary (F F)) (SIGNATURE realElementary (F F (Symbol))) (SIGNATURE validExponential ((Union F failed) (List (Kernel F)) F (Symbol))) (SIGNATURE rootNormalize (F F (Kernel F))) (SIGNATURE tanQ (F (Fraction (Integer)) F)))
      [4] rootNormalize0: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE normalize (F F)) (SIGNATURE normalize (F F (Symbol))) (SIGNATURE rischNormalize ((Record (: func F) (: kers (List (Kernel F))) (: vals (List F))) F (Symbol))) (SIGNATURE realElementary (F F)) (SIGNATURE realElementary (F F (Symbol))) (SIGNATURE validExponential ((Union F failed) (List (Kernel F)) F (Symbol))) (SIGNATURE rootNormalize (F F (Kernel F))) (SIGNATURE tanQ (F (Fraction (Integer)) F)))
      [5] ktoY: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE normalize (F F)) (SIGNATURE normalize (F F (Symbol))) (SIGNATURE rischNormalize ((Record (: func F) (: kers (List (Kernel F))) (: vals (List F))) F (Symbol))) (SIGNATURE realElementary (F F)) (SIGNATURE realElementary (F F (Symbol))) (SIGNATURE validExponential ((Union F failed) (List (Kernel F)) F (Symbol))) (SIGNATURE rootNormalize (F F (Kernel F))) (SIGNATURE tanQ (F (Fraction (Integer)) F)))
      [6] k2Elem:  ez has no value
      [7] k2Elem:  iez has no value
      [8] k2Elem:  tz2 has no value
      [9] tannosimp:  den has no value
      [10] tannosimp:  num has no value
      [11] expnosimp:  den has no value
      [12] expnosimp:  num has no value
      [13] rischNormalize:  vec has no value
      [14] rootKernelNormalize:  vec has no value
      [15] validExponential:  IN has no value
      [16] validExponential:  g has no value

============================================================================

   finalizing nrlib ESTOOLS 
   Warnings: 
      [1] isQuotient: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE f2df ((DoubleFloat) (Float))) (SIGNATURE ef2edf ((Expression (DoubleFloat)) (Expression (Float)))) (SIGNATURE ocf2ocdf ((OrderedCompletion (DoubleFloat)) (OrderedCompletion (Float)))) (SIGNATURE socf2socdf ((Segment (OrderedCompletion (DoubleFloat))) (Segment (OrderedCompletion (Float))))) (SIGNATURE convert ((List (Segment (OrderedCompletion (DoubleFloat)))) (List (Segment (OrderedCompletion (Float)))))) (SIGNATURE df2fi ((Fraction (Integer)) (DoubleFloat))) (SIGNATURE edf2fi ((Fraction (Integer)) (Expression (DoubleFloat)))) (SIGNATURE edf2df ((DoubleFloat) (Expression (DoubleFloat)))) (SIGNATURE isQuotient ((Union (Expression (DoubleFloat)) failed) (Expression (DoubleFloat)))) (SIGNATURE expenseOfEvaluation ((Float) (Vector (Expression (DoubleFloat))))) (SIGNATURE numberOfOperations ((Record (: additions (Integer)) (: multiplications (Integer)) (: exponentiations (Integer)) (: functionCalls (Integer))) (Vector (Expression (DoubleFloat))))) (SIGNATURE edf2efi ((Expression (Fraction (Integer))) (Expression (DoubleFloat)))) (SIGNATURE dfRange ((Segment (OrderedCompletion (DoubleFloat))) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE dflist ((List (DoubleFloat)) (List (Record (: left (Fraction (Integer))) (: right (Fraction (Integer))))))) (SIGNATURE df2mf ((MachineFloat) (DoubleFloat))) (SIGNATURE ldf2vmf ((Vector (MachineFloat)) (List (DoubleFloat)))) (SIGNATURE edf2ef ((Expression (Float)) (Expression (DoubleFloat)))) (SIGNATURE vedf2vef ((Vector (Expression (Float))) (Vector (Expression (DoubleFloat))))) (SIGNATURE in? ((Boolean) (DoubleFloat) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE df2st ((String) (DoubleFloat))) (SIGNATURE f2st ((String) (Float))) (SIGNATURE ldf2lst ((List (String)) (List (DoubleFloat)))) (SIGNATURE sdf2lst ((List (String)) (Stream (DoubleFloat)))) (SIGNATURE getlo ((DoubleFloat) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE gethi ((DoubleFloat) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE concat ((Result) (Result) (Result))) (SIGNATURE concat ((Result) (List (Result)))) (SIGNATURE outputMeasure ((String) (Float))) (SIGNATURE measure2Result ((Result) (Record (: measure (Float)) (: name (String)) (: explanations (List (String)))))) (SIGNATURE measure2Result ((Result) (Record (: measure (Float)) (: name (String)) (: explanations (List (String))) (: extra (Result))))) (SIGNATURE att2Result ((Result) (Record (: endPointContinuity (Union (: continuous Continuous at the end points) (: lowerSingular There is a singularity at the lower end point) (: upperSingular There is a singularity at the upper end point) (: bothSingular There are singularities at both end points) (: notEvaluated End point continuity not yet evaluated))) (: singularitiesStream (Union (: str (Stream (DoubleFloat))) (: notEvaluated Internal singularities not yet evaluated))) (: range (Union (: finite The range is finite) (: lowerInfinite The bottom of range is infinite) (: upperInfinite The top of range is infinite) (: bothInfinite Both top and bottom points are infinite) (: notEvaluated Range not yet evaluated)))))) (SIGNATURE iflist2Result ((Result) (Record (: stiffness (Float)) (: stability (Float)) (: expense (Float)) (: accuracy (Float)) (: intermediateResults (Float))))) (SIGNATURE pdf2ef ((Expression (Float)) (Polynomial (DoubleFloat)))) (SIGNATURE pdf2df ((DoubleFloat) (Polynomial (DoubleFloat)))) (SIGNATURE df2ef ((Expression (Float)) (DoubleFloat))) (SIGNATURE fi2df ((DoubleFloat) (Fraction (Integer)))) (SIGNATURE mat ((Matrix (DoubleFloat)) (List (DoubleFloat)) (NonNegativeInteger))))
      [2] numberOfOperations1: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE f2df ((DoubleFloat) (Float))) (SIGNATURE ef2edf ((Expression (DoubleFloat)) (Expression (Float)))) (SIGNATURE ocf2ocdf ((OrderedCompletion (DoubleFloat)) (OrderedCompletion (Float)))) (SIGNATURE socf2socdf ((Segment (OrderedCompletion (DoubleFloat))) (Segment (OrderedCompletion (Float))))) (SIGNATURE convert ((List (Segment (OrderedCompletion (DoubleFloat)))) (List (Segment (OrderedCompletion (Float)))))) (SIGNATURE df2fi ((Fraction (Integer)) (DoubleFloat))) (SIGNATURE edf2fi ((Fraction (Integer)) (Expression (DoubleFloat)))) (SIGNATURE edf2df ((DoubleFloat) (Expression (DoubleFloat)))) (SIGNATURE isQuotient ((Union (Expression (DoubleFloat)) failed) (Expression (DoubleFloat)))) (SIGNATURE expenseOfEvaluation ((Float) (Vector (Expression (DoubleFloat))))) (SIGNATURE numberOfOperations ((Record (: additions (Integer)) (: multiplications (Integer)) (: exponentiations (Integer)) (: functionCalls (Integer))) (Vector (Expression (DoubleFloat))))) (SIGNATURE edf2efi ((Expression (Fraction (Integer))) (Expression (DoubleFloat)))) (SIGNATURE dfRange ((Segment (OrderedCompletion (DoubleFloat))) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE dflist ((List (DoubleFloat)) (List (Record (: left (Fraction (Integer))) (: right (Fraction (Integer))))))) (SIGNATURE df2mf ((MachineFloat) (DoubleFloat))) (SIGNATURE ldf2vmf ((Vector (MachineFloat)) (List (DoubleFloat)))) (SIGNATURE edf2ef ((Expression (Float)) (Expression (DoubleFloat)))) (SIGNATURE vedf2vef ((Vector (Expression (Float))) (Vector (Expression (DoubleFloat))))) (SIGNATURE in? ((Boolean) (DoubleFloat) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE df2st ((String) (DoubleFloat))) (SIGNATURE f2st ((String) (Float))) (SIGNATURE ldf2lst ((List (String)) (List (DoubleFloat)))) (SIGNATURE sdf2lst ((List (String)) (Stream (DoubleFloat)))) (SIGNATURE getlo ((DoubleFloat) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE gethi ((DoubleFloat) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE concat ((Result) (Result) (Result))) (SIGNATURE concat ((Result) (List (Result)))) (SIGNATURE outputMeasure ((String) (Float))) (SIGNATURE measure2Result ((Result) (Record (: measure (Float)) (: name (String)) (: explanations (List (String)))))) (SIGNATURE measure2Result ((Result) (Record (: measure (Float)) (: name (String)) (: explanations (List (String))) (: extra (Result))))) (SIGNATURE att2Result ((Result) (Record (: endPointContinuity (Union (: continuous Continuous at the end points) (: lowerSingular There is a singularity at the lower end point) (: upperSingular There is a singularity at the upper end point) (: bothSingular There are singularities at both end points) (: notEvaluated End point continuity not yet evaluated))) (: singularitiesStream (Union (: str (Stream (DoubleFloat))) (: notEvaluated Internal singularities not yet evaluated))) (: range (Union (: finite The range is finite) (: lowerInfinite The bottom of range is infinite) (: upperInfinite The top of range is infinite) (: bothInfinite Both top and bottom points are infinite) (: notEvaluated Range not yet evaluated)))))) (SIGNATURE iflist2Result ((Result) (Record (: stiffness (Float)) (: stability (Float)) (: expense (Float)) (: accuracy (Float)) (: intermediateResults (Float))))) (SIGNATURE pdf2ef ((Expression (Float)) (Polynomial (DoubleFloat)))) (SIGNATURE pdf2df ((DoubleFloat) (Polynomial (DoubleFloat)))) (SIGNATURE df2ef ((Expression (Float)) (DoubleFloat))) (SIGNATURE fi2df ((DoubleFloat) (Fraction (Integer)))) (SIGNATURE mat ((Matrix (DoubleFloat)) (List (DoubleFloat)) (NonNegativeInteger))))

--------------non extending category----------------------
.. ExponentialExpansion(#1,#2,#3,#4) of cat 
(|Join| (|QuotientFieldCategory| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)) (|RetractableTo| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|)) (CATEGORY |domain| (SIGNATURE |limitPlus| ((|Union| (|OrderedCompletion| |#2|) "failed") $)) (SIGNATURE |coerce| ($ (|UnivariatePuiseuxSeries| |#2| |#3| |#4|)))))   has no 
============================================================================

(IF (|has| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (|IntegerNumberSystem|)) (IF (|has| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (|OpenMath|)) (ATTRIBUTE (|OpenMath|)) |noBranch|) |noBranch|)    finalizing nrlib EXPEXPAN 

============================================================================

   finalizing nrlib EXPRODE 
   Warnings: 
      [1] diffRhs: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE seriesSolve ((Any) (Equation F) (BasicOperator) (Equation F) (Equation F))) (SIGNATURE seriesSolve ((Any) (Equation F) (BasicOperator) (Equation F) (List F))) (SIGNATURE seriesSolve ((Any) (List (Equation F)) (List (BasicOperator)) (Equation F) (List (Equation F)))) (SIGNATURE seriesSolve ((Any) (List (Equation F)) (List (BasicOperator)) (Equation F) (List F))) (SIGNATURE seriesSolve ((Any) (List F) (List (BasicOperator)) (Equation F) (List F))) (SIGNATURE seriesSolve ((Any) (List F) (List (BasicOperator)) (Equation F) (List (Equation F)))) (SIGNATURE seriesSolve ((Any) (Equation F) (BasicOperator) (Equation F) F)) (SIGNATURE seriesSolve ((Any) F (BasicOperator) (Equation F) F)) (SIGNATURE seriesSolve ((Any) F (BasicOperator) (Equation F) (Equation F))) (SIGNATURE seriesSolve ((Any) F (BasicOperator) (Equation F) (List F))))
      [2] k2exquo:  IN has no value
      [3] k2exquo:  f has no value
      [4] div2exquo: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE seriesSolve ((Any) (Equation F) (BasicOperator) (Equation F) (Equation F))) (SIGNATURE seriesSolve ((Any) (Equation F) (BasicOperator) (Equation F) (List F))) (SIGNATURE seriesSolve ((Any) (List (Equation F)) (List (BasicOperator)) (Equation F) (List (Equation F)))) (SIGNATURE seriesSolve ((Any) (List (Equation F)) (List (BasicOperator)) (Equation F) (List F))) (SIGNATURE seriesSolve ((Any) (List F) (List (BasicOperator)) (Equation F) (List F))) (SIGNATURE seriesSolve ((Any) (List F) (List (BasicOperator)) (Equation F) (List (Equation F)))) (SIGNATURE seriesSolve ((Any) (Equation F) (BasicOperator) (Equation F) F)) (SIGNATURE seriesSolve ((Any) F (BasicOperator) (Equation F) F)) (SIGNATURE seriesSolve ((Any) F (BasicOperator) (Equation F) (Equation F))) (SIGNATURE seriesSolve ((Any) F (BasicOperator) (Equation F) (List F))))
      [5] diffRhsK: not known that (Ring) is of mode (CATEGORY package (SIGNATURE seriesSolve ((Any) (Equation F) (BasicOperator) (Equation F) (Equation F))) (SIGNATURE seriesSolve ((Any) (Equation F) (BasicOperator) (Equation F) (List F))) (SIGNATURE seriesSolve ((Any) (List (Equation F)) (List (BasicOperator)) (Equation F) (List (Equation F)))) (SIGNATURE seriesSolve ((Any) (List (Equation F)) (List (BasicOperator)) (Equation F) (List F))) (SIGNATURE seriesSolve ((Any) (List F) (List (BasicOperator)) (Equation F) (List F))) (SIGNATURE seriesSolve ((Any) (List F) (List (BasicOperator)) (Equation F) (List (Equation F)))) (SIGNATURE seriesSolve ((Any) (Equation F) (BasicOperator) (Equation F) F)) (SIGNATURE seriesSolve ((Any) F (BasicOperator) (Equation F) F)) (SIGNATURE seriesSolve ((Any) F (BasicOperator) (Equation F) (Equation F))) (SIGNATURE seriesSolve ((Any) F (BasicOperator) (Equation F) (List F))))
      [6] findEq: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE seriesSolve ((Any) (Equation F) (BasicOperator) (Equation F) (Equation F))) (SIGNATURE seriesSolve ((Any) (Equation F) (BasicOperator) (Equation F) (List F))) (SIGNATURE seriesSolve ((Any) (List (Equation F)) (List (BasicOperator)) (Equation F) (List (Equation F)))) (SIGNATURE seriesSolve ((Any) (List (Equation F)) (List (BasicOperator)) (Equation F) (List F))) (SIGNATURE seriesSolve ((Any) (List F) (List (BasicOperator)) (Equation F) (List F))) (SIGNATURE seriesSolve ((Any) (List F) (List (BasicOperator)) (Equation F) (List (Equation F)))) (SIGNATURE seriesSolve ((Any) (Equation F) (BasicOperator) (Equation F) F)) (SIGNATURE seriesSolve ((Any) F (BasicOperator) (Equation F) F)) (SIGNATURE seriesSolve ((Any) F (BasicOperator) (Equation F) (Equation F))) (SIGNATURE seriesSolve ((Any) F (BasicOperator) (Equation F) (List F))))
      [7] seriesSolve:  IN has no value
      [8] seriesSolve:  deq has no value
      [9] seriesSolve:  y has no value

============================================================================

   finalizing nrlib FC 
   Semantic Errors: 
      [1] common:  name is BOTH a variable and a literal
      [2] common:  contents is BOTH a variable and a literal
      [3] forLoop:  body is BOTH a variable and a literal
 
   Warnings: 
      [1] getElseIf:  conditionalBranch has no value
      [2] getCode:  assignmentBranch has no value
      [3] getCode:  arrayAssignmentBranch has no value
      [4] getCode:  conditionalBranch has no value
      [5] getCode:  returnBranch has no value
      [6] getCode:  blockBranch has no value
      [7] getCode:  commentBranch has no value
      [8] getCode:  callBranch has no value
      [9] getCode:  forBranch has no value
      [10] getCode:  labelBranch has no value
      [11] getCode:  loopBranch has no value
      [12] getCode:  printBranch has no value
      [13] getCode:  commonBranch has no value
 
============================================================================

   finalizing nrlib FC 
; (DEFUN |FC;getContinue| ...) is being compiled.
;; The variable |$fortIndent| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FDIVCAT 
; (DEFUN |FiniteDivisorCategory| ...) is being compiled.
;; The variable |FiniteDivisorCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |FiniteDivisorCategory;| ...) is being compiled.
;; The variable |FiniteDivisorCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FSRED 
   Warnings: 
      [1] bringDown: not known that (Ring) is of mode (CATEGORY package (SIGNATURE bringDown ((Fraction (Integer)) F)) (SIGNATURE bringDown ((SparseUnivariatePolynomial (Fraction (Integer))) F (Kernel F))) (SIGNATURE newReduc ((Void))))
      [2] bringDown: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE bringDown ((Fraction (Integer)) F)) (SIGNATURE bringDown ((SparseUnivariatePolynomial (Fraction (Integer))) F (Kernel F))) (SIGNATURE newReduc ((Void))))

============================================================================

   finalizing nrlib FSUPFACT 
   Warnings: 
      [1] anfactor:  overq has no value
      [2] anfactor:  overan has no value
      [3] ffactor0: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE ffactor ((Factored UP) UP)) (SIGNATURE qfactor ((Union (Factored (SparseUnivariatePolynomial (Fraction (Integer)))) failed) UP)) (SIGNATURE UP2ifCan ((Union (: overq (SparseUnivariatePolynomial (Fraction (Integer)))) (: overan (SparseUnivariatePolynomial (AlgebraicNumber))) (: failed (Boolean))) UP)) (IF (has F (RetractableTo (AlgebraicNumber))) (SIGNATURE anfactor ((Union (Factored (SparseUnivariatePolynomial (AlgebraicNumber))) failed) UP)) noBranch))
      [4] ffactor0: not known that (Ring) is of mode (CATEGORY package (SIGNATURE ffactor ((Factored UP) UP)) (SIGNATURE qfactor ((Union (Factored (SparseUnivariatePolynomial (Fraction (Integer)))) failed) UP)) (SIGNATURE UP2ifCan ((Union (: overq (SparseUnivariatePolynomial (Fraction (Integer)))) (: overan (SparseUnivariatePolynomial (AlgebraicNumber))) (: failed (Boolean))) UP)) (IF (has F (RetractableTo (AlgebraicNumber))) (SIGNATURE anfactor ((Union (Factored (SparseUnivariatePolynomial (AlgebraicNumber))) failed) UP)) noBranch))
      [5] qfactor:  overq has no value

============================================================================

   finalizing nrlib FSPECF 
   Warnings: 
      [1] iiabs: not known that (Ring) is of mode (CATEGORY R (SIGNATURE abs (R R)))

============================================================================

   finalizing nrlib FS2 
   Warnings: 
      [1] map: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE map (B (Mapping S R) A)))

============================================================================

   finalizing nrlib FS2UPS 
   Warnings: 
      [1] exprToUPS: not known that (Ring) is of mode (CATEGORY package (SIGNATURE exprToUPS ((Union (: %series UPS) (: %problem (Record (: func (String)) (: prob (String))))) FE (Boolean) (String))) (SIGNATURE exprToGenUPS ((Union (: %series UPS) (: %problem (Record (: func (String)) (: prob (String))))) FE (Boolean) (String))) (SIGNATURE localAbs (FE FE)))
      [2] listToUPS:  %series has no value
      [3] powerToUPS:  %series has no value
      [4] kernelToUPS: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE exprToUPS ((Union (: %series UPS) (: %problem (Record (: func (String)) (: prob (String))))) FE (Boolean) (String))) (SIGNATURE exprToGenUPS ((Union (: %series UPS) (: %problem (Record (: func (String)) (: prob (String))))) FE (Boolean) (String))) (SIGNATURE localAbs (FE FE)))
      [5] nthRootToUPS:  %series has no value
      [6] logToUPS:  %series has no value
      [7] atancotToUPS:  %series has no value
      [8] applyIfCan:  %series has no value
      [9] powToUPS:  %series has no value
      [10] newElem: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE exprToUPS ((Union (: %series UPS) (: %problem (Record (: func (String)) (: prob (String))))) FE (Boolean) (String))) (SIGNATURE exprToGenUPS ((Union (: %series UPS) (: %problem (Record (: func (String)) (: prob (String))))) FE (Boolean) (String))) (SIGNATURE localAbs (FE FE)))
      [11] opsInvolvingX: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE exprToUPS ((Union (: %series UPS) (: %problem (Record (: func (String)) (: prob (String))))) FE (Boolean) (String))) (SIGNATURE exprToGenUPS ((Union (: %series UPS) (: %problem (Record (: func (String)) (: prob (String))))) FE (Boolean) (String))) (SIGNATURE localAbs (FE FE)))
      [12] powerToGenUPS:  %series has no value
      [13] nthRootToGenUPS:  %series has no value
      [14] logToGenUPS:  %series has no value
      [15] expToGenUPS:  %series has no value
      [16] expGenUPS:  %series has no value
      [17] atancotToGenUPS:  %problem has no value
      [18] atancotToGenUPS:  %series has no value
      [19] genUPSApplyIfCan:  %series has no value
      [20] applyBddIfCan:  %problem has no value
      [21] applyBddIfCan:  %series has no value
      [22] powToGenUPS:  %series has no value
 

============================================================================

   finalizing nrlib GAUSSFAC 
   Warnings: 
      [1] intfactor:  unity has no value
      [2] factor: :(NonNegativeInteger) -- should replace by pretend
      [3] factor:  result has no value
      [4] factor:  unity has no value

============================================================================

   finalizing nrlib GCNAALG 
   Warnings: 
      [1] leftRankPolynomial: signature of lhs not unique: (SparseUnivariatePolynomial (Fraction (Polynomial R))) chosen
      [2] rightRankPolynomial: signature of lhs not unique: (SparseUnivariatePolynomial (Fraction (Polynomial R))) chosen
      [3] genericLeftNorm:  rf has no value
      [4] genericRightNorm:  rf has no value

============================================================================

   finalizing nrlib GCNAALG 
(|Module| (|Fraction| (|Polynomial| |#1|)))    extends 
(|LeftModule| (|Fraction| (|Polynomial| |#1|)))    but not 
(|LeftModule| (|SquareMatrix| |#2| (|Fraction| (|Polynomial| |#1|))))    

============================================================================

   finalizing nrlib GENUFACT 
   Warnings: 
      [1] factor: not known that (UnivariatePolynomialCategory (Integer)) is of mode (CATEGORY domain (SIGNATURE outputForm ((OutputForm) $ (OutputForm))) (SIGNATURE fmecg ($ $ (NonNegativeInteger) R $)))
      [2] factor: not known that (UnivariatePolynomialCategory (Fraction (Integer))) is of mode (CATEGORY domain (SIGNATURE outputForm ((OutputForm) $ (OutputForm))) (SIGNATURE fmecg ($ $ (NonNegativeInteger) R $)))
      [3] factor: not known that (UnivariatePolynomialCategory (Complex (Integer))) is of mode (CATEGORY domain (SIGNATURE outputForm ((OutputForm) $ (OutputForm))) (SIGNATURE fmecg ($ $ (NonNegativeInteger) R $)))
      [4] factor: not known that (UnivariatePolynomialCategory (Complex (Fraction (Integer)))) is of mode (CATEGORY domain (SIGNATURE outputForm ((OutputForm) $ (OutputForm))) (SIGNATURE fmecg ($ $ (NonNegativeInteger) R $)))
      [5] factor: not known that (UnivariatePolynomialCategory (AlgebraicNumber)) is of mode (CATEGORY domain (SIGNATURE outputForm ((OutputForm) $ (OutputForm))) (SIGNATURE fmecg ($ $ (NonNegativeInteger) R $)))
      [6] factor: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE factor ((Factored (SparseUnivariatePolynomial R)) (SparseUnivariatePolynomial R))))

--------------non extending category----------------------
.. InnerAlgebraicNumber of cat 
(|Join| (|ExpressionSpace|) (|AlgebraicallyClosedField|) (|RetractableTo| (|Integer|)) (|RetractableTo| (|Fraction| (|Integer|))) (|LinearlyExplicitRingOver| (|Integer|)) (|RealConstant|) (|LinearlyExplicitRingOver| (|Fraction| (|Integer|))) (|CharacteristicZero|) (|ConvertibleTo| (|Complex| (|Float|))) (|DifferentialRing|) (CATEGORY |domain| (SIGNATURE |coerce| ($ (|SparseMultivariatePolynomial| (|Integer|) (|Kernel| $)))) (SIGNATURE |numer| ((|SparseMultivariatePolynomial| (|Integer|) (|Kernel| $)) $)) (SIGNATURE |denom| ((|SparseMultivariatePolynomial| (|Integer|) (|Kernel| $)) $)) (SIGNATURE |reduce| ($ $)) (SIGNATURE |trueEqual| ((|Boolean|) $ $)) (SIGNATURE |norm| ((|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $) (|Kernel| $))) (SIGNATURE |norm| ((|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $) (|List| (|Kernel| $)))) (SIGNATURE |norm| ($ $ (|Kernel| $))) (SIGNATURE |norm| ($ $ (|List| (|Kernel| $))))))   has no 
============================================================================

(|FunctionSpace| (|Integer|))    finalizing nrlib IAN 

============================================================================

   finalizing nrlib INEP 
   Warnings: 
      [1] charpol: :(PositiveInteger) -- should replace by pretend
      [2] unknown Functor code (error unsupported matrix type)

============================================================================

   finalizing nrlib INFSP 
   Warnings: 
      [1] evaluate: not known that (Ring) is of mode (CATEGORY package (SIGNATURE innerSolve1 ((List F) (SparseUnivariatePolynomial K) Par)) (SIGNATURE innerSolve1 ((List F) (Polynomial K) Par)) (SIGNATURE innerSolve ((List (List F)) (List (Polynomial K)) (List (Polynomial K)) (List (Symbol)) Par)) (SIGNATURE makeEq ((List (Equation (Polynomial F))) (List F) (List (Symbol)))))
      [2] innerSolve1: not known that (UnivariatePolynomialCategory (Complex (Integer))) is of mode (CATEGORY domain (SIGNATURE outputForm ((OutputForm) $ (OutputForm))) (SIGNATURE fmecg ($ $ (NonNegativeInteger) K $)))
      [3] innerSolve1: pretend(List F) -- should replace by @
      [4] innerSolve: pretenddmp -- should replace by @
      [5] innerSolve:  lq has no value
      [6] innerSolve: not known that (PolynomialCategory K (DirectProduct (# lv) (NonNegativeInteger)) OV) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [7] innerSolve: not known that (PolynomialCategory K (DirectProduct (call LENGTH lv) (NonNegativeInteger)) OV) is of mode (CATEGORY domain (SIGNATURE reorder ($ $ (List (Integer)))))
      [8] innerSolve: pretend(List dmp) -- should replace by @
      [9] innerSolve:  listGen has no value
      [10] innerSolve:  result has no value

============================================================================

   finalizing nrlib INTAF 
   Warnings: 
      [1] rootintegrate: not known that (Ring) is of mode (CATEGORY package (SIGNATURE algint ((IntegrationResult F) F (Kernel F) (Kernel F) (Mapping (SparseUnivariatePolynomial F) (SparseUnivariatePolynomial F)))))
      [2] rootintegrate: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE algint ((IntegrationResult F) F (Kernel F) (Kernel F) (Mapping (SparseUnivariatePolynomial F) (SparseUnivariatePolynomial F)))))
      [3] UP2UPUP: not known that (Ring) is of mode (CATEGORY package (SIGNATURE algint ((IntegrationResult F) F (Kernel F) (Kernel F) (Mapping (SparseUnivariatePolynomial F) (SparseUnivariatePolynomial F)))))

============================================================================

   finalizing nrlib INTALG 
   Warnings: 
      [1] R2UP: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE algintegrate ((IntegrationResult R) R (Mapping UP UP))) (SIGNATURE palgintegrate ((IntegrationResult R) R (Mapping UP UP))) (SIGNATURE palginfieldint ((Union R failed) R (Mapping UP UP))))
      [2] R2UP: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE algintegrate ((IntegrationResult R) R (Mapping UP UP))) (SIGNATURE palgintegrate ((IntegrationResult R) R (Mapping UP UP))) (SIGNATURE palginfieldint ((Union R failed) R (Mapping UP UP))))
      [3] R2UP: not known that (Ring) is of mode (CATEGORY package (SIGNATURE algintegrate ((IntegrationResult R) R (Mapping UP UP))) (SIGNATURE palgintegrate ((IntegrationResult R) R (Mapping UP UP))) (SIGNATURE palginfieldint ((Union R failed) R (Mapping UP UP))))
      [4] univ: not known that (Ring) is of mode (CATEGORY package (SIGNATURE algintegrate ((IntegrationResult R) R (Mapping UP UP))) (SIGNATURE palgintegrate ((IntegrationResult R) R (Mapping UP UP))) (SIGNATURE palginfieldint ((Union R failed) R (Mapping UP UP))))

============================================================================

   finalizing nrlib INTEF 
   Warnings: 
      [1] tanint: not known that (Ring) is of mode (CATEGORY package (SIGNATURE lfextendedint ((Union (Record (: ratpart F) (: coeff F)) failed) F (Symbol) F)) (SIGNATURE lflimitedint ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Symbol) (List F))) (SIGNATURE lfinfieldint ((Union F failed) F (Symbol))) (SIGNATURE lfintegrate ((IntegrationResult F) F (Symbol))) (SIGNATURE lfextlimint ((Union (Record (: ratpart F) (: coeff F)) failed) F (Symbol) (Kernel F) (List (Kernel F)))))
      [2] tanint: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE lfextendedint ((Union (Record (: ratpart F) (: coeff F)) failed) F (Symbol) F)) (SIGNATURE lflimitedint ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Symbol) (List F))) (SIGNATURE lfinfieldint ((Union F failed) F (Symbol))) (SIGNATURE lfintegrate ((IntegrationResult F) F (Symbol))) (SIGNATURE lfextlimint ((Union (Record (: ratpart F) (: coeff F)) failed) F (Symbol) (Kernel F) (List (Kernel F)))))
      [3] unknownint: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE lfextendedint ((Union (Record (: ratpart F) (: coeff F)) failed) F (Symbol) F)) (SIGNATURE lflimitedint ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Symbol) (List F))) (SIGNATURE lfinfieldint ((Union F failed) F (Symbol))) (SIGNATURE lfintegrate ((IntegrationResult F) F (Symbol))) (SIGNATURE lfextlimint ((Union (Record (: ratpart F) (: coeff F)) failed) F (Symbol) (Kernel F) (List (Kernel F)))))
      [4] droponex: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE lfextendedint ((Union (Record (: ratpart F) (: coeff F)) failed) F (Symbol) F)) (SIGNATURE lflimitedint ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Symbol) (List F))) (SIGNATURE lfinfieldint ((Union F failed) F (Symbol))) (SIGNATURE lfintegrate ((IntegrationResult F) F (Symbol))) (SIGNATURE lfextlimint ((Union (Record (: ratpart F) (: coeff F)) failed) F (Symbol) (Kernel F) (List (Kernel F)))))
      [5] alglfint: not known that (Ring) is of mode (CATEGORY package (SIGNATURE lfextendedint ((Union (Record (: ratpart F) (: coeff F)) failed) F (Symbol) F)) (SIGNATURE lflimitedint ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Symbol) (List F))) (SIGNATURE lfinfieldint ((Union F failed) F (Symbol))) (SIGNATURE lfintegrate ((IntegrationResult F) F (Symbol))) (SIGNATURE lfextlimint ((Union (Record (: ratpart F) (: coeff F)) failed) F (Symbol) (Kernel F) (List (Kernel F)))))

============================================================================

   finalizing nrlib INTG0 
   Warnings: 
      [1] kerdiff: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE palgint0 ((IntegrationResult F) F (Kernel F) (Kernel F) F (SparseUnivariatePolynomial F))) (SIGNATURE palgint0 ((IntegrationResult F) F (Kernel F) (Kernel F) (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE palgextint0 ((Union (Record (: ratpart F) (: coeff F)) failed) F (Kernel F) (Kernel F) F F (SparseUnivariatePolynomial F))) (SIGNATURE palgextint0 ((Union (Record (: ratpart F) (: coeff F)) failed) F (Kernel F) (Kernel F) F (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE palglimint0 ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Kernel F) (Kernel F) (List F) F (SparseUnivariatePolynomial F))) (SIGNATURE palglimint0 ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Kernel F) (Kernel F) (List F) (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE palgRDE0 ((Union F failed) F F (Kernel F) (Kernel F) (Mapping (Union F failed) F F (Symbol)) F (SparseUnivariatePolynomial F))) (SIGNATURE palgRDE0 ((Union F failed) F F (Kernel F) (Kernel F) (Mapping (Union F failed) F F (Symbol)) (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE univariate ((SparseUnivariatePolynomial (Fraction (SparseUnivariatePolynomial F))) F (Kernel F) (Kernel F) (SparseUnivariatePolynomial F))) (SIGNATURE multivariate (F (SparseUnivariatePolynomial (Fraction (SparseUnivariatePolynomial F))) (Kernel F) F)) (SIGNATURE lift ((SparseUnivariatePolynomial (Fraction (SparseUnivariatePolynomial F))) (SparseUnivariatePolynomial F) (Kernel F))) (IF (has L (LinearOrdinaryDifferentialOperatorCategory F)) (PROGN (SIGNATURE palgLODE0 ((Record (: particular (Union F failed)) (: basis (List F))) L F (Kernel F) (Kernel F) F (SparseUnivariatePolynomial F))) (SIGNATURE palgLODE0 ((Record (: particular (Union F failed)) (: basis (List F))) L F (Kernel F) (Kernel F) (Kernel F) F (Fraction (SparseUnivariatePolynomial F))))) noBranch))
      [2] univ: not known that (Ring) is of mode (CATEGORY package (SIGNATURE palgint0 ((IntegrationResult F) F (Kernel F) (Kernel F) F (SparseUnivariatePolynomial F))) (SIGNATURE palgint0 ((IntegrationResult F) F (Kernel F) (Kernel F) (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE palgextint0 ((Union (Record (: ratpart F) (: coeff F)) failed) F (Kernel F) (Kernel F) F F (SparseUnivariatePolynomial F))) (SIGNATURE palgextint0 ((Union (Record (: ratpart F) (: coeff F)) failed) F (Kernel F) (Kernel F) F (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE palglimint0 ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Kernel F) (Kernel F) (List F) F (SparseUnivariatePolynomial F))) (SIGNATURE palglimint0 ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Kernel F) (Kernel F) (List F) (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE palgRDE0 ((Union F failed) F F (Kernel F) (Kernel F) (Mapping (Union F failed) F F (Symbol)) F (SparseUnivariatePolynomial F))) (SIGNATURE palgRDE0 ((Union F failed) F F (Kernel F) (Kernel F) (Mapping (Union F failed) F F (Symbol)) (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE univariate ((SparseUnivariatePolynomial (Fraction (SparseUnivariatePolynomial F))) F (Kernel F) (Kernel F) (SparseUnivariatePolynomial F))) (SIGNATURE multivariate (F (SparseUnivariatePolynomial (Fraction (SparseUnivariatePolynomial F))) (Kernel F) F)) (SIGNATURE lift ((SparseUnivariatePolynomial (Fraction (SparseUnivariatePolynomial F))) (SparseUnivariatePolynomial F) (Kernel F))) (IF (has L (LinearOrdinaryDifferentialOperatorCategory F)) (PROGN (SIGNATURE palgLODE0 ((Record (: particular (Union F failed)) (: basis (List F))) L F (Kernel F) (Kernel F) F (SparseUnivariatePolynomial F))) (SIGNATURE palgLODE0 ((Record (: particular (Union F failed)) (: basis (List F))) L F (Kernel F) (Kernel F) (Kernel F) F (Fraction (SparseUnivariatePolynomial F))))) noBranch))
      [3] univ: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE palgint0 ((IntegrationResult F) F (Kernel F) (Kernel F) F (SparseUnivariatePolynomial F))) (SIGNATURE palgint0 ((IntegrationResult F) F (Kernel F) (Kernel F) (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE palgextint0 ((Union (Record (: ratpart F) (: coeff F)) failed) F (Kernel F) (Kernel F) F F (SparseUnivariatePolynomial F))) (SIGNATURE palgextint0 ((Union (Record (: ratpart F) (: coeff F)) failed) F (Kernel F) (Kernel F) F (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE palglimint0 ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Kernel F) (Kernel F) (List F) F (SparseUnivariatePolynomial F))) (SIGNATURE palglimint0 ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Kernel F) (Kernel F) (List F) (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE palgRDE0 ((Union F failed) F F (Kernel F) (Kernel F) (Mapping (Union F failed) F F (Symbol)) F (SparseUnivariatePolynomial F))) (SIGNATURE palgRDE0 ((Union F failed) F F (Kernel F) (Kernel F) (Mapping (Union F failed) F F (Symbol)) (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE univariate ((SparseUnivariatePolynomial (Fraction (SparseUnivariatePolynomial F))) F (Kernel F) (Kernel F) (SparseUnivariatePolynomial F))) (SIGNATURE multivariate (F (SparseUnivariatePolynomial (Fraction (SparseUnivariatePolynomial F))) (Kernel F) F)) (SIGNATURE lift ((SparseUnivariatePolynomial (Fraction (SparseUnivariatePolynomial F))) (SparseUnivariatePolynomial F) (Kernel F))) (IF (has L (LinearOrdinaryDifferentialOperatorCategory F)) (PROGN (SIGNATURE palgLODE0 ((Record (: particular (Union F failed)) (: basis (List F))) L F (Kernel F) (Kernel F) F (SparseUnivariatePolynomial F))) (SIGNATURE palgLODE0 ((Record (: particular (Union F failed)) (: basis (List F))) L F (Kernel F) (Kernel F) (Kernel F) F (Fraction (SparseUnivariatePolynomial F))))) noBranch))
      [4] palgint0: not known that (Ring) is of mode (CATEGORY package (SIGNATURE palgint0 ((IntegrationResult F) F (Kernel F) (Kernel F) F (SparseUnivariatePolynomial F))) (SIGNATURE palgint0 ((IntegrationResult F) F (Kernel F) (Kernel F) (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE palgextint0 ((Union (Record (: ratpart F) (: coeff F)) failed) F (Kernel F) (Kernel F) F F (SparseUnivariatePolynomial F))) (SIGNATURE palgextint0 ((Union (Record (: ratpart F) (: coeff F)) failed) F (Kernel F) (Kernel F) F (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE palglimint0 ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Kernel F) (Kernel F) (List F) F (SparseUnivariatePolynomial F))) (SIGNATURE palglimint0 ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Kernel F) (Kernel F) (List F) (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE palgRDE0 ((Union F failed) F F (Kernel F) (Kernel F) (Mapping (Union F failed) F F (Symbol)) F (SparseUnivariatePolynomial F))) (SIGNATURE palgRDE0 ((Union F failed) F F (Kernel F) (Kernel F) (Mapping (Union F failed) F F (Symbol)) (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE univariate ((SparseUnivariatePolynomial (Fraction (SparseUnivariatePolynomial F))) F (Kernel F) (Kernel F) (SparseUnivariatePolynomial F))) (SIGNATURE multivariate (F (SparseUnivariatePolynomial (Fraction (SparseUnivariatePolynomial F))) (Kernel F) F)) (SIGNATURE lift ((SparseUnivariatePolynomial (Fraction (SparseUnivariatePolynomial F))) (SparseUnivariatePolynomial F) (Kernel F))) (IF (has L (LinearOrdinaryDifferentialOperatorCategory F)) (PROGN (SIGNATURE palgLODE0 ((Record (: particular (Union F failed)) (: basis (List F))) L F (Kernel F) (Kernel F) F (SparseUnivariatePolynomial F))) (SIGNATURE palgLODE0 ((Record (: particular (Union F failed)) (: basis (List F))) L F (Kernel F) (Kernel F) (Kernel F) F (Fraction (SparseUnivariatePolynomial F))))) noBranch))
      [5] palgint0: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE palgint0 ((IntegrationResult F) F (Kernel F) (Kernel F) F (SparseUnivariatePolynomial F))) (SIGNATURE palgint0 ((IntegrationResult F) F (Kernel F) (Kernel F) (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE palgextint0 ((Union (Record (: ratpart F) (: coeff F)) failed) F (Kernel F) (Kernel F) F F (SparseUnivariatePolynomial F))) (SIGNATURE palgextint0 ((Union (Record (: ratpart F) (: coeff F)) failed) F (Kernel F) (Kernel F) F (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE palglimint0 ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Kernel F) (Kernel F) (List F) F (SparseUnivariatePolynomial F))) (SIGNATURE palglimint0 ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Kernel F) (Kernel F) (List F) (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE palgRDE0 ((Union F failed) F F (Kernel F) (Kernel F) (Mapping (Union F failed) F F (Symbol)) F (SparseUnivariatePolynomial F))) (SIGNATURE palgRDE0 ((Union F failed) F F (Kernel F) (Kernel F) (Mapping (Union F failed) F F (Symbol)) (Kernel F) F (Fraction (SparseUnivariatePolynomial F)))) (SIGNATURE univariate ((SparseUnivariatePolynomial (Fraction (SparseUnivariatePolynomial F))) F (Kernel F) (Kernel F) (SparseUnivariatePolynomial F))) (SIGNATURE multivariate (F (SparseUnivariatePolynomial (Fraction (SparseUnivariatePolynomial F))) (Kernel F) F)) (SIGNATURE lift ((SparseUnivariatePolynomial (Fraction (SparseUnivariatePolynomial F))) (SparseUnivariatePolynomial F) (Kernel F))) (IF (has L (LinearOrdinaryDifferentialOperatorCategory F)) (PROGN (SIGNATURE palgLODE0 ((Record (: particular (Union F failed)) (: basis (List F))) L F (Kernel F) (Kernel F) F (SparseUnivariatePolynomial F))) (SIGNATURE palgLODE0 ((Record (: particular (Union F failed)) (: basis (List F))) L F (Kernel F) (Kernel F) (Kernel F) F (Fraction (SparseUnivariatePolynomial F))))) noBranch))
      [6] palgRDE0:  var has no value
      [7] palgRDE0:  coeff has no value

============================================================================

   finalizing nrlib INTHERAL 
   Warnings: 
      [1] HermiteIntegrate: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE HermiteIntegrate ((Record (: answer R) (: logpart R)) R (Mapping UP UP))))
      [2] localsolve:  coef1 has no value

============================================================================

   finalizing nrlib INTPAF 
   Warnings: 
      [1] UPUP2F0: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE palgint ((IntegrationResult F) F (Kernel F) (Kernel F))) (SIGNATURE palgextint ((Union (Record (: ratpart F) (: coeff F)) failed) F (Kernel F) (Kernel F) F)) (SIGNATURE palglimint ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Kernel F) (Kernel F) (List F))) (SIGNATURE palgRDE ((Union F failed) F F F (Kernel F) (Kernel F) (Mapping (Union F failed) F F (Symbol)))) (IF (has L (LinearOrdinaryDifferentialOperatorCategory F)) (SIGNATURE palgLODE ((Record (: particular (Union F failed)) (: basis (List F))) L F (Kernel F) (Kernel F) (Symbol))) noBranch))
      [2] chv: not known that (Ring) is of mode (CATEGORY package (SIGNATURE palgint ((IntegrationResult F) F (Kernel F) (Kernel F))) (SIGNATURE palgextint ((Union (Record (: ratpart F) (: coeff F)) failed) F (Kernel F) (Kernel F) F)) (SIGNATURE palglimint ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Kernel F) (Kernel F) (List F))) (SIGNATURE palgRDE ((Union F failed) F F F (Kernel F) (Kernel F) (Mapping (Union F failed) F F (Symbol)))) (IF (has L (LinearOrdinaryDifferentialOperatorCategory F)) (SIGNATURE palgLODE ((Record (: particular (Union F failed)) (: basis (List F))) L F (Kernel F) (Kernel F) (Symbol))) noBranch))
      [3] linearInXIfCan: not known that (Ring) is of mode (CATEGORY package (SIGNATURE palgint ((IntegrationResult F) F (Kernel F) (Kernel F))) (SIGNATURE palgextint ((Union (Record (: ratpart F) (: coeff F)) failed) F (Kernel F) (Kernel F) F)) (SIGNATURE palglimint ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Kernel F) (Kernel F) (List F))) (SIGNATURE palgRDE ((Union F failed) F F F (Kernel F) (Kernel F) (Mapping (Union F failed) F F (Symbol)))) (IF (has L (LinearOrdinaryDifferentialOperatorCategory F)) (SIGNATURE palgLODE ((Record (: particular (Union F failed)) (: basis (List F))) L F (Kernel F) (Kernel F) (Symbol))) noBranch))
      [4] linearInXIfCan: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE palgint ((IntegrationResult F) F (Kernel F) (Kernel F))) (SIGNATURE palgextint ((Union (Record (: ratpart F) (: coeff F)) failed) F (Kernel F) (Kernel F) F)) (SIGNATURE palglimint ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Kernel F) (Kernel F) (List F))) (SIGNATURE palgRDE ((Union F failed) F F F (Kernel F) (Kernel F) (Mapping (Union F failed) F F (Symbol)))) (IF (has L (LinearOrdinaryDifferentialOperatorCategory F)) (SIGNATURE palgLODE ((Record (: particular (Union F failed)) (: basis (List F))) L F (Kernel F) (Kernel F) (Symbol))) noBranch))
      [5] prootintegrate1: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE palgint ((IntegrationResult F) F (Kernel F) (Kernel F))) (SIGNATURE palgextint ((Union (Record (: ratpart F) (: coeff F)) failed) F (Kernel F) (Kernel F) F)) (SIGNATURE palglimint ((Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (Kernel F) (Kernel F) (List F))) (SIGNATURE palgRDE ((Union F failed) F F F (Kernel F) (Kernel F) (Mapping (Union F failed) F F (Symbol)))) (IF (has L (LinearOrdinaryDifferentialOperatorCategory F)) (SIGNATURE palgLODE ((Record (: particular (Union F failed)) (: basis (List F))) L F (Kernel F) (Kernel F) (Symbol))) noBranch))
      [6] candidates:  l has no value

============================================================================

   finalizing nrlib INTPM 
   Warnings: 
      [1] splitConstant: more than 1 modemap for: (One) with dc=F ===>(((F F) ((has R (SemiGroup)) (CONST F ($)))) ((F F) (T (CONST F ($)))))
      [2] matcherfei: not known that (SetCategory) is of mode (CATEGORY domain (SIGNATURE pmintegrate ((Union (Record (: special F) (: integrand F)) failed) F (Symbol))))
      [3] matchdilog: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE pmintegrate ((Union (Record (: special F) (: integrand F)) failed) F (Symbol))))
      [4] matchdilog0: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE pmintegrate ((Union (Record (: special F) (: integrand F)) failed) F (Symbol))))
      [5] matchdilog0: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE pmintegrate ((Union (Record (: special F) (: integrand F)) failed) F (Symbol))))
      [6] matchli0: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE pmintegrate ((Union (Record (: special F) (: integrand F)) failed) F (Symbol))))
      [7] matchsici:  ci0? has no value
      [8] pmintegrate:  const has no value
      [9] pmintegrate:  nconst has no value
      [10] pmComplexintegrate:  const has no value
      [11] pmComplexintegrate:  nconst has no value
      [12] formula1: not known that (OrderedSet) is of mode (CATEGORY $ (SIGNATURE pmintegrate ((Union F failed) F (Symbol) (OrderedCompletion F) (OrderedCompletion F))))

============================================================================

   finalizing nrlib INTTOOLS 
   Warnings: 
      [1] varselect: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE varselect ((List (Kernel F)) (List (Kernel F)) (Symbol))) (SIGNATURE kmax ((Kernel F) (List (Kernel F)))) (SIGNATURE ksec ((Kernel F) (Kernel F) (List (Kernel F)) (Symbol))) (SIGNATURE union ((List (Kernel F)) (List (Kernel F)) (List (Kernel F)))) (SIGNATURE vark ((List (Kernel F)) (List F) (Symbol))) (IF (has R (IntegralDomain)) (SIGNATURE removeConstantTerm (F F (Symbol))) noBranch) (IF (has R (GcdDomain)) (IF (has F (ElementaryFunctionCategory)) (PROGN (SIGNATURE mkPrim (F F (Symbol))) (IF (has R (ConvertibleTo (Pattern (Integer)))) (IF (has R (PatternMatchable (Integer))) (IF (has F (LiouvillianFunctionCategory)) (IF (has F (RetractableTo (Symbol))) (SIGNATURE intPatternMatch ((IntegrationResult F) F (Symbol) (Mapping (IntegrationResult F) F (Symbol)) (Mapping (Union (Record (: special F) (: integrand F)) failed) F (Symbol)))) noBranch) noBranch) noBranch) noBranch)) noBranch) noBranch))
      [2] vark: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE varselect ((List (Kernel F)) (List (Kernel F)) (Symbol))) (SIGNATURE kmax ((Kernel F) (List (Kernel F)))) (SIGNATURE ksec ((Kernel F) (Kernel F) (List (Kernel F)) (Symbol))) (SIGNATURE union ((List (Kernel F)) (List (Kernel F)) (List (Kernel F)))) (SIGNATURE vark ((List (Kernel F)) (List F) (Symbol))) (IF (has R (IntegralDomain)) (SIGNATURE removeConstantTerm (F F (Symbol))) noBranch) (IF (has R (GcdDomain)) (IF (has F (ElementaryFunctionCategory)) (PROGN (SIGNATURE mkPrim (F F (Symbol))) (IF (has R (ConvertibleTo (Pattern (Integer)))) (IF (has R (PatternMatchable (Integer))) (IF (has F (LiouvillianFunctionCategory)) (IF (has F (RetractableTo (Symbol))) (SIGNATURE intPatternMatch ((IntegrationResult F) F (Symbol) (Mapping (IntegrationResult F) F (Symbol)) (Mapping (Union (Record (: special F) (: integrand F)) failed) F (Symbol)))) noBranch) noBranch) noBranch) noBranch)) noBranch) noBranch))
      [3] removeConstantTerm: not known that (OrderedSet) is of mode (CATEGORY $ (SIGNATURE removeConstantTerm (F F (Symbol))))
      [4] removeConstantTerm:  ans has no value
      [5] cont: not known that (Ring) is of mode (CATEGORY $ (SIGNATURE mkPrim (F F (Symbol))))
      [6] cont:  unit has no value
      [7] linearLog?: not known that (Ring) is of mode (CATEGORY $ (SIGNATURE mkPrim (F F (Symbol))))
      [8] intPatternMatch:  nl has no value

============================================================================

   finalizing nrlib ITRIGMNP 
   Warnings: 
      [1] FG2F: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE GF2FG (FG (Complex F))) (SIGNATURE FG2F (F FG)) (SIGNATURE F2FG (FG F)) (SIGNATURE explogs2trigs ((Complex F) FG)) (SIGNATURE trigs2explogs (FG FG (List (Kernel FG)) (List (Symbol)))))
      [2] ker2explogs:  IN has no value
      [3] ker2explogs:  v has no value
      [4] ker2explogs: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE GF2FG (FG (Complex F))) (SIGNATURE FG2F (F FG)) (SIGNATURE F2FG (FG F)) (SIGNATURE explogs2trigs ((Complex F) FG)) (SIGNATURE trigs2explogs (FG FG (List (Kernel FG)) (List (Symbol)))))
      [5] ker2explogs:  a has no value
      [6] ker2trigs:  IN has no value
      [7] explogs2trigs: not known that (Ring) is of mode (CATEGORY package (SIGNATURE GF2FG (FG (Complex F))) (SIGNATURE FG2F (F FG)) (SIGNATURE F2FG (FG F)) (SIGNATURE explogs2trigs ((Complex F) FG)) (SIGNATURE trigs2explogs (FG FG (List (Kernel FG)) (List (Symbol)))))

============================================================================

   finalizing nrlib KOVACIC 
   Warnings: 
      [1] kovacic: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE kovacic ((Union (SparseUnivariatePolynomial (Fraction UP)) failed) (Fraction UP) (Fraction UP) (Fraction UP))) (SIGNATURE kovacic ((Union (SparseUnivariatePolynomial (Fraction UP)) failed) (Fraction UP) (Fraction UP) (Fraction UP) (Mapping (Factored UP) UP))))

============================================================================

   finalizing nrlib LF 
   Warnings: 
      [1] integrand: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE Ei (F F)) (SIGNATURE Si (F F)) (SIGNATURE Ci (F F)) (SIGNATURE li (F F)) (SIGNATURE erf (F F)) (SIGNATURE dilog (F F)) (SIGNATURE integral (F F (Symbol))) (SIGNATURE integral (F F (SegmentBinding F))))
      [2] eqint: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE Ei (F F)) (SIGNATURE Si (F F)) (SIGNATURE Ci (F F)) (SIGNATURE li (F F)) (SIGNATURE erf (F F)) (SIGNATURE dilog (F F)) (SIGNATURE integral (F F (Symbol))) (SIGNATURE integral (F F (SegmentBinding F))))

============================================================================

   finalizing nrlib LODOF 
   Warnings: 
      [1] factor: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE factor ((List (LinearOrdinaryDifferentialOperator1 (Fraction UP))) (LinearOrdinaryDifferentialOperator1 (Fraction UP)) (Mapping (List F) UP))) (IF (has F (AlgebraicallyClosedField)) (PROGN (SIGNATURE factor ((List (LinearOrdinaryDifferentialOperator1 (Fraction UP))) (LinearOrdinaryDifferentialOperator1 (Fraction UP)))) (SIGNATURE factor1 ((List (LinearOrdinaryDifferentialOperator1 (Fraction UP))) (LinearOrdinaryDifferentialOperator1 (Fraction UP))))) noBranch))
      [2] zro1: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE factor1 ((List (LinearOrdinaryDifferentialOperator1 (Fraction UP))) (LinearOrdinaryDifferentialOperator1 (Fraction UP)))))

============================================================================

   finalizing nrlib LSQM 
   Warnings: 
      [1] not known that (NonAssociativeAlgebra R) is of mode (CATEGORY domain (SIGNATURE transpose ($ $)) (SIGNATURE squareMatrix ($ (Matrix R))) (SIGNATURE coerce ((Matrix R) $)) (IF (has R (ATTRIBUTE (commutative *))) (ATTRIBUTE central) noBranch) (IF (has R (ATTRIBUTE (commutative *))) (IF (has R (ATTRIBUTE unitsKnown)) (ATTRIBUTE unitsKnown) noBranch) noBranch) (IF (has R (ConvertibleTo (InputForm))) (ATTRIBUTE (ConvertibleTo (InputForm))) noBranch))

--------------non extending category----------------------
.. LieSquareMatrix(#1,#2) of cat 
(|Join| (|SquareMatrixCategory| |#1| |#2| (|DirectProduct| |#1| |#2|) (|DirectProduct| |#1| |#2|)) (|CoercibleTo| (|Matrix| |#2|)) (|FramedNonAssociativeAlgebra| |#2|))   has no 
============================================================================

(|CoercibleTo| (|SquareMatrix| |#1| |#2|))    finalizing nrlib LSQM 

============================================================================

   finalizing nrlib OMEXPR 
   Warnings: 
      [1] outputOMFunction:  %defint has no value
      [2] outputOMFunction:  %defsum has no value
      [3] outputOMFunction:  %defprod has no value
      [4] outputOMFunction:  %power has no value
      [5] outputOMExpr: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE OMwrite ((String) (Expression R))) (SIGNATURE OMwrite ((String) (Expression R) (Boolean))) (SIGNATURE OMwrite ((Void) (OpenMathDevice) (Expression R))) (SIGNATURE OMwrite ((Void) (OpenMathDevice) (Expression R) (Boolean))))
      [6] OMwrite: pretend(String) -- should replace by @

============================================================================

   finalizing nrlib OMEXPR 
--->/research2/test0819/mnt/fedora5/../../src/algebra/OMEXPR.spad-->ExpressionToOpenMath((OMwrite ((String) (Expression R)))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/OMEXPR.spad-->ExpressionToOpenMath((OMwrite ((String) (Expression R) (Boolean)))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/OMEXPR.spad-->ExpressionToOpenMath((OMwrite ((Void) (OpenMathDevice) (Expression R)))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/OMEXPR.spad-->ExpressionToOpenMath((OMwrite ((Void) (OpenMathDevice) (Expression R) (Boolean)))): Not documented!!!!

--------------non extending category----------------------
.. MachineComplex of cat 
(|Join| (|FortranMachineTypeCategory|) (|ComplexCategory| (|MachineFloat|)) (CATEGORY |domain| (SIGNATURE |coerce| ($ (|Complex| (|Float|)))) (SIGNATURE |coerce| ($ (|Complex| (|Integer|)))) (SIGNATURE |coerce| ($ (|Complex| (|MachineFloat|)))) (SIGNATURE |coerce| ($ (|Complex| (|MachineInteger|)))) (SIGNATURE |coerce| ((|Complex| (|Float|)) $))))   has no 
============================================================================

(IF (|has| (|MachineFloat|) (|OpenMath|)) (ATTRIBUTE (|OpenMath|)) |noBranch|)    finalizing nrlib MCMPLX 

============================================================================

   finalizing nrlib MULTFACT 
   Warnings: 
      [1] factor: not known that (OrderedSet) is of mode (CATEGORY OV (SIGNATURE convert ((Symbol) $)))

============================================================================

   finalizing nrlib NAGD01 
   Warnings: 
      [1] d01ajf:  fn has no value
      [2] d01ajf:  fp has no value
      [3] d01ajf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [4] d01akf:  fn has no value
      [5] d01akf:  fp has no value
      [6] d01akf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [7] d01alf:  fn has no value
      [8] d01alf:  fp has no value
      [9] d01alf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [10] d01amf:  fn has no value
      [11] d01amf:  fp has no value
      [12] d01amf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [13] d01anf:  fn has no value
      [14] d01anf:  fp has no value
      [15] d01anf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [16] d01apf:  fn has no value
      [17] d01apf:  fp has no value
      [18] d01apf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [19] d01aqf:  fn has no value
      [20] d01aqf:  fp has no value
      [21] d01aqf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [22] d01asf:  fn has no value
      [23] d01asf:  fp has no value
      [24] d01asf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [25] d01bbf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [26] d01fcf:  fn has no value
      [27] d01fcf:  fp has no value
      [28] d01fcf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [29] d01gaf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [30] d01gbf:  fn has no value
      [31] d01gbf:  fp has no value
      [32] d01gbf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
 
============================================================================

   finalizing nrlib NAGD01 
--->/research2/test0819/mnt/fedora5/../../src/algebra/NAGD01.spad-->NagIntegrationPackage((d01asf ((Result) (DoubleFloat) (DoubleFloat) (Integer) (DoubleFloat) (Integer) (Integer) (Integer) (Integer) (Union (: fn (FileName)) (: fp (Asp1 G)))))): Mismatch: left bracket matches right pren
"\\spad{d01asf(a,{}omega,{}key,{}epsabs,{}limlst,{}lw,{}liw,{}ifail,{}g)} calculates an approximation to the sine or the cosine transform of a function \\spad{g} over [a,{}infty): See \\downlink{Manual Page}{manpageXXd01asf}."

============================================================================

   finalizing nrlib NAGD02 
   Warnings: 
      [1] d02bbf:  fn has no value
      [2] d02bbf:  fp has no value
      [3] d02bbf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [4] d02bhf:  fn has no value
      [5] d02bhf:  fp has no value
      [6] d02bhf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [7] d02cjf:  fn has no value
      [8] d02cjf:  fp has no value
      [9] d02cjf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [10] d02ejf:  fn has no value
      [11] d02ejf:  fp has no value
      [12] d02ejf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [13] d02gaf:  fn has no value
      [14] d02gaf:  fp has no value
      [15] d02gaf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [16] d02gbf:  fn has no value
      [17] d02gbf:  fp has no value
      [18] d02gbf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [19] d02kef:  fn has no value
      [20] d02kef:  fp has no value
      [21] d02kef: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [22] d02raf:  fn has no value
      [23] d02raf:  fp has no value
      [24] d02raf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @

============================================================================

   finalizing nrlib NAGF01 
   Warnings: 
      [1] f01brf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [2] f01bsf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [3] f01maf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [4] f01mcf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [5] f01qcf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [6] f01qdf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [7] f01qef: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [8] f01rcf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [9] f01rdf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [10] f01ref: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @

============================================================================

   finalizing nrlib NAGF02 
   Warnings: 
      [1] f02aaf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [2] f02abf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [3] f02adf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [4] f02aef: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [5] f02aff: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [6] f02agf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [7] f02ajf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [8] f02akf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [9] f02awf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [10] f02axf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [11] f02bbf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [12] f02bjf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [13] f02fjf:  fn has no value
      [14] f02fjf:  fp has no value
      [15] f02fjf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [16] f02wef: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [17] f02xef: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @

============================================================================

   finalizing nrlib NAGF04 
   Warnings: 
      [1] f04adf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [2] f04arf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [3] f04asf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [4] f04atf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [5] f04axf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [6] f04faf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [7] f04jgf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [8] f04maf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [9] f04mbf:  fn has no value
      [10] f04mbf:  fp has no value
      [11] f04mbf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [12] f04mcf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @
      [13] f04qaf:  fn has no value
      [14] f04qaf:  fp has no value
      [15] f04qaf: pretend(List (Record (: key (Symbol)) (: entry (Any)))) -- should replace by @

============================================================================

   finalizing nrlib NLINSOL 
   Warnings: 
      [1] allRoots: not known that (Ring) is of mode (CATEGORY package (SIGNATURE solveInField ((List (List (Equation (Fraction (Polynomial R))))) (List (Polynomial R)) (List (Symbol)))) (SIGNATURE solveInField ((List (List (Equation (Fraction (Polynomial R))))) (List (Polynomial R)))) (SIGNATURE solve ((List (List (Equation (Fraction (Polynomial R))))) (List (Polynomial R)) (List (Symbol)))) (SIGNATURE solve ((List (List (Equation (Fraction (Polynomial R))))) (List (Polynomial R)))))

============================================================================

   finalizing nrlib NSMP 
   Warnings: 
      [1] monicModulo:  mM has no value

============================================================================

   finalizing nrlib ODERTRIC 
   Semantic Errors: 
      [1]  RatODETools is not a known type
 
   Warnings: 
      [1] ricDsolve: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE ricDsolve ((List (Fraction UP)) (LinearOrdinaryDifferentialOperator1 (Fraction UP)) (Mapping (List F) UP))) (SIGNATURE ricDsolve ((List (Fraction UP)) (LinearOrdinaryDifferentialOperator1 (Fraction UP)) (Mapping (List F) UP) (Mapping (Factored UP) UP))) (SIGNATURE ricDsolve ((List (Fraction UP)) (LinearOrdinaryDifferentialOperator2 UP (Fraction UP)) (Mapping (List F) UP))) (SIGNATURE ricDsolve ((List (Fraction UP)) (LinearOrdinaryDifferentialOperator2 UP (Fraction UP)) (Mapping (List F) UP) (Mapping (Factored UP) UP))) (SIGNATURE singRicDE ((List (Record (: frac (Fraction UP)) (: eq (LinearOrdinaryDifferentialOperator2 UP (Fraction UP))))) (LinearOrdinaryDifferentialOperator2 UP (Fraction UP)) (Mapping (Factored UP) UP))) (SIGNATURE polyRicDE ((List (Record (: poly UP) (: eq (LinearOrdinaryDifferentialOperator2 UP (Fraction UP))))) (LinearOrdinaryDifferentialOperator2 UP (Fraction UP)) (Mapping (List F) UP))) (IF (has F (AlgebraicallyClosedField)) (PROGN (SIGNATURE ricDsolve ((List (Fraction UP)) (LinearOrdinaryDifferentialOperator1 (Fraction UP)))) (SIGNATURE ricDsolve ((List (Fraction UP)) (LinearOrdinaryDifferentialOperator1 (Fraction UP)) (Mapping (Factored UP) UP))) (SIGNATURE ricDsolve ((List (Fraction UP)) (LinearOrdinaryDifferentialOperator2 UP (Fraction UP)))) (SIGNATURE ricDsolve ((List (Fraction UP)) (LinearOrdinaryDifferentialOperator2 UP (Fraction UP)) (Mapping (Factored UP) UP)))) noBranch))
      [2] ratsln:  ls has no value
      [3] ratsln:  lv has no value
      [4] ratsol:  ans has no value
      [5] polyRicDE:  deg has no value
      [6] polyRicDE:  ans has no value
      [7] newtonSolution:  m has no value
      [8] zro1: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE ricDsolve ((List (Fraction UP)) (LinearOrdinaryDifferentialOperator2 UP (Fraction UP)) (Mapping (Factored UP) UP))))
 
============================================================================

   finalizing nrlib PADE 
   Warnings: 
      [1] padeInner:  plist has no value
      [2] padeInner:  alist has no value

============================================================================

   finalizing nrlib PDEPACK 
--->/research2/test0819/mnt/fedora5/../../src/algebra/PDEPACK.spad-->AnnaPartialDifferentialEquationPackage(constructor): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/PDEPACK.spad-->AnnaPartialDifferentialEquationPackage(): Missing Description

============================================================================

   finalizing nrlib PFO 
   Warnings: 
      [1] klist: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE order ((Union (NonNegativeInteger) failed) (FiniteDivisor F UP UPUP R))) (SIGNATURE torsion? ((Boolean) (FiniteDivisor F UP UPUP R))) (SIGNATURE torsionIfCan ((Union (Record (: order (NonNegativeInteger)) (: function R)) failed) (FiniteDivisor F UP UPUP R))))
      [2] UPQ2F: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE order ((Union (NonNegativeInteger) failed) (FiniteDivisor F UP UPUP R))) (SIGNATURE torsion? ((Boolean) (FiniteDivisor F UP UPUP R))) (SIGNATURE torsionIfCan ((Union (Record (: order (NonNegativeInteger)) (: function R)) failed) (FiniteDivisor F UP UPUP R))))
      [3] commonDen: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE order ((Union (NonNegativeInteger) failed) (FiniteDivisor F UP UPUP R))) (SIGNATURE torsion? ((Boolean) (FiniteDivisor F UP UPUP R))) (SIGNATURE torsionIfCan ((Union (Record (: order (NonNegativeInteger)) (: function R)) failed) (FiniteDivisor F UP UPUP R))))
      [4] selectIntegers: not known that (Ring) is of mode (CATEGORY package (SIGNATURE order ((Union (NonNegativeInteger) failed) (FiniteDivisor F UP UPUP R))) (SIGNATURE torsion? ((Boolean) (FiniteDivisor F UP UPUP R))) (SIGNATURE torsionIfCan ((Union (Record (: order (NonNegativeInteger)) (: function R)) failed) (FiniteDivisor F UP UPUP R))))

Warning: PFO;cmult has a duplicate definition in this file

============================================================================

   finalizing nrlib PMASSFS 
   Warnings: 
      [1] ass: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE assert (F F (String))) (SIGNATURE constant (F F)) (SIGNATURE optional (F F)) (SIGNATURE multiple (F F)))

============================================================================

   finalizing nrlib PMFS 
   Warnings: 
      [1] patternMatch: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE patternMatch ((PatternMatchResult S F) F (Pattern S) (PatternMatchResult S F))))
      [2] patternMatch:  var has no value

============================================================================

   finalizing nrlib PMPREDFS 
   Warnings: 
      [1] suchThat: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE suchThat (F F (Mapping (Boolean) D))) (SIGNATURE suchThat (F F (List (Mapping (Boolean) D)))))

============================================================================

   finalizing nrlib PSETPK 
   Warnings: 
      [1] selectPolynomials:  gps has no value
      [2] selectPolynomials:  bps has no value
      [3] selectOrPolynomials:  gps has no value
      [4] selectOrPolynomials:  bps has no value
      [5] selectAndPolynomials:  gps has no value
      [6] selectAndPolynomials:  bps has no value
      [7] certainlySubVariety?:  polnum has no value
      [8] autoRemainder:  newlp has no value
      [9] rewriteSetByReducingWithParticularGenerators:  rs has no value
      [10] squareFreeFactors: not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE removeRedundantFactorsInPols ((List P) (List P) (List P))))
      [11] univariatePolynomialsGcds:  p has no value
      [12] univariatePolynomialsGcds:  pInV has no value
      [13] univariatePolynomialsGcds:  stop has no value
      [14] univariatePolynomialsGcds:  lg has no value
      [15] removeRoughlyRedundantFactorsInContents:  newcp has no value
      [16] removeRedundantFactorsInContents:  newcp has no value
      [17] removeRedundantFactorsInPols:  newcp has no value
      [18] removeRedundantFactorsInPols:  newp has no value
      [19] unprotectedRemoveRedundantFactors:  d has no value
      [20] removeRedundantFactors:  toSee has no value
      [21] removeRedundantFactors:  toSave has no value

============================================================================

   finalizing nrlib RDEEF 
   Warnings: 
      [1] rischDEalg: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE rischDE ((Record (: ans F) (: right F) (: sol? (Boolean))) (Integer) F F (Symbol) (Mapping (Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (List F)) (Mapping (Union (Record (: ratpart F) (: coeff F)) failed) F F))))
      [2] rischDEalg: not known that (Ring) is of mode (CATEGORY package (SIGNATURE rischDE ((Record (: ans F) (: right F) (: sol? (Boolean))) (Integer) F F (Symbol) (Mapping (Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (List F)) (Mapping (Union (Record (: ratpart F) (: coeff F)) failed) F F))))
      [3] normalise0: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE rischDE ((Record (: ans F) (: right F) (: sol? (Boolean))) (Integer) F F (Symbol) (Mapping (Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (List F)) (Mapping (Union (Record (: ratpart F) (: coeff F)) failed) F F))))
      [4] normalise0: not known that (Ring) is of mode (CATEGORY package (SIGNATURE rischDE ((Record (: ans F) (: right F) (: sol? (Boolean))) (Integer) F F (Symbol) (Mapping (Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (List F)) (Mapping (Union (Record (: ratpart F) (: coeff F)) failed) F F))))
      [5] polyDElog:  limitedlogs has no value
      [6] polyDElog: more than 1 modemap for: (Zero) with dc=F ===>(((F F) ((has R (AbelianSemiGroup)) (CONST F ($)))) ((F F) (T (CONST F ($)))))
      [7] polyDElog:  eq has no value
      [8] polyDEexp:  eq has no value

============================================================================

   finalizing nrlib RDEEFS 
   Warnings: 
      [1] basecase: not known that (Ring) is of mode (CATEGORY package (SIGNATURE rischDEsys ((Union (List F) failed) (Integer) F F F (Symbol) (Mapping (Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (List F)) (Mapping (Union (Record (: ratpart F) (: coeff F)) failed) F F))))
      [2] basecase: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE rischDEsys ((Union (List F) failed) (Integer) F F F (Symbol) (Mapping (Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (List F)) (Mapping (Union (Record (: ratpart F) (: coeff F)) failed) F F))))
      [3] rischDEsys: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE rischDEsys ((Union (List F) failed) (Integer) F F F (Symbol) (Mapping (Union (Record (: mainpart F) (: limitedlogs (List (Record (: coeff F) (: logand F))))) failed) F (List F)) (Mapping (Union (Record (: ratpart F) (: coeff F)) failed) F F))))

============================================================================

   finalizing nrlib RSETCAT- 
   Warnings: 
      [1] intersect:  toSave has no value

============================================================================

   finalizing nrlib RSETCAT 
; (DEFUN |RegularTriangularSetCategory| ...) is being compiled.
;; The variable |RegularTriangularSetCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |RegularTriangularSetCategory;| ...) is being compiled.
;; The variable |RegularTriangularSetCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib RULE 
   Warnings: 
      [1] F2Symbol: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE rule ($ F F)) (SIGNATURE rule ($ F F (List (Symbol)))) (SIGNATURE suchThat ($ $ (List (Symbol)) (Mapping (Boolean) (List F)))) (SIGNATURE pattern ((Pattern Base) $)) (SIGNATURE lhs (F $)) (SIGNATURE rhs (F $)) (SIGNATURE elt (F $ F (PositiveInteger))) (SIGNATURE quotedOperators ((List (Symbol)) $)))
      [2] retractIfCan: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE rule ($ F F)) (SIGNATURE rule ($ F F (List (Symbol)))) (SIGNATURE suchThat ($ $ (List (Symbol)) (Mapping (Boolean) (List F)))) (SIGNATURE pattern ((Pattern Base) $)) (SIGNATURE lhs (F $)) (SIGNATURE rhs (F $)) (SIGNATURE elt (F $ F (PositiveInteger))) (SIGNATURE quotedOperators ((List (Symbol)) $)))

============================================================================

   finalizing nrlib SIMPAN 
   Warnings: 
      [1] simplify: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (IF (has (Integer) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Integer))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Integer) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Integer) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))

   SFORT abbreviates domain SimpleFortranProgram 
(SPADLET |$noSubsumption| (QUOTE T))

============================================================================

   finalizing nrlib SOLVESER 
   Warnings: 
      [1] unvectorise: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE decomposeFunc ((Fraction (SparseUnivariatePolynomial (Expression R))) (Fraction (SparseUnivariatePolynomial (Expression R))) (Fraction (SparseUnivariatePolynomial (Expression R))) (Fraction (SparseUnivariatePolynomial (Expression R))))) (SIGNATURE unvectorise ((Fraction (SparseUnivariatePolynomial (Expression R))) (Vector (Expression R)) (Fraction (SparseUnivariatePolynomial (Expression R))) (Integer))))
      [2] unvectorise: not known that (Ring) is of mode (CATEGORY package (SIGNATURE decomposeFunc ((Fraction (SparseUnivariatePolynomial (Expression R))) (Fraction (SparseUnivariatePolynomial (Expression R))) (Fraction (SparseUnivariatePolynomial (Expression R))) (Fraction (SparseUnivariatePolynomial (Expression R))))) (SIGNATURE unvectorise ((Fraction (SparseUnivariatePolynomial (Expression R))) (Vector (Expression R)) (Fraction (SparseUnivariatePolynomial (Expression R))) (Integer))))

============================================================================

   finalizing nrlib SUMFS 
   Warnings: 
      [1] sum: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE sum (F F (Symbol))) (SIGNATURE sum (F F (SegmentBinding F))))
      [2] notRF?: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE sum (F F (Symbol))) (SIGNATURE sum (F F (SegmentBinding F))))

(|UnivariateTaylorSeriesCategory| |#1|)    extends 
(|UnivariatePowerSeriesCategory| |#1| (|NonNegativeInteger|))    but not 
(|UnivariatePowerSeriesCategory| |#1| (|Integer|)) --------------non extending category----------------------
.. SparseUnivariateTaylorSeries(#1,#2,#3) of cat 
(|Join| (|UnivariateTaylorSeriesCategory| |#1|) (CATEGORY |domain| (SIGNATURE |coerce| ($ (|UnivariatePolynomial| |#2| |#1|))) (SIGNATURE |univariatePolynomial| ((|UnivariatePolynomial| |#2| |#1|) $ (|NonNegativeInteger|))) (SIGNATURE |coerce| ($ (|Variable| |#2|))) (SIGNATURE |differentiate| ($ $ (|Variable| |#2|))) (IF (|has| |#1| (|Algebra| (|Fraction| (|Integer|)))) (SIGNATURE |integrate| ($ $ (|Variable| |#2|))) |noBranch|)))   has no 
============================================================================

(|UnivariatePowerSeriesCategory| |#1| (|Integer|))    finalizing nrlib SUTS 

============================================================================

   finalizing nrlib TOOLSIGN 
   Warnings: 
      [1] nonQsign: pretend(AlgebraicNumber) -- should replace by @
      [2] nonQsign: not known that (AlgebraicallyClosedField) is of mode (CATEGORY domain (IF (has (Integer) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Integer))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Integer) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Integer) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [3] nonQsign: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (IF (has (Integer) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Integer))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Integer) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Integer) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))

============================================================================

   finalizing nrlib TRIGMNIP 
   Warnings: 
      [1] K2KG: not known that (RadicalCategory) is of mode (CATEGORY domain (IF (has (Complex R) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Complex R))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Complex R) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Complex R) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [2] K2KG: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (IF (has (Complex R) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Complex R))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Complex R) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Complex R) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [3] K2KG: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE complexNormalize (F F)) (SIGNATURE complexNormalize (F F (Symbol))) (SIGNATURE complexElementary (F F)) (SIGNATURE complexElementary (F F (Symbol))) (SIGNATURE trigs (F F)) (SIGNATURE real (F F)) (SIGNATURE imag (F F)) (SIGNATURE real? ((Boolean) F)) (SIGNATURE complexForm ((Complex F) F)))
      [4] real?:  ker has no value
      [5] complexKernels: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE complexNormalize (F F)) (SIGNATURE complexNormalize (F F (Symbol))) (SIGNATURE complexElementary (F F)) (SIGNATURE complexElementary (F F (Symbol))) (SIGNATURE trigs (F F)) (SIGNATURE real (F F)) (SIGNATURE imag (F F)) (SIGNATURE real? ((Boolean) F)) (SIGNATURE complexForm ((Complex F) F)))
      [6] complexKernels:  lk has no value
      [7] complexKernels:  lv has no value
      [8] complexNormalize: not known that (AlgebraicallyClosedField) is of mode (CATEGORY domain (IF (has (Complex R) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Complex R))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Complex R) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Complex R) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [9] complexNormalize: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (IF (has (Complex R) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Complex R))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Complex R) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Complex R) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))

============================================================================

   finalizing nrlib TRMANIP 
   Warnings: 
      [1] logArgs: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE expand (F F)) (SIGNATURE simplify (F F)) (SIGNATURE htrigs (F F)) (SIGNATURE simplifyExp (F F)) (SIGNATURE simplifyLog (F F)) (SIGNATURE expandPower (F F)) (SIGNATURE expandLog (F F)) (SIGNATURE cos2sec (F F)) (SIGNATURE cosh2sech (F F)) (SIGNATURE cot2trig (F F)) (SIGNATURE coth2trigh (F F)) (SIGNATURE csc2sin (F F)) (SIGNATURE csch2sinh (F F)) (SIGNATURE sec2cos (F F)) (SIGNATURE sech2cosh (F F)) (SIGNATURE sin2csc (F F)) (SIGNATURE sinh2csch (F F)) (SIGNATURE tan2trig (F F)) (SIGNATURE tanh2trigh (F F)) (SIGNATURE tan2cot (F F)) (SIGNATURE tanh2coth (F F)) (SIGNATURE cot2tan (F F)) (SIGNATURE coth2tanh (F F)) (SIGNATURE removeCosSq (F F)) (SIGNATURE removeSinSq (F F)) (SIGNATURE removeCoshSq (F F)) (SIGNATURE removeSinhSq (F F)) (IF (has R (PatternMatchable R)) (IF (has R (ConvertibleTo (Pattern R))) (IF (has F (ConvertibleTo (Pattern R))) (IF (has F (PatternMatchable R)) (SIGNATURE expandTrigProducts (F F)) noBranch) noBranch) noBranch) noBranch))
      [2] logArgs:  sum has no value
      [3] logArgs:  arg has no value
      [4] simplifyLog1:  exprs has no value
      [5] simplifyLog1:  terms has no value
      [6] simplifyLog1: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE expand (F F)) (SIGNATURE simplify (F F)) (SIGNATURE htrigs (F F)) (SIGNATURE simplifyExp (F F)) (SIGNATURE simplifyLog (F F)) (SIGNATURE expandPower (F F)) (SIGNATURE expandLog (F F)) (SIGNATURE cos2sec (F F)) (SIGNATURE cosh2sech (F F)) (SIGNATURE cot2trig (F F)) (SIGNATURE coth2trigh (F F)) (SIGNATURE csc2sin (F F)) (SIGNATURE csch2sinh (F F)) (SIGNATURE sec2cos (F F)) (SIGNATURE sech2cosh (F F)) (SIGNATURE sin2csc (F F)) (SIGNATURE sinh2csch (F F)) (SIGNATURE tan2trig (F F)) (SIGNATURE tanh2trigh (F F)) (SIGNATURE tan2cot (F F)) (SIGNATURE tanh2coth (F F)) (SIGNATURE cot2tan (F F)) (SIGNATURE coth2tanh (F F)) (SIGNATURE removeCosSq (F F)) (SIGNATURE removeSinSq (F F)) (SIGNATURE removeCoshSq (F F)) (SIGNATURE removeSinhSq (F F)) (IF (has R (PatternMatchable R)) (IF (has R (ConvertibleTo (Pattern R))) (IF (has F (ConvertibleTo (Pattern R))) (IF (has F (PatternMatchable R)) (SIGNATURE expandTrigProducts (F F)) noBranch) noBranch) noBranch) noBranch))
      [7] expandpow: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE expand (F F)) (SIGNATURE simplify (F F)) (SIGNATURE htrigs (F F)) (SIGNATURE simplifyExp (F F)) (SIGNATURE simplifyLog (F F)) (SIGNATURE expandPower (F F)) (SIGNATURE expandLog (F F)) (SIGNATURE cos2sec (F F)) (SIGNATURE cosh2sech (F F)) (SIGNATURE cot2trig (F F)) (SIGNATURE coth2trigh (F F)) (SIGNATURE csc2sin (F F)) (SIGNATURE csch2sinh (F F)) (SIGNATURE sec2cos (F F)) (SIGNATURE sech2cosh (F F)) (SIGNATURE sin2csc (F F)) (SIGNATURE sinh2csch (F F)) (SIGNATURE tan2trig (F F)) (SIGNATURE tanh2trigh (F F)) (SIGNATURE tan2cot (F F)) (SIGNATURE tanh2coth (F F)) (SIGNATURE cot2tan (F F)) (SIGNATURE coth2tanh (F F)) (SIGNATURE removeCosSq (F F)) (SIGNATURE removeSinSq (F F)) (SIGNATURE removeCoshSq (F F)) (SIGNATURE removeSinhSq (F F)) (IF (has R (PatternMatchable R)) (IF (has R (ConvertibleTo (Pattern R))) (IF (has F (ConvertibleTo (Pattern R))) (IF (has F (PatternMatchable R)) (SIGNATURE expandTrigProducts (F F)) noBranch) noBranch) noBranch) noBranch))
      [8] termexp:  exponent has no value
      [9] htrigs: not known that (Ring) is of mode (CATEGORY package (SIGNATURE expand (F F)) (SIGNATURE simplify (F F)) (SIGNATURE htrigs (F F)) (SIGNATURE simplifyExp (F F)) (SIGNATURE simplifyLog (F F)) (SIGNATURE expandPower (F F)) (SIGNATURE expandLog (F F)) (SIGNATURE cos2sec (F F)) (SIGNATURE cosh2sech (F F)) (SIGNATURE cot2trig (F F)) (SIGNATURE coth2trigh (F F)) (SIGNATURE csc2sin (F F)) (SIGNATURE csch2sinh (F F)) (SIGNATURE sec2cos (F F)) (SIGNATURE sech2cosh (F F)) (SIGNATURE sin2csc (F F)) (SIGNATURE sinh2csch (F F)) (SIGNATURE tan2trig (F F)) (SIGNATURE tanh2trigh (F F)) (SIGNATURE tan2cot (F F)) (SIGNATURE tanh2coth (F F)) (SIGNATURE cot2tan (F F)) (SIGNATURE coth2tanh (F F)) (SIGNATURE removeCosSq (F F)) (SIGNATURE removeSinSq (F F)) (SIGNATURE removeCoshSq (F F)) (SIGNATURE removeSinhSq (F F)) (IF (has R (PatternMatchable R)) (IF (has R (ConvertibleTo (Pattern R))) (IF (has F (ConvertibleTo (Pattern R))) (IF (has F (PatternMatchable R)) (SIGNATURE expandTrigProducts (F F)) noBranch) noBranch) noBranch) noBranch))
      [10] exlog: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE expand (F F)) (SIGNATURE simplify (F F)) (SIGNATURE htrigs (F F)) (SIGNATURE simplifyExp (F F)) (SIGNATURE simplifyLog (F F)) (SIGNATURE expandPower (F F)) (SIGNATURE expandLog (F F)) (SIGNATURE cos2sec (F F)) (SIGNATURE cosh2sech (F F)) (SIGNATURE cot2trig (F F)) (SIGNATURE coth2trigh (F F)) (SIGNATURE csc2sin (F F)) (SIGNATURE csch2sinh (F F)) (SIGNATURE sec2cos (F F)) (SIGNATURE sech2cosh (F F)) (SIGNATURE sin2csc (F F)) (SIGNATURE sinh2csch (F F)) (SIGNATURE tan2trig (F F)) (SIGNATURE tanh2trigh (F F)) (SIGNATURE tan2cot (F F)) (SIGNATURE tanh2coth (F F)) (SIGNATURE cot2tan (F F)) (SIGNATURE coth2tanh (F F)) (SIGNATURE removeCosSq (F F)) (SIGNATURE removeSinSq (F F)) (SIGNATURE removeCoshSq (F F)) (SIGNATURE removeSinhSq (F F)) (IF (has R (PatternMatchable R)) (IF (has R (ConvertibleTo (Pattern R))) (IF (has F (ConvertibleTo (Pattern R))) (IF (has F (PatternMatchable R)) (SIGNATURE expandTrigProducts (F F)) noBranch) noBranch) noBranch) noBranch))
      [11] logexpand:  IN has no value
      [12] logexpand:  x has no value
      [13] kerexpand:  IN has no value
      [14] kerexpand:  x has no value

============================================================================

   finalizing nrlib ULSCCAT 
; (DEFUN |UnivariateLaurentSeriesConstructorCategory| ...) is being compiled.
;; The variable |UnivariateLaurentSeriesConstructorCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |UnivariateLaurentSeriesConstructorCategory;| ...) is being compiled.
;; The variable |UnivariateLaurentSeriesConstructorCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib UPXSSING 
   Warnings: 
      [1] retractIfCan: signature of lhs not unique: (Union (UnivariatePuiseuxSeries FE var cen) failed)$ chosen
      [2] sortAndDiscardTerms:  zeroTerms has no value
      [3] sortAndDiscardTerms:  infiniteTerms has no value
      [4] sortAndDiscardTerms:  failedTerms has no value
      [5] dominantTermOnList:  %list has no value
      [6] dominantTermOnList:  %order has no value

--------------non extending category----------------------
.. UnivariatePuiseuxSeriesWithExponentialSingularity(#1,#2,#3,#4) of cat 
(|Join| (|FiniteAbelianMonoidRing| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|) (|ExponentialOfUnivariatePuiseuxSeries| |#2| |#3| |#4|)) (|IntegralDomain|) (CATEGORY |domain| (SIGNATURE |limitPlus| ((|Union| (|OrderedCompletion| |#2|) "failed") $)) (SIGNATURE |dominantTerm| ((|Union| (|Record| (|:| |%term| (|Record| (|:| |%coef| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|)) (|:| |%expon| (|ExponentialOfUnivariatePuiseuxSeries| |#2| |#3| |#4|)) (|:| |%expTerms| (|List| (|Record| (|:| |k| (|Fraction| (|Integer|))) (|:| |c| |#2|)))))) (|:| |%type| (|String|))) "failed") $))))   has no 
============================================================================

(IF (|has| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|) (|IntegralDomain|)) (IF (|has| (|ExponentialOfUnivariatePuiseuxSeries| |#2| |#3| |#4|) (|CancellationAbelianMonoid|)) (SIGNATURE |fmecg| ($ $ (|ExponentialOfUnivariatePuiseuxSeries| |#2| |#3| |#4|) (|UnivariatePuiseuxSeries| |#2| |#3| |#4|) $)) |noBranch|) |noBranch|)    finalizing nrlib UPXSSING 

============================================================================

   finalizing nrlib WUTSET 
   Warnings: 
      [1] medialSetWithTrace:  rs has no value
      [2] medialSetWithTrace:  contradiction has no value
      [3] medialSetWithTrace:  bs has no value
      [4] characteristicSetUsingTrace:  contradiction has no value
      [5] characteristicSetUsingTrace:  rs has no value
      [6] characteristicSetUsingTrace:  ms has no value
      [7] zeroSetSplit:  newlts has no value

============================================================================

   finalizing nrlib DEFINTEF 
   Warnings: 
      [1] checkForPole: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE integrate ((Union (: f1 (OrderedCompletion F)) (: f2 (List (OrderedCompletion F))) (: fail failed) (: pole potentialPole)) F (SegmentBinding (OrderedCompletion F)))) (SIGNATURE integrate ((Union (: f1 (OrderedCompletion F)) (: f2 (List (OrderedCompletion F))) (: fail failed) (: pole potentialPole)) F (SegmentBinding (OrderedCompletion F)) (String))) (SIGNATURE innerint ((Union (: f1 (OrderedCompletion F)) (: f2 (List (OrderedCompletion F))) (: fail failed) (: pole potentialPole)) F (Symbol) (OrderedCompletion F) (OrderedCompletion F) (Boolean))))
      [2] polyIfCan: not known that (Ring) is of mode (CATEGORY package (SIGNATURE integrate ((Union (: f1 (OrderedCompletion F)) (: f2 (List (OrderedCompletion F))) (: fail failed) (: pole potentialPole)) F (SegmentBinding (OrderedCompletion F)))) (SIGNATURE integrate ((Union (: f1 (OrderedCompletion F)) (: f2 (List (OrderedCompletion F))) (: fail failed) (: pole potentialPole)) F (SegmentBinding (OrderedCompletion F)) (String))) (SIGNATURE innerint ((Union (: f1 (OrderedCompletion F)) (: f2 (List (OrderedCompletion F))) (: fail failed) (: pole potentialPole)) F (Symbol) (OrderedCompletion F) (OrderedCompletion F) (Boolean))))
      [3] polyIfCan: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE integrate ((Union (: f1 (OrderedCompletion F)) (: f2 (List (OrderedCompletion F))) (: fail failed) (: pole potentialPole)) F (SegmentBinding (OrderedCompletion F)))) (SIGNATURE integrate ((Union (: f1 (OrderedCompletion F)) (: f2 (List (OrderedCompletion F))) (: fail failed) (: pole potentialPole)) F (SegmentBinding (OrderedCompletion F)) (String))) (SIGNATURE innerint ((Union (: f1 (OrderedCompletion F)) (: f2 (List (OrderedCompletion F))) (: fail failed) (: pole potentialPole)) F (Symbol) (OrderedCompletion F) (OrderedCompletion F) (Boolean))))

============================================================================

   finalizing nrlib DFINTTLS 
   Warnings: 
      [1] findLimit: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE ignore? ((Boolean) (String))) (SIGNATURE computeInt ((Union (OrderedCompletion F) failed) (Kernel F) F (OrderedCompletion F) (OrderedCompletion F) (Boolean))) (SIGNATURE checkForZero ((Union (Boolean) failed) (Polynomial R) (Symbol) (OrderedCompletion F) (OrderedCompletion F) (Boolean))) (SIGNATURE checkForZero ((Union (Boolean) failed) (SparseUnivariatePolynomial F) (OrderedCompletion F) (OrderedCompletion F) (Boolean))))
      [2] mkLogPos: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE ignore? ((Boolean) (String))) (SIGNATURE computeInt ((Union (OrderedCompletion F) failed) (Kernel F) F (OrderedCompletion F) (OrderedCompletion F) (Boolean))) (SIGNATURE checkForZero ((Union (Boolean) failed) (Polynomial R) (Symbol) (OrderedCompletion F) (OrderedCompletion F) (Boolean))) (SIGNATURE checkForZero ((Union (Boolean) failed) (SparseUnivariatePolynomial F) (OrderedCompletion F) (OrderedCompletion F) (Boolean))))
      [3] checkForZero: not known that (Ring) is of mode (CATEGORY package (SIGNATURE ignore? ((Boolean) (String))) (SIGNATURE computeInt ((Union (OrderedCompletion F) failed) (Kernel F) F (OrderedCompletion F) (OrderedCompletion F) (Boolean))) (SIGNATURE checkForZero ((Union (Boolean) failed) (Polynomial R) (Symbol) (OrderedCompletion F) (OrderedCompletion F) (Boolean))) (SIGNATURE checkForZero ((Union (Boolean) failed) (SparseUnivariatePolynomial F) (OrderedCompletion F) (OrderedCompletion F) (Boolean))))
      [4] findRealZero:  fin has no value
      [5] findRealZero:  halfinf has no value
      [6] var:  i has no value

============================================================================

   finalizing nrlib DEFINTRF 
   Warnings: 
      [1] nopole: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (IF (has R (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace R)) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has R (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has R (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [2] nopole: not known that (AlgebraicallyClosedFunctionSpace R) is of mode (CATEGORY domain (IF (has R (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace R)) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has R (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has R (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))

============================================================================

   finalizing nrlib D01TRNS 
   Warnings: 
      [1] transformFunction: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (IF (has (Fraction (Integer)) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Fraction (Integer)))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Fraction (Integer)) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Fraction (Integer)) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))

--------------non extending category----------------------
.. d01TransformFunctionType of cat 
(|NumericalIntegrationCategory|)   has no 
============================================================================

(|TableAggregate| (|Symbol|) (|Any|))    finalizing nrlib D01TRNS 

============================================================================

   finalizing nrlib D01TRNS 
--->/research2/test0819/mnt/fedora5/../../src/algebra/D01TRNS.spad-->d01TransformFunctionType(): Missing Description

============================================================================

   finalizing nrlib EFULS 
   Warnings: 
      [1] tanIfCan: not known that (Algebra (Fraction (Integer))) is of mode (CATEGORY Coef (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) Coef)))

============================================================================

   finalizing nrlib ESCONT 
   Warnings: 
      [1] zerosOf: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE getlo ((DoubleFloat) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE gethi ((DoubleFloat) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE functionIsFracPolynomial? ((Boolean) (Record (: var (Symbol)) (: fn (Expression (DoubleFloat))) (: range (Segment (OrderedCompletion (DoubleFloat)))) (: abserr (DoubleFloat)) (: relerr (DoubleFloat))))) (SIGNATURE problemPoints ((List (DoubleFloat)) (Expression (DoubleFloat)) (Symbol) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE zerosOf ((Stream (DoubleFloat)) (Expression (DoubleFloat)) (List (Symbol)) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE singularitiesOf ((Stream (DoubleFloat)) (Expression (DoubleFloat)) (List (Symbol)) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE singularitiesOf ((Stream (DoubleFloat)) (Vector (Expression (DoubleFloat))) (List (Symbol)) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE polynomialZeros ((List (DoubleFloat)) (Polynomial (Fraction (Integer))) (Symbol) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE df2st ((String) (DoubleFloat))) (SIGNATURE ldf2lst ((List (String)) (List (DoubleFloat)))) (SIGNATURE sdf2lst ((List (String)) (Stream (DoubleFloat)))))

============================================================================

   finalizing nrlib ESCONT 
--------------non extending category----------------------
.. ExpertSystemContinuityPackage of cat 
(CATEGORY |package| (SIGNATURE |getlo| ((|DoubleFloat|) (|Segment| (|OrderedCompletion| (|DoubleFloat|))))) (SIGNATURE |gethi| ((|DoubleFloat|) (|Segment| (|OrderedCompletion| (|DoubleFloat|))))) (SIGNATURE |functionIsFracPolynomial?| ((|Boolean|) (|Record| (|:| |var| (|Symbol|)) (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|))))) (SIGNATURE |problemPoints| ((|List| (|DoubleFloat|)) (|Expression| (|DoubleFloat|)) (|Symbol|) (|Segment| (|OrderedCompletion| (|DoubleFloat|))))) (SIGNATURE |zerosOf| ((|Stream| (|DoubleFloat|)) (|Expression| (|DoubleFloat|)) (|List| (|Symbol|)) (|Segment| (|OrderedCompletion| (|DoubleFloat|))))) (SIGNATURE |singularitiesOf| ((|Stream| (|DoubleFloat|)) (|Expression| (|DoubleFloat|)) (|List| (|Symbol|)) (|Segment| (|OrderedCompletion| (|DoubleFloat|))))) (SIGNATURE |singularitiesOf| ((|Stream| (|DoubleFloat|)) (|Vector| (|Expression| (|DoubleFloat|))) (|List| (|Symbol|)) (|Segment| (|OrderedCompletion| (|DoubleFloat|))))) (SIGNATURE |polynomialZeros| ((|List| (|DoubleFloat|)) (|Polynomial| (|Fraction| (|Integer|))) (|Symbol|) (|Segment| (|OrderedCompletion| (|DoubleFloat|))))) (SIGNATURE |df2st| ((|String|) (|DoubleFloat|))) (SIGNATURE |ldf2lst| ((|List| (|String|)) (|List| (|DoubleFloat|)))) (SIGNATURE |sdf2lst| ((|List| (|String|)) (|Stream| (|DoubleFloat|)))))    has no  f2df : Float -> DoubleFloat 

============================================================================

   finalizing nrlib EXPR 
   Warnings: 
      [1] not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [2] simplifyPower: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [3] **: pretend(Integer) -- should replace by @
      [4] **: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [5] <: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [6] numer: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [7] toprat: not known that (Field) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [8] toprat: not known that (ExpressionSpace) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [9] toprat: not known that (SIGNATURE numer ((SparseMultivariatePolynomial R (Kernel $)) $)) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [10] toprat: not known that (SIGNATURE denom ((SparseMultivariatePolynomial R (Kernel $)) $)) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [11] toprat: not known that (SIGNATURE coerce ($ (SparseMultivariatePolynomial R (Kernel $)))) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [12] reducedSystem: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [13] commonk0: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [14] rootOf: not known that (FunctionSpace R) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [15] rootOf: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [16] pi: not known that (FunctionSpace R) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [17] pi: not known that (RadicalCategory) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [18] abs: not known that (FunctionSpace R) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [19] **: not known that (FunctionSpace R) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [20] erf: not known that (FunctionSpace R) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [21] erf: not known that (RadicalCategory) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [22] erf: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [23] operator: not known that (FunctionSpace R) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [24] operator: not known that (ExpressionSpace) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [25] evl0: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [26] gcdPolynomial: not known that (GcdDomain) is of mode (CATEGORY domain (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))))
      [27] factorPolynomial: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))))
      [28] factorPolynomial: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))))
      [29] coerce: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [30] retract: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [31] retractIfCan: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [32] k2expr: not known that (ExpressionSpace) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [33] smp2expr: not known that (SetCategory) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [34] smp2expr: not known that (SIGNATURE + ($ $ $)) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [35] smp2expr: not known that (SIGNATURE * ($ $ $)) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [36] smp2expr: not known that (SIGNATURE ** ($ $ (NonNegativeInteger))) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [37] smp2an: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [38] convert: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [39] eval: not known that (ConvertibleTo (InputForm)) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [40] patternMatch: not known that (FunctionSpace R) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [41] patternMatch: not known that (ConvertibleTo (Pattern (Integer))) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [42] patternMatch: not known that (PatternMatchable (Integer)) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [43] patternMatch: not known that (RetractableTo (Kernel $)) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [44] patternMatch: not known that (SetCategory) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [45] patternMatch: not known that (ConvertibleTo (Pattern (Float))) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [46] patternMatch: not known that (PatternMatchable (Float)) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [47] isPlus:  gen has no value
      [48] not known that (Ring) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))
      [49] not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE simplifyPower ($ $ (Integer))))

============================================================================

   finalizing nrlib EXPR 
--->/research2/test0819/mnt/fedora5/../../src/algebra/EXPR.spad-->Expression((simplifyPower (% % (Integer)))): Improper first word in comments: simplifyPower?
"simplifyPower?(\\spad{f},{}\\spad{n}) \\undocumented{}"

============================================================================

   finalizing nrlib EXPR 
; (DEFUN |Expression;| ...) is being compiled.
;; The variable IDENTITY is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib EXPR2UPS 
   Warnings: 
      [1] iTaylor:  %problem has no value
      [2] iTaylor:  %series has no value
      [3] taylor: more than 1 modemap for: (Zero) with dc=FE ===>(((FE FE) ((has R (AbelianSemiGroup)) (CONST FE ($)))) ((FE FE) (T (CONST FE ($)))))
      [4] iLaurent:  %problem has no value
      [5] iLaurent:  %series has no value
      [6] laurent: more than 1 modemap for: (Zero) with dc=FE ===>(((FE FE) ((has R (AbelianSemiGroup)) (CONST FE ($)))) ((FE FE) (T (CONST FE ($)))))
      [7] iPuiseux:  %problem has no value
      [8] iPuiseux:  %series has no value
      [9] puiseux: more than 1 modemap for: (Zero) with dc=FE ===>(((FE FE) ((has R (AbelianSemiGroup)) (CONST FE ($)))) ((FE FE) (T (CONST FE ($)))))
      [10] iSeries:  %problem has no value
      [11] iSeries:  %series has no value
      [12] series: more than 1 modemap for: (Zero) with dc=FE ===>(((FE FE) ((has R (AbelianSemiGroup)) (CONST FE ($)))) ((FE FE) (T (CONST FE ($)))))

============================================================================

   finalizing nrlib FDIV 
   Warnings: 
      [1] *: signature of lhs not unique: $(Integer)$ chosen

============================================================================

   finalizing nrlib FDIV 
; (DEFUN |FiniteDivisor;| ...) is being compiled.
;; The variable IDENTITY is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FSCINT 
   Warnings: 
      [1] K2KG: not known that (RadicalCategory) is of mode (CATEGORY domain (IF (has (Complex R) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Complex R))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Complex R) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Complex R) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [2] K2KG: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (IF (has (Complex R) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Complex R))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Complex R) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Complex R) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [3] K2KG: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE internalIntegrate ((IntegrationResult F) F (Symbol))) (SIGNATURE internalIntegrate0 ((IntegrationResult F) F (Symbol))) (SIGNATURE complexIntegrate (F F (Symbol))))
      [4] internalIntegrate: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE internalIntegrate ((IntegrationResult F) F (Symbol))) (SIGNATURE internalIntegrate0 ((IntegrationResult F) F (Symbol))) (SIGNATURE complexIntegrate (F F (Symbol))))
      [5] internalIntegrate: not known that (AlgebraicallyClosedField) is of mode (CATEGORY domain (IF (has (Complex R) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Complex R))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Complex R) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Complex R) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [6] internalIntegrate: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (IF (has (Complex R) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Complex R))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Complex R) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Complex R) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))

============================================================================

   finalizing nrlib FSINT 
   Warnings: 
      [1] K2KG: not known that (RadicalCategory) is of mode (CATEGORY domain (IF (has (Complex R) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Complex R))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Complex R) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Complex R) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [2] K2KG: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (IF (has (Complex R) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Complex R))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Complex R) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Complex R) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [3] K2KG: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE integrate ((Union F (List F)) F (Symbol))))
      [4] postSubst: not known that (Ring) is of mode (CATEGORY package (SIGNATURE integrate ((Union F (List F)) F (Symbol))))
      [5] postSubst: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE integrate ((Union F (List F)) F (Symbol))))
      [6] integrate: not known that (AlgebraicallyClosedField) is of mode (CATEGORY domain (IF (has (Complex R) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Complex R))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Complex R) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Complex R) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [7] integrate: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (IF (has (Complex R) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Complex R))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Complex R) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Complex R) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))

============================================================================

   finalizing nrlib FS2EXPXP 
   Warnings: 
      [1] newElem: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE exprToXXP ((Union (: %expansion (ExponentialExpansion R FE x cen)) (: %problem (Record (: func (String)) (: prob (String))))) FE (Boolean))) (SIGNATURE localAbs (FE FE)))
      [2] k2Elem: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE exprToXXP ((Union (: %expansion (ExponentialExpansion R FE x cen)) (: %problem (Record (: func (String)) (: prob (String))))) FE (Boolean))) (SIGNATURE localAbs (FE FE)))
      [3] iExprToXXP:  %series has no value
      [4] listToXXP:  %expansion has no value
      [5] powerToXXP:  %expansion has no value
      [6] nthRootXXPIfCan:  %problem has no value
      [7] nthRootXXPIfCan:  %series has no value
      [8] nthRootToXXP:  %problem has no value
      [9] nthRootToXXP:  %expansion has no value
      [10] genPowerToXXP:  %expansion has no value
      [11] genExp:  %series has no value
      [12] exponential:  %problem has no value
      [13] exponential:  %series has no value
      [14] expToXXP:  %expansion has no value
      [15] logToXXP:  %expansion has no value
      [16] logToXXP:  %problem has no value
      [17] logToXXP:  %series has no value
      [18] applyIfCan:  %expansion has no value
      [19] applyBddIfCan:  %problem has no value
      [20] applyBddIfCan:  %expansion has no value
      [21] opsInvolvingX: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE exprToXXP ((Union (: %expansion (ExponentialExpansion R FE x cen)) (: %problem (Record (: func (String)) (: prob (String))))) FE (Boolean))) (SIGNATURE localAbs (FE FE)))
      [22] atancotToXXP:  %problem has no value
      [23] atancotToXXP:  %series has no value

--------------non extending category----------------------
.. GeneralUnivariatePowerSeries(#1,#2,#3) of cat 
(|Join| (|UnivariatePuiseuxSeriesCategory| |#1|) (CATEGORY |domain| (SIGNATURE |coerce| ($ (|Variable| |#2|))) (SIGNATURE |coerce| ($ (|UnivariatePuiseuxSeries| |#1| |#2| |#3|))) (SIGNATURE |differentiate| ($ $ (|Variable| |#2|))) (IF (|has| |#1| (|Algebra| (|Fraction| (|Integer|)))) (SIGNATURE |integrate| ($ $ (|Variable| |#2|))) |noBranch|)))   has no 
============================================================================

(|UnivariatePuiseuxSeriesConstructorCategory| |#1| (|UnivariateLaurentSeries| |#1| |#2| |#3|))    finalizing nrlib GSERIES 

============================================================================

   finalizing nrlib HELLFDIV 
   Warnings: 
      [1] unknown Functor code (error HyperellipticFiniteDivisor: curve must be hyperelliptic)

============================================================================

   finalizing nrlib INVLAPLA 
   Warnings: 
      [1] ilt: not known that (Ring) is of mode (CATEGORY package (SIGNATURE inverseLaplace ((Union F failed) F (Symbol) (Symbol))))
      [2] ilt: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE inverseLaplace ((Union F failed) F (Symbol) (Symbol))))
      [3] iltsqfr: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE inverseLaplace ((Union F failed) F (Symbol) (Symbol))))
      [4] iltirred: not known that (Ring) is of mode (CATEGORY package (SIGNATURE inverseLaplace ((Union F failed) F (Symbol) (Symbol))))

============================================================================

   finalizing nrlib IR2F 
   Warnings: 
      [1] evenRoots: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE split ((IntegrationResult F) (IntegrationResult F))) (SIGNATURE expand ((List F) (IntegrationResult F))) (SIGNATURE complexExpand (F (IntegrationResult F))))
      [2] ilog: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE split ((IntegrationResult F) (IntegrationResult F))) (SIGNATURE expand ((List F) (IntegrationResult F))) (SIGNATURE complexExpand (F (IntegrationResult F))))
      [3] ilog: not known that (Ring) is of mode (CATEGORY package (SIGNATURE split ((IntegrationResult F) (IntegrationResult F))) (SIGNATURE expand ((List F) (IntegrationResult F))) (SIGNATURE complexExpand (F (IntegrationResult F))))
      [4] lg2func: not known that (Ring) is of mode (CATEGORY package (SIGNATURE split ((IntegrationResult F) (IntegrationResult F))) (SIGNATURE expand ((List F) (IntegrationResult F))) (SIGNATURE complexExpand (F (IntegrationResult F))))

============================================================================

   finalizing nrlib IRRF2F 
   Warnings: 
      [1] expand: not known that (AlgebraicallyClosedFunctionSpace R) is of mode (CATEGORY domain (IF (has R (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace R)) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has R (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has R (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [2] expand: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (IF (has R (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace R)) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has R (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has R (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [3] integrate: not known that (AlgebraicallyClosedField) is of mode (CATEGORY domain (IF (has R (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace R)) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has R (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has R (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [4] integrate: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (IF (has R (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace R)) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has R (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has R (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))

============================================================================

   finalizing nrlib LAPLACE 
   Warnings: 
      [1] algebraic?: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE laplace (F F (Symbol) (Symbol))))
      [2] isLinear: not known that (Ring) is of mode (CATEGORY package (SIGNATURE laplace (F F (Symbol) (Symbol))))
      [3] isLinear: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE laplace (F F (Symbol) (Symbol))))
      [4] atn:  d has no value
      [5] mkPlus: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE laplace (F F (Symbol) (Symbol))))
      [6] locallaplace:  const has no value
      [7] locallaplace:  nconst has no value

============================================================================

   finalizing nrlib LIMITPS 
   Warnings: 
      [1] firstNonLogPtr: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE limit ((Union (OrderedCompletion FE) (Record (: leftHandLimit (Union (OrderedCompletion FE) failed)) (: rightHandLimit (Union (OrderedCompletion FE) failed))) failed) FE (Equation (OrderedCompletion FE)))) (SIGNATURE complexLimit ((Union (OnePointCompletion FE) failed) FE (Equation (OnePointCompletion FE)))) (SIGNATURE limit ((Union (OrderedCompletion FE) failed) FE (Equation FE) (String))))
      [2] complLimit:  %series has no value
      [3] realLimit:  %problem has no value
      [4] realLimit:  %series has no value
      [5] realLimit:  func has no value
      [6] realLimit:  prob has no value
      [7] xxpLimit:  %expansion has no value
      [8] limitPlus:  %problem has no value
      [9] limitPlus:  %series has no value
      [10] limitPlus:  func has no value
      [11] limitPlus:  prob has no value

============================================================================

   finalizing nrlib LODEEF 
   Warnings: 
      [1] algSolve: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE solve ((Union (Record (: particular F) (: basis (List F))) failed) L F (Symbol))) (SIGNATURE solve ((Union F failed) L F (Symbol) F (List F))))
      [2] algSolve: not known that (Ring) is of mode (CATEGORY package (SIGNATURE solve ((Union (Record (: particular F) (: basis (List F))) failed) L F (Symbol))) (SIGNATURE solve ((Union F failed) L F (Symbol) F (List F))))
      [3] xpart: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE solve ((Union (Record (: particular F) (: basis (List F))) failed) L F (Symbol))) (SIGNATURE solve ((Union F failed) L F (Symbol) F (List F))))
      [4] ulodo: not known that (Ring) is of mode (CATEGORY package (SIGNATURE solve ((Union (Record (: particular F) (: basis (List F))) failed) L F (Symbol))) (SIGNATURE solve ((Union F failed) L F (Symbol) F (List F))))

============================================================================

   finalizing nrlib NODE1 
   Warnings: 
      [1] solve: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE solve ((Union F failed) F F (BasicOperator) (Symbol))))
      [2] checkBernoulli: not known that (Ring) is of mode (CATEGORY package (SIGNATURE solve ((Union F failed) F F (BasicOperator) (Symbol))))

============================================================================

   finalizing nrlib ODECONST 
   Warnings: 
      [1] basisSqfr: not known that (Ring) is of mode (CATEGORY package (SIGNATURE constDsolve ((Record (: particular F) (: basis (List F))) L F (Symbol))))

============================================================================

   finalizing nrlib ODEINT 
   Warnings: 
      [1] expint: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE int (F F (Symbol))) (SIGNATURE expint (F F (Symbol))) (SIGNATURE diff ((Mapping F F) (Symbol))))
      [2] expint:  lrec has no value
      [3] expint:  exponent has no value
      [4] isQlog: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE int (F F (Symbol))) (SIGNATURE expint (F F (Symbol))) (SIGNATURE diff ((Mapping F F) (Symbol))))

============================================================================

   finalizing nrlib REP 
   Warnings: 
      [1] evalvect: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE radicalEigenvectors ((List (Record (: radval (Expression (Integer))) (: radmult (Integer)) (: radvect (List (Matrix (Expression (Integer))))))) (Matrix (Fraction (Polynomial (Integer)))))) (SIGNATURE radicalEigenvector ((List (Matrix (Expression (Integer)))) (Expression (Integer)) (Matrix (Fraction (Polynomial (Integer)))))) (SIGNATURE radicalEigenvalues ((List (Expression (Integer))) (Matrix (Fraction (Polynomial (Integer)))))) (SIGNATURE eigenMatrix ((Union (Matrix (Expression (Integer))) failed) (Matrix (Fraction (Polynomial (Integer)))))) (SIGNATURE normalise ((Matrix (Expression (Integer))) (Matrix (Expression (Integer))))) (SIGNATURE gramschmidt ((List (Matrix (Expression (Integer)))) (List (Matrix (Expression (Integer)))))) (SIGNATURE orthonormalBasis ((List (Matrix (Expression (Integer)))) (Matrix (Fraction (Polynomial (Integer)))))))
      [2] gramschmidt: :(PositiveInteger) -- should replace by pretend
      [3] gramschmidt: :RMR -- should replace by pretend
      [4] gramschmidt: :(Matrix (Expression (Integer))) -- should replace by pretend

============================================================================

   finalizing nrlib SOLVERAD 
   Warnings: 
      [1] quadratic: not known that (SIGNATURE ** ($ $ (Fraction (Integer)))) is of mode (CATEGORY domain (IF (has R (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace R)) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has R (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has R (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [2] findGenZeros: not known that (Ring) is of mode (CATEGORY package (SIGNATURE radicalSolve ((List (Equation (Expression R))) (Fraction (Polynomial R)) (Symbol))) (SIGNATURE radicalSolve ((List (Equation (Expression R))) (Fraction (Polynomial R)))) (SIGNATURE radicalSolve ((List (Equation (Expression R))) (Equation (Fraction (Polynomial R))) (Symbol))) (SIGNATURE radicalSolve ((List (Equation (Expression R))) (Equation (Fraction (Polynomial R))))) (SIGNATURE radicalSolve ((List (List (Equation (Expression R)))) (List (Fraction (Polynomial R))) (List (Symbol)))) (SIGNATURE radicalSolve ((List (List (Equation (Expression R)))) (List (Fraction (Polynomial R))))) (SIGNATURE radicalSolve ((List (List (Equation (Expression R)))) (List (Equation (Fraction (Polynomial R)))) (List (Symbol)))) (SIGNATURE radicalSolve ((List (List (Equation (Expression R)))) (List (Equation (Fraction (Polynomial R)))))) (SIGNATURE radicalRoots ((List (Expression R)) (Fraction (Polynomial R)) (Symbol))) (SIGNATURE radicalRoots ((List (List (Expression R))) (List (Fraction (Polynomial R))) (List (Symbol)))) (SIGNATURE contractSolve ((SuchThat (List (Expression R)) (List (Equation (Expression R)))) (Equation (Fraction (Polynomial R))) (Symbol))) (SIGNATURE contractSolve ((SuchThat (List (Expression R)) (List (Equation (Expression R)))) (Fraction (Polynomial R)) (Symbol))))
      [3] findGenZeros: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE radicalSolve ((List (Equation (Expression R))) (Fraction (Polynomial R)) (Symbol))) (SIGNATURE radicalSolve ((List (Equation (Expression R))) (Fraction (Polynomial R)))) (SIGNATURE radicalSolve ((List (Equation (Expression R))) (Equation (Fraction (Polynomial R))) (Symbol))) (SIGNATURE radicalSolve ((List (Equation (Expression R))) (Equation (Fraction (Polynomial R))))) (SIGNATURE radicalSolve ((List (List (Equation (Expression R)))) (List (Fraction (Polynomial R))) (List (Symbol)))) (SIGNATURE radicalSolve ((List (List (Equation (Expression R)))) (List (Fraction (Polynomial R))))) (SIGNATURE radicalSolve ((List (List (Equation (Expression R)))) (List (Equation (Fraction (Polynomial R)))) (List (Symbol)))) (SIGNATURE radicalSolve ((List (List (Equation (Expression R)))) (List (Equation (Fraction (Polynomial R)))))) (SIGNATURE radicalRoots ((List (Expression R)) (Fraction (Polynomial R)) (Symbol))) (SIGNATURE radicalRoots ((List (List (Expression R))) (List (Fraction (Polynomial R))) (List (Symbol)))) (SIGNATURE contractSolve ((SuchThat (List (Expression R)) (List (Equation (Expression R)))) (Equation (Fraction (Polynomial R))) (Symbol))) (SIGNATURE contractSolve ((SuchThat (List (Expression R)) (List (Equation (Expression R)))) (Fraction (Polynomial R)) (Symbol))))
      [4] findZeros: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE radicalSolve ((List (Equation (Expression R))) (Fraction (Polynomial R)) (Symbol))) (SIGNATURE radicalSolve ((List (Equation (Expression R))) (Fraction (Polynomial R)))) (SIGNATURE radicalSolve ((List (Equation (Expression R))) (Equation (Fraction (Polynomial R))) (Symbol))) (SIGNATURE radicalSolve ((List (Equation (Expression R))) (Equation (Fraction (Polynomial R))))) (SIGNATURE radicalSolve ((List (List (Equation (Expression R)))) (List (Fraction (Polynomial R))) (List (Symbol)))) (SIGNATURE radicalSolve ((List (List (Equation (Expression R)))) (List (Fraction (Polynomial R))))) (SIGNATURE radicalSolve ((List (List (Equation (Expression R)))) (List (Equation (Fraction (Polynomial R)))) (List (Symbol)))) (SIGNATURE radicalSolve ((List (List (Equation (Expression R)))) (List (Equation (Fraction (Polynomial R)))))) (SIGNATURE radicalRoots ((List (Expression R)) (Fraction (Polynomial R)) (Symbol))) (SIGNATURE radicalRoots ((List (List (Expression R))) (List (Fraction (Polynomial R))) (List (Symbol)))) (SIGNATURE contractSolve ((SuchThat (List (Expression R)) (List (Equation (Expression R)))) (Equation (Fraction (Polynomial R))) (Symbol))) (SIGNATURE contractSolve ((SuchThat (List (Expression R)) (List (Equation (Expression R)))) (Fraction (Polynomial R)) (Symbol))))
      [5] radicalRoots:  result has no value
      [6] solveInner:  solutions has no value

--------------non extending category----------------------
.. SparseUnivariateLaurentSeries(#1,#2,#3) of cat 
(|Join| (|UnivariateLaurentSeriesConstructorCategory| |#1| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)) (CATEGORY |domain| (SIGNATURE |coerce| ($ (|Variable| |#2|))) (SIGNATURE |differentiate| ($ $ (|Variable| |#2|))) (IF (|has| |#1| (|Algebra| (|Fraction| (|Integer|)))) (SIGNATURE |integrate| ($ $ (|Variable| |#2|))) |noBranch|)))    has no  makeSeries : (Reference OrderedCompletion Integer,Stream Record(k: Integer,c: #1)) -> % 
============================================================================

   finalizing nrlib SULS 

============================================================================

   finalizing nrlib ULSCONS 
   Warnings: 
      [1] termsToOutputForm:  l has no value

============================================================================

   finalizing nrlib UPXS 
   Warnings: 
      [1] termsToOutputForm:  l has no value

--------------non extending category----------------------
.. UnivariateTaylorSeries(#1,#2,#3) of cat 
(|Join| (|UnivariateTaylorSeriesCategory| |#1|) (CATEGORY |domain| (SIGNATURE |coerce| ($ (|UnivariatePolynomial| |#2| |#1|))) (SIGNATURE |univariatePolynomial| ((|UnivariatePolynomial| |#2| |#1|) $ (|NonNegativeInteger|))) (SIGNATURE |coerce| ($ (|Variable| |#2|))) (SIGNATURE |differentiate| ($ $ (|Variable| |#2|))) (SIGNATURE |lagrange| ($ $)) (SIGNATURE |lambert| ($ $)) (SIGNATURE |oddlambert| ($ $)) (SIGNATURE |evenlambert| ($ $)) (SIGNATURE |generalLambert| ($ $ (|Integer|) (|Integer|))) (SIGNATURE |revert| ($ $)) (SIGNATURE |multisect| ($ (|Integer|) (|Integer|) $)) (SIGNATURE |invmultisect| ($ (|Integer|) (|Integer|) $)) (IF (|has| |#1| (|Algebra| (|Fraction| (|Integer|)))) (SIGNATURE |integrate| ($ $ (|Variable| |#2|))) |noBranch|)))    has no  ?*? : (%,Integer) -> % 
============================================================================

   finalizing nrlib UTS 

============================================================================

   finalizing nrlib ASP29 
   Warnings: 
      [1]  ISTATE has no value
      [2]  NEXTIT has no value
      [3]  NEVALS has no value
      [4]  NVECS has no value
      [5]  K has no value
      [6]  F has no value
      [7]  D has no value

============================================================================

   finalizing nrlib COMBF 
   Warnings: 
      [1] **: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE ** (F F F)) (SIGNATURE binomial (F F F)) (SIGNATURE permutation (F F F)) (SIGNATURE factorial (F F)) (SIGNATURE factorials (F F)) (SIGNATURE factorials (F F (Symbol))) (SIGNATURE summation (F F (Symbol))) (SIGNATURE summation (F F (SegmentBinding F))) (SIGNATURE product (F F (Symbol))) (SIGNATURE product (F F (SegmentBinding F))) (SIGNATURE iifact (F F)) (SIGNATURE iibinom (F (List F))) (SIGNATURE iiperm (F (List F))) (SIGNATURE iipow (F (List F))) (SIGNATURE iidsum (F (List F))) (SIGNATURE iidprod (F (List F))) (SIGNATURE ipow (F (List F))))
      [2] facts: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE ** (F F F)) (SIGNATURE binomial (F F F)) (SIGNATURE permutation (F F F)) (SIGNATURE factorial (F F)) (SIGNATURE factorials (F F)) (SIGNATURE factorials (F F (Symbol))) (SIGNATURE summation (F F (Symbol))) (SIGNATURE summation (F F (SegmentBinding F))) (SIGNATURE product (F F (Symbol))) (SIGNATURE product (F F (SegmentBinding F))) (SIGNATURE iifact (F F)) (SIGNATURE iibinom (F (List F))) (SIGNATURE iiperm (F (List F))) (SIGNATURE iipow (F (List F))) (SIGNATURE iidsum (F (List F))) (SIGNATURE iidprod (F (List F))) (SIGNATURE ipow (F (List F))))
      [3] summand: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE ** (F F F)) (SIGNATURE binomial (F F F)) (SIGNATURE permutation (F F F)) (SIGNATURE factorial (F F)) (SIGNATURE factorials (F F)) (SIGNATURE factorials (F F (Symbol))) (SIGNATURE summation (F F (Symbol))) (SIGNATURE summation (F F (SegmentBinding F))) (SIGNATURE product (F F (Symbol))) (SIGNATURE product (F F (SegmentBinding F))) (SIGNATURE iifact (F F)) (SIGNATURE iibinom (F (List F))) (SIGNATURE iiperm (F (List F))) (SIGNATURE iipow (F (List F))) (SIGNATURE iidsum (F (List F))) (SIGNATURE iidprod (F (List F))) (SIGNATURE ipow (F (List F))))
      [4] ipow:  n has no value

============================================================================

   finalizing nrlib D01AGNT 
   Warnings: 
      [1] continuousAtPoint?: not known that (AlgebraicallyClosedField) is of mode (CATEGORY domain (IF (has (Fraction (Integer)) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Fraction (Integer)))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Fraction (Integer)) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Fraction (Integer)) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [2] continuousAtPoint?: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (IF (has (Fraction (Integer)) (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace (Fraction (Integer)))) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has (Fraction (Integer)) (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has (Fraction (Integer)) (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [3] functionIsOscillatory: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE rangeIsFinite ((Union (: finite The range is finite) (: lowerInfinite The bottom of range is infinite) (: upperInfinite The top of range is infinite) (: bothInfinite Both top and bottom points are infinite) (: notEvaluated Range not yet evaluated)) (Record (: var (Symbol)) (: fn (Expression (DoubleFloat))) (: range (Segment (OrderedCompletion (DoubleFloat)))) (: abserr (DoubleFloat)) (: relerr (DoubleFloat))))) (SIGNATURE functionIsContinuousAtEndPoints ((Union (: continuous Continuous at the end points) (: lowerSingular There is a singularity at the lower end point) (: upperSingular There is a singularity at the upper end point) (: bothSingular There are singularities at both end points) (: notEvaluated End point continuity not yet evaluated)) (Record (: var (Symbol)) (: fn (Expression (DoubleFloat))) (: range (Segment (OrderedCompletion (DoubleFloat)))) (: abserr (DoubleFloat)) (: relerr (DoubleFloat))))) (SIGNATURE getlo ((DoubleFloat) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE gethi ((DoubleFloat) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE functionIsOscillatory ((Float) (Record (: var (Symbol)) (: fn (Expression (DoubleFloat))) (: range (Segment (OrderedCompletion (DoubleFloat)))) (: abserr (DoubleFloat)) (: relerr (DoubleFloat))))) (SIGNATURE problemPoints ((List (DoubleFloat)) (Expression (DoubleFloat)) (Symbol) (Segment (OrderedCompletion (DoubleFloat))))) (SIGNATURE singularitiesOf ((Stream (DoubleFloat)) (Record (: var (Symbol)) (: fn (Expression (DoubleFloat))) (: range (Segment (OrderedCompletion (DoubleFloat)))) (: abserr (DoubleFloat)) (: relerr (DoubleFloat))))) (SIGNATURE df2st ((String) (DoubleFloat))) (SIGNATURE ldf2lst ((List (String)) (List (DoubleFloat)))) (SIGNATURE sdf2lst ((List (String)) (Stream (DoubleFloat)))) (SIGNATURE commaSeparate ((String) (List (String)))) (SIGNATURE changeName ((Result) (Symbol) (Symbol) (Result))))
      [4] singularitiesOf:  str has no value

--------------non extending category----------------------
.. d01AgentsPackage of cat 
(CATEGORY |package| (SIGNATURE |rangeIsFinite| ((|Union| (|:| |finite| "The range is finite") (|:| |lowerInfinite| "The bottom of range is infinite") (|:| |upperInfinite| "The top of range is infinite") (|:| |bothInfinite| "Both top and bottom points are infinite") (|:| |notEvaluated| "Range not yet evaluated")) (|Record| (|:| |var| (|Symbol|)) (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|))))) (SIGNATURE |functionIsContinuousAtEndPoints| ((|Union| (|:| |continuous| "Continuous at the end points") (|:| |lowerSingular| "There is a singularity at the lower end point") (|:| |upperSingular| "There is a singularity at the upper end point") (|:| |bothSingular| "There are singularities at both end points") (|:| |notEvaluated| "End point continuity not yet evaluated")) (|Record| (|:| |var| (|Symbol|)) (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|))))) (SIGNATURE |getlo| ((|DoubleFloat|) (|Segment| (|OrderedCompletion| (|DoubleFloat|))))) (SIGNATURE |gethi| ((|DoubleFloat|) (|Segment| (|OrderedCompletion| (|DoubleFloat|))))) (SIGNATURE |functionIsOscillatory| ((|Float|) (|Record| (|:| |var| (|Symbol|)) (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|))))) (SIGNATURE |problemPoints| ((|List| (|DoubleFloat|)) (|Expression| (|DoubleFloat|)) (|Symbol|) (|Segment| (|OrderedCompletion| (|DoubleFloat|))))) (SIGNATURE |singularitiesOf| ((|Stream| (|DoubleFloat|)) (|Record| (|:| |var| (|Symbol|)) (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|))))) (SIGNATURE |df2st| ((|String|) (|DoubleFloat|))) (SIGNATURE |ldf2lst| ((|List| (|String|)) (|List| (|DoubleFloat|)))) (SIGNATURE |sdf2lst| ((|List| (|String|)) (|Stream| (|DoubleFloat|)))) (SIGNATURE |commaSeparate| ((|String|) (|List| (|String|)))) (SIGNATURE |changeName| ((|Result|) (|Symbol|) (|Symbol|) (|Result|))))    has no  functionIsFracPolynomial? : Record(var: Symbol,fn: Expression DoubleFloat,range: Segment OrderedCompletion DoubleFloat,abserr: DoubleFloat,relerr: DoubleFloat) -> Boolean 
============================================================================

   finalizing nrlib D01AGNT 

============================================================================

   finalizing nrlib FSPRMELT 
   Warnings: 
      [1] F2P: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE primitiveElement ((Record (: primelt F) (: poly (List (SparseUnivariatePolynomial F))) (: prim (SparseUnivariatePolynomial F))) (List F))) (IF (has F (AlgebraicallyClosedField)) (SIGNATURE primitiveElement ((Record (: primelt F) (: pol1 (SparseUnivariatePolynomial F)) (: pol2 (SparseUnivariatePolynomial F)) (: prim (SparseUnivariatePolynomial F))) F F)) noBranch))
      [2] K2P: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE primitiveElement ((Record (: primelt F) (: poly (List (SparseUnivariatePolynomial F))) (: prim (SparseUnivariatePolynomial F))) (List F))) (IF (has F (AlgebraicallyClosedField)) (SIGNATURE primitiveElement ((Record (: primelt F) (: pol1 (SparseUnivariatePolynomial F)) (: pol2 (SparseUnivariatePolynomial F)) (: prim (SparseUnivariatePolynomial F))) F F)) noBranch))
      [3] primitiveElement: not known that (Ring) is of mode (CATEGORY package (SIGNATURE primitiveElement ((Record (: primelt F) (: poly (List (SparseUnivariatePolynomial F))) (: prim (SparseUnivariatePolynomial F))) (List F))) (IF (has F (AlgebraicallyClosedField)) (SIGNATURE primitiveElement ((Record (: primelt F) (: pol1 (SparseUnivariatePolynomial F)) (: pol2 (SparseUnivariatePolynomial F)) (: prim (SparseUnivariatePolynomial F))) F F)) noBranch))
      [4] primitiveElement: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE primitiveElement ((Record (: primelt F) (: poly (List (SparseUnivariatePolynomial F))) (: prim (SparseUnivariatePolynomial F))) (List F))) (IF (has F (AlgebraicallyClosedField)) (SIGNATURE primitiveElement ((Record (: primelt F) (: pol1 (SparseUnivariatePolynomial F)) (: pol2 (SparseUnivariatePolynomial F)) (: prim (SparseUnivariatePolynomial F))) F F)) noBranch))
      [5] F2UP: not known that (Ring) is of mode (CATEGORY $ (SIGNATURE primitiveElement ((Record (: primelt F) (: pol1 (SparseUnivariatePolynomial F)) (: pol2 (SparseUnivariatePolynomial F)) (: prim (SparseUnivariatePolynomial F))) F F)))

============================================================================

   finalizing nrlib NTSCAT 
; (DEFUN |NormalizedTriangularSetCategory| ...) is being compiled.
;; The variable |NormalizedTriangularSetCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NormalizedTriangularSetCategory;| ...) is being compiled.
;; The variable |NormalizedTriangularSetCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib REGSET 
   Warnings: 
      [1] construct:  ts has no value
      [2] preprocess:  lp1 has no value
      [3] preprocess:  lp2 has no value
      [4] preprocess:  lts has no value
 
============================================================================

   finalizing nrlib REGSET 
Warning: REGSET;decompose has a duplicate definition in this file

--------------non extending category----------------------
.. RegularChain(#1,#2) of cat 
(|Join| (|RegularTriangularSetCategory| |#1| (|IndexedExponents| (|OrderedVariableList| |#2|)) (|OrderedVariableList| |#2|) (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|))) (CATEGORY |domain| (SIGNATURE |zeroSetSplit| ((|List| $) (|List| (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|))) (|Boolean|) (|Boolean|)))))    has no  internalAugment : (NewSparseMultivariatePolynomial(#1,OrderedVariableList #2),%,Boolean,Boolean,Boolean,Boolean,Boolean) -> List % 
============================================================================

   finalizing nrlib RGCHAIN 

============================================================================

   finalizing nrlib RSETGCD 
   Warnings: 
      [1] toseInvertibleSet:  toSave has no value
      [2] prepareSubResAlgo:  toSave has no value
      [3] internalLastSubResultant:  toReturn has no value

============================================================================

   finalizing nrlib RSDCMPK 
   Warnings: 
      [1] algebraicDecompose:  llpwt has no value
      [2] internalDecompose:  llpwt has no value
      [3] internalDecompose:  lts has no value
      [4] decompose:  toSave has no value
      [5] upDateBranches:  branches1 has no value
      [6] upDateBranches:  branches2 has no value

============================================================================

   finalizing nrlib RSDCMPK 
--->/research2/test0819/mnt/fedora5/../../src/algebra/RSDCMPK.spad-->RegularSetDecompositionPackage((KrullNumber (N LP Split))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/RSDCMPK.spad-->RegularSetDecompositionPackage((numberOfVariables (N LP Split))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/RSDCMPK.spad-->RegularSetDecompositionPackage((algebraicDecompose ((Record (: done Split) (: todo (List LpWT))) P TS B))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/RSDCMPK.spad-->RegularSetDecompositionPackage((transcendentalDecompose ((Record (: done Split) (: todo (List LpWT))) P TS N))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/RSDCMPK.spad-->RegularSetDecompositionPackage((transcendentalDecompose ((Record (: done Split) (: todo (List LpWT))) P TS))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/RSDCMPK.spad-->RegularSetDecompositionPackage((internalDecompose ((Record (: done Split) (: todo (List LpWT))) P TS N B))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/RSDCMPK.spad-->RegularSetDecompositionPackage((internalDecompose ((Record (: done Split) (: todo (List LpWT))) P TS N))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/RSDCMPK.spad-->RegularSetDecompositionPackage((internalDecompose ((Record (: done Split) (: todo (List LpWT))) P TS))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/RSDCMPK.spad-->RegularSetDecompositionPackage((decompose (Split LP Split B B))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/RSDCMPK.spad-->RegularSetDecompositionPackage((decompose (Split LP Split B B B B B))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/RSDCMPK.spad-->RegularSetDecompositionPackage((upDateBranches ((List LpWT) LP Split (List LpWT) Wip N))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/RSDCMPK.spad-->RegularSetDecompositionPackage((convert ((String) (Record (: val (List P)) (: tower TS))))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/RSDCMPK.spad-->RegularSetDecompositionPackage((printInfo ((Void) (List (Record (: val (List P)) (: tower TS))) N))): Not documented!!!!

============================================================================

   finalizing nrlib SFRTCAT 
; (DEFUN |SquareFreeRegularTriangularSetCategory| ...) is being compiled.
;; The variable |SquareFreeRegularTriangularSetCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |SquareFreeRegularTriangularSetCategory;| ...) is being compiled.
;; The variable |SquareFreeRegularTriangularSetCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib SIGNEF 
   Warnings: 
      [1] sign: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE sign ((Union (Integer) failed) F)) (SIGNATURE sign ((Union (Integer) failed) F (Symbol) (OrderedCompletion F))) (SIGNATURE sign ((Union (Integer) failed) F (Symbol) F (String))))
      [2] smpsign: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE sign ((Union (Integer) failed) F)) (SIGNATURE sign ((Union (Integer) failed) F (Symbol) (OrderedCompletion F))) (SIGNATURE sign ((Union (Integer) failed) F (Symbol) F (String))))

============================================================================

   finalizing nrlib SNTSCAT 
; (DEFUN |SquareFreeNormalizedTriangularSetCategory| ...) is being compiled.
;; The variable |SquareFreeNormalizedTriangularSetCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |SquareFreeNormalizedTriangularSetCategory;| ...) is being compiled.
;; The variable |SquareFreeNormalizedTriangularSetCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib SOLVETRA 
   Warnings: 
      [1] solveInner: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE solve ((List (Equation (Expression R))) (Expression R))) (SIGNATURE solve ((List (Equation (Expression R))) (Equation (Expression R)))) (SIGNATURE solve ((List (Equation (Expression R))) (Equation (Expression R)) (Symbol))) (SIGNATURE solve ((List (Equation (Expression R))) (Expression R) (Symbol))) (SIGNATURE solve ((List (List (Equation (Expression R)))) (List (Equation (Expression R))) (List (Symbol)))))
      [2] solveInner: not known that (Ring) is of mode (CATEGORY package (SIGNATURE solve ((List (Equation (Expression R))) (Expression R))) (SIGNATURE solve ((List (Equation (Expression R))) (Equation (Expression R)))) (SIGNATURE solve ((List (Equation (Expression R))) (Equation (Expression R)) (Symbol))) (SIGNATURE solve ((List (Equation (Expression R))) (Expression R) (Symbol))) (SIGNATURE solve ((List (List (Equation (Expression R)))) (List (Equation (Expression R))) (List (Symbol)))))
      [3] tryToTrans: not known that (TranscendentalFunctionCategory) is of mode (CATEGORY domain (IF (has R (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace R)) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has R (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has R (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [4] tryToTrans: not known that (AlgebraicallyClosedField) is of mode (CATEGORY domain (IF (has R (IntegralDomain)) (PROGN (ATTRIBUTE (AlgebraicallyClosedFunctionSpace R)) (ATTRIBUTE (TranscendentalFunctionCategory)) (ATTRIBUTE (CombinatorialOpsCategory)) (ATTRIBUTE (LiouvillianFunctionCategory)) (ATTRIBUTE (SpecialFunctionCategory)) (SIGNATURE reduce ($ $)) (SIGNATURE number? ((Boolean) $)) (SIGNATURE simplifyPower ($ $ (Integer))) (IF (has R (GcdDomain)) (PROGN (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $))) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial $)) (SparseUnivariatePolynomial $)))) noBranch) (IF (has R (RetractableTo (Integer))) (ATTRIBUTE (RetractableTo (AlgebraicNumber))) noBranch)) noBranch))
      [5] subsTan: not known that (IntegralDomain) is of mode (CATEGORY package (SIGNATURE solve ((List (Equation (Expression R))) (Expression R))) (SIGNATURE solve ((List (Equation (Expression R))) (Equation (Expression R)))) (SIGNATURE solve ((List (Equation (Expression R))) (Equation (Expression R)) (Symbol))) (SIGNATURE solve ((List (Equation (Expression R))) (Expression R) (Symbol))) (SIGNATURE solve ((List (List (Equation (Expression R)))) (List (Equation (Expression R))) (List (Symbol)))))
      [6] buildnexpr:  anscoeff has no value
      [7] buildnexpr:  ansmant has no value
      [8] combineLog:  ans has no value
      [9] funcinv: not known that (OrderedSet) is of mode (CATEGORY R (ATTRIBUTE complex))

============================================================================

   finalizing nrlib SRDCMPK 
   Warnings: 
      [1] algebraicDecompose:  lts has no value
      [2] internalDecompose:  llpwt has no value
      [3] internalDecompose:  lts has no value
      [4] decompose:  toSave has no value
      [5] upDateBranches:  branches1 has no value
      [6] upDateBranches:  branches2 has no value

============================================================================

   finalizing nrlib SRDCMPK 
   Processing SquareFreeRegularSetDecompositionPackage for Browser database:
--->/research2/test0819/mnt/fedora5/../../src/algebra/SRDCMPK.spad-->SquareFreeRegularSetDecompositionPackage((KrullNumber (N LP Split))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/SRDCMPK.spad-->SquareFreeRegularSetDecompositionPackage((numberOfVariables (N LP Split))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/SRDCMPK.spad-->SquareFreeRegularSetDecompositionPackage((algebraicDecompose ((Record (: done Split) (: todo (List LpWT))) P TS))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/SRDCMPK.spad-->SquareFreeRegularSetDecompositionPackage((transcendentalDecompose ((Record (: done Split) (: todo (List LpWT))) P TS N))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/SRDCMPK.spad-->SquareFreeRegularSetDecompositionPackage((transcendentalDecompose ((Record (: done Split) (: todo (List LpWT))) P TS))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/SRDCMPK.spad-->SquareFreeRegularSetDecompositionPackage((internalDecompose ((Record (: done Split) (: todo (List LpWT))) P TS N B))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/SRDCMPK.spad-->SquareFreeRegularSetDecompositionPackage((internalDecompose ((Record (: done Split) (: todo (List LpWT))) P TS N))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/SRDCMPK.spad-->SquareFreeRegularSetDecompositionPackage((internalDecompose ((Record (: done Split) (: todo (List LpWT))) P TS))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/SRDCMPK.spad-->SquareFreeRegularSetDecompositionPackage((decompose (Split LP Split B B))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/SRDCMPK.spad-->SquareFreeRegularSetDecompositionPackage((decompose (Split LP Split B B B B B))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/SRDCMPK.spad-->SquareFreeRegularSetDecompositionPackage((upDateBranches ((List LpWT) LP Split (List LpWT) Wip N))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/SRDCMPK.spad-->SquareFreeRegularSetDecompositionPackage((convert ((String) (Record (: val (List P)) (: tower TS))))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/SRDCMPK.spad-->SquareFreeRegularSetDecompositionPackage((printInfo ((Void) (List (Record (: val (List P)) (: tower TS))) N))): Not documented!!!!

============================================================================

   finalizing nrlib SREGSET 
   Warnings: 
      [1] construct:  ts has no value
      [2] internalAugment:  lts has no value
      [3] preprocess:  lp1 has no value
      [4] preprocess:  lp2 has no value
      [5] preprocess:  lts has no value

============================================================================

   finalizing nrlib SREGSET 
Warning: SREGSET;decompose has a duplicate definition in this file

============================================================================

   finalizing nrlib ZDSOLVE 
   Warnings: 
      [1] squareFree:  toSave has no value
      [2] realSolve: not known that (Ring) is of mode (CATEGORY package (SIGNATURE triangSolve ((List (RegularChain R ls)) (List (Polynomial R)) (Boolean) (Boolean))) (SIGNATURE triangSolve ((List (RegularChain R ls)) (List (Polynomial R)) (Boolean))) (SIGNATURE triangSolve ((List (RegularChain R ls)) (List (Polynomial R)))) (SIGNATURE univariateSolve ((List (Record (: complexRoots (SparseUnivariatePolynomial R)) (: coordinates (List (Polynomial R))))) (RegularChain R ls))) (SIGNATURE univariateSolve ((List (Record (: complexRoots (SparseUnivariatePolynomial R)) (: coordinates (List (Polynomial R))))) (List (Polynomial R)) (Boolean) (Boolean) (Boolean))) (SIGNATURE univariateSolve ((List (Record (: complexRoots (SparseUnivariatePolynomial R)) (: coordinates (List (Polynomial R))))) (List (Polynomial R)) (Boolean) (Boolean))) (SIGNATURE univariateSolve ((List (Record (: complexRoots (SparseUnivariatePolynomial R)) (: coordinates (List (Polynomial R))))) (List (Polynomial R)) (Boolean))) (SIGNATURE univariateSolve ((List (Record (: complexRoots (SparseUnivariatePolynomial R)) (: coordinates (List (Polynomial R))))) (List (Polynomial R)))) (SIGNATURE realSolve ((List (List (RealClosure (Fraction R)))) (RegularChain R ls))) (SIGNATURE realSolve ((List (List (RealClosure (Fraction R)))) (List (Polynomial R)) (Boolean) (Boolean) (Boolean))) (SIGNATURE realSolve ((List (List (RealClosure (Fraction R)))) (List (Polynomial R)) (Boolean) (Boolean))) (SIGNATURE realSolve ((List (List (RealClosure (Fraction R)))) (List (Polynomial R)) (Boolean))) (SIGNATURE realSolve ((List (List (RealClosure (Fraction R)))) (List (Polynomial R)))) (SIGNATURE positiveSolve ((List (List (RealClosure (Fraction R)))) (RegularChain R ls))) (SIGNATURE positiveSolve ((List (List (RealClosure (Fraction R)))) (List (Polynomial R)) (Boolean) (Boolean))) (SIGNATURE positiveSolve ((List (List (RealClosure (Fraction R)))) (List (Polynomial R)) (Boolean))) (SIGNATURE positiveSolve ((List (List (RealClosure (Fraction R)))) (List (Polynomial R)))) (SIGNATURE squareFree ((List (SquareFreeRegularTriangularSet R (IndexedExponents (OrderedVariableList ls2)) (OrderedVariableList ls2) (NewSparseMultivariatePolynomial R (OrderedVariableList ls2)))) (RegularChain R ls))) (SIGNATURE convert ((NewSparseMultivariatePolynomial R (OrderedVariableList ls2)) (NewSparseMultivariatePolynomial R (OrderedVariableList ls)))) (SIGNATURE convert ((Polynomial (RealClosure (Fraction R))) (Polynomial R))) (SIGNATURE convert ((Polynomial (RealClosure (Fraction R))) (NewSparseMultivariatePolynomial R (OrderedVariableList ls2)))) (SIGNATURE convert ((SparseUnivariatePolynomial (RealClosure (Fraction R))) (SparseUnivariatePolynomial R))) (SIGNATURE convert ((List (NewSparseMultivariatePolynomial R (OrderedVariableList ls2))) (SquareFreeRegularTriangularSet R (IndexedExponents (OrderedVariableList ls2)) (OrderedVariableList ls2) (NewSparseMultivariatePolynomial R (OrderedVariableList ls2))))))
      [3] realSolve:  toSave has no value
      [4] positiveSolve:  toSave has no value
      [5] univariateSolve:  lq2 has no value

============================================================================

   finalizing nrlib IRURPK 
   Warnings: 
      [1] makeLinearAndMonic:  toSave has no value
      [2] rur:  toSave has no value

============================================================================

   finalizing nrlib LEXTRIPK 
   Warnings: 
      [1] trueVariables:  truels has no value
      [2] lexTriangular:  polnum has no value
      [3] lexTriangular:  toSave has no value
      [4] squareFreeLexTriangular:  polnum has no value
      [5] squareFreeLexTriangular:  toSave has no value

============================================================================

   finalizing nrlib NORMPK 
   Semantic Errors: 
      [1] recip:  hesrg has two modes: 
 
   Warnings: 
      [1] normalizedAssociate:  mp has no value
      [2] normalizedAssociate:  tp has no value

============================================================================

   finalizing nrlib QCMPACK 
   Warnings: 
      [1] removeSuperfluousCases:  maxcases has no value
      [2] removeSuperfluousCases:  lpwt1 has no value
      [3] removeSuperfluousCases:  headmaxcases has no value
      [4] removeSuperfluousCases:  toSave has no value
      [5] removeSuperfluousQuasiComponents:  maxlts has no value
      [6] removeSuperfluousQuasiComponents:  headmaxlts has no value
      [7] removeSuperfluousQuasiComponents:  toSave has no value
      [8] branchIfCan:  polnum has no value
      [9] prepareDecompose:  branches has no value

============================================================================

   finalizing nrlib RURPK 
   Warnings: 
      [1] rur:  lq has no value
      [2] rur:  q has no value
      [3] rur:  toSave has no value
      [4] rur:  toReturn has no value

============================================================================

   finalizing nrlib SFRGCD 
   Warnings: 
      [1] stosePrepareSubResAlgo:  toSave has no value
      [2] stoseInternalLastSubResultant:  toReturn has no value
      [3] stoseInvertibleSetsqfreg:  toSave has no value
      [4] stoseInvertibleSetreg:  toSave has no value

============================================================================

   finalizing nrlib SFRGCD 
   Processing SquareFreeRegularTriangularSetGcdPackage for Browser database:
--->/research2/test0819/mnt/fedora5/../../src/algebra/SFRGCD.spad-->SquareFreeRegularTriangularSetGcdPackage((startTableGcd! ((Void) S S S))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/SFRGCD.spad-->SquareFreeRegularTriangularSetGcdPackage((stopTableGcd! ((Void)))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/SFRGCD.spad-->SquareFreeRegularTriangularSetGcdPackage((startTableInvSet! ((Void) S S S))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/SFRGCD.spad-->SquareFreeRegularTriangularSetGcdPackage((stopTableInvSet! ((Void)))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/SFRGCD.spad-->SquareFreeRegularTriangularSetGcdPackage((stosePrepareSubResAlgo ((List LpWT) P P TS))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/SFRGCD.spad-->SquareFreeRegularTriangularSetGcdPackage((stoseInternalLastSubResultant ((List PWT) P P TS B B))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/SFRGCD.spad-->SquareFreeRegularTriangularSetGcdPackage((stoseInternalLastSubResultant ((List PWT) (List LpWT) V B))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/SFRGCD.spad-->SquareFreeRegularTriangularSetGcdPackage((stoseIntegralLastSubResultant ((List PWT) P P TS))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/SFRGCD.spad-->SquareFreeRegularTriangularSetGcdPackage((stoseLastSubResultant ((List PWT) P P TS))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/SFRGCD.spad-->SquareFreeRegularTriangularSetGcdPackage((stoseInvertible? (B P TS))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/SFRGCD.spad-->SquareFreeRegularTriangularSetGcdPackage((stoseInvertible?sqfreg ((List BWT) P TS))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/SFRGCD.spad-->SquareFreeRegularTriangularSetGcdPackage((stoseInvertibleSetsqfreg (Split P TS))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/SFRGCD.spad-->SquareFreeRegularTriangularSetGcdPackage((stoseInvertible?reg ((List BWT) P TS))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/SFRGCD.spad-->SquareFreeRegularTriangularSetGcdPackage((stoseInvertibleSetreg (Split P TS))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/SFRGCD.spad-->SquareFreeRegularTriangularSetGcdPackage((stoseInvertible? ((List BWT) P TS))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/SFRGCD.spad-->SquareFreeRegularTriangularSetGcdPackage((stoseInvertibleSet (Split P TS))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/SFRGCD.spad-->SquareFreeRegularTriangularSetGcdPackage((stoseSquareFreePart ((List PWT) P TS))): Not documented!!!!

============================================================================

   finalizing nrlib SFQCMPK 
   Warnings: 
      [1] removeSuperfluousCases:  maxcases has no value
      [2] removeSuperfluousCases:  lpwt1 has no value
      [3] removeSuperfluousCases:  headmaxcases has no value
      [4] removeSuperfluousCases:  toSave has no value
      [5] removeSuperfluousQuasiComponents:  maxlts has no value
      [6] removeSuperfluousQuasiComponents:  headmaxlts has no value
      [7] removeSuperfluousQuasiComponents:  toSave has no value
      [8] branchIfCan:  polnum has no value
      [9] prepareDecompose:  branches has no value

============================================================================

   finalizing nrlib ODEEF 
   Warnings: 
      [1] solve: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE solve ((Union (Record (: particular (Vector F)) (: basis (List (Vector F)))) failed) (Matrix F) (Vector F) (Symbol))) (SIGNATURE solve ((Union (List (Vector F)) failed) (Matrix F) (Symbol))) (SIGNATURE solve ((Union (Record (: particular (Vector F)) (: basis (List (Vector F)))) failed) (List (Equation F)) (List (BasicOperator)) (Symbol))) (SIGNATURE solve ((Union (Record (: particular (Vector F)) (: basis (List (Vector F)))) failed) (List F) (List (BasicOperator)) (Symbol))) (SIGNATURE solve ((Union (Record (: particular F) (: basis (List F))) F failed) (Equation F) (BasicOperator) (Symbol))) (SIGNATURE solve ((Union (Record (: particular F) (: basis (List F))) F failed) F (BasicOperator) (Symbol))) (SIGNATURE solve ((Union F failed) (Equation F) (BasicOperator) (Equation F) (List F))) (SIGNATURE solve ((Union F failed) F (BasicOperator) (Equation F) (List F))))
      [2] parseODE:  n has no value
      [3] parseODE:  c has no value
      [4] parseODE:  k has no value
      [5] getcoeff: not known that (OrderedSet) is of mode (CATEGORY package (SIGNATURE solve ((Union (Record (: particular (Vector F)) (: basis (List (Vector F)))) failed) (Matrix F) (Vector F) (Symbol))) (SIGNATURE solve ((Union (List (Vector F)) failed) (Matrix F) (Symbol))) (SIGNATURE solve ((Union (Record (: particular (Vector F)) (: basis (List (Vector F)))) failed) (List (Equation F)) (List (BasicOperator)) (Symbol))) (SIGNATURE solve ((Union (Record (: particular (Vector F)) (: basis (List (Vector F)))) failed) (List F) (List (BasicOperator)) (Symbol))) (SIGNATURE solve ((Union (Record (: particular F) (: basis (List F))) F failed) (Equation F) (BasicOperator) (Symbol))) (SIGNATURE solve ((Union (Record (: particular F) (: basis (List F))) F failed) F (BasicOperator) (Symbol))) (SIGNATURE solve ((Union F failed) (Equation F) (BasicOperator) (Equation F) (List F))) (SIGNATURE solve ((Union F failed) F (BasicOperator) (Equation F) (List F))))
      [6] getcoeff: not known that (Ring) is of mode (CATEGORY package (SIGNATURE solve ((Union (Record (: particular (Vector F)) (: basis (List (Vector F)))) failed) (Matrix F) (Vector F) (Symbol))) (SIGNATURE solve ((Union (List (Vector F)) failed) (Matrix F) (Symbol))) (SIGNATURE solve ((Union (Record (: particular (Vector F)) (: basis (List (Vector F)))) failed) (List (Equation F)) (List (BasicOperator)) (Symbol))) (SIGNATURE solve ((Union (Record (: particular (Vector F)) (: basis (List (Vector F)))) failed) (List F) (List (BasicOperator)) (Symbol))) (SIGNATURE solve ((Union (Record (: particular F) (: basis (List F))) F failed) (Equation F) (BasicOperator) (Symbol))) (SIGNATURE solve ((Union (Record (: particular F) (: basis (List F))) F failed) F (BasicOperator) (Symbol))) (SIGNATURE solve ((Union F failed) (Equation F) (BasicOperator) (Equation F) (List F))) (SIGNATURE solve ((Union F failed) F (BasicOperator) (Equation F) (List F))))

============================================================================

   finalizing nrlib RINTERP 
   Processing RationalInterpolation for Browser database:
--->-->RationalInterpolation((interpolate ((Fraction (Polynomial F)) (List F) (List F) (NonNegativeInteger) (NonNegativeInteger)))): Not documented!!!!

============================================================================

   finalizing nrlib ABELGRP 
; (DEFUN |AbelianGroup| ...) is being compiled.
;; The variable |AbelianGroup;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib ABELMON- 
--->/research2/test0819/mnt/fedora5/../../src/algebra/ABELMON.spad-->AbelianMonoid&(((Zero) (%) constant)): Improper first word in comments: 
"0 is the additive identity element."

============================================================================

   finalizing nrlib ABELMON 
--->/research2/test0819/mnt/fedora5/../../src/algebra/ABELMON.spad-->AbelianMonoid(((Zero) (%) constant)): Improper first word in comments: 
"0 is the additive identity element."

============================================================================

   finalizing nrlib ABELMON 
; (DEFUN |AbelianMonoid| ...) is being compiled.
;; The variable |AbelianMonoid;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib ABELSG 
; (DEFUN |AbelianSemiGroup| ...) is being compiled.
;; The variable |AbelianSemiGroup;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib ALAGG 
; (DEFUN |AssociationListAggregate| ...) is being compiled.
;; The variable |AssociationListAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AssociationListAggregate;| ...) is being compiled.
;; The variable |AssociationListAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib BOOLEAN 
--------(true (%) constant)---------
--->/research2/test0819/mnt/fedora5/../../src/algebra/BOOLEAN.spad-->Boolean((true (%) constant)): Improper initial operator in comments: is
"\\spad{true} is a logical constant."
--------(false (%) constant)---------
--->/research2/test0819/mnt/fedora5/../../src/algebra/BOOLEAN.spad-->Boolean((false (%) constant)): Improper initial operator in comments: is
"\\spad{false} is a logical constant."

============================================================================

   finalizing nrlib CABMON 
; (DEFUN |CancellationAbelianMonoid| ...) is being compiled.
;; The variable |CancellationAbelianMonoid;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib CLAGG 
; (DEFUN |Collection| ...) is being compiled.
;; The variable |Collection;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |Collection;| ...) is being compiled.
;; The variable |Collection;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib COMRING 
; (DEFUN |CommutativeRing| ...) is being compiled.
;; The variable |CommutativeRing;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib DFLOAT 
--->/research2/test0819/mnt/fedora5/../../src/algebra/DFLOAT.spad-->DoubleFloat((doubleFloatFormat ((String) (String)))): Improper first word in comments: change
"change the output format for doublefloats using lisp format strings"

============================================================================

   finalizing nrlib DIFRING 
; (DEFUN |DifferentialRing| ...) is being compiled.
;; The variable |DifferentialRing;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib DIVRING 
; (DEFUN |DivisionRing| ...) is being compiled.
;; The variable |DivisionRing;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib ENTIRER 
; (DEFUN |EntireRing| ...) is being compiled.
;; The variable |EntireRing;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib ES- 
   Warnings: 
      [1] tower: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE odd? ((Boolean) S)) (SIGNATURE even? ((Boolean) S)) (SIGNATURE eval (S S (BasicOperator) (Mapping S S))) (SIGNATURE eval (S S (BasicOperator) (Mapping S (List S)))) (SIGNATURE eval (S S (List (BasicOperator)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (BasicOperator)) (List (Mapping S S)))) (SIGNATURE eval (S S (Symbol) (Mapping S S))) (SIGNATURE eval (S S (Symbol) (Mapping S (List S)))) (SIGNATURE eval (S S (List (Symbol)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (Symbol)) (List (Mapping S S)))) (SIGNATURE freeOf? ((Boolean) S (Symbol))) (SIGNATURE freeOf? ((Boolean) S S)) (SIGNATURE map (S (Mapping S S) (Kernel S))) (SIGNATURE kernel (S (BasicOperator) (List S))) (SIGNATURE kernel (S (BasicOperator) S)) (SIGNATURE is? ((Boolean) S (Symbol))) (SIGNATURE is? ((Boolean) S (BasicOperator))) (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE operators ((List (BasicOperator)) S)) (SIGNATURE tower ((List (Kernel S)) S)) (SIGNATURE mainKernel ((Union (Kernel S) failed) S)) (SIGNATURE height ((NonNegativeInteger) S)) (SIGNATURE distribute (S S S)) (SIGNATURE distribute (S S)) (SIGNATURE paren (S (List S))) (SIGNATURE paren (S S)) (SIGNATURE box (S (List S))) (SIGNATURE box (S S)) (SIGNATURE subst (S S (List (Kernel S)) (List S))) (SIGNATURE subst (S S (List (Equation S)))) (SIGNATURE subst (S S (Equation S))) (SIGNATURE elt (S (BasicOperator) (List S))) (SIGNATURE elt (S (BasicOperator) S S S S)) (SIGNATURE elt (S (BasicOperator) S S S)) (SIGNATURE elt (S (BasicOperator) S S)) (SIGNATURE elt (S (BasicOperator) S)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE eval (S S (List (Kernel S)) (List S))) (SIGNATURE eval (S S (Kernel S) S)) (SIGNATURE retract ((Kernel S) S)) (SIGNATURE retractIfCan ((Union (Kernel S) failed) S)))
      [2] freeOf?: not known that (OrderedSet) is of mode (CATEGORY domain (SIGNATURE odd? ((Boolean) S)) (SIGNATURE even? ((Boolean) S)) (SIGNATURE eval (S S (BasicOperator) (Mapping S S))) (SIGNATURE eval (S S (BasicOperator) (Mapping S (List S)))) (SIGNATURE eval (S S (List (BasicOperator)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (BasicOperator)) (List (Mapping S S)))) (SIGNATURE eval (S S (Symbol) (Mapping S S))) (SIGNATURE eval (S S (Symbol) (Mapping S (List S)))) (SIGNATURE eval (S S (List (Symbol)) (List (Mapping S (List S))))) (SIGNATURE eval (S S (List (Symbol)) (List (Mapping S S)))) (SIGNATURE freeOf? ((Boolean) S (Symbol))) (SIGNATURE freeOf? ((Boolean) S S)) (SIGNATURE map (S (Mapping S S) (Kernel S))) (SIGNATURE kernel (S (BasicOperator) (List S))) (SIGNATURE kernel (S (BasicOperator) S)) (SIGNATURE is? ((Boolean) S (Symbol))) (SIGNATURE is? ((Boolean) S (BasicOperator))) (SIGNATURE belong? ((Boolean) (BasicOperator))) (SIGNATURE operator ((BasicOperator) (BasicOperator))) (SIGNATURE operators ((List (BasicOperator)) S)) (SIGNATURE tower ((List (Kernel S)) S)) (SIGNATURE mainKernel ((Union (Kernel S) failed) S)) (SIGNATURE height ((NonNegativeInteger) S)) (SIGNATURE distribute (S S S)) (SIGNATURE distribute (S S)) (SIGNATURE paren (S (List S))) (SIGNATURE paren (S S)) (SIGNATURE box (S (List S))) (SIGNATURE box (S S)) (SIGNATURE subst (S S (List (Kernel S)) (List S))) (SIGNATURE subst (S S (List (Equation S)))) (SIGNATURE subst (S S (Equation S))) (SIGNATURE elt (S (BasicOperator) (List S))) (SIGNATURE elt (S (BasicOperator) S S S S)) (SIGNATURE elt (S (BasicOperator) S S S)) (SIGNATURE elt (S (BasicOperator) S S)) (SIGNATURE elt (S (BasicOperator) S)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE eval (S S (List (Kernel S)) (List S))) (SIGNATURE eval (S S (Kernel S) S)) (SIGNATURE retract ((Kernel S) S)) (SIGNATURE retractIfCan ((Union (Kernel S) failed) S)))
      [3] eval:  IN has no value
      [4] eval:  f has no value
      [5] eval:  s has no value
      [6] map:  IN has no value
      [7] map:  x has no value
 
============================================================================

   finalizing nrlib ES 
; (DEFUN |ExpressionSpace| ...) is being compiled.
;; The variable |ExpressionSpace;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib EUCDOM- 
   Warnings: 
      [1] principalIdeal:  coef1 has no value
      [2] principalIdeal:  coef2 has no value

============================================================================

   finalizing nrlib EUCDOM 
; (DEFUN |EuclideanDomain| ...) is being compiled.
;; The variable |EuclideanDomain;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FFIELDC- 
   Warnings: 
      [1] conditionP: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE order ((PositiveInteger) S)) (SIGNATURE discreteLog ((NonNegativeInteger) S)) (SIGNATURE primitive? ((Boolean) S)) (SIGNATURE createPrimitiveElement (S)) (SIGNATURE conditionP ((Union (Vector S) failed) (Matrix S))) (SIGNATURE charthRoot (S S)) (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE init (S)) (SIGNATURE nextItem ((Union S failed) S)) (SIGNATURE discreteLog ((Union (NonNegativeInteger) failed) S S)) (SIGNATURE order ((OnePointCompletion (PositiveInteger)) S)) (SIGNATURE charthRoot ((Union S failed) S)) (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))))
      [2] order: signature of lhs not unique: (PositiveInteger)S chosen
      [3] order:  ord has no value
      [4] discreteLog:  disc1 has no value
      [5] discreteLog:  disclog has no value
      [6] discreteLog: not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE order ((PositiveInteger) S)) (SIGNATURE discreteLog ((NonNegativeInteger) S)) (SIGNATURE primitive? ((Boolean) S)) (SIGNATURE createPrimitiveElement (S)) (SIGNATURE conditionP ((Union (Vector S) failed) (Matrix S))) (SIGNATURE charthRoot (S S)) (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE init (S)) (SIGNATURE nextItem ((Union S failed) S)) (SIGNATURE discreteLog ((Union (NonNegativeInteger) failed) S S)) (SIGNATURE order ((OnePointCompletion (PositiveInteger)) S)) (SIGNATURE charthRoot ((Union S failed) S)) (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))))
      [7] gcdPolynomial: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE order ((PositiveInteger) S)) (SIGNATURE discreteLog ((NonNegativeInteger) S)) (SIGNATURE primitive? ((Boolean) S)) (SIGNATURE createPrimitiveElement (S)) (SIGNATURE conditionP ((Union (Vector S) failed) (Matrix S))) (SIGNATURE charthRoot (S S)) (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE init (S)) (SIGNATURE nextItem ((Union S failed) S)) (SIGNATURE discreteLog ((Union (NonNegativeInteger) failed) S S)) (SIGNATURE order ((OnePointCompletion (PositiveInteger)) S)) (SIGNATURE charthRoot ((Union S failed) S)) (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))))

============================================================================

   finalizing nrlib FFIELDC 
; (DEFUN |FiniteFieldCategory| ...) is being compiled.
;; The variable |FiniteFieldCategory;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib FPS 
; (DEFUN |FloatingPointSystem| ...) is being compiled.
;; The variable |FloatingPointSystem;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib GCDDOM- 
   Warnings: 
      [1] gcdPolynomial: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))) (SIGNATURE lcm (S (List S))) (SIGNATURE lcm (S S S)) (SIGNATURE gcd (S (List S))) (SIGNATURE gcd (S S S)))

============================================================================

   finalizing nrlib GCDDOM- 
--->/research2/test0819/mnt/fedora5/../../src/algebra/GCDDOM.spad-->GcdDomain&((gcdPolynomial ((SparseUnivariatePolynomial %) (SparseUnivariatePolynomial %) (SparseUnivariatePolynomial %)))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/GCDDOM.spad-->GcdDomain&(): Spurious comments: \indented{1}{gcdPolynomial(\spad{p},{}\spad{q}) returns the greatest common divisor (\spad{gcd}) of} univariate polynomials over the domain

============================================================================

   finalizing nrlib GCDDOM 
--->/research2/test0819/mnt/fedora5/../../src/algebra/GCDDOM.spad-->GcdDomain((gcdPolynomial ((SparseUnivariatePolynomial %) (SparseUnivariatePolynomial %) (SparseUnivariatePolynomial %)))): Not documented!!!!
--->/research2/test0819/mnt/fedora5/../../src/algebra/GCDDOM.spad-->GcdDomain(): Spurious comments: \indented{1}{gcdPolynomial(\spad{p},{}\spad{q}) returns the greatest common divisor (\spad{gcd}) of} univariate polynomials over the domain

============================================================================

   finalizing nrlib GCDDOM 
; (DEFUN |GcdDomain| ...) is being compiled.
;; The variable |GcdDomain;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib HOAGG 
; (DEFUN |HomogeneousAggregate| ...) is being compiled.
;; The variable |HomogeneousAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |HomogeneousAggregate;| ...) is being compiled.
;; The variable |HomogeneousAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib ILIST 
   Warnings: 
      [1] latex:  s has no value

============================================================================

   finalizing nrlib INS- 
   Warnings: 
      [1] factor: not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE invmod (S S S)) (SIGNATURE powmod (S S S S)) (SIGNATURE mask (S S)) (SIGNATURE copy (S S)) (SIGNATURE rationalIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE rational ((Fraction (Integer)) S)) (SIGNATURE rational? ((Boolean) S)) (SIGNATURE symmetricRemainder (S S S)) (SIGNATURE bit? ((Boolean) S S)) (SIGNATURE even? ((Boolean) S)) (SIGNATURE init (S)) (SIGNATURE nextItem ((Union S failed) S)) (SIGNATURE convert ((DoubleFloat) S)) (SIGNATURE convert ((Float) S)) (SIGNATURE permutation (S S S)) (SIGNATURE factorial (S S)) (SIGNATURE binomial (S S S)) (SIGNATURE patternMatch ((PatternMatchResult (Integer) S) S (Pattern (Integer)) (PatternMatchResult (Integer) S))) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE convert ((InputForm) S)) (SIGNATURE retract ((Integer) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE convert ((Integer) S)) (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE positive? ((Boolean) S)) (SIGNATURE euclideanSize ((NonNegativeInteger) S)) (SIGNATURE factor ((Factored S) S)) (SIGNATURE squareFree ((Factored S) S)) (SIGNATURE prime? ((Boolean) S)) (SIGNATURE characteristic ((NonNegativeInteger))))
      [2] patternMatch: not known that (SetCategory) is of mode (CATEGORY domain (SIGNATURE invmod (S S S)) (SIGNATURE powmod (S S S S)) (SIGNATURE mask (S S)) (SIGNATURE copy (S S)) (SIGNATURE rationalIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE rational ((Fraction (Integer)) S)) (SIGNATURE rational? ((Boolean) S)) (SIGNATURE symmetricRemainder (S S S)) (SIGNATURE bit? ((Boolean) S S)) (SIGNATURE even? ((Boolean) S)) (SIGNATURE init (S)) (SIGNATURE nextItem ((Union S failed) S)) (SIGNATURE convert ((DoubleFloat) S)) (SIGNATURE convert ((Float) S)) (SIGNATURE permutation (S S S)) (SIGNATURE factorial (S S)) (SIGNATURE binomial (S S S)) (SIGNATURE patternMatch ((PatternMatchResult (Integer) S) S (Pattern (Integer)) (PatternMatchResult (Integer) S))) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE convert ((InputForm) S)) (SIGNATURE retract ((Integer) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE convert ((Integer) S)) (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE positive? ((Boolean) S)) (SIGNATURE euclideanSize ((NonNegativeInteger) S)) (SIGNATURE factor ((Factored S) S)) (SIGNATURE squareFree ((Factored S) S)) (SIGNATURE prime? ((Boolean) S)) (SIGNATURE characteristic ((NonNegativeInteger))))
      [3] powmod:  y has no value

============================================================================

   finalizing nrlib INS 
; (DEFUN |IntegerNumberSystem| ...) is being compiled.
;; The variable |IntegerNumberSystem;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib INT 
   Warnings: 
      [1] OMwrite: pretend(String) -- should replace by @
      [2] hash: signature of lhs not unique: $$ chosen
      [3] factorPolynomial: not known that (UnivariatePolynomialCategory (Integer)) is of mode (CATEGORY domain (SIGNATURE outputForm ((OutputForm) $ (OutputForm))) (SIGNATURE fmecg ($ $ (NonNegativeInteger) $ $)))
      [4] gcdPolynomial: not known that (UnivariatePolynomialCategory (Integer)) is of mode (CATEGORY domain (SIGNATURE outputForm ((OutputForm) $ (OutputForm))) (SIGNATURE fmecg ($ $ (NonNegativeInteger) $ $)))

============================================================================

   finalizing nrlib INTDOM 
; (DEFUN |IntegralDomain| ...) is being compiled.
;; The variable |IntegralDomain;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib ISTRING 
   Warnings: 
      [1] split:  j has no value

============================================================================

   finalizing nrlib LNAGG 
; (DEFUN |LinearAggregate| ...) is being compiled.
;; The variable |LinearAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |LinearAggregate;| ...) is being compiled.
;; The variable |LinearAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib LSAGG 
; (DEFUN |ListAggregate| ...) is being compiled.
;; The variable |ListAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |ListAggregate;| ...) is being compiled.
;; The variable |ListAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib MONOID- 
--->/research2/test0819/mnt/fedora5/../../src/algebra/MONOID.spad-->Monoid&(((One) (%) constant)): Improper first word in comments: 
"1 is the multiplicative identity."

============================================================================

   finalizing nrlib MONOID 
--->/research2/test0819/mnt/fedora5/../../src/algebra/MONOID.spad-->Monoid(((One) (%) constant)): Improper first word in comments: 
"1 is the multiplicative identity."

============================================================================

   finalizing nrlib MONOID 
; (DEFUN |Monoid| ...) is being compiled.
;; The variable |Monoid;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib MTSCAT 
; (DEFUN |MultivariateTaylorSeriesCategory| ...) is being compiled.
;; The variable |MultivariateTaylorSeriesCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |MultivariateTaylorSeriesCategory;| ...) is being compiled.
;; The variable |MultivariateTaylorSeriesCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

--------------non extending category----------------------
.. NonNegativeInteger of cat 
(|Join| (|OrderedAbelianMonoidSup|) (|Monoid|) (CATEGORY |domain| (SIGNATURE |quo| ($ $ $)) (SIGNATURE |rem| ($ $ $)) (SIGNATURE |gcd| ($ $ $)) (SIGNATURE |divide| ((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $)) (SIGNATURE |exquo| ((|Union| $ "failed") $ $)) (SIGNATURE |shift| ($ $ (|Integer|))) (SIGNATURE |random| ($ $)) (ATTRIBUTE (|commutative| "*"))))   has no 
============================================================================

(|IntegerNumberSystem|)    finalizing nrlib NNI 

============================================================================

   finalizing nrlib OINTDOM 
; (DEFUN |OrderedIntegralDomain| ...) is being compiled.
;; The variable |OrderedIntegralDomain;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib ORDRING 
; (DEFUN |OrderedRing| ...) is being compiled.
;; The variable |OrderedRing;AL| is undefined.
;; The compiler will assume this variable is a global.

--------------non extending category----------------------
.. PositiveInteger of cat 
(|Join| (|AbelianSemiGroup|) (|OrderedSet|) (|Monoid|) (CATEGORY |domain| (SIGNATURE |gcd| ($ $ $)) (ATTRIBUTE (|commutative| "*"))))   has no 
============================================================================

(|OrderedAbelianMonoidSup|)    finalizing nrlib PI 

============================================================================

   finalizing nrlib POLYCAT- 
   Warnings: 
      [1] eval:  IN has no value
      [2] coefficient: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))) (SIGNATURE squareFree ((Factored S) S)) (SIGNATURE squareFreePart (S S)) (SIGNATURE charthRoot ((Union S failed) S)) (SIGNATURE < ((Boolean) S S)) (SIGNATURE convert ((InputForm) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE patternMatch ((PatternMatchResult (Integer) S) S (Pattern (Integer)) (PatternMatchResult (Integer) S))) (SIGNATURE patternMatch ((PatternMatchResult (Float) S) S (Pattern (Float)) (PatternMatchResult (Float) S))) (SIGNATURE factor ((Factored S) S)) (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE conditionP ((Union (Vector S) failed) (Matrix S))) (SIGNATURE primitivePart (S S VarSet)) (SIGNATURE content (S S VarSet)) (SIGNATURE discriminant (S S VarSet)) (SIGNATURE resultant (S S S VarSet)) (SIGNATURE primitiveMonomials ((List S) S)) (SIGNATURE totalDegree ((NonNegativeInteger) S (List VarSet))) (SIGNATURE totalDegree ((NonNegativeInteger) S)) (SIGNATURE isExpt ((Union (Record (: var VarSet) (: exponent (NonNegativeInteger))) failed) S)) (SIGNATURE isTimes ((Union (List S) failed) S)) (SIGNATURE isPlus ((Union (List S) failed) S)) (SIGNATURE monomial (S S (List VarSet) (List (NonNegativeInteger)))) (SIGNATURE monomial (S S VarSet (NonNegativeInteger))) (SIGNATURE monicDivide ((Record (: quotient S) (: remainder S)) S S VarSet)) (SIGNATURE monomials ((List S) S)) (SIGNATURE coefficient (S S (List VarSet) (List (NonNegativeInteger)))) (SIGNATURE coefficient (S S VarSet (NonNegativeInteger))) (SIGNATURE reducedSystem ((Matrix R) (Matrix S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix R)) (: vec (Vector R))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix S))) (SIGNATURE retract (VarSet S)) (SIGNATURE retractIfCan ((Union VarSet failed) S)) (SIGNATURE eval (S S (List VarSet) (List S))) (SIGNATURE eval (S S VarSet S)) (SIGNATURE eval (S S (List VarSet) (List R))) (SIGNATURE eval (S S VarSet R)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE monomial (S R E)) (SIGNATURE coefficient (R S E)) (SIGNATURE retract ((Integer) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retract (R S)) (SIGNATURE content (R S)) (SIGNATURE primitivePart (S S)))
      [3] totalDegree:  w has no value
      [4] reducedSystem:  IN has no value
      [5] reducedSystem:  r has no value
      [6] reducedSystem: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))) (SIGNATURE squareFree ((Factored S) S)) (SIGNATURE squareFreePart (S S)) (SIGNATURE charthRoot ((Union S failed) S)) (SIGNATURE < ((Boolean) S S)) (SIGNATURE convert ((InputForm) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE patternMatch ((PatternMatchResult (Integer) S) S (Pattern (Integer)) (PatternMatchResult (Integer) S))) (SIGNATURE patternMatch ((PatternMatchResult (Float) S) S (Pattern (Float)) (PatternMatchResult (Float) S))) (SIGNATURE factor ((Factored S) S)) (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE conditionP ((Union (Vector S) failed) (Matrix S))) (SIGNATURE primitivePart (S S VarSet)) (SIGNATURE content (S S VarSet)) (SIGNATURE discriminant (S S VarSet)) (SIGNATURE resultant (S S S VarSet)) (SIGNATURE primitiveMonomials ((List S) S)) (SIGNATURE totalDegree ((NonNegativeInteger) S (List VarSet))) (SIGNATURE totalDegree ((NonNegativeInteger) S)) (SIGNATURE isExpt ((Union (Record (: var VarSet) (: exponent (NonNegativeInteger))) failed) S)) (SIGNATURE isTimes ((Union (List S) failed) S)) (SIGNATURE isPlus ((Union (List S) failed) S)) (SIGNATURE monomial (S S (List VarSet) (List (NonNegativeInteger)))) (SIGNATURE monomial (S S VarSet (NonNegativeInteger))) (SIGNATURE monicDivide ((Record (: quotient S) (: remainder S)) S S VarSet)) (SIGNATURE monomials ((List S) S)) (SIGNATURE coefficient (S S (List VarSet) (List (NonNegativeInteger)))) (SIGNATURE coefficient (S S VarSet (NonNegativeInteger))) (SIGNATURE reducedSystem ((Matrix R) (Matrix S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix R)) (: vec (Vector R))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix S))) (SIGNATURE retract (VarSet S)) (SIGNATURE retractIfCan ((Union VarSet failed) S)) (SIGNATURE eval (S S (List VarSet) (List S))) (SIGNATURE eval (S S VarSet S)) (SIGNATURE eval (S S (List VarSet) (List R))) (SIGNATURE eval (S S VarSet R)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE monomial (S R E)) (SIGNATURE coefficient (R S E)) (SIGNATURE retract ((Integer) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retract (R S)) (SIGNATURE content (R S)) (SIGNATURE primitivePart (S S)))
      [7] solveLinearPolynomialEquation: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))) (SIGNATURE squareFree ((Factored S) S)) (SIGNATURE squareFreePart (S S)) (SIGNATURE charthRoot ((Union S failed) S)) (SIGNATURE < ((Boolean) S S)) (SIGNATURE convert ((InputForm) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE patternMatch ((PatternMatchResult (Integer) S) S (Pattern (Integer)) (PatternMatchResult (Integer) S))) (SIGNATURE patternMatch ((PatternMatchResult (Float) S) S (Pattern (Float)) (PatternMatchResult (Float) S))) (SIGNATURE factor ((Factored S) S)) (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE conditionP ((Union (Vector S) failed) (Matrix S))) (SIGNATURE primitivePart (S S VarSet)) (SIGNATURE content (S S VarSet)) (SIGNATURE discriminant (S S VarSet)) (SIGNATURE resultant (S S S VarSet)) (SIGNATURE primitiveMonomials ((List S) S)) (SIGNATURE totalDegree ((NonNegativeInteger) S (List VarSet))) (SIGNATURE totalDegree ((NonNegativeInteger) S)) (SIGNATURE isExpt ((Union (Record (: var VarSet) (: exponent (NonNegativeInteger))) failed) S)) (SIGNATURE isTimes ((Union (List S) failed) S)) (SIGNATURE isPlus ((Union (List S) failed) S)) (SIGNATURE monomial (S S (List VarSet) (List (NonNegativeInteger)))) (SIGNATURE monomial (S S VarSet (NonNegativeInteger))) (SIGNATURE monicDivide ((Record (: quotient S) (: remainder S)) S S VarSet)) (SIGNATURE monomials ((List S) S)) (SIGNATURE coefficient (S S (List VarSet) (List (NonNegativeInteger)))) (SIGNATURE coefficient (S S VarSet (NonNegativeInteger))) (SIGNATURE reducedSystem ((Matrix R) (Matrix S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix R)) (: vec (Vector R))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix S))) (SIGNATURE retract (VarSet S)) (SIGNATURE retractIfCan ((Union VarSet failed) S)) (SIGNATURE eval (S S (List VarSet) (List S))) (SIGNATURE eval (S S VarSet S)) (SIGNATURE eval (S S (List VarSet) (List R))) (SIGNATURE eval (S S VarSet R)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE monomial (S R E)) (SIGNATURE coefficient (R S E)) (SIGNATURE retract ((Integer) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retract (R S)) (SIGNATURE content (R S)) (SIGNATURE primitivePart (S S)))
      [8] factorPolynomial: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))) (SIGNATURE squareFree ((Factored S) S)) (SIGNATURE squareFreePart (S S)) (SIGNATURE charthRoot ((Union S failed) S)) (SIGNATURE < ((Boolean) S S)) (SIGNATURE convert ((InputForm) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE patternMatch ((PatternMatchResult (Integer) S) S (Pattern (Integer)) (PatternMatchResult (Integer) S))) (SIGNATURE patternMatch ((PatternMatchResult (Float) S) S (Pattern (Float)) (PatternMatchResult (Float) S))) (SIGNATURE factor ((Factored S) S)) (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE conditionP ((Union (Vector S) failed) (Matrix S))) (SIGNATURE primitivePart (S S VarSet)) (SIGNATURE content (S S VarSet)) (SIGNATURE discriminant (S S VarSet)) (SIGNATURE resultant (S S S VarSet)) (SIGNATURE primitiveMonomials ((List S) S)) (SIGNATURE totalDegree ((NonNegativeInteger) S (List VarSet))) (SIGNATURE totalDegree ((NonNegativeInteger) S)) (SIGNATURE isExpt ((Union (Record (: var VarSet) (: exponent (NonNegativeInteger))) failed) S)) (SIGNATURE isTimes ((Union (List S) failed) S)) (SIGNATURE isPlus ((Union (List S) failed) S)) (SIGNATURE monomial (S S (List VarSet) (List (NonNegativeInteger)))) (SIGNATURE monomial (S S VarSet (NonNegativeInteger))) (SIGNATURE monicDivide ((Record (: quotient S) (: remainder S)) S S VarSet)) (SIGNATURE monomials ((List S) S)) (SIGNATURE coefficient (S S (List VarSet) (List (NonNegativeInteger)))) (SIGNATURE coefficient (S S VarSet (NonNegativeInteger))) (SIGNATURE reducedSystem ((Matrix R) (Matrix S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix R)) (: vec (Vector R))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix S))) (SIGNATURE retract (VarSet S)) (SIGNATURE retractIfCan ((Union VarSet failed) S)) (SIGNATURE eval (S S (List VarSet) (List S))) (SIGNATURE eval (S S VarSet S)) (SIGNATURE eval (S S (List VarSet) (List R))) (SIGNATURE eval (S S VarSet R)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE monomial (S R E)) (SIGNATURE coefficient (R S E)) (SIGNATURE retract ((Integer) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retract (R S)) (SIGNATURE content (R S)) (SIGNATURE primitivePart (S S)))
      [9] factor: not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))) (SIGNATURE squareFree ((Factored S) S)) (SIGNATURE squareFreePart (S S)) (SIGNATURE charthRoot ((Union S failed) S)) (SIGNATURE < ((Boolean) S S)) (SIGNATURE convert ((InputForm) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE patternMatch ((PatternMatchResult (Integer) S) S (Pattern (Integer)) (PatternMatchResult (Integer) S))) (SIGNATURE patternMatch ((PatternMatchResult (Float) S) S (Pattern (Float)) (PatternMatchResult (Float) S))) (SIGNATURE factor ((Factored S) S)) (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE conditionP ((Union (Vector S) failed) (Matrix S))) (SIGNATURE primitivePart (S S VarSet)) (SIGNATURE content (S S VarSet)) (SIGNATURE discriminant (S S VarSet)) (SIGNATURE resultant (S S S VarSet)) (SIGNATURE primitiveMonomials ((List S) S)) (SIGNATURE totalDegree ((NonNegativeInteger) S (List VarSet))) (SIGNATURE totalDegree ((NonNegativeInteger) S)) (SIGNATURE isExpt ((Union (Record (: var VarSet) (: exponent (NonNegativeInteger))) failed) S)) (SIGNATURE isTimes ((Union (List S) failed) S)) (SIGNATURE isPlus ((Union (List S) failed) S)) (SIGNATURE monomial (S S (List VarSet) (List (NonNegativeInteger)))) (SIGNATURE monomial (S S VarSet (NonNegativeInteger))) (SIGNATURE monicDivide ((Record (: quotient S) (: remainder S)) S S VarSet)) (SIGNATURE monomials ((List S) S)) (SIGNATURE coefficient (S S (List VarSet) (List (NonNegativeInteger)))) (SIGNATURE coefficient (S S VarSet (NonNegativeInteger))) (SIGNATURE reducedSystem ((Matrix R) (Matrix S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix R)) (: vec (Vector R))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix S))) (SIGNATURE retract (VarSet S)) (SIGNATURE retractIfCan ((Union VarSet failed) S)) (SIGNATURE eval (S S (List VarSet) (List S))) (SIGNATURE eval (S S VarSet S)) (SIGNATURE eval (S S (List VarSet) (List R))) (SIGNATURE eval (S S VarSet R)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE monomial (S R E)) (SIGNATURE coefficient (R S E)) (SIGNATURE retract ((Integer) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retract (R S)) (SIGNATURE content (R S)) (SIGNATURE primitivePart (S S)))
      [10] conditionP: :(Integer) --should replace by pretend
      [11] patternMatch: not known that (SetCategory) is of mode (CATEGORY domain (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))) (SIGNATURE squareFree ((Factored S) S)) (SIGNATURE squareFreePart (S S)) (SIGNATURE charthRoot ((Union S failed) S)) (SIGNATURE < ((Boolean) S S)) (SIGNATURE convert ((InputForm) S)) (SIGNATURE convert ((Pattern (Integer)) S)) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE patternMatch ((PatternMatchResult (Integer) S) S (Pattern (Integer)) (PatternMatchResult (Integer) S))) (SIGNATURE patternMatch ((PatternMatchResult (Float) S) S (Pattern (Float)) (PatternMatchResult (Float) S))) (SIGNATURE factor ((Factored S) S)) (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE conditionP ((Union (Vector S) failed) (Matrix S))) (SIGNATURE primitivePart (S S VarSet)) (SIGNATURE content (S S VarSet)) (SIGNATURE discriminant (S S VarSet)) (SIGNATURE resultant (S S S VarSet)) (SIGNATURE primitiveMonomials ((List S) S)) (SIGNATURE totalDegree ((NonNegativeInteger) S (List VarSet))) (SIGNATURE totalDegree ((NonNegativeInteger) S)) (SIGNATURE isExpt ((Union (Record (: var VarSet) (: exponent (NonNegativeInteger))) failed) S)) (SIGNATURE isTimes ((Union (List S) failed) S)) (SIGNATURE isPlus ((Union (List S) failed) S)) (SIGNATURE monomial (S S (List VarSet) (List (NonNegativeInteger)))) (SIGNATURE monomial (S S VarSet (NonNegativeInteger))) (SIGNATURE monicDivide ((Record (: quotient S) (: remainder S)) S S VarSet)) (SIGNATURE monomials ((List S) S)) (SIGNATURE coefficient (S S (List VarSet) (List (NonNegativeInteger)))) (SIGNATURE coefficient (S S VarSet (NonNegativeInteger))) (SIGNATURE reducedSystem ((Matrix R) (Matrix S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix R)) (: vec (Vector R))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix S) (Vector S))) (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix S))) (SIGNATURE retract (VarSet S)) (SIGNATURE retractIfCan ((Union VarSet failed) S)) (SIGNATURE eval (S S (List VarSet) (List S))) (SIGNATURE eval (S S VarSet S)) (SIGNATURE eval (S S (List VarSet) (List R))) (SIGNATURE eval (S S VarSet R)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE monomial (S R E)) (SIGNATURE coefficient (R S E)) (SIGNATURE retract ((Integer) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retract (R S)) (SIGNATURE content (R S)) (SIGNATURE primitivePart (S S)))

============================================================================

   finalizing nrlib POLYCAT 
; (DEFUN |PolynomialCategory| ...) is being compiled.
;; The variable |PolynomialCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |PolynomialCategory;| ...) is being compiled.
;; The variable |PolynomialCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib PSETCAT- 
   Warnings: 
      [1] collectUnder:  lq has no value
      [2] collectUpper:  lq has no value
      [3] collect:  lq has no value
      [4] sort:  us has no value
      [5] sort:  vs has no value
      [6] sort:  ws has no value
      [7] localTriangular?:  q has no value
      [8] headRemainder:  r has no value
      [9] rewriteIdealWithHeadRemainder:  rs has no value
      [10] rewriteIdealWithRemainder:  rs has no value

============================================================================

   finalizing nrlib PSETCAT- 
Warning: PSETCAT-;exactQuo has a duplicate definition in this file

============================================================================

   finalizing nrlib PSETCAT 
; (DEFUN |PolynomialSetCategory| ...) is being compiled.
;; The variable |PolynomialSetCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |PolynomialSetCategory;| ...) is being compiled.
;; The variable |PolynomialSetCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib QFCAT- 
   Warnings: 
      [1] reducedSystem: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE < ((Boolean) A A)) (SIGNATURE init (A)) (SIGNATURE nextItem ((Union A failed) A)) (SIGNATURE retract ((Integer) A)) (SIGNATURE retractIfCan ((Union (Integer) failed) A)) (SIGNATURE retract ((Fraction (Integer)) A)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) A)) (SIGNATURE convert ((DoubleFloat) A)) (SIGNATURE convert ((Float) A)) (SIGNATURE convert ((InputForm) A)) (SIGNATURE retract ((Symbol) A)) (SIGNATURE retractIfCan ((Union (Symbol) failed) A)) (SIGNATURE coerce (A (Symbol))) (SIGNATURE random (A)) (SIGNATURE fractionPart (A A)) (SIGNATURE denominator (A A)) (SIGNATURE numerator (A A)) (SIGNATURE patternMatch ((PatternMatchResult (Float) A) A (Pattern (Float)) (PatternMatchResult (Float) A))) (SIGNATURE patternMatch ((PatternMatchResult (Integer) A) A (Pattern (Integer)) (PatternMatchResult (Integer) A))) (SIGNATURE convert ((Pattern (Float)) A)) (SIGNATURE convert ((Pattern (Integer)) A)) (SIGNATURE reducedSystem ((Matrix S) (Matrix A))) (SIGNATURE reducedSystem ((Record (: mat (Matrix S)) (: vec (Vector S))) (Matrix A) (Vector A))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix A) (Vector A))) (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix A))) (SIGNATURE differentiate (A A (Mapping S S))) (SIGNATURE differentiate (A A (Mapping S S) (NonNegativeInteger))) (SIGNATURE differentiate (A A (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE differentiate (A A (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (A A (List (Symbol)))) (SIGNATURE differentiate (A A (Symbol))) (SIGNATURE differentiate (A A (NonNegativeInteger))) (SIGNATURE differentiate (A A)) (SIGNATURE map (A (Mapping S S) A)) (SIGNATURE retract (S A)) (SIGNATURE retractIfCan ((Union S failed) A)) (SIGNATURE coerce (A S)) (SIGNATURE coerce (A (Fraction (Integer)))) (SIGNATURE coerce (A A)) (SIGNATURE coerce (A (Integer))) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE coerce ((OutputForm) A)))
      [2] patternMatch: not known that (SetCategory) is of mode (CATEGORY domain (SIGNATURE < ((Boolean) A A)) (SIGNATURE init (A)) (SIGNATURE nextItem ((Union A failed) A)) (SIGNATURE retract ((Integer) A)) (SIGNATURE retractIfCan ((Union (Integer) failed) A)) (SIGNATURE retract ((Fraction (Integer)) A)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) A)) (SIGNATURE convert ((DoubleFloat) A)) (SIGNATURE convert ((Float) A)) (SIGNATURE convert ((InputForm) A)) (SIGNATURE retract ((Symbol) A)) (SIGNATURE retractIfCan ((Union (Symbol) failed) A)) (SIGNATURE coerce (A (Symbol))) (SIGNATURE random (A)) (SIGNATURE fractionPart (A A)) (SIGNATURE denominator (A A)) (SIGNATURE numerator (A A)) (SIGNATURE patternMatch ((PatternMatchResult (Float) A) A (Pattern (Float)) (PatternMatchResult (Float) A))) (SIGNATURE patternMatch ((PatternMatchResult (Integer) A) A (Pattern (Integer)) (PatternMatchResult (Integer) A))) (SIGNATURE convert ((Pattern (Float)) A)) (SIGNATURE convert ((Pattern (Integer)) A)) (SIGNATURE reducedSystem ((Matrix S) (Matrix A))) (SIGNATURE reducedSystem ((Record (: mat (Matrix S)) (: vec (Vector S))) (Matrix A) (Vector A))) (SIGNATURE reducedSystem ((Record (: mat (Matrix (Integer))) (: vec (Vector (Integer)))) (Matrix A) (Vector A))) (SIGNATURE reducedSystem ((Matrix (Integer)) (Matrix A))) (SIGNATURE differentiate (A A (Mapping S S))) (SIGNATURE differentiate (A A (Mapping S S) (NonNegativeInteger))) (SIGNATURE differentiate (A A (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE differentiate (A A (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (A A (List (Symbol)))) (SIGNATURE differentiate (A A (Symbol))) (SIGNATURE differentiate (A A (NonNegativeInteger))) (SIGNATURE differentiate (A A)) (SIGNATURE map (A (Mapping S S) A)) (SIGNATURE retract (S A)) (SIGNATURE retractIfCan ((Union S failed) A)) (SIGNATURE coerce (A S)) (SIGNATURE coerce (A (Fraction (Integer)))) (SIGNATURE coerce (A A)) (SIGNATURE coerce (A (Integer))) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE coerce ((OutputForm) A)))

============================================================================

   finalizing nrlib QFCAT 
; (DEFUN |QuotientFieldCategory| ...) is being compiled.
;; The variable |QuotientFieldCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |QuotientFieldCategory;| ...) is being compiled.
;; The variable |QuotientFieldCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib RCAGG 
; (DEFUN |RecursiveAggregate| ...) is being compiled.
;; The variable |RecursiveAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |RecursiveAggregate;| ...) is being compiled.
;; The variable |RecursiveAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib RING 
; (DEFUN |Ring| ...) is being compiled.
;; The variable |Ring;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib RNG 
; (DEFUN |Rng| ...) is being compiled.
;; The variable |Rng;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib RNS- 
   Warnings: 
      [1] patternMatch: not known that (SetCategory) is of mode (CATEGORY domain (SIGNATURE round (S S)) (SIGNATURE truncate (S S)) (SIGNATURE fractionPart (S S)) (SIGNATURE floor (S S)) (SIGNATURE ceiling (S S)) (SIGNATURE norm (S S)) (SIGNATURE patternMatch ((PatternMatchResult (Float) S) S (Pattern (Float)) (PatternMatchResult (Float) S))) (SIGNATURE convert ((Pattern (Float)) S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE coerce (S (Integer))) (SIGNATURE convert ((DoubleFloat) S)) (SIGNATURE convert ((Float) S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE coerce (S S)) (SIGNATURE coerce (S (Integer))) (SIGNATURE characteristic ((NonNegativeInteger))) (SIGNATURE coerce ((OutputForm) S)))

============================================================================

   finalizing nrlib RNS 
; (DEFUN |RealNumberSystem| ...) is being compiled.
;; The variable |RealNumberSystem;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib SETAGG 
; (DEFUN |SetAggregate| ...) is being compiled.
;; The variable |SetAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |SetAggregate;| ...) is being compiled.
;; The variable |SetAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib SETCAT 
; (DEFUN |SetCategory| ...) is being compiled.
;; The variable |SetCategory;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib SINT 
   Warnings: 
      [1] hash: signature of lhs not unique: $$ chosen

============================================================================

   finalizing nrlib SINT 
--->/research2/test0819/mnt/fedora5/../../src/algebra/SINT.spad-->SingleInteger((/\ (% % %))): Improper initial operator in comments: /
"\\spad{n} \\spad{/\\} \\spad{m} returns the bit-by-bit logical {\\em and} of the single integers \\spad{n} and \\spad{m}."
--->/research2/test0819/mnt/fedora5/../../src/algebra/SINT.spad-->SingleInteger((/\ (% % %))): Missing right brace for \spad
--------(\/ (% % %))---------
--->/research2/test0819/mnt/fedora5/../../src/algebra/SINT.spad-->SingleInteger((\/ (% % %))): Improper first word in comments: n
"\\spad{n} \\spad{\\/} \\spad{m} returns the bit-by-bit logical {\\em or} of the single integers \\spad{n} and \\spad{m}."

============================================================================

   finalizing nrlib SINT 
(SPADLET |$noSubsets| NIL)
Value = NIL

============================================================================

   finalizing nrlib STAGG 
; (DEFUN |StreamAggregate| ...) is being compiled.
;; The variable |StreamAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |StreamAggregate;| ...) is being compiled.
;; The variable |StreamAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib SYMBOL 
   Warnings: 
      [1] latex:  s has no value
      [2] latex:  sc has no value

============================================================================

   finalizing nrlib TSETCAT- 
   Warnings: 
      [1] basicSet:  p has no value
      [2] basicSet:  gps has no value
      [3] basicSet:  bps has no value
      [4] initials:  lip has no value
      [5] initiallyReduced?:  red has no value
      [6] reduce: signature of lhs not unique: PPS(Mapping P P P)(Mapping (Boolean) P P) chosen
      [7] rewriteSetWithReduction:  rs has no value
      [8] select: signature of lhs not unique: (Union P failed)SV chosen
      [9] collectQuasiMonic:  newlp has no value

============================================================================

   finalizing nrlib TSETCAT 
; (DEFUN |TriangularSetCategory| ...) is being compiled.
;; The variable |TriangularSetCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |TriangularSetCategory;| ...) is being compiled.
;; The variable |TriangularSetCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib UFD- 
   Warnings: 
      [1] squareFreePart: not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE squareFreePart (S S)) (SIGNATURE prime? ((Boolean) S)))

============================================================================

   finalizing nrlib UFD 
; (DEFUN |UniqueFactorizationDomain| ...) is being compiled.
;; The variable |UniqueFactorizationDomain;AL| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib ULSCAT 
; (DEFUN |UnivariateLaurentSeriesCategory| ...) is being compiled.
;; The variable |UnivariateLaurentSeriesCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |UnivariateLaurentSeriesCategory;| ...) is being compiled.
;; The variable |UnivariateLaurentSeriesCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib UPOLYC- 
   Warnings: 
      [1] solveLinearPolynomialEquation: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE coerce (S S)) (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))) (SIGNATURE squareFree ((Factored S) S)) (SIGNATURE squareFreePart (S S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE init (S)) (SIGNATURE nextItem ((Union S failed) S)) (SIGNATURE elt ((Fraction S) S (Fraction S))) (SIGNATURE euclideanSize ((NonNegativeInteger) S)) (SIGNATURE divide ((Record (: quotient S) (: remainder S)) S S)) (SIGNATURE integrate (S S)) (SIGNATURE elt (R (Fraction S) R)) (SIGNATURE separate ((Record (: primePart S) (: commonPart S)) S S)) (SIGNATURE pseudoDivide ((Record (: coef R) (: quotient S) (: remainder S)) S S)) (SIGNATURE pseudoQuotient (S S S)) (SIGNATURE composite ((Union (Fraction S) failed) (Fraction S) S)) (SIGNATURE composite ((Union S failed) S S)) (SIGNATURE order ((NonNegativeInteger) S S)) (SIGNATURE elt ((Fraction S) (Fraction S) (Fraction S))) (SIGNATURE differentiate (S S (Mapping R R) S)) (SIGNATURE shiftLeft (S S (NonNegativeInteger))) (SIGNATURE shiftRight (S S (NonNegativeInteger))) (SIGNATURE karatsubaDivide ((Record (: quotient S) (: remainder S)) S (NonNegativeInteger))) (SIGNATURE unmakeSUP (S (SparseUnivariatePolynomial R))) (SIGNATURE makeSUP ((SparseUnivariatePolynomial R) S)) (SIGNATURE vectorise ((Vector R) S (NonNegativeInteger))) (SIGNATURE differentiate (S S (Mapping R R))) (SIGNATURE differentiate (S S (Mapping R R) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE elt (S S S)) (SIGNATURE elt (R S R)) (SIGNATURE factor ((Factored S) S)) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE content (S S (SingletonAsOrderedSet))) (SIGNATURE variables ((List (SingletonAsOrderedSet)) S)) (SIGNATURE totalDegree ((NonNegativeInteger) S (List (SingletonAsOrderedSet)))) (SIGNATURE totalDegree ((NonNegativeInteger) S)) (SIGNATURE monomial (S S (List (SingletonAsOrderedSet)) (List (NonNegativeInteger)))) (SIGNATURE monomial (S S (SingletonAsOrderedSet) (NonNegativeInteger))) (SIGNATURE minimumDegree ((List (NonNegativeInteger)) S (List (SingletonAsOrderedSet)))) (SIGNATURE minimumDegree ((NonNegativeInteger) S (SingletonAsOrderedSet))) (SIGNATURE mainVariable ((Union (SingletonAsOrderedSet) failed) S)) (SIGNATURE degree ((List (NonNegativeInteger)) S (List (SingletonAsOrderedSet)))) (SIGNATURE degree ((NonNegativeInteger) S (SingletonAsOrderedSet))) (SIGNATURE retract ((SingletonAsOrderedSet) S)) (SIGNATURE retractIfCan ((Union (SingletonAsOrderedSet) failed) S)) (SIGNATURE coerce (S (SingletonAsOrderedSet))) (SIGNATURE eval (S S (List (SingletonAsOrderedSet)) (List S))) (SIGNATURE eval (S S (SingletonAsOrderedSet) S)) (SIGNATURE eval (S S (List (SingletonAsOrderedSet)) (List R))) (SIGNATURE eval (S S (SingletonAsOrderedSet) R)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE degree ((NonNegativeInteger) S)) (SIGNATURE monomial (S R (NonNegativeInteger))) (SIGNATURE retract ((Integer) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE coerce (S R)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retract (R S)) (SIGNATURE minimumDegree ((NonNegativeInteger) S)) (SIGNATURE content (R S)) (SIGNATURE differentiate (S S (List (SingletonAsOrderedSet)) (List (NonNegativeInteger)))) (SIGNATURE differentiate (S S (SingletonAsOrderedSet) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (SingletonAsOrderedSet)))) (SIGNATURE differentiate (S S (SingletonAsOrderedSet))) (SIGNATURE coerce (S (Integer))) (SIGNATURE coerce ((OutputForm) S)))
      [2] factorPolynomial: not known that (Ring) is of mode (CATEGORY domain (SIGNATURE coerce (S S)) (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))) (SIGNATURE squareFree ((Factored S) S)) (SIGNATURE squareFreePart (S S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE init (S)) (SIGNATURE nextItem ((Union S failed) S)) (SIGNATURE elt ((Fraction S) S (Fraction S))) (SIGNATURE euclideanSize ((NonNegativeInteger) S)) (SIGNATURE divide ((Record (: quotient S) (: remainder S)) S S)) (SIGNATURE integrate (S S)) (SIGNATURE elt (R (Fraction S) R)) (SIGNATURE separate ((Record (: primePart S) (: commonPart S)) S S)) (SIGNATURE pseudoDivide ((Record (: coef R) (: quotient S) (: remainder S)) S S)) (SIGNATURE pseudoQuotient (S S S)) (SIGNATURE composite ((Union (Fraction S) failed) (Fraction S) S)) (SIGNATURE composite ((Union S failed) S S)) (SIGNATURE order ((NonNegativeInteger) S S)) (SIGNATURE elt ((Fraction S) (Fraction S) (Fraction S))) (SIGNATURE differentiate (S S (Mapping R R) S)) (SIGNATURE shiftLeft (S S (NonNegativeInteger))) (SIGNATURE shiftRight (S S (NonNegativeInteger))) (SIGNATURE karatsubaDivide ((Record (: quotient S) (: remainder S)) S (NonNegativeInteger))) (SIGNATURE unmakeSUP (S (SparseUnivariatePolynomial R))) (SIGNATURE makeSUP ((SparseUnivariatePolynomial R) S)) (SIGNATURE vectorise ((Vector R) S (NonNegativeInteger))) (SIGNATURE differentiate (S S (Mapping R R))) (SIGNATURE differentiate (S S (Mapping R R) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE elt (S S S)) (SIGNATURE elt (R S R)) (SIGNATURE factor ((Factored S) S)) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE content (S S (SingletonAsOrderedSet))) (SIGNATURE variables ((List (SingletonAsOrderedSet)) S)) (SIGNATURE totalDegree ((NonNegativeInteger) S (List (SingletonAsOrderedSet)))) (SIGNATURE totalDegree ((NonNegativeInteger) S)) (SIGNATURE monomial (S S (List (SingletonAsOrderedSet)) (List (NonNegativeInteger)))) (SIGNATURE monomial (S S (SingletonAsOrderedSet) (NonNegativeInteger))) (SIGNATURE minimumDegree ((List (NonNegativeInteger)) S (List (SingletonAsOrderedSet)))) (SIGNATURE minimumDegree ((NonNegativeInteger) S (SingletonAsOrderedSet))) (SIGNATURE mainVariable ((Union (SingletonAsOrderedSet) failed) S)) (SIGNATURE degree ((List (NonNegativeInteger)) S (List (SingletonAsOrderedSet)))) (SIGNATURE degree ((NonNegativeInteger) S (SingletonAsOrderedSet))) (SIGNATURE retract ((SingletonAsOrderedSet) S)) (SIGNATURE retractIfCan ((Union (SingletonAsOrderedSet) failed) S)) (SIGNATURE coerce (S (SingletonAsOrderedSet))) (SIGNATURE eval (S S (List (SingletonAsOrderedSet)) (List S))) (SIGNATURE eval (S S (SingletonAsOrderedSet) S)) (SIGNATURE eval (S S (List (SingletonAsOrderedSet)) (List R))) (SIGNATURE eval (S S (SingletonAsOrderedSet) R)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE degree ((NonNegativeInteger) S)) (SIGNATURE monomial (S R (NonNegativeInteger))) (SIGNATURE retract ((Integer) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE coerce (S R)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retract (R S)) (SIGNATURE minimumDegree ((NonNegativeInteger) S)) (SIGNATURE content (R S)) (SIGNATURE differentiate (S S (List (SingletonAsOrderedSet)) (List (NonNegativeInteger)))) (SIGNATURE differentiate (S S (SingletonAsOrderedSet) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (SingletonAsOrderedSet)))) (SIGNATURE differentiate (S S (SingletonAsOrderedSet))) (SIGNATURE coerce (S (Integer))) (SIGNATURE coerce ((OutputForm) S)))
      [3] factor: not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE coerce (S S)) (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))) (SIGNATURE squareFree ((Factored S) S)) (SIGNATURE squareFreePart (S S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE init (S)) (SIGNATURE nextItem ((Union S failed) S)) (SIGNATURE elt ((Fraction S) S (Fraction S))) (SIGNATURE euclideanSize ((NonNegativeInteger) S)) (SIGNATURE divide ((Record (: quotient S) (: remainder S)) S S)) (SIGNATURE integrate (S S)) (SIGNATURE elt (R (Fraction S) R)) (SIGNATURE separate ((Record (: primePart S) (: commonPart S)) S S)) (SIGNATURE pseudoDivide ((Record (: coef R) (: quotient S) (: remainder S)) S S)) (SIGNATURE pseudoQuotient (S S S)) (SIGNATURE composite ((Union (Fraction S) failed) (Fraction S) S)) (SIGNATURE composite ((Union S failed) S S)) (SIGNATURE order ((NonNegativeInteger) S S)) (SIGNATURE elt ((Fraction S) (Fraction S) (Fraction S))) (SIGNATURE differentiate (S S (Mapping R R) S)) (SIGNATURE shiftLeft (S S (NonNegativeInteger))) (SIGNATURE shiftRight (S S (NonNegativeInteger))) (SIGNATURE karatsubaDivide ((Record (: quotient S) (: remainder S)) S (NonNegativeInteger))) (SIGNATURE unmakeSUP (S (SparseUnivariatePolynomial R))) (SIGNATURE makeSUP ((SparseUnivariatePolynomial R) S)) (SIGNATURE vectorise ((Vector R) S (NonNegativeInteger))) (SIGNATURE differentiate (S S (Mapping R R))) (SIGNATURE differentiate (S S (Mapping R R) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE elt (S S S)) (SIGNATURE elt (R S R)) (SIGNATURE factor ((Factored S) S)) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE content (S S (SingletonAsOrderedSet))) (SIGNATURE variables ((List (SingletonAsOrderedSet)) S)) (SIGNATURE totalDegree ((NonNegativeInteger) S (List (SingletonAsOrderedSet)))) (SIGNATURE totalDegree ((NonNegativeInteger) S)) (SIGNATURE monomial (S S (List (SingletonAsOrderedSet)) (List (NonNegativeInteger)))) (SIGNATURE monomial (S S (SingletonAsOrderedSet) (NonNegativeInteger))) (SIGNATURE minimumDegree ((List (NonNegativeInteger)) S (List (SingletonAsOrderedSet)))) (SIGNATURE minimumDegree ((NonNegativeInteger) S (SingletonAsOrderedSet))) (SIGNATURE mainVariable ((Union (SingletonAsOrderedSet) failed) S)) (SIGNATURE degree ((List (NonNegativeInteger)) S (List (SingletonAsOrderedSet)))) (SIGNATURE degree ((NonNegativeInteger) S (SingletonAsOrderedSet))) (SIGNATURE retract ((SingletonAsOrderedSet) S)) (SIGNATURE retractIfCan ((Union (SingletonAsOrderedSet) failed) S)) (SIGNATURE coerce (S (SingletonAsOrderedSet))) (SIGNATURE eval (S S (List (SingletonAsOrderedSet)) (List S))) (SIGNATURE eval (S S (SingletonAsOrderedSet) S)) (SIGNATURE eval (S S (List (SingletonAsOrderedSet)) (List R))) (SIGNATURE eval (S S (SingletonAsOrderedSet) R)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE degree ((NonNegativeInteger) S)) (SIGNATURE monomial (S R (NonNegativeInteger))) (SIGNATURE retract ((Integer) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE coerce (S R)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retract (R S)) (SIGNATURE minimumDegree ((NonNegativeInteger) S)) (SIGNATURE content (R S)) (SIGNATURE differentiate (S S (List (SingletonAsOrderedSet)) (List (NonNegativeInteger)))) (SIGNATURE differentiate (S S (SingletonAsOrderedSet) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (SingletonAsOrderedSet)))) (SIGNATURE differentiate (S S (SingletonAsOrderedSet))) (SIGNATURE coerce (S (Integer))) (SIGNATURE coerce ((OutputForm) S)))
      [4] elt: not known that (IntegralDomain) is of mode (CATEGORY domain (SIGNATURE coerce (S S)) (SIGNATURE gcdPolynomial ((SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S) (SparseUnivariatePolynomial S))) (SIGNATURE squareFree ((Factored S) S)) (SIGNATURE squareFreePart (S S)) (SIGNATURE coerce (S (Fraction (Integer)))) (SIGNATURE init (S)) (SIGNATURE nextItem ((Union S failed) S)) (SIGNATURE elt ((Fraction S) S (Fraction S))) (SIGNATURE euclideanSize ((NonNegativeInteger) S)) (SIGNATURE divide ((Record (: quotient S) (: remainder S)) S S)) (SIGNATURE integrate (S S)) (SIGNATURE elt (R (Fraction S) R)) (SIGNATURE separate ((Record (: primePart S) (: commonPart S)) S S)) (SIGNATURE pseudoDivide ((Record (: coef R) (: quotient S) (: remainder S)) S S)) (SIGNATURE pseudoQuotient (S S S)) (SIGNATURE composite ((Union (Fraction S) failed) (Fraction S) S)) (SIGNATURE composite ((Union S failed) S S)) (SIGNATURE order ((NonNegativeInteger) S S)) (SIGNATURE elt ((Fraction S) (Fraction S) (Fraction S))) (SIGNATURE differentiate (S S (Mapping R R) S)) (SIGNATURE shiftLeft (S S (NonNegativeInteger))) (SIGNATURE shiftRight (S S (NonNegativeInteger))) (SIGNATURE karatsubaDivide ((Record (: quotient S) (: remainder S)) S (NonNegativeInteger))) (SIGNATURE unmakeSUP (S (SparseUnivariatePolynomial R))) (SIGNATURE makeSUP ((SparseUnivariatePolynomial R) S)) (SIGNATURE vectorise ((Vector R) S (NonNegativeInteger))) (SIGNATURE differentiate (S S (Mapping R R))) (SIGNATURE differentiate (S S (Mapping R R) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)) (List (NonNegativeInteger)))) (SIGNATURE differentiate (S S (Symbol) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (Symbol)))) (SIGNATURE differentiate (S S (Symbol))) (SIGNATURE differentiate (S S)) (SIGNATURE differentiate (S S (NonNegativeInteger))) (SIGNATURE elt (S S S)) (SIGNATURE elt (R S R)) (SIGNATURE factor ((Factored S) S)) (SIGNATURE squareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorPolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE factorSquareFreePolynomial ((Factored (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE solveLinearPolynomialEquation ((Union (List (SparseUnivariatePolynomial S)) failed) (List (SparseUnivariatePolynomial S)) (SparseUnivariatePolynomial S))) (SIGNATURE content (S S (SingletonAsOrderedSet))) (SIGNATURE variables ((List (SingletonAsOrderedSet)) S)) (SIGNATURE totalDegree ((NonNegativeInteger) S (List (SingletonAsOrderedSet)))) (SIGNATURE totalDegree ((NonNegativeInteger) S)) (SIGNATURE monomial (S S (List (SingletonAsOrderedSet)) (List (NonNegativeInteger)))) (SIGNATURE monomial (S S (SingletonAsOrderedSet) (NonNegativeInteger))) (SIGNATURE minimumDegree ((List (NonNegativeInteger)) S (List (SingletonAsOrderedSet)))) (SIGNATURE minimumDegree ((NonNegativeInteger) S (SingletonAsOrderedSet))) (SIGNATURE mainVariable ((Union (SingletonAsOrderedSet) failed) S)) (SIGNATURE degree ((List (NonNegativeInteger)) S (List (SingletonAsOrderedSet)))) (SIGNATURE degree ((NonNegativeInteger) S (SingletonAsOrderedSet))) (SIGNATURE retract ((SingletonAsOrderedSet) S)) (SIGNATURE retractIfCan ((Union (SingletonAsOrderedSet) failed) S)) (SIGNATURE coerce (S (SingletonAsOrderedSet))) (SIGNATURE eval (S S (List (SingletonAsOrderedSet)) (List S))) (SIGNATURE eval (S S (SingletonAsOrderedSet) S)) (SIGNATURE eval (S S (List (SingletonAsOrderedSet)) (List R))) (SIGNATURE eval (S S (SingletonAsOrderedSet) R)) (SIGNATURE eval (S S (List S) (List S))) (SIGNATURE eval (S S S S)) (SIGNATURE eval (S S (Equation S))) (SIGNATURE eval (S S (List (Equation S)))) (SIGNATURE degree ((NonNegativeInteger) S)) (SIGNATURE monomial (S R (NonNegativeInteger))) (SIGNATURE retract ((Integer) S)) (SIGNATURE retractIfCan ((Union (Integer) failed) S)) (SIGNATURE retract ((Fraction (Integer)) S)) (SIGNATURE retractIfCan ((Union (Fraction (Integer)) failed) S)) (SIGNATURE coerce (S R)) (SIGNATURE retractIfCan ((Union R failed) S)) (SIGNATURE retract (R S)) (SIGNATURE minimumDegree ((NonNegativeInteger) S)) (SIGNATURE content (R S)) (SIGNATURE differentiate (S S (List (SingletonAsOrderedSet)) (List (NonNegativeInteger)))) (SIGNATURE differentiate (S S (SingletonAsOrderedSet) (NonNegativeInteger))) (SIGNATURE differentiate (S S (List (SingletonAsOrderedSet)))) (SIGNATURE differentiate (S S (SingletonAsOrderedSet))) (SIGNATURE coerce (S (Integer))) (SIGNATURE coerce ((OutputForm) S)))

============================================================================

   finalizing nrlib UPOLYC 
; (DEFUN |UnivariatePolynomialCategory| ...) is being compiled.
;; The variable |UnivariatePolynomialCategory;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |UnivariatePolynomialCategory;| ...) is being compiled.
;; The variable |UnivariatePolynomialCategory;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib URAGG 
; (DEFUN |UnaryRecursiveAggregate| ...) is being compiled.
;; The variable |UnaryRecursiveAggregate;AL| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |UnaryRecursiveAggregate;| ...) is being compiled.
;; The variable |UnaryRecursiveAggregate;CAT| is undefined.
;; The compiler will assume this variable is a global.

============================================================================

   finalizing nrlib CWMMT 
   Warnings: 
      [1] test6:  rec has no value
      [2] test7:  rec has no value
      [3] test8:  rec has no value
      [4] test9:  rec has no value
      [5] test10:  rec has no value

============================================================================

   finalizing nrlib CWMMT 
--->-->CompWithMappingModeTest((runTests ((Boolean)))): Not documented!!!!
--->-->CompWithMappingModeTest(constructor): Not documented!!!!
--->-->CompWithMappingModeTest(): Missing Description

   compiling exported systemCommand : String -> Void
      MSYSCMD;systemCommand;SV;1 is replaced by doSystemCommand 
   compiling exported OMmakeConn : SingleInteger -> $
      OMCONN;OMmakeConn;Si$;1 is replaced by OM-MAKECONN 
   compiling exported OMcloseConn : $ -> Void
      OMCONN;OMcloseConn;$V;2 is replaced by OM-CLOSECONN 
   compiling exported OMconnInDevice : $ -> OpenMathDevice
      OMCONN;OMconnInDevice;$Omd;3 is replaced by OM-GETCONNINDEV 
   compiling exported OMconnOutDevice : $ -> OpenMathDevice
      OMCONN;OMconnOutDevice;$Omd;4 is replaced by OM-GETCONNOUTDEV 
   compiling exported OMconnectTCP : ($,String,SingleInteger) -> Boolean
      OMCONN;OMconnectTCP;$SSiB;5 is replaced by OM-CONNECTTCP 
   compiling exported OMbindTCP : ($,SingleInteger) -> Boolean
      OMCONN;OMbindTCP;$SiB;6 is replaced by OM-BINDTCP 
   compiling exported OMopenFile : (String,String,OpenMathEncoding) -> $
      OMDEV;OMopenFile;2SOme$;1 is replaced by OM-OPENFILEDEV 
   compiling exported OMopenString : (String,OpenMathEncoding) -> $
      OMDEV;OMopenString;SOme$;2 is replaced by OM-OPENSTRINGDEV 
   compiling exported OMclose : $ -> Void
      OMDEV;OMclose;$V;3 is replaced by OM-CLOSEDEV 
   compiling exported OMsetEncoding : ($,OpenMathEncoding) -> Void
      OMDEV;OMsetEncoding;$OmeV;4 is replaced by OM-SETDEVENCODING 
   compiling exported OMputApp : $ -> Void
      OMDEV;OMputApp;$V;5 is replaced by OM-PUTAPP 
   compiling exported OMputAtp : $ -> Void
      OMDEV;OMputAtp;$V;6 is replaced by OM-PUTATP 
   compiling exported OMputAttr : $ -> Void
      OMDEV;OMputAttr;$V;7 is replaced by OM-PUTATTR 
   compiling exported OMputBind : $ -> Void
      OMDEV;OMputBind;$V;8 is replaced by OM-PUTBIND 
   compiling exported OMputBVar : $ -> Void
      OMDEV;OMputBVar;$V;9 is replaced by OM-PUTBVAR 
   compiling exported OMputError : $ -> Void
      OMDEV;OMputError;$V;10 is replaced by OM-PUTERROR 
   compiling exported OMputObject : $ -> Void
      OMDEV;OMputObject;$V;11 is replaced by OM-PUTOBJECT 
   compiling exported OMputEndApp : $ -> Void
      OMDEV;OMputEndApp;$V;12 is replaced by OM-PUTENDAPP 
   compiling exported OMputEndAtp : $ -> Void
      OMDEV;OMputEndAtp;$V;13 is replaced by OM-PUTENDATP 
   compiling exported OMputEndAttr : $ -> Void
      OMDEV;OMputEndAttr;$V;14 is replaced by OM-PUTENDATTR 
   compiling exported OMputEndBind : $ -> Void
      OMDEV;OMputEndBind;$V;15 is replaced by OM-PUTENDBIND 
   compiling exported OMputEndBVar : $ -> Void
      OMDEV;OMputEndBVar;$V;16 is replaced by OM-PUTENDBVAR 
   compiling exported OMputEndError : $ -> Void
      OMDEV;OMputEndError;$V;17 is replaced by OM-PUTENDERROR 
   compiling exported OMputEndObject : $ -> Void
      OMDEV;OMputEndObject;$V;18 is replaced by OM-PUTENDOBJECT 
   compiling exported OMputInteger : ($,Integer) -> Void
      OMDEV;OMputInteger;$IV;19 is replaced by OM-PUTINT 
   compiling exported OMputFloat : ($,DoubleFloat) -> Void
      OMDEV;OMputFloat;$DfV;20 is replaced by OM-PUTFLOAT 
   compiling exported OMputVariable : ($,Symbol) -> Void
      OMDEV;OMputVariable;$SV;21 is replaced by OM-PUTVAR 
   compiling exported OMputString : ($,String) -> Void
      OMDEV;OMputString;$SV;22 is replaced by OM-PUTSTRING 
   compiling exported OMputSymbol : ($,String,String) -> Void
      OMDEV;OMputSymbol;$2SV;23 is replaced by OM-PUTSYMBOL 
   compiling exported OMgetApp : $ -> Void
      OMDEV;OMgetApp;$V;24 is replaced by OM-GETAPP 
   compiling exported OMgetAtp : $ -> Void
      OMDEV;OMgetAtp;$V;25 is replaced by OM-GETATP 
   compiling exported OMgetAttr : $ -> Void
      OMDEV;OMgetAttr;$V;26 is replaced by OM-GETATTR 
   compiling exported OMgetBind : $ -> Void
      OMDEV;OMgetBind;$V;27 is replaced by OM-GETBIND 
   compiling exported OMgetBVar : $ -> Void
      OMDEV;OMgetBVar;$V;28 is replaced by OM-GETBVAR 
   compiling exported OMgetError : $ -> Void
      OMDEV;OMgetError;$V;29 is replaced by OM-GETERROR 
   compiling exported OMgetObject : $ -> Void
      OMDEV;OMgetObject;$V;30 is replaced by OM-GETOBJECT 
   compiling exported OMgetEndApp : $ -> Void
      OMDEV;OMgetEndApp;$V;31 is replaced by OM-GETENDAPP 
   compiling exported OMgetEndAtp : $ -> Void
      OMDEV;OMgetEndAtp;$V;32 is replaced by OM-GETENDATP 
   compiling exported OMgetEndAttr : $ -> Void
      OMDEV;OMgetEndAttr;$V;33 is replaced by OM-GETENDATTR 
   compiling exported OMgetEndBind : $ -> Void
      OMDEV;OMgetEndBind;$V;34 is replaced by OM-GETENDBIND 
   compiling exported OMgetEndBVar : $ -> Void
      OMDEV;OMgetEndBVar;$V;35 is replaced by OM-GETENDBVAR 
   compiling exported OMgetEndError : $ -> Void
      OMDEV;OMgetEndError;$V;36 is replaced by OM-GETENDERROR 
   compiling exported OMgetEndObject : $ -> Void
      OMDEV;OMgetEndObject;$V;37 is replaced by OM-GETENDOBJECT 
   compiling exported OMgetInteger : $ -> Integer
      OMDEV;OMgetInteger;$I;38 is replaced by OM-GETINT 
   compiling exported OMgetFloat : $ -> DoubleFloat
      OMDEV;OMgetFloat;$Df;39 is replaced by OM-GETFLOAT 
   compiling exported OMgetVariable : $ -> Symbol
      OMDEV;OMgetVariable;$S;40 is replaced by OM-GETVAR 
   compiling exported OMgetString : $ -> String
      OMDEV;OMgetString;$S;41 is replaced by OM-GETSTRING 
   compiling exported OMgetSymbol : $ -> Record(cd: String,name: String)
      OMDEV;OMgetSymbol;$R;42 is replaced by OM-GETSYMBOL 
   compiling exported OMgetType : $ -> Symbol
      OMDEV;OMgetType;$S;43 is replaced by OM-GETTYPE 
   compiling exported construct : $ -> Stream S
      ITUPLE;construct;$S;5 is replaced by x 
   compiling local func : (Symbol,D1,D2) -> I
      MKBCFUNC;func is replaced by FUNCALLnamexy 
   compiling exported makeRecord : (S,T$) -> Record(part1: S,part2: T$)
      MKRECORD;makeRecord;ST$R;1 is replaced by CONS 
   compiling local func : (Symbol,D) -> I
      MKUCFUNC;func is replaced by FUNCALLnamex 
   compiling exported coerce : S -> None
      NONE1;coerce;SN;1 is replaced by s 
   compiling exported coerce : Exit -> S
      RESLATC;coerce;ES;2 is replaced by errorBug: Should not be able to obtain value of type Exit 
   compiling exported eq? : (S,S) -> Boolean
      AGG-;eq?;2SB;1 is replaced by EQ 
   compiling exported coerce : $ -> OutputForm
      ANON;coerce;$Of;1 is replaced by x 
   compiling exported red : () -> $
      COLOR;red;$;4 is replaced by CONS11.0 
   compiling exported yellow : () -> $
      COLOR;yellow;$;5 is replaced by CONS111.0 
   compiling exported green : () -> $
      COLOR;green;$;6 is replaced by CONS141.0 
   compiling exported blue : () -> $
      COLOR;blue;$;7 is replaced by CONS221.0 
   compiling exported hue : $ -> Integer
      COLOR;hue;$I;8 is replaced by QCAR 
   compiling exported numberOfHues : () -> PositiveInteger
      COLOR;numberOfHues;Pi;10 is replaced by 27 
   compiling exported closed? : $ -> Boolean
      COMPPROP;closed?;$B;1 is replaced by QCAR 
   compiling exported solid? : $ -> Boolean
      COMPPROP;solid?;$B;2 is replaced by QCDR 
   compiling exported coerce : $ -> OutputForm
      EXIT;coerce;$Of;1 is replaced by errorCannot use an Exit value. 
   compiling exported = : ($,$) -> Boolean
      EXIT;=;2$B;2 is replaced by errorCannot use an Exit value. 
   compiling exported bitLength : Integer -> Integer
      INTBIT;bitLength;2I;1 is replaced by INTEGER-LENGTH 
   compiling exported bitTruth : (Integer,Integer) -> Boolean
      INTBIT;bitTruth;2IB;3 is replaced by INTEGER-BIT 
   compiling exported arg1 : (A,C) -> A
      MAPHACK2;arg1;ACA;1 is replaced by a 
   compiling exported arg2 : (A,C) -> C
      MAPHACK2;arg2;A2C;2 is replaced by c 
   compiling exported id : A -> A
      MAPPKG1;id;2A;5 is replaced by a 
   compiling exported coerce : Record(var: Symbol,fn: Expression DoubleFloat,range: Segment OrderedCompletion DoubleFloat,abserr: DoubleFloat,relerr: DoubleFloat) -> $
      NIPROB;coerce;R$;1 is replaced by CONS0s 
   compiling exported coerce : Record(fn: Expression DoubleFloat,range: List Segment OrderedCompletion DoubleFloat,abserr: DoubleFloat,relerr: DoubleFloat) -> $
      NIPROB;coerce;R$;2 is replaced by CONS1s 
   compiling exported coerce : Union(nia: Record(var: Symbol,fn: Expression DoubleFloat,range: Segment OrderedCompletion DoubleFloat,abserr: DoubleFloat,relerr: DoubleFloat),mdnia: Record(fn: Expression DoubleFloat,range: List Segment OrderedCompletion DoubleFloat,abserr: DoubleFloat,relerr: DoubleFloat)) -> $
      NIPROB;coerce;U$;3 is replaced by s 
   compiling exported coerce : $ -> OutputForm
      NONE;coerce;$Of;1 is replaced by NONE 
   compiling exported = : ($,$) -> Boolean
      NONE;=;2$B;2 is replaced by EQ 
   compiling exported coerce : Record(xinit: DoubleFloat,xend: DoubleFloat,fn: Vector Expression DoubleFloat,yinit: List DoubleFloat,intvals: List DoubleFloat,g: Expression DoubleFloat,abserr: DoubleFloat,relerr: DoubleFloat) -> $
      ODEPROB;coerce;R$;1 is replaced by s 
   compiling exported retract : $ -> Record(xinit: DoubleFloat,xend: DoubleFloat,fn: Vector Expression DoubleFloat,yinit: List DoubleFloat,intvals: List DoubleFloat,g: Expression DoubleFloat,abserr: DoubleFloat,relerr: DoubleFloat)
      ODEPROB;retract;$R;3 is replaced by x 
   compiling exported = : ($,$) -> Boolean
   compiling exported OMencodingUnknown : () -> $
      OMENC;OMencodingUnknown;$;3 is replaced by 0 
   compiling exported OMencodingBinary : () -> $
      OMENC;OMencodingBinary;$;4 is replaced by 1 
   compiling exported coerce : Record(fn: Expression DoubleFloat,init: List DoubleFloat,lb: List OrderedCompletion DoubleFloat,cf: List Expression DoubleFloat,ub: List OrderedCompletion DoubleFloat) -> $
      OPTPROB;coerce;R$;1 is replaced by CONS0s 
   compiling exported coerce : Record(lfn: List Expression DoubleFloat,init: List DoubleFloat) -> $
      OPTPROB;coerce;R$;2 is replaced by CONS1s 
   compiling exported coerce : Union(noa: Record(fn: Expression DoubleFloat,init: List DoubleFloat,lb: List OrderedCompletion DoubleFloat,cf: List Expression DoubleFloat,ub: List OrderedCompletion DoubleFloat),lsa: Record(lfn: List Expression DoubleFloat,init: List DoubleFloat)) -> $
      OPTPROB;coerce;U$;3 is replaced by x 
      SingleInteger 
      OMENC;=;2$B;1 is replaced by EQL 
   compiling exported dark : Color -> $
      Integer 
      PALETTE;dark;C$;1 is replaced by CONS1c 
   compiling exported dim : Color -> $
      PALETTE;dim;C$;2 is replaced by CONS2c 
   compiling exported bright : Color -> $
      PALETTE;bright;C$;3 is replaced by CONS3c 
   compiling exported pastel : Color -> $
      PALETTE;pastel;C$;4 is replaced by CONS4c 
   compiling exported light : Color -> $
      PALETTE;light;C$;5 is replaced by CONS5c 
   compiling exported hue : $ -> Color
      PALETTE;hue;$C;6 is replaced by QCDR 
   compiling exported shade : $ -> Integer
      PALETTE;shade;$I;7 is replaced by QCAR 
   compiling exported curve : (ComponentFunction,ComponentFunction) -> $
      PARPCURV;curve;2ComponentFunction$;1 is replaced by CONS 
   compiling exported curve : (ComponentFunction,ComponentFunction,ComponentFunction) -> $
      PARSCURV;curve;3ComponentFunction$;1 is replaced by VECTOR 
   compiling exported surface : (ComponentFunction,ComponentFunction,ComponentFunction) -> $
      PARSURF;surface;3ComponentFunction$;1 is replaced by VECTOR 
   compiling exported coerce : Record(pde: List Expression DoubleFloat,constraints: List Record(start: DoubleFloat,finish: DoubleFloat,grid: NonNegativeInteger,boundaryType: Integer,dStart: Matrix DoubleFloat,dFinish: Matrix DoubleFloat),f: List List Expression DoubleFloat,st: String,tol: DoubleFloat) -> $
      PDEPROB;coerce;R$;1 is replaced by s 
   compiling exported retract : $ -> Record(pde: List Expression DoubleFloat,constraints: List Record(start: DoubleFloat,finish: DoubleFloat,grid: NonNegativeInteger,boundaryType: Integer,dStart: Matrix DoubleFloat,dFinish: Matrix DoubleFloat),f: List List Expression DoubleFloat,st: String,tol: DoubleFloat)
      PDEPROB;retract;$R;3 is replaced by x 
   compiling local rep : $ -> Record(val: V,tower: C,flag: Boolean)
      SPLNODE;rep is replaced by n 
   compiling local per : Record(val: V,tower: C,flag: Boolean) -> $
      SPLNODE;per is replaced by r 
   compiling exported construct : (S1,S2) -> $
      SUCH;construct;S1S2$;1 is replaced by CONS 
   compiling exported lhs : $ -> S1
      SUCH;lhs;$S1;2 is replaced by QCAR 
   compiling exported rhs : $ -> S2
      SUCH;rhs;$S2;3 is replaced by QCDR 
   compiling exported sin? : $ -> Boolean
      FCOMP;sin?;$B;3 is replaced by QCAR 
   compiling exported argument : $ -> E
      FCOMP;argument;$E;4 is replaced by QCDR 
   compiling exported Zero : () -> $
      IDPAM;Zero;$;1 is replaced by  
   compiling exported zero? : $ -> Boolean
      Integer 
      List 
      IDPAM;zero?;$B;2 is replaced by NULL 
   compiling local qsetrest! : (Rep,Rep) -> Rep
      IDPAM;qsetrest! is replaced by RPLACD 
   compiling exported reductum : $ -> $
      IDPO;reductum;2$;5 is replaced by CDR 
   compiling exported exponent : $ -> E
      MODMONOM;exponent;$E;2 is replaced by QCDR 
   compiling exported index : $ -> IS
      MODMONOM;index;$IS;3 is replaced by QCAR 
   compiling exported coerce : $ -> Record(index: IS,exponent: E)
      MODMONOM;coerce;$R;4 is replaced by x 
   compiling exported coerce : Record(index: IS,exponent: E) -> $
      MODMONOM;coerce;R$;5 is replaced by x 
   compiling exported construct : (IS,E) -> $
      MODMONOM;construct;ISE$;6 is replaced by CONS 
   compiling exported makeVariable : (S,NonNegativeInteger) -> $
      ODVAR;makeVariable;SNni$;1 is replaced by CONS 
   compiling exported variable : $ -> S
      ODVAR;variable;$S;2 is replaced by QCAR 
   compiling exported order : $ -> NonNegativeInteger
      ODVAR;order;$Nni;3 is replaced by QCDR 
      OPQUERY;getDatabase;SD;1 is replaced by getBrowseDatabase 
   compiling exported makeVariable : (S,NonNegativeInteger) -> $
      SDVAR;makeVariable;SNni$;1 is replaced by CONS 
   compiling exported variable : $ -> S
      SDVAR;variable;$S;2 is replaced by QCAR 
   compiling exported order : $ -> NonNegativeInteger
      SDVAR;order;$Nni;3 is replaced by QCDR 
   compiling local err : R -> R
      AUTOMOR;err is replaced by errorMorphism is not invertible 
   compiling local ident : (R,Integer) -> R
      AUTOMOR;ident is replaced by r 
   compiling exported = : ($,$) -> Boolean
      AUTOMOR;=;2$B;4 is replaced by EQ 
   compiling exported morphism : (R,Integer) -> R -> $
      AUTOMOR;morphism;M$;9 is replaced by f 
   compiling exported position : $ -> NonNegativeInteger
      MKCHSET;position;$Nni;1 is replaced by QCDR 
   compiling exported coerce : $ -> S
      MKCHSET;coerce;$S;3 is replaced by QCAR 
   compiling exported modulus : $ -> Mod
      MODRING;modulus;$Mod;1 is replaced by QCDR 
   compiling exported coerce : $ -> R
      MODRING;coerce;$R;2 is replaced by QCAR 
   compiling exported convert : $ -> Integer
      ZMOD;convert;$I;4 is replaced by x 
   compiling exported Zero : () -> $
      ZMOD;Zero;$;7 is replaced by 0 
   compiling exported One : () -> $
      ZMOD;One;$;8 is replaced by 1 
   compiling exported init : () -> $
      ZMOD;init;$;9 is replaced by 0 
   compiling exported = : ($,$) -> Boolean
      ZMOD;=;2$B;11 is replaced by EQL 
   compiling exported convert : $ -> Integer
      ZMOD;convert;$I;22 is replaced by x 
   compiling exported Zero : () -> $
      ZMOD;Zero;$;25 is replaced by 0 
   compiling exported One : () -> $
      ZMOD;One;$;26 is replaced by 1 
   compiling exported init : () -> $
      ZMOD;init;$;27 is replaced by 0 
   compiling exported = : ($,$) -> Boolean
      ZMOD;=;2$B;29 is replaced by EQL 
   compiling exported Zero : () -> $
      CARD;Zero;$;1 is replaced by CONS-10 
   compiling exported One : () -> $
      CARD;One;$;2 is replaced by CONS-11 
   compiling exported coerce : NonNegativeInteger -> $
      CARD;coerce;Nni$;3 is replaced by CONS-1n 
   compiling exported Aleph : NonNegativeInteger -> $
      CARD;Aleph;Nni$;4 is replaced by CONSn-1 
   compiling local stream : $ -> Stream Coef
      ITAYLOR;stream is replaced by x 
   compiling exported series : Stream Coef -> $
      ITAYLOR;series;S$;2 is replaced by st 
   compiling exported pole? : $ -> Boolean
      ITAYLOR;pole?;$B;19 is replaced by QUOTE 
   compiling exported euclideanSize : S -> NonNegativeInteger
      FIELD-;euclideanSize;SNni;7 is replaced by 0 
   compiling exported prime? : S -> Boolean
      FIELD-;prime?;SB;8 is replaced by QUOTE 
   compiling exported scalarTypeOf : $ -> Union(fst: FortranScalarType,void: void)
      FT;scalarTypeOf;$U;2 is replaced by QVELTu0 
   compiling exported dimensionsOf : $ -> List Polynomial Integer
      FT;dimensionsOf;$L;3 is replaced by QVELTu1 
   compiling exported external? : $ -> Boolean
      FT;external?;$B;4 is replaced by QVELTu2 
   compiling local qsetrest! : (Rep,Rep) -> Rep
      IDPAG;qsetrest! is replaced by RPLACD 
   compiling exported op : P -> $
      OMLO;op;P$;1 is replaced by a 
   compiling exported po : $ -> P
      OMLO;po;$P;2 is replaced by x 
   compiling exported makeprod : (A,B) -> $
      PRODUCT;makeprod;AB$;3 is replaced by CONS 
   compiling exported selectfirst : $ -> A
      PRODUCT;selectfirst;$A;4 is replaced by QCAR 
   compiling exported selectsecond : $ -> B
      PRODUCT;selectsecond;$B;5 is replaced by QCDR 
   compiling exported empty : () -> $
      BTREE;empty;$;2 is replaced by  
   compiling exported empty : () -> $
      BTREE;empty;$;3 is replaced by  
   compiling exported empty? : $ -> Boolean
      BTREE;empty?;$B;7 is replaced by NULL 
   compiling exported coerce : List S -> $
      DLIST;coerce;L$;4 is replaced by x 
   compiling exported coerce : $ -> List S
      DLIST;coerce;$L;5 is replaced by x 
   compiling exported numberOfMonomials : $ -> NonNegativeInteger
      FM1;numberOfMonomials;$Nni;1 is replaced by LENGTH 
   compiling exported ListOfTerms : $ -> List Record(k: S,c: R)
      FM1;ListOfTerms;$L;2 is replaced by x 
   compiling exported leadingTerm : $ -> Record(k: S,c: R)
      FM1;leadingTerm;$R;3 is replaced by SPADfirst 
   compiling exported characteristic : () -> NonNegativeInteger
      IPADIC;characteristic;Nni;1 is replaced by 0 
   compiling local stream : $ -> Stream Integer
      IPADIC;stream is replaced by x 
   compiling local padic : Stream Integer -> $
      IPADIC;padic is replaced by x 
   compiling local showAll? : () -> Boolean
      IPADIC;showAll? is replaced by QUOTET 
   compiling exported coerce : $ -> XPBWPolynomial(VarSet,R)
      LEXP;coerce;$Xpbwp;11 is replaced by p 
   compiling exported makeUnit : () -> $
      LMOPS;makeUnit;$;1 is replaced by  
   compiling exported makeMulti : List Record(gen: S,exp: E) -> $
      LMOPS;makeMulti;L$;6 is replaced by l 
   compiling exported listOfMonoms : $ -> List Record(gen: S,exp: E)
      LMOPS;listOfMonoms;$L;8 is replaced by l 
   compiling exported reverse : $ -> $
      LMOPS;reverse;2$;11 is replaced by REVERSE 
   compiling exported reverse! : $ -> $
      LMOPS;reverse!;2$;12 is replaced by NREVERSE 
   compiling exported retractable? : $ -> Boolean
      MAGMA;retractable?;$B;5 is replaced by QEQCARx0 
   compiling exported coerce : VarSet -> $
      MAGMA;coerce;VarSet$;8 is replaced by CONS0l 
   compiling local zCoord : (DoubleFloat,DoubleFloat,DoubleFloat) -> DoubleFloat
      MESH;zCoord is replaced by z 
   compiling exported moebius : (F,F,F,F) -> $
      MOEBIUS;moebius;4F$;1 is replaced by VECTOR 
   compiling local a : $ -> F
      MOEBIUS;a is replaced by QVELTt0 
   compiling local b : $ -> F
      MOEBIUS;b is replaced by QVELTt1 
   compiling local c : $ -> F
      MOEBIUS;c is replaced by QVELTt2 
   compiling local d : $ -> F
      MOEBIUS;d is replaced by QVELTt3 
   compiling exported conjug : R -> R
      MODOP;conjug;2R;41 is replaced by r 
   compiling exported coerce : List Record(coef: R,monom: M) -> $
      MRING;coerce;L$;1 is replaced by x 
   compiling exported Zero : () -> $
      MRING;Zero;$;7 is replaced by  
   compiling exported numberOfMonomials : $ -> NonNegativeInteger
      MRING;numberOfMonomials;$Nni;21 is replaced by LENGTH 
   compiling exported coerce : R -> $
      ODR;coerce;R$;1 is replaced by u 
   compiling exported coerce : $ -> R
      ODR;coerce;$R;2 is replaced by p 
   compiling exported coerce : R -> $
      ONECOMP;coerce;R$;1 is replaced by CONS0r 
   compiling exported finite? : $ -> Boolean
      ONECOMP;finite?;$B;3 is replaced by QEQCARx0 
   compiling exported infinite? : $ -> Boolean
      ONECOMP;infinite?;$B;4 is replaced by QEQCARx1 
   compiling exported infinity : () -> $
      ONECOMP;infinity;$;5 is replaced by CONS1infinity 
   compiling exported coerce : R -> $
      ORDCOMP;coerce;R$;1 is replaced by CONS0r 
   compiling exported finite? : $ -> Boolean
      ORDCOMP;finite?;$B;3 is replaced by QEQCARx0 
   compiling exported infinite? : $ -> Boolean
      ORDCOMP;infinite?;$B;4 is replaced by QEQCARx1 
   compiling exported atoms : $ -> PatternMatchResult(R,S)
      PATLRES;atoms;$Pmr;2 is replaced by QCAR 
   compiling exported lists : $ -> PatternMatchResult(R,L)
      PATLRES;lists;$Pmr;3 is replaced by QCDR 
   compiling exported One : () -> $
      PBWLB;One;$;1 is replaced by  
   compiling exported first : $ -> LyndonWord VarSet
      PBWLB;first;$Lw;4 is replaced by SPADfirst 
   compiling exported rest : $ -> $
      PBWLB;rest;2$;5 is replaced by CDR 
   compiling exported coerce : LyndonWord VarSet -> $
      PBWLB;coerce;Lw$;7 is replaced by LIST 
   compiling exported ListOfTerms : $ -> List LyndonWord VarSet
      PBWLB;ListOfTerms;$L;8 is replaced by x 
   compiling exported coerce : $ -> Tree S
      PENDTREE;coerce;$T;1 is replaced by t 
   compiling exported coerce : R -> $
      PFR;coerce;R$;11 is replaced by CONSr 
   compiling exported wholePart : $ -> R
      PFR;wholePart;$R;21 is replaced by QCAR 
   compiling exported Zero : () -> $
      PRTITION;Zero;$;1 is replaced by  
   compiling exported coerce : $ -> List Integer
      PRTITION;coerce;$L;2 is replaced by s 
   compiling exported = : ($,$) -> Boolean
      PRTITION;=;2$B;6 is replaced by EQUAL 
   compiling exported matrix : $ -> SquareMatrix(n,K)
      QFORM;matrix;$Sm;2 is replaced by q 
   compiling exported SEGMENT : (S,S) -> $
      SEG;SEGMENT;2S$;1 is replaced by VECTORab1 
   compiling exported lo : $ -> S
      SEG;lo;$S;2 is replaced by QVELTs0 
   compiling exported low : $ -> S
      SEG;low;$S;3 is replaced by QVELTs0 
   compiling exported hi : $ -> S
      SEG;hi;$S;4 is replaced by QVELTs1 
   compiling exported high : $ -> S
      SEG;high;$S;5 is replaced by QVELTs1 
   compiling exported incr : $ -> Integer
      SEG;incr;$I;6 is replaced by QVELTs2 
   compiling exported segment : (S,S) -> $
      SEG;segment;2S$;7 is replaced by VECTORab1 
   compiling exported convert : S -> $
      SEG;convert;S$;11 is replaced by VECTORaa1 
   compiling exported = : ($,$) -> Boolean
      SEXOF;=;2$B;2 is replaced by EQUAL 
   compiling exported eq : ($,$) -> Boolean
      SEXOF;eq;2$B;3 is replaced by EQ 
   compiling exported null? : $ -> Boolean
      SEXOF;null?;$B;4 is replaced by NULL 
   compiling exported atom? : $ -> Boolean
      SEXOF;atom?;$B;5 is replaced by ATOM 
   compiling exported pair? : $ -> Boolean
      SEXOF;pair?;$B;6 is replaced by PAIRP 
   compiling exported string? : $ -> Boolean
      SEXOF;string?;$B;8 is replaced by STRINGP 
   compiling exported symbol? : $ -> Boolean
      SEXOF;symbol?;$B;9 is replaced by IDENTP 
   compiling exported integer? : $ -> Boolean
      SEXOF;integer?;$B;10 is replaced by INTP 
   compiling exported float? : $ -> Boolean
      SEXOF;float?;$B;11 is replaced by RNUMP 
   compiling exported expr : $ -> Expr
      SEXOF;expr;$Expr;17 is replaced by b 
   compiling exported convert : List $ -> $
      SEXOF;convert;L$;18 is replaced by l 
   compiling exported convert : Str -> $
      SEXOF;convert;Str$;19 is replaced by st 
   compiling exported convert : Sym -> $
      SEXOF;convert;Sym$;20 is replaced by sy 
   compiling exported convert : Int -> $
      SEXOF;convert;Int$;21 is replaced by n 
   compiling exported convert : Flt -> $
      SEXOF;convert;Flt$;22 is replaced by f 
   compiling exported convert : Expr -> $
      SEXOF;convert;Expr$;23 is replaced by e 
   compiling exported car : $ -> $
      SEXOF;car;2$;24 is replaced by CAR 
   compiling exported cdr : $ -> $
      SEXOF;cdr;2$;25 is replaced by CDR 
   compiling exported # : $ -> Integer
      SEXOF;#;$I;26 is replaced by LENGTH 
   compiling exported tableau : List List S -> $
      TABLEAU;tableau;L$;1 is replaced by lls 
   compiling exported listOfLists : $ -> List List S
      TABLEAU;listOfLists;$L;2 is replaced by x 
   compiling exported getCurve : $ -> Curve
      TUBE;getCurve;$Curve;1 is replaced by QVELTplot0 
   compiling exported listLoops : $ -> List List Point DoubleFloat
      TUBE;listLoops;$L;2 is replaced by QVELTplot1 
   compiling exported closed? : $ -> Boolean
      TUBE;closed?;$B;3 is replaced by QVELTplot2 
   compiling exported setClosed : ($,Boolean) -> Boolean
      TUBE;setClosed;$2B;5 is replaced by QSETVELTplot2flag 
   compiling exported tube : (Curve,List List Point DoubleFloat,Boolean) -> $
      TUBE;tube;CurveLB$;6 is replaced by VECTOR 
   compiling exported hasHi : $ -> Boolean
      UNISEG;hasHi;$B;6 is replaced by QEQCARs1 
   compiling exported # : $ -> NonNegativeInteger
      XPR;#;$Nni;3 is replaced by LENGTH 
   compiling exported # : $ -> NonNegativeInteger
      IARRAY1;#;$Nni;1 is replaced by QVSIZE 
   compiling exported empty : () -> $
      IARRAY1;empty;$;4 is replaced by GETREFV0 
   compiling exported qelt : ($,Integer) -> S
      IARRAY1;qelt;$IS;9 is replaced by ELT 
   compiling exported qsetelt! : ($,Integer,S) -> S
      IARRAY1;qsetelt!;$I2S;10 is replaced by SETELT 
   compiling exported maxIndex : $ -> Integer
      IARRAY1;maxIndex;$I;13 is replaced by QVSIZE 
   compiling exported physicalLength : $ -> NonNegativeInteger
      IFARRAY;physicalLength;$Nni;1 is replaced by QVELTr0 
   compiling exported coerce : $ -> Magma VarSet
      LWORD;coerce;$M;9 is replaced by x 
   compiling local rep : Matrix R -> PrimitiveArray PrimitiveArray R
      MATSTOR;rep is replaced by m 
   compiling exported numberOfMonomials : $ -> NonNegativeInteger
      PR;numberOfMonomials;$Nni;3 is replaced by LENGTH 
   compiling local qsetrest! : (Rep,Rep) -> Rep
      PR;qsetrest! is replaced by RPLACD 
   compiling exported frst : $ -> S
      STREAM;frst;$S;3 is replaced by QCAR 
   compiling exported rst : $ -> $
      STREAM;rst;2$;4 is replaced by QCDR 
   compiling exported concat : (S,$) -> $
      STREAM;concat;S2$;38 is replaced by CONS 
   compiling exported coerce : $ -> PrimitiveArray S
      TUPLE;coerce;$Pa;2 is replaced by QCDR 
   compiling exported length : $ -> NonNegativeInteger
      TUPLE;length;$Nni;3 is replaced by QCAR 
   compiling local construct : List Record(k: VarSet,c: $) -> FreeModule1($,VarSet)
      XRPOLY;construct is replaced by lt 
   compiling exported constant? : $ -> Boolean
      XRPOLY;constant?;$B;18 is replaced by QEQCARp0 
   compiling exported coerce : R -> $
      XRPOLY;coerce;R$;22 is replaced by CONS0r 
   compiling exported cartesian : Point R -> Point R
      COORDSYS;cartesian;2P;1 is replaced by pt 
   compiling exported coerce : List S -> $
      DBASE;coerce;L$;1 is replaced by u 
   compiling exported transcendenceDegree : () -> NonNegativeInteger
      FAXF-;transcendenceDegree;Nni;2 is replaced by 0 
   compiling exported algebraic? : S -> Boolean
      FAXF-;algebraic?;SB;7 is replaced by QUOTET 
   compiling exported transcendent? : S -> Boolean
      FAXF-;transcendent?;SB;8 is replaced by QUOTE 
   compiling exported string : Integer -> $
      STRING;string;I$;1 is replaced by STRINGIMAGE 
   compiling exported coerce : $ -> RadixExpansion 2
      BINARY;coerce;$Re;2 is replaced by x 
   compiling exported coerce : $ -> RadixExpansion 10
      DECIMAL;coerce;$Re;2 is replaced by x 
   compiling exported parts : $ -> List R
      DIRPROD;parts;$L;3 is replaced by VEC2LIST 
   compiling exported sayLength : String -> Integer
      DISPLAY;sayLength;SI;10 is replaced by QCSIZE 
   compiling exported = : (S,S) -> $
      EQ;=;2S$;2 is replaced by CONS 
   compiling exported equation : (S,S) -> $
      EQ;equation;2S$;3 is replaced by CONS 
   compiling exported lhs : $ -> S
      EQ;lhs;$S;4 is replaced by QCAR 
   compiling exported rhs : $ -> S
      EQ;rhs;$S;5 is replaced by QCDR 
   compiling exported name : $ -> FileName
      FILE;name;$Fn;8 is replaced by QVELTf0 
   compiling exported iomode : $ -> String
      FILE;iomode;$S;9 is replaced by QVELTf2 
   compiling exported = : ($,$) -> Boolean
      FNAME;=;2$B;1 is replaced by EQUAL 
   compiling exported coerce : $ -> String
      FNAME;coerce;$S;3 is replaced by NAMESTRING 
   compiling exported filename : (String,String,String) -> $
      FNAME;filename;3S$;5 is replaced by fnameMake 
   compiling exported directory : $ -> String
      FNAME;directory;$S;6 is replaced by fnameDirectory 
   compiling exported name : $ -> String
      FNAME;name;$S;7 is replaced by fnameName 
   compiling exported extension : $ -> String
      FNAME;extension;$S;8 is replaced by fnameType 
   compiling exported exists? : $ -> Boolean
      FNAME;exists?;$B;9 is replaced by fnameExists? 
   compiling exported readable? : $ -> Boolean
      FNAME;readable?;$B;10 is replaced by fnameReadable? 
   compiling exported writable? : $ -> Boolean
      FNAME;writable?;$B;11 is replaced by fnameWritable? 
   compiling exported new : (String,String,String) -> $
      FNAME;new;3S$;12 is replaced by fnameNew 
   compiling exported topFortranOutputStack : () -> String
      FOP;topFortranOutputStack;S;1 is replaced by STRINGIMAGE$fortranOutputFile 
   compiling exported prologue : $ -> List String
      FORMULA;prologue;$L;6 is replaced by QVELTf0 
   compiling exported formula : $ -> List String
      FORMULA;formula;$L;7 is replaced by QVELTf1 
   compiling exported epilogue : $ -> List String
      FORMULA;epilogue;$L;8 is replaced by QVELTf2 
   compiling exported setPrologue! : ($,List String) -> List String
      FORMULA;setPrologue!;$2L;9 is replaced by QSETVELTf0l 
   compiling exported setFormula! : ($,List String) -> List String
      FORMULA;setFormula!;$2L;10 is replaced by QSETVELTf1l 
   compiling exported setEpilogue! : ($,List String) -> List String
      FORMULA;setEpilogue!;$2L;11 is replaced by QSETVELTf2l 
   compiling local stringify : OutputForm -> String
      FORMULA;stringify is replaced by object2String 
   compiling local precondition : OutputForm -> OutputForm
      FORMULA;precondition is replaced by outputTran 
   compiling exported linkToFortran : (Symbol,List Union(array: List Symbol,scalar: Symbol),List List Union(array: List Symbol,scalar: Symbol),List Symbol) -> SExpression
      FORT;linkToFortran;SLLLSe;4 is replaced by makeFortnameargsdeclsres 
   compiling exported linkToFortran : (Symbol,List Union(array: List Symbol,scalar: Symbol),List List Union(array: List Symbol,scalar: Symbol),List Symbol,Symbol) -> SExpression
      FORT;linkToFortran;SLLLSSe;5 is replaced by makeFortnameargsdeclsresreturnType 
   compiling exported fortranLiteral : String -> Void
      FTEM;fortranLiteral;SV;2 is replaced by PRINTEXPs$fortranOutputStream 
   compiling exported fortranCarriageReturn : () -> Void
      FTEM;fortranCarriageReturn;V;3 is replaced by TERPRI$fortranOutputStream 
   compiling exported compBound : (BP,List BP) -> NonNegativeInteger
      GENEEZ;compBound;BPLNni;3 is replaced by errorattempt to use compBound without a well-understood valuation 
   compiling exported virtualDegree : Dpol -> NonNegativeInteger
      GBINTERN;virtualDegree;DpolNni;2 is replaced by 0 
   compiling exported key : $ -> Integer
      GRIMAGE;key;$I;10 is replaced by QVELTgraf0 
   compiling exported pointLists : $ -> List List Point DoubleFloat
      GRIMAGE;pointLists;$L;11 is replaced by QVELTgraf3 
   compiling exported coerce : $ -> RadixExpansion 16
      HEXADEC;coerce;$Re;2 is replaced by x 
   compiling exported empty : () -> $
      IBITS;empty;$;5 is replaced by BVEC-MAKE-FULL00 
   compiling exported copy : $ -> $
      IBITS;copy;2$;6 is replaced by BVEC-COPY 
   compiling exported # : $ -> NonNegativeInteger
      IBITS;#;$Nni;7 is replaced by BVEC-SIZE 
   compiling exported = : ($,$) -> Boolean
      IBITS;=;2$B;8 is replaced by BVEC-EQUAL 
   compiling exported < : ($,$) -> Boolean
      IBITS;<;2$B;9 is replaced by BVEC-GREATERuv 
   compiling exported Not : $ -> $
      IBITS;Not;2$;15 is replaced by BVEC-NOT 
   compiling exported < : ($,$) -> Boolean
      ICARD;<;2$B;1 is replaced by CGREATERPyx 
   compiling exported = : ($,$) -> Boolean
      ICARD;=;2$B;2 is replaced by EQUAL 
   compiling exported coerce : String -> $
      ICARD;coerce;S$;5 is replaced by s 
   compiling exported empty : () -> $
      IIARRAY2;empty;$;2 is replaced by GETREFV0 
   compiling exported nrows : $ -> NonNegativeInteger
      IIARRAY2;nrows;$Nni;8 is replaced by QVSIZE 
   compiling local poly : $ -> UP
      LAUPOL;poly is replaced by QCAR 
   compiling exported order : $ -> Integer
      LAUPOL;order;$I;5 is replaced by QCDR 
   compiling local gpol : (UP,Integer) -> $
      LAUPOL;gpol is replaced by CONS 
   compiling exported numer : $ -> M
      LO;numer;$M;5 is replaced by QCAR 
   compiling exported denom : $ -> S
      LO;denom;$S;6 is replaced by QCDR 
   compiling exported mantissa : $ -> Integer
      MFLOAT;mantissa;$I;4 is replaced by QCAR 
   compiling exported exponent : $ -> Integer
      MFLOAT;exponent;$I;5 is replaced by QCDR 
   compiling exported Zero : () -> $
      MFLOAT;Zero;$;28 is replaced by CONS00 
   compiling exported characteristic : () -> NonNegativeInteger
      MFLOAT;characteristic;Nni;47 is replaced by 0 
   compiling exported retract : $ -> Integer
      MINT;retract;$I;5 is replaced by u 
   compiling exported retractIfCan : $ -> Union(Integer,failed)
      MINT;retractIfCan;$U;6 is replaced by CONS0u 
   compiling exported lift : $ -> Rep
      MODMON;lift;$Rep;15 is replaced by x 
   compiling local rep : $ -> List Record(k: NonNegativeInteger,c: R)
      NSUP;rep is replaced by s 
   compiling local per : List Record(k: NonNegativeInteger,c: R) -> $
      NSUP;per is replaced by l 
   compiling exported coerce : $ -> SparseUnivariatePolynomial R
      NSUP;coerce;$Sup;3 is replaced by p 
   compiling exported coerce : SparseUnivariatePolynomial R -> $
      NSUP;coerce;Sup$;4 is replaced by p 
   compiling exported retractIfCan : $ -> Union(SparseUnivariatePolynomial R,failed)
      NSUP;retractIfCan;$U;5 is replaced by CONS0p 
   compiling exported OMlistCDs : () -> List String
      OMPKG;OMlistCDs;L;5 is replaced by OM-LISTCDS 
   compiling exported OMlistSymbols : String -> List String
      OMPKG;OMlistSymbols;SL;6 is replaced by OM-LISTSYMBOLS 
   compiling local getExpon : $ -> Integer
      PADICRC;getExpon is replaced by QCAR 
   compiling local getZp : $ -> PADIC
      PADICRC;getZp is replaced by QCDR 
   compiling local makeQp : (Integer,PADIC) -> $
      PADICRC;makeQp is replaced by CONS 
   compiling local showAll? : () -> Boolean
      PADICRC;showAll? is replaced by QUOTET 
   compiling exported status : $ -> Union(Boolean,failed)
      QALGSET;status;$U;8 is replaced by QVELTx0 
   compiling exported definingEquations : $ -> List Dpoly
      QALGSET;definingEquations;$L;10 is replaced by QVELTx1 
   compiling exported definingInequation : $ -> Dpoly
      QALGSET;definingInequation;$Dpoly;11 is replaced by QVELTx2 
   compiling exported characteristic : () -> NonNegativeInteger
      RADIX;characteristic;Nni;1 is replaced by 0 
   compiling exported Zero : () -> $
      RADIX;Zero;$;3 is replaced by VECTOR1 
   compiling exported wholeRagits : $ -> List Integer
      RADIX;wholeRagits;$L;25 is replaced by QVELTa1 
   compiling exported prefixRagits : $ -> List Integer
      RADIX;prefixRagits;$L;27 is replaced by QVELTa2 
   compiling exported cycleRagits : $ -> List Integer
      RADIX;cycleRagits;$L;28 is replaced by QVELTa3 
   compiling exported characteristic : () -> NonNegativeInteger
      RCFIELD-;characteristic;Nni;4 is replaced by 0 
   compiling exported lift : $ -> FPol
      RESRING;lift;$FPol;5 is replaced by x 
   compiling exported coerce : R -> $
      SMP;coerce;R$;21 is replaced by CONS0c 
   compiling local stream : $ -> Rep
      SMTS;stream is replaced by x 
   compiling local showAll? : () -> Boolean
      SMTS;showAll? is replaced by QUOTET 
   compiling local stream : $ -> Rep
      SMTS;stream is replaced by x 
   compiling local rep : $ -> Record(root: SplittingNode(V,C),subTrees: List $)
      SPLTREE;rep is replaced by n 
   compiling local per : Record(root: SplittingNode(V,C),subTrees: List $) -> $
      SPLTREE;per is replaced by r 
   compiling exported cyclic? : $ -> Boolean
      SPLTREE;cyclic?;$B;16 is replaced by QUOTE 
   compiling exported zero? : $ -> Boolean
      SUP;zero?;$B;5 is replaced by NULL 
   compiling exported univariate : $ -> SparseUnivariatePolynomial R
      SUP;univariate;2$;14 is replaced by p 
   compiling exported multivariate : (SparseUnivariatePolynomial R,SingletonAsOrderedSet) -> $
      SUP;multivariate;$Saos$;15 is replaced by sup 
   compiling local parse : String -> InputForm
      TEMUTL;parse is replaced by ncParseFromString 
   compiling exported prologue : $ -> List String
      TEX;prologue;$L;7 is replaced by QVELTf0 
   compiling exported tex : $ -> List String
      TEX;tex;$L;8 is replaced by QVELTf1 
   compiling exported epilogue : $ -> List String
      TEX;epilogue;$L;9 is replaced by QVELTf2 
   compiling exported setPrologue! : ($,List String) -> List String
      TEX;setPrologue!;$2L;10 is replaced by QSETVELTf0l 
   compiling exported setTex! : ($,List String) -> List String
      TEX;setTex!;$2L;11 is replaced by QSETVELTf1l 
   compiling exported setEpilogue! : ($,List String) -> List String
      TEX;setEpilogue!;$2L;12 is replaced by QSETVELTf2l 
   compiling local stringify : OutputForm -> String
      TEX;stringify is replaced by object2String 
   compiling local precondition : OutputForm -> OutputForm
      TEX;precondition is replaced by outputTran 
   compiling exported empty? : $ -> Boolean
      TREE;empty?;$B;1 is replaced by QEQCARt1 
   compiling exported empty : () -> $
      TREE;empty;$;2 is replaced by CONS1empty 
   compiling exported viewWriteAvailable : () -> List String
      VIEWDEF;viewWriteAvailable;L;24 is replaced by LISTPIXMAPBITMAPPOSTSCRIPTIMAGE 
   compiling exported options : $ -> List DrawOption
      VIEW2D;options;$L;3 is replaced by QVELTviewport7 
   compiling exported graphStates : $ -> Vector Record(scaleX: DoubleFloat,scaleY: DoubleFloat,deltaX: DoubleFloat,deltaY: DoubleFloat,points: Integer,connect: Integer,spline: Integer,axes: Integer,axesColor: Palette,units: Integer,unitsColor: Palette,showing: Integer)
      VIEW2D;graphStates;$V;7 is replaced by QVELTviewport2 
   compiling exported graphs : $ -> Vector Union(GraphImage,undefined)
      VIEW2D;graphs;$V;8 is replaced by QVELTviewport1 
   compiling exported key : $ -> Integer
      VIEW2D;key;$I;9 is replaced by QVELTviewport0 
   compiling exported void : () -> $
      VOID;void;$;1 is replaced by voidValue 
   compiling exported exponent : $ -> UnivariatePuiseuxSeries(FE,var,cen)
      EXPUPXS;exponent;$Ups;2 is replaced by f 
   compiling exported parametric? : $ -> Boolean
      PLOT;parametric?;$B;17 is replaced by QVELTp0 
   compiling exported definingPolynomial : $ -> ThePolDom
      ROIRC;definingPolynomial;$ThePolDom;22 is replaced by QVELTrootChar2 
   compiling exported left : $ -> TheField
      ROIRC;left;$TheField;31 is replaced by QVELTrootChar0 
   compiling exported right : $ -> TheField
      ROIRC;right;$TheField;32 is replaced by QVELTrootChar1 
   compiling exported numer : $ -> Vector A
      FRIDEAL;numer;$V;2 is replaced by QCAR 
   compiling exported denom : $ -> R
      FRIDEAL;denom;$R;3 is replaced by QCDR 
   compiling local mkIdeal : (Vector A,R) -> $
      FRIDEAL;mkIdeal is replaced by CONS 
   compiling exported module : Vector A -> $
      FRMOD;module;V$;2 is replaced by v 
   compiling exported basis : $ -> Vector A
      FRMOD;basis;$V;3 is replaced by m 
   compiling exported subspace : $ -> SubSpace(3,R)
      SPACE3;subspace;$Ss;49 is replaced by QVELTs0 
   compiling local stringify : OutputForm -> String
      MMLFORM;stringify is replaced by object2String 
   compiling local precondition : OutputForm -> OutputForm
      MMLFORM;precondition is replaced by outputTran 
   compiling exported coerce : $ -> List Permutation S
      PERMGRP;coerce;$L;19 is replaced by QCAR 
   compiling exported generators : $ -> List Permutation S
      PERMGRP;generators;$L;20 is replaced by QCAR 
   compiling exported lift : $ -> UP
      SAE;lift;$UP;10 is replaced by x 
   compiling exported subspace : $ -> ThreeSpace DoubleFloat
      VIEW3D;subspace;$Ts;6 is replaced by QVELTviewport11 
   compiling exported options : $ -> List DrawOption
      VIEW3D;options;$L;8 is replaced by QVELTviewport12 
   compiling exported key : $ -> Integer
      VIEW3D;key;$I;43 is replaced by QVELTviewport0 
   compiling exported = : ($,$) -> Boolean
      HASHTBL;=;2$B;1 is replaced by EQ 
   compiling exported keys : $ -> List Key
      HASHTBL;keys;$L;2 is replaced by HKEYS 
   compiling exported # : $ -> NonNegativeInteger
      HASHTBL;#;$Nni;3 is replaced by HCOUNT 
   compiling exported setelt : ($,Key,Entry) -> Entry
      HASHTBL;setelt;$Key2Entry;4 is replaced by HPUT 
   compiling exported convert : $ -> Integer
      IPF;convert;$I;5 is replaced by x 
   compiling exported representationType : () -> Union(prime,polynomial,normal,cyclic)
      IPF;representationType;U;10 is replaced by CONS0prime 
   compiling exported degree : $ -> PositiveInteger
      IPF;degree;$Pi;15 is replaced by 1 
   compiling exported extensionDegree : () -> PositiveInteger
      IPF;extensionDegree;Pi;16 is replaced by 1 
   compiling exported inGroundField? : $ -> Boolean
      IPF;inGroundField?;$B;17 is replaced by QUOTET 
   compiling exported retract : $ -> $
      IPF;retract;2$;20 is replaced by x 
   compiling exported retractIfCan : $ -> Union($,failed)
      IPF;retractIfCan;$U;21 is replaced by CONS0x 
   compiling exported charthRoot : $ -> $
      IPF;charthRoot;2$;26 is replaced by x 
   compiling exported name : $ -> FileName
      KAFILE;name;$Fn;10 is replaced by QVELTf0 
   compiling exported iomode : $ -> String
      KAFILE;iomode;$S;11 is replaced by QVELTf2 
   compiling exported failed : () -> $
      PATRES;failed;$;2 is replaced by CONS1failed 
   compiling exported failed? : $ -> Boolean
      PATRES;failed?;$B;3 is replaced by QEQCARx1 
   compiling local makeCorners : (DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat) -> Record(minXVal: DoubleFloat,maxXVal: DoubleFloat,minYVal: DoubleFloat,maxYVal: DoubleFloat)
      ACPLOT;makeCorners is replaced by VECTOR 
   compiling local getXMin : Record(minXVal: DoubleFloat,maxXVal: DoubleFloat,minYVal: DoubleFloat,maxYVal: DoubleFloat) -> DoubleFloat
      ACPLOT;getXMin is replaced by QVELTcorners0 
   compiling local getXMax : Record(minXVal: DoubleFloat,maxXVal: DoubleFloat,minYVal: DoubleFloat,maxYVal: DoubleFloat) -> DoubleFloat
      ACPLOT;getXMax is replaced by QVELTcorners1 
   compiling local getYMin : Record(minXVal: DoubleFloat,maxXVal: DoubleFloat,minYVal: DoubleFloat,maxYVal: DoubleFloat) -> DoubleFloat
      ACPLOT;getYMin is replaced by QVELTcorners2 
   compiling local getYMax : Record(minXVal: DoubleFloat,maxXVal: DoubleFloat,minYVal: DoubleFloat,maxYVal: DoubleFloat) -> DoubleFloat
      ACPLOT;getYMax is replaced by QVELTcorners3 
   compiling exported listBranches : $ -> List List Point DoubleFloat
      ACPLOT;listBranches;$L;41 is replaced by QVELTacplot10 
   compiling exported obj : $ -> None
      ANY;obj;$N;1 is replaced by QCDR 
   compiling exported dom : $ -> SExpression
      ANY;dom;$Se;2 is replaced by QCAR 
   compiling exported domainOf : $ -> OutputForm
      ANY;domainOf;$Of;3 is replaced by QCAR 
   compiling exported name : $ -> Symbol
      BOP;name;$S;2 is replaced by QVELTop0 
   compiling exported properties : $ -> AssociationList(String,None)
      BOP;properties;$Al;3 is replaced by QVELTop2 
   compiling local oper : (Symbol,SingleInteger,AssociationList(String,None)) -> $
      BOP;oper is replaced by VECTOR 
   compiling local cdisp : (OutputForm,List OutputForm) -> OutputForm
      BOP1;cdisp is replaced by a 
   compiling local csex : (InputForm,List InputForm) -> InputForm
      BOP1;csex is replaced by a 
   compiling exported rank : () -> PositiveInteger
      COMPCAT-;rank;Pi;7 is replaced by 2 
   compiling local id : DoubleFloat -> DoubleFloat
      DRAWCFUN;id is replaced by x 
   compiling local zCoord : (DoubleFloat,DoubleFloat,DoubleFloat) -> DoubleFloat
      DRAWCFUN;zCoord is replaced by z 
   compiling local xCoord : (DoubleFloat,DoubleFloat) -> DoubleFloat
      DRAWCFUN;xCoord is replaced by x 
   compiling local length : List Segment Float -> NonNegativeInteger
      DROPT;length is replaced by LENGTH 
   compiling local lengthR : List Segment Fraction Integer -> NonNegativeInteger
      DROPT;lengthR is replaced by LENGTH 
   compiling local lengthI : List Integer -> NonNegativeInteger
      DROPT;lengthI is replaced by LENGTH 
   compiling exported coerce : $ -> Expression R
      FEXPR;coerce;$E;27 is replaced by u 
   compiling exported representationType : () -> Union(prime,polynomial,normal,cyclic)
      FFCGP;representationType;U;12 is replaced by CONS3cyclic 
   compiling exported generator : () -> $
      FFCGP;generator;$;23 is replaced by 1 
   compiling exported createPrimitiveElement : () -> $
      FFCGP;createPrimitiveElement;$;24 is replaced by 1 
   compiling exported primitiveElement : () -> $
      FFCGP;primitiveElement;$;25 is replaced by 1 
   compiling exported Zero : () -> $
      FFCGP;Zero;$;33 is replaced by -1 
   compiling exported One : () -> $
      FFCGP;One;$;34 is replaced by 0 
   compiling exported = : ($,$) -> Boolean
      FFCGP;=;2$B;36 is replaced by EQL 
   compiling exported represents : Vector GF -> $
      FFNBP;represents;V$;2 is replaced by v 
   compiling exported coordinates : $ -> Vector GF
      FFNBP;coordinates;$V;17 is replaced by x 
   compiling exported representationType : () -> Union(prime,polynomial,normal,cyclic)
      FFNBP;representationType;U;48 is replaced by CONS2normal 
   compiling exported representationType : () -> Union(prime,polynomial,normal,cyclic)
      FFP;representationType;U;29 is replaced by CONS1polynomial 
   compiling exported Zero : () -> $
      FLOAT;Zero;$;48 is replaced by CONS00 
   compiling exported One : () -> $
      FLOAT;One;$;49 is replaced by CONS10 
   compiling exported base : () -> PositiveInteger
      FLOAT;base;Pi;50 is replaced by 2 
   compiling exported mantissa : $ -> Integer
      FLOAT;mantissa;$I;51 is replaced by QCAR 
   compiling exported exponent : $ -> Integer
      FLOAT;exponent;$I;52 is replaced by QCDR 
   compiling exported convert : $ -> Float
      FLOAT;convert;2$;116 is replaced by x 
   compiling exported polyPart : $ -> UP
      FPARFRAC;polyPart;$UP;4 is replaced by QCAR 
   compiling exported fracPart : $ -> List Record(exponent: NonNegativeInteger,center: UP,num: UP)
      FPARFRAC;fracPart;$L;5 is replaced by QCDR 
   compiling exported factorList : $ -> List Record(flg: Union(nil,sqfr,irred,prime),fctr: R,xpnt: Integer)
      FR;factorList;$L;7 is replaced by QCDR 
   compiling exported unit : $ -> R
      FR;unit;$R;8 is replaced by QCAR 
   compiling local mkFF : (R,List Record(flg: Union(nil,sqfr,irred,prime),fctr: R,xpnt: Integer)) -> $
      FR;mkFF is replaced by CONS 
   compiling exported rational? : $ -> Boolean
      FR;rational?;$B;23 is replaced by QUOTET 
   compiling local debugA : (List S,List S,Boolean) -> Boolean
      FS-;debugA is replaced by t 
   compiling exported real? : $ -> Boolean
      FST;real?;$B;7 is replaced by QEQCARt0 
   compiling exported double? : $ -> Boolean
      FST;double?;$B;8 is replaced by QEQCARt5 
   compiling exported logical? : $ -> Boolean
      FST;logical?;$B;9 is replaced by QEQCARt4 
   compiling exported integer? : $ -> Boolean
      FST;integer?;$B;10 is replaced by QEQCARt1 
   compiling exported character? : $ -> Boolean
      FST;character?;$B;11 is replaced by QEQCARt3 
   compiling exported complex? : $ -> Boolean
      FST;complex?;$B;12 is replaced by QEQCARt2 
   compiling exported doubleComplex? : $ -> Boolean
      FST;doubleComplex?;$B;13 is replaced by QEQCARt6 
   compiling exported = : ($,$) -> Boolean
      FUNCTION;=;2$B;3 is replaced by QUOTET 
   compiling exported zero? : $ -> Boolean
      GDMP;zero?;$B;1 is replaced by NULL 
   compiling exported convert : $ -> Fraction SparseUnivariatePolynomial Integer
      HACKPI;convert;$F;2 is replaced by x 
   compiling exported generators : $ -> List DPoly
      IDEAL;generators;$L;35 is replaced by QCAR 
   compiling exported groebner? : $ -> Boolean
      IDEAL;groebner?;$B;36 is replaced by QCDR 
   compiling exported convert : $ -> SExpression
      INFORM;convert;$Se;3 is replaced by x 
   compiling exported convert : SExpression -> $
      INFORM;convert;Se$;4 is replaced by x 
   compiling exported ratpart : $ -> F
      IR;ratpart;$F;4 is replaced by QVELTu0 
   compiling exported logpart : $ -> List Record(scalar: Fraction Integer,coeff: SparseUnivariatePolynomial F,logand: SparseUnivariatePolynomial F)
      IR;logpart;$L;5 is replaced by QVELTu1 
   compiling exported notelem : $ -> List Record(integrand: F,intvar: F)
      IR;notelem;$L;6 is replaced by QVELTu2 
   compiling local makeTerm : (Integer,Coef) -> Record(k: Integer,c: Coef)
      ISUPS;makeTerm is replaced by CONS 
   compiling local getCoef : Record(k: Integer,c: Coef) -> Coef
      ISUPS;getCoef is replaced by QCDR 
   compiling local getExpon : Record(k: Integer,c: Coef) -> Integer
      ISUPS;getExpon is replaced by QCAR 
   compiling exported makeSeries : (Reference OrderedCompletion Integer,Stream Record(k: Integer,c: Coef)) -> $
      ISUPS;makeSeries;RS$;4 is replaced by CONS 
   compiling exported getRef : $ -> Reference OrderedCompletion Integer
      ISUPS;getRef;$R;5 is replaced by QCAR 
   compiling exported getStream : $ -> Stream Record(k: Integer,c: Coef)
      ISUPS;getStream;$S;6 is replaced by QCDR 
   compiling local factorials? : () -> Boolean
      ISUPS;factorials? is replaced by QUOTE 
   compiling local showAll? : () -> Boolean
      ISUPS;showAll? is replaced by QUOTET 
   compiling exported height : $ -> NonNegativeInteger
      KERNEL;height;$Nni;4 is replaced by QVELTk2 
   compiling exported operator : $ -> BasicOperator
      KERNEL;operator;$Bo;5 is replaced by QVELTk0 
   compiling exported argument : $ -> List S
      KERNEL;argument;$L;6 is replaced by QVELTk1 
   compiling exported position : $ -> NonNegativeInteger
      KERNEL;position;$Nni;7 is replaced by QVELTk3 
   compiling exported setPosition : ($,NonNegativeInteger) -> Void
      KERNEL;setPosition;$NniV;8 is replaced by QSETVELTk3n 
   compiling exported minRowIndex : $ -> Integer
      MATRIX;minRowIndex;$I;1 is replaced by 1 
   compiling exported minColIndex : $ -> Integer
      MATRIX;minColIndex;$I;2 is replaced by 1 
   compiling exported coerce : PrimitiveArray PrimitiveArray PrimitiveArray R -> $
      M3D;coerce;Pa$;3 is replaced by matrixRep 
   compiling exported coerce : $ -> PrimitiveArray PrimitiveArray PrimitiveArray R
      M3D;coerce;$Pa;4 is replaced by mat 
   compiling exported fortranCompilerName : () -> String
      NAGSP;fortranCompilerName;S;4 is replaced by STRINGIMAGE$fortranCompilerName 
   compiling exported fortranLinkerArgs : () -> String
      NAGSP;fortranLinkerArgs;S;5 is replaced by STRINGIMAGE$fortranLibraries 
   compiling exported FormatArabic : PositiveInteger -> String
      NUMFMT;FormatArabic;PiS;7 is replaced by STRINGIMAGE 
   compiling exported ScanArabic : String -> PositiveInteger
      NUMFMT;ScanArabic;SPi;8 is replaced by PARSE-INTEGER 
   compiling exported omError : (OpenMathErrorKind,List Symbol) -> $
      OMERR;omError;OmekL$;2 is replaced by CONS 
   compiling exported errorKind : $ -> OpenMathErrorKind
      OMERR;errorKind;$Omek;3 is replaced by QCAR 
   compiling exported errorInfo : $ -> List Symbol
      OMERR;errorInfo;$L;4 is replaced by QCDR 
   compiling exported OMParseError? : $ -> Boolean
      OMERRK;OMParseError?;$B;1 is replaced by QEQCARu0 
   compiling exported OMUnknownCD? : $ -> Boolean
      OMERRK;OMUnknownCD?;$B;2 is replaced by QEQCARu1 
   compiling exported OMUnknownSymbol? : $ -> Boolean
      OMERRK;OMUnknownSymbol?;$B;3 is replaced by QEQCARu2 
   compiling exported OMReadError? : $ -> Boolean
      OMERRK;OMReadError?;$B;4 is replaced by QEQCARu3 
   compiling exported = : ($,$) -> Boolean
      OSI;=;2$B;1 is replaced by EQL 
   compiling exported < : ($,$) -> Boolean
      OSI;<;2$B;2 is replaced by < 
   compiling exported coerce : Integer -> $
      OSI;coerce;I$;3 is replaced by i 
   compiling exported value : $ -> Integer
      OSI;value;$I;4 is replaced by x 
   compiling exported constant? : $ -> Boolean
      PATTERN;constant?;$B;6 is replaced by QVELTp0 
   compiling exported depth : $ -> NonNegativeInteger
      PATTERN;depth;$Nni;7 is replaced by QVELTp2 
   compiling exported index : PositiveInteger -> $
      OVAR;index;Pi$;6 is replaced by i 
   compiling exported lookup : $ -> PositiveInteger
      OVAR;lookup;$Pi;7 is replaced by j 
   compiling exported < : ($,$) -> Boolean
      OVAR;<;2$B;10 is replaced by <s2s1 
   compiling exported = : ($,$) -> Boolean
      OVAR;=;2$B;11 is replaced by EQL 
   compiling exported equation : (Symbol,String) -> $
      QEQUAT;equation;SS$;2 is replaced by CONS 
   compiling exported variable : $ -> Symbol
      QEQUAT;variable;$S;3 is replaced by QCAR 
   compiling exported value : $ -> String
      QEQUAT;value;$S;4 is replaced by QCDR 
   compiling exported coerce : TheField -> $
      RECLOS;coerce;TheField$;35 is replaced by CONS0rn 
   compiling exported = : ($,$) -> Boolean
      RULECOLD;=;2$B;3 is replaced by QUOTET 
   compiling exported create : () -> $
      SAOS;create;$;1 is replaced by ? 
   compiling exported < : ($,$) -> Boolean
      SAOS;<;2$B;2 is replaced by QUOTE 
   compiling exported = : ($,$) -> Boolean
      SAOS;=;2$B;4 is replaced by QUOTET 
   compiling exported min : ($,$) -> $
      SAOS;min;3$;5 is replaced by a 
   compiling exported max : ($,$) -> $
      SAOS;max;3$;6 is replaced by a 
   compiling exported equation : (Symbol,Segment S) -> $
      SEGBIND;equation;SS$;1 is replaced by CONS 
   compiling exported variable : $ -> Symbol
      SEGBIND;variable;$S;2 is replaced by QCAR 
   compiling exported segment : $ -> Segment S
      SEGBIND;segment;$S;3 is replaced by QCDR 
   compiling exported coerce : $ -> Table(Symbol,FortranType)
      SYMTAB;coerce;$T;2 is replaced by t 
   compiling local factorials? : () -> Boolean
      UTSCAT-;factorials? is replaced by QUOTE 
   compiling local showAll? : () -> Boolean
      UTSCAT-;showAll? is replaced by QUOTET 
   compiling exported = : ($,$) -> Boolean
      VARIABLE;=;2$B;4 is replaced by QUOTET 
   compiling exported localUnquote : (F,List Symbol) -> F
      APPRULE;localUnquote;FLF;8 is replaced by f 
   compiling exported complex : (R,R) -> $
      COMPLEX;complex;2R$;11 is replaced by CONS 
   compiling exported real : $ -> R
      COMPLEX;real;$R;12 is replaced by QCAR 
   compiling exported imag : $ -> R
      COMPLEX;imag;$R;13 is replaced by QCDR 
   compiling local terms : $ -> List Record(k: ExtAlgBasis,c: Expression CoefRing)
      DERHAM;terms is replaced by a 
   compiling exported Gamma : Complex DoubleFloat -> Complex DoubleFloat
      DFSFUN;Gamma;2C;1 is replaced by CGAMMA 
   compiling exported Gamma : DoubleFloat -> DoubleFloat
      DFSFUN;Gamma;2Df;2 is replaced by RGAMMA 
   compiling exported polygamma : (NonNegativeInteger,Complex DoubleFloat) -> Complex DoubleFloat
      DFSFUN;polygamma;Nni2C;3 is replaced by CPSI 
   compiling exported polygamma : (NonNegativeInteger,DoubleFloat) -> DoubleFloat
      DFSFUN;polygamma;Nni2Df;4 is replaced by RPSI 
   compiling exported logGamma : Complex DoubleFloat -> Complex DoubleFloat
      DFSFUN;logGamma;2C;5 is replaced by CLNGAMMA 
   compiling exported logGamma : DoubleFloat -> DoubleFloat
      DFSFUN;logGamma;2Df;6 is replaced by RLNGAMMA 
   compiling exported besselJ : (Complex DoubleFloat,Complex DoubleFloat) -> Complex DoubleFloat
      DFSFUN;besselJ;3C;7 is replaced by CBESSELJ 
   compiling exported besselJ : (DoubleFloat,DoubleFloat) -> DoubleFloat
      DFSFUN;besselJ;3Df;8 is replaced by RBESSELJ 
   compiling exported besselI : (Complex DoubleFloat,Complex DoubleFloat) -> Complex DoubleFloat
      DFSFUN;besselI;3C;9 is replaced by CBESSELI 
   compiling exported besselI : (DoubleFloat,DoubleFloat) -> DoubleFloat
      DFSFUN;besselI;3Df;10 is replaced by RBESSELI 
   compiling exported hypergeometric0F1 : (Complex DoubleFloat,Complex DoubleFloat) -> Complex DoubleFloat
      DFSFUN;hypergeometric0F1;3C;11 is replaced by CHYPER0F1 
   compiling exported specialTrigs : (F,List Record(func: F,pole: Boolean)) -> Union(F,failed)
      EF;specialTrigs;FLU;45 is replaced by CONS1failed 
   compiling exported localReal? : F -> Boolean
      EF;localReal?;FB;72 is replaced by QUOTET 
   compiling exported localReal? : F -> Boolean
      EF;localReal?;FB;73 is replaced by QUOTET 
   compiling local coeff : Record(%coef: UnivariatePuiseuxSeries(FE,var,cen),%expon: ExponentialOfUnivariatePuiseuxSeries(FE,var,cen),%expTerms: List Record(k: Fraction Integer,c: FE)) -> UnivariatePuiseuxSeries(FE,var,cen)
      EXPEXPAN;coeff is replaced by QVELTterm0 
   compiling local exponent : Record(%coef: UnivariatePuiseuxSeries(FE,var,cen),%expon: ExponentialOfUnivariatePuiseuxSeries(FE,var,cen),%expTerms: List Record(k: Fraction Integer,c: FE)) -> ExponentialOfUnivariatePuiseuxSeries(FE,var,cen)
      EXPEXPAN;exponent is replaced by QVELTterm1 
   compiling local project : (DoubleFloat,DoubleFloat) -> DoubleFloat
      EXPRTUBE;project is replaced by x 
   compiling exported code : $ -> Union(nullBranch: null,assignmentBranch: Record(var: Symbol,arrayIndex: List Polynomial Integer,rand: Record(ints2Floats?: Boolean,expr: OutputForm)),arrayAssignmentBranch: Record(var: Symbol,rand: OutputForm,ints2Floats?: Boolean),conditionalBranch: Record(switch: Switch,thenClause: $,elseClause: $),returnBranch: Record(empty?: Boolean,value: Record(ints2Floats?: Boolean,expr: OutputForm)),blockBranch: List $,commentBranch: List String,callBranch: String,forBranch: Record(range: SegmentBinding Polynomial Integer,span: Polynomial Integer,body: $),labelBranch: SingleInteger,loopBranch: Record(switch: Switch,body: $),commonBranch: Record(name: Symbol,contents: List Symbol),printBranch: List OutputForm)
      FC;code;$U;24 is replaced by QCDR 
   compiling exported operation : $ -> Union(Null: null,Assignment: assignment,Conditional: conditional,Return: return,Block: block,Comment: comment,Call: call,For: for,While: while,Repeat: repeat,Goto: goto,Continue: continue,ArrayAssignment: arrayAssignment,Save: save,Stop: stop,Common: common,Print: print)
      FC;operation;$U;25 is replaced by QCAR 
   compiling local codeFrom : $ -> List FortranCode
      FORTRAN;codeFrom is replaced by QCDR 
   compiling exported coerce : Record(localSymbols: SymbolTable,code: List FortranCode) -> $
      FORTRAN;coerce;R$;12 is replaced by u 
   compiling local rep : $ -> List P
      GTSET;rep is replaced by s 
   compiling local per : List P -> $
      GTSET;per is replaced by l 
   compiling exported roughUnitIdeal? : $ -> Boolean
      GTSET;roughUnitIdeal?;$B;11 is replaced by QUOTE 
   compiling exported empty : () -> $
      GPOLSET;empty;$;3 is replaced by  
   compiling exported parts : $ -> List P
      GPOLSET;parts;$L;4 is replaced by ps 
   compiling exported coerce : $ -> List P
      GPOLSET;coerce;$L;12 is replaced by ps 
   compiling exported coerce : $ -> A
      JORDAN;coerce;$A;2 is replaced by a 
   compiling exported coerce : A -> $
      JORDAN;coerce;A$;3 is replaced by a 
   compiling exported ** : ($,PositiveInteger) -> $
      JORDAN;**;$Pi$;4 is replaced by a 
   compiling exported coerce : $ -> A
      LIE;coerce;$A;2 is replaced by a 
   compiling exported coerce : A -> $
      LIE;coerce;A$;3 is replaced by a 
   compiling exported coerce : $ -> SparseMultivariatePolynomial(R,VarSet)
      NSMP;coerce;$Smp;2 is replaced by p 
   compiling exported coerce : SparseMultivariatePolynomial(R,VarSet) -> $
      NSMP;coerce;Smp$;3 is replaced by p 
   compiling exported retractIfCan : $ -> Union(SparseMultivariatePolynomial(R,VarSet),failed)
      NSMP;retractIfCan;$U;4 is replaced by CONS0p 
   compiling exported octon : (Quaternion R,Quaternion R) -> $
      OCT;octon;2Q$;12 is replaced by CONS 
   compiling exported removeSquaresIfCan : List P -> List P
      PSETPK;removeSquaresIfCan;2L;39 is replaced by lp 
   compiling exported real : $ -> R
      QUAT;real;$R;3 is replaced by QVELTx0 
   compiling exported imagI : $ -> R
      QUAT;imagI;$R;4 is replaced by QVELTx1 
   compiling exported imagJ : $ -> R
      QUAT;imagJ;$R;5 is replaced by QVELTx2 
   compiling exported imagK : $ -> R
      QUAT;imagK;$R;6 is replaced by QVELTx3 
   compiling exported quatern : (R,R,R,R) -> $
      QUAT;quatern;4R$;7 is replaced by VECTOR 
   compiling exported pattern : $ -> Pattern Base
      RULE;pattern;$P;1 is replaced by QVELTx0 
   compiling exported lhs : $ -> F
      RULE;lhs;$F;2 is replaced by QVELTx1 
   compiling exported rhs : $ -> F
      RULE;rhs;$F;3 is replaced by QVELTx2 
   compiling exported quotedOperators : $ -> List Symbol
      RULE;quotedOperators;$L;4 is replaced by QVELTx3 
   compiling local mkRule : (Pattern Base,F,F,List Symbol) -> $
      RULE;mkRule is replaced by VECTOR 
   compiling exported fortran : (Symbol,FortranScalarType,FS) -> $
      SFORT;fortran;SFstFS$;1 is replaced by VECTOR 
   compiling local nameOf : $ -> Symbol
      SFORT;nameOf is replaced by QVELTu0 
   compiling local bodyOf : $ -> FS
      SFORT;bodyOf is replaced by QVELTu2 
   compiling local makeTerm : (Integer,Coef) -> Record(k: Integer,c: Coef)
      SUTS;makeTerm is replaced by CONS 
   compiling local getCoef : Record(k: Integer,c: Coef) -> Coef
      SUTS;getCoef is replaced by QCDR 
   compiling local getExpon : Record(k: Integer,c: Coef) -> Integer
      SUTS;getExpon is replaced by QCAR 
   compiling exported pole? : $ -> Boolean
      SUTS;pole?;$B;30 is replaced by QUOTE 
   compiling exported acos : $ -> $
      SUTS;acos;2$;74 is replaced by erroracos: acos undefined on this coefficient domain 
   compiling exported acot : $ -> $
      SUTS;acot;2$;75 is replaced by erroracot: acot undefined on this coefficient domain 
   compiling exported asec : $ -> $
      SUTS;asec;2$;76 is replaced by errorasec: asec undefined on this coefficient domain 
   compiling exported acsc : $ -> $
      SUTS;acsc;2$;77 is replaced by erroracsc: acsc undefined on this coefficient domain 
   compiling exported acosh : $ -> $
      SUTS;acosh;2$;86 is replaced by erroracosh: acosh undefined on this coefficient domain 
   compiling exported acoth : $ -> $
      SUTS;acoth;2$;87 is replaced by erroracoth: acoth undefined on this coefficient domain 
   compiling exported asech : $ -> $
      SUTS;asech;2$;88 is replaced by errorasech: asech undefined on this coefficient domain 
   compiling exported acsch : $ -> $
      SUTS;acsch;2$;89 is replaced by erroracsch: acsch undefined on this coefficient domain 
   compiling exported nonQsign : R -> Union(Integer,failed)
      TOOLSIGN;nonQsign;RU;2 is replaced by CONS1failed 
   compiling local makeTerm : (UnivariatePuiseuxSeries(FE,var,cen),ExponentialOfUnivariatePuiseuxSeries(FE,var,cen)) -> Record(%coef: UnivariatePuiseuxSeries(FE,var,cen),%expon: ExponentialOfUnivariatePuiseuxSeries(FE,var,cen),%expTerms: List Record(k: Fraction Integer,c: FE))
      UPXSSING;makeTerm is replaced by VECTORcoefexpon 
   compiling local coeff : Record(%coef: UnivariatePuiseuxSeries(FE,var,cen),%expon: ExponentialOfUnivariatePuiseuxSeries(FE,var,cen),%expTerms: List Record(k: Fraction Integer,c: FE)) -> UnivariatePuiseuxSeries(FE,var,cen)
      UPXSSING;coeff is replaced by QVELTterm0 
   compiling local exponent : Record(%coef: UnivariatePuiseuxSeries(FE,var,cen),%expon: ExponentialOfUnivariatePuiseuxSeries(FE,var,cen),%expTerms: List Record(k: Fraction Integer,c: FE)) -> ExponentialOfUnivariatePuiseuxSeries(FE,var,cen)
      UPXSSING;exponent is replaced by QVELTterm1 
   compiling local exponentTerms : Record(%coef: UnivariatePuiseuxSeries(FE,var,cen),%expon: ExponentialOfUnivariatePuiseuxSeries(FE,var,cen),%expTerms: List Record(k: Fraction Integer,c: FE)) -> List Record(k: Fraction Integer,c: FE)
      UPXSSING;exponentTerms is replaced by QVELTterm2 
   compiling local setExponentTerms! : (Record(%coef: UnivariatePuiseuxSeries(FE,var,cen),%expon: ExponentialOfUnivariatePuiseuxSeries(FE,var,cen),%expTerms: List Record(k: Fraction Integer,c: FE)),List Record(k: Fraction Integer,c: FE)) -> List Record(k: Fraction Integer,c: FE)
      UPXSSING;setExponentTerms! is replaced by QSETVELTterm2list 
   compiling local rep : $ -> List P
      WUTSET;rep is replaced by s 
   compiling local per : List P -> $
      WUTSET;per is replaced by l 
   compiling exported belong? : BasicOperator -> Boolean
      EXPR;belong?;BoB;1 is replaced by QUOTET 
   compiling exported numer : $ -> SparseMultivariatePolynomial(R,Kernel $)
      EXPR;numer;$Smp;126 is replaced by x 
   compiling exported coerce : SparseMultivariatePolynomial(R,Kernel $) -> $
      EXPR;coerce;Smp$;127 is replaced by p 
   compiling exported coerce : Kernel $ -> $
      EXPR;coerce;K$;154 is replaced by k 
   compiling exported kernels : $ -> List Kernel $
      EXPR;kernels;$L;155 is replaced by LIST 
   compiling exported ideal : $ -> FractionalIdeal(UP,Fraction UP,UPUP,R)
      FDIV;ideal;$Fi;20 is replaced by QCAR 
   compiling exported coerce : UnivariatePuiseuxSeries(Coef,var,cen) -> $
      GSERIES;coerce;Ups$;1 is replaced by upxs 
   compiling local puiseux : $ -> UnivariatePuiseuxSeries(Coef,var,cen)
      GSERIES;puiseux is replaced by f 
   compiling exported coerce : SparseUnivariateTaylorSeries(Coef,var,cen) -> $
      SULS;coerce;Suts$;5 is replaced by uts 
   compiling exported removeZeroes : $ -> $
      SULS;removeZeroes;2$;10 is replaced by uls 
   compiling exported removeZeroes : (Integer,$) -> $
      SULS;removeZeroes;I2$;11 is replaced by uls 
   compiling local getExpon : $ -> Fraction Integer
      SUPXS;getExpon is replaced by QCAR 
   compiling local getExpon : $ -> Integer
      ULSCONS;getExpon is replaced by QCAR 
   compiling local getUTS : $ -> UTS
      ULSCONS;getUTS is replaced by QCDR 
   compiling exported laurent : (Integer,UTS) -> $
      ULSCONS;laurent;IUTS$;3 is replaced by CONS 
   compiling local termExpon : Record(k: Integer,c: Coef) -> Integer
      ULSCONS;termExpon is replaced by QCAR 
   compiling local termCoef : Record(k: Integer,c: Coef) -> Coef
      ULSCONS;termCoef is replaced by QCDR 
   compiling local rec : (Integer,Coef) -> Record(k: Integer,c: Coef)
      ULSCONS;rec is replaced by CONS 
   compiling local showAll? : () -> Boolean
      ULSCONS;showAll? is replaced by QUOTET 
   compiling local getExpon : $ -> Fraction Integer
      UPXS;getExpon is replaced by QCAR 
   compiling local showAll? : () -> Boolean
      UPXS;showAll? is replaced by QUOTET 
   compiling local getExpon : $ -> Fraction Integer
      UPXSCONS;getExpon is replaced by QCAR 
   compiling local getULS : $ -> ULS
      UPXSCONS;getULS is replaced by QCDR 
   compiling exported puiseux : (Fraction Integer,ULS) -> $
      UPXSCONS;puiseux;FULS$;3 is replaced by CONS 
   compiling local stream : $ -> Stream Coef
      UTS;stream is replaced by x 
   compiling local getExpon : Record(k: NonNegativeInteger,c: Coef) -> NonNegativeInteger
      UTS;getExpon is replaced by QCAR 
   compiling local getCoef : Record(k: NonNegativeInteger,c: Coef) -> Coef
      UTS;getCoef is replaced by QCDR 
   compiling local rec : (NonNegativeInteger,Coef) -> Record(k: NonNegativeInteger,c: Coef)
      UTS;rec is replaced by CONS 
   compiling local rep : $ -> List P
      REGSET;rep is replaced by s 
   compiling local per : List P -> $
      REGSET;per is replaced by l 
   compiling exported roughUnitIdeal? : $ -> Boolean
      REGSET;roughUnitIdeal?;$B;11 is replaced by QUOTE 
   compiling local rep : $ -> List P
      SREGSET;rep is replaced by s 
   compiling local per : List P -> $
      SREGSET;per is replaced by l 
   compiling exported roughUnitIdeal? : $ -> Boolean
      SREGSET;roughUnitIdeal?;$B;11 is replaced by QUOTE 
   compiling exported children : $ -> List $
      SUBSPACE;children;$L;8 is replaced by QVELTspace3 
   compiling exported numberOfChildren : $ -> NonNegativeInteger
      SUBSPACE;numberOfChildren;$Nni;9 is replaced by QVELTspace9 
   compiling exported extractIndex : $ -> NonNegativeInteger
      SUBSPACE;extractIndex;$Nni;27 is replaced by QVELTspace1 
   compiling exported extractProperty : $ -> SubSpaceComponentProperty
      SUBSPACE;extractProperty;$Sscp;29 is replaced by QVELTspace2 
   compiling exported pointData : $ -> List Point R
      SUBSPACE;pointData;$L;31 is replaced by QVELTspace6 
   compiling exported level : $ -> NonNegativeInteger
      SUBSPACE;level;$Nni;32 is replaced by QVELTspace5 
   compiling local exactInterval : (R,R) -> $
      INTRVL;exactInterval is replaced by CONS 
   compiling exported inf : $ -> R
      INTRVL;inf;$R;10 is replaced by QCAR 
   compiling exported sup : $ -> R
      INTRVL;sup;$R;11 is replaced by QCDR 
   compiling exported characteristic : () -> NonNegativeInteger
      INTRVL;characteristic;Nni;38 is replaced by 0 
   compiling exported test : $ -> Boolean
      BOOLEAN;test;2$;1 is replaced by a 
   compiling exported true : () -> $
      BOOLEAN;true;$;3 is replaced by QUOTET 
   compiling exported false : () -> $
      BOOLEAN;false;$;4 is replaced by  
   compiling exported = : ($,$) -> Boolean
      BOOLEAN;=;3$;15 is replaced by BooleanEquality 
   compiling exported size : () -> NonNegativeInteger
      BOOLEAN;size;Nni;18 is replaced by 2 
   compiling exported = : ($,$) -> Boolean
      CHAR;=;2$B;1 is replaced by EQL 
   compiling exported < : ($,$) -> Boolean
      CHAR;<;2$B;2 is replaced by QSLESSP 
   compiling exported size : () -> NonNegativeInteger
      CHAR;size;Nni;3 is replaced by 256 
   compiling exported ord : $ -> Integer
      CHAR;ord;$I;7 is replaced by c 
   compiling exported space : () -> $
      CHAR;space;$;9 is replaced by QENUM   0 
   compiling exported quote : () -> $
      CHAR;quote;$;10 is replaced by QENUM" 0 
   compiling exported escape : () -> $
      CHAR;escape;$;11 is replaced by QENUM_ 0 
   compiling local checkComplex : $ -> $
      DFLOAT;checkComplex is replaced by C-TO-R 
   compiling exported base : () -> PositiveInteger
      DFLOAT;base;Pi;7 is replaced by FLOAT-RADIX0.0 
   compiling exported precision : () -> PositiveInteger
      DFLOAT;precision;Pi;10 is replaced by FLOAT-DIGITS0.0 
   compiling exported max : () -> $
      DFLOAT;max;$;12 is replaced by MOST-POSITIVE-LONG-FLOAT 
   compiling exported min : () -> $
      DFLOAT;min;$;13 is replaced by MOST-NEGATIVE-LONG-FLOAT 
   compiling exported Zero : () -> $
      DFLOAT;Zero;$;15 is replaced by FLOAT0MOST-POSITIVE-LONG-FLOAT 
   compiling exported One : () -> $
      DFLOAT;One;$;16 is replaced by FLOAT1MOST-POSITIVE-LONG-FLOAT 
   compiling exported pi : () -> $
      DFLOAT;pi;$;18 is replaced by PI 
   compiling exported < : ($,$) -> Boolean
      DFLOAT;<;2$B;21 is replaced by < 
   compiling exported - : $ -> $
      DFLOAT;-;2$;22 is replaced by - 
   compiling exported + : ($,$) -> $
      DFLOAT;+;3$;23 is replaced by + 
   compiling exported - : ($,$) -> $
      DFLOAT;-;3$;24 is replaced by - 
   compiling exported * : ($,$) -> $
      DFLOAT;*;3$;25 is replaced by * 
   compiling exported * : (Integer,$) -> $
      DFLOAT;*;I2$;26 is replaced by * 
   compiling exported max : ($,$) -> $
      DFLOAT;max;3$;27 is replaced by MAX 
   compiling exported min : ($,$) -> $
      DFLOAT;min;3$;28 is replaced by MIN 
   compiling exported = : ($,$) -> Boolean
      DFLOAT;=;2$B;29 is replaced by = 
   compiling exported / : ($,Integer) -> $
      DFLOAT;/;$I$;30 is replaced by / 
   compiling exported ** : ($,Integer) -> $
      DFLOAT;**;$I$;33 is replaced by EXPT 
   compiling exported coerce : Integer -> $
      DFLOAT;coerce;I$;35 is replaced by FLOATiMOST-POSITIVE-LONG-FLOAT 
   compiling exported exp : $ -> $
      DFLOAT;exp;2$;36 is replaced by EXP 
   compiling exported sin : $ -> $
      DFLOAT;sin;2$;39 is replaced by SIN 
   compiling exported cos : $ -> $
      DFLOAT;cos;2$;40 is replaced by COS 
   compiling exported tan : $ -> $
      DFLOAT;tan;2$;41 is replaced by TAN 
   compiling exported cot : $ -> $
      DFLOAT;cot;2$;42 is replaced by COT 
   compiling exported sec : $ -> $
      DFLOAT;sec;2$;43 is replaced by SEC 
   compiling exported csc : $ -> $
      DFLOAT;csc;2$;44 is replaced by CSC 
   compiling exported atan : $ -> $
      DFLOAT;atan;2$;47 is replaced by ATAN 
   compiling exported acot : $ -> $
      DFLOAT;acot;2$;49 is replaced by ACOT 
   compiling exported sinh : $ -> $
      DFLOAT;sinh;2$;51 is replaced by SINH 
   compiling exported cosh : $ -> $
      DFLOAT;cosh;2$;52 is replaced by COSH 
   compiling exported tanh : $ -> $
      DFLOAT;tanh;2$;53 is replaced by TANH 
   compiling exported csch : $ -> $
      DFLOAT;csch;2$;54 is replaced by CSCH 
   compiling exported coth : $ -> $
      DFLOAT;coth;2$;55 is replaced by COTH 
   compiling exported sech : $ -> $
      DFLOAT;sech;2$;56 is replaced by SECH 
   compiling exported asinh : $ -> $
      DFLOAT;asinh;2$;57 is replaced by ASINH 
   compiling exported acsch : $ -> $
      DFLOAT;acsch;2$;60 is replaced by ACSCH 
   compiling exported / : ($,$) -> $
      DFLOAT;/;3$;63 is replaced by / 
   compiling exported negative? : $ -> Boolean
      DFLOAT;negative?;$B;64 is replaced by MINUSP 
   compiling exported zero? : $ -> Boolean
      DFLOAT;zero?;$B;65 is replaced by ZEROP 
   compiling exported hash : $ -> Integer
      DFLOAT;hash;$I;66 is replaced by HASHEQ 
   compiling exported differentiate : $ -> $
      DFLOAT;differentiate;2$;68 is replaced by 0.0 
   compiling exported wholePart : $ -> Integer
      DFLOAT;wholePart;$I;71 is replaced by FIX 
   compiling exported convert : $ -> DoubleFloat
      DFLOAT;convert;2$;73 is replaced by x 
   compiling exported abs : $ -> $
      DFLOAT;abs;2$;82 is replaced by FLOAT-SIGN1.0x 
   compiling exported # : $ -> NonNegativeInteger
      ILIST;#;$Nni;1 is replaced by LENGTH 
   compiling exported concat : (S,$) -> $
      ILIST;concat;S2$;2 is replaced by CONS 
   compiling exported eq? : ($,$) -> Boolean
      ILIST;eq?;2$B;3 is replaced by EQ 
   compiling exported first : $ -> S
      ILIST;first;$S;4 is replaced by SPADfirst 
   compiling exported elt : ($,first) -> S
      ILIST;elt;$firstS;5 is replaced by SPADfirstx 
   compiling exported empty : () -> $
      ILIST;empty;$;6 is replaced by  
   compiling exported empty? : $ -> Boolean
      ILIST;empty?;$B;7 is replaced by NULL 
   compiling exported rest : $ -> $
      ILIST;rest;2$;8 is replaced by CDR 
   compiling exported elt : ($,rest) -> $
      ILIST;elt;$rest$;9 is replaced by CDRx 
   compiling exported construct : List S -> $
      ILIST;construct;L$;14 is replaced by l 
   compiling exported parts : $ -> List S
      ILIST;parts;$L;15 is replaced by s 
   compiling exported reverse! : $ -> $
      ILIST;reverse!;2$;16 is replaced by NREVERSE 
   compiling exported reverse : $ -> $
      ILIST;reverse;2$;17 is replaced by REVERSE 
   compiling exported characteristic : () -> NonNegativeInteger
      INS-;characteristic;Nni;1 is replaced by 0 
   compiling exported copy : S -> S
      INS-;copy;2S;5 is replaced by x 
   compiling exported rational? : S -> Boolean
      INS-;rational?;SB;8 is replaced by QUOTET 
   compiling exported zero? : $ -> Boolean
      INT;zero?;$B;6 is replaced by ZEROP 
   compiling exported one? : $ -> Boolean
      INT;one?;$B;7 is replaced by EQLx1 
   compiling exported Zero : () -> $
      INT;Zero;$;8 is replaced by 0 
   compiling exported One : () -> $
      INT;One;$;9 is replaced by 1 
   compiling exported base : () -> $
      INT;base;$;10 is replaced by 2 
   compiling exported copy : $ -> $
      INT;copy;2$;11 is replaced by x 
   compiling exported inc : $ -> $
      INT;inc;2$;12 is replaced by +x1 
   compiling exported dec : $ -> $
      INT;dec;2$;13 is replaced by -x1 
   compiling exported hash : $ -> $
      INT;hash;2$;14 is replaced by SXHASH 
   compiling exported negative? : $ -> Boolean
      INT;negative?;$B;15 is replaced by MINUSP 
   compiling exported coerce : Integer -> $
      INT;coerce;2$;17 is replaced by m 
   compiling exported convert : $ -> Integer
      INT;convert;2$;18 is replaced by x 
   compiling exported length : $ -> $
      INT;length;2$;19 is replaced by INTEGER-LENGTH 
   compiling exported convert : $ -> DoubleFloat
      INT;convert;$Df;24 is replaced by FLOATxMOST-POSITIVE-LONG-FLOAT 
   compiling exported convert : $ -> String
      INT;convert;$S;26 is replaced by STRINGIMAGE 
   compiling exported reducedSystem : Matrix $ -> Matrix Integer
      INT;reducedSystem;2M;29 is replaced by m 
   compiling exported abs : $ -> $
      INT;abs;2$;31 is replaced by ABS 
   compiling exported random : () -> $
      INT;random;$;32 is replaced by random 
   compiling exported random : $ -> $
      INT;random;2$;33 is replaced by RANDOM 
   compiling exported = : ($,$) -> Boolean
      INT;=;2$B;34 is replaced by EQL 
   compiling exported < : ($,$) -> Boolean
      INT;<;2$B;35 is replaced by < 
   compiling exported - : $ -> $
      INT;-;2$;36 is replaced by - 
   compiling exported + : ($,$) -> $
      INT;+;3$;37 is replaced by + 
   compiling exported - : ($,$) -> $
      INT;-;3$;38 is replaced by - 
   compiling exported * : ($,$) -> $
      INT;*;3$;39 is replaced by * 
   compiling exported * : (Integer,$) -> $
      INT;*;3$;40 is replaced by * 
   compiling exported ** : ($,NonNegativeInteger) -> $
      INT;**;$Nni$;41 is replaced by EXPT 
   compiling exported odd? : $ -> Boolean
      INT;odd?;$B;42 is replaced by ODDP 
   compiling exported max : ($,$) -> $
      INT;max;3$;43 is replaced by MAX 
   compiling exported min : ($,$) -> $
      INT;min;3$;44 is replaced by MIN 
   compiling exported divide : ($,$) -> Record(quotient: $,remainder: $)
      INT;divide;2$R;45 is replaced by DIVIDE2 
   compiling exported quo : ($,$) -> $
      INT;quo;3$;46 is replaced by QUOTIENT2 
   compiling exported rem : ($,$) -> $
      INT;rem;3$;47 is replaced by REMAINDER2 
   compiling exported shift : ($,$) -> $
      INT;shift;3$;48 is replaced by ASH 
   compiling exported gcd : ($,$) -> $
      INT;gcd;3$;51 is replaced by GCD 
   compiling exported unitCanonical : $ -> $
      INT;unitCanonical;2$;53 is replaced by ABS 
   compiling exported new : (NonNegativeInteger,Character) -> $
      ISTRING;new;NniC$;1 is replaced by MAKE-FULL-CVEC 
   compiling exported empty : () -> $
      ISTRING;empty;$;2 is replaced by MAKE-FULL-CVEC0 
   compiling exported # : $ -> NonNegativeInteger
      ISTRING;#;$Nni;4 is replaced by QCSIZE 
   compiling exported = : ($,$) -> Boolean
      ISTRING;=;2$B;5 is replaced by EQUAL 
   compiling exported < : ($,$) -> Boolean
      ISTRING;<;2$B;6 is replaced by CGREATERPts 
   compiling exported concat : ($,$) -> $
      ISTRING;concat;3$;7 is replaced by STRCONC 
   compiling exported copy : $ -> $
      ISTRING;copy;2$;8 is replaced by COPY-SEQ 
   compiling exported nil : () -> $
      LIST;nil;$;1 is replaced by  
   compiling exported null : $ -> Boolean
      LIST;null;$B;2 is replaced by NULL 
   compiling exported cons : (S,$) -> $
      LIST;cons;S2$;3 is replaced by CONS 
   compiling exported append : ($,$) -> $
      LIST;append;3$;4 is replaced by APPEND 
   compiling exported sup : ($,$) -> $
      NNI;sup;3$;1 is replaced by MAX 
   compiling exported shift : ($,Integer) -> $
      NNI;shift;$I$;2 is replaced by ASH 
   compiling exported print : $ -> Void
      OUTFORM;print;$V;1 is replaced by mathprint 
   compiling exported = : ($,$) -> Boolean
      OUTFORM;=;2$B;4 is replaced by EQUAL 
   compiling exported coerce : $ -> OutputForm
      OUTFORM;coerce;2$;6 is replaced by a 
   compiling exported outputForm : Integer -> $
      OUTFORM;outputForm;I$;7 is replaced by n 
   compiling exported outputForm : Symbol -> $
      OUTFORM;outputForm;S$;8 is replaced by e 
   compiling exported outputForm : DoubleFloat -> $
      OUTFORM;outputForm;Df$;9 is replaced by f 
   compiling local sform : String -> $
      OUTFORM;sform is replaced by s 
   compiling local eform : Symbol -> $
      OUTFORM;eform is replaced by e 
   compiling local iform : Integer -> $
      OUTFORM;iform is replaced by n 
   compiling exported width : $ -> Integer
      OUTFORM;width;$I;14 is replaced by outformWidth 
   compiling exported height : $ -> Integer
      OUTFORM;height;$I;15 is replaced by height 
   compiling exported subHeight : $ -> Integer
      OUTFORM;subHeight;$I;16 is replaced by subspan 
   compiling exported superHeight : $ -> Integer
      OUTFORM;superHeight;$I;17 is replaced by superspan 
   compiling exported height : () -> Integer
      OUTFORM;height;I;18 is replaced by 20 
   compiling exported width : () -> Integer
      OUTFORM;width;I;19 is replaced by 66 
   compiling exported elt : ($,List $) -> $
      OUTFORM;elt;$L$;73 is replaced by CONS 
   compiling exported # : $ -> NonNegativeInteger
      PRIMARR;#;$Nni;1 is replaced by QVSIZE 
   compiling exported minIndex : $ -> Integer
      PRIMARR;minIndex;$I;2 is replaced by 0 
   compiling exported empty : () -> $
      PRIMARR;empty;$;3 is replaced by GETREFV0 
   compiling exported qelt : ($,Integer) -> S
      PRIMARR;qelt;$IS;5 is replaced by ELT 
   compiling exported elt : ($,Integer) -> S
      PRIMARR;elt;$IS;6 is replaced by ELT 
   compiling exported qsetelt! : ($,Integer,S) -> S
      PRIMARR;qsetelt!;$I2S;7 is replaced by SETELT 
   compiling exported setelt : ($,Integer,S) -> S
      PRIMARR;setelt;$I2S;8 is replaced by SETELT 
   compiling exported = : ($,$) -> Boolean
      REF;=;2$B;1 is replaced by EQ 
   compiling exported ref : S -> $
      REF;ref;S$;2 is replaced by LIST 
   compiling exported elt : $ -> S
      REF;elt;$S;3 is replaced by QCAR 
   compiling exported deref : $ -> S
      REF;deref;$S;5 is replaced by QCAR 
   compiling exported characteristic : () -> NonNegativeInteger
      RNS-;characteristic;Nni;1 is replaced by 0 
   compiling exported hash : S -> SingleInteger
      SETCAT-;hash;SSi;1 is replaced by 0 
   compiling exported latex : S -> String
      SETCAT-;latex;SS;2 is replaced by \mbox{\bf Unimplemented} 
   compiling exported reducedSystem : Matrix $ -> Matrix Integer
      SINT;reducedSystem;MM;6 is replaced by m 
   compiling exported convert : $ -> Integer
      SINT;convert;$I;8 is replaced by x 
   compiling exported Zero : () -> $
      SINT;Zero;$;10 is replaced by 0 
   compiling exported One : () -> $
      SINT;One;$;11 is replaced by 1 
   compiling exported base : () -> $
      SINT;base;$;12 is replaced by 2 
   compiling exported max : () -> $
      SINT;max;$;13 is replaced by MOST-POSITIVE-FIXNUM 
   compiling exported min : () -> $
      SINT;min;$;14 is replaced by MOST-NEGATIVE-FIXNUM 
   compiling exported = : ($,$) -> Boolean
      SINT;=;2$B;15 is replaced by EQL 
   compiling exported ~ : $ -> $
      SINT;~;2$;16 is replaced by LOGNOT 
   compiling exported not : $ -> $
      SINT;not;2$;17 is replaced by LOGNOT 
   compiling exported /\ : ($,$) -> $
      SINT;/\;3$;18 is replaced by LOGAND 
   compiling exported \/ : ($,$) -> $
      SINT;\/;3$;19 is replaced by LOGIOR 
   compiling exported Not : $ -> $
      SINT;Not;2$;20 is replaced by LOGNOT 
   compiling exported And : ($,$) -> $
      SINT;And;3$;21 is replaced by LOGAND 
   compiling exported Or : ($,$) -> $
      SINT;Or;3$;22 is replaced by LOGIOR 
   compiling exported xor : ($,$) -> $
      SINT;xor;3$;23 is replaced by LOGXOR 
   compiling exported < : ($,$) -> Boolean
      SINT;<;2$B;24 is replaced by QSLESSP 
   compiling exported inc : $ -> $
      SINT;inc;2$;25 is replaced by QSADD1 
   compiling exported dec : $ -> $
      SINT;dec;2$;26 is replaced by QSSUB1 
   compiling exported - : $ -> $
      SINT;-;2$;27 is replaced by QSMINUS 
   compiling exported + : ($,$) -> $
      SINT;+;3$;28 is replaced by QSPLUS 
   compiling exported - : ($,$) -> $
      SINT;-;3$;29 is replaced by QSDIFFERENCE 
   compiling exported * : ($,$) -> $
      SINT;*;3$;30 is replaced by QSTIMES 
   compiling exported quo : ($,$) -> $
      SINT;quo;3$;32 is replaced by QSQUOTIENT 
   compiling exported rem : ($,$) -> $
      SINT;rem;3$;33 is replaced by QSREMAINDER 
   compiling exported gcd : ($,$) -> $
      SINT;gcd;3$;35 is replaced by GCD 
   compiling exported abs : $ -> $
      SINT;abs;2$;36 is replaced by QSABSVAL 
   compiling exported odd? : $ -> Boolean
      SINT;odd?;$B;37 is replaced by QSODDP 
   compiling exported zero? : $ -> Boolean
      SINT;zero?;$B;38 is replaced by QSZEROP 
   compiling exported one? : $ -> Boolean
      SINT;one?;$B;39 is replaced by EQLx1 
   compiling exported max : ($,$) -> $
      SINT;max;3$;40 is replaced by QSMAX 
   compiling exported min : ($,$) -> $
      SINT;min;3$;41 is replaced by QSMIN 
   compiling exported hash : $ -> $
      SINT;hash;2$;42 is replaced by HASHEQ 
   compiling exported length : $ -> $
      SINT;length;2$;43 is replaced by INTEGER-LENGTH 
   compiling exported shift : ($,$) -> $
      SINT;shift;3$;44 is replaced by QSLEFTSHIFT 
   compiling exported mulmod : ($,$,$) -> $
      SINT;mulmod;4$;45 is replaced by QSMULTMOD 
   compiling exported addmod : ($,$,$) -> $
      SINT;addmod;4$;46 is replaced by QSADDMOD 
   compiling exported submod : ($,$,$) -> $
      SINT;submod;4$;47 is replaced by QSDIFMOD 
   compiling exported negative? : $ -> Boolean
      SINT;negative?;$B;48 is replaced by QSMINUSP 
   compiling exported reducedSystem : (Matrix $,Vector $) -> Record(mat: Matrix Integer,vec: Vector Integer)
      SINT;reducedSystem;MVR;49 is replaced by CONS 
   compiling exported random : $ -> $
      SINT;random;2$;53 is replaced by RANDOM 
   compiling exported convert : $ -> Symbol
      SYMBOL;convert;2$;7 is replaced by s 
   compiling exported = : ($,$) -> Boolean
      SYMBOL;=;2$B;9 is replaced by EQUAL 
   compiling exported < : ($,$) -> Boolean
      SYMBOL;<;2$B;10 is replaced by GGREATERPyx 
   compiling local mapper : (Integer -> Boolean,Integer) -> Boolean
      CWMMT;mapper is replaced by SPADCALLnfn 


============================================================================

>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.


>compiling AXSERV.spad to AXSERV.nrlib
 
; (DEFUN |AXSERV;getCommand| ...) is being compiled.
;; The variable |tmpmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |tmpalgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savemathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |$texOutputStream| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |savealgebra| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultmathml| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |resultalgebra| is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;getShow| ...) is being compiled.
;; The variable SAVESTREAM is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |AXSERV;lastType| ...) is being compiled.
;; The variable |first| is undefined.
;; The compiler will assume this variable is a global.
;; The variable |stepSav| is undefined.
;; The compiler will assume this variable is a global.

=========================================================================

>compiling FDIV.spad to FDIV.nrlib
 
--------constructor---------
; (DEFUN |FiniteDivisor;| ...) is being compiled.
;; The variable IDENTITY is undefined.
;; The compiler will assume this variable is a global.

========================================================================
>compiling EQ.spad to EQ.nrlib
 
; (DEFUN |Equation;| ...) is being compiled.
;; The variable IDENTITY is undefined.


=========================================================================

>compiling NAGD02.spad to NAGD02.nrlib
 
; (DEFUN |NAGD02;d02bbf;Df3IDfMDfIUUR;1| ...) is being compiled.
;; The variable FCN is undefined.
;; The compiler will assume this variable is a global.
;; The variable OUTPUT is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NAGD02;d02bhf;Df2I2DfMDfIUUR;2| ...) is being compiled.
;; The variable G is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NAGD02;d02ejf;Df2ISIDfMDfIUUUUR;4| ...) is being compiled.
;; The variable PEDERV is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NAGD02;d02gbf;2DfIDf3I4M2IUUR;6| ...) is being compiled.
;; The variable FCNF is undefined.
;; The compiler will assume this variable is a global.
;; The variable FCNG is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NAGD02;d02kef;M2IDf2I2DfM2IUUR;7| ...) is being compiled.
;; The variable COEFFN is undefined.
;; The compiler will assume this variable is a global.
;; The variable BDYVAL is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NAGD02;d02raf;4IDf6I2MDfIUUR;9| ...) is being compiled.
;; The variable JACOBF is undefined.
;; The compiler will assume this variable is a global.
;; The variable JACEPS is undefined.
;; The compiler will assume this variable is a global.
;; The variable JACOBG is undefined.
;; The compiler will assume this variable is a global.
;; The variable JACGEP is undefined.
;; The compiler will assume this variable is a global.


=========================================================================

>compiling NAGE04.spad to NAGE04.nrlib
 
; (DEFUN |NAGE04;e04dgf;I2DfIDfB2Df4IMIUR;1| ...) is being compiled.
;; The variable OBJFUN is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NAGE04;e04fdf;4IMIUR;2| ...) is being compiled.
;; The variable LSFUN1 is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NAGE04;e04gcf;4IMIUR;3| ...) is being compiled.
;; The variable LSFUN2 is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NAGE04;e04jaf;4I3MIUR;4| ...) is being compiled.
;; The variable FUNCT1 is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NAGE04;e04naf;8IDf6M3B2IMMIUR;6| ...) is being compiled.
;; The variable QPHESS is undefined.
;; The compiler will assume this variable is a global.
; (DEFUN |NAGE04;e04ucf;6I3M2IBDfI2DfB4DfB5I3Df5IM4MIUUR;7| ...) is being compiled.
;; The variable CONFUN is undefined.
;; The compiler will assume this variable is a global.

========================================================================

============================================================================
============================================================================
============================================================================
========== TPDHERE FIXED ===================================================
============================================================================
============================================================================
============================================================================

fixed 7045: gentoo needs -lXpm on loader flags

============================================================================

fixed 7023: 
axiom -noht
draw(sin(x),x=0..1)
(click quit on control)

fixed 7023: draw(sin(x),x=-%pi..%pi) & close the 2D graphic window => crash

Here is a patchlet that needs to be reviewed. It fixes a bug in the
function 'discardGraph' (src/graph/viewman/makeGraph.c). This bug is
triggered when closing a view2D window [see the end of this email].

@@ -144,7 +144,7 @@

   for (j=0, pL=theGraph->listOfListsOfPoints;
        j<theGraph->numberOfLists; j++,pL++)
     free(pL->listOfPoints);
-  free(pL);
+  free(theGraph->listOfListsOfPoints);
   free(theGraph);

}

Nothing more to say than it uses the correct pointer to free the array.
See the beginning of src/graph/viewman/makeGraph.c for the memory
allocation and src/graph/include/view2D.h for the structure
declarations.

Greg


==============

1-> draw(sin(x),x=-%pi..%pi)

close the 2D graphic window =>

*** glibc detected
*** /usr/local/FriCAS/target/x86_64-unknown-linux/lib/viewman:
munmap_chunk(): invalid pointer: 0x000000000060b0d0 ***
======= Backtrace: =========
/lib/libc.so.6(cfree+0x1b6)[0x2b0346291d06]
/usr/local/FriCAS/target/x86_64-unknown-linux/lib/viewman[0x40334e]
/usr/local/FriCAS/target/x86_64-unknown-linux/lib/viewman[0x401786]
/usr/local/FriCAS/target/x86_64-unknown-linux/lib/viewman[0x4017d8]
/usr/local/FriCAS/target/x86_64-unknown-linux/lib/viewman[0x4039b9]
/lib/libc.so.6(__libc_start_main+0xf4)[0x2b03462381c4]
/usr/local/FriCAS/target/x86_64-unknown-linux/lib/viewman[0x401579]
======= Memory map: ========
00400000-00409000 r-xp 00000000 08:06
607870                             /usr/local/FriCAS/target/x86_64-unknown-linux/lib/viewman
00608000-00609000 rw-p 00008000 08:06
607870                             /usr/local/FriCAS/target/x86_64-unknown-linux/lib/viewman
00609000-0062c000 rw-p 00609000 00:00 0
[heap]
2b03455bb000-2b03455d8000 r-xp 00000000 08:06
4693820                    /lib/ld-2.7.so
2b03455d8000-2b03455db000 rw-p 2b03455d8000 00:00 0 
2b03457d7000-2b03457d9000 rw-p 0001c000 08:06
4693820                    /lib/ld-2.7.so
2b03457d9000-2b03457db000 r-xp 00000000 08:06
4693818                    /lib/libutil-2.7.so
2b03457db000-2b03459da000 ---p 00002000 08:06
4693818                    /lib/libutil-2.7.so
2b03459da000-2b03459dc000 rw-p 00001000 08:06
4693818                    /lib/libutil-2.7.so
2b03459dc000-2b03459ec000 r-xp 00000000 08:06
528342                     /usr/lib/libXpm.so.4.11.0
2b03459ec000-2b0345bec000 ---p 00010000 08:06
528342                     /usr/lib/libXpm.so.4.11.0
2b0345bec000-2b0345bed000 rw-p 00010000 08:06
528342                     /usr/lib/libXpm.so.4.11.0
2b0345bed000-2b0345bf5000 r-xp 00000000 08:06
524156                     /usr/lib/libSM.so.6.0.0
2b0345bf5000-2b0345df4000 ---p 00008000 08:06
524156                     /usr/lib/libSM.so.6.0.0
2b0345df4000-2b0345df5000 rw-p 00007000 08:06
524156                     /usr/lib/libSM.so.6.0.0
2b0345df5000-2b0345e0b000 r-xp 00000000 08:06
524100                     /usr/lib/libICE.so.6.3.0
2b0345e0b000-2b034600b000 ---p 00016000 08:06
524100                     /usr/lib/libICE.so.6.3.0
2b034600b000-2b034600c000 rw-p 00016000 08:06
524100                     /usr/lib/libICE.so.6.3.0
2b034600c000-2b0346011000 rw-p 2b034600c000 00:00 0 
2b0346011000-2b0346113000 r-xp 00000000 08:06
524535                     /usr/lib/libX11.so.6.2.0
2b0346113000-2b0346213000 ---p 00102000 08:06
524535                     /usr/lib/libX11.so.6.2.0
2b0346213000-2b034621a000 rw-p 00102000 08:06
524535                     /usr/lib/libX11.so.6.2.0
2b034621a000-2b034636e000 r-xp 00000000 08:06
4693798                    /lib/libc-2.7.so
2b034636e000-2b034656e000 ---p 00154000 08:06
4693798                    /lib/libc-2.7.so
2b034656e000-2b0346571000 r--p 00154000 08:06
4693798                    /lib/libc-2.7.so
2b0346571000-2b0346573000 rw-p 00157000 08:06
4693798                    /lib/libc-2.7.so
2b0346573000-2b0346578000 rw-p 2b0346573000 00:00 0 
2b0346578000-2b034657a000 r-xp 00000000 08:06
527433                     /usr/lib/libXau.so.6.0.0
2b034657a000-2b0346679000 ---p 00002000 08:06
527433                     /usr/lib/libXau.so.6.0.0
2b0346679000-2b034667a000 rw-p 00001000 08:06
527433                     /usr/lib/libXau.so.6.0.0
2b034667a000-2b034667b000 rw-p 2b034667a000 00:00 0 
2b034667b000-2b0346680000 r-xp 00000000 08:06
527018                     /usr/lib/libXdmcp.so.6.0.0
2b0346680000-2b034677f000 ---p 00005000 08:06
527018                     /usr/lib/libXdmcp.so.6.0.0
2b034677f000-2b0346780000 rw-p 00004000 08:06
527018                     /usr/lib/libXdmcp.so.6.0.0
2b0346780000-2b0346782000 r-xp 00000000 08:06
4693806                    /lib/libdl-2.7.so
2b0346782000-2b0346982000 ---p 00002000 08:06
4693806                    /lib/libdl-2.7.so
2b0346982000-2b0346984000 rw-p 00002000 08:06
4693806                    /lib/libdl-2.7.so

============================================================================

fixed 7020: find the right sourcefile for each axiom domain

============================================================================

fixed 7019: mathml does not render F,3 properly
(1) -> F:=operator 'F

   (1)  F
                                                          Type: BasicOperator
(2) -> x:=operator 'x

   (2)  x
                                                          Type: BasicOperator
(3) -> y:=operator 'y

   (3)  y
                                                          Type: BasicOperator
(4) -> a:=F(x z, y z, z^2)+x y(z+1)

                                   2
   (4)  x(y(z + 1)) + F(x(z),y(z),z )
                                                     Type: Expression Integer
(5) -> dadz:=D(a,z)

   (5)
                      2     ,                  2     ,                  2
     2zF  (x(z),y(z),z ) + y (z)F  (x(z),y(z),z ) + x (z)F  (x(z),y(z),z )
        ,3                       ,2                       ,1
   + 
      ,           ,
     x (y(z + 1))y (z + 1)

                                                     Type: Expression Integer
(6) -> )set out mathml on
(6) -> dadz:=D(a,z)

   (6)
                      2     ,                  2     ,                  2
     2zF  (x(z),y(z),z ) + y (z)F  (x(z),y(z),z ) + x (z)F  (x(z),y(z),z )
        ,3                       ,2                       ,1
   + 
      ,           ,
     x (y(z + 1))y (z + 1)

<math xmlns="http://www.w3.org/1998/Math/MathML" mathsize="big" display="block">
<mrow><mrow><mn>2</mn><mo>&#x02062;</mo><mi>z</mi><mo>&#x02062;</mo><mfrac><mo>&#x02202;</mo><mi>F</mi><mrow><mo>&#x02202;</mo><mi>**z2</mi></mrow></mfrac><mo>(</mo><mi>xz</mi><mo>,</mo><mi>yz</mi><mo>,</mo><mi>**z2</mi><mo>)</mo></mrow><mo>+</mo><mrow><mfrac><mrow><msup><mo>&#x02146;</mo><mn>1</mn></msup><mi>y</mi></mrow><mrow><mo>&#x02146;</mo><msup><mi>z</mi><mn>1</mn></msup></mrow></mfrac><mo>&#x02061;</mo><mo>(</mo><mi>z</mi><mo>)</mo><mo>&#x02062;</mo><mfrac><mo>&#x02202;</mo><mi>F</mi><mrow><mo>&#x02202;</mo><mi>yz</mi></mrow></mfrac><mo>(</mo><mi>xz</mi><mo>,</mo><mi>yz</mi><mo>,</mo><mi>**z2</mi><mo>)</mo></mrow><mo>+</mo><mrow><mfrac><mrow><msup><mo>&#x02146;</mo><mn>1</mn></msup><mi>x</mi></mrow><mrow><mo>&#x02146;</mo><msup><mi>z</mi><mn>1</mn></msup></mrow></mfrac><mo>&#x02061;</mo><mo>(</mo><mi>z</mi><mo>)</mo><mo>&#x02062;</mo><mfrac><mo>&#x02202;</mo><mi>F</mi><mrow><mo>&#x02202;</mo><mi>xz</mi></mrow></mfrac><mo>(</mo><mi>xz</mi><mo>,</mo><mi>yz</mi><mo>,</mo><mi>**z2</mi><mo>)</mo></mrow><mo>+</mo><mrow><mfrac><mrow><msup><mo>&#x02146;</mo><mn>1</mn></msup><mi>x</mi></mrow><mrow><mo>&#x02146;</mo><msup><mi>y+z1</mi><mn>1</mn></msup></mrow></mfrac><mo>&#x02061;</mo><mo>(</mo><mi>y+z1</mi><mo>)</mo><mo>&#x02062;</mo><mfrac><mrow><msup><mo>&#x02146;</mo><mn>1</mn></msup><mi>y</mi></mrow><mrow><mo>&#x02146;</mo><msup><mi>+z1</mi><mn>1</mn></msup></mrow></mfrac><mo>&#x02061;</mo><mo>(</mo><mi>+z1</mi><mo>)</mo></mrow></mrow>
</math>

                                                     Type: Expression Integer
(7) -> 

This renders at

 2zinvalid-markup(xz,....

============================================================================

fixed 7016: display of %%var is wrong
  by waldek 20071205
zerosOf(y**4+1,y)
definingPolynomial %y1
   %%var^2+1
but the mathml shows
   var^2+1

============================================================================

fixed 7014: Cannot take first of an empty list
  by waldek patch added 20071205
)set out mathml on
z:=continuedFraction(3,repeating [1],repeating [3,6])

   (7)
           1 |     1 |     1 |     1 |     1 |     1 |     1 |     1 |     1 |
     3 + +---+ + +---+ + +---+ + +---+ + +---+ + +---+ + +---+ + +---+ + +---+
         | 3     | 6     | 3     | 6     | 3     | 6     | 3     | 6     | 3
   + 
       1 |
     +---+ + ...
     | 6
 
   >> System error:
   Cannot take first of an empty list

BDS[0]: + = NIL
BDS[1]: ++ = NIL
BDS[2]: +++ = NIL
BDS[3]: - = (PROGN (GBC T) (LOAD "/research2/test/obj/fedora5/interp/makeint.lisp") (GBC T) (SPAD-SAVE "/research2/test/obj/fedora5/bin/interpsys"))
BDS[4]: * = NIL
BDS[5]: ** = NIL
BDS[6]: *** = NIL
BDS[7]: / = NIL
BDS[8]: // = NIL
    FRS[2]: (CATCH (QUOTE (NIL)) ***) ---> IHS[5],VS[8],BDS[9]
BDS[9]: /// = NIL
BDS[10]: |$PrintCompilerMessageIfTrue| = T
    FRS[3]: (CATCH (QUOTE (NIL)) ***) ---> IHS[6],VS[8],BDS[11]
    FRS[4]: (CATCH (QUOTE |coerceFailure|) ***) ---> IHS[6],VS[8],BDS[11]
    FRS[5]: (CATCH (QUOTE |top_level|) ***) ---> IHS[6],VS[8],BDS[11]
BDS[11]: |$inLispVM| = T
BDS[12]: |$e| = ((NIL))
BDS[13]: $SPAD = NIL
BDS[14]: $NEWSPAD = NIL
BDS[15]: $BOOT = NIL
BDS[16]: |$InteractiveMode| = T
BDS[17]: *EOF* = NIL
BDS[18]: IN-STREAM = #<OBJNULL>
BDS[19]: CURINSTREAM = #<synonym stream to *STANDARD-INPUT*>
    FRS[6]: (CATCH (QUOTE |top_level|) ***) ---> IHS[6],VS[8],BDS[20]
BDS[20]: CUROUTSTREAM = #<synonym stream to *STANDARD-OUTPUT*>
BDS[21]: |$promptMsg| = #<OBJNULL>
BDS[22]: |$shoeReadLineFunction| = #<OBJNULL>
BDS[23]: |$systemCommandFunction| = #<OBJNULL>
BDS[24]: |$ncMsgList| = NIL
BDS[25]: |$erMsgToss| = #<OBJNULL>
BDS[26]: |$lastPos| = #<OBJNULL>
BDS[27]: |$inclAssertions| = #<OBJNULL>
BDS[28]: |$okToExecuteMachineCode| = #<OBJNULL>
BDS[29]: |$newcompErrorCount| = 0
BDS[30]: |$newcompMode| = NIL
BDS[31]: |$libQuiet| = #<OBJNULL>
BDS[32]: |$fn| = #<OBJNULL>
    FRS[7]: (CATCH (QUOTE |SpadCompileItem|) ***) ---> IHS[6],VS[8],BDS[33]
    FRS[8]: (CATCH (QUOTE |coerceFailure|) ***) ---> IHS[6],VS[8],BDS[33]
    FRS[9]: (CATCH (QUOTE SPAD_READER) ***) ---> IHS[6],VS[8],BDS[33]
BDS[33]: |$stepNo| = #<OBJNULL>
BDS[34]: |$convPhase| = #<OBJNULL>
    FRS[10]: (UNWIND-PROTECT ***) ---> IHS[6],VS[8],BDS[35]
BDS[35]: |$ncMsgList| = NIL
BDS[36]: |$op| = #<OBJNULL>
BDS[37]: |$Coerce| = #<OBJNULL>
BDS[38]: |$compErrorMessageStack| = #<OBJNULL>
BDS[39]: |$freeVars| = #<OBJNULL>
BDS[40]: |$mapList| = #<OBJNULL>
BDS[41]: |$compilingMap| = NIL
BDS[42]: |$compilingLoop| = #<OBJNULL>
BDS[43]: |$interpOnly| = NIL
BDS[44]: |$whereCacheList| = #<OBJNULL>
BDS[45]: |$timeGlobalName| = #<OBJNULL>
BDS[46]: |$StreamFrame| = #<OBJNULL>
BDS[47]: |$declaredMode| = #<OBJNULL>
BDS[48]: |$localVars| = NIL
BDS[49]: |$analyzingMapList| = #<OBJNULL>
BDS[50]: |$lastLineInSEQ| = #<OBJNULL>
BDS[51]: |$instantCoerceCount| = #<OBJNULL>
BDS[52]: |$instantCanCoerceCount| = #<OBJNULL>
BDS[53]: |$instantMmCondCount| = #<OBJNULL>
BDS[54]: |$fortVar| = #<OBJNULL>
BDS[55]: |$minivector| = #<OBJNULL>
BDS[56]: |$minivectorCode| = #<OBJNULL>
BDS[57]: |$minivectorNames| = NIL
BDS[58]: |$domPvar| = NIL
BDS[59]: |$inRetract| = #<OBJNULL>
BDS[60]: |$e| = ((NIL))
    FRS[11]: (BLOCK NIL ***) ---> IHS[9],VS[137],BDS[61]
BDS[61]: |$outputMode| = #<OBJNULL>
BDS[62]: SERROR::*ERROR-HANDLER-ARGS* = NIL
BDS[63]: SYSTEM::*BREAK-MESSAGE* = ""
BDS[64]: SYSTEM::*QUIT-TAGS* = NIL
BDS[65]: SYSTEM::*QUIT-TAG* = (NIL)
BDS[66]: SYSTEM::*BREAK-LEVEL* = NIL
BDS[67]: SYSTEM::*IHS-BASE* = 1
BDS[68]: SYSTEM::*IHS-TOP* = 3
BDS[69]: SYSTEM::*CURRENT-IHS* = 1
BDS[70]: SYSTEM::*FRS-BASE* = 0
BDS[71]: SYSTEM::*FRS-TOP* = 0
BDS[72]: SYSTEM::*BREAK-ENV* = NIL
BDS[73]: *BREAK-ENABLE* = T
BDS[74]: *READTABLE* = #<readtable 0840bf78>
BDS[75]: *READ-SUPPRESS* = NIL
BDS[76]: + = NIL
BDS[77]: ++ = NIL
BDS[78]: +++ = NIL
BDS[79]: - = NIL
BDS[80]: * = NIL
BDS[81]: ** = NIL
BDS[82]: *** = NIL
BDS[83]: / = NIL
BDS[84]: // = NIL
BDS[85]: /// = NIL

============================================================================

fixed 7013: (SF/1814510): System Error PF2
 -> FFP(PF 2,x3+x+1)

Cannot convert from type Polynomial SparseUnivariatePolynomial
PrimeField 2 to SparseUnivariatePolynomial PrimeField 2 for value
x3+x+1

 -> FFP(PF 2,x3+x+1)
 >> System Error

============================================================================

fixed 7011: The function |SubDomain| is undefined

(4) -> [Ring, SetCategory]

 
   >> System error:
   The function |SubDomain| is undefined.

The change to i-output in function output(expr,domain) from

  (FUNCTIONP(opOf domain)) and

  (FUNCTIONP(opOf domain)) and (not (SYMBOLP(opOf domain))) and

changes the result to:
 LISP output:
(UNPRINTABLE UNPRINTABLE)
                                                  Type: List SubDomain Domain


============================================================================

fixed 7010, fixed 209: The function |Domain| is undefined

(4) -> [Integer, Float]

 
   >> System error:
   The function |Domain| is undefined.

The change to i-output in function output(expr,domain) from

  (FUNCTIONP(opOf domain)) and

  (FUNCTIONP(opOf domain)) and (not (SYMBOLP(opOf domain))) and

changes the result to:
 LISP output:
(UNPRINTABLE UNPRINTABLE)
                                                  Type: List SubDomain Domain

============================================================================

fixed105: integrate(z^3000,z=0..1)

============================================================================

fixed 7015: display of hex digits is wrong
hex(10)

   (9)  A
<math xmlns="http://www.w3.org/1998/Math/MathML" mathsize="big" display="block">
<mi>#\A</mi>
</math>

                                                   Type: HexadecimalExpansion

============================================================================

fixed 7042: FAILED 1 of 16 stanzas file LinearOrdinaryDifferentialOperator
MISMATCH
expected:"   Compiling function G3349 with type Integer -> Boolean "
     got:"   Compiling function G3347 with type Integer -> Boolean "
FAILED LinearOrdinaryDifferentialOperator  12 of 16

============================================================================

fixed 7041: FAILED 1 of 5 stanzas file OrderedVariableList

expected:"   Compiling function G1572 with type NonNegativeInteger -> Boolean "
     got:"   Compiling function G1570 with type NonNegativeInteger -> Boolean "
MISMATCH
expected:"   Compiling function G1408 with type Integer -> Boolean "
     got:"   Compiling function G1406 with type Integer -> Boolean "
FAILED OrderedVariableList  4

============================================================================

fixed 7054: bookvol11 has /home/silver

============================================================================

fixed 7057: summation is ambiguous

summation(i^2,i=a..b)^(d-c)

         b      d - c
        --+    2
   (1)  >     i
        --+
        i= a

summation(i^2^(d-c),i=a..b)

         b      d - c
        --+    2
   (2)  >     i
        --+
        i= a

sum(operator(f) (i)+1,i=1..n)

         n
        --+
   (3)  >     f(i) + 1
        --+
        i= 1

sum(operator(f) (i),i=1..n)+1

         n
        --+
   (4)  >     f(i) + 1
        --+
        i= 1

sum(operator(f) (i)+1,i=1..n)^3

         n            3
        --+
   (5)  >     f(i) + 1
        --+
        i= 1

============================================================================

fixed 7052: axbook gets remade

154 making /research2/test/mnt/fedora5/doc/hypertex/axbook/xhtml from /research2/test/src/hyper/axbook.tgz

=========================================================================

fixed 7090/355:

fix needs combfunc, op, and sf patches

-- derivative of besselK (issue 355)
D(besselK(a,x),x)

        - besselK(a + 1,x) - besselK(a - 1,x)
   (5)  -------------------------------------
                          2
                                                     Type: Expression Integer

D(besselK(a,x),a)

   (6)  0
                                                     Type: Expression Integer

integrate(D(besselK(a,x),a),a)

   (7)  0
                                          Type: Union(Expression Integer,...)

limit(D(besselK(a,x),a),a=1/2)

   (8)  0
                        Type: Union(OrderedCompletion Expression Integer,...)


Now reads:

(1) -> D(besselK(a,x),x)

        - besselK(a + 1,x) - besselK(a - 1,x)
   (1)  -------------------------------------
                          2
                                                     Type: Expression Integer
(2) -> D(besselK(a,x),a)

   (2)  besselK  (a,x)
               ,1
                                                     Type: Expression Integer
(3) -> integrate(D(besselK(a,x),a),a)

   (3)  besselK(a,x)
                                          Type: Union(Expression Integer,...)
(4) -> limit(D(besselK(a,x),a),a=1/2)

   (4)  "failed"
                                                    Type: Union("failed",...)
=========================================================================

fixed 7093: some function renames in regression test files

calculus2.input.pamphlet.patch
collect.input.pamphlet.patch
easter.input.pamphlet.patch
exlap.input.pamphlet.patch
exsum.input.pamphlet.patch
grpthry.input.pamphlet.patch
knot2.input.pamphlet.patch
repa6.input.pamphlet.patch
for i in /tmp/*input.*patch ; do echo $i ; patch <$i ; done

=========================================================================

fixed 7094: integer.spad (221)
fixed 7065/221:

PI has OASGP

change

PositiveInteger: Join(AbelianSemiGroup,OrderedSet,Monoid) with

to

PositiveInteger: Join(OrderedAbelianSemiGroup,Monoid) with

because

OrderedAbelianSemiGroup is AbelianSemiGroup,OrderedSet

=========================================================================

fixed 7089/343:

-- order in FreeAbelianGroup (issue 343)
Z2:=FreeAbelianGroup Symbol
a:= a::FreeAbelianGroup Symbol
b:= b::FreeAbelianGroup Symbol
z:= 0::FreeAbelianGroup Symbol

a < -b
-b < z
z < a

--- free.spad.pamphlet	2007-10-18 00:37:06.000000000 -0400
+++ free.spad.pamphlet.tpd	2007-10-18 00:37:14.000000000 -0400
@@ -531,21 +531,21 @@
       inmax l ==
         mx := first l
         for t in rest l repeat
-          if t.gen > mx.gen then mx := t
+          if mx.gen < t.gen then mx := t
         mx
 
+      -- lexicographic order
       a < b ==
         zero? a  =>
           zero? b => false
-          (inmax terms b).exp > 0
+          0 < (inmax terms b).exp
         ta := inmax terms a
         zero? b => ta.exp < 0
-        ta := inmax terms a
         tb := inmax terms b
-        ta.gen < tb.gen => true
-        ta.gen > tb.gen => false
+        ta.gen < tb.gen => 0 < tb.exp
+        tb.gen < ta.gen => ta.exp < 0
         ta.exp < tb.exp => true
-        ta.exp > tb.exp => false
+        tb.exp < ta.exp => false
         lc := ta.exp * ta.gen
         (a - lc) < (b - lc)
 

=========================================================================

fixed 7100/149: hyperdoc fails to allowed edits if num-lock is on

=========================================================================

fixed 7101/204: MoreSystemCommands is loaded during test runs

=========================================================================

wish 1001: E(n,x)==(n=1 => E1(x) ; 1/(n-1)*(%e^-x-x*En(n-1,x)))

=========================================================================

fixed bug 7103: output of negative numbers is wrong

20080105 tpd src/algebra/acplot.spad fix output form of negative numbers
20080105 tpd src/algebra/sf.spad fix output form of negative numbers

=========================================================================

fixed bug 7102: Equality testing in TableAggregate 

=========================================================================

wish 1002: Axiom quick reference card

=========================================================================

fixed 7106: extra )spool in LexTriangularPackage

=========================================================================

fixed 7099: complex Gamma bug

Note that at the value 1.0+4.6i there is a radical departure between
the table and the computed values in the imaginary part of the value
even though the real part is exact.

For the complex number 1+4.5i using Axiom's algorithm we create a 
list of 4 values, 
     [the complex number
      the Abramowitz value
      the Axiom expression
      the difference of (Axiom expression) - (Abramowitz)]

So at the complex value of 1+4.5i we find:

     [1. + 4.5 * %i,
       - 5.397606238984 + 3.035196999922 * %i,_
       log(Gamma(1. + 4.5*%i)),_
       log(Gamma(1. + 4.5*%i))-(- 5.397606238984 + 3.035196999922 * %i)]

     [1. + 4.5 %i, 
      - 5.3976062389840003 + 3.0351969999219999 %i,
      - 5.3976062389839621 + 3.0351969999216122 %i,
        3.8191672047105385E-14 - 3.8768988019910466E-13 %i]

which is correct to about 13 places. We also compute the same values
using the formula 6.1.40 on page 257 in Abramowitz:

    [1. + 4.5 * %i,
      - 5.397606238984 + 3.035196999922 * %i,
      H(1. + 4.5 * %i),
      H(1. + 4.5 * %i)-(- 5.397606238984 + 3.035196999922 * %i)],

     [1.0 + 4.5 %i, 
      - 5.397606238984 + 3.035196999922 %i,
      - 5.3976062390513914695 + 3.035196999831937613 %i,
      - 0.673914695 E -10 - 0.90062387 E -10 %i]

which is correct to about 10 places.

At the complex value of 1+4.6i we find:

     [1. + 4.6 * %i,
      - 5.543696418304 + 3.187112279389 * %i,_
      log(Gamma(1. + 4.6*%i)),_
      log(Gamma(1. + 4.6*%i))-(- 5.543696418304 + 3.187112279389 * %i)]

     [1. + 4.6 %i, 
      - 5.5436964183040001 + 3.1871122793889999 %i,
      - 5.5436964183041857 - 3.0960730277910646 %i,
      - 1.8562928971732617E-13 - 6.2831853071800641 %i]

which is wildly different from Abramowitz in the imaginary part.
But using the 6.1.40 formula we compute:

     [1. + 4.6 * %i,
      - 5.543696418304 + 3.187112279389 * %i,
      H(1. + 4.6 * %i),
      H(1. + 4.6 * %i)-(- 5.543696418304 + 3.187112279389 * %i)],

     [1.0 + 4.6 %i, 
      - 5.543696418304 + 3.187112279389 %i,
      - 5.543696418361390699 + 3.1871122793208820187 %i,
      - 0.57390699 E -10 - 0.681179813 E -10 %i]

which is again correct to about 10 places.

The Abramowitz formula is computed in src/input/gamma.input.pamphlet

=========================================================================

fixed 7113: mathML display bug (20080316.01.acr.patch)

-> x:=104348/33215

  104348
  ------
   33215

-> factor(numer x)/factor(denom x)

   2
  2 19 1373
  ---------
  5 7 13 73

but mathML shows:

   2
  2 191373
  --------
   571373

=========================================================================

fixed 7082/47: fixed by patch 20080508.01.wxh.patch

complexForm(log(%i) - log(-%i))
-- integrate((z^a+1)^b, z) crashes (issue 100)
integrate((z^a+1)^b, z)

=========================================================================

fixed 7080/308: fixed

integrate(x^a*(x^b+1)^p, x)

-- laplace(log(z), z,w) crashes (issue 101)
laplace(log(z), z,w)

laplace(1/sqrt(z), z, w)
laplace(sqrt(z), z, w)

=========================================================================

fixed 7079/103:

solve(z=z,z)

=========================================================================

fixed 7073/199:

integrate(exp(-x^2)+exp(x)/x,x)

============================================================================

enable restarting hyperdoc
fixed  (7) )hyperdoc should (re-)start hyperdoc and reconnect

=========================================================================

fixed 7117: topics -> graphics -> viewports crashes axiom with

uncompress: No such file or directory

=========================================================================

fixed 7115: topics -> graphics -> Examples -> Assorted Examples -> downarrow

uncompress: No such file or directory

=========================================================================

fixed 7146: Warning: macro table not found

patch 20081123.03.tpd.patch

=========================================================================

fixed 7148: bookvol0, bookvol1 use SmallFloat

should be DoubleFloat

patch 20081123.05.tpd.patch

=========================================================================

fixed 7161: r21bugsbig value stack overflow 
20081205.01.tpd.patch (integer.spad change reverted)

=========================================================================

fixed 7141: )cd relative does not work

export $AXIOM=/research2/test/mnt/fedora5
cd /tmp
axiom
)cd /home
fails with
 
   >> System error:
   Can't change the current directory to "/research2/test/mnt/fedora5/NIL/".

=========================================================================
20090221.01.tpd.patch
fixed 7170: )d op 

all ops output fails due to the use of X in the comments

=========================================================================
20090221.01.tpd.patch

fixed 7171: )d op 

the Examples output is off-by-one in printing

=========================================================================
20090222.04.tpd.patch

fixed 7178: missing function inspect in ArrayStack

map! a
   Internal Error
   The function map! with signature hashcode is missing from domain 
      ArrayStack(Integer) 

(11) -> 

=========================================================================
20090222.04.tpd.patch

fixed 7177: missing function map! in ArrayStack

map! a
   Internal Error
   The function map! with signature hashcode is missing from domain 
      ArrayStack(Integer) 

(11) -> 

=========================================================================
20090222.04.tpd.patch

fixed 7176: missing function parts in ArrayStack

parts a
   Internal Error
   The function parts with signature hashcode is missing from domain 
      ArrayStack(Integer) 

(11) -> 

=========================================================================
20090222.04.tpd.patch

fixed 7175: missing function map in ArrayStack

map(x+->x+1,a)
   Loading /research/test/mnt/fedora10/algebra/BGAGG-.o for domain 
      BagAggregate& 
   Loading /research/test/mnt/fedora10/algebra/HOAGG-.o for domain 
      HomogeneousAggregate& 
   Loading /research/test/mnt/fedora10/algebra/AGG-.o for domain 
      Aggregate& 
   Loading /research/test/mnt/fedora10/algebra/SETCAT-.o for domain 
      SetCategory& 
   Loading /research/test/mnt/fedora10/algebra/BASTYPE-.o for domain 
      BasicType& 
   Internal Error
   The function map with signature hashcode is missing from domain 
      ArrayStack(Integer) 

(10) -> 

=========================================================================
20090222.02.tpd.patch

fixed 7174: missing function map! in Stack

map! a
   Internal Error
   The function map! with signature hashcode is missing from domain 
      Stack(Integer) 

(11) -> 

=========================================================================
20090222.02.tpd.patch

fixed 7173: missing function parts in Stack

parts a
   Internal Error
   The function parts with signature hashcode is missing from domain 
      Stack(Integer) 

(11) -> 

=========================================================================
20090222.02.tpd.patch

fixed 7172: missing function map in Stack

map(x+->x+1,a)
   Loading /research/test/mnt/fedora10/algebra/BGAGG-.o for domain 
      BagAggregate& 
   Loading /research/test/mnt/fedora10/algebra/HOAGG-.o for domain 
      HomogeneousAggregate& 
   Loading /research/test/mnt/fedora10/algebra/AGG-.o for domain 
      Aggregate& 
   Loading /research/test/mnt/fedora10/algebra/SETCAT-.o for domain 
      SetCategory& 
   Loading /research/test/mnt/fedora10/algebra/BASTYPE-.o for domain 
      BasicType& 
   Internal Error
   The function map with signature hashcode is missing from domain 
      Stack(Integer) 

(10) -> 

=========================================================================

fixed in 20090310.01.tpd.patch
fixed 7179: )abb anywhere in the algebra pamphlets breaks the world

using )abb in a sentence unrelated to the actual abbreviation line
breaks the algebra build claiming nil is not a number. The bug is in
the code in daase.lisp in make-databases in the local function
build-name-to-pamphlet-hash which assumes that )abb must be
the introduction to a new cat/dom/pkg. This could be fixed by
requiring the )abb to start in column 1


=========================================================================
fixed in 20090323.01.tpd.patch
bug 7182: )set mes auto 

should indicate the current value.
The problem is that in the $setOptions tree the autoload branch
indicates a FUNCTION when it should indicate LITERALS and a variable.

=========================================================================
fixed in 20090315.01.tpd.patch
fixed 7183: input-libraries is not a valid function

=========================================================================
fixed in 20090228.01.tpd.patch
fixed 7184: read-char-no-hang skips newlines

=========================================================================

20090315.01.tpd.patch by removing calls to open-library, library-name,
                      and close-library which are CCL functions

fixed 7180: )set compiler input add foo

>> System error:
OPEN-LIBRARY is invalid as a function

=========================================================================

20090404.01.tpd.patch
fixed 7185: (Ralf) Jenks book has bad cross references

=========================================================================
fixed by 20090413.03.tpd.patch
#gitbug1
fixed 7191: compile caches /root

)fin
(defun f () 1)
(compile 'f)

=========================================================================
fixed by 20090313.04.tpd.patch
todo 323: add slackware

=========================================================================
20090414.01.tpd.patch, 20090414.02.tpd.patch
fixed 7192: SPADEDIT is missing

=========================================================================
20090803.02.tpd.patch
fixed 7202: make fails, use make parallel works

=========================================================================
20120214 closed. aldor is no longer supported
todo 327: aldor build info

cd src
tar -zxf ../zips/aldor.20070901.tgz 
patch /research/silver/pending/aldor/Makefile.globals.tpd
 ALDOR_PROJECT=${SRC}/aldor
 ALDOR_INSTALL=${MID}/aldor
 GENERIC_DIR=${MID}/aldor_generic
 GmpDir=/usr/include
make aldorcompiler

tell nate

########################################
#
# Makefile.globals to help build an Aldor distribution
#
# Yannis Chicha, Aldor.org, July 2003
#  chicha@aldor.org
#
##########################################

# YOU CAN MODIFY THE FOLLOWING ELEMENTS


# ALDOR_PROJECT is the full path to the root of the Aldor source tree. This is
# probably the directory where _this_ Makefile.globals is located.  Do not use
# `pwd`.

#
#  SHELL must be /bin/bash on those operating systems (such as some versions
#  of Solaris) where /bin/sh only supports up to 255 characters on the command
#  line
#
SHELL=/bin/bash
ALDOR_PROJECT=$(HOME)/aldor/aldor

# All these things under $(ALDOR_PROJECT) can actually be in unrelated places,
# and don't need to be under any common parent directory.
#ALDOR_SRC=$(ALDOR_PROJECT)/aldor
ALDOR_INSTALL=$(ALDOR_PROJECT)/install/aldor
GENERIC_DIR=$(ALDOR_PROJECT)/install/aldor_generic

ALDOR_VERSION=1.1.0

# MACHINE should be one of: linux, win32gcc, win32msvc, sun4os55g64
# or the machines listed in:  $(ALDOR_PROJECT)/aldor/tools/unix/docc.
MACHINE=linux

# This varible sets the name of the libraries to be built
# aldor builds the basic libaldor library.
# axllib builds the basic libaxllib library, it is also used to run aldor's 
#     regression tests.
# algebra builds libalgebra library and it depends on libaldor, so it must be
#     built first. 
# Note: the order in the list sets the order of building the libraries.
#LIBS_TO_BUILD=aldor axllib debuglib algebra
LIBS_TO_BUILD=aldor axllib 

# This is used to form the name of the tarball archive used for binary 
# distribution.
DISTRIB_PLATFORM=linux-i386

# This should be the directory which contains include/gmp.h.
GmpDir=/usr

LIBALDORROOT=$(ALDOR_PROJECT)/lib/aldor
ALDORLIBROOT=$(LIBALDORROOT)
ALGEBRAROOT=$(ALDOR_PROJECT)/lib/algebra
AXLROOT=$(ALDOR_PROJECT)/lib/axllib

# DO NOT TOUCH THE FOLLOWING PART

export SHELL
export ALDOR_INSTALL
export GENERIC_DIR
export ALDOR_VERSION
export MACHINE
export LIBS_TO_BUILD
export ALDORLIBROOT
export LIBALDORROOT
export ALGEBRAROOT
export GmpDir

ALDORROOT=$(ALDOR_INSTALL)/$(MACHINE)/$(ALDOR_VERSION)
export ALDORROOT

COMPILER=aldor

ifeq ($(MACHINE), win32gcc)
	COMPILER=aldor.sh
endif

ifeq ($(MACHINE), win32msvc)
	COMPILER=aldor.sh
endif

export COMPILER


=========================================================================
fixed 20120219. 

merged waldek's format.lisp with my format.lisp.
Note that this breaks the printing of types.

bug 7217: bad title generated in Axiom 3D output

given:

cf(x,y) == 0.5
draw(exp(cos(x-y)-sin(x*y))-2,x=-5..5,y=-5..5,_
     colorFunction==cf,style=="smooth")

The title reads:
  DEXP((-DSIN(x*y))+DCOS(y-x))-2
but should read:
  exp(cos(x-y)-sin(x*y))-2

bug is probably here:
src/interp/newfort.lisp.pamphlet:;    op = '"cos" => '"DCOS"
src/interp/newfort.lisp.pamphlet:;    op = '"cosh" => '"DCOSH"
src/interp/newfort.lisp.pamphlet:           ((BOOT-EQUAL |op| "cos") "DCOS")
src/interp/newfort.lisp.pamphlet:           ((BOOT-EQUAL |op| "cosh") "DCOSH")


fixed 20130313.03.tpd.patch
=========================================================================
macros 30230: 

      AFFSP;affinePoint;L$;6 is replaced by pt 
      AFFSP;coerce;$L;5 is replaced by pt 
      AFFSP;list;$L;7 is replaced by ptt 
      AFFSP;pointValue;$L;8 is replaced by ptt 

warnings 20495:

   Warnings: 
      [1] definingField: pretendRep -- should replace by @
      [2] coerce: pretendRep -- should replace by @
      [3] list: pretendRep -- should replace by @
      [4] pointValue: pretendRep -- should replace by @


fixed 20130313.04.tpd.patch
=========================================================================
warnings 20480:

>compiling INTRVL.spad to INTRVL.nrlib
 
macros 30143:

      INTRVL;characteristic;Nni;38 is replaced by 0 
      INTRVL;exactInterval is replaced by CONS 
      INTRVL;inf;$R;10 is replaced by QCAR 
      INTRVL;sup;$R;11 is replaced by QCDR 

   Warnings: 
      [1] roundDown: pretend(Integer) -- should replace by @
      [2] roundUp: pretend(Integer) -- should replace by @
      [3] normaliseFloat: pretend(Integer) -- should replace by @
      [4] **: pretend(Integer) -- should replace by @
      [5] ^: pretend(Integer) -- should replace by @
      [6] interval: pretend(Integer) -- should replace by @

fixed 20130313.05.tpd.patch
=========================================================================
macros 30047:

      SEXOF;float?;$B;11 is replaced by RNUMP 

fixed 20130313.06.tpd.patch
=========================================================================
warnings 20501:

>compiling SEXOF.spad to SEXOF.nrlib
 
   Warnings: 
      [1] convert: pretend$ -- should replace by @


fixed 20130313.07.tpd.patch
=========================================================================
bug 7235: 

>compiling FSPECF.spad to FSPECF.nrlib
 
"iiGamma(x) should be local but conditional."

typos 40077:

>compiling FSPECF.spad to FSPECF.nrlib
 
--->bookvol10.4.pamphlet-->FunctionalSpecialFunction((iiBeta (F (List F)))): Improper first word in comments: iiGamma

fixed 20130314.01.tpd.patch
=========================================================================
warnings 20467:

>compiling GRAY.spad to GRAY.nrlib
 
   Warnings: 
      [1] firstSubsetGray: :(Vector (Integer)) -- should replace by @
 
fixed 20130314.06.tpd.patch
=========================================================================
warnings 20542:

>compiling ITAYLOR.spad to ITAYLOR.nrlib
 
   Warnings: 
      [1] series: pretend$ -- should replace by @
      [2] =:  st has no value

fixed 20130314.07.tpd.patch
=========================================================================
warnings 20056:

>compiling SYMBOL.spad to SYMBOL.nrlib
 
   Warnings: 
      [1] OMwrite: pretend(String) -- should replace by @
      [2] latex: pretend(String) -- should replace by @
 
fixed 20130314.08.tpd.patch
=========================================================================
warnings 20057:

>compiling SINT.spad to SINT.nrlib
 
   Warnings: 
      [1] OMwrite: pretend(String) -- should replace by @
      [2] **: pretend(Integer) -- should replace by @

fixed 20130314.09.tpd.patch
=========================================================================
warnings 20383:

>compiling SMTS.spad to SMTS.nrlib
 
   Warnings: 
      [6] *: pretendRep -- should replace by @
      [7] *: pretend$ -- should replace by @
      [11] eval: pretend$ -- should replace by @
      [12] subststream: pretend$ -- should replace by @
      [15] stream: pretendRep -- should replace by @
      [21] /: pretend$ -- should replace by @
 
dup 50005:

Warning: SMTS;stream has a duplicate definition in this file

fixed 20130314.10.tpd.patch
=========================================================================
warnings 20001:

>compiling MFLOAT.spad to MFLOAT.nrlib
 
   Warnings: 
      [1] normalise: pretend(Integer) -- should replace by @
      [3] changeBase: pretend(Integer) -- should replace by @
      [7] retractIfCan: pretend(Integer) -- should replace by @
      [8] +: pretend(Integer) -- should replace by @
 
fixed 20130315.01.tpd.patch
=========================================================================
warnings 20063:

>compiling LIST.spad to LIST.nrlib
 
   Warnings: 
      [1] OMwrite: pretend(String) -- should replace by @
      [2] setIntersection:  u has no value
      [3] setDifference:  lu has no value
 
fixed 20130315.02.tpd.patch
=========================================================================
warnings 20073:

>compiling DFLOAT.spad to DFLOAT.nrlib
 
   Warnings: 
      [1] OMwrite: pretend(String) -- should replace by @
      [4] coerce: pretend(String) -- should replace by @
      [6] polygamma: :$ -- should replace by @
      [7] polygamma: :(Union (Integer) failed) -- should replace by @
 

fixed 20130315.03.tpd.patch
=========================================================================
warnings 20465:

>compiling INBFF.spad to INBFF.nrlib
 
   Warnings: 
      [1] repSq: pretend(NonNegativeInteger) -- should replace by @
      [2] dAndcExp:  erg has no value
 
fixed 20130315.04.tpd.patch
=========================================================================
typos 40304:

>compiling BLAS1.spad to BLAS1.nrlib

--->bookvol10.5.pamphlet-->BlasLevelOne((dcabs1 (DF CDF))): Improper first word in comments: 
"\\indented{1}{dcabs1(z) computes \\spad{(+} (abs (realpart \\spad{z))} (abs (imagpart z)))} \\blankline \\spad{X} t1:Complex DoubleFloat \\spad{:=} complex(1.0,0) \\spad{X} dcabs1(t1)"

--->bookvol10.5.pamphlet-->BlasLevelOne((dasum (DF SI DX SI))): Improper first word in comments: 
--->bookvol10.5.pamphlet-->BlasLevelOne((dasum (DF SI DX SI))): Missing left bracket
"\\indented{1}{dasum(n,array,incx) computes the sum of \\spad{n} elements in array} \\indented{1}{using a stride of incx} \\blankline \\spad{X} dx:PRIMARR(DFLOAT):=[ [1.0,2.0,3.0,4.0,5.0,6.0] ] \\spad{X} dasum(6,dx,1) \\spad{X} dasum(3,dx,2)"

--->bookvol10.5.pamphlet-->BlasLevelOne((daxpy (DX SI DF DX SI DX SI))): Improper first word in comments: 
--->bookvol10.5.pamphlet-->BlasLevelOne((daxpy (DX SI DF DX SI DX SI))): Missing left bracket
--->bookvol10.5.pamphlet-->BlasLevelOne((daxpy (DX SI DF DX SI DX SI))): Missing left bracket
--->bookvol10.5.pamphlet-->BlasLevelOne((daxpy (DX SI DF DX SI DX SI))): Missing left bracket
--->bookvol10.5.pamphlet-->BlasLevelOne((daxpy (DX SI DF DX SI DX SI))): Missing left bracket
"\\indented{1}{daxpy(n,da,x,incx,y,incy) computes a \\spad{y} = a*x + \\spad{y}} \\indented{1}{for each of the chosen elements of the vectors \\spad{x} and \\spad{y}} \\indented{1}{and a constant multiplier a} \\indented{1}{Note that the vector \\spad{y} is modified with the results.} \\blankline \\spad{X} x:PRIMARR(DFLOAT):=[ [1.0,2.0,3.0,4.0,5.0,6.0] ] \\spad{X} y:PRIMARR(DFLOAT):=[ [1.0,2.0,3.0,4.0,5.0,6.0] ] \\spad{X} daxpy(6,2.0,x,1,y,1) \\spad{X} \\spad{y} \\spad{X} m:PRIMARR(DFLOAT):=[ [1.0,2.0,3.0] ] \\spad{X} n:PRIMARR(DFLOAT):=[ [1.0,2.0,3.0,4.0,5.0,6.0] ] \\spad{X} daxpy(3,-2.0,m,1,n,2) \\spad{X} \\spad{n}"

--->bookvol10.5.pamphlet-->BlasLevelOne((dcopy (DX SI DX SI DX SI))): Improper first word in comments: 
--->bookvol10.5.pamphlet-->BlasLevelOne((dcopy (DX SI DX SI DX SI))): Missing left bracket
--->bookvol10.5.pamphlet-->BlasLevelOne((dcopy (DX SI DX SI DX SI))): Missing left bracket
--->bookvol10.5.pamphlet-->BlasLevelOne((dcopy (DX SI DX SI DX SI))): Missing left bracket
--->bookvol10.5.pamphlet-->BlasLevelOne((dcopy (DX SI DX SI DX SI))): Missing left bracket
"\\indented{1}{dcopy(n,x,incx,y,incy) copies \\spad{y} from \\spad{x}} \\indented{1}{for each of the chosen elements of the vectors \\spad{x} and \\spad{y}} \\indented{1}{Note that the vector \\spad{y} is modified with the results.} \\blankline \\spad{X} x:PRIMARR(DFLOAT):=[ [1.0,2.0,3.0,4.0,5.0,6.0] ] \\spad{X} y:PRIMARR(DFLOAT):=[ [0.0,0.0,0.0,0.0,0.0,0.0] ] \\spad{X} dcopy(6,x,1,y,1) \\spad{X} \\spad{y} \\spad{X} m:PRIMARR(DFLOAT):=[ [1.0,2.0,3.0] ] \\spad{X} n:PRIMARR(DFLOAT):=[ [0.0,0.0,0.0,0.0,0.0,0.0] ] \\spad{X} dcopy(3,m,1,n,2) \\spad{X} \\spad{n}"

--->bookvol10.5.pamphlet-->BlasLevelOne((ddot (DF SI DX SI DX SI))): Improper first word in comments: 
--->bookvol10.5.pamphlet-->BlasLevelOne((ddot (DF SI DX SI DX SI))): Missing left bracket
--->bookvol10.5.pamphlet-->BlasLevelOne((ddot (DF SI DX SI DX SI))): Missing left bracket
"\\indented{1}{ddot(n,x,incx,y,incy) computes the vector dot product} \\indented{1}{of elements from the vector \\spad{x} and the vector \\spad{y}} \\indented{1}{If the indicies are negative the elements are taken} \\indented{1}{relative to the far end of the vector.} \\blankline \\spad{X} x:PRIMARR(DFLOAT):=[ [1.0,2.0,3.0,4.0,5.0] ] \\spad{X} y:PRIMARR(DFLOAT):=[ [5.0,6.0,7.0,8.0,9.0] ] \\spad{X} ddot(0,a,1,b,1) \\spad{--} handle 0 elements \\spad{==>} 0 \\spad{X} ddot(3,a,1,b,1) \\spad{--} (1,2,3) * (5,6,7) \\spad{==>} 38.0 \\spad{X} ddot(3,a,1,b,2) \\spad{--} increment = 2 in \\spad{b} (1,2,3) * (5,7,9) \\spad{==>} 46.0 \\spad{X} ddot(3,a,2,b,1) \\spad{--} increment = 2 in a (1,3,5) * (5,6,7) \\spad{==>} 58.0 \\spad{X} ddot(3,a,1,b,-2) \\spad{--} increment = \\spad{-2} in \\spad{b} (1,2,3) * (9,7,5) \\spad{==>} 38.0 \\spad{X} ddot(2,a,-2,b,1) \\spad{--} increment = \\spad{-2} in a (5,3,1) * (5,6,7) \\spad{==>} 50.0 \\spad{X} ddot(3,a,-2,b,-2) \\spad{--} (5,3,1) * (9,7,5) \\spad{==>} 71.0"

--->bookvol10.5.pamphlet-->BlasLevelOne((dnrm2 (DF SI DX SI))): Improper first word in comments: 
--->bookvol10.5.pamphlet-->BlasLevelOne((dnrm2 (DF SI DX SI))): Missing left bracket
"\\indented{1}{dnrm2 takes the norm of the vector, ||x||} \\blankline \\spad{X} a:PRIMARR(DFLOAT):=[ [3.0, -4.0, 5.0, -7.0, 9.0] ] \\spad{X} dnrm2(3,a,1) \\spad{--} 7.0710678118654755 = \\spad{sqrt(3.0^2} + \\spad{-4.0^2} + 5.0^2) \\spad{X} dnrm2(5,a,1) \\spad{--} 13.416407864998739 = sqrt(180.0) \\spad{X} dnrm2(3,a,2) \\spad{--} 10.72380529476361 = sqrt(115.0)"

--->bookvol10.5.pamphlet-->BlasLevelOne((drotg (DX DF DF DF DF))): Improper first word in comments: 
"\\indented{1}{drotg computes a 2D plane Givens rotation spanned by two} \\indented{1}{coordinate axes.} \\blankline \\spad{X} a:MATRIX(DFLOAT):=[[6,5,0],[5,1,4],[0,4,3]] \\spad{X} drotg(elt(a,1,1),elt(a,1,2),0.0D0,0.0D0)"

--->bookvol10.5.pamphlet-->BlasLevelOne((drot (LDX SI DX SI DX SI DF DF))): Improper first word in comments: 
"\\indented{1}{drot computes a 2D plane Givens rotation spanned by two} \\indented{1}{coordinate axes. It modifies the arrays in place.} \\indented{1}{The call drot(n,dx,incx,dy,incy,c,s) has the \\spad{dx} array which} \\indented{1}{contains the \\spad{y} axis locations and dy which contains the} \\indented{1}{y axis locations. They are rotated in parallel where} \\indented{1}{c is the cosine of the angle and \\spad{s} is the sine of the angle and} \\indented{1}{c^2+s^2 = 1} \\blankline \\spad{X} dx:PRIMARR(DFLOAT):=[[6,0, 1.0, 4.0, -1.0, -1.0]] \\spad{X} dy:PRIMARR(DFLOAT):=[[5.0, 1.0, -4.0, 4.0, -4.0]] \\spad{X} drot(5,dx,1,dy,1,0.707106781,0.707106781) \\spad{--} rotate by 45 degrees \\spad{X} \\spad{dx} \\spad{--} \\spad{dx} has been modified \\spad{X} dy \\spad{--} dy has been modified \\spad{X} drot(5,dx,1,dy,1,0.707106781,-0.707106781) \\spad{--} rotate by \\spad{-45} degrees \\spad{X} \\spad{dx} \\spad{--} \\spad{dx} has been modified \\spad{X} dy \\spad{--} dy has been modified"

--->bookvol10.5.pamphlet-->BlasLevelOne((dscal (DX SI DF DX SI))): Improper first word in comments: 
"\\indented{1}{dscal scales each element of the vector by the scalar so} \\indented{1}{dscal(n,da,dx,incx) = da*dx for \\spad{n} elements, incremented by incx} \\indented{1}{Note that the \\spad{dx} array is modified in place.} \\blankline \\spad{X} dx:PRIMARR(DFLOAT):=[[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]] \\spad{X} dscal(6,2.0,dx,1) \\spad{X} \\spad{dx} \\spad{X} dx:PRIMARR(DFLOAT):=[[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]] \\spad{X} dscal(3,0.5,dx,1) \\spad{X} \\spad{dx}"

--->bookvol10.5.pamphlet-->BlasLevelOne((dswap (LDX SI DX SI DX SI))): Improper first word in comments: 
"\\indented{1}{dswap swaps elements from the first vector with the second} \\indented{1}{Note that the arrays are modified in place.} \\blankline \\spad{X} dx:PRIMARR(DFLOAT):=[[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]] \\spad{X} dy:PRIMARR(DFLOAT):=[[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]] \\spad{X} dswap(5,dx,1,dy,1) \\spad{X} dx:PRIMARR(DFLOAT):=[[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]] \\spad{X} dy:PRIMARR(DFLOAT):=[[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]] \\spad{X} dswap(3,dx,2,dy,2) \\spad{X} dx:PRIMARR(DFLOAT):=[[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]] \\spad{X} dy:PRIMARR(DFLOAT):=[[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]] \\spad{X} dswap(5,dx,1,dy,-1)"

--->bookvol10.5.pamphlet-->BlasLevelOne((dzasum (DF SI PCDF SI))): Improper first word in comments: 
"\\indented{1}{dzasum takes the sum over all of the array where each} \\indented{1}{element of the array sum is the sum of the absolute} \\indented{1}{value of the real part and the absolute value of the} \\indented{1}{imaginary part of each array element:} \\indented{3}{for \\spad{i} in array do sum = sum + (real(a(i)) + imag(a(i)))} \\blankline \\spad{X} d:PRIMARR(COMPLEX(DFLOAT)):=[[1.0+2.0*\\%i,-3.0+4.0*\\%i,5.0-6.0*\\%i]] \\spad{X} dzasum(3,d,1) \\spad{--} 21.0 \\spad{X} dzasum(3,d,2) \\spad{--} 14.0 \\spad{X} dzasum(-3,d,1) \\spad{--} 0.0"

--->bookvol10.5.pamphlet-->BlasLevelOne((dznrm2 (DF SI PCDF SI))): Improper first word in comments: 
"\\indented{1}{dznrm2 returns the norm of a complex vector. It computes} \\indented{1}{sqrt(sum(v*conjugate(v)))} \\blankline \\spad{X} a:PRIMARR(COMPLEX(DFLOAT)) \\spad{X} a:=[[3.+4.*\\%i,-4.+5.*\\%i,5.+6.*\\%i,7.-8.*\\%i,-9.-2.*\\%i]] \\spad{X} dznrm2(5,a,1) \\spad{--} should be 18.028 \\spad{X} dznrm2(3,a,2) \\spad{--} should be 13.077 \\spad{X} dznrm2(3,a,1) \\spad{--} should be 11.269 \\spad{X} dznrm2(3,a,-1) \\spad{--} should be 0.0 \\spad{X} dznrm2(-3,a,-1) \\spad{--} should be 0.0 \\spad{X} dznrm2(1,a,1) \\spad{--} should be 5.0 \\spad{X} dznrm2(1,a,2) \\spad{--} should be 5.0"

--->bookvol10.5.pamphlet-->BlasLevelOne((icamax (INT INT PCF INT))): Improper first word in comments: 
"\\indented{1}{icamax computes the largest absolute value of the elements} \\indented{1}{of the array and returns the index of the first instance} \\indented{1}{of the maximum} \\blankline \\spad{X} a:PRIMARR(COMPLEX(FLOAT)) \\spad{X} a:=[[3.+4.*\\%i,-4.+5.*\\%i,5.+6.*\\%i,7.-8.*\\%i,-9.-2.*\\%i]] \\spad{X} icamax(5,a,1) \\spad{--} should be 3 \\spad{X} icamax(0,a,1) \\spad{--} should be \\spad{-1} \\spad{X} icamax(5,a,-1) \\spad{--} should be \\spad{-1} \\spad{X} icamax(3,a,1) \\spad{--} should be 2 \\spad{X} icamax(3,a,2) \\spad{--} should be 1"

--->bookvol10.5.pamphlet-->BlasLevelOne((idamax (INT INT DX INT))): Improper first word in comments: 
"\\indented{1}{idamax computes the largest absolute value of the elements} \\indented{1}{of the array and returns the index of the first instance} \\indented{1}{of the maximum.} \\blankline \\spad{X} a:PRIMARR(DFLOAT):=[[3.0, 4.0, -3.0, 5.0, -1.0]] \\spad{X} idamax(5,a,1) \\spad{--} should be 3 \\spad{X} idamax(3,a,1) \\spad{--} should be 1 \\spad{X} idamax(0,a,1) \\spad{--} should be \\spad{-1} \\spad{X} idamax(-5,a,1) \\spad{--} should be \\spad{-1} \\spad{X} idamax(5,a,-1) \\spad{--} should be \\spad{-1} \\spad{X} idamax(5,a,2) \\spad{--} should be 0 \\spad{X} idamax(1,a,0) \\spad{--} should be \\spad{-1} \\spad{X} idamax(1,a,-1) \\spad{--} should be \\spad{-1} \\spad{X} a:PRIMARR(DFLOAT):=[[3.0, 4.0, -3.0, -5.0, -1.0]] \\spad{X} idamax(5,a,1) \\spad{--} should be 3"

--->bookvol10.5.pamphlet-->BlasLevelOne((isamax (INT INT SX INT))): Improper first word in comments: 
"\\indented{1}{isamax computes the largest absolute value of the elements} \\indented{1}{of the array and returns the index of the first instance} \\indented{1}{of the maximum.} \\blankline \\spad{X} a:PRIMARR(FLOAT):=[[3.0, 4.0, -3.0, 5.0, -1.0]] \\spad{X} isamax(5,a,1) \\spad{--} should be 3 \\spad{X} isamax(3,a,1) \\spad{--} should be 1 \\spad{X} isamax(0,a,1) \\spad{--} should be \\spad{-1} \\spad{X} isamax(-5,a,1) \\spad{--} should be \\spad{-1} \\spad{X} isamax(5,a,-1) \\spad{--} should be \\spad{-1} \\spad{X} isamax(5,a,2) \\spad{--} should be 0 \\spad{X} isamax(1,a,0) \\spad{--} should be \\spad{-1} \\spad{X} isamax(1,a,-1) \\spad{--} should be \\spad{-1} \\spad{X} a:PRIMARR(FLOAT):=[[3.0, 4.0, -3.0, -5.0, -1.0]] \\spad{X} isamax(5,a,1) \\spad{--} should be 3"

--->bookvol10.5.pamphlet-->BlasLevelOne((izamax (INT SI PCDF SI))): Improper first word in comments: 
"\\indented{1}{izamax computes the largest absolute value of the elements} \\indented{1}{of the array and returns the index of the first instance} \\indented{1}{of the maximum.} \\blankline \\spad{X} a:PRIMARR(COMPLEX(DFLOAT)) \\spad{X} a:=[[3.+4.*\\%i,-4.+5.*\\%i,5.+6.*\\%i,7.-8.*\\%i,-9.-2.*\\%i]] \\spad{X} izamax(5,a,1) \\spad{--} should be 3 \\spad{X} izamax(0,a,1) \\spad{--} should be \\spad{-1} \\spad{X} izamax(5,a,-1) \\spad{--} should be \\spad{-1} \\spad{X} izamax(3,a,1) \\spad{--} should be 2 \\spad{X} izamax(3,a,2) \\spad{--} should be 1"

--->bookvol10.5.pamphlet-->BlasLevelOne((zaxpy (PCDF SI CDF PCDF SI PCDF SI))): Improper first word in comments: 
"\\indented{1}{zaxpy(n,da,x,incx,y,incy) computes a \\spad{y} = a*x + \\spad{y}} \\indented{1}{for each of the chosen elements of the vectors \\spad{x} and \\spad{y}} \\indented{1}{and a constant multiplier a} \\indented{1}{Note that the vector \\spad{y} is modified with the results.} \\blankline \\spad{X} a:PRIMARR(COMPLEX(DFLOAT)) \\spad{X} a:=[[3.+4.*\\%i, -4.+5.*\\%i, 5.+6.*%i, 7.-8.*%i, -9.-2.*\\%i]] \\spad{X} b:PRIMARR(COMPLEX(DFLOAT)) \\spad{X} b:=[[3.+4.*\\%i, -4.+5.*\\%i, 5.+6.*%i, 7.-8.*%i, -9.-2.*\\%i]] \\spad{X} zaxpy(3,2.0,a,1,b,1) \\spad{X} b:=[[3.+4.*\\%i, -4.+5.*\\%i, 5.+6.*%i, 7.-8.*%i, -9.-2.*\\%i]] \\spad{X} zaxpy(5,2.0,a,1,b,1) \\spad{X} b:=[[3.+4.*\\%i, -4.+5.*\\%i, 5.+6.*%i, 7.-8.*%i, -9.-2.*\\%i]] \\spad{X} zaxpy(3,2.0,a,3,b,3) \\spad{X} b:=[[3.+4.*\\%i, -4.+5.*\\%i, 5.+6.*%i, 7.-8.*%i, -9.-2.*\\%i]] \\spad{X} zaxpy(4,2.0,a,2,b,2)"

