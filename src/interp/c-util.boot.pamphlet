\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp c-util.boot}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
This file contains both the {\bf boot} code and the {\bf Lisp}
code that is the result of the {\bf boot to lisp} translation.
We need to keep the translated code around so we can bootstrap
the system. In other words, we need this boot code translated
so we can build the boot translator. 

{\bf NOTE: AFTER CHANGING THIS BOOT CODE YOU MUST TRANSLATE
THIS CODE TO LISP AND STORE THE RESULTING LISP CODE BACK INTO
THIS FILE.}

See the {\bf c-util.clisp} section below.
\section{License}
<<license>>=
-- Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
-- All rights reserved.
--
-- Redistribution and use in source and binary forms, with or without
-- modification, are permitted provided that the following conditions are
-- met:
--
--     - Redistributions of source code must retain the above copyright
--       notice, this list of conditions and the following disclaimer.
--
--     - Redistributions in binary form must reproduce the above copyright
--       notice, this list of conditions and the following disclaimer in
--       the documentation and/or other materials provided with the
--       distribution.
--
--     - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--       names of its contributors may be used to endorse or promote products
--       derived from this software without specific prior written permission.
--
-- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-- IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-- TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-- PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
-- OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-- EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-- PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-- PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-- LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-- NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-- SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

@
<<*>>=
<<license>>

--% Debugging Functions
 
CONTINUE() == continue()
continue() == FIN comp($x,$m,$f)
 
LEVEL(:l) == APPLY('level,l)
level(:l) ==
  null l => same()
  l is [n] and INTEGERP n => displayComp ($level:= n)
  SAY '"Correct format: (level n) where n is the level you want to go to"
 
UP() == up()
up() == displayComp ($level:= $level-1)
 
SAME() == same()
same() == displayComp $level
 
DOWN() == down()
down() == displayComp ($level:= $level+1)
 
displaySemanticErrors() ==
  n:= #($semanticErrorStack:= REMDUP $semanticErrorStack)
  n=0 => nil
  l:= NREVERSE $semanticErrorStack
  $semanticErrorStack:= nil
  sayBrightly bright '"  Semantic Errors:"
  displaySemanticError(l,CUROUTSTREAM)
  sayBrightly '" "
  displayWarnings()
 
displaySemanticError(l,stream) ==
  for x in l for i in 1.. repeat
    sayBrightly(['"      [",i,'"] ",:first x],stream)
 
displayWarnings() ==
  n:= #($warningStack:= REMDUP $warningStack)
  n=0 => nil
  sayBrightly bright '"  Warnings:"
  l := NREVERSE $warningStack
  displayWarning(l,CUROUTSTREAM)
  $warningStack:= nil
  sayBrightly '" "
 
displayWarning(l,stream) ==
  for x in l for i in 1.. repeat
    sayBrightly(['"      [",i,'"] ",:x],stream)
 
displayComp level ==
  $tripleCache:= nil
  $bright:= " << "
  $dim:= " >> "
  if $insideCapsuleFunctionIfTrue=true then
    sayBrightly ['"error in function",'%b,$op,'%d,'%l]
  --mathprint removeZeroOne mkErrorExpr level
  pp removeZeroOne mkErrorExpr level
  sayBrightly ['"****** level",'%b,level,'%d,'" ******"]
  [$x,$m,$f,$exitModeStack]:= ELEM($s,level)
  ($X:=$x;$M:=$m;$F:=$f)
  SAY("$x:= ",$x)
  SAY("$m:= ",$m)
  SAY "$f:="
  F_,PRINT_-ONE $f
  nil
 
mkErrorExpr level ==
  bracket ASSOCLEFT DROP(level-#$s,$s) where
    bracket l ==
      #l<2 => l
      l is [a,b] =>
        highlight(b,a) where
          highlight(b,a) ==
            atom b =>
              substitute(var,b,a) where
                var:= INTERN STRCONC(STRINGIMAGE $bright,_
                                     STRINGIMAGE b,STRINGIMAGE $dim)
            highlight1(b,a) where
              highlight1(b,a) ==
                atom a => a
                a is [ =b,:c] => [$bright,b,$dim,:c]
                [highlight1(b,first a),:highlight1(b,rest a)]
      substitute(bracket rest l,first rest l,first l)
 
compAndTrace [x,m,e] ==
  SAY("tracing comp, compFormWithModemap of: ",x)
  TRACE_,1(["comp","compFormWithModemap"],nil)
  T:= comp(x,m,e)
  UNTRACE_,1 "comp"
  UNTRACE_,1 "compFormWithModemap"
  T
 
errorRef s == stackWarning ['%b,s,'%d,'"has no value"]
 
unErrorRef s == unStackWarning ['%b,s,'%d,'"has no value"]
 
--% ENVIRONMENT FUNCTIONS
 
consProplistOf(var,proplist,prop,val) ==
  semchkProplist(var,proplist,prop,val)
  $InteractiveMode and (u:= ASSOC(prop,proplist)) =>
    RPLACD(u,val)
    proplist
  [[prop,:val],:proplist]
 
warnLiteral x ==
  stackSemanticError(['%b,x,'%d,
    '"is BOTH a variable and a literal"],nil)
 
intersectionEnvironment(e,e') ==
  ce:= makeCommonEnvironment(e,e')
  ic:= intersectionContour(deltaContour(e,ce),deltaContour(e',ce))
  e'':= (ic => addContour(ic,ce); ce)
  --$ie:= e''   this line is for debugging purposes only
 
deltaContour([[c,:cl],:el],[[c',:cl'],:el']) ==
  ^el=el' => systemError '"deltaContour" --a cop out for now
  eliminateDuplicatePropertyLists contourDifference(c,c') where
    contourDifference(c,c') == [first x for x in tails c while (x^=c')]
    eliminateDuplicatePropertyLists contour ==
      contour is [[x,:.],:contour'] =>
        LASSOC(x,contour') =>
                               --save some CONSing if possible
          [first contour,:DELLASOS(x,eliminateDuplicatePropertyLists contour')]
        [first contour,:eliminateDuplicatePropertyLists contour']
      nil
 
intersectionContour(c,c') ==
  $var: local := nil
  computeIntersection(c,c') where
    computeIntersection(c,c') ==
      varlist:= REMDUP ASSOCLEFT c
      varlist':= REMDUP ASSOCLEFT c'
      interVars:= setIntersection(varlist,varlist')
      unionVars:= setUnion(varlist,varlist')
      diffVars:= setDifference(unionVars,interVars)
      modeAssoc:= buildModeAssoc(diffVars,c,c')
      [:modeAssoc,:
        [[x,:proplist]
          for [x,:y] in c | MEMBER(x,interVars) and
            (proplist:= interProplist(y,LASSOC($var:= x,c')))]]
    interProplist(p,p') ==
                            --p is new proplist; p' is old one
      [:modeCompare(p,p'),:[pair' for pair in p | (pair':= compare(pair,p'))]]
    buildModeAssoc(varlist,c,c') ==
      [[x,:mp] for x in varlist | (mp:= modeCompare(LASSOC(x,c),LASSOC(x,c')))]
    compare(pair is [prop,:val],p') ==
      --1. if the property-value pair are identical, accept it immediately
      pair=(pair':= ASSOC(prop,p')) => pair
      --2. if property="value" and modes are unifiable, give intersection
      --       property="value" but value=genSomeVariable)()
      (val':= KDR pair') and prop="value" and
        (m:= unifiable(val.mode,val'.mode)) => _
                                 ["value",genSomeVariable(),m,nil]
            --this tells us that an undeclared variable received
            --two different values but with identical modes
      --3. property="mode" is covered by modeCompare
      prop="mode" => nil
    modeCompare(p,p') ==
      pair:= ASSOC("mode",p) =>
        pair':= ASSOC("mode",p') =>
          m'':= unifiable(rest pair,rest pair') => LIST ["mode",:m'']
          stackSemanticError(['%b,$var,'%d,"has two modes: "],nil)
       --stackWarning ("mode for",'%b,$var,'%d,"introduced conditionally")
        LIST ["conditionalmode",:rest pair]
        --LIST pair
       --stackWarning ("mode for",'%b,$var,'%d,"introduced conditionally")
      pair':= ASSOC("mode",p') => LIST ["conditionalmode",:rest pair']
        --LIST pair'
    unifiable(m1,m2) ==
      m1=m2 => m1
        --we may need to add code to coerce up to tagged unions
        --but this can not be done here, but should be done by compIf
      m:=
        m1 is ["Union",:.] =>
          m2 is ["Union",:.] => ["Union",:S_+(rest m1,rest m2)]
          ["Union",:S_+(rest m1,[m2])]
        m2 is ["Union",:.] => ["Union",:S_+(rest m2,[m1])]
        ["Union",m1,m2]
      for u in getDomainsInScope $e repeat
        if u is ["Union",:u'] and (and/[MEMBER(v,u') for v in rest m]) then
          return m
        --this loop will return NIL if not satisfied
 
addContour(c,E is [cur,:tail]) ==
  [NCONC(fn(c,E),cur),:tail] where
    fn(c,e) ==
        for [x,:proplist] in c repeat
           fn1(x,proplist,getProplist(x,e)) where
              fn1(x,p,ee) ==
                for pv in p repeat fn3(x,pv,ee) where
                 fn3(x,pv,e) ==
                   [p,:v]:=pv;
                   if MEMBER(x,$getPutTrace) then
                     pp([x,"has",pv]);
                   if p="conditionalmode" then
                     RPLACA(pv,"mode");
                     --check for conflicts with earlier mode
                     if vv:=LASSOC("mode",e) then
                        if v ^=vv then
                          stackWarning ["The conditional modes ",
                                     v," and ",vv," conflict"]
        LIST c
 
makeCommonEnvironment(e,e') ==
  interE makeSameLength(e,e') where  --$ie:=
    interE [e,e'] ==
      rest e=rest e' => [interLocalE makeSameLength(first e,first e'),:rest e]
      interE [rest e,rest e']
    interLocalE [le,le'] ==
      rest le=rest le' =>
        [interC makeSameLength(first le,first le'),:rest le]
      interLocalE [rest le,rest le']
    interC [c,c'] ==
      c=c' => c
      interC [rest c,rest c']
    makeSameLength(x,y) ==
      fn(x,y,#x,#y) where
        fn(x,y,nx,ny) ==
          nx>ny => fn(rest x,y,nx-1,ny)
          nx<ny => fn(x,rest y,nx,ny-1)
          [x,y]
 
printEnv E ==
  for x in E for i in 1.. repeat
    for y in x for j in 1.. repeat
      SAY('"******CONTOUR ",j,'", LEVEL ",i,'":******")
      for z in y repeat
        TERPRI()
        SAY("Properties Of: ",first z)
        for u in rest z repeat
          PRIN0 first u
          printString ": "
          PRETTYPRINT tran(rest u,first u) where
            tran(val,prop) ==
              prop="value" => DROP(-1,val)
              val
 
prEnv E ==
  for x in E for i in 1.. repeat
    for y in x for j in 1.. repeat
      SAY('"******CONTOUR ",j,'", LEVEL ",i,'":******")
      for z in y | not LASSOC("modemap",rest z) repeat
        TERPRI()
        SAY("Properties Of: ",first z)
        for u in rest z repeat
          PRIN0 first u
          printString ": "
          PRETTYPRINT tran(rest u,first u) where
            tran(val,prop) ==
              prop="value" => DROP(-1,val)
              val
 
prModemaps E ==
  listOfOperatorsSeenSoFar:= nil
  for x in E for i in 1.. repeat
    for y in x for j in 1.. repeat
      for z in y | null MEMBER(first z,listOfOperatorsSeenSoFar) and
        (modemap:= LASSOC("modemap",rest z)) repeat
          listOfOperatorsSeenSoFar:= [first z,:listOfOperatorsSeenSoFar]
          TERPRI()
          PRIN0 first z
          printString ": "
          PRETTYPRINT modemap
 
prTriple T ==
   SAY '"Code:"
   pp T.0
   SAY '"Mode:"
   pp T.1
 
TrimCF() ==
  new:= nil
  old:= CAAR $CategoryFrame
  for u in old repeat
    if not ASSQ(first u,new) then
      uold:= rest u
      unew:= nil
      for v in uold repeat if not ASSQ(first v,unew) then unew:= [v,:unew]
      new:= [[first u,:NREVERSE unew],:new]
  $CategoryFrame:= [[NREVERSE new]]
  nil
 
 
--% PREDICATES
 
 
isConstantId(name,e) ==
  IDENTP name =>
    pl:= getProplist(name,e) =>
      (LASSOC("value",pl) or LASSOC("mode",pl) => false; true)
    true
  false
 
isFalse() == nil
 
isFluid s == atom s and "$"=(PNAME s).(0)
 
isFunction(x,e) ==
  get(x,"modemap",e) or GET(x,"SPECIAL") or x="case" or getmode(x,e) is [
    "Mapping",:.]
 
isLiteral(x,e) == get(x,"isLiteral",e)
 
makeLiteral(x,e) == put(x,"isLiteral","true",e)
 
isSomeDomainVariable s ==
  IDENTP s and #(x:= PNAME s)>2 and x.(0)="#" and x.(1)="#"
 
isSubset(x,y,e) ==
  x="$" and y="Rep" or x=y or
    LASSOC(opOf x,get(opOf y,"Subsets",e) or GET(opOf y,"Subsets")) or
      LASSOC(opOf x,get(opOf y,"SubDomain",e)) or
        opOf(y)='Type or opOf(y)='Object
 
isDomainInScope(domain,e) ==
  domainList:= getDomainsInScope e
  atom domain =>
    MEMQ(domain,domainList) => true
    not IDENTP domain or isSomeDomainVariable domain => true
    false
  (name:= first domain)="Category" => true
  ASSQ(name,domainList) => true
--   null CDR domain or domainMember(domain,domainList) => true
--   false
  isFunctor name => false
  true --is not a functor
 
isSymbol x == IDENTP x or x=nil
 
isSimple x ==
  atom x or $InteractiveMode => true
  x is [op,:argl] and
    isSideEffectFree op and (and/[isSimple y for y in argl])
 
isSideEffectFree op ==
  MEMBER(op,$SideEffectFreeFunctionList) or op is ["elt",.,op'] and
    isSideEffectFree op'
 
isAlmostSimple x ==
  --returns (<new predicate> . <list of assignments>) or nil
  $assignmentList: local --$assigmentList is only used in this function
  transform:=
    fn x where
      fn x ==
        atom x or null rest x => x
        [op,y,:l]:= x
        op="has" => x
        op="is" => x
        op="LET" =>
          IDENTP y => (setAssignment LIST x; y)
          true => (setAssignment [["LET",g:= genVariable(),:l],["LET",y,g]]; g)
        isSideEffectFree op => [op,:mapInto(rest x,"fn")]
        true => $assignmentList:= "failed"
      setAssignment x ==
        $assignmentList="failed" => nil
        $assignmentList:= [:$assignmentList,:x]
  $assignmentList="failed" => nil
  wrapSEQExit [:$assignmentList,transform]
 
incExitLevel u ==
  adjExitLevel(u,1,1)
  u
 
decExitLevel u ==
  (adjExitLevel(u,1,-1); removeExit0 u) where
    removeExit0 x ==
      atom x => x
      x is ["exit",0,u] => removeExit0 u
      [removeExit0 first x,:removeExit0 rest x]
 
adjExitLevel(x,seqnum,inc) ==
  atom x => x
  x is [op,:l] and MEMQ(op,'(SEQ REPEAT COLLECT)) =>
    for u in l repeat adjExitLevel(u,seqnum+1,inc)
  x is ["exit",n,u] =>
    (adjExitLevel(u,seqnum,inc); seqnum>n => x; rplac(CADR x,n+inc))
  x is [op,:l] => for u in l repeat adjExitLevel(u,seqnum,inc)
 
wrapSEQExit l ==
  null rest l => first l
  [:c,x]:= [incExitLevel u for u in l]
  ["SEQ",:c,["exit",1,x]]
 
 
--% UTILITY FUNCTIONS
 
--appendOver x == "append"/x
 
removeEnv t == [t.expr,t.mode,$EmptyEnvironment]  -- t is a triple
 
-- This function seems no longer used
--ordinsert(x,l) ==
--  null l => [x]
--  x=first l => l
--  _?ORDER(x,first l) => [x,:l]
--  [first l,:ordinsert(x,rest l)]
 
makeNonAtomic x ==
  atom x => [x]
  x
 
flatten(l,key) ==
  null l => nil
  first l is [k,:r] and k=key => [:r,:flatten(rest l,key)]
  [first l,:flatten(rest l,key)]
 
genDomainVar() ==
  $Index:= $Index+1
  INTERNL STRCONC("#D",STRINGIMAGE $Index)
 
genVariable() ==
  INTERNL STRCONC("#G",STRINGIMAGE ($genSDVar:= $genSDVar+1))
 
genSomeVariable() ==
  INTERNL STRCONC("##",STRINGIMAGE ($genSDVar:= $genSDVar+1))
 
listOfIdentifiersIn x ==
  IDENTP x => [x]
  x is [op,:l] => REMDUP ("append"/[listOfIdentifiersIn y for y in l])
  nil
 
mapInto(x,fn) == [FUNCALL(fn,y) for y in x]
 
numOfOccurencesOf(x,y) ==
  fn(x,y,0) where
    fn(x,y,n) ==
      null y => 0
      x=y => n+1
      atom y => n
      fn(x,first y,n)+fn(x,rest y,n)
 
compilerMessage x ==
  $PrintCompilerMessageIfTrue => APPLX("SAY",x)
 
printDashedLine() ==
  SAY
    '"----------------------------------------------------------------------"
 
stackSemanticError(msg,expr) ==
  BUMPERRORCOUNT "semantic"
  if $insideCapsuleFunctionIfTrue then msg:= [$op,": ",:msg]
  if atom msg then msg:= LIST msg
  entry:= [msg,expr]
  if not MEMBER(entry,$semanticErrorStack) then $semanticErrorStack:=
    [entry,:$semanticErrorStack]
  $scanIfTrue and $insideCapsuleFunctionIfTrue=true and #$semanticErrorStack-
    $initCapsuleErrorCount>3 => THROW("compCapsuleBody",nil)
  nil
 
stackWarning msg ==
  if $insideCapsuleFunctionIfTrue then msg:= [$op,": ",:msg]
  if not MEMBER(msg,$warningStack) then $warningStack:= [msg,:$warningStack]
  nil
 
unStackWarning msg ==
  if $insideCapsuleFunctionIfTrue then msg:= [$op,": ",:msg]
  $warningStack:= EFFACE(msg,$warningStack)
  nil
 
stackMessage msg ==
  $compErrorMessageStack:= [msg,:$compErrorMessageStack]
  nil
 
stackMessageIfNone msg ==
  --used in situations such as compForm where the earliest message is wanted
  if null $compErrorMessageStack then $compErrorMessageStack:=
    [msg,:$compErrorMessageStack]
  nil
 
stackAndThrow msg ==
  $compErrorMessageStack:= [msg,:$compErrorMessageStack]
  THROW("compOrCroak",nil)
 
printString x == PRINTEXP (STRINGP x => x; PNAME x)
 
printAny x == if atom x then printString x else PRIN0 x
 
printSignature(before,op,[target,:argSigList]) ==
  printString before
  printString op
  printString ": _("
  if argSigList then
    printAny first argSigList
    for m in rest argSigList repeat (printString ","; printAny m)
  printString "_) -> "
  printAny target
  TERPRI()
 
pmatch(s,p) == pmatchWithSl(s,p,"ok")
 
pmatchWithSl(s,p,al) ==
  s=$EmptyMode => nil
  s=p => al
  v:= ASSOC(p,al) => s=rest v or al
  MEMQ(p,$PatternVariableList) => [[p,:s],:al]
  null atom p and null atom s and_
          (al':= pmatchWithSl(first s,first p,al)) and
    pmatchWithSl(rest s,rest p,al')
 
elapsedTime() ==
  currentTime:= TEMPUS_-FUGIT()
  elapsedSeconds:= (currentTime-$previousTime)*1.0/$timerTicksPerSecond
  $previousTime:= currentTime
  elapsedSeconds
 
addStats([a,b],[c,d]) == [a+c,b+d]
 
printStats [byteCount,elapsedSeconds] ==
  timeString := normalizeStatAndStringify elapsedSeconds
  if byteCount = 0 then SAY('"Time: ",timeString,'" SEC.") else
    SAY('"Size: ",byteCount,'" BYTES     Time: ",timeString,'" SEC.")
  TERPRI()
  nil
 
extendsCategoryForm(domain,form,form') ==
  --is domain of category form also of category form'?
  --domain is only used for SubsetCategory resolution.
  --and ensuring that X being a Ring means that it
  --satisfies (Algebra X)
  form=form' => true
  form=$Category => nil
  form' is ["Join",:l] => and/[extendsCategoryForm(domain,form,x) for x in l]
  form' is ["CATEGORY",.,:l] =>
    and/[extendsCategoryForm(domain,form,x) for x in l]
  form' is ["SubsetCategory",cat,dom] =>
    extendsCategoryForm(domain,form,cat) and isSubset(domain,dom,$e)
  form is ["Join",:l] => or/[extendsCategoryForm(domain,x,form') for x in l]
  form is ["CATEGORY",.,:l] =>
    MEMBER(form',l) or
      stackWarning ["not known that ",form'," is of mode ",form] or true
  isCategoryForm(form,$EmptyEnvironment) =>
          --Constructs the associated vector
    formVec:=(compMakeCategoryObject(form,$e)).expr
            --Must be $e to pick up locally bound domains
    form' is ["SIGNATURE",op,args,:.] =>
        ASSOC([op,args],formVec.(1)) or
            ASSOC(SUBSTQ(domain,"$",[op,args]),
                  SUBSTQ(domain,"$",formVec.(1)))
    form' is ["ATTRIBUTE",at] =>
         ASSOC(at,formVec.2) or
            ASSOC(SUBSTQ(domain,"$",at),SUBSTQ(domain,"$",formVec.2))
    form' is ["IF",:.] => true --temporary hack so comp won't fail
    -- Are we dealing with an Aldor category?  If so use the "has" function
    # formVec = 1 => newHasTest(form,form')
    catvlist:= formVec.4
    MEMBER(form',first catvlist) or
     MEMBER(form',SUBSTQ(domain,"$",first catvlist)) or
      (or/
        [extendsCategoryForm(domain,SUBSTQ(domain,"$",cat),form')
          for [cat,:.] in CADR catvlist])
  nil
 
getmode(x,e) ==
  prop:=getProplist(x,e)
  u:= LASSQ("value",prop) => u.mode
  LASSQ("mode",prop)
 
getmodeOrMapping(x,e) ==
  u:= getmode(x,e) => u
  (u:= get(x,"modemap",e)) is [[[.,:map],.],:.] => ["Mapping",:map]
  nil
 
outerProduct l ==
                --of a list of lists
  null l => LIST nil
  "append"/[[[x,:y] for y in outerProduct rest l] for x in first l]
 
sublisR(al,u) ==
  atom u => u
  y:= RASSOC(t:= [sublisR(al,x) for x in u],al) => y
  true => t
 
substituteOp(op',op,x) ==
  atom x => x
  [(op=(f:= first x) => op'; f),:[substituteOp(op',op,y) for y in rest x]]
 
--substituteForFormalArguments(argl,expr) ==
--  SUBLIS([[v,:a] for a in argl for v in $FormalMapVariableList],expr)
 
 -- following is only intended for substituting in domains slots 1 and 4
 -- signatures and categories
sublisV(p,e) ==
  (atom p => e; suba(p,e)) where
    suba(p,e) ==
      STRINGP e => e
      -- no need to descend vectors unless they are categories
      --REFVECP e => LIST2REFVEC [suba(p,e.i) for i in 0..MAXINDEX e]
      isCategory e => LIST2REFVEC [suba(p,e.i) for i in 0..MAXINDEX e]
      atom e => (y:= ASSQ(e,p) => rest y; e)
      u:= suba(p,QCAR e)
      v:= suba(p,QCDR e)
      EQ(QCAR e,u) and EQ(QCDR e,v) => e
      [u,:v]
 
--% DEBUGGING PRINT ROUTINES used in breaks
 
_?MODEMAPS x == _?modemaps x
_?modemaps x ==
  env:=
    $insideCapsuleFunctionIfTrue=true => $CapsuleModemapFrame
    $f
  x="all" => displayModemaps env
  -- displayOpModemaps(x,old2NewModemaps get(x,"modemap",env))
  displayOpModemaps(x,get(x,"modemap",env))


old2NewModemaps x ==
--  [[dcSig,pred] for [dcSig,[pred,:.],:.] in x]
  x is [dcSig,[pred,:.],:.]  =>  [dcSig,pred]
  x

traceUp() ==
  atom $x => sayBrightly "$x is an atom"
  for y in rest $x repeat
    u:= comp(y,$EmptyMode,$f) =>
      sayBrightly [y,'" ==> mode",'%b,u.mode,'%d]
    sayBrightly [y,'" does not compile"]
 
_?M x == _?m x
_?m x ==
  u:= comp(x,$EmptyMode,$f) => u.mode
  nil
 
traceDown() ==
  mmList:= getFormModemaps($x,$f) =>
    for mm in mmList repeat if u:= qModemap mm then return u
  sayBrightly "no modemaps for $x"
 
qModemap mm ==
  sayBrightly ['%b,"modemap",'%d,:formatModemap mm]
  [[dc,target,:sl],[pred,:.]]:= mm
  and/[qArg(a,m) for a in rest $x for m in sl] => target
  sayBrightly ['%b,"fails",'%d,'%l]
 
qArg(a,m) ==
  yesOrNo:=
    u:= comp(a,m,$f) => "yes"
    "no"
  sayBrightly [a," --> ",m,'%b,yesOrNo,'%d]
  yesOrNo="yes"
 
_?COMP x == _?comp x
_?comp x ==
  msg:=
    u:= comp(x,$EmptyMode,$f) =>
      [MAKESTRING "compiles to mode",'%b,u.mode,'%d]
    nil
  sayBrightly msg
 
_?domains() == pp getDomainsInScope $f
_?DOMAINS() == ?domains()
 
_?mode x == displayProplist(x,[["mode",:getmode(x,$f)]])
_?MODE x == _?mode x
 
_?properties x == displayProplist(x,getProplist(x,$f))
_?PROPERTIES x == _?properties x
 
_?value x == displayProplist(x,[["value",:get(x,"value",$f)]])
_?VALUE x == _?value x
 
displayProplist(x,alist) ==
  sayBrightly ["properties of",'%b,x,'%d,":"]
  fn alist where
    fn alist ==
      alist is [[prop,:val],:l] =>
        if prop="value" then val:= [val.expr,val.mode,'"..."]
        sayBrightly ["   ",'%b,prop,'%d,": ",val]
        fn deleteAssoc(prop,l)
 
displayModemaps E ==
  listOfOperatorsSeenSoFar:= nil
  for x in E for i in 1.. repeat
    for y in x for j in 1.. repeat
      for z in y | null MEMBER(first z,listOfOperatorsSeenSoFar) and
        (modemaps:= LASSOC("modemap",rest z)) repeat
          listOfOperatorsSeenSoFar:= [first z,:listOfOperatorsSeenSoFar]
          displayOpModemaps(first z,modemaps)
 
--% General object traversal functions
 
GEQSUBSTLIST(old, new, body) ==
    GEQNSUBSTLIST(old, new, GCOPY body)
 
GEQNSUBSTLIST(old, new, body) ==
    or/[:[EQ(o,n) for o in old] for n in new] =>
        mid := [GENSYM() for o in old]
        GEQNSUBSTLIST(old, mid, body)
        GEQNSUBSTLIST(mid, new, body)
    alist := [[o,:n] for o in old for n in new]
    traverse(function GSUBSTinner, alist, body) where
        GSUBSTinner(alist, ob) ==
            (pr := ASSQ(ob, alist)) => CDR pr
            ob
 
GCOPY ob == COPY ob  -- for now
 
traverse(fn, arg, ob) ==
    $seen:    local := MAKE_-HASHTABLE 'EQ
    $notseen: local := GENSYM()
 
    traverseInner(ob, fn, arg) where
        traverseInner(ob, fn, arg) ==
            e := HGET($seen, ob, $notseen)
            not EQ(e, $notseen) => e
 
            nob := FUNCALL(fn, arg, ob)
            HPUT($seen, ob, nob)
            not EQ(nob, ob) => nob
            PAIRP ob =>
                ne:=traverseInner(QCAR ob, fn, arg)
                if not EQ(ne,QCAR ob) then QRPLACA(ob, ne)
                ne:=traverseInner(QCDR ob, fn, arg)
                if not EQ(ne,QCDR ob) then QRPLACD(ob, ne)
                ob
            VECP ob =>
                n := QVMAXINDEX ob
                for i in 0..n repeat
                    e:=QVELT(ob,i)
                    ne:=traverseInner(e, fn, arg)
                    if not EQ(ne,e) then QSETVELT(ob,i,ne)
                ob
            HASHTABLEP ob =>
                keys := HKEYS ob
                for k in keys repeat
                    e  := HGET(ob, k)
                    nk := traverseInner(k, fn, arg)
                    ne := traverseInner(e, fn, arg)
                    if not EQ(k,nk) or not EQ(e,ne) then
                        HREM(ob, k)
                        HPUT(ob, nk, ne)
                ob
            PAPPP ob =>
                for i in 1..PA_-SPEC_-COUNT ob repeat
                    s := PA_-SPEC(ob, i)
                    not PAIRP s =>
                        ns := traverseInner(s,fn,arg)
                        if not EQ(s,ns) then
                            SET_-PA_-SPEC(ob,i,ns)
                    ns := traverseInner(QCDR s, fn, arg)
                    if not EQ(ns,QCDR s) then
                       apply(SET_-PA_-SPEC, [ob,i,QCAR s,:ns])
                ob
            ob
@
\section{c-util.clisp}
<<c-util.clisp>>=

(IN-PACKAGE "BOOT" )

;
;--% Debugging Functions
;
;CONTINUE() == continue()

;;;     ***       CONTINUE REDEFINED

(DEFUN CONTINUE NIL (|continue|)) 
;continue() == FIN comp($x,$m,$f)

;;;     ***       |continue| REDEFINED

(DEFUN |continue| NIL (FIN (|comp| |$x| |$m| |$f|))) 
;
;LEVEL(:l) == APPLY('level,l)

;;;     ***       LEVEL REDEFINED

(DEFUN LEVEL (&REST #0=#:G2489 &AUX |l|)
 (DSETQ |l| #0#) (APPLY (QUOTE |level|) |l|)) 
;level(:l) ==
;  null l => same()
;  l is [n] and INTEGERP n => displayComp ($level:= n)
;  SAY '"Correct format: (level n) where n is the level you want to go to"

;;;     ***       |level| REDEFINED

(DEFUN |level| (&REST #0=#:G2496 &AUX |l|)
 (DSETQ |l| #0#)
 (PROG (|n|)
  (RETURN
   (COND
    ((NULL |l|) (|same|))
    ((AND
       (PAIRP |l|)
       (EQ (QCDR |l|) NIL)
       (PROGN (SPADLET |n| (QCAR |l|)) (QUOTE T))
       (INTEGERP |n|))
      (|displayComp| (SPADLET |$level| |n|)))
    ((QUOTE T)
      (SAY
       (MAKESTRING 
         "Correct format: (level n) where n is the level you want to go to"
           ))))))) 
;
;UP() == up()

;;;     ***       UP REDEFINED

(DEFUN UP NIL (|up|)) 
;up() == displayComp ($level:= $level-1)

;;;     ***       |up| REDEFINED

(DEFUN |up| NIL
 (|displayComp| (SPADLET |$level| (SPADDIFFERENCE |$level| 1)))) 
;
;SAME() == same()

;;;     ***       SAME REDEFINED

(DEFUN SAME NIL (|same|)) 
;same() == displayComp $level

;;;     ***       |same| REDEFINED

(DEFUN |same| NIL (|displayComp| |$level|)) 
;
;DOWN() == down()

;;;     ***       DOWN REDEFINED

(DEFUN DOWN NIL (|down|)) 
;down() == displayComp ($level:= $level+1)

;;;     ***       |down| REDEFINED

(DEFUN |down| NIL (|displayComp| (SPADLET |$level| (PLUS |$level| 1)))) 
;
;displaySemanticErrors() ==
;  n:= #($semanticErrorStack:= REMDUP $semanticErrorStack)
;  n=0 => nil
;  l:= NREVERSE $semanticErrorStack
;  $semanticErrorStack:= nil
;  sayBrightly bright '"  Semantic Errors:"
;  displaySemanticError(l,CUROUTSTREAM)
;  sayBrightly '" "
;  displayWarnings()

;;;     ***       |displaySemanticErrors| REDEFINED

(DEFUN |displaySemanticErrors| NIL
 (PROG (|n| |l|)
  (RETURN
   (PROGN
    (SPADLET |n|
     (|#| (SPADLET |$semanticErrorStack| (REMDUP |$semanticErrorStack|))))
    (COND 
     ((EQL |n| 0) NIL)
     ((QUOTE T)
       (SPADLET |l| (NREVERSE |$semanticErrorStack|))
       (SPADLET |$semanticErrorStack| NIL)
       (|sayBrightly| (|bright| (MAKESTRING "  Semantic Errors:")))
       (|displaySemanticError| |l| CUROUTSTREAM)
       (|sayBrightly| (MAKESTRING " "))
       (|displayWarnings|))))))) 
;
;displaySemanticError(l,stream) ==
;  for x in l for i in 1.. repeat
;    sayBrightly(['"      [",i,'"] ",:first x],stream)

;;;     ***       |displaySemanticError| REDEFINED

(DEFUN |displaySemanticError| (|l| |stream|)
 (SEQ
  (DO ((#0=#:G2529 |l| (CDR #0#)) (|x| NIL) (|i| 1 (QSADD1 |i|)))
      ((OR (ATOM #0#) (PROGN (SETQ |x| (CAR #0#)) NIL)) NIL)
   (SEQ
    (EXIT
     (|sayBrightly|
      (CONS
       (MAKESTRING "      [")
       (CONS |i| (CONS (MAKESTRING "] ") (CAR |x|))))
      |stream|)))))) 
;
;displayWarnings() ==
;  n:= #($warningStack:= REMDUP $warningStack)
;  n=0 => nil
;  sayBrightly bright '"  Warnings:"
;  l := NREVERSE $warningStack
;  displayWarning(l,CUROUTSTREAM)
;  $warningStack:= nil
;  sayBrightly '" "

;;;     ***       |displayWarnings| REDEFINED

(DEFUN |displayWarnings| NIL
 (PROG (|n| |l|)
  (RETURN
   (PROGN
    (SPADLET |n| (|#| (SPADLET |$warningStack| (REMDUP |$warningStack|))))
    (COND
     ((EQL |n| 0) NIL)
     ((QUOTE T)
       (|sayBrightly| (|bright| (MAKESTRING "  Warnings:")))
       (SPADLET |l| (NREVERSE |$warningStack|))
       (|displayWarning| |l| CUROUTSTREAM)
       (SPADLET |$warningStack| NIL)
       (|sayBrightly| (MAKESTRING " ")))))))) 
;
;displayWarning(l,stream) ==
;  for x in l for i in 1.. repeat
;    sayBrightly(['"      [",i,'"] ",:x],stream)

;;;     ***       |displayWarning| REDEFINED

(DEFUN |displayWarning| (|l| |stream|)
 (SEQ
  (DO ((#0=#:G2550 |l| (CDR #0#)) (|x| NIL) (|i| 1 (QSADD1 |i|)))
      ((OR (ATOM #0#) (PROGN (SETQ |x| (CAR #0#)) NIL)) NIL)
   (SEQ
    (EXIT
     (|sayBrightly|
      (CONS
       (MAKESTRING "      [")
       (CONS |i| (CONS (MAKESTRING "] ") |x|))) |stream|)))))) 
;
;displayComp level ==
;  $tripleCache:= nil
;  $bright:= " << "
;  $dim:= " >> "
;  if $insideCapsuleFunctionIfTrue=true then
;    sayBrightly ['"error in function",'%b,$op,'%d,'%l]
;  --mathprint removeZeroOne mkErrorExpr level
;  pp removeZeroOne mkErrorExpr level
;  sayBrightly ['"****** level",'%b,level,'%d,'" ******"]
;  [$x,$m,$f,$exitModeStack]:= ELEM($s,level)
;  ($X:=$x;$M:=$m;$F:=$f)
;  SAY("$x:= ",$x)
;  SAY("$m:= ",$m)
;  SAY "$f:="
;  F_,PRINT_-ONE $f
;  nil

;;;     ***       |displayComp| REDEFINED

(DEFUN |displayComp| (|level|)
 (PROG (|LETTMP#1|)
  (RETURN
   (PROGN
    (SPADLET |$tripleCache| NIL)
    (SPADLET |$bright| (QUOTE | << |)) 
    (SPADLET |$dim| (QUOTE | >> |))
    (COND
     ((BOOT-EQUAL |$insideCapsuleFunctionIfTrue| (QUOTE T))
       (|sayBrightly|
        (CONS
         (MAKESTRING "error in function")
         (CONS
          (QUOTE |%b|)
          (CONS |$op| (CONS (QUOTE |%d|) (CONS (QUOTE |%l|) NIL))))))))
    (|pp| (|removeZeroOne| (|mkErrorExpr| |level|)))
    (|sayBrightly|
     (CONS
      (MAKESTRING "****** level")
      (CONS
       (QUOTE |%b|)
       (CONS |level| (CONS (QUOTE |%d|) (CONS (MAKESTRING " ******") NIL))))))
    (SPADLET |LETTMP#1| (ELEM |$s| |level|))
    (SPADLET |$x| (CAR |LETTMP#1|))
    (SPADLET |$m| (CADR |LETTMP#1|))
    (SPADLET |$f| (CADDR |LETTMP#1|))
    (SPADLET |$exitModeStack| (CADDDR |LETTMP#1|))
    (SPADLET $X |$x|)
    (SPADLET $M |$m|)
    (SPADLET $F |$f|)
    (SAY (MAKESTRING "$x:= ") |$x|)
    (SAY (MAKESTRING "$m:= ") |$m|)
    (SAY (MAKESTRING "$f:="))
    (|F,PRINT-ONE| |$f|)
     NIL)))) 
;
;mkErrorExpr level ==
;  bracket ASSOCLEFT DROP(level-#$s,$s) where
;    bracket l ==
;      #l<2 => l
;      l is [a,b] =>
;        highlight(b,a) where
;          highlight(b,a) ==
;            atom b =>
;              substitute(var,b,a) where
;                var:= INTERN STRCONC(STRINGIMAGE $bright,_
;                                     STRINGIMAGE b,STRINGIMAGE $dim)
;            highlight1(b,a) where
;              highlight1(b,a) ==
;                atom a => a
;                a is [ =b,:c] => [$bright,b,$dim,:c]
;                [highlight1(b,first a),:highlight1(b,rest a)]
;      substitute(bracket rest l,first rest l,first l)

;;;     ***       |mkErrorExpr,highlight1| REDEFINED

(DEFUN |mkErrorExpr,highlight1| (|b| |a|)
 (PROG (|c|)
  (RETURN
   (SEQ
    (IF (ATOM |a|) (EXIT |a|))
    (IF
      (AND
       (PAIRP |a|)
       (EQUAL (QCAR |a|) |b|)
       (PROGN (SPADLET |c| (QCDR |a|)) (QUOTE T)))
      (EXIT (CONS |$bright| (CONS |b| (CONS |$dim| |c|)))))
    (EXIT
     (CONS
      (|mkErrorExpr,highlight1| |b| (CAR |a|))
      (|mkErrorExpr,highlight1| |b| (CDR |a|)))))))) 

;;;     ***       |mkErrorExpr,highlight| REDEFINED

(DEFUN |mkErrorExpr,highlight| (|b| |a|)
 (PROG (|var|)
  (RETURN
   (SEQ
    (IF (ATOM |b|)
     (EXIT 
      (PROGN
       (SPADLET |var|
        (INTERN
         (STRCONC
           (STRINGIMAGE |$bright|) (STRINGIMAGE |b|) (STRINGIMAGE |$dim|))))
       (MSUBST |var| |b| |a|))))
    (EXIT (|mkErrorExpr,highlight1| |b| |a|)))))) 

;;;     ***       |mkErrorExpr,bracket| REDEFINED

(DEFUN |mkErrorExpr,bracket| (|l|)
 (PROG (|a| |ISTMP#1| |b|)
  (RETURN
   (SEQ
    (IF (QSLESSP (|#| |l|) 2) (EXIT |l|))
    (IF
     (AND
      (PAIRP |l|)
      (PROGN
       (SPADLET |a| (QCAR |l|))
       (SPADLET |ISTMP#1| (QCDR |l|))
       (AND
        (PAIRP |ISTMP#1|)
        (EQ (QCDR |ISTMP#1|) NIL)
        (PROGN (SPADLET |b| (QCAR |ISTMP#1|)) (QUOTE T)))))
      (EXIT (|mkErrorExpr,highlight| |b| |a|)))
    (EXIT
     (MSUBST (|mkErrorExpr,bracket| (CDR |l|)) (CAR (CDR |l|)) (CAR |l|))))))) 

;;;     ***       |mkErrorExpr| REDEFINED

(DEFUN |mkErrorExpr| (|level|)
 (|mkErrorExpr,bracket|
  (ASSOCLEFT (DROP (SPADDIFFERENCE |level| (|#| |$s|)) |$s|)))) 
;
;compAndTrace [x,m,e] ==
;  SAY("tracing comp, compFormWithModemap of: ",x)
;  TRACE_,1(["comp","compFormWithModemap"],nil)
;  T:= comp(x,m,e)
;  UNTRACE_,1 "comp"
;  UNTRACE_,1 "compFormWithModemap"
;  T

;;;     ***       |compAndTrace| REDEFINED

(DEFUN |compAndTrace| (#0=#:G2621)
 (PROG (|x| |m| |e| T$)
  (RETURN
   (PROGN
    (SPADLET |x| (CAR #0#))
    (SPADLET |m| (CADR #0#))
    (SPADLET |e| (CADDR #0#))
    (SAY (MAKESTRING "tracing comp, compFormWithModemap of: ") |x|)
    (|TRACE,1| 
     (CONS (QUOTE |comp|) (CONS (QUOTE |compFormWithModemap|) NIL)) NIL)
    (SPADLET T$ (|comp| |x| |m| |e|))
    (|UNTRACE,1|
     (QUOTE |comp|)) (|UNTRACE,1| (QUOTE |compFormWithModemap|)) T$)))) 
;
;errorRef s == stackWarning ['%b,s,'%d,'"has no value"]

;;;     ***       |errorRef| REDEFINED

(DEFUN |errorRef| (|s|)
 (|stackWarning|
  (CONS
   (QUOTE |%b|)
   (CONS |s| (CONS (QUOTE |%d|) (CONS (MAKESTRING "has no value") NIL)))))) 
;
;unErrorRef s == unStackWarning ['%b,s,'%d,'"has no value"]

;;;     ***       |unErrorRef| REDEFINED

(DEFUN |unErrorRef| (|s|)
 (|unStackWarning|
  (CONS
   (QUOTE |%b|)
   (CONS |s| (CONS (QUOTE |%d|) (CONS (MAKESTRING "has no value") NIL)))))) 
;
;--% ENVIRONMENT FUNCTIONS
;
;consProplistOf(var,proplist,prop,val) ==
;  semchkProplist(var,proplist,prop,val)
;  $InteractiveMode and (u:= ASSOC(prop,proplist)) =>
;    RPLACD(u,val)
;    proplist
;  [[prop,:val],:proplist]

;;;     ***       |consProplistOf| REDEFINED

(DEFUN |consProplistOf| (|var| |proplist| |prop| |val|)
 (PROG (|u|)
  (RETURN
   (PROGN
    (|semchkProplist| |var| |proplist| |prop| |val|)
    (COND
     ((AND |$InteractiveMode| (SPADLET |u| (|assoc| |prop| |proplist|)))
       (RPLACD |u| |val|) |proplist|)
     ((QUOTE T) (CONS (CONS |prop| |val|) |proplist|))))))) 
;
;warnLiteral x ==
;  stackSemanticError(['%b,x,'%d,
;    '"is BOTH a variable and a literal"],nil)

;;;     ***       |warnLiteral| REDEFINED

(DEFUN |warnLiteral| (|x|)
 (|stackSemanticError|
  (CONS
   (QUOTE |%b|)
   (CONS
    |x|
    (CONS
     (QUOTE |%d|)
     (CONS (MAKESTRING "is BOTH a variable and a literal") NIL)))) NIL)) 
;
;intersectionEnvironment(e,e') ==
;  ce:= makeCommonEnvironment(e,e')
;  ic:= intersectionContour(deltaContour(e,ce),deltaContour(e',ce))
;  e'':= (ic => addContour(ic,ce); ce)

;;;     ***       |intersectionEnvironment| REDEFINED

(DEFUN |intersectionEnvironment| (|e| |e'|)
 (PROG (|ce| |ic| |e''|)
  (RETURN
   (PROGN 
    (SPADLET |ce| (|makeCommonEnvironment| |e| |e'|))
    (SPADLET |ic| 
     (|intersectionContour|
      (|deltaContour| |e| |ce|)
      (|deltaContour| |e'| |ce|)))
    (SPADLET |e''|
     (COND (|ic| (|addContour| |ic| |ce|)) ((QUOTE T) |ce|))))))) 
;  --$ie:= e''   this line is for debugging purposes only
;
;deltaContour([[c,:cl],:el],[[c',:cl'],:el']) ==
;  ^el=el' => systemError '"deltaContour" --a cop out for now
;  eliminateDuplicatePropertyLists contourDifference(c,c') where
;    contourDifference(c,c') == [first x for x in tails c while (x^=c')]
;    eliminateDuplicatePropertyLists contour ==
;      contour is [[x,:.],:contour'] =>
;        LASSOC(x,contour') =>
;                               --save some CONSing if possible
;          [first contour,:DELLASOS(x,_
;                          eliminateDuplicatePropertyLists contour')]
;        [first contour,:eliminateDuplicatePropertyLists contour']
;      nil

;;;     ***       |deltaContour,eliminateDuplicatePropertyLists| REDEFINED

(DEFUN |deltaContour,eliminateDuplicatePropertyLists| (|contour|)
 (PROG (|ISTMP#1| |x| |contour'|)
  (RETURN
   (SEQ 
    (IF
     (AND
      (PAIRP |contour|)
      (PROGN
       (SPADLET |ISTMP#1| (QCAR |contour|))
       (AND
        (PAIRP |ISTMP#1|)
        (PROGN (SPADLET |x| (QCAR |ISTMP#1|)) (QUOTE T))))
      (PROGN (SPADLET |contour'| (QCDR |contour|)) (QUOTE T)))
     (EXIT
      (SEQ
       (IF (LASSOC |x| |contour'|)
        (EXIT 
         (CONS 
          (CAR |contour|)
          (DELLASOS |x| 
           (|deltaContour,eliminateDuplicatePropertyLists| |contour'|)))))
       (EXIT
        (CONS
         (CAR |contour|)
         (|deltaContour,eliminateDuplicatePropertyLists| |contour'|))))))
    (EXIT NIL))))) 

;;;     ***       |deltaContour,contourDifference| REDEFINED

(DEFUN |deltaContour,contourDifference| (|c| |c'|)
 (PROG NIL
  (RETURN
   (SEQ
    (PROG (#0=#:G2679)
     (SPADLET #0# NIL)
     (RETURN
      (DO ((|x| |c| (CDR |x|)))
          ((OR (ATOM |x|) (NULL (NEQUAL |x| |c'|))) (NREVERSE0 #0#))
       (SEQ (EXIT (SETQ #0# (CONS (CAR |x|) #0#))))))))))) 

;;;     ***       |deltaContour| REDEFINED

(DEFUN |deltaContour| (#0=#:G2695 #1=#:G2706)
 (PROG (|c'| |cl'| |el'| |c| |cl| |el|)
  (RETURN
   (PROGN
    (SPADLET |c'| (CAAR #1#))
    (SPADLET |cl'| (CDAR #1#))
    (SPADLET |el'| (CDR #1#))
    (SPADLET |c| (CAAR #0#))
    (SPADLET |cl| (CDAR #0#))
    (SPADLET |el| (CDR #0#))
    (COND
     ((NULL (BOOT-EQUAL |el| |el'|))
       (|systemError| (MAKESTRING "deltaContour")))
     ((QUOTE T)
       (|deltaContour,eliminateDuplicatePropertyLists|
         (|deltaContour,contourDifference| |c| |c'|)))))))) 
;
;intersectionContour(c,c') ==
;  $var: local := nil
;  computeIntersection(c,c') where
;    computeIntersection(c,c') ==
;      varlist:= REMDUP ASSOCLEFT c
;      varlist':= REMDUP ASSOCLEFT c'
;      interVars:= setIntersection(varlist,varlist')
;      unionVars:= setUnion(varlist,varlist')
;      diffVars:= setDifference(unionVars,interVars)
;      modeAssoc:= buildModeAssoc(diffVars,c,c')
;      [:modeAssoc,:
;        [[x,:proplist]
;          for [x,:y] in c | MEMBER(x,interVars) and
;            (proplist:= interProplist(y,LASSOC($var:= x,c')))]]
;    interProplist(p,p') ==
;                            --p is new proplist; p' is old one
;      [:modeCompare(p,p'),:[pair' for pair in p | (pair':= compare(pair,p'))]]
;    buildModeAssoc(varlist,c,c') ==
;      [[x,:mp] for x in varlist _
;         | (mp:= modeCompare(LASSOC(x,c),LASSOC(x,c')))]
;    compare(pair is [prop,:val],p') ==
;      --1. if the property-value pair are identical, accept it immediately
;      pair=(pair':= ASSOC(prop,p')) => pair
;      --2. if property="value" and modes are unifiable, give intersection
;      --       property="value" but value=genSomeVariable)()
;      (val':= KDR pair') and prop="value" and
;        (m:= unifiable(val.mode,val'.mode)) => _
;                     ["value",genSomeVariable(),m,nil]
;            --this tells us that an undeclared variable received
;            --two different values but with identical modes
;      --3. property="mode" is covered by modeCompare
;      prop="mode" => nil
;    modeCompare(p,p') ==
;      pair:= ASSOC("mode",p) =>
;        pair':= ASSOC("mode",p') =>
;          m'':= unifiable(rest pair,rest pair') => LIST ["mode",:m'']
;          stackSemanticError(['%b,$var,'%d,"has two modes: "],nil)
;       --stackWarning ("mode for",'%b,$var,'%d,"introduced conditionally")
;        LIST ["conditionalmode",:rest pair]
;        --LIST pair
;       --stackWarning ("mode for",'%b,$var,'%d,"introduced conditionally")
;      pair':= ASSOC("mode",p') => LIST ["conditionalmode",:rest pair']
;        --LIST pair'
;    unifiable(m1,m2) ==
;      m1=m2 => m1
;        --we may need to add code to coerce up to tagged unions
;        --but this can not be done here, but should be done by compIf
;      m:=
;        m1 is ["Union",:.] =>
;          m2 is ["Union",:.] => ["Union",:S_+(rest m1,rest m2)]
;          ["Union",:S_+(rest m1,[m2])]
;        m2 is ["Union",:.] => ["Union",:S_+(rest m2,[m1])]
;        ["Union",m1,m2]
;      for u in getDomainsInScope $e repeat
;        if u is ["Union",:u'] and (and/[MEMBER(v,u') for v in rest m]) then
;          return m

;;;     ***       |intersectionContour,unifiable| REDEFINED

(DEFUN |intersectionContour,unifiable| (|m1| |m2|)
 (PROG (|m| |u'|)
  (RETURN
   (SEQ
    (IF (BOOT-EQUAL |m1| |m2|) (EXIT |m1|))
    (SPADLET |m|
     (SEQ
      (IF (AND (PAIRP |m1|) (EQ (QCAR |m1|) (QUOTE |Union|)))
       (EXIT
        (SEQ
         (IF (AND (PAIRP |m2|) (EQ (QCAR |m2|) (QUOTE |Union|)))
          (EXIT
           (CONS (QUOTE |Union|) (S+ (CDR |m1|) (CDR |m2|)))))
         (EXIT (CONS (QUOTE |Union|) (S+ (CDR |m1|) (CONS |m2| NIL)))))))
      (IF (AND (PAIRP |m2|) (EQ (QCAR |m2|) (QUOTE |Union|)))
       (EXIT (CONS (QUOTE |Union|) (S+ (CDR |m2|) (CONS |m1| NIL)))))
      (EXIT (CONS (QUOTE |Union|) (CONS |m1| (CONS |m2| NIL))))))
    (EXIT
     (DO ((#0=#:G2748 (|getDomainsInScope| |$e|) (CDR #0#)) (|u| NIL))
         ((OR (ATOM #0#) (PROGN (SETQ |u| (CAR #0#)) NIL)) NIL)
      (SEQ
       (EXIT
        (IF
         (AND
          (AND
           (PAIRP |u|)
           (EQ (QCAR |u|) (QUOTE |Union|))
           (PROGN (SPADLET |u'| (QCDR |u|)) (QUOTE T)))
          (PROG (#1=#:G2754)
           (SPADLET #1# (QUOTE T))
           (RETURN
            (DO ((#2=#:G2760 NIL (NULL #1#))
                 (#3=#:G2761 (CDR |m|) (CDR #3#))
                 (|v| NIL))
                ((OR #2# (ATOM #3#) (PROGN (SETQ |v| (CAR #3#)) NIL))
                 #1#)
                 (SEQ (EXIT (SETQ #1# (AND #1# (|member| |v| |u'|)))))))))
          (RETURN |m|) NIL))))))))) 

;;;     ***       |intersectionContour,modeCompare| REDEFINED

(DEFUN |intersectionContour,modeCompare| (|p| |p'|)
 (PROG (|pair| |m''| |pair'|)
  (RETURN
   (SEQ
    (IF (SPADLET |pair| (|assoc| (QUOTE |mode|) |p|))
     (EXIT
      (SEQ
       (IF (SPADLET |pair'| (|assoc| (QUOTE |mode|) |p'|))
        (EXIT
         (SEQ
          (IF (SPADLET |m''| 
               (|intersectionContour,unifiable| (CDR |pair|) (CDR |pair'|)))
            (EXIT (LIST (CONS (QUOTE |mode|) |m''|))))
          (EXIT
           (|stackSemanticError|
            (CONS
             (QUOTE |%b|)
             (CONS 
              |$var| 
              (CONS 
               (QUOTE |%d|) 
               (CONS (QUOTE |has two modes: |) NIL)))) NIL)))))
       (EXIT (LIST (CONS (QUOTE |conditionalmode|) (CDR |pair|)))))))
    (EXIT 
     (IF (SPADLET |pair'| (|assoc| (QUOTE |mode|) |p'|))
       (EXIT (LIST (CONS (QUOTE |conditionalmode|) (CDR |pair'|)))))))))) 

;;;     ***       |intersectionContour,compare| REDEFINED

(DEFUN |intersectionContour,compare| (|pair| |p'|)
 (PROG (|prop| |val| |pair'| |val'| |m|)
  (RETURN
   (SEQ
    (PROGN
     (SPADLET |prop| (CAR |pair|))
     (SPADLET |val| (CDR |pair|))
     |pair|
     (SEQ
      (IF (BOOT-EQUAL |pair| (SPADLET |pair'| (|assoc| |prop| |p'|)))
        (EXIT |pair|))
      (IF
        (AND 
         (AND 
          (SPADLET |val'| (KDR |pair'|))
          (BOOT-EQUAL |prop| (QUOTE |value|)))
         (SPADLET |m|
          (|intersectionContour,unifiable| (CADR |val|) (CADR |val'|))))
        (EXIT
         (CONS
          (QUOTE |value|)
          (CONS (|genSomeVariable|) (CONS |m| (CONS NIL NIL))))))
      (EXIT (IF (BOOT-EQUAL |prop| (QUOTE |mode|)) (EXIT NIL))))))))) 

;;;     ***       |intersectionContour,buildModeAssoc| REDEFINED

(DEFUN |intersectionContour,buildModeAssoc| (|varlist| |c| |c'|) 
 (PROG (|mp|) 
  (RETURN 
   (SEQ 
    (PROG (#0=#:G2802) 
     (SPADLET #0# NIL)
     (RETURN 
      (DO ((#1=#:G2808 |varlist| (CDR #1#)) (|x| NIL))
          ((OR (ATOM #1#) (PROGN (SETQ |x| (CAR #1#)) NIL)) (NREVERSE0 #0#))
       (SEQ
        (EXIT
         (COND
          ((SPADLET |mp|
            (|intersectionContour,modeCompare|
              (LASSOC |x| |c|) (LASSOC |x| |c'|)))
            (SETQ #0# (CONS (CONS |x| |mp|) #0#))))))))))))) 

;;;     ***       |intersectionContour,interProplist| REDEFINED

(DEFUN |intersectionContour,interProplist| (|p| |p'|)
 (PROG (|pair'|)
  (RETURN
   (SEQ
    (APPEND
     (|intersectionContour,modeCompare| |p| |p'|)
     (PROG (#0=#:G2824)
      (SPADLET #0# NIL)
      (RETURN
       (DO ((#1=#:G2830 |p| (CDR #1#)) (|pair| NIL))
           ((OR (ATOM #1#) (PROGN (SETQ |pair| (CAR #1#)) NIL))
             (NREVERSE0 #0#))
        (SEQ
         (EXIT
          (COND
           ((SPADLET |pair'| (|intersectionContour,compare| |pair| |p'|))
             (SETQ #0# (CONS |pair'| #0#)))))))))))))) 

;;;     ***       |intersectionContour,computeIntersection| REDEFINED

(DEFUN |intersectionContour,computeIntersection| (|c| |c'|)
 (PROG (|varlist| |varlist'| |interVars| |unionVars| |diffVars| |modeAssoc|
        |x| |y| |proplist|)
  (RETURN
   (SEQ
    (SPADLET |varlist| (REMDUP (ASSOCLEFT |c|)))
    (SPADLET |varlist'| (REMDUP (ASSOCLEFT |c'|)))
    (SPADLET |interVars| (|intersection| |varlist| |varlist'|))
    (SPADLET |unionVars| (|union| |varlist| |varlist'|))
    (SPADLET |diffVars| (SETDIFFERENCE |unionVars| |interVars|))
    (SPADLET |modeAssoc|
     (|intersectionContour,buildModeAssoc| |diffVars| |c| |c'|))
    (EXIT
     (APPEND
       |modeAssoc| 
       (PROG (#0=#:G2847) 
        (SPADLET #0# NIL)
        (RETURN 
         (DO ((#1=#:G2854 |c| (CDR #1#)) (#2=#:G2731 NIL))
             ((OR
               (ATOM #1#)
               (PROGN (SETQ #2# (CAR #1#)) NIL)
               (PROGN
                (PROGN
                 (SPADLET |x| (CAR #2#))
                 (SPADLET |y| (CDR #2#))
                 #2#)
                 NIL))
              (NREVERSE0 #0#))
          (SEQ
           (EXIT
            (COND
             ((AND
               (|member| |x| |interVars|)
               (SPADLET |proplist|
                (|intersectionContour,interProplist|
                   |y| (LASSOC (SPADLET |$var| |x|) |c'|))))
               (SETQ #0# (CONS (CONS |x| |proplist|) #0#))))))))))))))) 

;;;     ***       |intersectionContour| REDEFINED

(DEFUN |intersectionContour| (|c| |c'|)
 (PROG (|$var|)
  (DECLARE (SPECIAL |$var|))
   (RETURN
    (PROGN
     (SPADLET |$var| NIL)
     (|intersectionContour,computeIntersection| |c| |c'|))))) 
;        --this loop will return NIL if not satisfied
;
;addContour(c,E is [cur,:tail]) ==
;  [NCONC(fn(c,E),cur),:tail] where
;    fn(c,e) ==
;        for [x,:proplist] in c repeat
;           fn1(x,proplist,getProplist(x,e)) where
;              fn1(x,p,ee) ==
;                for pv in p repeat fn3(x,pv,ee) where
;                 fn3(x,pv,e) ==
;                   [p,:v]:=pv;
;                   if MEMBER(x,$getPutTrace) then
;                     pp([x,"has",pv]);
;                   if p="conditionalmode" then
;                     RPLACA(pv,"mode");
;                     --check for conflicts with earlier mode
;                     if vv:=LASSOC("mode",e) then
;                        if v ^=vv then
;                          stackWarning ["The conditional modes ",
;                                     v," and ",vv," conflict"]
;        LIST c

;;;     ***       |addContour,fn3| REDEFINED

(DEFUN |addContour,fn3| (|x| |pv| |e|)
 (PROG (|p| |v| |vv|)
  (RETURN
   (SEQ
    (PROGN (SPADLET |p| (CAR |pv|)) (SPADLET |v| (CDR |pv|)) |pv|)
    (IF (|member| |x| |$getPutTrace|)
      (|pp| (CONS |x| (CONS (QUOTE |has|) (CONS |pv| NIL)))) NIL)
    (EXIT
     (IF (BOOT-EQUAL |p| (QUOTE |conditionalmode|))
      (SEQ
       (RPLACA |pv| (QUOTE |mode|))
       (EXIT
        (IF
         (SPADLET |vv| (LASSOC (QUOTE |mode|) |e|))
         (IF (NEQUAL |v| |vv|)
          (|stackWarning| 
           (CONS 
            (QUOTE |The conditional modes |)
            (CONS 
             |v| 
             (CONS 
              (QUOTE | and |)
              (CONS |vv| (CONS (QUOTE | conflict|) NIL))))))
          NIL)
         NIL)))
      NIL)))))) 

;;;     ***       |addContour,fn1| REDEFINED

(DEFUN |addContour,fn1| (|x| |p| |ee|)
 (SEQ
  (DO ((#0=#:G2898 |p| (CDR #0#)) (|pv| NIL))
      ((OR (ATOM #0#) (PROGN (SETQ |pv| (CAR #0#)) NIL)) NIL)
   (SEQ (EXIT (|addContour,fn3| |x| |pv| |ee|)))))) 

;;;     ***       |addContour,fn| REDEFINED

(DEFUN |addContour,fn| (|c| |e|)
 (PROG (|x| |proplist|)
  (RETURN
   (SEQ
    (DO ((#0=#:G2917 |c| (CDR #0#)) (#1=#:G2908 NIL))
        ((OR
          (ATOM #0#)
          (PROGN (SETQ #1# (CAR #0#)) NIL)
          (PROGN
           (PROGN (SPADLET |x| (CAR #1#)) (SPADLET |proplist| (CDR #1#)) #1#)
           NIL))
          NIL)
     (SEQ
      (EXIT
       (|addContour,fn1| |x| |proplist| (|getProplist| |x| |e|)))))
    (EXIT (LIST |c|)))))) 

;;;     ***       |addContour| REDEFINED

(DEFUN |addContour| (|c| E)
 (PROG (|cur| |tail|)
  (RETURN
   (PROGN
    (SPADLET |cur| (CAR E))
    (SPADLET |tail| (CDR E))
    (CONS (NCONC (|addContour,fn| |c| E) |cur|) |tail|))))) 
;
;makeCommonEnvironment(e,e') ==
;  interE makeSameLength(e,e') where  --$ie:=
;    interE [e,e'] ==
;      rest e=rest e' => [interLocalE makeSameLength(first e,first e'),:rest e]
;      interE [rest e,rest e']
;    interLocalE [le,le'] ==
;      rest le=rest le' =>
;        [interC makeSameLength(first le,first le'),:rest le]
;      interLocalE [rest le,rest le']
;    interC [c,c'] ==
;      c=c' => c
;      interC [rest c,rest c']
;    makeSameLength(x,y) ==
;      fn(x,y,#x,#y) where
;        fn(x,y,nx,ny) ==
;          nx>ny => fn(rest x,y,nx-1,ny)
;          nx<ny => fn(x,rest y,nx,ny-1)
;          [x,y]

;;;     ***       |makeCommonEnvironment,fn| REDEFINED

(DEFUN |makeCommonEnvironment,fn| (|x| |y| |nx| |ny|)
 (SEQ
  (IF (> |nx| |ny|)
   (EXIT
    (|makeCommonEnvironment,fn| (CDR |x|) |y| (SPADDIFFERENCE |nx| 1) |ny|)))
  (IF (> |ny| |nx|)
   (EXIT
    (|makeCommonEnvironment,fn| |x| (CDR |y|) |nx| (SPADDIFFERENCE |ny| 1))))
  (EXIT (CONS |x| (CONS |y| NIL))))) 

;;;     ***       |makeCommonEnvironment,makeSameLength| REDEFINED

(DEFUN |makeCommonEnvironment,makeSameLength| (|x| |y|)
 (|makeCommonEnvironment,fn| |x| |y| (|#| |x|) (|#| |y|))) 

;;;     ***       |makeCommonEnvironment,interC| REDEFINED

(DEFUN |makeCommonEnvironment,interC| (#0=#:G2954)
 (PROG (|c| |c'|)
  (RETURN
   (SEQ
    (PROGN
     (SPADLET |c| (CAR #0#))
     (SPADLET |c'| (CADR #0#))
     #0#
     (SEQ
      (IF (BOOT-EQUAL |c| |c'|) (EXIT |c|))
      (EXIT
       (|makeCommonEnvironment,interC|
        (CONS (CDR |c|) (CONS (CDR |c'|) NIL)))))))))) 

;;;     ***       |makeCommonEnvironment,interLocalE| REDEFINED

(DEFUN |makeCommonEnvironment,interLocalE| (#0=#:G2968)
 (PROG (|le| |le'|)
  (RETURN
   (SEQ
    (PROGN
     (SPADLET |le| (CAR #0#))
     (SPADLET |le'| (CADR #0#))
     #0#
     (SEQ
      (IF (BOOT-EQUAL (CDR |le|) (CDR |le'|))
       (EXIT
        (CONS
         (|makeCommonEnvironment,interC|
          (|makeCommonEnvironment,makeSameLength| (CAR |le|) (CAR |le'|)))
         (CDR |le|))))
      (EXIT
       (|makeCommonEnvironment,interLocalE|
        (CONS (CDR |le|) (CONS (CDR |le'|) NIL)))))))))) 

;;;     ***       |makeCommonEnvironment,interE| REDEFINED

(DEFUN |makeCommonEnvironment,interE| (#0=#:G2982)
 (PROG (|e| |e'|)
  (RETURN
   (SEQ
    (PROGN
     (SPADLET |e| (CAR #0#))
     (SPADLET |e'| (CADR #0#))
     #0#
     (SEQ
      (IF (BOOT-EQUAL (CDR |e|) (CDR |e'|))
       (EXIT
        (CONS
         (|makeCommonEnvironment,interLocalE|
          (|makeCommonEnvironment,makeSameLength| (CAR |e|) (CAR |e'|)))
         (CDR |e|))))
      (EXIT
       (|makeCommonEnvironment,interE|
        (CONS (CDR |e|) (CONS (CDR |e'|) NIL)))))))))) 

;;;     ***       |makeCommonEnvironment| REDEFINED

(DEFUN |makeCommonEnvironment| (|e| |e'|)
 (|makeCommonEnvironment,interE|
  (|makeCommonEnvironment,makeSameLength| |e| |e'|))) 
;
;printEnv E ==
;  for x in E for i in 1.. repeat
;    for y in x for j in 1.. repeat
;      SAY('"******CONTOUR ",j,'", LEVEL ",i,'":******")
;      for z in y repeat
;        TERPRI()
;        SAY("Properties Of: ",first z)
;        for u in rest z repeat
;          PRIN0 first u
;          printString ": "
;          PRETTYPRINT tran(rest u,first u) where
;            tran(val,prop) ==
;              prop="value" => DROP(-1,val)
;              val

;;;     ***       |printEnv,tran| REDEFINED

(DEFUN |printEnv,tran| (|val| |prop|)
 (SEQ
  (IF (BOOT-EQUAL |prop| (QUOTE |value|))
    (EXIT (DROP (SPADDIFFERENCE 1) |val|)))
  (EXIT |val|))) 

;;;     ***       |printEnv| REDEFINED

(DEFUN |printEnv| (E)
 (SEQ
  (DO ((#0=#:G3020 E (CDR #0#)) (|x| NIL) (|i| 1 (QSADD1 |i|)))
      ((OR (ATOM #0#) (PROGN (SETQ |x| (CAR #0#)) NIL)) NIL)
   (SEQ
    (EXIT
     (DO ((#1=#:G3038 |x| (CDR #1#)) (|y| NIL) (|j| 1 (QSADD1 |j|)))
         ((OR (ATOM #1#) (PROGN (SETQ |y| (CAR #1#)) NIL)) NIL)
      (SEQ
       (EXIT
        (PROGN
         (SAY
           (MAKESTRING "******CONTOUR ") |j|
           (MAKESTRING ", LEVEL ") |i| (MAKESTRING ":******"))
         (DO ((#2=#:G3053 |y| (CDR #2#)) (|z| NIL))
             ((OR (ATOM #2#) (PROGN (SETQ |z| (CAR #2#)) NIL)) NIL)
          (SEQ
           (EXIT
            (PROGN
             (TERPRI)
             (SAY (MAKESTRING "Properties Of: ") (CAR |z|))
             (DO ((#3=#:G3065 (CDR |z|) (CDR #3#)) (|u| NIL))
                 ((OR (ATOM #3#) (PROGN (SETQ |u| (CAR #3#)) NIL)) NIL)
              (SEQ
               (EXIT
                (PROGN
                 (PRIN0 (CAR |u|))
                 (|printString| (QUOTE |: |))
                 (PRETTYPRINT
                  (|printEnv,tran| (CDR |u|) (CAR |u|)))))))))))))))))))) 
;
;prEnv E ==
;  for x in E for i in 1.. repeat
;    for y in x for j in 1.. repeat
;      SAY('"******CONTOUR ",j,'", LEVEL ",i,'":******")
;      for z in y | not LASSOC("modemap",rest z) repeat
;        TERPRI()
;        SAY("Properties Of: ",first z)
;        for u in rest z repeat
;          PRIN0 first u
;          printString ": "
;          PRETTYPRINT tran(rest u,first u) where
;            tran(val,prop) ==
;              prop="value" => DROP(-1,val)
;              val

;;;     ***       |prEnv,tran| REDEFINED

(DEFUN |prEnv,tran| (|val| |prop|)
 (SEQ
  (IF (BOOT-EQUAL |prop| (QUOTE |value|))
   (EXIT (DROP (SPADDIFFERENCE 1) |val|))) (EXIT |val|))) 

;;;     ***       |prEnv| REDEFINED

(DEFUN |prEnv| (E)
 (SEQ
  (DO ((#0=#:G3094 E (CDR #0#)) (|x| NIL) (|i| 1 (QSADD1 |i|)))
      ((OR (ATOM #0#) (PROGN (SETQ |x| (CAR #0#)) NIL)) NIL)
   (SEQ
    (EXIT
     (DO ((#1=#:G3112 |x| (CDR #1#)) (|y| NIL) (|j| 1 (QSADD1 |j|)))
         ((OR (ATOM #1#) (PROGN (SETQ |y| (CAR #1#)) NIL)) NIL)
      (SEQ
       (EXIT
        (PROGN
         (SAY (MAKESTRING "******CONTOUR ") |j| 
              (MAKESTRING ", LEVEL ") |i| (MAKESTRING ":******"))
         (DO ((#2=#:G3128 |y| (CDR #2#)) (|z| NIL))
             ((OR (ATOM #2#) (PROGN (SETQ |z| (CAR #2#)) NIL)) NIL)
          (SEQ
           (EXIT
            (COND
             ((NULL (LASSOC (QUOTE |modemap|) (CDR |z|)))
               (PROGN 
                (TERPRI)
                (SAY (MAKESTRING "Properties Of: ") (CAR |z|))
                (DO ((#3=#:G3140 (CDR |z|) (CDR #3#)) (|u| NIL))
                    ((OR (ATOM #3#) (PROGN (SETQ |u| (CAR #3#)) NIL)) NIL)
                 (SEQ
                  (EXIT
                   (PROGN 
                    (PRIN0 (CAR |u|))
                    (|printString| (QUOTE |: |))
                    (PRETTYPRINT 
                     (|prEnv,tran| (CDR |u|) (CAR |u|)))))))))))))))))))))) 
;
;prModemaps E ==
;  listOfOperatorsSeenSoFar:= nil
;  for x in E for i in 1.. repeat
;    for y in x for j in 1.. repeat
;      for z in y | null MEMBER(first z,listOfOperatorsSeenSoFar) and
;        (modemap:= LASSOC("modemap",rest z)) repeat
;          listOfOperatorsSeenSoFar:= [first z,:listOfOperatorsSeenSoFar]
;          TERPRI()
;          PRIN0 first z
;          printString ": "
;          PRETTYPRINT modemap

;;;     ***       |prModemaps| REDEFINED

(DEFUN |prModemaps| (E) 
 (PROG (|modemap| |listOfOperatorsSeenSoFar|)
  (RETURN
   (SEQ
    (PROGN
     (SPADLET |listOfOperatorsSeenSoFar| NIL)
     (DO ((#0=#:G3160 E (CDR #0#)) (|x| NIL) (|i| 1 (QSADD1 |i|)))
         ((OR (ATOM #0#) (PROGN (SETQ |x| (CAR #0#)) NIL)) NIL)
      (SEQ
       (EXIT
        (DO ((#1=#:G3175 |x| (CDR #1#)) (|y| NIL) (|j| 1 (QSADD1 |j|)))
            ((OR (ATOM #1#) (PROGN (SETQ |y| (CAR #1#)) NIL)) NIL)
         (SEQ
          (EXIT
           (DO ((#2=#:G3190 |y| (CDR #2#)) (|z| NIL))
               ((OR (ATOM #2#) (PROGN (SETQ |z| (CAR #2#)) NIL)) NIL)
            (SEQ
             (EXIT
              (COND
               ((AND
                 (NULL (|member| (CAR |z|) |listOfOperatorsSeenSoFar|))
                 (SPADLET |modemap| (LASSOC (QUOTE |modemap|) (CDR |z|))))
                 (PROGN 
                  (SPADLET |listOfOperatorsSeenSoFar|
                   (CONS (CAR |z|) |listOfOperatorsSeenSoFar|))
                  (TERPRI)
                  (PRIN0 (CAR |z|))
                  (|printString| (QUOTE |: |))
                  (PRETTYPRINT |modemap|)))))))))))))))))) 
;
;prTriple T ==
;   SAY '"Code:"
;   pp T.0
;   SAY '"Mode:"
;   pp T.1

;;;     ***       |prTriple| REDEFINED

(DEFUN |prTriple| (T$)
 (PROGN 
  (SAY (MAKESTRING "Code:"))
  (|pp| (ELT T$ 0))
  (SAY (MAKESTRING "Mode:"))
  (|pp| (ELT T$ 1)))) 
;
;TrimCF() ==
;  new:= nil
;  old:= CAAR $CategoryFrame
;  for u in old repeat
;    if not ASSQ(first u,new) then
;      uold:= rest u
;      unew:= nil
;      for v in uold repeat if not ASSQ(first v,unew) then unew:= [v,:unew]
;      new:= [[first u,:NREVERSE unew],:new]
;  $CategoryFrame:= [[NREVERSE new]]
;  nil

;;;     ***       |TrimCF| REDEFINED

(DEFUN |TrimCF| NIL
 (PROG (|old| |uold| |unew| |new|)
  (RETURN
   (SEQ 
    (PROGN
     (SPADLET |new| NIL)
     (SPADLET |old| (CAAR |$CategoryFrame|))
     (DO ((#0=#:G3211 |old| (CDR #0#)) (|u| NIL))
         ((OR (ATOM #0#) (PROGN (SETQ |u| (CAR #0#)) NIL)) NIL)
      (SEQ
       (EXIT
        (COND
         ((NULL (ASSQ (CAR |u|) |new|))
           (SPADLET |uold| (CDR |u|))
           (SPADLET |unew| NIL)
           (DO ((#1=#:G3220 |uold| (CDR #1#)) (|v| NIL))
               ((OR (ATOM #1#) (PROGN (SETQ |v| (CAR #1#)) NIL)) NIL)
            (SEQ
             (EXIT
              (COND
               ((NULL (ASSQ (CAR |v|) |unew|))
                 (SPADLET |unew| (CONS |v| |unew|)))
               ((QUOTE T) NIL)))))
           (SPADLET |new| (CONS (CONS (CAR |u|) (NREVERSE |unew|)) |new|)))
         ((QUOTE T) NIL)))))
     (SPADLET |$CategoryFrame|
      (CONS (CONS (NREVERSE |new|) NIL) NIL)) NIL))))) 
;
;
;--% PREDICATES
;
;
;isConstantId(name,e) ==
;  IDENTP name =>
;    pl:= getProplist(name,e) =>
;      (LASSOC("value",pl) or LASSOC("mode",pl) => false; true)
;    true
;  false

;;;     ***       |isConstantId| REDEFINED

(DEFUN |isConstantId| (|name| |e|)
 (PROG (|pl|)
  (RETURN
   (COND
    ((IDENTP |name|)
      (COND
       ((SPADLET |pl| (|getProplist| |name| |e|))
         (COND 
          ((OR (LASSOC (QUOTE |value|) |pl|)
               (LASSOC (QUOTE |mode|) |pl|)) NIL)
          ((QUOTE T) (QUOTE T))))
       ((QUOTE T) (QUOTE T))))
    ((QUOTE T) NIL))))) 
;
;isFalse() == nil

;;;     ***       |isFalse| REDEFINED

(DEFUN |isFalse| NIL NIL) 
;
;isFluid s == atom s and "$"=(PNAME s).(0)

;;;     ***       |isFluid| REDEFINED

(DEFUN |isFluid| (|s|)
 (AND (ATOM |s|) (BOOT-EQUAL (QUOTE $) (ELT (PNAME |s|) 0)))) 
;
;isFunction(x,e) ==
;  get(x,"modemap",e) or GET(x,"SPECIAL") or x="case" or getmode(x,e) is [
;    "Mapping",:.]

;;;     ***       |isFunction| REDEFINED

(DEFUN |isFunction| (|x| |e|)
 (PROG (|ISTMP#1|)
  (RETURN
   (OR
    (|get| |x| (QUOTE |modemap|) |e|)
    (GETL |x| (QUOTE SPECIAL))
    (BOOT-EQUAL |x| (QUOTE |case|))
    (PROGN
     (SPADLET |ISTMP#1| (|getmode| |x| |e|))
     (AND (PAIRP |ISTMP#1|) (EQ (QCAR |ISTMP#1|) (QUOTE |Mapping|)))))))) 
;
;isLiteral(x,e) == get(x,"isLiteral",e)

;;;     ***       |isLiteral| REDEFINED

(DEFUN |isLiteral| (|x| |e|) (|get| |x| (QUOTE |isLiteral|) |e|)) 
;
;makeLiteral(x,e) == put(x,"isLiteral","true",e)

;;;     ***       |makeLiteral| REDEFINED

(DEFUN |makeLiteral| (|x| |e|)
 (|put| |x| (QUOTE |isLiteral|) (QUOTE |true|) |e|)) 
;
;isSomeDomainVariable s ==
;  IDENTP s and #(x:= PNAME s)>2 and x.(0)="#" and x.(1)="#"

;;;     ***       |isSomeDomainVariable| REDEFINED

(DEFUN |isSomeDomainVariable| (|s|)
 (PROG (|x|)
  (RETURN
   (AND 
    (IDENTP |s|)
    (> (|#| (SPADLET |x| (PNAME |s|))) 2)
    (BOOT-EQUAL (ELT |x| 0) (QUOTE |#|))
    (BOOT-EQUAL (ELT |x| 1) (QUOTE |#|)))))) 
;
;isSubset(x,y,e) ==
;  x="$" and y="Rep" or x=y or
;    LASSOC(opOf x,get(opOf y,"Subsets",e) or GET(opOf y,"Subsets")) or
;      LASSOC(opOf x,get(opOf y,"SubDomain",e)) or
;        opOf(y)='Type or opOf(y)='Object

;;;     ***       |isSubset| REDEFINED

(DEFUN |isSubset| (|x| |y| |e|)
 (OR
  (AND (BOOT-EQUAL |x| (QUOTE $)) (BOOT-EQUAL |y| (QUOTE |Rep|)))
  (BOOT-EQUAL |x| |y|)
  (LASSOC 
   (|opOf| |x|)
   (OR 
    (|get| (|opOf| |y|) (QUOTE |Subsets|) |e|)
    (GETL (|opOf| |y|) (QUOTE |Subsets|))))
  (LASSOC (|opOf| |x|) (|get| (|opOf| |y|) (QUOTE |SubDomain|) |e|))
  (BOOT-EQUAL (|opOf| |y|) (QUOTE |Type|))
  (BOOT-EQUAL (|opOf| |y|) (QUOTE |Object|)))) 
;
;isDomainInScope(domain,e) ==
;  domainList:= getDomainsInScope e
;  atom domain =>
;    MEMQ(domain,domainList) => true
;    not IDENTP domain or isSomeDomainVariable domain => true
;    false
;  (name:= first domain)="Category" => true
;  ASSQ(name,domainList) => true
;--   null CDR domain or domainMember(domain,domainList) => true
;--   false
;  isFunctor name => false
;  true --is not a functor

;;;     ***       |isDomainInScope| REDEFINED

(DEFUN |isDomainInScope| (|domain| |e|)
 (PROG (|domainList| |name|)
  (RETURN
   (PROGN
    (SPADLET |domainList| (|getDomainsInScope| |e|))
    (COND
     ((ATOM |domain|)
       (COND 
        ((MEMQ |domain| |domainList|) (QUOTE T))
        ((OR (NULL (IDENTP |domain|)) (|isSomeDomainVariable| |domain|))
          (QUOTE T))
        ((QUOTE T) NIL)))
     ((BOOT-EQUAL (SPADLET |name| (CAR |domain|)) (QUOTE |Category|))
       (QUOTE T))
     ((ASSQ |name| |domainList|) (QUOTE T))
     ((|isFunctor| |name|) NIL)
     ((QUOTE T) (QUOTE T))))))) 
;
;isSymbol x == IDENTP x or x=nil

;;;     ***       |isSymbol| REDEFINED

(DEFUN |isSymbol| (|x|) (OR (IDENTP |x|) (NULL |x|))) 
;
;isSimple x ==
;  atom x or $InteractiveMode => true
;  x is [op,:argl] and
;    isSideEffectFree op and (and/[isSimple y for y in argl])

;;;     ***       |isSimple| REDEFINED

(DEFUN |isSimple| (|x|)
 (PROG (|op| |argl|)
  (RETURN
   (SEQ
    (COND
     ((OR (ATOM |x|) |$InteractiveMode|) (QUOTE T))
     ((QUOTE T)
       (AND
        (PAIRP |x|)
        (PROGN (SPADLET |op| (QCAR |x|)) (SPADLET |argl| (QCDR |x|)) (QUOTE T))
        (|isSideEffectFree| |op|)
        (PROG (#0=#:G3282)
         (SPADLET #0# (QUOTE T))
         (RETURN
          (DO ((#1=#:G3288 NIL (NULL #0#))
               (#2=#:G3289 |argl| (CDR #2#))
               (|y| NIL))
              ((OR #1# (ATOM #2#) (PROGN (SETQ |y| (CAR #2#)) NIL)) #0#)
           (SEQ (EXIT (SETQ #0# (AND #0# (|isSimple| |y|))))))))))))))) 
;
;isSideEffectFree op ==
;  MEMBER(op,$SideEffectFreeFunctionList) or op is ["elt",.,op'] and
;    isSideEffectFree op'

;;;     ***       |isSideEffectFree| REDEFINED

(DEFUN |isSideEffectFree| (|op|)
 (PROG (|ISTMP#1| |ISTMP#2| |op'|)
  (RETURN
   (OR
    (|member| |op| |$SideEffectFreeFunctionList|)
    (AND
     (PAIRP |op|)
     (EQ (QCAR |op|) (QUOTE |elt|))
     (PROGN
      (SPADLET |ISTMP#1| (QCDR |op|))
      (AND
       (PAIRP |ISTMP#1|)
       (PROGN
        (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
        (AND
         (PAIRP |ISTMP#2|)
         (EQ (QCDR |ISTMP#2|) NIL)
         (PROGN (SPADLET |op'| (QCAR |ISTMP#2|)) (QUOTE T))))))
     (|isSideEffectFree| |op'|)))))) 
;
;isAlmostSimple x ==
;  --returns (<new predicate> . <list of assignments>) or nil
;  $assignmentList: local --$assigmentList is only used in this function
;  transform:=
;    fn x where
;      fn x ==
;        atom x or null rest x => x
;        [op,y,:l]:= x
;        op="has" => x
;        op="is" => x
;        op="LET" =>
;          IDENTP y => (setAssignment LIST x; y)
;          true => _
;            (setAssignment [["LET",g:= genVariable(),:l],["LET",y,g]]; g)
;        isSideEffectFree op => [op,:mapInto(rest x,"fn")]
;        true => $assignmentList:= "failed"
;      setAssignment x ==
;        $assignmentList="failed" => nil
;        $assignmentList:= [:$assignmentList,:x]
;  $assignmentList="failed" => nil
;  wrapSEQExit [:$assignmentList,transform]

;;;     ***       |isAlmostSimple,setAssignment| REDEFINED

(DEFUN |isAlmostSimple,setAssignment| (|x|)
 (SEQ
  (IF (BOOT-EQUAL |$assignmentList| (QUOTE |failed|)) (EXIT NIL))
  (EXIT (SPADLET |$assignmentList| (APPEND |$assignmentList| |x|))))) 

;;;     ***       |isAlmostSimple,fn| REDEFINED

(DEFUN |isAlmostSimple,fn| (|x|)
 (PROG (|op| |y| |l| |g|) 
  (RETURN
   (SEQ
    (IF (OR (ATOM |x|) (NULL (CDR |x|))) (EXIT |x|))
    (PROGN
     (SPADLET |op| (CAR |x|))
     (SPADLET |y| (CADR |x|))
     (SPADLET |l| (CDDR |x|)) |x|)
    (IF (BOOT-EQUAL |op| (QUOTE |has|)) (EXIT |x|))
    (IF (BOOT-EQUAL |op| (QUOTE |is|)) (EXIT |x|))
    (IF (BOOT-EQUAL |op| (QUOTE LET))
     (EXIT
      (SEQ
       (IF (IDENTP |y|)
        (EXIT (SEQ (|isAlmostSimple,setAssignment| (LIST |x|)) (EXIT |y|))))
       (EXIT
        (IF (QUOTE T)
         (EXIT
          (SEQ
           (|isAlmostSimple,setAssignment|
            (CONS
             (CONS (QUOTE LET) (CONS (SPADLET |g| (|genVariable|)) |l|))
             (CONS (CONS (QUOTE LET) (CONS |y| (CONS |g| NIL))) NIL)))
           (EXIT |g|))))))))
    (IF (|isSideEffectFree| |op|)
     (EXIT (CONS |op| (|mapInto| (CDR |x|) (QUOTE |isAlmostSimple,fn|)))))
    (EXIT
     (IF (QUOTE T) (EXIT (SPADLET |$assignmentList| (QUOTE |failed|))))))))) 

;;;     ***       |isAlmostSimple| REDEFINED

(DEFUN |isAlmostSimple| (|x|)
 (PROG (|$assignmentList| |transform|)
  (DECLARE (SPECIAL |$assignmentList|))
  (RETURN
   (PROGN
    (SPADLET |$assignmentList| NIL)
    (SPADLET |transform| (|isAlmostSimple,fn| |x|))
    (COND
     ((BOOT-EQUAL |$assignmentList| (QUOTE |failed|)) NIL)
     ((QUOTE T)
       (|wrapSEQExit| (APPEND |$assignmentList| (CONS |transform| NIL))))))))) 
;
;incExitLevel u ==
;  adjExitLevel(u,1,1)
;  u

;;;     ***       |incExitLevel| REDEFINED

(DEFUN |incExitLevel| (|u|) (PROGN (|adjExitLevel| |u| 1 1) |u|)) 
;
;decExitLevel u ==
;  (adjExitLevel(u,1,-1); removeExit0 u) where
;    removeExit0 x ==
;      atom x => x
;      x is ["exit",0,u] => removeExit0 u
;      [removeExit0 first x,:removeExit0 rest x]

;;;     ***       |decExitLevel,removeExit0| REDEFINED

(DEFUN |decExitLevel,removeExit0| (|x|) 
 (PROG (|ISTMP#1| |ISTMP#2| |u|) 
  (RETURN 
   (SEQ 
    (IF (ATOM |x|) (EXIT |x|))
    (IF 
     (AND 
      (PAIRP |x|)
      (EQ (QCAR |x|) (QUOTE |exit|))
      (PROGN
       (SPADLET |ISTMP#1| (QCDR |x|))
       (AND
        (PAIRP |ISTMP#1|)
        (EQUAL (QCAR |ISTMP#1|) 0)
        (PROGN
         (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
         (AND 
          (PAIRP |ISTMP#2|)
          (EQ (QCDR |ISTMP#2|) NIL)
          (PROGN (SPADLET |u| (QCAR |ISTMP#2|)) (QUOTE T)))))))
      (EXIT (|decExitLevel,removeExit0| |u|)))
    (EXIT 
     (CONS 
      (|decExitLevel,removeExit0| (CAR |x|))
      (|decExitLevel,removeExit0| (CDR |x|)))))))) 

;;;     ***       |decExitLevel| REDEFINED

(DEFUN |decExitLevel| (|u|)
 (PROGN
  (|adjExitLevel| |u| 1 (SPADDIFFERENCE 1))
  (|decExitLevel,removeExit0| |u|))) 
;
;adjExitLevel(x,seqnum,inc) ==
;  atom x => x
;  x is [op,:l] and MEMQ(op,'(SEQ REPEAT COLLECT)) =>
;    for u in l repeat adjExitLevel(u,seqnum+1,inc)
;  x is ["exit",n,u] =>
;    (adjExitLevel(u,seqnum,inc); seqnum>n => x; rplac(CADR x,n+inc))
;  x is [op,:l] => for u in l repeat adjExitLevel(u,seqnum,inc)

;;;     ***       |adjExitLevel| REDEFINED

(DEFUN |adjExitLevel| (|x| |seqnum| |inc|)
 (PROG (|ISTMP#1| |n| |ISTMP#2| |u| |op| |l|)
  (RETURN
   (SEQ
    (COND
     ((ATOM |x|) |x|)
     ((AND 
       (PAIRP |x|)
       (PROGN (SPADLET |op| (QCAR |x|)) (SPADLET |l| (QCDR |x|)) (QUOTE T))
       (MEMQ |op| (QUOTE (SEQ REPEAT COLLECT))))
      (DO ((#0=#:G3401 |l| (CDR #0#)) (|u| NIL))
          ((OR (ATOM #0#) (PROGN (SETQ |u| (CAR #0#)) NIL)) NIL)
       (SEQ (EXIT (|adjExitLevel| |u| (PLUS |seqnum| 1) |inc|)))))
     ((AND
       (PAIRP |x|)
       (EQ (QCAR |x|) (QUOTE |exit|))
       (PROGN
        (SPADLET |ISTMP#1| (QCDR |x|))
        (AND 
         (PAIRP |ISTMP#1|)
         (PROGN
          (SPADLET |n| (QCAR |ISTMP#1|))
          (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
          (AND
           (PAIRP |ISTMP#2|)
           (EQ (QCDR |ISTMP#2|) NIL)
           (PROGN (SPADLET |u| (QCAR |ISTMP#2|)) (QUOTE T)))))))
       (|adjExitLevel| |u| |seqnum| |inc|)
       (COND
        ((> |seqnum| |n|) |x|)
        ((QUOTE T) (|rplac| (CADR |x|) (PLUS |n| |inc|)))))
     ((AND 
       (PAIRP |x|)
       (PROGN (SPADLET |op| (QCAR |x|)) (SPADLET |l| (QCDR |x|)) (QUOTE T)))
       (DO ((#1=#:G3410 |l| (CDR #1#)) (|u| NIL))
           ((OR (ATOM #1#) (PROGN (SETQ |u| (CAR #1#)) NIL)) NIL)
        (SEQ (EXIT (|adjExitLevel| |u| |seqnum| |inc|)))))))))) 
;
;wrapSEQExit l ==
;  null rest l => first l
;  [:c,x]:= [incExitLevel u for u in l]
;  ["SEQ",:c,["exit",1,x]]

;;;     ***       |wrapSEQExit| REDEFINED

(DEFUN |wrapSEQExit| (|l|)
 (PROG (|LETTMP#1| |LETTMP#2| |x| |c|)
  (RETURN
   (SEQ
    (COND
     ((NULL (CDR |l|)) (CAR |l|))
     ((QUOTE T)
       (SPADLET |LETTMP#1|
        (PROG (#0=#:G3441)
         (SPADLET #0# NIL)
         (RETURN
          (DO ((#1=#:G3446 |l| (CDR #1#)) (|u| NIL))
              ((OR (ATOM #1#) (PROGN (SETQ |u| (CAR #1#)) NIL))
               (NREVERSE0 #0#))
           (SEQ (EXIT (SETQ #0# (CONS (|incExitLevel| |u|) #0#))))))))
       (SPADLET |LETTMP#2| (REVERSE |LETTMP#1|))
       (SPADLET |x| (CAR |LETTMP#2|))
       (SPADLET |c| (NREVERSE (CDR |LETTMP#2|)))
       (CONS
        (QUOTE SEQ)
        (APPEND |c|
         (CONS (CONS (QUOTE |exit|) (CONS 1 (CONS |x| NIL))) NIL))))))))) 
;
;
;--% UTILITY FUNCTIONS
;
;--appendOver x == "append"/x
;
;removeEnv t == [t.expr,t.mode,$EmptyEnvironment]  -- t is a triple

;;;     ***       |removeEnv| REDEFINED

(DEFUN |removeEnv| (|t|)
 (CONS (CAR |t|) (CONS (CADR |t|) (CONS |$EmptyEnvironment| NIL)))) 
;
;-- This function seems no longer used
;--ordinsert(x,l) ==
;--  null l => [x]
;--  x=first l => l
;--  _?ORDER(x,first l) => [x,:l]
;--  [first l,:ordinsert(x,rest l)]
;
;makeNonAtomic x ==
;  atom x => [x]
;  x

;;;     ***       |makeNonAtomic| REDEFINED

(DEFUN |makeNonAtomic| (|x|)
 (COND ((ATOM |x|) (CONS |x| NIL)) ((QUOTE T) |x|))) 
;
;flatten(l,key) ==
;  null l => nil
;  first l is [k,:r] and k=key => [:r,:flatten(rest l,key)]
;  [first l,:flatten(rest l,key)]

;;;     ***       |flatten| REDEFINED

(DEFUN |flatten| (|l| |key|)
 (PROG (|ISTMP#1| |k| |r|)
  (RETURN
   (COND
    ((NULL |l|) NIL)
    ((AND 
       (PROGN 
        (SPADLET |ISTMP#1| (CAR |l|))
        (AND 
         (PAIRP |ISTMP#1|)
         (PROGN
          (SPADLET |k| (QCAR |ISTMP#1|))
          (SPADLET |r| (QCDR |ISTMP#1|))
          (QUOTE T))))
       (BOOT-EQUAL |k| |key|))
      (APPEND |r| (|flatten| (CDR |l|) |key|)))
    ((QUOTE T) (CONS (CAR |l|) (|flatten| (CDR |l|) |key|))))))) 
;
;genDomainVar() ==
;  $Index:= $Index+1
;  INTERNL STRCONC("#D",STRINGIMAGE $Index)

;;;     ***       |genDomainVar| REDEFINED

(DEFUN |genDomainVar| NIL
 (PROGN
  (SPADLET |$Index| (PLUS |$Index| 1))
  (INTERNL (STRCONC (QUOTE |#D|) (STRINGIMAGE |$Index|))))) 
;
;genVariable() ==
;  INTERNL STRCONC("#G",STRINGIMAGE ($genSDVar:= $genSDVar+1))

;;;     ***       |genVariable| REDEFINED

(DEFUN |genVariable| NIL
 (INTERNL
  (STRCONC
   (QUOTE |#G|)
   (STRINGIMAGE (SPADLET |$genSDVar| (PLUS |$genSDVar| 1)))))) 
;
;genSomeVariable() ==
;  INTERNL STRCONC("##",STRINGIMAGE ($genSDVar:= $genSDVar+1))

;;;     ***       |genSomeVariable| REDEFINED

(DEFUN |genSomeVariable| NIL
 (INTERNL
  (STRCONC
   (QUOTE |##|)
   (STRINGIMAGE (SPADLET |$genSDVar| (PLUS |$genSDVar| 1)))))) 
;
;listOfIdentifiersIn x ==
;  IDENTP x => [x]
;  x is [op,:l] => REMDUP ("append"/[listOfIdentifiersIn y for y in l])
;  nil

;;;     ***       |listOfIdentifiersIn| REDEFINED

(DEFUN |listOfIdentifiersIn| (|x|)
 (PROG (|op| |l|)
  (RETURN
   (SEQ
    (COND
     ((IDENTP |x|) (CONS |x| NIL))
     ((AND 
        (PAIRP |x|)
        (PROGN (SPADLET |op| (QCAR |x|)) (SPADLET |l| (QCDR |x|)) (QUOTE T)))
       (REMDUP
        (PROG (#0=#:G3499)
         (SPADLET #0# NIL)
         (RETURN
          (DO ((#1=#:G3504 |l| (CDR #1#)) (|y| NIL))
              ((OR (ATOM #1#) (PROGN (SETQ |y| (CAR #1#)) NIL)) #0#)
           (SEQ
            (EXIT
             (SETQ #0# (APPEND #0# (|listOfIdentifiersIn| |y|))))))))))
     ((QUOTE T) NIL)))))) 
;
;mapInto(x,fn) == [FUNCALL(fn,y) for y in x]

;;;     ***       |mapInto| REDEFINED

(DEFUN |mapInto| (|x| |fn|)
 (PROG NIL
  (RETURN
   (SEQ
    (PROG (#0=#:G3520)
     (SPADLET #0# NIL)
     (RETURN
      (DO ((#1=#:G3525 |x| (CDR #1#)) (|y| NIL))
          ((OR (ATOM #1#) (PROGN (SETQ |y| (CAR #1#)) NIL)) (NREVERSE0 #0#))
       (SEQ (EXIT (SETQ #0# (CONS (FUNCALL |fn| |y|) #0#))))))))))) 
;
;numOfOccurencesOf(x,y) ==
;  fn(x,y,0) where
;    fn(x,y,n) ==
;      null y => 0
;      x=y => n+1
;      atom y => n
;      fn(x,first y,n)+fn(x,rest y,n)

;;;     ***       |numOfOccurencesOf,fn| REDEFINED

(DEFUN |numOfOccurencesOf,fn| (|x| |y| |n|)
 (SEQ
  (IF (NULL |y|) (EXIT 0))
  (IF (BOOT-EQUAL |x| |y|) (EXIT (PLUS |n| 1)))
  (IF (ATOM |y|) (EXIT |n|))
  (EXIT
   (PLUS
    (|numOfOccurencesOf,fn| |x| (CAR |y|) |n|)
    (|numOfOccurencesOf,fn| |x| (CDR |y|) |n|))))) 

;;;     ***       |numOfOccurencesOf| REDEFINED

(DEFUN |numOfOccurencesOf| (|x| |y|) (|numOfOccurencesOf,fn| |x| |y| 0)) 
;
;compilerMessage x ==
;  $PrintCompilerMessageIfTrue => APPLX("SAY",x)

;;;     ***       |compilerMessage| REDEFINED

(DEFUN |compilerMessage| (|x|)
 (SEQ (COND (|$PrintCompilerMessageIfTrue| (EXIT (APPLX (QUOTE SAY) |x|)))))) 
;
;printDashedLine() ==
;  SAY
;   '"----------------------------------------------------------------------"

;;;     ***       |printDashedLine| REDEFINED

(DEFUN |printDashedLine| NIL
 (SAY (MAKESTRING 
   "----------------------------------------------------------------------"))) 
;
;stackSemanticError(msg,expr) ==
;  BUMPERRORCOUNT "semantic"
;  if $insideCapsuleFunctionIfTrue then msg:= [$op,": ",:msg]
;  if atom msg then msg:= LIST msg
;  entry:= [msg,expr]
;  if not MEMBER(entry,$semanticErrorStack) then $semanticErrorStack:=
;    [entry,:$semanticErrorStack]
;  $scanIfTrue and $insideCapsuleFunctionIfTrue=true and #$semanticErrorStack-
;    $initCapsuleErrorCount>3 => THROW("compCapsuleBody",nil)
;  nil

;;;     ***       |stackSemanticError| REDEFINED

(DEFUN |stackSemanticError| (|msg| |expr|)
 (PROG (|entry|)
  (RETURN
   (PROGN
    (BUMPERRORCOUNT (QUOTE |semantic|))
    (COND 
     (|$insideCapsuleFunctionIfTrue| 
      (SPADLET |msg| (CONS |$op| (CONS (QUOTE |: |) |msg|)))))
    (COND ((ATOM |msg|) (SPADLET |msg| (LIST |msg|))))
    (SPADLET |entry| (CONS |msg| (CONS |expr| NIL)))
    (COND 
     ((NULL (|member| |entry| |$semanticErrorStack|))
       (SPADLET |$semanticErrorStack| (CONS |entry| |$semanticErrorStack|))))
    (COND 
     ((AND |$scanIfTrue| 
           (BOOT-EQUAL |$insideCapsuleFunctionIfTrue| (QUOTE T))
           (> (SPADDIFFERENCE 
                (|#| |$semanticErrorStack|)
                |$initCapsuleErrorCount|)
              3))
       (THROW (QUOTE |compCapsuleBody|) NIL))
     ((QUOTE T) NIL)))))) 
;
;stackWarning msg ==
;  if $insideCapsuleFunctionIfTrue then msg:= [$op,": ",:msg]
;  if not MEMBER(msg,$warningStack) then $warningStack:= [msg,:$warningStack]
;  nil

;;;     ***       |stackWarning| REDEFINED

(DEFUN |stackWarning| (|msg|)
 (PROGN
  (COND
   (|$insideCapsuleFunctionIfTrue| 
    (SPADLET |msg| (CONS |$op| (CONS (QUOTE |: |) |msg|)))))
  (COND 
   ((NULL (|member| |msg| |$warningStack|)) 
    (SPADLET |$warningStack| (CONS |msg| |$warningStack|))))
  NIL)) 
;
;unStackWarning msg ==
;  if $insideCapsuleFunctionIfTrue then msg:= [$op,": ",:msg]
;  $warningStack:= EFFACE(msg,$warningStack)
;  nil

;;;     ***       |unStackWarning| REDEFINED

(DEFUN |unStackWarning| (|msg|)
 (PROGN
  (COND
   (|$insideCapsuleFunctionIfTrue| 
    (SPADLET |msg| (CONS |$op| (CONS (QUOTE |: |) |msg|)))))
  (SPADLET |$warningStack| (EFFACE |msg| |$warningStack|)) NIL)) 
;
;stackMessage msg ==
;  $compErrorMessageStack:= [msg,:$compErrorMessageStack]
;  nil

;;;     ***       |stackMessage| REDEFINED

(DEFUN |stackMessage| (|msg|) 
 (PROGN 
  (SPADLET |$compErrorMessageStack| (CONS |msg| |$compErrorMessageStack|))
   NIL)) 
;
;stackMessageIfNone msg ==
;  --used in situations such as compForm where the earliest message is wanted
;  if null $compErrorMessageStack then $compErrorMessageStack:=
;    [msg,:$compErrorMessageStack]
;  nil

;;;     ***       |stackMessageIfNone| REDEFINED

(DEFUN |stackMessageIfNone| (|msg|) 
 (PROGN 
  (COND 
   ((NULL |$compErrorMessageStack|)
     (SPADLET |$compErrorMessageStack| 
      (CONS |msg| |$compErrorMessageStack|))))
  NIL)) 
;
;stackAndThrow msg ==
;  $compErrorMessageStack:= [msg,:$compErrorMessageStack]
;  THROW("compOrCroak",nil)

;;;     ***       |stackAndThrow| REDEFINED

(DEFUN |stackAndThrow| (|msg|)
 (PROGN
  (SPADLET |$compErrorMessageStack| (CONS |msg| |$compErrorMessageStack|))
  (THROW (QUOTE |compOrCroak|) NIL))) 
;
;printString x == PRINTEXP (STRINGP x => x; PNAME x)

;;;     ***       |printString| REDEFINED

(DEFUN |printString| (|x|)
 (PRINTEXP (COND ((STRINGP |x|) |x|) ((QUOTE T) (PNAME |x|))))) 
;
;printAny x == if atom x then printString x else PRIN0 x

;;;     ***       |printAny| REDEFINED

(DEFUN |printAny| (|x|)
 (COND ((ATOM |x|) (|printString| |x|)) ((QUOTE T) (PRIN0 |x|)))) 
;
;printSignature(before,op,[target,:argSigList]) ==
;  printString before
;  printString op
;  printString ": _("
;  if argSigList then
;    printAny first argSigList
;    for m in rest argSigList repeat (printString ","; printAny m)
;  printString "_) -> "
;  printAny target
;  TERPRI()

;;;     ***       |printSignature| REDEFINED

(DEFUN |printSignature| (|before| |op| #0=#:G3594)
 (PROG (|target| |argSigList|)
  (RETURN
   (SEQ
    (PROGN
     (SPADLET |target| (CAR #0#))
     (SPADLET |argSigList| (CDR #0#))
     (|printString| |before|)
     (|printString| |op|)
     (|printString| 
      (QUOTE |: (|))
      (COND 
       (|argSigList|
        (|printAny| (CAR |argSigList|))
        (DO ((#1=#:G3608 (CDR |argSigList|) (CDR #1#)) (|m| NIL))
            ((OR (ATOM #1#) (PROGN (SETQ |m| (CAR #1#)) NIL)) NIL)
         (SEQ (EXIT (PROGN (|printString| (QUOTE |,|)) (|printAny| |m|)))))))
      (|printString| (QUOTE |) -> |))
     (|printAny| |target|) (TERPRI)))))) 
;
;pmatch(s,p) == pmatchWithSl(s,p,"ok")

;;;     ***       |pmatch| REDEFINED

(DEFUN |pmatch| (|s| |p|) (|pmatchWithSl| |s| |p| (QUOTE |ok|))) 
;
;pmatchWithSl(s,p,al) ==
;  s=$EmptyMode => nil
;  s=p => al
;  v:= ASSOC(p,al) => s=rest v or al
;  MEMQ(p,$PatternVariableList) => [[p,:s],:al]
;  null atom p and null atom s and _
;           (al':= pmatchWithSl(first s,first p,al)) and
;    pmatchWithSl(rest s,rest p,al')

;;;     ***       |pmatchWithSl| REDEFINED

(DEFUN |pmatchWithSl| (|s| |p| |al|)
 (PROG (|v| |al'|)
  (RETURN
   (COND
    ((BOOT-EQUAL |s| |$EmptyMode|) NIL)
    ((BOOT-EQUAL |s| |p|) |al|)
    ((SPADLET |v| (|assoc| |p| |al|)) (OR (BOOT-EQUAL |s| (CDR |v|)) |al|))
    ((MEMQ |p| |$PatternVariableList|) (CONS (CONS |p| |s|) |al|))
    ((QUOTE T)
      (AND
       (NULL (ATOM |p|))
       (NULL (ATOM |s|))
       (SPADLET |al'| (|pmatchWithSl| (CAR |s|) (CAR |p|) |al|))
       (|pmatchWithSl| (CDR |s|) (CDR |p|) |al'|))))))) 
;
;elapsedTime() ==
;  currentTime:= TEMPUS_-FUGIT()
;  elapsedSeconds:= (currentTime-$previousTime)*1.0/$timerTicksPerSecond
;  $previousTime:= currentTime
;  elapsedSeconds

;;;     ***       |elapsedTime| REDEFINED

(DEFUN |elapsedTime| NIL
 (PROG (|currentTime| |elapsedSeconds|)
  (RETURN
   (PROGN
    (SPADLET |currentTime| (TEMPUS-FUGIT))
    (SPADLET |elapsedSeconds| 
     (QUOTIENT 
      (TIMES 
       (SPADDIFFERENCE |currentTime| |$previousTime|)
        1.0) 
      |$timerTicksPerSecond|))
    (SPADLET |$previousTime| |currentTime|) |elapsedSeconds|)))) 
;
;addStats([a,b],[c,d]) == [a+c,b+d]

;;;     ***       |addStats| REDEFINED

(DEFUN |addStats| (#0=#:G3635 #1=#:G3644) 
 (PROG (|c| |d| |a| |b|) 
  (RETURN 
   (PROGN 
    (SPADLET |c| (CAR #1#))
    (SPADLET |d| (CADR #1#))
    (SPADLET |a| (CAR #0#))
    (SPADLET |b| (CADR #0#))
    (CONS (PLUS |a| |c|) (CONS (PLUS |b| |d|) NIL)))))) 
;
;printStats [byteCount,elapsedSeconds] ==
;  timeString := normalizeStatAndStringify elapsedSeconds
;  if byteCount = 0 then SAY('"Time: ",timeString,'" SEC.") else
;    SAY('"Size: ",byteCount,'" BYTES     Time: ",timeString,'" SEC.")
;  TERPRI()
;  nil

;;;     ***       |printStats| REDEFINED

(DEFUN |printStats| (#0=#:G3665)
 (PROG (|byteCount| |elapsedSeconds| |timeString|)
  (RETURN
   (PROGN
    (SPADLET |byteCount| (CAR #0#))
    (SPADLET |elapsedSeconds| (CADR #0#))
    (SPADLET |timeString| (|normalizeStatAndStringify| |elapsedSeconds|))
    (COND
     ((EQL |byteCount| 0)
       (SAY (MAKESTRING "Time: ") |timeString| (MAKESTRING " SEC.")))
     ((QUOTE T) 
       (SAY (MAKESTRING "Size: ") |byteCount| 
         (MAKESTRING " BYTES     Time: ") |timeString| (MAKESTRING " SEC."))))
    (TERPRI) NIL)))) 
;
;extendsCategoryForm(domain,form,form') ==
;  --is domain of category form also of category form'?
;  --domain is only used for SubsetCategory resolution.
;  --and ensuring that X being a Ring means that it
;  --satisfies (Algebra X)
;  form=form' => true
;  form=$Category => nil
;  form' is ["Join",:l] => and/[extendsCategoryForm(domain,form,x) for x in l]
;  form' is ["CATEGORY",.,:l] =>
;    and/[extendsCategoryForm(domain,form,x) for x in l]
;  form' is ["SubsetCategory",cat,dom] =>
;    extendsCategoryForm(domain,form,cat) and isSubset(domain,dom,$e)
;  form is ["Join",:l] => or/[extendsCategoryForm(domain,x,form') for x in l]
;  form is ["CATEGORY",.,:l] =>
;    MEMBER(form',l) or
;      stackWarning ["not known that ",form'," is of mode ",form] or true
;  isCategoryForm(form,$EmptyEnvironment) =>
;          --Constructs the associated vector
;    formVec:=(compMakeCategoryObject(form,$e)).expr
;            --Must be $e to pick up locally bound domains
;    form' is ["SIGNATURE",op,args,:.] =>
;        ASSOC([op,args],formVec.(1)) or
;            ASSOC(SUBSTQ(domain,"$",[op,args]),
;                  SUBSTQ(domain,"$",formVec.(1)))
;    form' is ["ATTRIBUTE",at] =>
;         ASSOC(at,formVec.2) or
;            ASSOC(SUBSTQ(domain,"$",at),SUBSTQ(domain,"$",formVec.2))
;    form' is ["IF",:.] => true --temporary hack so comp won't fail
;    -- Are we dealing with an Aldor category?  If so use the "has" function
;    # formVec = 1 => newHasTest(form,form')
;    catvlist:= formVec.4
;    MEMBER(form',first catvlist) or
;     MEMBER(form',SUBSTQ(domain,"$",first catvlist)) or
;      (or/
;        [extendsCategoryForm(domain,SUBSTQ(domain,"$",cat),form')
;          for [cat,:.] in CADR catvlist])
;  nil

;;;     ***       |extendsCategoryForm| REDEFINED

(DEFUN |extendsCategoryForm| (|domain| |form| |form'|)
 (PROG (|dom| |l| |formVec| |op| |ISTMP#2| |args| |ISTMP#1| |at| |catvlist|
        |cat|) 
  (RETURN 
   (SEQ 
    (COND 
     ((BOOT-EQUAL |form| |form'|) (QUOTE T))
     ((BOOT-EQUAL |form| |$Category|) NIL)
     ((AND 
        (PAIRP |form'|)
        (EQ (QCAR |form'|) (QUOTE |Join|))
        (PROGN (SPADLET |l| (QCDR |form'|)) (QUOTE T)))
       (PROG (#0=#:G3729)
        (SPADLET #0# (QUOTE T))
        (RETURN
         (DO ((#1=#:G3735 NIL (NULL #0#)) (#2=#:G3736 |l| (CDR #2#)) (|x| NIL))
             ((OR #1# (ATOM #2#) (PROGN (SETQ |x| (CAR #2#)) NIL)) #0#)
          (SEQ
           (EXIT
            (SETQ #0#
             (AND #0# (|extendsCategoryForm| |domain| |form| |x|)))))))))
     ((AND 
        (PAIRP |form'|)
        (EQ (QCAR |form'|) (QUOTE CATEGORY))
        (PROGN
         (SPADLET |ISTMP#1| (QCDR |form'|))
         (AND 
          (PAIRP |ISTMP#1|)
          (PROGN 
           (SPADLET |l| (QCDR |ISTMP#1|))
           (QUOTE T)))))
       (PROG (#3=#:G3743)
        (SPADLET #3# (QUOTE T))
        (RETURN
         (DO ((#4=#:G3749 NIL (NULL #3#)) (#5=#:G3750 |l| (CDR #5#)) (|x| NIL))
             ((OR #4# (ATOM #5#) (PROGN (SETQ |x| (CAR #5#)) NIL)) #3#)
          (SEQ
           (EXIT
            (SETQ #3#
             (AND #3# (|extendsCategoryForm| |domain| |form| |x|)))))))))
     ((AND 
       (PAIRP |form'|)
       (EQ (QCAR |form'|) (QUOTE |SubsetCategory|))
       (PROGN
        (SPADLET |ISTMP#1| (QCDR |form'|))
        (AND 
         (PAIRP |ISTMP#1|)
         (PROGN
          (SPADLET |cat| (QCAR |ISTMP#1|))
          (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
          (AND
           (PAIRP |ISTMP#2|)
           (EQ (QCDR |ISTMP#2|) NIL)
           (PROGN (SPADLET |dom| (QCAR |ISTMP#2|)) (QUOTE T)))))))
       (AND
        (|extendsCategoryForm| |domain| |form| |cat|)
        (|isSubset| |domain| |dom| |$e|)))
      ((AND
         (PAIRP |form|)
         (EQ (QCAR |form|) (QUOTE |Join|))
         (PROGN (SPADLET |l| (QCDR |form|)) (QUOTE T)))
       (PROG (#6=#:G3757)
        (SPADLET #6# NIL)
        (RETURN
         (DO ((#7=#:G3763 NIL #6#) (#8=#:G3764 |l| (CDR #8#)) (|x| NIL))
             ((OR #7# (ATOM #8#) (PROGN (SETQ |x| (CAR #8#)) NIL)) #6#)
          (SEQ
           (EXIT
            (SETQ #6#
             (OR #6# (|extendsCategoryForm| |domain| |x| |form'|)))))))))
      ((AND 
        (PAIRP |form|)
        (EQ (QCAR |form|) (QUOTE CATEGORY))
        (PROGN 
         (SPADLET |ISTMP#1| (QCDR |form|))
         (AND 
          (PAIRP |ISTMP#1|)
          (PROGN (SPADLET |l| (QCDR |ISTMP#1|)) (QUOTE T)))))
       (OR 
        (|member| |form'| |l|)
        (|stackWarning|
         (CONS
          (QUOTE |not known that |)
          (CONS |form'| (CONS (QUOTE | is of mode |) (CONS |form| NIL)))))
         (QUOTE T)))
      ((|isCategoryForm| |form| |$EmptyEnvironment|)
       (SPADLET |formVec| (CAR (|compMakeCategoryObject| |form| |$e|)))
       (COND
        ((AND 
          (PAIRP |form'|)
          (EQ (QCAR |form'|) (QUOTE SIGNATURE))
          (PROGN 
           (SPADLET |ISTMP#1| (QCDR |form'|))
           (AND 
            (PAIRP |ISTMP#1|)
            (PROGN 
             (SPADLET |op| (QCAR |ISTMP#1|))
             (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
             (AND 
              (PAIRP |ISTMP#2|)
              (PROGN (SPADLET |args| (QCAR |ISTMP#2|)) (QUOTE T)))))))
         (OR (|assoc| (CONS |op| (CONS |args| NIL)) (ELT |formVec| 1))
             (|assoc| 
              (SUBSTQ |domain| (QUOTE $) (CONS |op| (CONS |args| NIL)))
              (SUBSTQ |domain| (QUOTE $) (ELT |formVec| 1)))))
        ((AND 
          (PAIRP |form'|)
          (EQ (QCAR |form'|) (QUOTE ATTRIBUTE))
          (PROGN 
           (SPADLET |ISTMP#1| (QCDR |form'|))
           (AND 
            (PAIRP |ISTMP#1|)
            (EQ (QCDR |ISTMP#1|) NIL)
            (PROGN (SPADLET |at| (QCAR |ISTMP#1|)) (QUOTE T)))))
         (OR 
          (|assoc| |at| (ELT |formVec| 2))
          (|assoc| 
            (SUBSTQ |domain| (QUOTE $) |at|)
            (SUBSTQ |domain| (QUOTE $) (ELT |formVec| 2)))))
        ((AND (PAIRP |form'|) (EQ (QCAR |form'|) (QUOTE IF))) (QUOTE T))
        ((EQL (|#| |formVec|) 1) (|newHasTest| |form| |form'|))
        ((QUOTE T) 
          (SPADLET |catvlist| (ELT |formVec| 4))
          (OR 
           (|member| |form'| (CAR |catvlist|))
           (|member| |form'| (SUBSTQ |domain| (QUOTE $) (CAR |catvlist|)))
           (PROG (#9=#:G3771)
            (SPADLET #9# NIL)
            (RETURN
             (DO ((#10=#:G3778 NIL #9#)
                  (#11=#:G3779 (CADR |catvlist|) (CDR #11#))
                  (#12=#:G3724 NIL))
                 ((OR #10# 
                      (ATOM #11#)
                      (PROGN (SETQ #12# (CAR #11#)) NIL)
                      (PROGN (PROGN (SPADLET |cat| (CAR #12#)) #12#) NIL))
                  #9#)
              (SEQ
               (EXIT
                (SETQ #9#
                 (OR #9#
                  (|extendsCategoryForm| |domain| 
                    (SUBSTQ |domain| (QUOTE $) |cat|) |form'|))))))))))))
      ((QUOTE T) NIL)))))) 
;
;getmode(x,e) ==
;  prop:=getProplist(x,e)
;  u:= LASSQ("value",prop) => u.mode
;  LASSQ("mode",prop)

;;;     ***       |getmode| REDEFINED

(DEFUN |getmode| (|x| |e|)
 (PROG (|prop| |u|)
  (RETURN
   (PROGN
    (SPADLET |prop| (|getProplist| |x| |e|))
    (COND
     ((SPADLET |u| (LASSQ (QUOTE |value|) |prop|)) (CADR |u|))
     ((QUOTE T) (LASSQ (QUOTE |mode|) |prop|))))))) 
;
;getmodeOrMapping(x,e) ==
;  u:= getmode(x,e) => u
;  (u:= get(x,"modemap",e)) is [[[.,:map],.],:.] => ["Mapping",:map]
;  nil

;;;     ***       |getmodeOrMapping| REDEFINED

(DEFUN |getmodeOrMapping| (|x| |e|)
 (PROG (|u| |ISTMP#1| |ISTMP#2| |ISTMP#3| |map| |ISTMP#4|)
  (RETURN
   (COND
    ((SPADLET |u| (|getmode| |x| |e|)) |u|)
    ((PROGN 
      (SPADLET |ISTMP#1| (SPADLET |u| (|get| |x| (QUOTE |modemap|) |e|)))
      (AND 
       (PAIRP |ISTMP#1|)
       (PROGN 
        (SPADLET |ISTMP#2| (QCAR |ISTMP#1|))
        (AND 
         (PAIRP |ISTMP#2|)
         (PROGN 
          (SPADLET |ISTMP#3| (QCAR |ISTMP#2|))
          (AND 
           (PAIRP |ISTMP#3|)
            (PROGN (SPADLET |map| (QCDR |ISTMP#3|)) (QUOTE T))))
         (PROGN 
          (SPADLET |ISTMP#4| (QCDR |ISTMP#2|))
          (AND (PAIRP |ISTMP#4|) (EQ (QCDR |ISTMP#4|) NIL)))))))
     (CONS (QUOTE |Mapping|) |map|))
    ((QUOTE T) NIL))))) 
;
;outerProduct l ==
;                --of a list of lists
;  null l => LIST nil
;  "append"/[[[x,:y] for y in outerProduct rest l] for x in first l]

;;;     ***       |outerProduct| REDEFINED

(DEFUN |outerProduct| (|l|)
 (PROG NIL
  (RETURN
   (SEQ
    (COND
     ((NULL |l|) (LIST NIL))
     ((QUOTE T)
       (PROG (#0=#:G3855)
        (SPADLET #0# NIL)
        (RETURN
         (DO ((#1=#:G3860 (CAR |l|) (CDR #1#)) (|x| NIL))
             ((OR (ATOM #1#) (PROGN (SETQ |x| (CAR #1#)) NIL)) #0#)
          (SEQ
           (EXIT
            (SETQ #0#
             (APPEND #0#
              (PROG (#2=#:G3870)
               (SPADLET #2# NIL)
               (RETURN
                (DO ((#3=#:G3875 (|outerProduct| (CDR |l|)) (CDR #3#))
                     (|y| NIL))
                    ((OR (ATOM #3#) (PROGN (SETQ |y| (CAR #3#)) NIL))
                     (NREVERSE0 #2#))
                 (SEQ
                  (EXIT
                   (SETQ #2# (CONS (CONS |x| |y|) #2#)))))))))))))))))))) 
;
;sublisR(al,u) ==
;  atom u => u
;  y:= RASSOC(t:= [sublisR(al,x) for x in u],al) => y
;  true => t

;;;     ***       |sublisR| REDEFINED

(DEFUN |sublisR| (|al| |u|)
 (PROG (|t| |y|)
  (RETURN
   (SEQ
    (COND
     ((ATOM |u|) |u|)
     ((SPADLET |y|
       (|rassoc|
        (SPADLET |t|
         (PROG (#0=#:G3891)
          (SPADLET #0# NIL)
          (RETURN
           (DO ((#1=#:G3896 |u| (CDR #1#)) (|x| NIL))
               ((OR (ATOM #1#) (PROGN (SETQ |x| (CAR #1#)) NIL))
                (NREVERSE0 #0#))
            (SEQ (EXIT (SETQ #0# (CONS (|sublisR| |al| |x|) #0#)))))))) |al|))
       |y|)
     ((QUOTE T) |t|)))))) 
;
;substituteOp(op',op,x) ==
;  atom x => x
;  [(op=(f:= first x) => op'; f),:[substituteOp(op',op,y) for y in rest x]]

;;;     ***       |substituteOp| REDEFINED

(DEFUN |substituteOp| (|op'| |op| |x|)
 (PROG (|f|)
  (RETURN
   (SEQ
    (COND
     ((ATOM |x|) |x|)
     ((QUOTE T)
      (CONS
       (COND
        ((BOOT-EQUAL |op| (SPADLET |f| (CAR |x|))) |op'|)
        ((QUOTE T) |f|))
       (PROG (#0=#:G3914)
        (SPADLET #0# NIL)
        (RETURN
         (DO ((#1=#:G3919 (CDR |x|) (CDR #1#)) (|y| NIL))
             ((OR (ATOM #1#) (PROGN (SETQ |y| (CAR #1#)) NIL))
              (NREVERSE0 #0#))
          (SEQ
           (EXIT
            (SETQ #0# (CONS (|substituteOp| |op'| |op| |y|) #0#)))))))))))))) 
;
;--substituteForFormalArguments(argl,expr) ==
;--  SUBLIS([[v,:a] for a in argl for v in $FormalMapVariableList],expr)
;
; -- following is only intended for substituting in domains slots 1 and 4
; -- signatures and categories
;sublisV(p,e) ==
;  (atom p => e; suba(p,e)) where
;    suba(p,e) ==
;      STRINGP e => e
;      -- no need to descend vectors unless they are categories
;      --REFVECP e => LIST2REFVEC [suba(p,e.i) for i in 0..MAXINDEX e]
;      isCategory e => LIST2REFVEC [suba(p,e.i) for i in 0..MAXINDEX e]
;      atom e => (y:= ASSQ(e,p) => rest y; e)
;      u:= suba(p,QCAR e)
;      v:= suba(p,QCDR e)
;      EQ(QCAR e,u) and EQ(QCDR e,v) => e
;      [u,:v]

;;;     ***       |sublisV,suba| REDEFINED

(DEFUN |sublisV,suba| (|p| |e|)
 (PROG (|y| |u| |v|)
  (RETURN
   (SEQ
    (IF (STRINGP |e|) (EXIT |e|))
    (IF (|isCategory| |e|)
     (EXIT
      (LIST2REFVEC
       (PROG (#0=#:G3936)
        (SPADLET #0# NIL)
        (RETURN
         (DO ((#1=#:G3941 (MAXINDEX |e|)) (|i| 0 (QSADD1 |i|)))
             ((QSGREATERP |i| #1#) (NREVERSE0 #0#))
          (SEQ
           (EXIT
            (SETQ #0# (CONS (|sublisV,suba| |p| (ELT |e| |i|)) #0#))))))))))
    (IF (ATOM |e|)
     (EXIT
      (SEQ
       (IF (SPADLET |y| (ASSQ |e| |p|)) (EXIT (CDR |y|))) (EXIT |e|))))
    (SPADLET |u| (|sublisV,suba| |p| (QCAR |e|)))
    (SPADLET |v| (|sublisV,suba| |p| (QCDR |e|)))
    (IF (AND (EQ (QCAR |e|) |u|) (EQ (QCDR |e|) |v|)) (EXIT |e|))
    (EXIT (CONS |u| |v|)))))) 

;;;     ***       |sublisV| REDEFINED

(DEFUN |sublisV| (|p| |e|)
 (COND ((ATOM |p|) |e|) ((QUOTE T) (|sublisV,suba| |p| |e|)))) 
;
;--% DEBUGGING PRINT ROUTINES used in breaks
;
;_?MODEMAPS x == _?modemaps x

;;;     ***       ?MODEMAPS REDEFINED

(DEFUN ?MODEMAPS (|x|) (|?modemaps| |x|)) 
;_?modemaps x ==
;  env:=
;    $insideCapsuleFunctionIfTrue=true => $CapsuleModemapFrame
;    $f
;  x="all" => displayModemaps env
;  displayOpModemaps(x,old2NewModemaps get(x,"modemap",env))

;;;     ***       |?modemaps| REDEFINED

(DEFUN |?modemaps| (|x|)
 (PROG (|env|)
  (RETURN
   (PROGN
    (SPADLET |env|
     (COND
      ((BOOT-EQUAL |$insideCapsuleFunctionIfTrue| (QUOTE T))
        |$CapsuleModemapFrame|)
      ((QUOTE T) |$f|)))
    (COND 
     ((BOOT-EQUAL |x| (QUOTE |all|)) (|displayModemaps| |env|))
     ((QUOTE T)
       (|displayOpModemaps| |x| 
        (|old2NewModemaps| (|get| |x| (QUOTE |modemap|) |env|))))))))) 
;old2NewModemaps x ==
;  [[dcSig,pred] for [dcSig,[pred,:.],:.] in x]

;;;     ***       |old2NewModemaps| REDEFINED

(DEFUN |old2NewModemaps| (|x|)
 (PROG (|dcSig| |pred|)
  (RETURN
   (SEQ 
    (PROG (#0=#:G3975)
     (SPADLET #0# NIL)
     (RETURN
      (DO ((#1=#:G3981 |x| (CDR #1#)) (#2=#:G3966 NIL))
          ((OR 
             (ATOM #1#)
             (PROGN (SETQ #2# (CAR #1#)) NIL)
             (PROGN 
              (PROGN
               (SPADLET |dcSig| (CAR #2#))
               (SPADLET |pred| (CAADR #2#))
               #2#)
              NIL))
           (NREVERSE0 #0#))
       (SEQ
        (EXIT
         (SETQ #0# (CONS (CONS |dcSig| (CONS |pred| NIL)) #0#))))))))))) 
;
;traceUp() ==
;  atom $x => sayBrightly "$x is an atom"
;  for y in rest $x repeat
;    u:= comp(y,$EmptyMode,$f) =>
;      sayBrightly [y,'" ==> mode",'%b,u.mode,'%d]
;    sayBrightly [y,'" does not compile"]

;;;     ***       |traceUp| REDEFINED

(DEFUN |traceUp| NIL
 (PROG (|u|)
  (RETURN
   (SEQ
    (COND
     ((ATOM |$x|) (|sayBrightly| (MAKESTRING "$x is an atom")))
     ((QUOTE T)
       (DO ((#0=#:G3999 (CDR |$x|) (CDR #0#)) (|y| NIL))
           ((OR (ATOM #0#) (PROGN (SETQ |y| (CAR #0#)) NIL)) NIL)
        (SEQ
         (EXIT
          (COND
           ((SPADLET |u| (|comp| |y| |$EmptyMode| |$f|))
             (|sayBrightly| 
              (CONS 
               |y| 
               (CONS 
                (MAKESTRING " ==> mode")
                (CONS
                 (QUOTE |%b|)
                 (CONS (CADR |u|) (CONS (QUOTE |%d|) NIL)))))))
           ((QUOTE T)
             (|sayBrightly| 
              (CONS |y| 
               (CONS (MAKESTRING " does not compile") NIL)))))))))))))) 
;
;_?M x == _?m x

;;;     ***       ?M REDEFINED

(DEFUN ?M (|x|) (|?m| |x|)) 
;_?m x ==
;  u:= comp(x,$EmptyMode,$f) => u.mode
;  nil

;;;     ***       |?m| REDEFINED

(DEFUN |?m| (|x|)
 (PROG (|u|)
  (RETURN
   (COND
    ((SPADLET |u| (|comp| |x| |$EmptyMode| |$f|)) (CADR |u|))
    ((QUOTE T) NIL))))) 
;
;traceDown() ==
;  mmList:= getFormModemaps($x,$f) =>
;    for mm in mmList repeat if u:= qModemap mm then return u
;  sayBrightly "no modemaps for $x"

;;;     ***       |traceDown| REDEFINED

(DEFUN |traceDown| NIL
 (PROG (|mmList| |u|)
  (RETURN
   (SEQ
    (COND
     ((SPADLET |mmList| (|getFormModemaps| |$x| |$f|))
       (DO ((#0=#:G4021 |mmList| (CDR #0#)) (|mm| NIL))
           ((OR (ATOM #0#) (PROGN (SETQ |mm| (CAR #0#)) NIL)) NIL)
        (SEQ
         (EXIT
          (COND
            ((SPADLET |u| (|qModemap| |mm|)) (RETURN |u|))
            ((QUOTE T) NIL))))))
     ((QUOTE T) (|sayBrightly| (MAKESTRING "no modemaps for $x")))))))) 
;
;qModemap mm ==
;  sayBrightly ['%b,"modemap",'%d,:formatModemap mm]
;  [[dc,target,:sl],[pred,:.]]:= mm
;  and/[qArg(a,m) for a in rest $x for m in sl] => target
;  sayBrightly ['%b,"fails",'%d,'%l]

;;;     ***       |qModemap| REDEFINED

(DEFUN |qModemap| (|mm|)
 (PROG (|dc| |target| |sl| |pred|)
  (RETURN
   (SEQ
    (PROGN
     (|sayBrightly|
       (CONS 
        (QUOTE |%b|)
        (CONS
         (MAKESTRING "modemap")
         (CONS (QUOTE |%d|) (|formatModemap| |mm|)))))
     (SPADLET |dc| (CAAR |mm|))
     (SPADLET |target| (CADAR |mm|))
     (SPADLET |sl| (CDDAR |mm|))
     (SPADLET |pred| (CAADR |mm|))
     (COND
      ((PROG (#0=#:G4038)
        (SPADLET #0# (QUOTE T))
        (RETURN
         (DO ((#1=#:G4045 NIL (NULL #0#))
              (#2=#:G4046 (CDR |$x|) (CDR #2#))
              (|a| NIL)
              (#3=#:G4047 |sl| (CDR #3#))
              (|m| NIL))
             ((OR #1# 
                 (ATOM #2#)
                 (PROGN (SETQ |a| (CAR #2#)) NIL)
                 (ATOM #3#)
                 (PROGN (SETQ |m| (CAR #3#)) NIL))
               #0#)
          (SEQ (EXIT (SETQ #0# (AND #0# (|qArg| |a| |m|))))))))
        |target|)
      ((QUOTE T) 
       (|sayBrightly| 
        (CONS 
         (QUOTE |%b|) 
         (CONS 
          (MAKESTRING "fails") 
          (CONS (QUOTE |%d|) (CONS (QUOTE |%l|) NIL)))))))))))) 
;
;qArg(a,m) ==
;  yesOrNo:=
;    u:= comp(a,m,$f) => "yes"
;    "no"
;  sayBrightly [a," --> ",m,'%b,yesOrNo,'%d]
;  yesOrNo="yes"

;;;     ***       |qArg| REDEFINED

(DEFUN |qArg| (|a| |m|)
 (PROG (|u| |yesOrNo|)
  (RETURN
   (PROGN
    (SPADLET |yesOrNo|
     (COND 
      ((SPADLET |u| (|comp| |a| |m| |$f|)) (QUOTE |yes|))
      ((QUOTE T) (QUOTE |no|))))
    (|sayBrightly| 
     (CONS 
      |a| 
      (CONS 
       (MAKESTRING " --> ") 
       (CONS 
        |m| 
        (CONS (QUOTE |%b|) (CONS |yesOrNo| (CONS (QUOTE |%d|) NIL)))))))
    (BOOT-EQUAL |yesOrNo| (QUOTE |yes|)))))) 
;
;_?COMP x == _?comp x

;;;     ***       ?COMP REDEFINED

(DEFUN ?COMP (|x|) (|?comp| |x|)) 
;_?comp x ==
;  msg:=
;    u:= comp(x,$EmptyMode,$f) =>
;      [MAKESTRING "compiles to mode",'%b,u.mode,'%d]
;    nil
;  sayBrightly msg

;;;     ***       |?comp| REDEFINED

(DEFUN |?comp| (|x|)
 (PROG (|u| |msg|)
  (RETURN
   (PROGN
    (SPADLET |msg|
     (COND
      ((SPADLET |u| (|comp| |x| |$EmptyMode| |$f|))
        (CONS 
         (MAKESTRING "compiles to mode")
         (CONS (QUOTE |%b|) (CONS (CADR |u|) (CONS (QUOTE |%d|) NIL)))))
      ((QUOTE T) NIL)))
    (|sayBrightly| |msg|))))) 
;
;_?domains() == pp getDomainsInScope $f

;;;     ***       |?domains| REDEFINED

(DEFUN |?domains| NIL (|pp| (|getDomainsInScope| |$f|))) 
;_?DOMAINS() == ?domains()

;;;     ***       ?DOMAINS REDEFINED

(DEFUN ?DOMAINS NIL (|?domains|)) 
;
;_?mode x == displayProplist(x,[["mode",:getmode(x,$f)]])

;;;     ***       |?mode| REDEFINED

(DEFUN |?mode| (|x|)
 (|displayProplist| |x|
   (CONS (CONS (QUOTE |mode|) (|getmode| |x| |$f|)) NIL))) 
;_?MODE x == _?mode x

;;;     ***       ?MODE REDEFINED

(DEFUN ?MODE (|x|) (|?mode| |x|)) 
;
;_?properties x == displayProplist(x,getProplist(x,$f))

;;;     ***       |?properties| REDEFINED

(DEFUN |?properties| (|x|) (|displayProplist| |x| (|getProplist| |x| |$f|))) 
;_?PROPERTIES x == _?properties x

;;;     ***       ?PROPERTIES REDEFINED

(DEFUN ?PROPERTIES (|x|) (|?properties| |x|)) 
;
;_?value x == displayProplist(x,[["value",:get(x,"value",$f)]])

;;;     ***       |?value| REDEFINED

(DEFUN |?value| (|x|)
 (|displayProplist| |x|
  (CONS (CONS (QUOTE |value|) (|get| |x| (QUOTE |value|) |$f|)) NIL))) 
;_?VALUE x == _?value x

;;;     ***       ?VALUE REDEFINED

(DEFUN ?VALUE (|x|) (|?value| |x|)) 
;
;displayProplist(x,alist) ==
;  sayBrightly ["properties of",'%b,x,'%d,":"]
;  fn alist where
;    fn alist ==
;      alist is [[prop,:val],:l] =>
;        if prop="value" then val:= [val.expr,val.mode,'"..."]
;        sayBrightly ["   ",'%b,prop,'%d,": ",val]
;        fn deleteAssoc(prop,l)

;;;     ***       |displayProplist,fn| REDEFINED

(DEFUN |displayProplist,fn| (|alist|)
 (PROG (|ISTMP#1| |prop| |l| |val|)
  (RETURN
   (SEQ 
    (IF
      (AND 
       (PAIRP |alist|)
       (PROGN 
        (SPADLET |ISTMP#1| (QCAR |alist|))
        (AND 
         (PAIRP |ISTMP#1|)
         (PROGN 
          (SPADLET |prop| (QCAR |ISTMP#1|))
          (SPADLET |val| (QCDR |ISTMP#1|))
          (QUOTE T))))
       (PROGN (SPADLET |l| (QCDR |alist|)) (QUOTE T)))
     (EXIT
      (SEQ
       (IF (BOOT-EQUAL |prop| (QUOTE |value|))
        (SPADLET |val|
         (CONS 
          (CAR |val|) 
          (CONS (CADR |val|) (CONS (MAKESTRING "...") NIL)))) NIL)
       (|sayBrightly| 
        (CONS 
         (MAKESTRING "   ") 
         (CONS 
          (QUOTE |%b|) 
          (CONS 
           |prop| 
           (CONS 
            (QUOTE |%d|) 
            (CONS (MAKESTRING ": ") (CONS |val| NIL)))))))
       (EXIT (|displayProplist,fn| (|deleteAssoc| |prop| |l|)))))))))) 

;;;     ***       |displayProplist| REDEFINED

(DEFUN |displayProplist| (|x| |alist|)
 (PROGN 
  (|sayBrightly|
   (CONS
    (MAKESTRING "properties of")
    (CONS
     (QUOTE |%b|)
     (CONS |x| (CONS (QUOTE |%d|) (CONS (MAKESTRING ":") NIL))))))
  (|displayProplist,fn| |alist|))) 
;
;displayModemaps E ==
;  listOfOperatorsSeenSoFar:= nil
;  for x in E for i in 1.. repeat
;    for y in x for j in 1.. repeat
;      for z in y | null MEMBER(first z,listOfOperatorsSeenSoFar) and
;        (modemaps:= LASSOC("modemap",rest z)) repeat
;          listOfOperatorsSeenSoFar:= [first z,:listOfOperatorsSeenSoFar]
;          displayOpModemaps(first z,modemaps)

;;;     ***       |displayModemaps| REDEFINED

(DEFUN |displayModemaps| (E)
 (PROG (|modemaps| |listOfOperatorsSeenSoFar|)
  (RETURN
   (SEQ
    (PROGN
     (SPADLET |listOfOperatorsSeenSoFar| NIL)
     (DO
      ((#0=#:G4136 E (CDR #0#)) (|x| NIL) (|i| 1 (QSADD1 |i|)))
      ((OR (ATOM #0#) (PROGN (SETQ |x| (CAR #0#)) NIL)) NIL)
      (SEQ
       (EXIT
        (DO ((#1=#:G4148 |x| (CDR #1#)) (|y| NIL) (|j| 1 (QSADD1 |j|)))
            ((OR (ATOM #1#) (PROGN (SETQ |y| (CAR #1#)) NIL)) NIL)
         (SEQ
          (EXIT
           (DO ((#2=#:G4160 |y| (CDR #2#)) (|z| NIL))
               ((OR (ATOM #2#) (PROGN (SETQ |z| (CAR #2#)) NIL)) NIL)
            (SEQ
             (EXIT
              (COND
               ((AND 
                 (NULL (|member| (CAR |z|) |listOfOperatorsSeenSoFar|))
                 (SPADLET |modemaps| (LASSOC (QUOTE |modemap|) (CDR |z|))))
                (PROGN 
                 (SPADLET |listOfOperatorsSeenSoFar| 
                  (CONS (CAR |z|) |listOfOperatorsSeenSoFar|))
                 (|displayOpModemaps| (CAR |z|) |modemaps|)))))))))))))))))) 
;
;--% General object traversal functions
;
;GEQSUBSTLIST(old, new, body) ==
;    GEQNSUBSTLIST(old, new, GCOPY body)

;;;     ***       GEQSUBSTLIST REDEFINED

(DEFUN GEQSUBSTLIST (|old| |new| |body|)
 (GEQNSUBSTLIST |old| |new| (GCOPY |body|))) 
;
;GEQNSUBSTLIST(old, new, body) ==
;    or/[:[EQ(o,n) for o in old] for n in new] =>
;        mid := [GENSYM() for o in old]
;        GEQNSUBSTLIST(old, mid, body)
;        GEQNSUBSTLIST(mid, new, body)
;    alist := [[o,:n] for o in old for n in new]
;    traverse(function GSUBSTinner, alist, body) where
;        GSUBSTinner(alist, ob) ==
;            (pr := ASSQ(ob, alist)) => CDR pr
;            ob

;;;     ***       |GEQNSUBSTLIST,GSUBSTinner| REDEFINED

(DEFUN |GEQNSUBSTLIST,GSUBSTinner| (|alist| |ob|)
 (PROG (|pr|)
  (RETURN
   (SEQ
    (IF (SPADLET |pr| (ASSQ |ob| |alist|)) (EXIT (CDR |pr|))) (EXIT |ob|))))) 

;;;     ***       GEQNSUBSTLIST REDEFINED

(DEFUN GEQNSUBSTLIST (|old| |new| |body|)
 (PROG (|mid| |alist|)
  (RETURN
   (SEQ
    (COND
     ((REDUCE-N (QUOTE OR2) NIL 
       (PROG (#0=#:G4183)
        (SPADLET #0# NIL)
        (RETURN
         (DO ((#1=#:G4188 |new| (CDR #1#)) (|n| NIL))
             ((OR (ATOM #1#) (PROGN (SETQ |n| (CAR #1#)) NIL)) #0#)
          (SEQ
           (EXIT
            (SETQ #0#
             (APPEND #0#
              (PROG (#2=#:G4198)
               (SPADLET #2# NIL)
               (RETURN
                (DO ((#3=#:G4203 |old| (CDR #3#)) (|o| NIL))
                    ((OR (ATOM #3#) (PROGN (SETQ |o| (CAR #3#)) NIL))
                     (NREVERSE0 #2#))
                 (SEQ (EXIT (SETQ #2# (CONS (EQ |o| |n|) #2#))))))))))))))
        NIL)
       (SPADLET |mid|
        (PROG (#4=#:G4213)
         (SPADLET #4# NIL)
         (RETURN
          (DO ((#5=#:G4218 |old| (CDR #5#)) (|o| NIL))
              ((OR (ATOM #5#) (PROGN (SETQ |o| (CAR #5#)) NIL))
               (NREVERSE0 #4#))
           (SEQ (EXIT (SETQ #4# (CONS (GENSYM) #4#))))))))
       (GEQNSUBSTLIST |old| |mid| |body|)
       (GEQNSUBSTLIST |mid| |new| |body|))
     ((QUOTE T)
       (SPADLET |alist|
        (PROG (#6=#:G4229)
         (SPADLET #6# NIL)
         (RETURN
          (DO ((#7=#:G4235 |old| (CDR #7#))
               (|o| NIL)
               (#8=#:G4236 |new| (CDR #8#))
               (|n| NIL))
              ((OR (ATOM #7#)
                   (PROGN (SETQ |o| (CAR #7#)) NIL)
                   (ATOM #8#)
                   (PROGN (SETQ |n| (CAR #8#)) NIL))
               (NREVERSE0 #6#))
           (SEQ (EXIT (SETQ #6# (CONS (CONS |o| |n|) #6#))))))))
       (|traverse|
        (|function| |GEQNSUBSTLIST,GSUBSTinner|) |alist| |body|))))))) 
;
;GCOPY ob == COPY ob  -- for now

;;;     ***       GCOPY REDEFINED

(DEFUN GCOPY (|ob|) (COPY |ob|)) 
;
;traverse(fn, arg, ob) ==
;    $seen:    local := MAKE_-HASHTABLE 'EQ
;    $notseen: local := GENSYM()
;
;    traverseInner(ob, fn, arg) where
;        traverseInner(ob, fn, arg) ==
;            e := HGET($seen, ob, $notseen)
;            not EQ(e, $notseen) => e
;
;            nob := FUNCALL(fn, arg, ob)
;            HPUT($seen, ob, nob)
;            not EQ(nob, ob) => nob
;            PAIRP ob =>
;                ne:=traverseInner(QCAR ob, fn, arg)
;                if not EQ(ne,QCAR ob) then QRPLACA(ob, ne)
;                ne:=traverseInner(QCDR ob, fn, arg)
;                if not EQ(ne,QCDR ob) then QRPLACD(ob, ne)
;                ob
;            VECP ob =>
;                n := QVMAXINDEX ob
;                for i in 0..n repeat
;                    e:=QVELT(ob,i)
;                    ne:=traverseInner(e, fn, arg)
;                    if not EQ(ne,e) then QSETVELT(ob,i,ne)
;                ob
;            HASHTABLEP ob =>
;                keys := HKEYS ob
;                for k in keys repeat
;                    e  := HGET(ob, k)
;                    nk := traverseInner(k, fn, arg)
;                    ne := traverseInner(e, fn, arg)
;                    if not EQ(k,nk) or not EQ(e,ne) then
;                        HREM(ob, k)
;                        HPUT(ob, nk, ne)
;                ob
;            PAPPP ob =>
;                for i in 1..PA_-SPEC_-COUNT ob repeat
;                    s := PA_-SPEC(ob, i)
;                    not PAIRP s =>
;                        ns := traverseInner(s,fn,arg)
;                        if not EQ(s,ns) then
;                            SET_-PA_-SPEC(ob,i,ns)
;                    ns := traverseInner(QCDR s, fn, arg)
;                    if not EQ(ns,QCDR s) then
;                       apply(SET_-PA_-SPEC, [ob,i,QCAR s,:ns])
;                ob
;            ob

;;;     ***       |traverse,traverseInner| REDEFINED

(DEFUN |traverse,traverseInner| (|ob| |fn| |arg|)
 (PROG (|nob| |n| |keys| |e| |nk| |ne| |s| |ns|)
  (RETURN
   (SEQ
    (SPADLET |e| (HGET |$seen| |ob| |$notseen|))
    (IF (NULL (EQ |e| |$notseen|)) (EXIT |e|))
    (SPADLET |nob| (FUNCALL |fn| |arg| |ob|))
    (HPUT |$seen| |ob| |nob|)
    (IF (NULL (EQ |nob| |ob|)) (EXIT |nob|))
    (IF (PAIRP |ob|)
     (EXIT
      (SEQ
       (SPADLET |ne| (|traverse,traverseInner| (QCAR |ob|) |fn| |arg|))
       (IF (NULL (EQ |ne| (QCAR |ob|))) (QRPLACA |ob| |ne|) NIL)
       (SPADLET |ne| (|traverse,traverseInner| (QCDR |ob|) |fn| |arg|))
       (IF (NULL (EQ |ne| (QCDR |ob|))) (QRPLACD |ob| |ne|) NIL)
       (EXIT |ob|))))
    (IF (VECP |ob|)
     (EXIT
      (SEQ
       (SPADLET |n| (QVMAXINDEX |ob|))
       (DO ((|i| 0 (QSADD1 |i|)))
           ((QSGREATERP |i| |n|) NIL)
        (SEQ
         (SPADLET |e| (QVELT |ob| |i|))
         (SPADLET |ne| (|traverse,traverseInner| |e| |fn| |arg|))
         (EXIT (IF (NULL (EQ |ne| |e|)) (QSETVELT |ob| |i| |ne|) NIL))))
       (EXIT |ob|))))
    (IF (HASHTABLEP |ob|)
     (EXIT
      (SEQ
       (SPADLET |keys| (HKEYS |ob|))
       (DO ((#0=#:G4276 |keys| (CDR #0#)) (|k| NIL))
           ((OR (ATOM #0#) (PROGN (SETQ |k| (CAR #0#)) NIL)) NIL)
        (SEQ
         (SPADLET |e| (HGET |ob| |k|))
         (SPADLET |nk| (|traverse,traverseInner| |k| |fn| |arg|))
         (SPADLET |ne| (|traverse,traverseInner| |e| |fn| |arg|))
         (EXIT
          (IF (OR (NULL (EQ |k| |nk|)) (NULL (EQ |e| |ne|)))
           (SEQ 
            (HREM |ob| |k|)
            (EXIT (HPUT |ob| |nk| |ne|))) NIL)))) (EXIT |ob|))))
    (IF (PAPPP |ob|)
     (EXIT
      (SEQ
       (DO ((#1=#:G4285 (PA-SPEC-COUNT |ob|)) (|i| 1 (QSADD1 |i|)))
           ((QSGREATERP |i| #1#) NIL)
        (SEQ
         (SPADLET |s| (PA-SPEC |ob| |i|))
         (IF (NULL (PAIRP |s|))
          (EXIT
           (SEQ
            (SPADLET |ns| (|traverse,traverseInner| |s| |fn| |arg|))
            (EXIT (IF (NULL (EQ |s| |ns|)) (SET-PA-SPEC |ob| |i| |ns|) NIL)))))
         (SPADLET |ns| (|traverse,traverseInner| (QCDR |s|) |fn| |arg|))
         (EXIT
          (IF (NULL (EQ |ns| (QCDR |s|)))
           (APPLY SET-PA-SPEC (CONS |ob| (CONS |i| (CONS (QCAR |s|) |ns|))))
           NIL))))
       (EXIT |ob|))))
    (EXIT |ob|))))) 

;;;     ***       |traverse| REDEFINED

(DEFUN |traverse| (|fn| |arg| |ob|)
 (PROG (|$seen| |$notseen|)
  (DECLARE (SPECIAL |$seen| |$notseen|))
   (RETURN
    (PROGN
     (SPADLET |$seen| (MAKE-HASHTABLE (QUOTE EQ)))
     (SPADLET |$notseen| (GENSYM))
     (|traverse,traverseInner| |ob| |fn| |arg|))))) 
;;;Boot translation finished for c-util.boot
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
