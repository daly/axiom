\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra files.spad}
\author{Stephen M. Watt, Victor Miller, Barry Trager}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{category FILECAT FileCategory}
<<category FILECAT FileCategory>>=
)abbrev category FILECAT FileCategory
++ Author: Stephen M. Watt, Victor Miller
++ Date Created: 
++ Date Last Updated: June 4, 1991
++ Basic Operations: 
++ Related Domains: File 
++ Also See:
++ AMS Classifications:
++ Keywords: 
++ Examples:
++ References:
++ Description:
++   This category provides an interface to operate on files in the
++   computer's file system.  The precise method of naming files
++   is determined by the Name parameter.  The type of the contents
++   of the file is determined by S.
 
FileCategory(Name, S): Category == FCdefinition where
    Name:      SetCategory
    S:         SetCategory
    IOMode ==> String  -- Union("input", "output", "closed")
 
    FCdefinition == SetCategory with
        open: Name -> %
          ++ open(s) returns the file s open for input.  

        open: (Name, IOMode) -> %
          ++ open(s,mode) returns a file s open for operation in the 
          ++ indicated mode: "input" or "output".

        reopen_!: (%, IOMode) -> %
          ++ reopen!(f,mode) returns a file f reopened for operation in the
          ++ indicated mode: "input" or "output".
          ++ \spad{reopen!(f,"input")} will reopen the file f for input.

        close_!: % -> %
          ++ close!(f) returns the file f closed to input and output.
 
        name: % -> Name
          ++ name(f) returns the external name of the file f.

        iomode: % -> IOMode
          ++ iomode(f) returns the status of the file f. The input/output 
          ++ status of f may be "input", "output" or "closed" mode.
 
        read_!: % -> S
          ++ read!(f) extracts a value from file f.  The state of f is
          ++ modified so a subsequent call to \spadfun{read!} will return
          ++ the next element.

        write_!: (%,S) -> S
          ++ write!(f,s) puts the value s into the file f. 
          ++ The state of f is modified so subsequents call to \spad{write!}
          ++ will append one after another.
 
@
\section{domain FILE File}
<<File.input>>=
-- files.spad.pamphlet File.input
)spool File.output
)set message test on
)set message auto off
)clear all
--S 1
ifile:File List Integer:=open("jazz1","output") 
--R 
--R
--R   (1)  "jazz1"
--R                                                      Type: File List Integer
--E 1

--S 2
write!(ifile, [-1,2,3])
--R 
--R
--R   (2)  [- 1,2,3]
--R                                                           Type: List Integer
--E 2

--S 3
write!(ifile, [10,-10,0,111])
--R 
--R
--R   (3)  [10,- 10,0,111]
--R                                                           Type: List Integer
--E 3

--S 4
write!(ifile, [7])
--R 
--R
--R   (4)  [7]
--R                                                           Type: List Integer
--E 4

--S 5
reopen!(ifile, "input")
--R 
--R
--R   (5)  "jazz1"
--R                                                      Type: File List Integer
--E 5

--S 6
read! ifile
--R 
--R
--R   (6)  [- 1,2,3]
--R                                                           Type: List Integer
--E 6

--S 7
read! ifile
--R 
--R
--R   (7)  [10,- 10,0,111]
--R                                                           Type: List Integer
--E 7

--S 8
readIfCan! ifile 
--R 
--R
--R   (8)  [7]
--R                                                Type: Union(List Integer,...)
--E 8

--S 9
readIfCan! ifile
--R 
--R
--R   (9)  "failed"
--R                                                    Type: Union("failed",...)
--E 9

--S 10
iomode ifile
--R 
--R
--R   (10)  "input"
--R                                                                 Type: String
--E 10

--S 11
name ifile
--R 
--R
--R   (11)  "jazz1"
--R                                                               Type: FileName
--E 11

--S 12
close! ifile
--R 
--R
--R   (12)  "jazz1"
--R                                                      Type: File List Integer
--E 12
)system rm jazz1
)spool
)lisp (bye)
@
<<File.help>>=
====================================================================
File examples
====================================================================

The File(S) domain provides a basic interface to read and write values
of type S in files.

Before working with a file, it must be made accessible to Axiom with
the open operation.

  ifile:File List Integer:=open("/tmp/jazz1","output") 
    "jazz1"
                         Type: File List Integer

The open function arguments are a FileNam} and a String specifying the
mode.  If a full pathname is not specified, the current default
directory is assumed.  The mode must be one of "input" or "output".
If it is not specified, "input" is assumed.  Once the file has been
opened, you can read or write data.

The operations read and write are provided.

  write!(ifile, [-1,2,3])
    [- 1,2,3]
                         Type: List Integer

  write!(ifile, [10,-10,0,111])
    [10,- 10,0,111]
                         Type: List Integer

  write!(ifile, [7])
    [7]
                         Type: List Integer

You can change from writing to reading (or vice versa) by reopening a file.

  reopen!(ifile, "input")
    "jazz1"
                         Type: File List Integer

  read! ifile
    [- 1,2,3]
                         Type: List Integer

  read! ifile
    [10,- 10,0,111]
                         Type: List Integer

The read operation can cause an error if one tries to read more data
than is in the file.  To guard against this possibility the readIfCan
operation should be used.

  readIfCan! ifile 
    [7]
                         Type: Union(List Integer,...)

  readIfCan! ifile
    "failed"
                         Type: Union("failed",...)

You can find the current mode of the file, and the file's name.

  iomode ifile
    "input"
                         Type: String

  name ifile
    "jazz1"
                         Type: FileName

When you are finished with a file, you should close it.

  close! ifile
    "jazz1"
                         Type: File List Integer

  )system rm /tmp/jazz1

A limitation of the underlying LISP system is that not all values can
be represented in a file.  In particular, delayed values containing
compiled functions cannot be saved.

See Also:
o )help TextFile
o )help KeyedAccessFile
o )help Library
o )help Filename
o )show File
o $AXIOM/doc/src/algebra/files.spad.dvi

@
<<domain FILE File>>=
)abbrev domain FILE File
++ Author: Stephen M. Watt, Victor Miller
++ Date Created: 1984
++ Date Last Updated: June 4, 1991
++ Basic Operations: 
++ Related Domains: 
++ Also See:
++ AMS Classifications:
++ Keywords: 
++ Examples:
++ References:
++ Description:
++   This domain provides a basic model of files to save arbitrary values.
++   The operations provide sequential access to the contents.
 
File(S:SetCategory): FileCategory(FileName, S) with
        readIfCan_!: % -> Union(S, "failed")
            ++ readIfCan!(f) returns a value from the file f, if possible.
            ++ If f is not open for reading, or if f is at the end of file
            ++ then \spad{"failed"} is the result.
    == add
        FileState ==> SExpression
        IOMode    ==> String
 
        Rep:=Record(fileName:    FileName,   _
                    fileState:   FileState,  _
                    fileIOmode:  IOMode)
 
        defstream(fn: FileName, mode: IOMode): FileState ==
            mode = "input"  =>
              not readable? fn => error ["File is not readable", fn]
              MAKE_-INSTREAM(fn::String)$Lisp
            mode = "output" =>
              not writable? fn => error ["File is not writable", fn]
              MAKE_-OUTSTREAM(fn::String)$Lisp
            error ["IO mode must be input or output", mode]
 
        f1 = f2 ==
            f1.fileName = f2.fileName
        coerce(f: %): OutputForm ==
            f.fileName::OutputForm
 
        open fname ==
            open(fname, "input")
        open(fname, mode) ==
            fstream := defstream(fname, mode)
            [fname, fstream, mode]
        reopen_!(f, mode) ==
            fname := f.fileName
            f.fileState := defstream(fname, mode)
            f.fileIOmode:= mode
            f
        close_! f ==
            SHUT(f.fileState)$Lisp
            f.fileIOmode := "closed"
            f
        name f ==
            f.fileName
        iomode f ==
            f.fileIOmode
        read_! f ==
            f.fileIOmode ^= "input" =>
                error "File not in read state"
            x := VMREAD(f.fileState)$Lisp
            PLACEP(x)$Lisp =>
                error "End of file"
            x
        readIfCan_! f ==
            f.fileIOmode ^= "input" =>
                error "File not in read state"
            x: S := VMREAD(f.fileState)$Lisp
            PLACEP(x)$Lisp => "failed"
            x
        write_!(f, x) ==
            f.fileIOmode ^= "output" =>
                error "File not in write state"
            z := PRINT_-FULL(x, f.fileState)$Lisp
            TERPRI(f.fileState)$Lisp
            x

@
\section{domain TEXTFILE TextFile}
<<domain TEXTFILE TextFile>>=
)abbrev domain TEXTFILE TextFile
++ Author: Stephen M. Watt
++ Date Created: 1985
++ Date Last Updated: June 4, 1991
++ Basic Operations: writeLine! readLine! readLineIfCan! readIfCan! endOfFile?
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords: 
++ References:
++ Description: 
++   This domain provides an implementation of text files.  Text is stored
++   in these files using the native character set of the computer.

TextFile: Cat == Def where
    StreamName ==> Union(FileName, "console")
 
    Cat == FileCategory(FileName, String) with
        writeLine_!: (%, String) -> String
          ++ writeLine!(f,s) writes the contents of the string s 
          ++ and finishes the current line in the file f.
          ++ The value of s is returned.

        writeLine_!: % -> String
          ++ writeLine!(f) finishes the current line in the file f.
          ++ An empty string is returned.  The call \spad{writeLine!(f)} is
          ++ equivalent to \spad{writeLine!(f,"")}.

        readLine_!: % -> String
          ++ readLine!(f) returns a string of the contents of a line from 
          ++ the file f.

        readLineIfCan_!: % -> Union(String, "failed")
          ++ readLineIfCan!(f) returns a string of the contents of a line from
          ++ file f, if possible.  If f is not readable or if it is 
          ++ positioned at the end of file, then \spad{"failed"} is returned.

        readIfCan_!: % -> Union(String, "failed")
          ++ readIfCan!(f) returns a string of the contents of a line from
          ++ file f, if possible.  If f is not readable or if it is 
          ++ positioned at the end of file, then \spad{"failed"} is returned.

        endOfFile?: % -> Boolean
          ++ endOfFile?(f) tests whether the file f is positioned after the
          ++ end of all text.  If the file is open for output, then
          ++ this test is always true.
 
    Def == File(String) add
        FileState ==> SExpression
 
        Rep := Record(fileName:   FileName,    _
                      fileState:  FileState,   _
                      fileIOmode: String)
 
        read_! f      == readLine_! f
        readIfCan_! f == readLineIfCan_! f
 
        readLine_! f ==
            f.fileIOmode ^= "input"  => error "File not in read state"
            s: String := read_-line(f.fileState)$Lisp
            PLACEP(s)$Lisp => error "End of file"
            s
        readLineIfCan_! f ==
            f.fileIOmode ^= "input"  => error "File not in read state"
            s: String := read_-line(f.fileState)$Lisp
            PLACEP(s)$Lisp => "failed"
            s
        write_!(f, x) ==
            f.fileIOmode ^= "output" => error "File not in write state"
            PRINTEXP(x, f.fileState)$Lisp
            x
        writeLine_! f ==
            f.fileIOmode ^= "output" => error "File not in write state"
            TERPRI(f.fileState)$Lisp
            ""
        writeLine_!(f, x) ==
            f.fileIOmode ^= "output" => error "File not in write state"
            PRINTEXP(x, f.fileState)$Lisp
            TERPRI(f.fileState)$Lisp
            x
        endOfFile? f ==
          f.fileIOmode = "output" => false
          (EOFP(f.fileState)$Lisp pretend Boolean) => true
          false

@
\section{domain BINFILE BinaryFile}
<<domain BINFILE BinaryFile>>=
)abbrev domain BINFILE BinaryFile
++ Author: Barry M. Trager
++ Date Created: 1993
++ Date Last Updated:
++ Basic Operations: writeByte! readByte! readByteIfCan!
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords: 
++ References:
++ Description: 
++   This domain provides an implementation of binary files. Data is
++   accessed one byte at a time as a small integer.

BinaryFile: Cat == Def where
 
    Cat == FileCategory(FileName, SingleInteger) with
        readIfCan_!: % -> Union(SingleInteger, "failed")
            ++ readIfCan!(f) returns a value from the file f, if possible.
            ++ If f is not open for reading, or if f is at the end of file
            ++ then \spad{"failed"} is the result.

--      "#": % -> SingleInteger
--          ++ #(f) returns the length of the file f in bytes.

        position: % -> SingleInteger
            ++ position(f) returns the current byte-position in the file f.

        position_!: (%, SingleInteger) -> SingleInteger
            ++ position!(f, i) sets the current byte-position to i.

    Def == File(SingleInteger) add
        FileState ==> SExpression
 
        Rep := Record(fileName:   FileName,    _
                      fileState:  FileState,   _
                      fileIOmode: String)
 
--      direc : Symbol := INTERN("DIRECTION","KEYWORD")$Lisp
--      input : Symbol := INTERN("INPUT","KEYWORD")$Lisp
--      output : Symbol := INTERN("OUTPUT","KEYWORD")$Lisp
--      eltype : Symbol := INTERN("ELEMENT-TYPE","KEYWORD")$Lisp
--      bytesize : SExpression := LIST(QUOTE(UNSIGNED$Lisp)$Lisp,8)$Lisp
   

        defstream(fn: FileName, mode: String): FileState ==
            mode = "input"  =>
              not readable? fn => error ["File is not readable", fn]
              BINARY__OPEN__INPUT(fn::String)$Lisp
--            OPEN(fn::String, direc, input, eltype, bytesize)$Lisp
            mode = "output" =>
              not writable? fn => error ["File is not writable", fn]
              BINARY__OPEN__OUTPUT(fn::String)$Lisp
--            OPEN(fn::String, direc, output, eltype, bytesize)$Lisp
            error ["IO mode must be input or output", mode]

        open(fname, mode) ==
            fstream := defstream(fname, mode)
            [fname, fstream, mode]

        reopen_!(f, mode) ==
            fname := f.fileName
            f.fileState := defstream(fname, mode)
            f.fileIOmode:= mode
            f

        close_! f ==
            f.fileIOmode = "output" => 
                 BINARY__CLOSE__OUTPUT()$Lisp
                 f
            f.fileIOmode = "input" => 
                  BINARY__CLOSE__INPUT()$Lisp
                  f
            error "file must be in read or write state"

        read! f ==
            f.fileIOmode ^= "input"  => error "File not in read state"
            BINARY__SELECT__INPUT(f.fileState)$Lisp 
            BINARY__READBYTE()$Lisp
--          READ_-BYTE(f.fileState)$Lisp
        readIfCan_! f ==
            f.fileIOmode ^= "input"  => error "File not in read state"
            BINARY__SELECT__INPUT(f.fileState)$Lisp 
            n:SingleInteger:=BINARY__READBYTE()$Lisp
            n = -1 => "failed"
            n::Union(SingleInteger,"failed")
--          READ_-BYTE(f.fileState,NIL$Lisp,
--                   "failed"::Union(SingleInteger,"failed"))$Lisp
        write_!(f, x) ==
            f.fileIOmode ^= "output" => error "File not in write state"
            x < 0 or x>255 => error "integer cannot be represented as a byte"
            BINARY__PRINBYTE(x)$Lisp
--          WRITE_-BYTE(x, f.fileState)$Lisp
            x

--      # f == FILE_-LENGTH(f.fileState)$Lisp
        position f == 
           f.fileIOmode ^= "input"  => error "file must be in read state"
           FILE_-POSITION(f.fileState)$Lisp
        position_!(f,i) == 
           f.fileIOmode ^= "input"  => error "file must be in read state"
           (FILE_-POSITION(f.fileState,i)$Lisp ; i) 

@
\section{domain KAFILE KeyedAccessFile}
<<KeyedAccessFile.input>>=
-- files.spad.pamphlet KeyedAccessFile.input
)spool KeyedAccessFile.output
)set message test on
)set message auto off
)clear all
ey: KeyedAccessFile(Integer) := open("editor.year", "output")
ey."Char":= 1986
ey."Caviness" := 1985
ey."Fitch"    := 1984
ey."Char"
ey("Char")
ey "Char"
search("Char", ey)
search("Smith", ey)
remove!("Char", ey)
keys ey
#ey
KE := Record(key: String, entry: Integer)
reopen!(ey, "output")
write!(ey, ["van Hulzen", 1983]$KE)
write!(ey, ["Calmet", 1982]$KE)
write!(ey, ["Wang", 1981]$KE)
close! ey
keys ey
members ey
)system rm -r editor.year
)spool
)lisp (bye)
@
<<KeyedAccessFile.help>>=
\section{KeyedAccessFile}
\label{KeyedAccessFileXmpPage}

The domain KeyedAccessFile(S) provides files which can be used
as associative tables.  Data values are stored in these files and can
be retrieved according to their keys.  The keys must be strings so
this type behaves very much like the StringTable(S) domain.  The
difference is that keyed access files reside in secondary storage
while string tables are kept in memory.  

Before a keyed access file can be used, it must first be opened.
A new file can be created by opening it for output.

  ey: KeyedAccessFile(Integer) := open("editor.year", "output")

Just as for vectors, tables or lists, values are saved in a keyed
access file by setting elements.

  ey."Char":= 1986

  ey."Caviness" := 1985

  ey."Fitch"    := 1984

Values are retrieved using application, in any of its syntactic forms.

  ey."Char"

  ey("Char")

  ey "Char"

Attempting to retrieve a non-existent element in this way causes an
error.  If it is not known whether a key exists, you should use the
search operation.

  search("Char", ey)

  search("Smith", ey)

When an entry is no longer needed, it can be removed from the file.

  remove!("Char", ey)

The keys operation returns a list of all the keys for a given file.

  keys ey

The # operation gives the number of entries.

  #ey

The table view of keyed access files provides safe operations.  That
is, if the Axiom program is terminated between file operations, the
file is left in a consistent, current state.  This means, however,
that the operations are somewhat costly.  For example, after each
update the file is closed.

Here we add several more items to the file, then check its contents.

  KE := Record(key: String, entry: Integer)

  reopen!(ey, "output")

If many items are to be added to a file at the same time, then it is
more efficient to use the write operation.

  write!(ey, ["van Hulzen", 1983]$KE)

  write!(ey, ["Calmet", 1982]$KE)

  write!(ey, ["Wang", 1981]$KE)

  close! ey

The read operation is also available from the file view, but it
returns elements in a random order.  It is generally clearer and more
efficient to use the keys operation and to extract elements by key.

  keys ey

  members ey

  )system rm -r editor.year

See Also:
o )help Table
o )help StringTable
o )help File
o )help TextFile
o )help Library
o )show KeyedAccessFile
o $AXIOM/doc/src/algebra/files.spad.dvi

@
<<domain KAFILE KeyedAccessFile>>=
)abbrev domain KAFILE KeyedAccessFile
++ Author: Stephen M. Watt
++ Date Created: 1985
++ Date Last Updated: June 4, 1991
++ Basic Operations: 
++ Related Domains: 
++ Also See:
++ AMS Classifications:
++ Keywords: 
++ Examples:
++ References:
++ Description:
++  This domain allows a random access file to be viewed both as a table
++  and as a file object.
 
 
KeyedAccessFile(Entry): KAFcategory == KAFcapsule where
    Name  ==> FileName
    Key   ==> String
    Entry :   SetCategory
 
    KAFcategory ==
        Join(FileCategory(Name, Record(key: Key, entry: Entry)),
             TableAggregate(Key, Entry)) with
                 finiteAggregate
                 pack_!: % -> %
                     ++ pack!(f) reorganizes the file f on disk to recover 
                     ++ unused space.
 
    KAFcapsule == add
 
        CLASS     ==> 131   -- an arbitrary no. greater than 127
        FileState ==> SExpression
        IOMode    ==> String
 
 
        Cons:= Record(car: SExpression, cdr: SExpression)
        Rep := Record(fileName:    Name,     _
                      fileState:   FileState,   _
                      fileIOmode:  IOMode)
 
        defstream(fn: Name, mode: IOMode): FileState ==
            mode = "input"  =>
              not readable? fn => error ["File is not readable", fn]
              RDEFINSTREAM(fn::String)$Lisp
            mode = "output" =>
              not writable? fn => error ["File is not writable", fn]
              RDEFOUTSTREAM(fn::String)$Lisp
            error ["IO mode must be input or output", mode]
 
        ---- From Set ----
        f1 = f2 ==
            f1.fileName = f2.fileName
        coerce(f: %): OutputForm ==
            f.fileName::OutputForm
 
        ---- From FileCategory ----
        open fname ==
            open(fname, "either")
        open(fname, mode) ==
            mode = "either" =>
                exists? fname =>
                    open(fname, "input")
                writable? fname =>
                    reopen_!(open(fname, "output"), "input")
                error "File does not exist and cannot be created"
            [fname, defstream(fname, mode), mode]
        reopen_!(f, mode) ==
            close_! f
            if mode ^= "closed" then
                f.fileState := defstream(f.fileName, mode)
                f.fileIOmode  := mode
            f
        close_! f  ==
            if f.fileIOmode ^= "closed" then
                RSHUT(f.fileState)$Lisp
                f.fileIOmode  := "closed"
            f
        read_! f ==
            f.fileIOmode ^= "input" => error ["File not in read state",f]
            ks: List Symbol := RKEYIDS(f.fileName)$Lisp
            null ks => error ["Attempt to read empty file", f]
            ix := random()$Integer rem #ks
            k: String := PNAME(ks.ix)$Lisp
            [k, SPADRREAD(k, f.fileState)$Lisp]
        write_!(f, pr) ==
            f.fileIOmode ^= "output" => error ["File not in write state",f]
            SPADRWRITE(pr.key, pr.entry, f.fileState)$Lisp
            pr
        name f ==
            f.fileName
        iomode f ==
            f.fileIOmode
 
        ---- From TableAggregate ----
        empty() ==
            fn := new("", "kaf", "sdata")$Name
            open fn
        keys f ==
            close_! f
            l: List SExpression := RKEYIDS(f.fileName)$Lisp
            [PNAME(n)$Lisp for n in l]
        # f ==
            # keys f
        elt(f,k) ==
            reopen_!(f, "input")
            SPADRREAD(k, f.fileState)$Lisp
        setelt(f,k,e) ==
            -- Leaves f in a safe, closed state.  For speed use "write".
            reopen_!(f, "output")
            UNWIND_-PROTECT(write_!(f, [k,e]), close_! f)$Lisp
            close_! f
            e
        search(k,f) ==
            not member?(k, keys f) => "failed"   -- can't trap RREAD error
            reopen_!(f, "input")
            (SPADRREAD(k, f.fileState)$Lisp)@Entry
        remove_!(k:String,f:%)  ==
            result := search(k,f)
            result case "failed" => result
            close_! f
            RDROPITEMS(NAMESTRING(f.fileName)$Lisp, LIST(k)$Lisp)$Lisp
            result
        pack_! f ==
            close_! f
            RPACKFILE(f.fileName)$Lisp
            f

@
\section{domain LIB Library}
<<Library.input>>=
-- files.spad.pamphlet Library.input
)spool Library.output
)set message test on
)set message auto off
)clear all
stuff := library "Neat.stuff"
stuff.int := 32**2
stuff."poly" := x**2 + 1
stuff.str := "Hello"
keys stuff
stuff.poly
stuff("poly")
)system rm -rf Neat.stuff
)spool
)lisp (bye)
@
<<Library.help>>=
====================================================================
Library examples
====================================================================
 
The Library domain provides a simple way to store Axiom values
in a file.  This domain is similar to KeyedAccessFile but fewer
declarations are needed and items of different types can be saved
together in the same file.

To create a library, you supply a file name.

  stuff := library "Neat.stuff"

Now values can be saved by key in the file.  The keys should be
mnemonic, just as the field names are for records.  They can be given
either as strings or symbols.

  stuff.int := 32**2

  stuff."poly" := x**2 + 1

  stuff.str := "Hello"

You obtain the set of available keys using the keys operation.

  keys stuff

You extract values by giving the desired key in this way.

  stuff.poly

  stuff("poly")

When the file is no longer needed, you should remove it from the
file system.

  )system rm -rf Neat.stuff
 
See Also:
o )help File
o )help TextFile
o )help KeyedAccessFile
o )show Library
o $AXIOM/doc/src/algebra/files.spad.dvi

@
<<domain LIB Library>>=
)abbrev domain LIB Library
++ Author: Stephen M. Watt
++ Date Created: 1985
++ Date Last Updated: June 4, 1991
++ Basic Operations: 
++ Related Domains: KeyedAccessFile
++ Also See:
++ AMS Classifications:
++ Keywords: 
++ Examples:
++ References:
++ Description:
++   This domain provides a simple way to save values in files.
Library(): TableAggregate(String, Any) with
         library:  FileName -> %
             ++ library(ln) creates a new library file.
         pack_!: % -> %
             ++ pack!(f) reorganizes the file f on disk to recover 
             ++ unused space.

         elt : (%, Symbol) -> Any
             ++ elt(lib,k) or lib.k  extracts the value corresponding to the key \spad{k}
             ++ from the library \spad{lib}.

         setelt : (%, Symbol, Any) -> Any
             ++ \spad{lib.k := v} saves the value \spad{v} in the library
             ++ \spad{lib}.  It can later be extracted using the key \spad{k}.

         close_!: % -> %
          ++ close!(f) returns the library f closed to input and output.

    == KeyedAccessFile(Any) add
         Rep := KeyedAccessFile(Any)
         library f == open f
         elt(f:%,v:Symbol) == elt(f, string v)
         setelt(f:%, v:Symbol, val:Any) == setelt(f, string v, val)

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>

<<category FILECAT FileCategory>>
<<domain FILE File>>
<<domain TEXTFILE TextFile>>
<<domain BINFILE BinaryFile>>
<<domain KAFILE KeyedAccessFile>>
<<domain LIB Library>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
