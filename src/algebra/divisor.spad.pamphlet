\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra divisor.spad}
\author{Manuel Bronstein}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{package FRIDEAL2 FractionalIdealFunctions2}
<<package FRIDEAL2 FractionalIdealFunctions2>>=
)abbrev package FRIDEAL2 FractionalIdealFunctions2
++ Lifting of morphisms to fractional ideals.
++ Author: Manuel Bronstein
++ Date Created: 1 Feb 1989
++ Date Last Updated: 27 Feb 1990
++ Keywords: ideal, algebra, module.
FractionalIdealFunctions2(R1, F1, U1, A1, R2, F2, U2, A2):
 Exports == Implementation where
  R1, R2: EuclideanDomain
  F1: QuotientFieldCategory R1
  U1: UnivariatePolynomialCategory F1
  A1: Join(FramedAlgebra(F1, U1), RetractableTo F1)
  F2: QuotientFieldCategory R2
  U2: UnivariatePolynomialCategory F2
  A2: Join(FramedAlgebra(F2, U2), RetractableTo F2)

  Exports ==> with
    map: (R1 -> R2, FractionalIdeal(R1, F1, U1, A1)) ->
                                         FractionalIdeal(R2, F2, U2, A2)
	++ map(f,i) \undocumented{}

  Implementation ==> add
    fmap: (F1 -> F2, A1) -> A2

    fmap(f, a) ==
      v := coordinates a
      represents
        [f qelt(v, i) for i in minIndex v .. maxIndex v]$Vector(F2)

    map(f, i) ==
      b := basis i
      ideal [fmap(f(numer #1) / f(denom #1), qelt(b, j))
             for j in minIndex b .. maxIndex b]$Vector(A2)

@
\section{package MHROWRED ModularHermitianRowReduction}
<<package MHROWRED ModularHermitianRowReduction>>=
)abbrev package MHROWRED ModularHermitianRowReduction
++ Modular hermitian row reduction.
++ Author: Manuel Bronstein
++ Date Created: 22 February 1989
++ Date Last Updated: 24 November 1993
++ Keywords: matrix, reduction.
-- should be moved into matrix whenever possible
ModularHermitianRowReduction(R): Exports == Implementation where
  R: EuclideanDomain

  Z   ==> Integer
  V   ==> Vector R
  M   ==> Matrix R
  REC ==> Record(val:R, cl:Z, rw:Z)

  Exports ==> with
    rowEch       : M -> M
      ++ rowEch(m) computes a modular row-echelon form of m, finding
      ++ an appropriate modulus.
    rowEchelon   : (M, R) -> M
      ++ rowEchelon(m, d) computes a modular row-echelon form mod d of
      ++    [d     ]
      ++    [  d   ]
      ++    [    . ]
      ++    [     d]
      ++    [   M  ]
      ++ where \spad{M = m mod d}.
    rowEchLocal    : (M, R) -> M
      ++ rowEchLocal(m,p) computes a modular row-echelon form of m, finding
      ++ an appropriate modulus over a local ring where p is the only prime.
    rowEchelonLocal: (M, R, R) -> M
      ++ rowEchelonLocal(m, d, p) computes the row-echelon form of m
      ++ concatenated with d times the identity matrix
      ++ over a local ring where p is the only prime.
    normalizedDivide: (R, R) -> Record(quotient:R, remainder:R)
      ++ normalizedDivide(n,d) returns a normalized quotient and
      ++ remainder such that consistently unique representatives
      ++ for the residue class are chosen, e.g. positive remainders



  Implementation ==> add
    order   : (R, R) -> Z
    vconc   : (M, R) -> M
    non0    : (V, Z) -> Union(REC, "failed")
    nonzero?: V -> Boolean
    mkMat   : (M, List Z) -> M
    diagSubMatrix: M -> Union(Record(val:R, mat:M), "failed")
    determinantOfMinor: M -> R
    enumerateBinomial: (List Z, Z, Z) -> List Z

    nonzero? v == any?(#1 ^= 0, v)

-- returns [a, i, rown] if v = [0,...,0,a,0,...,0]
-- where a <> 0 and i is the index of a, "failed" otherwise.
    non0(v, rown) ==
      ans:REC
      allZero:Boolean := true
      for i in minIndex v .. maxIndex v repeat
        if qelt(v, i) ^= 0 then
          if allZero then
            allZero := false
            ans := [qelt(v, i), i, rown]
          else return "failed"
      allZero => "failed"
      ans

-- returns a matrix made from the non-zero rows of x whose row number
-- is not in l
    mkMat(x, l) ==
      empty?(ll := [parts row(x, i)
         for i in minRowIndex x .. maxRowIndex x |
           (not member?(i, l)) and nonzero? row(x, i)]$List(List R)) =>
              zero(1, ncols x)
      matrix ll

-- returns [m, d] where m = x with the zero rows and the rows of
-- the diagonal of d removed, if x has a diagonal submatrix of d's,
-- "failed" otherwise.
    diagSubMatrix x ==
      l  := [u::REC for i in minRowIndex x .. maxRowIndex x |
                                     (u := non0(row(x, i), i)) case REC]
      for a in removeDuplicates([r.val for r in l]$List(R)) repeat
        {[r.cl for r in l | r.val = a]$List(Z)}$Set(Z) =
          {[z for z in minColIndex x .. maxColIndex x]$List(Z)}$Set(Z)
            => return [a, mkMat(x, [r.rw for r in l | a = r.val])]
      "failed"

-- returns a non-zero determinant of a minor of x of rank equal to
-- the number of columns of x, if there is one, 0 otherwise
    determinantOfMinor x ==
-- do not compute a modulus for square matrices, since this is as expensive
-- as the Hermite reduction itself
      (nr := nrows x) <= (nc := ncols x) => 0
      lc := [i for i in minColIndex x .. maxColIndex x]$List(Integer)
      lr := [i for i in minRowIndex x .. maxRowIndex x]$List(Integer)
      for i in 1..(n := binomial(nr, nc)) repeat
        (d := determinant x(enumerateBinomial(lr, nc, i), lc)) ^= 0 =>
          j := i + 1 + (random()$Z rem (n - i))
          return gcd(d, determinant x(enumerateBinomial(lr, nc, j), lc))
      0

-- returns the i-th selection of m elements of l = (a1,...,an),
--                 /n\
-- where 1 <= i <= | |
--                 \m/
    enumerateBinomial(l, m, i) ==
      m1 := minIndex l - 1
      zero?(m := m - 1) => [l(m1 + i)]
      for j in 1..(n := #l) repeat
        i <= (b := binomial(n - j, m)) =>
          return concat(l(m1 + j), enumerateBinomial(rest(l, j), m, i))
        i := i - b
      error "Should not happen"

    rowEch x ==
      (u := diagSubMatrix x) case "failed" =>
        zero?(d := determinantOfMinor x) => rowEchelon x
        rowEchelon(x, d)
      rowEchelon(u.mat, u.val)

    vconc(y, m) ==
      vertConcat(diagonalMatrix new(ncols y, m)$V, map(#1 rem m, y))

    order(m, p) ==
      zero? m => -1
      for i in 0.. repeat
        (mm := m exquo p) case "failed" => return i
        m := mm::R

    if R has IntegerNumberSystem then
        normalizedDivide(n:R, d:R):Record(quotient:R, remainder:R) ==
            qr := divide(n, d)
            qr.remainder >= 0 => qr
            d > 0 =>
                qr.remainder := qr.remainder + d
                qr.quotient := qr.quotient - 1
                qr
            qr.remainder := qr.remainder - d
            qr.quotient := qr.quotient + 1
            qr
    else
        normalizedDivide(n:R, d:R):Record(quotient:R, remainder:R) ==
            divide(n, d)

    rowEchLocal(x,p) ==
      (u := diagSubMatrix x) case "failed" =>
        zero?(d := determinantOfMinor x) => rowEchelon x
        rowEchelonLocal(x, d, p)
      rowEchelonLocal(u.mat, u.val, p)

    rowEchelonLocal(y, m, p) ==
        m := p**(order(m,p)::NonNegativeInteger)
        x     := vconc(y, m)
        nrows := maxRowIndex x
        ncols := maxColIndex x
        minr  := i := minRowIndex x
        for j in minColIndex x .. ncols repeat
          if i > nrows then leave x
          rown := minr - 1
          pivord : Integer
          npivord : Integer
          for k in i .. nrows repeat
            qelt(x,k,j) = 0 => "next k"
            npivord := order(qelt(x,k,j),p)
            (rown = minr - 1) or (npivord  <  pivord) =>
                    rown := k
                    pivord := npivord
          rown = minr - 1 => "enuf"
          x := swapRows_!(x, i, rown)
          (a, b, d) := extendedEuclidean(qelt(x,i,j), m)
          qsetelt_!(x,i,j,d)
          pivot := d
          for k in j+1 .. ncols repeat
            qsetelt_!(x,i,k, a * qelt(x,i,k) rem m)
          for k in i+1 .. nrows repeat
            zero? qelt(x,k,j) => "next k"
            q := (qelt(x,k,j) exquo pivot) :: R
            for k1 in j+1 .. ncols repeat
              v2 := (qelt(x,k,k1) - q * qelt(x,i,k1)) rem m
              qsetelt_!(x, k, k1, v2)
            qsetelt_!(x, k, j, 0)
          for k in minr .. i-1 repeat
            zero? qelt(x,k,j) => "enuf"
            qr    := normalizedDivide(qelt(x,k,j), pivot)
            qsetelt_!(x,k,j, qr.remainder)
            for k1 in j+1 .. ncols x repeat
              qsetelt_!(x,k,k1,
                     (qelt(x,k,k1) - qr.quotient * qelt(x,i,k1)) rem m)
          i := i+1
        x

    if R has Field then
      rowEchelon(y, m) == rowEchelon vconc(y, m)

    else

      rowEchelon(y, m) ==
        x     := vconc(y, m)
        nrows := maxRowIndex x
        ncols := maxColIndex x
        minr  := i := minRowIndex x
        for j in minColIndex x .. ncols repeat
          if i > nrows then leave
          rown := minr - 1
          for k in i .. nrows repeat
            if (qelt(x,k,j) ^= 0) and ((rown = minr - 1) or
                  sizeLess?(qelt(x,k,j), qelt(x,rown,j))) then rown := k
          rown = minr - 1 => "next j"
          x := swapRows_!(x, i, rown)
          for k in i+1 .. nrows repeat
            zero? qelt(x,k,j) => "next k"
            (a, b, d) := extendedEuclidean(qelt(x,i,j), qelt(x,k,j))
            (b1, a1) :=
               ((qelt(x,i,j) exquo d)::R, (qelt(x,k,j) exquo d)::R)
            -- a*b1+a1*b = 1
            for k1 in j+1 .. ncols repeat
              v1 := (a  * qelt(x,i,k1) +  b * qelt(x,k,k1)) rem m
              v2 := (b1 * qelt(x,k,k1) - a1 * qelt(x,i,k1)) rem m
              qsetelt_!(x, i, k1, v1)
              qsetelt_!(x, k, k1, v2)
            qsetelt_!(x, i, j, d)
            qsetelt_!(x, k, j, 0)
          un := unitNormal qelt(x,i,j)
          qsetelt_!(x,i,j,un.canonical)
          if un.associate ^= 1 then for jj in (j+1)..ncols repeat
              qsetelt_!(x,i,jj,un.associate * qelt(x,i,jj))

          xij := qelt(x,i,j)
          for k in minr .. i-1 repeat
            zero? qelt(x,k,j) => "next k"
            qr    := normalizedDivide(qelt(x,k,j), xij)
            qsetelt_!(x,k,j, qr.remainder)
            for k1 in j+1 .. ncols x repeat
              qsetelt_!(x,k,k1,
                     (qelt(x,k,k1) - qr.quotient * qelt(x,i,k1)) rem m)
          i := i+1
        x

@
\section{package FDIV2 FiniteDivisorFunctions2}
<<package FDIV2 FiniteDivisorFunctions2>>=
)abbrev package FDIV2 FiniteDivisorFunctions2
++ Lift a map to finite divisors.
++ Author: Manuel Bronstein
++ Date Created: 1988
++ Date Last Updated: 19 May 1993
FiniteDivisorFunctions2(R1, UP1, UPUP1, F1, R2, UP2, UPUP2, F2):
 Exports == Implementation where
  R1   : Field
  UP1  : UnivariatePolynomialCategory R1
  UPUP1: UnivariatePolynomialCategory Fraction UP1
  F1   : FunctionFieldCategory(R1, UP1, UPUP1)
  R2   : Field
  UP2  : UnivariatePolynomialCategory R2
  UPUP2: UnivariatePolynomialCategory Fraction UP2
  F2   : FunctionFieldCategory(R2, UP2, UPUP2)

  Exports ==> with
    map: (R1 -> R2, FiniteDivisor(R1, UP1, UPUP1, F1)) ->
                                       FiniteDivisor(R2, UP2, UPUP2, F2)
	++ map(f,d) \undocumented{} 

  Implementation ==> add
    import UnivariatePolynomialCategoryFunctions2(R1,UP1,R2,UP2)
    import FunctionFieldCategoryFunctions2(R1,UP1,UPUP1,F1,R2,UP2,UPUP2,F2)
    import FractionalIdealFunctions2(UP1, Fraction UP1, UPUP1, F1,
                                     UP2, Fraction UP2, UPUP2, F2)

    map(f, d) ==
      rec := decompose d
      divisor map(f, rec.principalPart) + divisor map(map(f, #1), rec.id)

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>

-- SPAD files for the algebraic integration world should be compiled
-- in the following order:
--
--   curve DIVISOR reduc pfo intalg int

<<package FRIDEAL2 FractionalIdealFunctions2>>
<<package MHROWRED ModularHermitianRowReduction>>
<<package FDIV2 FiniteDivisorFunctions2>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
