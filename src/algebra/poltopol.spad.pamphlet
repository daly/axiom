\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra poltopol.spad}
\author{Manuel Bronstein, Patrizia Gianni}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{package MPC2 MPolyCatFunctions2}
<<package MPC2 MPolyCatFunctions2>>=
)abbrev package MPC2 MPolyCatFunctions2
++ Utilities for MPolyCat
++ Author: Manuel Bronstein
++ Date Created: 1987
++ Date Last Updated: 28 March 1990  (PG)
MPolyCatFunctions2(VarSet,E1,E2,R,S,PR,PS) : public == private where
 
  VarSet : OrderedSet
  E1     : OrderedAbelianMonoidSup
  E2     : OrderedAbelianMonoidSup
  R      : Ring
  S      : Ring
  PR     : PolynomialCategory(R,E1,VarSet)
  PS     : PolynomialCategory(S,E2,VarSet)
  SUPR   ==> SparseUnivariatePolynomial PR
  SUPS   ==> SparseUnivariatePolynomial PS
 
  public == with
    map:     (R -> S,PR) -> PS
	++ map(f,p) \undocumented	
    reshape: (List S, PR) -> PS
	++ reshape(l,p) \undocumented
 
  private == add
 
    supMap:  (R -> S, SUPR) -> SUPS
 
    supMap(fn : R -> S, supr : SUPR): SUPS ==
      supr = 0 => monomial(fn(0$R) :: PS,0)$SUPS
      c : PS := map(fn,leadingCoefficient supr)$%
      monomial(c,degree supr)$SUPS + supMap(fn, reductum supr)
 
    map(fn : R -> S, pr : PR): PS ==
      varu : Union(VarSet,"failed") := mainVariable pr
      varu case "failed" =>  -- have a constant
        fn(retract pr) :: PS
      var : VarSet := varu :: VarSet
      supr : SUPR := univariate(pr,var)$PR
      multivariate(supMap(fn,supr),var)$PS

@
\section{package MPC3 MPolyCatFunctions3}
<<package MPC3 MPolyCatFunctions3>>=
)abbrev package MPC3 MPolyCatFunctions3
++ Description:
++ This package \undocumented
MPolyCatFunctions3(Vars1,Vars2,E1,E2,R,PR1,PR2): C == T where
  E1   : OrderedAbelianMonoidSup
  E2   : OrderedAbelianMonoidSup
  Vars1: OrderedSet
  Vars2: OrderedSet
  R    : Ring
  PR1  : PolynomialCategory(R,E1,Vars1)
  PR2  : PolynomialCategory(R,E2,Vars2)
 
  C ==> with
    map: (Vars1 -> Vars2, PR1) -> PR2
	++ map(f,x) \undocumented
 
  T ==> add
 
    map(f:Vars1 -> Vars2, p:PR1):PR2 ==
      (x1 := mainVariable p) case "failed" =>
        c:R:=(retract p)
        c::PR2
      up := univariate(p, x1::Vars1)
      x2 := f(x1::Vars1)
      ans:PR2 := 0
      while up ^= 0 repeat
        ans := ans + monomial(map(f,leadingCoefficient up),x2,degree up)
        up  := reductum up
      ans

@
\section{package POLTOPOL PolToPol}
<<package POLTOPOL PolToPol>>=
)abbrev package POLTOPOL PolToPol
++ Author : P.Gianni, Summer '88
++ Description:
++ Package with the conversion functions among different kind of polynomials
PolToPol(lv,R) : C == T
 
 where
  R      :    Ring
  lv     :    List Symbol
  NNI    ==>  NonNegativeInteger
  Ov     ==>  OrderedVariableList(lv)
  IES    ==>  IndexedExponents Symbol
 
  DP     ==>  DirectProduct(#lv,NonNegativeInteger)
  DPoly  ==>  DistributedMultivariatePolynomial(lv,R)
 
  HDP    ==>  HomogeneousDirectProduct(#lv,NonNegativeInteger)
  HDPoly ==>  HomogeneousDistributedMultivariatePolynomial(lv,R)
  P      ==>  Polynomial R
  VV     ==>  Vector NNI
  MPC3   ==>  MPolyCatFunctions3
 
  C == with
     dmpToHdmp    :    DPoly    -> HDPoly
       ++ dmpToHdmp(p) converts p from a \spadtype{DMP} to a \spadtype{HDMP}.
     hdmpToDmp    :   HDPoly    -> DPoly
       ++ hdmpToDmp(p) converts p from a \spadtype{HDMP} to a \spadtype{DMP}.
     pToHdmp      :     P       -> HDPoly
       ++ pToHdmp(p) converts p from a \spadtype{POLY} to a \spadtype{HDMP}.
     hdmpToP      :   HDPoly    -> P
       ++ hdmpToP(p) converts p from a \spadtype{HDMP} to a \spadtype{POLY}.
     dmpToP       :    DPoly    -> P
       ++ dmpToP(p) converts p from a \spadtype{DMP} to a \spadtype{POLY}.
     pToDmp       :     P       -> DPoly
       ++ pToDmp(p) converts p from a \spadtype{POLY} to a \spadtype{DMP}.
  T == add
 
    variable1(xx:Symbol):Ov == variable(xx)::Ov
 
   -- transform a P in a HDPoly --
    pToHdmp(pol:P) : HDPoly ==
      map(variable1,pol)$MPC3(Symbol,Ov,IES,HDP,R,P,HDPoly)
 
   -- transform an HDPoly in a P --
    hdmpToP(hdpol:HDPoly) : P ==
      map(convert,hdpol)$MPC3(Ov,Symbol,HDP,IES,R,HDPoly,P)
 
   -- transform an DPoly in a P --
    dmpToP(dpol:DPoly) : P ==
      map(convert,dpol)$MPC3(Ov,Symbol,DP,IES,R,DPoly,P)
 
   -- transform a P in a DPoly --
    pToDmp(pol:P) : DPoly ==
      map(variable1,pol)$MPC3(Symbol,Ov,IES,DP,R,P,DPoly)
 
   -- transform a DPoly in a HDPoly --
    dmpToHdmp(dpol:DPoly) : HDPoly ==
      dpol=0 => 0$HDPoly
      monomial(leadingCoefficient dpol,
               directProduct(degree(dpol)::VV)$HDP)$HDPoly+
                                                 dmpToHdmp(reductum dpol)
 
   -- transform a HDPoly in a DPoly --
    hdmpToDmp(hdpol:HDPoly) : DPoly ==
      hdpol=0 => 0$DPoly
      dd:DP:= directProduct((degree hdpol)::VV)$DP
      monomial(leadingCoefficient hdpol,dd)$DPoly+
               hdmpToDmp(reductum hdpol)

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>

<<package MPC2 MPolyCatFunctions2>>
<<package MPC3 MPolyCatFunctions3>>
<<package POLTOPOL PolToPol>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
