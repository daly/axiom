<?xml version="1.0" encoding="UTF-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN"
"http://www.w3.org/TR/MathML2/dtd/xhtml-math11-f.dtd" [
<!ENTITY mathml "http://www.w3.org/1998/Math/MathML">
]>

<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:xlink="http://www.w3.org/1999/xlink" >


  <head>
    <title>Section2.1</title>
    <link rel="stylesheet" type="text/css" href="graphicstyle.css" />
    <script type="text/javascript" src="bookax1.js" />
  </head>

  <body>
<a href="book-contents.xhtml" style="margin-right: 10px;">Book Contents</a><a href="section-2.0.xhtml" style="margin-right: 10px;">Previous Section 2.0 Using Types and Modes</a><a href="section-2.2.xhtml" style="margin-right: 10px;">Next Section 2.2 Writing Types and Modes</a>
<a href="book-index.xhtml">Book Index</a><div class="section"  id="sec-2.1">
<h2 class="sectiontitle">2.1  The Basic Idea</h2>


<a name="ugTypesBasic" class="label"/>


<p>The Axiom world deals with many kinds of objects.  There are
mathematical objects such as numbers and polynomials, data structure
objects such as lists and arrays, and graphics objects such as points
and graphic images.  Functions are objects too.
</p>


<p>Axiom organizes objects using the notion of domain of computation, or
simply <span class="italic">domain</span>.  Each domain denotes a class of objects.  The
class of objects it denotes is usually given by the name of the
domain: <span class="teletype">Integer</span> for the integers, <span class="teletype">Float</span> for floating-point
numbers, and so on.  The convention is that the first letter of a
domain name is capitalized.  Similarly, the domain 
<span class="teletype">Polynomial(Integer)</span> denotes ``polynomials with integer
coefficients.''  Also, <span class="teletype">Matrix(Float)</span> denotes ``matrices with
floating-point entries.''
</p>


<p>Every basic Axiom object belongs to a unique domain.  The integer <math xmlns="&mathml;" mathsize="big"><mstyle><mn>3</mn></mstyle></math>
belongs to the domain <span class="teletype">Integer</span> and the polynomial <math xmlns="&mathml;" mathsize="big"><mstyle><mrow><mi>x</mi><mo>+</mo><mn>3</mn></mrow></mstyle></math> belongs
to the domain <span class="teletype">Polynomial(Integer)</span>.  The domain of an object is
also called its <span class="italic">type</span>.  Thus we speak of ``the type 
<span class="teletype">Integer</span>'' and ``the type <span class="teletype">Polynomial(Integer)</span>.''
</p>


<p>After an Axiom computation, the type is displayed toward the
right-hand side of the page (or screen).
</p>



<div id="spadComm2-1" class="spadComm" >
<form id="formComm2-1" action="javascript:makeRequest('2-1');" >
<input id="comm2-1" type="text" class="command" style="width: 2em;" value="-3" />
</form>
<span id="commSav2-1" class="commSav" >-3</span>
<div id="mathAns2-1" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mo>-</mo><mn>3</mn></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: Integer
</div>



<p>Here we create a rational number but it looks like the last result.
The type however tells you it is different.  You cannot identify the
type of an object by how Axiom displays the object.
</p>



<div id="spadComm2-2" class="spadComm" >
<form id="formComm2-2" action="javascript:makeRequest('2-2');" >
<input id="comm2-2" type="text" class="command" style="width: 3em;" value="-3/1" />
</form>
<span id="commSav2-2" class="commSav" >-3/1</span>
<div id="mathAns2-2" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mo>-</mo><mn>3</mn></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: Fraction Integer
</div>



<p>When a computation produces a result of a simpler type, Axiom leaves
the type unsimplified.  Thus no information is lost.
</p>



<div id="spadComm2-3" class="spadComm" >
<form id="formComm2-3" action="javascript:makeRequest('2-3');" >
<input id="comm2-3" type="text" class="command" style="width: 6em;" value="x + 3 - x" />
</form>
<span id="commSav2-3" class="commSav" >x + 3 - x</span>
<div id="mathAns2-3" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mn>3</mn></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: Polynomial Integer
</div>



<p>This seldom matters since Axiom retracts the answer to the
simpler type if it is necessary.
</p>



<div id="spadComm2-4" class="spadComm" >
<form id="formComm2-4" action="javascript:makeRequest('2-4');" >
<input id="comm2-4" type="text" class="command" style="width: 9em;" value="factorial(%)" />
</form>
<span id="commSav2-4" class="commSav" >factorial(%)</span>
<div id="mathAns2-4" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mn>6</mn></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: Expression Integer
</div>



<p>When you issue a positive number, the type <span class="teletype">PositiveInteger</span> is
printed.  Surely, <math xmlns="&mathml;" mathsize="big"><mstyle><mn>3</mn></mstyle></math> also has type <span class="teletype">Integer</span>!  The curious reader
may now have two questions.  First, is the type of an object not
unique?  Second, how is <span class="teletype">PositiveInteger</span> related to 
<span class="teletype">Integer</span>?
</p>



<div id="spadComm2-5" class="spadComm" >
<form id="formComm2-5" action="javascript:makeRequest('2-5');" >
<input id="comm2-5" type="text" class="command" style="width: 1em;" value="3" />
</form>
<span id="commSav2-5" class="commSav" >3</span>
<div id="mathAns2-5" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mn>3</mn></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: PositiveInteger
</div>



<p>Any domain can be refined to a <span class="italic">subdomain</span> by a membership 
<span class="teletype">predicate</span>. A <span class="teletype">predicate</span> is a function that, when applied to an
object of the domain, returns either <span class="teletype">true</span> or <span class="teletype">false</span>.  For
example, the domain <span class="teletype">Integer</span> can be refined to the subdomain 
<span class="teletype">PositiveInteger</span>, the set of integers <math xmlns="&mathml;" mathsize="big"><mstyle><mi>x</mi></mstyle></math> such that <math xmlns="&mathml;" mathsize="big"><mstyle><mrow><mi>x</mi><mo>&gt;</mo><mn>0</mn></mrow></mstyle></math>, by giving
the Axiom predicate <math xmlns="&mathml;" mathsize="big"><mstyle><mrow><mi>x</mi><mo>+</mo><mo>-</mo><mo>&gt;</mo><mi>x</mi><mo>&gt;</mo><mn>0</mn></mrow></mstyle></math>.  Similarly, Axiom can define
subdomains such as ``the subdomain of diagonal matrices,'' ``the
subdomain of lists of length two,'' ``the subdomain of monic
irreducible polynomials in <math xmlns="&mathml;" mathsize="big"><mstyle><mi>x</mi></mstyle></math>,'' and so on.  Trivially, any domain is
a subdomain of itself.
</p>


<p>While an object belongs to a unique domain, it can belong to any
number of subdomains.  Any subdomain of the domain of an object can be
used as the <span class="italic">type</span> of that object.  The type of <math xmlns="&mathml;" mathsize="big"><mstyle><mn>3</mn></mstyle></math> is indeed both
<span class="teletype">Integer</span> and <span class="teletype">PositiveInteger</span> as well as any other subdomain
of integer whose predicate is satisfied, such as ``the prime
integers,'' ``the odd positive integers between 3 and 17,'' and so on.
</p>



<a name="subsec-2.1.1"/>
<div class="subsection"  id="subsec-2.1.1">
<h3 class="subsectitle">2.1.1  Domain Constructors</h3>


<a name="ugTypesBasicDomainCons" class="label"/>


<p>In Axiom, domains are objects.  You can create them, pass them to
functions, and, as we'll see later, test them for certain properties.
</p>


<p>In Axiom, you ask for a value of a function by applying its name
to a set of arguments.
</p>


<p>To ask for ``the factorial of <math xmlns="&mathml;" mathsize="big"><mstyle><mn>7</mn></mstyle></math>'' you enter this expression to
Axiom.  This applies the function <span class="teletype">factorial</span> to the value <math xmlns="&mathml;" mathsize="big"><mstyle><mn>7</mn></mstyle></math> to
compute the result.
</p>



<div id="spadComm2-6" class="spadComm" >
<form id="formComm2-6" action="javascript:makeRequest('2-6');" >
<input id="comm2-6" type="text" class="command" style="width: 8em;" value="factorial(7)" />
</form>
<span id="commSav2-6" class="commSav" >factorial(7)</span>
<div id="mathAns2-6" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mn>5040</mn></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: PositiveInteger
</div>



<p>Enter the type <span class="teletype">Polynomial (Integer)</span> as an expression to Axiom.
This looks much like a function call as well.  It is!  The result is
appropriately stated to be of type <span class="teletype">Domain</span>, which according to
our usual convention, denotes the class of all domains.
</p>



<div id="spadComm2-7" class="spadComm" >
<form id="formComm2-7" action="javascript:makeRequest('2-7');" >
<input id="comm2-7" type="text" class="command" style="width: 13em;" value="Polynomial(Integer)" />
</form>
<span id="commSav2-7" class="commSav" >Polynomial(Integer)</span>
<div id="mathAns2-7" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mtext><mrow><mtext>PolynomialInteger</mtext></mrow></mtext></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: Domain
</div>



<p>The most basic operation involving domains is that of building a new
domain from a given one.  To create the domain of ``polynomials over
the integers,'' Axiom applies the function <span class="teletype">Polynomial</span> to the
domain <span class="teletype">Integer</span>.  A function like <span class="teletype">Polynomial</span> is called a
<span class="italic">domain constructor</span> or, <span class="index">constructor:domain</span><a name="chapter-2-0"/> more simply, a
<span class="italic">constructor</span>.  A domain constructor is a function that creates a
domain.  An argument to a domain constructor can be another domain or,
in general, an arbitrary kind of object.  <span class="teletype">Polynomial</span> takes a
single domain argument while <span class="teletype">SquareMatrix</span> takes a positive
integer as an argument to give its dimension and a domain argument to
give the type of its components.
</p>


<p>What kinds of domains can you use as the argument to <span class="teletype">Polynomial</span>
or <span class="teletype">SquareMatrix</span> or <span class="teletype">List</span>?  Well, the first two are
mathematical in nature.  You want to be able to perform algebraic
operations like ``<span class="teletype">+</span>'' and ``<span class="teletype">*</span>'' on polynomials and square
matrices, and operations such as <span style="font-weight: bold;"> determinant</span> on square
matrices.  So you want to allow polynomials of integers <span class="italic">and</span>
polynomials of square matrices with complex number coefficients and,
in general, anything that ``makes sense.'' At the same time, you don't
want Axiom to be able to build nonsense domains such as ``polynomials
of strings!''
</p>


<p>In contrast to algebraic structures, data structures can hold any kind
of object.  Operations on lists such as <span class="spadfunFrom" style="font-weight: bold;">insert</span><span class="index">insert</span><a name="chapter-2-1"/><span class="index">List</span><a name="chapter-2-2"/>,
<span class="spadfunFrom" style="font-weight: bold;">delete</span><span class="index">delete</span><a name="chapter-2-3"/><span class="index">List</span><a name="chapter-2-4"/>, and <span class="spadfunFrom" style="font-weight: bold;">concat</span><span class="index">concat</span><a name="chapter-2-5"/><span class="index">List</span><a name="chapter-2-6"/> just
manipulate the list itself without changing or operating on its
elements.  Thus you can build <span class="teletype">List</span> over almost any datatype,
including itself.
</p>


<p>Create a complicated algebraic domain.
</p>



<div id="spadComm2-8" class="spadComm" >
<form id="formComm2-8" action="javascript:makeRequest('2-8');" >
<input id="comm2-8" type="text" class="command" style="width: 43em;" value="List (List (Matrix (Polynomial (Complex (Fraction (Integer))))))" />
</form>
<span id="commSav2-8" class="commSav" >List (List (Matrix (Polynomial (Complex (Fraction (Integer))))))</span>
<div id="mathAns2-8" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mtext><mrow><mtext>ListListMatrixPolynomialComplexFractionInteger</mtext></mrow></mtext></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: Domain
</div>



<p>Try to create a meaningless domain.
</p>



<div id="spadComm2-9" class="spadComm" >
<form id="formComm2-9" action="javascript:makeRequest('2-9');" >
<input id="comm2-9" type="text" class="command" style="width: 12em;" value="Polynomial(String)" />
</form>
<span id="commSav2-9" class="commSav" >Polynomial(String)</span>
<div id="mathAns2-9" ></div>
</div>




<div class="verbatim"><br />
&nbsp;&nbsp;&nbsp;Polynomial&nbsp;String&nbsp;is&nbsp;not&nbsp;a&nbsp;valid&nbsp;type.<br />
</div>



<p>Evidently from our last example, Axiom has some mechanism that tells
what a constructor can use as an argument.  This brings us to the
notion of <span class="italic">category</span>.  As domains are objects, they too have a
domain.  The domain of a domain is a category.  A category is simply a
type whose members are domains.
</p>


<p>A common algebraic category is <span class="teletype">Ring</span>, the class of all domains
that are ``rings.''  A ring is an algebraic structure with constants
<math xmlns="&mathml;" mathsize="big"><mstyle><mn>0</mn></mstyle></math> and <math xmlns="&mathml;" mathsize="big"><mstyle><mn>1</mn></mstyle></math> and operations <span class="spadopFrom" title="Ring">+</span>, <span class="spadopFrom" title="Ring">-</span>,
and <span class="spadopFrom" title="Ring">*</span>.  These operations are assumed ``closed''
with respect to the domain, meaning that they take two objects of the
domain and produce a result object also in the domain.  The operations
are understood to satisfy certain ``axioms,'' certain mathematical
principles providing the algebraic foundation for rings.  For example,
the <span class="italic">additive inverse axiom</span> for rings states: 
</p>


<div class="center" style="text-align: center;">


<p>Every element <math xmlns="&mathml;" mathsize="big"><mstyle><mi>x</mi></mstyle></math> has an additive inverse <math xmlns="&mathml;" mathsize="big"><mstyle><mi>y</mi></mstyle></math> such that <math xmlns="&mathml;" mathsize="big"><mstyle><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>=</mo><mn>0</mn></mrow></mstyle></math>.
</p>



</div>

<p> The prototypical example of a domain that is a ring is
the integers.  Keep them in mind whenever we mention <span class="teletype">Ring</span>.
</p>


<p>Many algebraic domain constructors such as <span class="teletype">Complex</span>, 
<span class="teletype">Polynomial</span>, <span class="teletype">Fraction</span>, take rings as arguments and return rings
as values.  You can use the infix operator ``<math xmlns="&mathml;" mathsize="big"><mstyle><mi>has</mi></mstyle></math>'' to ask a domain
if it belongs to a particular category.
</p>


<p>All numerical types are rings.  Domain constructor <span class="teletype">Polynomial</span>
builds ``the ring of polynomials over any other ring.''
</p>



<div id="spadComm2-10" class="spadComm" >
<form id="formComm2-10" action="javascript:makeRequest('2-10');" >
<input id="comm2-10" type="text" class="command" style="width: 19em;" value="Polynomial(Integer) has Ring" />
</form>
<span id="commSav2-10" class="commSav" >Polynomial(Integer) has Ring</span>
<div id="mathAns2-10" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mtext>true</mtext></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: Boolean
</div>



<p>Constructor <span class="teletype">List</span> never produces a ring.
</p>



<div id="spadComm2-11" class="spadComm" >
<form id="formComm2-11" action="javascript:makeRequest('2-11');" >
<input id="comm2-11" type="text" class="command" style="width: 15em;" value="List(Integer) has Ring" />
</form>
<span id="commSav2-11" class="commSav" >List(Integer) has Ring</span>
<div id="mathAns2-11" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mtext>false</mtext></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: Boolean
</div>



<p>The constructor <span class="teletype">Matrix(R)</span> builds ``the domain of all matrices
over the ring <math xmlns="&mathml;" mathsize="big"><mstyle><mi>R</mi></mstyle></math>.'' This domain is never a ring since the operations
``<span class="teletype">+</span>'', ``<span class="teletype">-</span>'', and ``<span class="teletype">*</span>'' on matrices of arbitrary
shapes are undefined.
</p>



<div id="spadComm2-12" class="spadComm" >
<form id="formComm2-12" action="javascript:makeRequest('2-12');" >
<input id="comm2-12" type="text" class="command" style="width: 16em;" value="Matrix(Integer) has Ring" />
</form>
<span id="commSav2-12" class="commSav" >Matrix(Integer) has Ring</span>
<div id="mathAns2-12" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mtext>false</mtext></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: Boolean
</div>



<p>Thus you can never build polynomials over matrices.
</p>



<div id="spadComm2-13" class="spadComm" >
<form id="formComm2-13" action="javascript:makeRequest('2-13');" >
<input id="comm2-13" type="text" class="command" style="width: 18em;" value="Polynomial(Matrix(Integer))" />
</form>
<span id="commSav2-13" class="commSav" >Polynomial(Matrix(Integer))</span>
<div id="mathAns2-13" ></div>
</div>




<div class="verbatim"><br />
&nbsp;&nbsp;&nbsp;Polynomial&nbsp;Matrix&nbsp;Integer&nbsp;is&nbsp;not&nbsp;a&nbsp;valid&nbsp;type.<br />
</div>



<p>Use <span class="teletype">SquareMatrix(n,R)</span> instead.  For any positive integer <math xmlns="&mathml;" mathsize="big"><mstyle><mi>n</mi></mstyle></math>, it
builds ``the ring of <math xmlns="&mathml;" mathsize="big"><mstyle><mi>n</mi></mstyle></math> by <math xmlns="&mathml;" mathsize="big"><mstyle><mi>n</mi></mstyle></math> matrices over <math xmlns="&mathml;" mathsize="big"><mstyle><mi>R</mi></mstyle></math>.''
</p>



<div id="spadComm2-14" class="spadComm" >
<form id="formComm2-14" action="javascript:makeRequest('2-14');" >
<input id="comm2-14" type="text" class="command" style="width: 30em;" value="Polynomial(SquareMatrix(7,Complex(Integer)))" />
</form>
<span id="commSav2-14" class="commSav" >Polynomial(SquareMatrix(7,Complex(Integer)))</span>
<div id="mathAns2-14" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mtext><mrow><mtext>PolynomialSquareMatrix(7,ComplexInteger)</mtext></mrow></mtext></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: Domain
</div>



<p>Another common category is <span class="teletype">Field</span>, the class of all fields.
<span class="index">field</span><a name="chapter-2-7"/> A field is a ring with additional operations.  For
example, a field has commutative multiplication and a closed operation
<span class="spadopFrom" title="Field">/</span> for the division of two elements.  <span class="teletype">Integer</span>
is not a field since, for example, <math xmlns="&mathml;" mathsize="big"><mstyle><mrow><mn>3</mn><mo>/</mo><mn>2</mn></mrow></mstyle></math> does not have an integer
result.  The prototypical example of a field is the rational numbers,
that is, the domain <span class="teletype">Fraction(Integer)</span>.  In general, the
constructor <span class="teletype">Fraction</span> takes an IntegralDomain, which is a ring
with additional properties, as an argument and returns a field. 
<span class="footnote">Actually, the argument domain must have some additional
so as to belong to the category <span class="teletype">IntegralDomain</span></span>
Other domain constructors, such as <span class="teletype">Complex</span>, build fields only if their
argument domain is a field.
</p>


<p>The complex integers (often called the ``Gaussian integers'') do not form
a field.
</p>



<div id="spadComm2-15" class="spadComm" >
<form id="formComm2-15" action="javascript:makeRequest('2-15');" >
<input id="comm2-15" type="text" class="command" style="width: 18em;" value="Complex(Integer) has Field" />
</form>
<span id="commSav2-15" class="commSav" >Complex(Integer) has Field</span>
<div id="mathAns2-15" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mtext mathvariant='monospace'>false</mtext></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: Boolean
</div>



<p>But fractions of complex integers do.
</p>



<div id="spadComm2-16" class="spadComm" >
<form id="formComm2-16" action="javascript:makeRequest('2-16');" >
<input id="comm2-16" type="text" class="command" style="width: 24em;" value="Fraction(Complex(Integer)) has Field" />
</form>
<span id="commSav2-16" class="commSav" >Fraction(Complex(Integer)) has Field</span>
<div id="mathAns2-16" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mtext mathvariant='monospace'>true</mtext></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: Boolean
</div>



<p>The algebraically equivalent domain of complex rational numbers is a field
since domain constructor <span class="teletype">Complex</span> produces a field whenever its
argument is a field.
</p>



<div id="spadComm2-17" class="spadComm" >
<form id="formComm2-17" action="javascript:makeRequest('2-17');" >
<input id="comm2-17" type="text" class="command" style="width: 24em;" value="Complex(Fraction(Integer)) has Field" />
</form>
<span id="commSav2-17" class="commSav" >Complex(Fraction(Integer)) has Field</span>
<div id="mathAns2-17" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mtext mathvariant='monospace'>true</mtext></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: Boolean
</div>



<p>The most basic category is <span class="teletype">Type</span>.  <span class="index">Type</span><a name="chapter-2-8"/> It denotes the
class of all domains and subdomains. Note carefully that <span class="teletype">Type</span>
does not denote the class of all types.  The type of all categories is
<span class="teletype">Category</span>.  The type of <span class="teletype">Type</span> itself is undefined.  Domain
constructor <span class="teletype">List</span> is able to build ``lists of elements from
domain <math xmlns="&mathml;" mathsize="big"><mstyle><mi>D</mi></mstyle></math>'' for arbitrary <math xmlns="&mathml;" mathsize="big"><mstyle><mi>D</mi></mstyle></math> simply by requiring that <math xmlns="&mathml;" mathsize="big"><mstyle><mi>D</mi></mstyle></math> belong to
category <span class="teletype">Type</span>.
</p>


<p>Now, you may ask, what exactly is a category?  <span class="index">category</span><a name="chapter-2-9"/> Like
domains, categories can be defined in the Axiom language.  A category
is defined by three components:
</p>




<ol>
<li>
 a name (for example, <span class="teletype">Ring</span>),
used to refer to the class of domains that the category represents;
</li>
<li> a set of operations, used to refer to the operations that
the domains of this class support
(for example, ``<span class="teletype">+</span>'', ``<span class="teletype">-</span>'', and ``<span class="teletype">*</span>'' for rings); and
</li>
<li> an optional list of other categories that this category extends.
</li>
</ol>



<p>This last component is a new idea.  And it is key to the design of
Axiom!  Because categories can extend one another, they form
hierarchies.  Detailed charts showing the category hierarchies
in Axiom are displayed in Appendix (TPDHERE).  There you see
that all categories are extensions of <span class="teletype">Type</span> and that <span class="teletype">Field</span>
is an extension of <span class="teletype">Ring</span>.
</p>


<p>The operations supported by the domains of a category are called the
<span style="font-style: italic;"> exports</span> of that category because these are the operations made
available for system-wide use.  The exports of a domain of a given
category are not only the ones explicitly mentioned by the category.
Since a category extends other categories, the operations of these
other categories---and all categories these other categories
extend---are also exported by the domains.
</p>


<p>For example, polynomial domains belong to <span class="teletype">PolynomialCategory</span>.
This category explicitly mentions some twenty-nine operations on
polynomials, but it extends eleven other categories (including 
<span class="teletype">Ring</span>).  As a result, the current system has over one hundred
operations on polynomials.
</p>


<p>If a domain belongs to a category that extends, say, <span class="teletype">Ring</span>, it is
convenient to say that the domain exports <span class="teletype">Ring</span>.  The name of the
category thus provides a convenient shorthand for the list of
operations exported by the category.  Rather than listing operations
such as <span class="spadopFrom" title="Ring">+</span> and <span class="spadopFrom" title="Ring">*</span> of <span class="teletype">Ring</span>
each time they are needed, the definition of a type simply asserts
that it exports category <span class="teletype">Ring</span>.
</p>


<p>The category name, however, is more than a shorthand.  The name 
<span class="teletype">Ring</span>, in fact, implies that the operations exported by rings are
required to satisfy a set of ``axioms'' associated with the name 
<span class="teletype">Ring</span>. This subtle but important feature distinguishes Axiom from
other abstract datatype designs.
</p>


<p>Why is it not correct to assume that some type is a ring if it exports
all of the operations of <span class="teletype">Ring</span>?  Here is why.  Some languages
such as <span style="font-weight: bold;"> APL</span> <span class="index">APL</span><a name="chapter-2-10"/> denote the <span class="teletype">Boolean</span> constants
<span class="teletype">true</span> and <span class="teletype">false</span> by the integers <math xmlns="&mathml;" mathsize="big"><mstyle><mn>1</mn></mstyle></math> and <math xmlns="&mathml;" mathsize="big"><mstyle><mn>0</mn></mstyle></math> respectively, then use
``<span class="teletype">+</span>'' and ``<span class="teletype">*</span>'' to denote the logical operators <span style="font-weight: bold;"> or</span> and
<span style="font-weight: bold;"> and</span>.  But with these definitions <span class="teletype">Boolean</span> is not a
ring since the additive inverse axiom is violated. That is, there is
no inverse element <math xmlns="&mathml;" mathsize="big"><mstyle><mi>a</mi></mstyle></math> such that <math xmlns="&mathml;" mathsize="big"><mstyle><mrow><mn>1</mn><mo>+</mo><mi>a</mi><mo>=</mo><mn>0</mn></mrow></mstyle></math>, or, in the usual terms:
<span class="teletype">true or a = false</span>.  This alternative definition of <span class="teletype">Boolean</span>
can be easily and correctly implemented in Axiom, since <span class="teletype">Boolean</span>
simply does not assert that it is of category <span class="teletype">Ring</span>.  This
prevents the system from building meaningless domains such as 
<span class="teletype">Polynomial(Boolean)</span> and then wrongfully applying algorithms that
presume that the ring axioms hold.
</p>


<p>Enough on categories. To learn more about them, see Chapter
<a href="section-12.0.xhtml#ugCategories" class="ref" >ugCategories</a> .  
We now return to our discussion of domains.
</p>


<p>Domains <span class="italic">export</span> a set of operations to make them available for
system-wide use.  <span class="teletype">Integer</span>, for example, exports the operations
<span class="spadopFrom" title="Integer">+</span> and <span class="spadopFrom" title="Integer">=</span> given by the
signatures <span class="spadopFrom" title="Integer">+</span>:
(Integer,Integer)->Integer and <span class="spadopFrom" title="Integer">=</span>:
(Integer,Integer)->Boolean, respectively.  Each of these
operations takes two <span class="teletype">Integer</span> arguments.  The
<span class="spadopFrom" title="Integer">+</span> operation also returns an <span class="teletype">Integer</span> but
<span class="spadopFrom" title="Integer">=</span> returns a <span class="teletype">Boolean</span>: <span class="teletype">true</span> or <span class="teletype">false</span>.
The operations exported by a domain usually manipulate objects of the
domain---but not always.
</p>


<p>The operations of a domain may actually take as arguments, and return
as values, objects from any domain.  For example, <span class="teletype">Fraction
(Integer)</span> exports the operations <span class="spadopFrom" title="Fraction">/</span>:
(Integer,Integer)->Fraction(Integer) and
<span class="spadfunFrom" style="font-weight: bold;">characteristic</span><span class="index">characteristic</span><a name="chapter-2-11"/><span class="index">Fraction</span><a name="chapter-2-12"/>:
->NonNegativeInteger.
</p>


<p>Suppose all operations of a domain take as arguments and return as
values, only objects from <span class="italic">other</span> domains.  <span class="index">package</span><a name="chapter-2-13"/> This
kind of domain <span class="index">constructor:package</span><a name="chapter-2-14"/> is what Axiom calls a 
<span class="italic">package</span>.
</p>


<p>A package does not designate a class of objects at all.  Rather, a
package is just a collection of operations.  Actually the bulk of the
Axiom library of algorithms consists of packages.  The facilities for
factorization; integration; solution of linear, polynomial, and
differential equations; computation of limits; and so on, are all
defined in packages.  Domains needed by algorithms can be passed to a
package as arguments or used by name if they are not ``variable.''
Packages are useful for defining operations that convert objects of
one type to another, particularly when these types have different
parameterizations.  As an example, the package <span class="teletype">PolynomialFunction2(R,S)</span> 
defines operations that convert polynomials
over a domain <math xmlns="&mathml;" mathsize="big"><mstyle><mi>R</mi></mstyle></math> to polynomials over <math xmlns="&mathml;" mathsize="big"><mstyle><mi>S</mi></mstyle></math>.  To convert an object from
<span class="teletype">Polynomial(Integer)</span> to <span class="teletype">Polynomial(Float)</span>, Axiom builds the
package <span class="teletype">PolynomialFunctions2(Integer,Float)</span> in order to create
the required conversion function.  (This happens ``behind the scenes''
for you: see <a href="section-2.7.xhtml#ugTypesConvert" class="ref" >ugTypesConvert</a> 
for details on how to convert objects.)
</p>


<p>Axiom categories, domains and packages and all their contained
functions are written in the Axiom programming language and have been
compiled into machine code.  This is what comprises the Axiom 
<span class="italic">library</span>.  We will show you how to use these
domains and their functions and how to write your own functions.
</p>




</div>




</div><a href="book-contents.xhtml" style="margin-right: 10px;">Book Contents</a>
<a href="section-2.0.xhtml" style="margin-right: 10px;">Previous Section 2.0 Using Types and Modes</a><a href="section-2.2.xhtml" style="margin-right: 10px;">Next Section 2.2 Writing Types and Modes</a>
<a href="book-index.xhtml">Book Index</a></body>
</html>