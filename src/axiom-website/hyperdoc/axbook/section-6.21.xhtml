<?xml version="1.0" encoding="UTF-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN"
"http://www.w3.org/TR/MathML2/dtd/xhtml-math11-f.dtd" [
<!ENTITY mathml "http://www.w3.org/1998/Math/MathML">
]>

<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:xlink="http://www.w3.org/1999/xlink" >


  <head>
    <title>Section6.21</title>
    <link rel="stylesheet" type="text/css" href="graphicstyle.css" />
    <script type="text/javascript" src="bookax1.js" />
  </head>

  <body>
<a href="book-contents.xhtml" style="margin-right: 10px;">Book Contents</a><a href="section-6.20.xhtml" style="margin-right: 10px;">Previous Section 6.20 Example: Testing for Palindromes</a><a href="section-7.0.xhtml" style="margin-right: 10px;">Next Section 7.0 Graphics</a><a href="book-index.xhtml">Book Index</a><div class="section"  id="sec-6.21">
<h2 class="sectiontitle">6.21  Rules and Pattern Matching</h2>


<a name="ugUserRules" class="label"/>


<p>A common mathematical formula is 
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mrow><mrow><mo>log</mo><mo>(</mo><mi>y</mi><mo>)</mo></mrow><mo>+</mo><mrow><mo>log</mo><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mo>log</mo><mo>(</mo><mrow><mi>x</mi><mo></mo><mi>y</mi></mrow><mo>)</mo></mrow></mrow></mrow><mspace width="1em"/><mo>&#x2200;</mo><mi>x</mi><mspace width="0.5em"/><mtext>and</mtext><mspace width="0.5em"/><mi>y</mi></mstyle></math>

The presence of ``<math xmlns="&mathml;" mathsize="big"><mstyle><mo>&#x2200;</mo></mstyle></math>'' indicates that <math xmlns="&mathml;" mathsize="big"><mstyle><mi>x</mi></mstyle></math> and <math xmlns="&mathml;" mathsize="big"><mstyle><mi>y</mi></mstyle></math> can stand for
arbitrary mathematical expressions in the above formula.  You can use
such mathematical formulas in Axiom to specify ``rewrite rules''.
Rewrite rules are objects in Axiom that can be assigned to variables
for later use, often for the purpose of simplification.  Rewrite rules
look like ordinary function definitions except that they are preceded
by the reserved word <math xmlns="&mathml;" mathsize="big"><mstyle><mi>rule</mi></mstyle></math>.  <span class="index">rule</span><a name="chapter-6-69"/> For example, a rewrite rule
for the above formula is:
</p>



<div class="verbatim"><br />
rule&nbsp;log(x)&nbsp;+&nbsp;log(y)&nbsp;==&nbsp;log(x&nbsp;*&nbsp;y)<br />
</div>



<p>Like function definitions, no action is taken when a rewrite rule is
issued.  Think of rewrite rules as functions that take one argument.
When a rewrite rule <math xmlns="&mathml;" mathsize="big"><mstyle><mrow><mi>A</mi><mo>=</mo><mi>B</mi></mrow></mstyle></math> is applied to an argument <math xmlns="&mathml;" mathsize="big"><mstyle><mi>f</mi></mstyle></math>, its meaning
is: ``rewrite every subexpression of <math xmlns="&mathml;" mathsize="big"><mstyle><mi>f</mi></mstyle></math> that <span class="italic">matches</span> <math xmlns="&mathml;" mathsize="big"><mstyle><mi>A</mi></mstyle></math> by
<math xmlns="&mathml;" mathsize="big"><mstyle><mrow><mi>B</mi><mo>.</mo></mrow></mstyle></math>'' The left-hand side of a rewrite rule is called a <span class="italic">pattern</span>;
its right-side side is called its <span class="italic">substitution</span>.
</p>


<p>Create a rewrite rule named <span style="font-weight: bold;"> logrule</span>.  The generated symbol
beginning with a ``<span class="teletype">%</span>'' is a place-holder for any other terms that
might occur in the sum.
</p>



<div id="spadComm6-202" class="spadComm" >
<form id="formComm6-202" action="javascript:makeRequest('6-202');" >
<input id="comm6-202" type="text" class="command" style="width: 30em;" value="logrule := rule log(x) + log(y) == log(x * y)" />
</form>
<span id="commSav6-202" class="commSav" >logrule := rule log(x) + log(y) == log(x * y)</span>
<div id="mathAns6-202" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mrow><mrow><mo>log</mo><mo>(</mo><mi>y</mi><mo>)</mo></mrow><mo>+</mo><mrow><mo>log</mo><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><mo>%</mo><mi>C</mi></mrow><mtext><mrow><mtext>==</mtext></mrow></mtext><mrow><mrow><mo>log</mo><mo>(</mo><mrow><mi>x</mi><mo></mo><mi>y</mi></mrow><mo>)</mo></mrow><mo>+</mo><mo>%</mo><mi>C</mi></mrow></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: RewriteRule(Integer,Integer,Expression Integer)
</div>



<p>Create an expression with logarithms.
</p>



<div id="spadComm6-203" class="spadComm" >
<form id="formComm6-203" action="javascript:makeRequest('6-203');" >
<input id="comm6-203" type="text" class="command" style="width: 15em;" value="f := log sin x + log x" />
</form>
<span id="commSav6-203" class="commSav" >f := log sin x + log x</span>
<div id="mathAns6-203" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mrow><mo>log</mo><mo>(</mo><mrow><mo>sin</mo><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>)</mo></mrow><mo>+</mo><mrow><mo>log</mo><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: Expression Integer
</div>



<p>Apply <span style="font-weight: bold;"> logrule</span> to <math xmlns="&mathml;" mathsize="big"><mstyle><mi>f</mi></mstyle></math>.
</p>



<div id="spadComm6-204" class="spadComm" >
<form id="formComm6-204" action="javascript:makeRequest('6-204');" >
<input id="comm6-204" type="text" class="command" style="width: 6em;" value="logrule f" />
</form>
<span id="commSav6-204" class="commSav" >logrule f</span>
<div id="mathAns6-204" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mo>log</mo><mo>(</mo><mrow><mi>x</mi><mo></mo><mrow><mo>sin</mo><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow><mo>)</mo></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: Expression Integer
</div>



<p>The meaning of our example rewrite rule is: ``for all expressions <math xmlns="&mathml;" mathsize="big"><mstyle><mi>x</mi></mstyle></math>
and <math xmlns="&mathml;" mathsize="big"><mstyle><mi>y</mi></mstyle></math>, rewrite <math xmlns="&mathml;" mathsize="big"><mstyle><mrow><mi>log</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>+</mo><mi>log</mi><mo>(</mo><mi>y</mi><mo>)</mo></mrow></mstyle></math> by <math xmlns="&mathml;" mathsize="big"><mstyle><mrow><mi>log</mi><mo>(</mo><mi>x</mi><mo>*</mo><mi>y</mi><mo>)</mo></mrow></mstyle></math>.''  Patterns
generally have both operation names (here, <span style="font-weight: bold;"> log</span> and ``<span class="teletype">+</span>'') and
variables (here, <math xmlns="&mathml;" mathsize="big"><mstyle><mi>x</mi></mstyle></math> and <math xmlns="&mathml;" mathsize="big"><mstyle><mi>y</mi></mstyle></math>).  By default, every operation name
stands for itself.  Thus <span style="font-weight: bold;"> log</span> matches only ``<math xmlns="&mathml;" mathsize="big"><mstyle><mi>log</mi></mstyle></math>'' and not any
other operation such as <span style="font-weight: bold;"> sin</span>.  On the other hand, variables do
not stand for themselves.  Rather, a variable denotes a <span class="italic">pattern
variable</span> that is free to match any expression whatsoever.
<span class="index">pattern:variables</span><a name="chapter-6-70"/>
</p>


<p>When a rewrite rule is applied, a process called 
<span class="italic">pattern matching</span> goes to work by systematically scanning
<span class="index">pattern:matching</span><a name="chapter-6-71"/> the subexpressions of the argument.  When a
subexpression is found that ``matches'' the pattern, the subexpression
is replaced by the right-hand side of the rule.  The details of what
happens will be covered later.
</p>


<p>The customary Axiom notation for patterns is actually a shorthand for
a longer, more general notation.  Pattern variables can be made
explicit by using a percent ``<span class="teletype">%</span>'' as the first character of the
variable name.  To say that a name stands for itself, you can prefix
that name with a quote operator ``<span class="teletype">'</span>''.  Although the current Axiom
parser does not let you quote an operation name, this more general
notation gives you an alternate way of giving the same rewrite rule:
</p>



<div class="verbatim"><br />
rule&nbsp;log(%x)&nbsp;+&nbsp;log(%y)&nbsp;==&nbsp;log(x&nbsp;*&nbsp;y)<br />
</div>



<p>This longer notation gives you patterns that the standard notation
won't handle.  For example, the rule
</p>



<div class="verbatim"><br />
rule&nbsp;%f(c&nbsp;*&nbsp;'x)&nbsp;==&nbsp;&nbsp;c*%f(x)<br />
</div>


<p>means ``for all <math xmlns="&mathml;" mathsize="big"><mstyle><mi>f</mi></mstyle></math> and <math xmlns="&mathml;" mathsize="big"><mstyle><mi>c</mi></mstyle></math>, replace <math xmlns="&mathml;" mathsize="big"><mstyle><mrow><mi>f</mi><mo>(</mo><mi>y</mi><mo>)</mo></mrow></mstyle></math> by <math xmlns="&mathml;" mathsize="big"><mstyle><mrow><mi>c</mi><mo>*</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mstyle></math> when <math xmlns="&mathml;" mathsize="big"><mstyle><mi>y</mi></mstyle></math> is
the product of <math xmlns="&mathml;" mathsize="big"><mstyle><mi>c</mi></mstyle></math> and the explicit variable <math xmlns="&mathml;" mathsize="big"><mstyle><mi>x</mi></mstyle></math>.''
</p>


<p>Thus the pattern can have several adornments on the names that appear there.
Normally, all these adornments are dropped in the substitution on the
right-hand side.
</p>


<p>To summarize:
</p>




<div class="boxed2">


<div class="boxed">



<p>To enter a single rule in Axiom, use the following syntax: <span class="index">rule</span><a name="chapter-6-72"/>
</p>



<div class="center" style="text-align: center;">


<p><span class="teletype">rule <span class="italic">leftHandSide</span> == <span class="italic">rightHandSide</span></span>
</p>



</div>



<p>The <span class="italic">leftHandSide</span> is a pattern to be matched and the <span class="italic">
rightHandSide</span> is its substitution.  The rule is an object of type
<span class="teletype">RewriteRule</span> that can be assigned to a variable and applied to
expressions to transform them.<br/>
</p>



</div>
</div>



<p>Rewrite rules can be collected
into rulesets so that a set of rules can be applied at once.
Here is another simplification rule for logarithms.
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mrow><mi>y</mi><mo>&InvisibleTimes;</mo><mrow><mo>log</mo><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mo>log</mo><mo>(</mo><mrow><msup><mi>x</mi><mi>y</mi></msup></mrow><mo>)</mo></mrow></mrow></mrow><mspace width="1em"/><mo>&#x2200;</mo><mi>x</mi><mspace width="0.5em"/><mtext>and</mtext><mspace width="0.5em"/><mi>y</mi></mstyle></math>

If instead of giving a single rule following the reserved word <math xmlns="&mathml;" mathsize="big"><mstyle><mi>rule</mi></mstyle></math>
you give a ``pile'' of rules, you create what is called a <span class="italic">
ruleset.</span>  <span class="index">ruleset</span><a name="chapter-6-73"/> Like rules, rulesets are objects in Axiom
and can be assigned to variables.  You will find it useful to group
commonly used rules into input files, and read them in as needed.
</p>


<p>Create a ruleset named <math xmlns="&mathml;" mathsize="big"><mstyle><mi>logrules</mi></mstyle></math>.
</p>



<div class="verbatim"><br />
logrules&nbsp;:=&nbsp;rule<br />
&nbsp;&nbsp;log(x)&nbsp;+&nbsp;log(y)&nbsp;==&nbsp;log(x&nbsp;*&nbsp;y)<br />
&nbsp;&nbsp;y&nbsp;*&nbsp;log&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;==&nbsp;log(x&nbsp;**&nbsp;y)<br />
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mo>{</mo><mrow><mrow><mrow><mo>log</mo><mo>(</mo><mi>y</mi><mo>)</mo></mrow><mo>+</mo><mrow><mo>log</mo><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><mo>%</mo><mi>B</mi></mrow><mtext><mrow><mtext>==</mtext></mrow></mtext><mrow><mrow><mo>log</mo><mo>(</mo><mrow><mi>x</mi><mo></mo><mi>y</mi></mrow><mo>)</mo></mrow><mo>+</mo><mo>%</mo><mi>B</mi></mrow></mrow><mo>,</mo><mrow><mrow><mi>y</mi><mo></mo><mrow><mo>log</mo><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow><mtext><mrow><mtext>==</mtext></mrow></mtext><mrow><mo>log</mo><mo>(</mo><mrow><msup><mi>x</mi><mi>y</mi></msup></mrow><mo>)</mo></mrow></mrow><mo>}</mo></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: Ruleset(Integer,Integer,Expression Integer)
</div>



<p>Again, create an expression <math xmlns="&mathml;" mathsize="big"><mstyle><mi>f</mi></mstyle></math> containing logarithms.
</p>



<div id="spadComm6-205" class="spadComm" >
<form id="formComm6-205" action="javascript:makeRequest('6-205');" >
<input id="comm6-205" type="text" class="command" style="width: 21em;" value="f := a * log(sin x) - 2 * log x" />
</form>
<span id="commSav6-205" class="commSav" >f := a * log(sin x) - 2 * log x</span>
<div id="mathAns6-205" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mrow><mi>a</mi><mo></mo><mrow><mo>log</mo><mo>(</mo><mrow><mo>sin</mo><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>)</mo></mrow></mrow><mo>-</mo><mrow><mn>2</mn><mo></mo><mrow><mo>log</mo><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: Expression Integer
</div>



<p>Apply the ruleset <span style="font-weight: bold;"> logrules</span> to <math xmlns="&mathml;" mathsize="big"><mstyle><mi>f</mi></mstyle></math>.
</p>



<div id="spadComm6-206" class="spadComm" >
<form id="formComm6-206" action="javascript:makeRequest('6-206');" >
<input id="comm6-206" type="text" class="command" style="width: 7em;" value="logrules f" />
</form>
<span id="commSav6-206" class="commSav" >logrules f</span>
<div id="mathAns6-206" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mo>log</mo><mo>(</mo><mfrac><mrow><msup><mrow><mo>sin</mo><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mi>a</mi></msup></mrow><mrow><msup><mi>x</mi><mn>2</mn></msup></mrow></mfrac><mo>)</mo></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: Expression Integer
</div>




<p>We have allowed pattern variables to match arbitrary expressions in
the above examples.  Often you want a variable only to match
expressions satisfying some predicate.  For example, we may want to
apply the transformation 
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mi>y</mi><mo>log</mo><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mo>log</mo><mo>(</mo><msup><mi>x</mi><mi>y</mi></msup><mo>)</mo></mrow></mstyle></math> 
only when <math xmlns="&mathml;" mathsize="big"><mstyle><mi>y</mi></mstyle></math> is an integer.
</p>


<p>The way to restrict a pattern variable <math xmlns="&mathml;" mathsize="big"><mstyle><mi>y</mi></mstyle></math> by a predicate <math xmlns="&mathml;" mathsize="big"><mstyle><mrow><mi>f</mi><mo>(</mo><mi>y</mi><mo>)</mo></mrow></mstyle></math>
<span class="index">pattern:variable:predicate</span><a name="chapter-6-74"/> is by using a vertical bar ``<span class="teletype">|</span>'',
which means ``such that,'' in <span class="index">such that</span><a name="chapter-6-75"/> much the same way it
is used in function definitions.  <span class="index">predicate:on a pattern
variable</span><a name="chapter-6-76"/> You do this only once, but at the earliest (meaning deepest
and leftmost) part of the pattern.
</p>


<p>This restricts the logarithmic rule to create integer exponents only.
</p>



<div class="verbatim"><br />
logrules2&nbsp;:=&nbsp;rule<br />
&nbsp;&nbsp;log(x)&nbsp;+&nbsp;log(y)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;==&nbsp;log(x&nbsp;*&nbsp;y)<br />
&nbsp;&nbsp;(y&nbsp;|&nbsp;integer?&nbsp;y)&nbsp;*&nbsp;log&nbsp;x&nbsp;==&nbsp;log(x&nbsp;**&nbsp;y)<br />
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mo>{</mo><mrow><mrow><mrow><mo>log</mo><mo>(</mo><mi>y</mi><mo>)</mo></mrow><mo>+</mo><mrow><mo>log</mo><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>+</mo><mo>%</mo><mi>D</mi></mrow><mtext><mrow><mtext>==</mtext></mrow></mtext><mrow><mrow><mo>log</mo><mo>(</mo><mrow><mi>x</mi><mo></mo><mi>y</mi></mrow><mo>)</mo></mrow><mo>+</mo><mo>%</mo><mi>D</mi></mrow></mrow><mo>,</mo><mrow><mrow><mi>y</mi><mo></mo><mrow><mo>log</mo><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow><mtext><mrow><mtext>==</mtext></mrow></mtext><mrow><mo>log</mo><mo>(</mo><mrow><msup><mi>x</mi><mi>y</mi></msup></mrow><mo>)</mo></mrow></mrow><mo>}</mo></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: Ruleset(Integer,Integer,Expression Integer)
</div>



<p>Compare this with the result of applying the previous set of rules.
</p>



<div id="spadComm6-207" class="spadComm" >
<form id="formComm6-207" action="javascript:makeRequest('6-207');" >
<input id="comm6-207" type="text" class="command" style="width: 1em;" value="f" />
</form>
<span id="commSav6-207" class="commSav" >f</span>
<div id="mathAns6-207" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mrow><mi>a</mi><mo></mo><mrow><mo>log</mo><mo>(</mo><mrow><mo>sin</mo><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>)</mo></mrow></mrow><mo>-</mo><mrow><mn>2</mn><mo></mo><mrow><mo>log</mo><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: Expression Integer
</div>





<div id="spadComm6-208" class="spadComm" >
<form id="formComm6-208" action="javascript:makeRequest('6-208');" >
<input id="comm6-208" type="text" class="command" style="width: 8em;" value="logrules2 f" />
</form>
<span id="commSav6-208" class="commSav" >logrules2 f</span>
<div id="mathAns6-208" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mrow><mi>a</mi><mo></mo><mrow><mo>log</mo><mo>(</mo><mrow><mo>sin</mo><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>)</mo></mrow></mrow><mo>+</mo><mrow><mo>log</mo><mo>(</mo><mfrac><mn>1</mn><mrow><msup><mi>x</mi><mn>2</mn></msup></mrow></mfrac><mo>)</mo></mrow></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: Expression Integer
</div>



<p>You should be aware that you might need to apply a function like 
<span class="teletype">integer</span> within your predicate expression to actually apply the test
function.
</p>


<p>Here we use <span class="teletype">integer</span> because <math xmlns="&mathml;" mathsize="big"><mstyle><mi>n</mi></mstyle></math> has type <span class="teletype">Expression
Integer</span> but <span style="font-weight: bold;"> even?</span> is an operation defined on integers.
</p>



<div id="spadComm6-209" class="spadComm" >
<form id="formComm6-209" action="javascript:makeRequest('6-209');" >
<input id="comm6-209" type="text" class="command" style="width: 56em;" value="evenRule := rule cos(x)**(n | integer? n and even? integer n)==(1-sin(x)**2)**(n/2)" />
</form>
<span id="commSav6-209" class="commSav" >evenRule := rule cos(x)**(n | integer? n and even? integer n)==(1-sin(x)**2)**(n/2)</span>
<div id="mathAns6-209" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mrow><msup><mrow><mo>cos</mo><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mi>n</mi></msup></mrow><mtext><mrow><mtext>==</mtext></mrow></mtext><mrow><msup><mrow><mo>(</mo><mo>-</mo><mrow><msup><mrow><mo>sin</mo><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mn>2</mn></msup></mrow><mo>+</mo><mn>1</mn><mo>)</mo></mrow><mfrac><mi>n</mi><mn>2</mn></mfrac></msup></mrow></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: RewriteRule(Integer,Integer,Expression Integer)
</div>



<p>Here is the application of the rule.
</p>



<div id="spadComm6-210" class="spadComm" >
<form id="formComm6-210" action="javascript:makeRequest('6-210');" >
<input id="comm6-210" type="text" class="command" style="width: 14em;" value="evenRule( cos(x)**2 )" />
</form>
<span id="commSav6-210" class="commSav" >evenRule( cos(x)**2 )</span>
<div id="mathAns6-210" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mo>-</mo><mrow><msup><mrow><mo>sin</mo><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mn>2</mn></msup></mrow><mo>+</mo><mn>1</mn></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: Expression Integer
</div>



<p>This is an example of some of the usual identities involving products of
sines and cosines.
</p>



<div class="verbatim"><br />
sinCosProducts&nbsp;==&nbsp;rule<br />
&nbsp;&nbsp;sin(x)&nbsp;*&nbsp;sin(y)&nbsp;==&nbsp;(cos(x-y)&nbsp;-&nbsp;cos(x&nbsp;+&nbsp;y))/2<br />
&nbsp;&nbsp;cos(x)&nbsp;*&nbsp;cos(y)&nbsp;==&nbsp;(cos(x-y)&nbsp;+&nbsp;cos(x+y))/2<br />
&nbsp;&nbsp;sin(x)&nbsp;*&nbsp;cos(y)&nbsp;==&nbsp;(sin(x-y)&nbsp;+&nbsp;sin(x&nbsp;+&nbsp;y))/2<br />
</div>




<div class="returnType">
Type: Void
</div>





<div id="spadComm6-211" class="spadComm" >
<form id="formComm6-211" action="javascript:makeRequest('6-211');" >
<input id="comm6-211" type="text" class="command" style="width: 36em;" value="g := sin(a)*sin(b) + cos(b)*cos(a) + sin(2*a)*cos(2*a)" />
</form>
<span id="commSav6-211" class="commSav" >g := sin(a)*sin(b) + cos(b)*cos(a) + sin(2*a)*cos(2*a)</span>
<div id="mathAns6-211" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mrow><mrow><mo>sin</mo><mo>(</mo><mi>a</mi><mo>)</mo></mrow><mo></mo><mrow><mo>sin</mo><mo>(</mo><mi>b</mi><mo>)</mo></mrow></mrow><mo>+</mo><mrow><mrow><mo>cos</mo><mo>(</mo><mrow><mn>2</mn><mo></mo><mi>a</mi></mrow><mo>)</mo></mrow><mo></mo><mrow><mo>sin</mo><mo>(</mo><mrow><mn>2</mn><mo></mo><mi>a</mi></mrow><mo>)</mo></mrow></mrow><mo>+</mo><mrow><mrow><mo>cos</mo><mo>(</mo><mi>a</mi><mo>)</mo></mrow><mo></mo><mrow><mo>cos</mo><mo>(</mo><mi>b</mi><mo>)</mo></mrow></mrow></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: Expression Integer
</div>





<div id="spadComm6-212" class="spadComm" >
<form id="formComm6-212" action="javascript:makeRequest('6-212');" >
<input id="comm6-212" type="text" class="command" style="width: 11em;" value="sinCosProducts g" />
</form>
<span id="commSav6-212" class="commSav" >sinCosProducts g</span>
<div id="mathAns6-212" ></div>
</div>




<div class="verbatim"><br />
&nbsp;&nbsp;&nbsp;Compiling&nbsp;body&nbsp;of&nbsp;rule&nbsp;sinCosProducts&nbsp;to&nbsp;compute&nbsp;value&nbsp;of&nbsp;type&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ruleset(Integer,Integer,Expression&nbsp;Integer)&nbsp;<br />
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mfrac><mrow><mrow><mo>sin</mo><mo>(</mo><mrow><mn>4</mn><mo></mo><mi>a</mi></mrow><mo>)</mo></mrow><mo>+</mo><mrow><mn>2</mn><mo></mo><mrow><mo>cos</mo><mo>(</mo><mrow><mi>b</mi><mo>-</mo><mi>a</mi></mrow><mo>)</mo></mrow></mrow></mrow><mn>2</mn></mfrac></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: Expression Integer
</div>



<p>Another qualification you will often want to use is to allow a pattern to
match an identity element.
Using the pattern <math xmlns="&mathml;" mathsize="big"><mstyle><mrow><mi>x</mi><mo>+</mo><mi>y</mi></mrow></mstyle></math>, for example, neither <math xmlns="&mathml;" mathsize="big"><mstyle><mi>x</mi></mstyle></math> nor <math xmlns="&mathml;" mathsize="big"><mstyle><mi>y</mi></mstyle></math>
matches the expression <math xmlns="&mathml;" mathsize="big"><mstyle><mn>0</mn></mstyle></math>.
Similarly, if a pattern contains a product <math xmlns="&mathml;" mathsize="big"><mstyle><mrow><mi>x</mi><mo>*</mo><mi>y</mi></mrow></mstyle></math> or an exponentiation
<math xmlns="&mathml;" mathsize="big"><mstyle><mrow><mi>x</mi><mo>*</mo><mo>*</mo><mi>y</mi></mrow></mstyle></math>, then neither <math xmlns="&mathml;" mathsize="big"><mstyle><mi>x</mi></mstyle></math> or <math xmlns="&mathml;" mathsize="big"><mstyle><mi>y</mi></mstyle></math> matches <math xmlns="&mathml;" mathsize="big"><mstyle><mn>1</mn></mstyle></math>.
</p>


<p>If identical elements were matched, pattern matching would generally loop.
Here is an expansion rule for exponentials.
</p>



<div id="spadComm6-213" class="spadComm" >
<form id="formComm6-213" action="javascript:makeRequest('6-213');" >
<input id="comm6-213" type="text" class="command" style="width: 30em;" value="exprule := rule exp(a + b) == exp(a) * exp(b)" />
</form>
<span id="commSav6-213" class="commSav" >exprule := rule exp(a + b) == exp(a) * exp(b)</span>
<div id="mathAns6-213" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mrow><msup><mi>e</mi><mrow><mo>(</mo><mi>b</mi><mo>+</mo><mi>a</mi><mo>)</mo></mrow></msup></mrow><mtext><mrow><mtext>==</mtext></mrow></mtext><mrow><mrow><msup><mi>e</mi><mi>a</mi></msup></mrow><mo></mo><mrow><msup><mi>e</mi><mi>b</mi></msup></mrow></mrow></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: RewriteRule(Integer,Integer,Expression Integer)
</div>



<p>This rule would cause infinite rewriting on this if either <math xmlns="&mathml;" mathsize="big"><mstyle><mi>a</mi></mstyle></math> or
<math xmlns="&mathml;" mathsize="big"><mstyle><mi>b</mi></mstyle></math> were allowed to match <math xmlns="&mathml;" mathsize="big"><mstyle><mn>0</mn></mstyle></math>.
</p>



<div id="spadComm6-214" class="spadComm" >
<form id="formComm6-214" action="javascript:makeRequest('6-214');" >
<input id="comm6-214" type="text" class="command" style="width: 9em;" value="exprule exp x" />
</form>
<span id="commSav6-214" class="commSav" >exprule exp x</span>
<div id="mathAns6-214" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><msup><mi>e</mi><mi>x</mi></msup></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: Expression Integer
</div>



<p>There are occasions when you do want a pattern variable in a sum or
product to match <math xmlns="&mathml;" mathsize="big"><mstyle><mn>0</mn></mstyle></math> or <math xmlns="&mathml;" mathsize="big"><mstyle><mn>1</mn></mstyle></math>. If so, prefix its name
with a ``<span class="teletype">?</span>'' whenever it appears in a left-hand side of a rule.
For example, consider the following rule for the exponential integral:
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle></mstyle></math>
This rule is valid for <math xmlns="&mathml;" mathsize="big"><mstyle><mrow><mi>y</mi><mo>=</mo><mn>0</mn></mrow></mstyle></math>.  One solution is to create a <span class="teletype">Ruleset</span> with two rules, one with and one without <math xmlns="&mathml;" mathsize="big"><mstyle><mi>y</mi></mstyle></math>.  A better
solution is to use an ``optional'' pattern variable.
</p>


<p>Define rule <span class="teletype">eirule</span> with
a pattern variable <math xmlns="&mathml;" mathsize="big"><mstyle></mstyle></math> to indicate
that an expression may or may not occur.
</p>



<div id="spadComm6-215" class="spadComm" >
<form id="formComm6-215" action="javascript:makeRequest('6-215');" >
<input id="comm6-215" type="text" class="command" style="width: 45em;" value="eirule := rule integral((?y + exp x)/x,x) == integral(y/x,x) + Ei x" />
</form>
<span id="commSav6-215" class="commSav" >eirule := rule integral((?y + exp x)/x,x) == integral(y/x,x) + Ei x</span>
<div id="mathAns6-215" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mrow><msup><mo>&#x222B;</mo><mrow><mi>x</mi></mrow></msup><mrow><mfrac><mrow><mrow><msup><mi>e</mi><mo>%</mo></msup><mi>M</mi></mrow><mo>+</mo><mi>y</mi></mrow><mrow><mo>%</mo><mi>M</mi></mrow></mfrac><mo></mo><mrow><mi>d</mi><mo>%</mo><mi>M</mi></mrow></mrow></mrow><mtext><mrow><mtext>==</mtext></mrow></mtext><mrow><mrow><mrow><mrow><mtext mathvariant='monospace'>'</mtext></mrow><mi>integral</mi></mrow><mo>(</mo><mrow><mfrac><mi>y</mi><mi>x</mi></mfrac><mo>,</mo><mi>x</mi></mrow><mo>)</mo></mrow><mo>+</mo><mrow><mrow><mrow><mtext mathvariant='monospace'>'</mtext></mrow><mi>Ei</mi></mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: RewriteRule(Integer,Integer,Expression Integer)
</div>



<p>Apply rule <span class="teletype">eirule</span> to an integral without this term.
</p>



<div id="spadComm6-216" class="spadComm" >
<form id="formComm6-216" action="javascript:makeRequest('6-216');" >
<input id="comm6-216" type="text" class="command" style="width: 18em;" value="eirule integral(exp u/u, u)" />
</form>
<span id="commSav6-216" class="commSav" >eirule integral(exp u/u, u)</span>
<div id="mathAns6-216" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mi>Ei</mi><mo>(</mo><mi>u</mi><mo>)</mo></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: Expression Integer
</div>



<p>Apply rule <span class="teletype">eirule</span> to an integral with this term.
</p>



<div id="spadComm6-217" class="spadComm" >
<form id="formComm6-217" action="javascript:makeRequest('6-217');" >
<input id="comm6-217" type="text" class="command" style="width: 24em;" value="eirule integral(sin u + exp u/u, u)" />
</form>
<span id="commSav6-217" class="commSav" >eirule integral(sin u + exp u/u, u)</span>
<div id="mathAns6-217" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mrow><msup><mo>&#x222B;</mo><mrow><mi>u</mi></mrow></msup><mrow><mrow><mo>sin</mo><mo>(</mo><mrow><mo>%</mo><mi>M</mi></mrow><mo>)</mo></mrow><mo></mo><mrow><mi>d</mi><mo>%</mo><mi>M</mi></mrow></mrow></mrow><mo>+</mo><mrow><mi>Ei</mi><mo>(</mo><mi>u</mi><mo>)</mo></mrow></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: Expression Integer
</div>



<p>Here is one final adornment you will find useful.  When matching a
pattern of the form <math xmlns="&mathml;" mathsize="big"><mstyle><mrow><mi>x</mi><mo>+</mo><mi>y</mi></mrow></mstyle></math> to an expression containing a long sum of
the form <math xmlns="&mathml;" mathsize="big"><mstyle><mrow><mi>a</mi><mo>+</mo><mo>&#x2026;</mo><mo>+</mo><mi>b</mi></mrow></mstyle></math>, there is no way to predict in advance which
subset of the sum matches <math xmlns="&mathml;" mathsize="big"><mstyle><mi>x</mi></mstyle></math> and which matches <math xmlns="&mathml;" mathsize="big"><mstyle><mi>y</mi></mstyle></math>.  Aside from
efficiency, this is generally unimportant since the rule holds for any
possible combination of matches for <math xmlns="&mathml;" mathsize="big"><mstyle><mi>x</mi></mstyle></math> and <math xmlns="&mathml;" mathsize="big"><mstyle><mi>y</mi></mstyle></math>.  In some situations,
however, you may want to say which pattern variable is a sum (or
product) of several terms, and which should match only a single term.
To do this, put a prefix colon ``<span class="teletype">:</span>'' before the pattern variable
that you want to match multiple terms.
<span class="index">pattern:variable:matching several terms</span><a name="chapter-6-77"/>
</p>


<p>The remaining rules involve operators <math xmlns="&mathml;" mathsize="big"><mstyle><mi>u</mi></mstyle></math> and <math xmlns="&mathml;" mathsize="big"><mstyle><mi>v</mi></mstyle></math>. <span class="index">operator</span><a name="chapter-6-78"/>
</p>



<div id="spadComm6-218" class="spadComm" >
<form id="formComm6-218" action="javascript:makeRequest('6-218');" >
<input id="comm6-218" type="text" class="command" style="width: 11em;" value="u := operator 'u" />
</form>
<span id="commSav6-218" class="commSav" >u := operator 'u</span>
<div id="mathAns6-218" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mi>u</mi></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: BasicOperator
</div>



<p>These definitions tell Axiom that <math xmlns="&mathml;" mathsize="big"><mstyle><mi>u</mi></mstyle></math> and <math xmlns="&mathml;" mathsize="big"><mstyle><mi>v</mi></mstyle></math> are formal operators to
be used in expressions.
</p>



<div id="spadComm6-219" class="spadComm" >
<form id="formComm6-219" action="javascript:makeRequest('6-219');" >
<input id="comm6-219" type="text" class="command" style="width: 11em;" value="v := operator 'v" />
</form>
<span id="commSav6-219" class="commSav" >v := operator 'v</span>
<div id="mathAns6-219" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mi>v</mi></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: BasicOperator
</div>



<p>First define <span class="teletype">myRule</span> with no restrictions on the pattern variables
<math xmlns="&mathml;" mathsize="big"><mstyle><mi>x</mi></mstyle></math> and <math xmlns="&mathml;" mathsize="big"><mstyle><mi>y</mi></mstyle></math>.
</p>



<div id="spadComm6-220" class="spadComm" >
<form id="formComm6-220" action="javascript:makeRequest('6-220');" >
<input id="comm6-220" type="text" class="command" style="width: 24em;" value="myRule := rule u(x + y) == u x + v y" />
</form>
<span id="commSav6-220" class="commSav" >myRule := rule u(x + y) == u x + v y</span>
<div id="mathAns6-220" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mrow><mi>u</mi><mo>(</mo><mrow><mi>y</mi><mo>+</mo><mi>x</mi></mrow><mo>)</mo></mrow><mtext><mrow><mtext>==</mtext></mrow></mtext><mrow><mrow><mrow><mrow><mtext mathvariant='monospace'>'</mtext></mrow><mi>v</mi></mrow><mo>(</mo><mi>y</mi><mo>)</mo></mrow><mo>+</mo><mrow><mrow><mrow><mtext mathvariant='monospace'>'</mtext></mrow><mi>u</mi></mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: RewriteRule(Integer,Integer,Expression Integer)
</div>



<p>Apply <span class="teletype">myRule</span> to an expression.
</p>



<div id="spadComm6-221" class="spadComm" >
<form id="formComm6-221" action="javascript:makeRequest('6-221');" >
<input id="comm6-221" type="text" class="command" style="width: 16em;" value="myRule u(a + b + c + d)" />
</form>
<span id="commSav6-221" class="commSav" >myRule u(a + b + c + d)</span>
<div id="mathAns6-221" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mrow><mi>v</mi><mo>(</mo><mrow><mi>d</mi><mo>+</mo><mi>c</mi><mo>+</mo><mi>b</mi></mrow><mo>)</mo></mrow><mo>+</mo><mrow><mi>u</mi><mo>(</mo><mi>a</mi><mo>)</mo></mrow></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: Expression Integer
</div>



<p>Define <span class="teletype">myOtherRule</span> to match several terms so that the rule gets
applied recursively.
</p>



<div id="spadComm6-222" class="spadComm" >
<form id="formComm6-222" action="javascript:makeRequest('6-222');" >
<input id="comm6-222" type="text" class="command" style="width: 28em;" value="myOtherRule := rule u(:x + y) == u x + v y" />
</form>
<span id="commSav6-222" class="commSav" >myOtherRule := rule u(:x + y) == u x + v y</span>
<div id="mathAns6-222" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mrow><mi>u</mi><mo>(</mo><mrow><mi>y</mi><mo>+</mo><mi>x</mi></mrow><mo>)</mo></mrow><mtext><mrow><mtext>==</mtext></mrow></mtext><mrow><mrow><mrow><mrow><mtext mathvariant='monospace'>'</mtext></mrow><mi>v</mi></mrow><mo>(</mo><mi>y</mi><mo>)</mo></mrow><mo>+</mo><mrow><mrow><mrow><mtext mathvariant='monospace'>'</mtext></mrow><mi>u</mi></mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: RewriteRule(Integer,Integer,Expression Integer)
</div>



<p>Apply <span class="teletype">myOtherRule</span> to the same expression.
</p>



<div id="spadComm6-223" class="spadComm" >
<form id="formComm6-223" action="javascript:makeRequest('6-223');" >
<input id="comm6-223" type="text" class="command" style="width: 19em;" value="myOtherRule u(a + b + c + d)" />
</form>
<span id="commSav6-223" class="commSav" >myOtherRule u(a + b + c + d)</span>
<div id="mathAns6-223" ></div>
</div>


<div class="math">
<table>
<tr><td>
<math xmlns="&mathml;" mathsize="big" display="block"><mstyle><mrow><mrow><mi>v</mi><mo>(</mo><mi>c</mi><mo>)</mo></mrow><mo>+</mo><mrow><mi>v</mi><mo>(</mo><mi>b</mi><mo>)</mo></mrow><mo>+</mo><mrow><mi>v</mi><mo>(</mo><mi>a</mi><mo>)</mo></mrow><mo>+</mo><mrow><mi>u</mi><mo>(</mo><mi>d</mi><mo>)</mo></mrow></mrow></mstyle></math>
</td></tr>
</table>
</div>




<div class="returnType">
Type: Expression Integer
</div>





<div class="boxed2">


<div class="boxed">



<p>Summary of pattern variable adornments:
</p>


<p><table class="begintabular">
<tr><td><span class="teletype">(x | predicate?(x))</span> </td><td> means that the substutution <math xmlns="&mathml;" mathsize="big"><mstyle><mi>s</mi></mstyle></math> for <math xmlns="&mathml;" mathsize="big"><mstyle><mi>x</mi></mstyle></math> must satisfy <span class="teletype">predicate(s) = true.</span> </td></tr>
<tr><td><span class="teletype">?x</span> </td><td> means that <math xmlns="&mathml;" mathsize="big"><mstyle><mi>x</mi></mstyle></math> can match an identity element (0 or 1). </td></tr>
<tr><td><span class="teletype">:x</span> </td><td> means that <math xmlns="&mathml;" mathsize="big"><mstyle><mi>x</mi></mstyle></math> can match several terms in a sum.</td></tr> 
</table>
</p>



</div>
</div>



<p>Here are some final remarks on pattern matching.  Pattern matching
provides a very useful paradigm for solving certain classes of
problems, namely, those that involve transformations of one form to
another and back.  However, it is important to recognize its
limitations.  <span class="index">pattern:matching:caveats</span><a name="chapter-6-79"/>
</p>


<p>First, pattern matching slows down as the number of rules you have to
apply increases.  Thus it is good practice to organize the sets of
rules you use optimally so that irrelevant rules are never included.
</p>


<p>Second, careless use of pattern matching can lead to wrong answers.
You should avoid using pattern matching to handle hidden algebraic
relationships that can go undetected by other programs.  As a simple
example, a symbol such as ``J'' can easily be used to represent the
square root of <math xmlns="&mathml;" mathsize="big"><mstyle><mrow><mo>-</mo><mn>1</mn></mrow></mstyle></math> or some other important algebraic quantity.  Many
algorithms branch on whether an expression is zero or not, then divide
by that expression if it is not.  If you fail to simplify an
expression involving powers of <math xmlns="&mathml;" mathsize="big"><mstyle><mi>J</mi></mstyle></math> to <math xmlns="&mathml;" mathsize="big"><mstyle><mrow><mo>-</mo><mn>1</mn><mo>,</mo></mrow></mstyle></math> algorithms may incorrectly
assume an expression is non-zero, take a wrong branch, and produce a
meaningless result.
</p>


<p>Pattern matching should also not be used as a substitute for a domain.
In Axiom, objects of one domain are transformed to objects of other
domains using well-defined <span style="font-weight: bold;"> coerce</span> operations.  Pattern matching
should be used on objects that are all the same type.  Thus if your
application can be handled by type <span class="teletype">Expression</span> in Axiom and you
think you need pattern matching, consider this choice carefully.
<span class="index">Expression</span><a name="chapter-6-80"/> You may well be better served by extending an
existing domain or by building a new domain of objects for your
application.
</p>




</div><a href="book-contents.xhtml" style="margin-right: 10px;">Book Contents</a>
<a href="section-6.20.xhtml" style="margin-right: 10px;">Previous Section 6.20 Example: Testing for Palindromes</a><a href="section-7.0.xhtml" style="margin-right: 10px;">Next Section 7.0 Graphics</a><a href="book-index.xhtml">Book Index</a></body>
</html>