\documentclass{article}
\usepackage{axiom}
\usepackage{graphicx}
\setlength{\textwidth}{400pt}
\begin{document}
\title{The Math Behind Bitcoin\cite{1}}
\author{Eric Walder and Timothy Daly}
\maketitle
\begin{abstract}
A review of the mathematics behind bitcoin. Also a demonstration
of finite field arithmetic and graphics generation in Axiom.
\end{abstract}
\newpage
\tableofcontents
\newpage

One reason Bitcoin can be confusing for beginners is that the
technology behind it redefines the concept of ownership.

To own something in the traditional sense, be it a house or a sum of
money, means either having personal custody of the thing or granting
custody to a trusted entity such as a bank.

With Bitcoin the case is different. Bitcoins themselves are not stored
either centrally or locally and so no one entity is their
custodian. They exist as records on a distributed ledger called the
block chain, copies of which are shared by a volunteer network of
connected computers. To ``own'' a bitcoin simply means having the
ability to transfer control of it to someone else by creating a record
of the transfer in the block chain. What grants this ability? Access
to an ECDSA private and public key pair. What does that mean and how
does that secure Bitcoin?

Let's have a look under the hood.

ECDSA is short for Elliptic Curve Digital Signature Algorithm. It's a
process that uses an elliptic curve and a finite field to ``sign'' data
in such a way that third parties can verify the authenticity of the
signature while the signer retains the exclusive ability to create the
signature. With Bitcoin, the data that is signed is the transaction
that transfers ownership.

ECDSA has separate procedures for signing and verification. Each
procedure is an algorithm composed of a few arithmetic operations. The
signing algorithm makes use of the private key, and the verification
process makes use of the public key. We will show an example of this
later.

But first, a crash course on elliptic curves and finite fields.

\section{Elliptic Curves}

An elliptic curve is represented algebraically as an equation of the form:

\begin{verbatim}
    y2 = x3 + ax + b
\end{verbatim}

For a = 0 and b = 7 (the version used by Bitcoin), it looks like this:

\includegraphics[scale=0.5]{bitcoin1.eps}
\begin{chunk}{*}
)clear all
bitcoin1:=draw(y^2-x^3-7=0,x,y,range==[-5..5,-5..5],title=="Bitcoin curve")
axes(bitcoin1,1,"on")
units(bitcoin1,1,"on")
points(bitcoin1,1,"off")

\end{chunk}

Elliptic curves have useful properties. For example, a non-vertical
line intersecting two non-tangent points on the curve will always
intersect a third point on the curve. A further property is that a
non-vertical line tangent to the curve at one point will intersect
precisely one other point on the curve.

We can use these properties to define two operations: point addition
and point doubling.

Point addition, P + Q = R, is defined as the reflection through the
x-axis of the third intersecting point R’ on a line that includes P
and Q. It's easiest to understand this using a diagram:

\includegraphics[scale=0.5]{bitcoin2.eps}
\begin{chunk}{*}
)clear all
t1:=draw(0.5*x+2.5,x=-5..5)
t2:=getGraph(t1,1)
t3:=draw(10*x-15=0,x,y,range==[-5..5,-5..5])
t4:=getGraph(t3,1)
bitcoin2:=draw(y^2-x^3-7=0,x,y,range==[-5..5,-5..5],title=="Point Addition")
putGraph(bitcoin2,t2,2)
putGraph(bitcoin2,t4,3)
axes(bitcoin2,1,"on")
units(bitcoin2,1,"on")
points(bitcoin2,1,"off")
makeViewport2D(bitcoin2)

\end{chunk}

Similarly, point doubling, P + P = R is defined by finding the line
tangent to the point to be doubled, P, and taking reflection through
the x-axis of the intersecting point R' on the curve to get R. Here's
an example of what that would look like:

\includegraphics[scale=0.5]{bitcoin3.eps}
\begin{chunk}{*}
)clear all
t1:=draw(x-238/100=0,x,y,range==[-5..5,-5..5])
t2:=getGraph(t1,1)
-- [-1.074,2.4],[2.382,4.531]
t3:=draw(3083/5000*(x+537/500)+12/5-y=0,x,y,range==[-5..10,-10..10])
t4:=getGraph(t3,1)
bitcoin3:=draw(y^2-x^3-7=0,x,y,range==[-5..5,-5..5],title=="Point Doubling")
putGraph(bitcoin3,t2,2)
putGraph(bitcoin3,t4,3)
axes(bitcoin3,1,"on")
units(bitcoin3,1,"on")
points(bitcoin3,1,"off")
makeViewport2D(bitcoin3)

\end{chunk}

Together, these two operations are used for scalar multiplication, R =
a P, defined by adding the point P to itself a times.  For example:

\begin{verbatim}
    R = 7P
    R = P + (P + (P + (P + (P + (P + P)))))
\end{verbatim}

The process of scalar multiplication is normally simplified by using a
combination of point addition and point doubling operations. For
example:

\begin{verbatim}
    R = 7P
    R = P + 6P
    R = P + 2 (3P)
    R = P + 2 (P + 2P)
\end{verbatim}

Here, 7P has been broken down into two point doubling steps and two
point addition steps.  

\section{Finite Fields}

A finite field, in the context of ECDSA, can be thought of as a
predefined range of positive numbers within which every calculation
must fall. Any number outside this range ``wraps around'' so as to fall
within the range.

The simplest way to think about this is calculating remainders, as
represented by the modulus (mod) operator. For example, 9/7 gives 1
with a remainder of 2:

\begin{verbatim}
    9 mod 7 = 2
\end{verbatim}

Here our finite field is modulo 7, and all mod operations over this
field yield a result falling within a range from 0 to 6.  

In Axiom, we can create a finite field and do the arithmetic there.
\begin{chunk}{*}
mod7:=FiniteField(7,1)
a:mod7:=9

\end{chunk}

\section{Putting it Together}

ECDSA uses elliptic curves in the context of a finite field, which
greatly changes their appearance but not their underlying equations or
special properties. The same equation plotted above, in a finite field
of modulo 67, looks like this:

\includegraphics[scale=0.5]{bitcoin4.eps}
\begin{chunk}{*}
)clear all
FIN:=FiniteField(67,1)  -- declare a field p**n, p=67, n=1
f(x:INT,y:INT):FIN == (y^2-x^3-7)::FIN -- compute a finite point
m():LIST(POINT(DFLOAT)) ==
  lli:LIST(LIST(INT)) := []
  for x in 0..66 repeat
   for y in 0..66 repeat
    a:FIN:=f(x,y)
    if a = 0 then lli:=concat(lli,[[x,y]])
  ld:=lli::LIST(LIST(DFLOAT))
  lpd:=[point(p) for p in ld]
m()
vfloats:=vertical::LIST(LIST(DFLOAT))
pfloats:=[point(p) for p in vfloats]
ldo:=title("BitCoin Modular Points")
rng:=range([0..67,0..67])
bitcoin4:=draw(m(),[ldo,rng])$DRAWPT
connect(bitcoin4,1,"off")$VIEW2D -- turn off the lines
units(bitcoin4,1,"on")$VIEW2D -- turn on the units
axes(bitcoin4,1,"on")$VIEW2D -- turn on the axes
makeViewport2D(bitcoin4)

\end{chunk}

It's now a set of points, in which all the x and y values are integers
between 0 and 66. Note that the ``curve'' still retains its horizontal
symmetry.

In Axiom, we can declare a function that takes Integer values for
$x$ and $y$ and returns an answer from the finite field 67.
\begin{chunk}{*}
FIN:=FiniteField(67,1)  -- declare a field p**n, p=67, n=1
f(x:INT,y:INT):FIN == (y^2-x^3-7)::FIN -- compute a finite point
k():LIST(LIST(INT)) ==
  b:LIST(LIST(INT)) := []
  for x in 0..66 repeat
   for y in 0..66 repeat
    a:FIN:=f(x,y)
    if a = 0 then b:=concat(b,[[x,y]])
  b
k()

\end{chunk}

Point addition and doubling are now slightly different visually. Lines
drawn on this graph will wrap around the horizontal and vertical
directions, just like in a game of Asteroids, maintaining the same
slope. So adding points (2, 22) and (6, 25) looks like this:

\includegraphics[scale=0.5]{bitcoin5.eps}
\begin{chunk}{*}
)clear all
FIN:=FiniteField(67,1)  -- declare a field p**n, p=67, n=1
f(x:INT,y:INT):FIN == (y^2-x^3-7)::FIN -- compute a finite point
m():LIST(POINT(DFLOAT)) ==
  lli:LIST(LIST(INT)) := []
  for x in 0..66 repeat
   for y in 0..66 repeat
    a:FIN:=f(x,y)
    if a = 0 then lli:=concat(lli,[[x,y]])
  ld:=lli::LIST(LIST(DFLOAT))
  lpd:=[point(p) for p in ld]
m()
line(x1:INT,y1:INT,x2:INT,y2:INT):EXPR(INT) ==
    -- y-y1 = m(x-x1) where m = (y2-y1)/x2-x1)
  (y2-y1)/(x2-x1)*(x-x1) + y1

line1:=draw(line(2,22,6,25),x=0..67)
line1graph:=getGraph(line1,1)

line2:=draw(line(30,26,47,39),x=0..67)
line2graph:=getGraph(line2,1)

-- this never draws for some reason
--line3:=draw(x-47=0,x,y,range==[0..67,0..67])
--line3graph:=getGraph(line3,1)

vertical:LIST(LIST(INT)):=_
[[47,0],[47,1],[47,2],[47,3],[47,4],[47,5],[47,6],[47,7],[47,8],_
[47,9],[47,10],[47,11],[47,12],[47,13],[47,14],[47,15],[47,16],[47,17],_
[47,18],[47,19],[47,20],[47,21],[47,22],[47,23],[47,24],[47,25],[47,26],_
[47,27],[47,28],[47,29],[47,30],[47,31],[47,32],[47,33],[47,34],[47,35],_
[47,36],[47,37],[47,38],[47,39],[47,40],[47,41],[47,42],[47,43],[47,44],_
[47,45],[47,46],[47,47],[47,48],[47,49],[47,50],[47,51],[47,52],[47,53],_
[47,54],[47,55],[47,56],[47,57],[47,58],[47,59],[47,60],[47,61],[47,62],_
[47,63],[47,64],[47,65],[47,66]]
vfloats:=vertical::LIST(LIST(DFLOAT))
pfloats:=[point(p) for p in vfloats]

ldo:=title("BitCoin Modular Points")
rng:=range([0..67,0..67])
bitcoin5:=draw(append(m(),pfloats),[ldo,rng])$DRAWPT

putGraph(bitcoin5,line1graph,2)
putGraph(bitcoin5,line2graph,3)
putGraph(bitcoin5,line3graph,4)
axes(bitcoin5,1,"on")$VIEW2D -- turn on the axes
units(bitcoin5,1,"on")$VIEW2D -- turn on the units
connect(bitcoin5,1,"off")$VIEW2D -- turn off the lines
makeViewport2D(bitcoin5)

\end{chunk}

The third intersecting point is (47, 39) and its reflection point is
(47, 28). We can see this reflection point by looking that the list
of points which make up the modular graph
\begin{verbatim}
   [[ 2,22], [ 2,45], [ 4, 2], [4,65],  [ 5,20], [ 5,47], [ 6,25], [ 6,42], 
    [ 7,22], [ 7,45], [11,20], [11,47], [12,23], [12,44], [13,23], [13,44], 
    [14, 2], [14,65], [16, 4], [16,63], [17,30], [17,37], [18,12], [18,55],
    [21,25], [21,42], [23,28], [23,39], [24,30], [24,37], [25,17], [25,50],
    [26,30], [26,37], [27,27], [27,40], [30,26], [30,41], [34, 7], [34,60],
    [38,26], [38,41], [40,25], [40,42], [42,23], [42,44], [46,27], [46,40],
    [47,28], [47,39], [48, 7], [48,60], [49, 2], [49,65], [51,20], [51,47],
    [52, 7], [52,60], [53,12], [53,55], [54,17], [54,50], [55,17], [55,50],
    [56, 4], [56,63], [58,22], [58,45], [61,27], [61,40], [62, 4], [62,63],
    [63,12], [63,55], [64,28], [64,39], [66,26], [66,41]]
\end{verbatim}

Notice that the points come in pairs on the vertical axis. So we can
look for the two points with first component of 47, which are
[47,28] and [47,39]. Thus the reflection point of [47,39] is 
[47,28].

\section{Back to ECDSA and Bitcoin}

A protocol such as Bitcoin selects a set of parameters for the
elliptic curve and its finite field representation that is fixed for
all users of the protocol. The parameters include the equation used,
the prime modulo of the field, and a base point that falls on the
curve. The order of the base point, which is not independently
selected but is a function of the other parameters, can be thought of
graphically as the number of times the point can be added to itself
until its slope is infinite, or a vertical line. The base point is
selected such that the order is a large prime number.

Bitcoin uses very large numbers for its base point, prime modulo, and
order. In fact, all practical applications of ECDSA use enormous
values. The security of the algorithm relies on these values being
large, and therefore impractical to brute force or reverse engineer.

In the case of Bitcoin:

\begin{verbatim}
    Elliptic curve equation: y2 = x3 + 7

    Prime modulo = 2256 – 232 – 29 – 28 – 27 – 26 – 24 - 1 = FFFFFFFF
    FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE FFFFFC2F

    Base point = 04 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB
    2DCE28D9 59F2815B 16F81798 483ADA77 26A3C465 5DA4FBFC 0E1108A8
    FD17B448 A6855419 9C47D08F FB10D4B8

    Order = FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B
    BFD25E8C D0364141
\end{verbatim}

Who chose these numbers, and why? A great deal of research, and a fair
amount of intrigue, surrounds the selection of appropriate
parameters. After all, a large, seemingly random number could hide a
backdoor method of reconstructing the private key. In brief, this
particular realization goes by the name of secp256k1 and is part of a
family of elliptic curve solutions over finite fields proposed for use
in cryptography.

\section{Private Keys and Public Keys}

With these formalities out of the way, we are now in a position to
understand private and public keys and how they are related. Here it
is in a nutshell: In ECDSA, the private key is an unpredictably chosen
number between 1 and the order. The public key is derived from the
private key by scalar multiplication of the base point a number of
times equal to the value of the private key. Expressed as an equation:

\begin{verbatim}
    public key = private key * base point
\end{verbatim}

This shows that the maximum possible number of private keys (and thus
Bitcoin addresses) is equal to the order.

In a continuous field we could plot the tangent line and pinpoint the
public key on the graph, but there are some equations that accomplish
the same thing in the context of finite fields. Point addition of p +
q to find r is defined component-wise as follows:

\begin{verbatim}
    c = (qy - py) / (qx - px)
    rx = c2 - px - qx
    ry = c (px - rx) - py
\end{verbatim}

And point doubling of p to find r is as follows:

\begin{verbatim}
    c = (3px2 + a) / 2py
    rx = c2 - 2px
    ry = c (px - rx) - py 
\end{verbatim}

In practice, computation of the public key is broken down into a
number of point doubling and point addition operations starting from
the base point.

Let's run a back of the envelope example using small numbers, to get
an intuition about how the keys are constructed and used in signing
and verifying. The parameters we will use are:

\begin{verbatim}
    Equation: y2 = x3 + 7  (which is to say, a = 0 and b = 7)
    Prime Modulo: 67
    Base Point: (2, 22)
    Order: 79
    Private key:  2
\end{verbatim}

First, let's find the public key. Since we have selected the simplest
possible private key with value = 2, it will require only a single
point doubling operation from the base point. The calculation looks
like this:

\begin{verbatim}
    c = (3 * 22 + 0) / (2 * 22) mod 67
    c = (3 * 4) / (44) mod 67
    c = 12 / 44 mod 67
\end{verbatim}

Here we have to pause for a bit of sleight-of-hand: how do we perform
division in the context of a finite field, where the result must
always be an integer? We have to multiply by the inverse, which space
does not permit us to define here (we refer you to here and here if
interested). In the case at hand, you will have to trust us for the
moment that:

\begin{verbatim}
      -1
    44  = 32
\end{verbatim}
\begin{chunk}{*}
)clear all 
FIN:=FiniteField(67,1)  -- declare a field p**n, p=67, n=1
inv(44)$FIN

\end{chunk}

Moving right along:

\begin{verbatim}
    c = 12 * 32 mod 67
    c = 384 mod 67
    c = 49
\end{verbatim}
\begin{chunk}{*}
)clear all 
FIN:=FiniteField(67,1)  -- declare a field p**n, p=67, n=1
inv(12*32)::FIN

\end{chunk}

\begin{verbatim}
    rx = (49^2 - 2 * 2) mod 67
    rx = (2401 - 4) mod 67
    rx = 2397 mod 67
    rx = 52
\end{verbatim}
\begin{chunk}{*}
)clear all 
FIN:=FiniteField(67,1)  -- declare a field p**n, p=67, n=1
(49^2 - 2 * 2)::FIN

\end{chunk}

\begin{verbatim}
    ry = (49 * (2 - 52) - 22) mod 67
    ry = (49 * (-50) - 22) mod 67
    ry = (-2450 - 22) mod 67
    ry = -2472 mod 67
    ry = 7
\end{verbatim}
\begin{chunk}{*}
)clear all 
FIN:=FiniteField(67,1)  -- declare a field p**n, p=67, n=1
(49 * (2 - 52) - 22)::FIN

\end{chunk}

Our public key thus corresponds to the point (52, 7). All that work
for a private key of 2!

This operation - going from private to public key - is computationally
easy in comparison to trying to work backwards to deduce the private
key from the public key, which while theoretically possible is
computationally infeasible due to the large parameters used in actual
elliptic cryptography.

Therefore, going from the private key to the public key is by design a
one-way trip.

As with the private key, the public key is normally represented by a
hexadecimal string. But wait, how do we get from a point on a plane,
described by two numbers, to a single number? In an uncompressed
public key the two 256-bit numbers representing the x and y
coordinates are just stuck together in one long string. We can also
take advantage of the symmetry of the elliptic curve to produce a
compressed public key, by keeping just the x value and noting which
half of the curve the point is on. From this partial information we
can recover both coordinates.

\section{Signing Data with the Private Key}

Now that we have a private and public key pair, let's sign some data!

The data can be of any length. The usual first step is to hash the
data to generate a number containing the same number of bits (256) as
the order of the curve. Here, for the sake of simplicity, we’ll skip
the hashing step and just sign the raw data z. We’ll call G the base
point, n the order, and d the private key. The recipe for signing is
as follows:

\begin{enumerate}
\item Choose some integer k between 1 and n - 1.
\item Calculate the point (x, y) = k * G, using scalar multiplication.
\item Find r = x mod n. If r = 0, return to step 1.
\item Find s = (z + r * d) / k mod n. If s = 0, return to step 1.
\item The signature is the pair (r, s)
\end{enumerate}

As a reminder, in step 4, if the numbers result in a fraction (which
in real life they almost always will), the numerator should be
multiplied by the inverse of the denominator. In step 1, it is
important that k not be repeated in different signatures and that it
not be guessable by a third party. That is, k should either be random
or generated by deterministic means that are kept secret from third
parties. Otherwise it would be possible to extract the private key
from step 4, since s, z, r, k and n are all known. You can read about
a past exploit of this type\cite{2}.

Let's pick our data to be the number 17, and follow the recipe. Our variables:

\begin{verbatim}
    z = 17 (data)
    n = 79 (order)
    G = (2, 22) (base point)
    d = 2 (private key)
\end{verbatim}

1. Pick a random number:

\begin{verbatim}
    k = rand(1, n - 1)
    k = rand(1, 79 - 1)
    k = 3  (is this really random?  OK you got us, but it will make 
            our example simpler!)
\end{verbatim}

2. Calculate the point. This is done in the same manner as determining
the public key, but for brevity let's omit the arithmetic for point
addition and point doubling.

\begin{verbatim}
    (x, y) = 3G
    (x, y) = G + 2G
    (x, y) = (2, 22) + (52, 7)
    (x, y) = (62, 63)
    x = 62
    y = 63
\end{verbatim}

3. Find r:

\begin{verbatim}
    r = x mod n
    r = 62 mod 79
    r = 62
\end{verbatim}

4. Find s:

\begin{verbatim}
    s = (z + r * d) / k mod n
    s = (17 + 62 * 2) / 3 mod 79
    s = (17 + 124) / 3 mod 79
    s = 141 / 3 mod 79
    s = 47 mod 79
    s = 47
\end{verbatim}

Note that above we were able to divide by 3 since the result was an
integer. In real-life cases we would use the inverse of k (like
before, we have hidden some gory details by computing it elsewhere):

\begin{verbatim}
    s = (z + r * d) / k mod n
    s = (17 + 62 * 2) / 3 mod 79
    s = (17 + 124) / 3 mod 79
    s = 141 / 3 mod 79
    s = 141 * 3-1 mod 79
    s = 141 * 53 mod 79
    s = 7473 mod 79
    s = 47
\end{verbatim}

5. Our signature is the pair (r, s) = (62, 47).

As with the private and public keys, this signature is normally
represented by a hexadecimal string.  

\section{Verifying the Signature with the Public Key}

We now have some data and a signature for that data. A third party who
has our public key can receive our data and signature, and verify that
we are the senders. Let's see how this works.

With Q being the public key and the other variables defined as before,
the steps for verifying a signature are as follows:

\begin{enumerate}
\item Verify that r and s are between 1 and n - 1.
\item Calculate w = s-1 mod n
\item Calculate u = z * w mod n
\item Calculate v = r * w mod n
\item Calculate the point (x, y) = uG + vQ
\item Verify that r = x mod n. The signature is invalid if it is not.
\end{enumerate}

Why do these steps work? We are skipping the proof, but you can read
the details here. Let's follow the recipe and see how it works. Our
variables, once again:

\begin{verbatim}
    z = 17 (data)
    (r, s) = (62, 47) (signature)
    n = 79 (order)
    G = (2, 22) (base point)
    Q = (52, 7) (public key)
\end{verbatim}

1. Verify that r and s are between 1 and n - 1. Check and check.

\begin{verbatim}
    r: 1 <= 62 < 79
    s: 1 <= 47 < 79
\end{verbatim}

2. Calculate w:

\begin{verbatim}
    w = s-1 mod n
    w = 47-1 mod 79
    w = 37
\end{verbatim}

3. Calculate u:

\begin{verbatim}
    u = zw mod n
    u = 17 * 37 mod 79
    u = 629 mod 79
    u = 76
\end{verbatim}

4. Calculate v:

\begin{verbatim}
    v = rw mod n
    v = 62 * 37 mod 79
    v = 2294 mod 79
    v = 3
\end{verbatim}

5. Calculate the point (x, y):

\begin{verbatim}
    (x, y) = uG + vQ
\end{verbatim}

Let's break down the point doubling and addition in uG and vQ separately.

\begin{verbatim}
    uG = 76G
    uG = 2(38G)
    uG = 2( 2(19G) )
    uG = 2( 2(G + 18G) )
    uG = 2( 2(G + 2(9G) ) )
    uG = 2( 2(G + 2(G + 8G) ) )
    uG = 2( 2(G + 2(G + 2(4G) ) ) )
    uG = 2( 2(G + 2(G + 2( 2(2G) ) ) ) )
\end{verbatim}

Sit back for a moment to appreciate that by using the grouping trick
we reduce 75 successive addition operations to just six operations of
point doubling and two operations of point addition. These tricks will
come in handy when the numbers get really large.

Working our way from the inside out:

\begin{verbatim}
    uG = 2( 2(G + 2(G + 2( 2( 2(2, 22) ) ) ) ) )
    uG = 2( 2(G + 2(G + 2( 2(52, 7) ) ) ) )
    uG = 2( 2(G + 2(G + 2(25, 17)  ) ) )
    uG = 2( 2(G + 2( (2, 22) + (21, 42) ) ) )
    uG = 2( 2(G + 2(13, 44) ) )
    uG = 2( 2( (2, 22) + (66, 26) ) )
    uG = 2( 2(38, 26) )
    uG = 2(27, 40)
    uG = (62, 4)
\end{verbatim}

And now for vQ:

\begin{verbatim}
    vQ = 3Q
    vQ = Q + 2Q
    vQ = Q + 2(52, 7)
    vQ = (52, 7) + (25, 17)
    vQ = (11, 20)
\end{verbatim}

Putting them together:

\begin{verbatim}
    (x, y) = uG + vQ
    (x, y) = (62, 4) + (11, 20)
    (x, y) = (62, 63)
\end{verbatim}

Clearly step 5 is the bulk of the work. For the final step,

6. Verify that r = x mod n

\begin{verbatim}
    r = x mod n
    62 = 62 mod 79
    62 = 62
\end{verbatim}

Our signature is valid!

\section{Conclusion}

For those of you who saw all the equations and skipped to the bottom,
what have we just learned?

We have developed some intuition about the deep mathematical
relationship that exists between public and private keys. We have seen
how even in the simplest examples the math behind signatures and
verification quickly gets complicated, and we can appreciate the
enormous complexity which must be involved when the parameters
involved are 256-bit numbers. We have seen how the clever application
of the simplest mathematical procedures can create the one-way ``trap
door'' functions necessary to preserve the information asymmetry which
defines ownership of a bitcoin. And we have newfound confidence in the
robustness of the system, provided that we carefully safeguard the
knowledge of our private keys.

In other words, this is why it is commonly said that Bitcoin is
``backed by math.''

If you hung in through the complicated bits, we hope it gave you the
confidence to take the next step and try out the math on your own (a
modular arithmetic calculator makes the finite field math much
easier). We found that going through the steps of signing and
verifying data by hand provides a deeper understanding of the
cryptography that enables Bitcoin's unique form of ownership.

***

Special thanks to Steven Phelps for help with this article
3 months ago

\begin{thebibliography}{99}
\bibitem[1]{1} 
\verb|http://blog.chain.com/post/95218566791/the-math-behind-bitcoin|
\bibitem[2]{2} 
\verb|arstechnica.com/gaming/2010/12/ps3-hacked-through-poor-implementation|
\verb|-of-cryptography|
\end{thebibliography}
\end{document}
