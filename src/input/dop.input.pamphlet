\documentclass{article}
\usepackage{axiom}
\setlength{\textwidth}{400pt}
\begin{document}
\title{\$SPAD/src/input dop.input}
\author{Timothy Daly}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{License}
\begin{chunk}{license}
--Copyright The Numerical Algorithms Group Limited 1991.
\end{chunk}
\begin{chunk}{*}
)set break resume
)spool dop.output
)set message test on
)set message auto off
)clear all
 
--S 1 of 127
)d op binaryTree
--R 
--R
--RThere are 2 exposed functions called binaryTree :
--R   [1] (BinaryTree D1,D1,BinaryTree D1) -> BinaryTree D1 from 
--R            BinaryTree D1
--R            if D1 has SETCAT
--R   [2] D1 -> BinaryTree D1 from BinaryTree D1 if D1 has SETCAT
--R
--RExamples of binaryTree from BinaryTree
--R
--Rt1:=binaryTree([1,2,3]) 
--Rt2:=binaryTree([4,5,6]) 
--RbinaryTree(t1,[7,8,9],t2)
--R
--Rt1:=binaryTree([1,2,3])
--R
--E 1

--S 2 of 127
)d op rationalPoint?
--R 
--R
--RThere is one exposed function called rationalPoint? :
--R   [1] (D2,D2) -> Boolean from D
--R            if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC 
--R            D2 and D4 has UPOLYC FRAC D3
--R
--RThere is one unexposed function called rationalPoint? :
--R   [1] (D2,D2) -> Boolean from FunctionFieldCategory&(D3,D2,D4,D5)
--R            if D2 has UFD and D4 has UPOLYC D2 and D5 has UPOLYC FRAC 
--R            D4 and D3 has FFCAT(D2,D4,D5)
--R
--RExamples of rationalPoint? from FunctionFieldCategory&
--R
--RP0 := UnivariatePolynomial(x, Integer) 
--RP1 := UnivariatePolynomial(y, Fraction P0) 
--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
--RrationalPoint?(0,0)$R 
--RR2 := RadicalFunctionField(INT, P0, P1, 2 * x**2, 4) 
--RrationalPoint?(0,0)$R2
--R
--R
--RExamples of rationalPoint? from FunctionFieldCategory
--R
--RP0 := UnivariatePolynomial(x, Integer) 
--RP1 := UnivariatePolynomial(y, Fraction P0) 
--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
--RrationalPoint?(0,0)$R 
--RR2 := RadicalFunctionField(INT, P0, P1, 2 * x**2, 4) 
--RrationalPoint?(0,0)$R2
--R
--E 2

--S 3 of 127
)d op nthFactor
--R 
--R
--RThere are 2 exposed functions called nthFactor :
--R   [1] (D,Integer) -> D1 from D
--R            if D has FAMONC(D1,D3) and D3 has CABMON and D1 has SETCAT
--R            
--R   [2] (Factored D1,Integer) -> D1 from Factored D1 if D1 has INTDOM
--R         
--R
--RThere are 4 unexposed functions called nthFactor :
--R   [1] (FreeGroup D1,Integer) -> D1 from FreeGroup D1 if D1 has SETCAT
--R            
--R   [2] (FreeMonoid D1,Integer) -> D1 from FreeMonoid D1 if D1 has 
--R            SETCAT
--R   [3] (ListMonoidOps(D1,D3,D4),Integer) -> D1 from ListMonoidOps(D1,D3
--R            ,D4)
--R            if D1 has SETCAT and D3 has ABELMON and D4: D3
--R   [4] (OrderedFreeMonoid D1,Integer) -> D1 from OrderedFreeMonoid D1
--R            if D1 has ORDSET
--R
--RExamples of nthFactor from FreeAbelianMonoidCategory
--R
--R
--RExamples of nthFactor from FreeGroup
--R
--R
--RExamples of nthFactor from FreeMonoid
--R
--R
--RExamples of nthFactor from Factored
--R
--Ra:=factor 9720000 
--RnthFactor(a,2)
--R
--R
--RExamples of nthFactor from ListMonoidOps
--R
--R
--RExamples of nthFactor from OrderedFreeMonoid
--R
--Rm1:=(x*y*y*z)$OFMONOID(Symbol) 
--RnthFactor(m1,2)
--R
--E 3

--S 4 of 127
)d op qsetelt!
--R 
--R
--RThere are 2 exposed functions called qsetelt! :
--R   [1] (D,Integer,Integer,D1) -> D1 from D
--R            if D has ARR2CAT(D1,D3,D4) and D1 has TYPE and D3 has FLAGG
--R            D1 and D4 has FLAGG D1
--R   [2] (D,D2,D1) -> D1 from D
--R            if D has shallowlyMutable and D has ELTAGG(D2,D1) and D2 
--R            has SETCAT and D1 has TYPE
--R
--RExamples of qsetelt! from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,0) 
--Rqsetelt!(arr,1,1,17)
--R
--R
--RExamples of qsetelt! from EltableAggregate
--R
--E 4

--S 5 of 127
)d op cycleElt
--R 
--R
--RThere is one unexposed function called cycleElt :
--R   [1] D1 -> Union(D1,"failed") from CyclicStreamTools(D2,D1)
--R            if D2 has TYPE and D1 has LZSTAGG D2
--R
--RExamples of cycleElt from CyclicStreamTools
--R
--Rp:=repeating([1,2,3]) 
--Rq:=cons(4,p) 
--RcycleElt q 
--Rr:=[1,2,3]::Stream(Integer) 
--RcycleElt r
--R
--E 5

--S 6 of 127
)d op cyclicEntries
--R 
--R
--RThere is one exposed function called cyclicEntries :
--R   [1] Tree D2 -> List Tree D2 from Tree D2 if D2 has SETCAT
--R
--RExamples of cyclicEntries from Tree
--R
--Rt1:=tree [1,2,3,4] 
--RcyclicEntries t1
--R
--E 6

--S 7 of 127
)d op oneDimensionalArray
--R 
--R
--RThere are 2 exposed functions called oneDimensionalArray :
--R   [1] (NonNegativeInteger,D2) -> OneDimensionalArray D2
--R            from OneDimensionalArray D2 if D2 has TYPE
--R   [2] List D2 -> OneDimensionalArray D2 from OneDimensionalArray D2
--R            if D2 has TYPE
--R
--RExamples of oneDimensionalArray from OneDimensionalArray
--R
--RoneDimensionalArray(10,0.0)
--R
--RoneDimensionalArray [i**2 for i in 1..10]
--R
--E 7

--S 8 of 127
)d op alphanumeric?
--R 
--R
--RThere is one exposed function called alphanumeric? :
--R   [1] Character -> Boolean from Character
--R
--RExamples of alphanumeric? from Character
--R
--Rchars := [char "a", char "A", char "X", char "8", char "+"] 
--R[alphanumeric? c for c in chars]
--R
--E 8

--S 9 of 127
)d op digit?
--R 
--R
--RThere is one exposed function called digit? :
--R   [1] Character -> Boolean from Character
--R
--RExamples of digit? from Character
--R
--Rchars := [char "a", char "A", char "X", char "8", char "+"] 
--R[digit? c for c in chars]
--R
--E 9

--S 10 of 127
)d op sqfrFactor
--R 
--R
--RThere is one exposed function called sqfrFactor :
--R   [1] (D1,Integer) -> Factored D1 from Factored D1 if D1 has INTDOM
--R         
--R
--RExamples of sqfrFactor from Factored
--R
--Ra:=sqfrFactor(3,5) 
--RnthFlag(a,1)
--R
--E 10

--S 11 of 127
)d op integralMatrix
--R 
--R
--RThere is one exposed function called integralMatrix :
--R   [1]  -> Matrix Fraction D3 from D
--R            if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC 
--R            D2 and D4 has UPOLYC FRAC D3
--R
--RExamples of integralMatrix from FunctionFieldCategory
--R
--RP0 := UnivariatePolynomial(x, Integer) 
--RP1 := UnivariatePolynomial(y, Fraction P0) 
--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
--RintegralMatrix()$R
--R
--E 11

--S 12 of 127
)d op ptree
--R 
--R
--RThere are 2 exposed functions called ptree :
--R   [1] (PendantTree D1,PendantTree D1) -> PendantTree D1 from 
--R            PendantTree D1
--R            if D1 has SETCAT
--R   [2] D1 -> PendantTree D1 from PendantTree D1 if D1 has SETCAT
--R
--RExamples of ptree from PendantTree
--R
--Rt1:=ptree([1,2,3]) 
--Rptree(t1,ptree([1,2,3]))
--R
--Rt1:=ptree([1,2,3])
--R
--E 12

--S 13 of 127
)d op insert!
--R 
--R
--RThere are 13 exposed functions called insert! :
--R   [1] (D1,ArrayStack D1) -> ArrayStack D1 from ArrayStack D1 if D1 has
--R            SETCAT
--R   [2] (D1,D) -> D from D if D has BGAGG D1 and D1 has TYPE
--R   [3] (D1,BinarySearchTree D1) -> BinarySearchTree D1
--R            from BinarySearchTree D1 if D1 has ORDSET
--R   [4] (D1,BinaryTournament D1) -> BinaryTournament D1
--R            from BinaryTournament D1 if D1 has ORDSET
--R   [5] (D1,Dequeue D1) -> Dequeue D1 from Dequeue D1 if D1 has SETCAT
--R         
--R   [6] (D,D,Integer) -> D from D if D has ELAGG D2 and D2 has TYPE
--R   [7] (D1,D,Integer) -> D from D if D has ELAGG D1 and D1 has TYPE
--R   [8] (D1,Heap D1) -> Heap D1 from Heap D1 if D1 has ORDSET
--R   [9] Record(key: Record(var: Symbol,fn: Expression DoubleFloat,range
--R            : Segment OrderedCompletion DoubleFloat,abserr: DoubleFloat,
--R            relerr: DoubleFloat),entry: Record(endPointContinuity: Union(
--R            continuous: Continuous at the end points,lowerSingular: 
--R            There is a singularity at the lower end point,upperSingular: 
--R            There is a singularity at the upper end point,bothSingular: 
--R            There are singularities at both end points,notEvaluated: 
--R            End point continuity not yet evaluated),singularitiesStream: 
--R            Union(str: Stream DoubleFloat,notEvaluated: 
--R            Internal singularities not yet evaluated),range: Union(finite: 
--R            The range is finite,lowerInfinite: 
--R            The bottom of range is infinite,upperInfinite: 
--R            The top of range is infinite,bothInfinite: 
--R            Both top and bottom points are infinite,notEvaluated: 
--R            Range not yet evaluated))) -> IntegrationFunctionsTable
--R            from IntegrationFunctionsTable
--R   [10] (D1,D,NonNegativeInteger) -> D from D
--R            if D has MDAGG D1 and D1 has SETCAT
--R   [11] Record(key: Record(xinit: DoubleFloat,xend: DoubleFloat,fn: 
--R            Vector Expression DoubleFloat,yinit: List DoubleFloat,intvals: 
--R            List DoubleFloat,g: Expression DoubleFloat,abserr: DoubleFloat,
--R            relerr: DoubleFloat),entry: Record(stiffness: Float,stability: 
--R            Float,expense: Float,accuracy: Float,intermediateResults: Float))
--R             -> ODEIntensityFunctionsTable
--R            from ODEIntensityFunctionsTable
--R   [12] (D1,Queue D1) -> Queue D1 from Queue D1 if D1 has SETCAT
--R   [13] (D1,Stack D1) -> Stack D1 from Stack D1 if D1 has SETCAT
--R
--RThere is one unexposed function called insert! :
--R   [1] (D2,D3) -> Void from TabulatedComputationPackage(D2,D3)
--R            if D2 has SETCAT and D3 has SETCAT
--R
--RExamples of insert! from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Rinsert!(8,a) 
--Ra
--R
--R
--RExamples of insert! from BagAggregate
--R
--R
--RExamples of insert! from BinarySearchTree
--R
--Rt1:=binarySearchTree [1,2,3,4] 
--Rinsert!(5,t1)
--R
--R
--RExamples of insert! from BinaryTournament
--R
--Rt1:=binaryTournament [1,2,3,4] 
--Rinsert!(5,t1) 
--Rt1
--R
--R
--RExamples of insert! from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rinsert! (8,a) 
--Ra
--R
--R
--RExamples of insert! from ExtensibleLinearAggregate
--R
--R
--RExamples of insert! from Heap
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--Rinsert!(8,a) 
--Ra
--R
--R
--RExamples of insert! from IntegrationFunctionsTable
--R
--R
--RExamples of insert! from MultiDictionary
--R
--R
--RExamples of insert! from ODEIntensityFunctionsTable
--R
--R
--RExamples of insert! from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rinsert! (8,a) 
--Ra
--R
--R
--RExamples of insert! from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rinsert!(8,a) 
--Ra
--R
--R
--RExamples of insert! from TabulatedComputationPackage
--R
--E 13

--S 14 of 127
)d op genus
--R 
--R
--RThere are 5 exposed functions called genus :
--R   [1] D6 -> NonNegativeInteger
--R            from DesingTreePackage(D7,D8,D6,D9,D10,D11,D12,D1,D2,D3,D4)
--R            if D7 has FIELD and D8: LIST SYMBOL and D6 has POLYCAT(D7,
--R            D9,OVAR D8) and D9 has DIRPCAT(# D8,NNI) and D10 has 
--R            PRSPCAT D7 and D11 has LOCPOWC D7 and D12 has PLACESC(D7,
--R            D11) and D1 has DIVCAT D12 and D2 has INFCLCT(D7,D8,D6,D9,
--R            D10,D11,D12,D1,D4) and D4 has BLMETCT and D3 has DSTRCAT D2
--R            
--R   [2]  -> NonNegativeInteger from D
--R            if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC 
--R            D2 and D4 has UPOLYC FRAC D3
--R   [3]  -> NonNegativeInteger
--R            from GeneralPackageForAlgebraicFunctionField(D6,D7,D8,D9,
--R            D10,D11,D12,D1,D2,D3,D4)
--R            if D6 has FIELD and D7: LIST SYMBOL and D8 has POLYCAT(D6,
--R            D9,OVAR D7) and D9 has DIRPCAT(# D7,NNI) and D10 has 
--R            PRSPCAT D6 and D11 has LOCPOWC D6 and D12 has PLACESC(D6,
--R            D11) and D1 has DIVCAT D12 and D2 has INFCLCT(D6,D7,D8,D9,
--R            D10,D11,D12,D1,D4) and D4 has BLMETCT and D3 has DSTRCAT D2
--R            
--R   [4]  -> NonNegativeInteger
--R            from PackageForAlgebraicFunctionFieldOverFiniteField(D2,D3,
--R            D4)
--R            if D2 has FFIELDC and D3: LIST SYMBOL and D4 has BLMETCT
--R         
--R   [5]  -> NonNegativeInteger from PackageForAlgebraicFunctionField(D2,
--R            D3,D4)
--R            if D2 has FIELD and D3: LIST SYMBOL and D4 has BLMETCT
--R
--RThere is one unexposed function called genus :
--R   [1]  -> NonNegativeInteger from FunctionFieldCategory&(D2,D3,D4,D5)
--R            if D3 has UFD and D4 has UPOLYC D3 and D5 has UPOLYC FRAC 
--R            D4 and D2 has FFCAT(D3,D4,D5)
--R
--RExamples of genus from DesingTreePackage
--R
--R
--RExamples of genus from FunctionFieldCategory&
--R
--RP0 := UnivariatePolynomial(x, Integer) 
--RP1 := UnivariatePolynomial(y, Fraction P0) 
--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
--Rgenus()$R
--R
--R
--RExamples of genus from FunctionFieldCategory
--R
--RP0 := UnivariatePolynomial(x, Integer) 
--RP1 := UnivariatePolynomial(y, Fraction P0) 
--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
--Rgenus()$R
--R
--R
--RExamples of genus from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of genus from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of genus from PackageForAlgebraicFunctionField
--R
--E 14

--S 15 of 127
)d op hexDigit?
--R 
--R
--RThere is one exposed function called hexDigit? :
--R   [1] Character -> Boolean from Character
--R
--RExamples of hexDigit? from Character
--R
--Rchars := [char "a", char "A", char "X", char "8", char "+"] 
--R[hexDigit? c for c in chars]
--R
--E 15

--S 16 of 127
)d op computeCycleLength
--R 
--R
--RThere is one unexposed function called computeCycleLength :
--R   [1] D2 -> NonNegativeInteger from CyclicStreamTools(D3,D2)
--R            if D3 has TYPE and D2 has LZSTAGG D3
--R
--RExamples of computeCycleLength from CyclicStreamTools
--R
--Rp:=repeating([1,2,3]) 
--Rq:=cons(4,p) 
--RcomputeCycleLength(cycleElt(q))
--R
--E 16

--S 17 of 127
)d op findCycle
--R 
--R
--RThere is one exposed function called findCycle :
--R   [1] (NonNegativeInteger,Stream D3) -> Record(cycle?: Boolean,prefix
--R            : NonNegativeInteger,period: NonNegativeInteger)
--R            from Stream D3 if D3 has TYPE
--R
--RExamples of findCycle from Stream
--R
--Rm:=[1,2,3] 
--Rn:=repeating(m) 
--RfindCycle(3,n) 
--RfindCycle(2,n)
--R
--E 17

--S 18 of 127
)d op draw
--R 
--R
--RThere are 31 exposed functions called draw :
--R   [1] ((DoubleFloat -> DoubleFloat),Segment Float,List DrawOption) -> 
--R            TwoDimensionalViewport
--R            from TopLevelDrawFunctionsForCompiledFunctions
--R   [2] ((DoubleFloat -> DoubleFloat),Segment Float) -> 
--R            TwoDimensionalViewport
--R            from TopLevelDrawFunctionsForCompiledFunctions
--R   [3] (ParametricPlaneCurve (DoubleFloat -> DoubleFloat),Segment Float
--R            ,List DrawOption) -> TwoDimensionalViewport
--R            from TopLevelDrawFunctionsForCompiledFunctions
--R   [4] (ParametricPlaneCurve (DoubleFloat -> DoubleFloat),Segment Float
--R            ) -> TwoDimensionalViewport
--R            from TopLevelDrawFunctionsForCompiledFunctions
--R   [5] (ParametricSpaceCurve (DoubleFloat -> DoubleFloat),Segment Float
--R            ,List DrawOption) -> ThreeDimensionalViewport
--R            from TopLevelDrawFunctionsForCompiledFunctions
--R   [6] (ParametricSpaceCurve (DoubleFloat -> DoubleFloat),Segment Float
--R            ) -> ThreeDimensionalViewport
--R            from TopLevelDrawFunctionsForCompiledFunctions
--R   [7] ((DoubleFloat -> Point DoubleFloat),Segment Float,List 
--R            DrawOption) -> ThreeDimensionalViewport
--R            from TopLevelDrawFunctionsForCompiledFunctions
--R   [8] ((DoubleFloat -> Point DoubleFloat),Segment Float) -> 
--R            ThreeDimensionalViewport
--R            from TopLevelDrawFunctionsForCompiledFunctions
--R   [9] (((DoubleFloat,DoubleFloat) -> DoubleFloat),Segment Float,
--R            Segment Float,List DrawOption) -> ThreeDimensionalViewport
--R            from TopLevelDrawFunctionsForCompiledFunctions
--R   [10] (((DoubleFloat,DoubleFloat) -> DoubleFloat),Segment Float,
--R            Segment Float) -> ThreeDimensionalViewport
--R            from TopLevelDrawFunctionsForCompiledFunctions
--R   [11] (((DoubleFloat,DoubleFloat) -> Point DoubleFloat),Segment Float
--R            ,Segment Float,List DrawOption) -> ThreeDimensionalViewport
--R            from TopLevelDrawFunctionsForCompiledFunctions
--R   [12] (((DoubleFloat,DoubleFloat) -> Point DoubleFloat),Segment Float
--R            ,Segment Float) -> ThreeDimensionalViewport
--R            from TopLevelDrawFunctionsForCompiledFunctions
--R   [13] (ParametricSurface ((DoubleFloat,DoubleFloat) -> DoubleFloat),
--R            Segment Float,Segment Float,List DrawOption) -> 
--R            ThreeDimensionalViewport
--R            from TopLevelDrawFunctionsForCompiledFunctions
--R   [14] (ParametricSurface ((DoubleFloat,DoubleFloat) -> DoubleFloat),
--R            Segment Float,Segment Float) -> ThreeDimensionalViewport
--R            from TopLevelDrawFunctionsForCompiledFunctions
--R   [15] (Equation D6,Symbol,Symbol,List DrawOption) -> 
--R            TwoDimensionalViewport
--R            from TopLevelDrawFunctionsForAlgebraicCurves(D5,D6)
--R            if D6 has FS D5 and D5 has Join(IntegralDomain,OrderedSet,
--R            RetractableTo Integer)
--R   [16] (D2,SegmentBinding Float,List DrawOption) -> 
--R            TwoDimensionalViewport
--R            from TopLevelDrawFunctions D2
--R            if D2 has Join(ConvertibleTo InputForm,SetCategory)
--R   [17] (D2,SegmentBinding Float) -> TwoDimensionalViewport
--R            from TopLevelDrawFunctions D2
--R            if D2 has Join(ConvertibleTo InputForm,SetCategory)
--R   [18] (ParametricPlaneCurve D5,SegmentBinding Float,List DrawOption)
--R             -> TwoDimensionalViewport
--R            from TopLevelDrawFunctions D5
--R            if D5 has Join(ConvertibleTo InputForm,SetCategory)
--R   [19] (ParametricPlaneCurve D4,SegmentBinding Float) -> 
--R            TwoDimensionalViewport
--R            from TopLevelDrawFunctions D4
--R            if D4 has Join(ConvertibleTo InputForm,SetCategory)
--R   [20] (ParametricSpaceCurve D5,SegmentBinding Float,List DrawOption)
--R             -> ThreeDimensionalViewport
--R            from TopLevelDrawFunctions D5
--R            if D5 has Join(ConvertibleTo InputForm,SetCategory)
--R   [21] (ParametricSpaceCurve D4,SegmentBinding Float) -> 
--R            ThreeDimensionalViewport
--R            from TopLevelDrawFunctions D4
--R            if D4 has Join(ConvertibleTo InputForm,SetCategory)
--R   [22] (D2,SegmentBinding Float,SegmentBinding Float,List DrawOption)
--R             -> ThreeDimensionalViewport
--R            from TopLevelDrawFunctions D2
--R            if D2 has Join(ConvertibleTo InputForm,SetCategory)
--R   [23] (D2,SegmentBinding Float,SegmentBinding Float) -> 
--R            ThreeDimensionalViewport
--R            from TopLevelDrawFunctions D2
--R            if D2 has Join(ConvertibleTo InputForm,SetCategory)
--R   [24] (ParametricSurface D5,SegmentBinding Float,SegmentBinding Float
--R            ,List DrawOption) -> ThreeDimensionalViewport
--R            from TopLevelDrawFunctions D5
--R            if D5 has Join(ConvertibleTo InputForm,SetCategory)
--R   [25] (ParametricSurface D4,SegmentBinding Float,SegmentBinding Float
--R            ) -> ThreeDimensionalViewport
--R            from TopLevelDrawFunctions D4
--R            if D4 has Join(ConvertibleTo InputForm,SetCategory)
--R   [26] (List DoubleFloat,List DoubleFloat) -> TwoDimensionalViewport
--R            from TopLevelDrawFunctionsForPoints
--R   [27] (List DoubleFloat,List DoubleFloat,List DrawOption) -> 
--R            TwoDimensionalViewport
--R            from TopLevelDrawFunctionsForPoints
--R   [28] List Point DoubleFloat -> TwoDimensionalViewport
--R            from TopLevelDrawFunctionsForPoints
--R   [29] (List Point DoubleFloat,List DrawOption) -> 
--R            TwoDimensionalViewport
--R            from TopLevelDrawFunctionsForPoints
--R   [30] (List DoubleFloat,List DoubleFloat,List DoubleFloat) -> 
--R            ThreeDimensionalViewport
--R            from TopLevelDrawFunctionsForPoints
--R   [31] (List DoubleFloat,List DoubleFloat,List DoubleFloat,List 
--R            DrawOption) -> ThreeDimensionalViewport
--R            from TopLevelDrawFunctionsForPoints
--R
--RExamples of draw from TopLevelDrawFunctionsForCompiledFunctions
--R
--R
--RExamples of draw from TopLevelDrawFunctionsForAlgebraicCurves
--R
--R
--RExamples of draw from TopLevelDrawFunctions
--R
--R
--RExamples of draw from TopLevelDrawFunctionsForPoints
--R
--E 18

--S 19 of 127
)d op repeating
--R 
--R
--RThere is one exposed function called repeating :
--R   [1] List D2 -> Stream D2 from Stream D2 if D2 has TYPE
--R
--RExamples of repeating from Stream
--R
--Rm:=repeating([-1,0,1,2,3])
--R
--E 19

--S 20 of 127
)d op cons
--R 
--R
--RThere are 2 exposed functions called cons :
--R   [1] (D1,List D1) -> List D1 from List D1 if D1 has TYPE
--R   [2] (D1,Stream D1) -> Stream D1 from Stream D1 if D1 has TYPE
--R
--RExamples of cons from List
--R
--R
--RExamples of cons from Stream
--R
--Rm:=[1,2,3] 
--Rn:=repeating(m) 
--Rcons(4,n)
--R
--E 20

--S 21 of 127
)d op map
--R 
--R
--RThere are 86 exposed functions called map :
--R   [1] ((D2 -> D2),D) -> D from D
--R            if D has AMR(D2,D3) and D2 has RING and D3 has OAMON
--R   [2] (((D2,D2) -> D2),D,D,D2) -> D from D
--R            if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has FLAGG
--R            D2 and D4 has FLAGG D2
--R   [3] (((D2,D2) -> D2),D,D) -> D from D
--R            if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has FLAGG
--R            D2 and D4 has FLAGG D2
--R   [4] ((D2 -> D2),D) -> D from D
--R            if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has FLAGG
--R            D2 and D4 has FLAGG D2
--R   [5] ((D4 -> D5),OneDimensionalArray D4) -> OneDimensionalArray D5
--R            from OneDimensionalArrayFunctions2(D4,D5)
--R            if D4 has TYPE and D5 has TYPE
--R   [6] ((D2 -> D2),ArrayStack D2) -> ArrayStack D2 from ArrayStack D2
--R            if D2 has SETCAT
--R   [7] ((D6 -> D7),CartesianTensor(D4,D5,D6)) -> CartesianTensor(D4,D5,
--R            D7)
--R            from CartesianTensorFunctions2(D4,D5,D6,D7)
--R            if D4: INT and D5: NNI and D6 has COMRING and D7 has 
--R            COMRING
--R   [8] ((D4 -> D5),Complex D4) -> Complex D5 from ComplexFunctions2(D4,
--R            D5)
--R            if D4 has COMRING and D5 has COMRING
--R   [9] ((D2 -> D2),Dequeue D2) -> Dequeue D2 from Dequeue D2 if D2 has 
--R            SETCAT
--R   [10] ((D5 -> D6),DirectProduct(D4,D5)) -> DirectProduct(D4,D6)
--R            from DirectProductFunctions2(D4,D5,D6)
--R            if D4: NNI and D5 has TYPE and D6 has TYPE
--R   [11] ((D4 -> D5),Equation D4) -> Equation D5 from EquationFunctions2
--R            (D4,D5)
--R            if D4 has TYPE and D5 has TYPE
--R   [12] ((D2 -> D2),Equation D2) -> Equation D2 from Equation D2 if D2 
--R            has TYPE
--R   [13] ((D4 -> D1),Kernel D4) -> D1 from ExpressionSpaceFunctions2(D4,
--R            D1)
--R            if D4 has ES and D1 has ES
--R   [14] ((D -> D),Kernel D) -> D from D if D has ES
--R   [15] ((D4 -> D5),Matrix D4) -> Matrix D5
--R            from ExpertSystemToolsPackage2(D4,D5)
--R            if D4 has RING and D5 has RING
--R   [16] ((D4 -> D5),Expression D4) -> Expression D5
--R            from ExpressionFunctions2(D4,D5)
--R            if D4 has ORDSET and D5 has ORDSET
--R   [17] ((D5 -> D6),D3) -> D1
--R            from FiniteAbelianMonoidRingFunctions2(D4,D5,D3,D6,D1)
--R            if D5 has RING and D6 has RING and D4 has OAMON and D1 has 
--R            FAMR(D6,D4) and D3 has FAMR(D5,D4)
--R   [18] ((D7 -> D11),FiniteDivisor(D7,D8,D9,D10)) -> FiniteDivisor(D11,
--R            D1,D2,D3)
--R            from FiniteDivisorFunctions2(D7,D8,D9,D10,D11,D1,D2,D3)
--R            if D7 has FIELD and D8 has UPOLYC D7 and D9 has UPOLYC FRAC
--R            D8 and D10 has FFCAT(D7,D8,D9) and D11 has FIELD and D1 has
--R            UPOLYC D11 and D2 has UPOLYC FRAC D1 and D3 has FFCAT(D11,
--R            D1,D2)
--R   [19] ((D2 -> D2),D) -> D from D if D has FEVALAB D2 and D2 has 
--R            SETCAT
--R   [20] ((D5 -> D8),D4) -> D2
--R            from FunctionFieldCategoryFunctions2(D5,D6,D7,D4,D8,D9,D1,
--R            D2)
--R            if D5 has UFD and D8 has UFD and D6 has UPOLYC D5 and D7 
--R            has UPOLYC FRAC D6 and D9 has UPOLYC D8 and D2 has FFCAT(D8
--R            ,D9,D1) and D4 has FFCAT(D5,D6,D7) and D1 has UPOLYC FRAC 
--R            D9
--R   [21] ((D4 -> D5),D3) -> D1 from FiniteLinearAggregateFunctions2(D4,
--R            D3,D5,D1)
--R            if D4 has TYPE and D5 has TYPE and D1 has FLAGG D5 and D3 
--R            has FLAGG D4
--R   [22] ((D2 -> D2),D) -> D from D
--R            if D has FMCAT(D2,D3) and D2 has RING and D3 has SETCAT
--R   [23] ((D4 -> D5),Factored D4) -> Factored D5 from FactoredFunctions2
--R            (D4,D5)
--R            if D4 has INTDOM and D5 has INTDOM
--R   [24] ((D4 -> D5),Fraction D4) -> Fraction D5 from FractionFunctions2
--R            (D4,D5)
--R            if D4 has INTDOM and D5 has INTDOM
--R   [25] ((D7 -> D11),FractionalIdeal(D7,D8,D9,D10)) -> FractionalIdeal(
--R            D11,D1,D2,D3)
--R            from FractionalIdealFunctions2(D7,D8,D9,D10,D11,D1,D2,D3)
--R            if D7 has EUCDOM and D8 has QFCAT D7 and D9 has UPOLYC D8 
--R            and D10 has Join(FramedAlgebra(D8,D9),RetractableTo D8) and
--R            D11 has EUCDOM and D1 has QFCAT D11 and D2 has UPOLYC D1 
--R            and D3 has Join(FramedAlgebra(D1,D2),RetractableTo D1)
--R   [26] ((D4 -> D5),D3) -> D1
--R            from FramedNonAssociativeAlgebraFunctions2(D3,D4,D1,D5)
--R            if D4 has COMRING and D5 has COMRING and D1 has FRNAALG D5 
--R            and D3 has FRNAALG D4
--R   [27] ((D2 -> D2),Factored D2) -> Factored D2 from Factored D2
--R            if D2 has INTDOM
--R   [28] ((D4 -> D5),D3) -> D1 from FunctionSpaceFunctions2(D4,D3,D5,D1)
--R            if D4 has Join(Ring,OrderedSet) and D5 has Join(Ring,
--R            OrderedSet) and D1 has FS D5 and D3 has FS D4
--R   [29] ((D4 -> D5),D3) -> D1 from FiniteSetAggregateFunctions2(D4,D3,
--R            D5,D1)
--R            if D4 has SETCAT and D5 has SETCAT and D1 has FSAGG D5 and 
--R            D3 has FSAGG D4
--R   [30] ((D2 -> D2),Heap D2) -> Heap D2 from Heap D2 if D2 has ORDSET
--R         
--R   [31] ((D2 -> D2),D) -> D from D if D has HOAGG D2 and D2 has TYPE
--R         
--R   [32] ((D2 -> D2),D) -> D from D
--R            if D has IDPC(D2,D3) and D2 has SETCAT and D3 has ORDSET
--R         
--R   [33] ((D4 -> D5),IntegrationResult D4) -> IntegrationResult D5
--R            from IntegrationResultFunctions2(D4,D5)
--R            if D4 has FIELD and D5 has FIELD
--R   [34] ((D4 -> D5),Union(Record(ratpart: D4,coeff: D4),"failed")) -> 
--R            Union(Record(ratpart: D5,coeff: D5),"failed")
--R            from IntegrationResultFunctions2(D4,D5)
--R            if D4 has FIELD and D5 has FIELD
--R   [35] ((D4 -> D1),Union(D4,"failed")) -> Union(D1,"failed")
--R            from IntegrationResultFunctions2(D4,D1)
--R            if D4 has FIELD and D1 has FIELD
--R   [36] ((D4 -> D5),Union(Record(mainpart: D4,limitedlogs: List Record(
--R            coeff: D4,logand: D4)),"failed")) -> Union(Record(mainpart: D5,
--R            limitedlogs: List Record(coeff: D5,logand: D5)),"failed")
--R            from IntegrationResultFunctions2(D4,D5)
--R            if D4 has FIELD and D5 has FIELD
--R   [37] ((D4 -> D5),InfiniteTuple D4) -> InfiniteTuple D5
--R            from InfiniteTupleFunctions2(D4,D5)
--R            if D4 has TYPE and D5 has TYPE
--R   [38] (((D5,D6) -> D7),InfiniteTuple D5,InfiniteTuple D6) -> 
--R            InfiniteTuple D7
--R            from InfiniteTupleFunctions3(D5,D6,D7)
--R            if D5 has TYPE and D6 has TYPE and D7 has TYPE
--R   [39] (((D5,D6) -> D7),Stream D5,InfiniteTuple D6) -> Stream D7
--R            from InfiniteTupleFunctions3(D5,D6,D7)
--R            if D5 has TYPE and D6 has TYPE and D7 has TYPE
--R   [40] (((D5,D6) -> D7),InfiniteTuple D5,Stream D6) -> Stream D7
--R            from InfiniteTupleFunctions3(D5,D6,D7)
--R            if D5 has TYPE and D6 has TYPE and D7 has TYPE
--R   [41] ((D2 -> D2),InfiniteTuple D2) -> InfiniteTuple D2 from 
--R            InfiniteTuple D2
--R            if D2 has TYPE
--R   [42] ((D4 -> D5),List D4) -> List D5 from ListFunctions2(D4,D5)
--R            if D4 has TYPE and D5 has TYPE
--R   [43] (((D5,D6) -> D7),List D5,List D6) -> List D7
--R            from ListFunctions3(D5,D6,D7)
--R            if D5 has TYPE and D6 has TYPE and D7 has TYPE
--R   [44] (((D2,D2) -> D2),D,D) -> D from D if D has LNAGG D2 and D2 has 
--R            TYPE
--R   [45] ((D5 -> D8),D4) -> D2
--R            from MatrixCategoryFunctions2(D5,D6,D7,D4,D8,D9,D1,D2)
--R            if D5 has RING and D8 has RING and D6 has FLAGG D5 and D7 
--R            has FLAGG D5 and D2 has MATCAT(D8,D9,D1) and D4 has MATCAT(
--R            D5,D6,D7) and D9 has FLAGG D8 and D1 has FLAGG D8
--R   [46] ((D5 -> Union(D8,"failed")),D4) -> Union(D2,"failed")
--R            from MatrixCategoryFunctions2(D5,D6,D7,D4,D8,D9,D1,D2)
--R            if D5 has RING and D8 has RING and D6 has FLAGG D5 and D7 
--R            has FLAGG D5 and D2 has MATCAT(D8,D9,D1) and D4 has MATCAT(
--R            D5,D6,D7) and D9 has FLAGG D8 and D1 has FLAGG D8
--R   [47] ((D7 -> D8),D3) -> D1 from MPolyCatFunctions2(D4,D5,D6,D7,D8,D3
--R            ,D1)
--R            if D7 has RING and D8 has RING and D4 has ORDSET and D5 has
--R            OAMONS and D1 has POLYCAT(D8,D6,D4) and D6 has OAMONS and 
--R            D3 has POLYCAT(D7,D5,D4)
--R   [48] ((D4 -> D5),MonoidRing(D4,D6)) -> MonoidRing(D5,D6)
--R            from MonoidRingFunctions2(D4,D5,D6)
--R            if D4 has RING and D5 has RING and D6 has MONOID
--R   [49] ((D4 -> D5),D3) -> D1 from OctonionCategoryFunctions2(D3,D4,D1,
--R            D5)
--R            if D4 has COMRING and D5 has COMRING and D1 has OC D5 and 
--R            D3 has OC D4
--R   [50] ((D4 -> D5),OnePointCompletion D4) -> OnePointCompletion D5
--R            from OnePointCompletionFunctions2(D4,D5)
--R            if D4 has SETCAT and D5 has SETCAT
--R   [51] ((D4 -> D5),OnePointCompletion D4,OnePointCompletion D5) -> 
--R            OnePointCompletion D5
--R            from OnePointCompletionFunctions2(D4,D5)
--R            if D4 has SETCAT and D5 has SETCAT
--R   [52] ((D4 -> D5),OrderedCompletion D4) -> OrderedCompletion D5
--R            from OrderedCompletionFunctions2(D4,D5)
--R            if D4 has SETCAT and D5 has SETCAT
--R   [53] ((D4 -> D5),OrderedCompletion D4,OrderedCompletion D5,
--R            OrderedCompletion D5) -> OrderedCompletion D5
--R            from OrderedCompletionFunctions2(D4,D5)
--R            if D4 has SETCAT and D5 has SETCAT
--R   [54] ((D4 -> D5),ParametricPlaneCurve D4) -> ParametricPlaneCurve D5
--R            from ParametricPlaneCurveFunctions2(D4,D5)
--R            if D4 has TYPE and D5 has TYPE
--R   [55] ((D4 -> D5),ParametricSpaceCurve D4) -> ParametricSpaceCurve D5
--R            from ParametricSpaceCurveFunctions2(D4,D5)
--R            if D4 has TYPE and D5 has TYPE
--R   [56] ((D4 -> D5),ParametricSurface D4) -> ParametricSurface D5
--R            from ParametricSurfaceFunctions2(D4,D5)
--R            if D4 has TYPE and D5 has TYPE
--R   [57] ((D5 -> D6),PatternMatchResult(D4,D5)) -> PatternMatchResult(D4
--R            ,D6)
--R            from PatternMatchResultFunctions2(D4,D5,D6)
--R            if D4 has SETCAT and D5 has SETCAT and D6 has SETCAT
--R   [58] ((D4 -> D5),Pattern D4) -> Pattern D5 from PatternFunctions2(D4
--R            ,D5)
--R            if D4 has SETCAT and D5 has SETCAT
--R   [59] ((D4 -> D5),Polynomial D4) -> Polynomial D5
--R            from PolynomialFunctions2(D4,D5) if D4 has RING and D5 has 
--R            RING
--R   [60] ((D4 -> D5),PrimitiveArray D4) -> PrimitiveArray D5
--R            from PrimitiveArrayFunctions2(D4,D5)
--R            if D4 has TYPE and D5 has TYPE
--R   [61] ((D4 -> D5),Point D4) -> Point D5 from PointFunctions2(D4,D5)
--R            if D4 has RING and D5 has RING
--R   [62] ((D4 -> D5),D3) -> D1 from QuotientFieldCategoryFunctions2(D4,
--R            D5,D3,D1)
--R            if D4 has INTDOM and D5 has INTDOM and D1 has QFCAT D5 and 
--R            D3 has QFCAT D4
--R   [63] ((D4 -> D5),D3) -> D1 from QuaternionCategoryFunctions2(D3,D4,
--R            D1,D5)
--R            if D4 has COMRING and D5 has COMRING and D1 has QUATCAT D5 
--R            and D3 has QUATCAT D4
--R   [64] ((D2 -> D2),Queue D2) -> Queue D2 from Queue D2 if D2 has 
--R            SETCAT
--R   [65] (((D4,D4) -> D4),D,D) -> D from D
--R            if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5 has
--R            DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4)
--R   [66] ((D4 -> D4),D) -> D from D
--R            if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5 has
--R            DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4)
--R   [67] ((D9 -> D1),D6) -> D4
--R            from RectangularMatrixCategoryFunctions2(D7,D8,D9,D10,D11,
--R            D6,D1,D2,D3,D4)
--R            if D9 has RING and D1 has RING and D7: NNI and D8: NNI and 
--R            D10 has DIRPCAT(D8,D9) and D11 has DIRPCAT(D7,D9) and D4 
--R            has RMATCAT(D7,D8,D1,D2,D3) and D6 has RMATCAT(D7,D8,D9,D10
--R            ,D11) and D2 has DIRPCAT(D8,D1) and D3 has DIRPCAT(D7,D1)
--R         
--R   [68] ((D4 -> D5),Segment D4) -> Segment D5 from SegmentFunctions2(D4
--R            ,D5)
--R            if D4 has TYPE and D5 has TYPE
--R   [69] ((D4 -> D5),Segment D4) -> List D5 from SegmentFunctions2(D4,D5
--R            )
--R            if D4 has ORDRING and D4 has TYPE and D5 has TYPE
--R   [70] ((D4 -> D5),SegmentBinding D4) -> SegmentBinding D5
--R            from SegmentBindingFunctions2(D4,D5)
--R            if D4 has TYPE and D5 has TYPE
--R   [71] ((D3 -> D3),D) -> D1 from D
--R            if D has SEGXCAT(D3,D1) and D3 has ORDRING and D1 has STAGG
--R            D3
--R   [72] ((D2 -> D2),Stack D2) -> Stack D2 from Stack D2 if D2 has 
--R            SETCAT
--R   [73] ((D4 -> D5),Stream D4) -> Stream D5 from StreamFunctions2(D4,D5
--R            )
--R            if D4 has TYPE and D5 has TYPE
--R   [74] (((D5,D6) -> D7),Stream D5,Stream D6) -> Stream D7
--R            from StreamFunctions3(D5,D6,D7)
--R            if D5 has TYPE and D6 has TYPE and D7 has TYPE
--R   [75] ((D4 -> D5),SparseUnivariatePolynomial D4) -> 
--R            SparseUnivariatePolynomial D5
--R            from SparseUnivariatePolynomialFunctions2(D4,D5)
--R            if D4 has RING and D5 has RING
--R   [76] (((D3,D3) -> D3),D,D) -> D from D
--R            if D has TBAGG(D2,D3) and D2 has SETCAT and D3 has SETCAT
--R         
--R   [77] ((D5 -> D6),UnivariateLaurentSeries(D5,D7,D9)) -> 
--R            UnivariateLaurentSeries(D6,D8,D1)
--R            from UnivariateLaurentSeriesFunctions2(D5,D6,D7,D8,D9,D1)
--R            if D5 has RING and D6 has RING and D7: SYMBOL and D9: D5 
--R            and D1: D6 and D8: SYMBOL
--R   [78] ((D4 -> D5),UniversalSegment D4) -> UniversalSegment D5
--R            from UniversalSegmentFunctions2(D4,D5)
--R            if D4 has TYPE and D5 has TYPE
--R   [79] ((D4 -> D5),UniversalSegment D4) -> Stream D5
--R            from UniversalSegmentFunctions2(D4,D5)
--R            if D4 has ORDRING and D4 has TYPE and D5 has TYPE
--R   [80] ((D5 -> D7),UnivariatePolynomial(D4,D5)) -> 
--R            UnivariatePolynomial(D6,D7)
--R            from UnivariatePolynomialFunctions2(D4,D5,D6,D7)
--R            if D4: SYMBOL and D5 has RING and D7 has RING and D6: 
--R            SYMBOL
--R   [81] ((D4 -> D5),D3) -> D1
--R            from UnivariatePolynomialCategoryFunctions2(D4,D3,D5,D1)
--R            if D4 has RING and D5 has RING and D1 has UPOLYC D5 and D3 
--R            has UPOLYC D4
--R   [82] ((D5 -> D6),UnivariatePuiseuxSeries(D5,D7,D9)) -> 
--R            UnivariatePuiseuxSeries(D6,D8,D1)
--R            from UnivariatePuiseuxSeriesFunctions2(D5,D6,D7,D8,D9,D1)
--R            if D5 has RING and D6 has RING and D7: SYMBOL and D9: D5 
--R            and D1: D6 and D8: SYMBOL
--R   [83] ((D4 -> D5),D3) -> D1
--R            from UnivariateTaylorSeriesFunctions2(D4,D5,D3,D1)
--R            if D4 has RING and D5 has RING and D1 has UTSCAT D5 and D3 
--R            has UTSCAT D4
--R   [84] ((D4 -> D5),Vector D4) -> Vector D5 from VectorFunctions2(D4,D5
--R            )
--R            if D4 has TYPE and D5 has TYPE
--R   [85] ((D4 -> Union(D5,"failed")),Vector D4) -> Union(Vector D5,
--R            "failed")
--R            from VectorFunctions2(D4,D5) if D4 has TYPE and D5 has TYPE
--R            
--R   [86] ((D3 -> D3),D) -> D from D
--R            if D has XFALG(D2,D3) and D2 has ORDSET and D3 has RING
--R
--RThere are 10 unexposed functions called map :
--R   [1] ((D2 -> D2),AntiSymm(D2,D3)) -> AntiSymm(D2,D3) from AntiSymm(D2
--R            ,D3)
--R            if D2 has RING and D3: LIST SYMBOL
--R   [2] ((Expression D2 -> Expression D2),DeRhamComplex(D2,D3)) -> 
--R            DeRhamComplex(D2,D3)
--R            from DeRhamComplex(D2,D3)
--R            if D2 has Join(Ring,OrderedSet) and D3: LIST SYMBOL
--R   [3] ((D5 -> D1),String,Kernel D5) -> D1
--R            from ExpressionSpaceFunctions1(D5,D1)
--R            if D5 has ES and D1 has TYPE
--R   [4] ((D4 -> D6),D3) -> D1 from MultipleMap(D4,D5,D3,D6,D7,D1)
--R            if D4 has INTDOM and D6 has INTDOM and D5 has UPOLYC D4 and
--R            D1 has UPOLYC FRAC D7 and D3 has UPOLYC FRAC D5 and D7 has 
--R            UPOLYC D6
--R   [5] ((D4 -> D5),D3) -> D1 from MPolyCatFunctions3(D4,D5,D6,D7,D8,D3,
--R            D1)
--R            if D4 has ORDSET and D5 has ORDSET and D6 has OAMONS and D8
--R            has RING and D1 has POLYCAT(D8,D7,D5) and D7 has OAMONS and
--R            D3 has POLYCAT(D8,D6,D4)
--R   [6] ((D2 -> D2),MonoidRing(D2,D3)) -> MonoidRing(D2,D3)
--R            from MonoidRing(D2,D3) if D2 has RING and D3 has MONOID
--R   [7] ((D4 -> D5),NewSparseUnivariatePolynomial D4) -> 
--R            NewSparseUnivariatePolynomial D5
--R            from NewSparseUnivariatePolynomialFunctions2(D4,D5)
--R            if D4 has RING and D5 has RING
--R   [8] ((D7 -> D2),(D8 -> D2),D5) -> D2
--R            from PolynomialCategoryLifting(D6,D7,D8,D5,D2)
--R            if D7 has ORDSET and D8 has RING and D6 has OAMONS and D2 
--R            has SetCategory with 
--R               ?+? : (%,%) -> %
--R               ?*? : (%,%) -> %
--R               D : (%,NonNegativeInteger) -> %and D5 has POLYCAT(D8
--R            ,D6,D7)
--R   [9] ((Polynomial D3 -> D1),D1) -> D1 from PushVariables(D3,D4,D5,D1)
--R            if D3 has RING and D1 has POLYCAT(POLY D3,D4,D5) and D4 has
--R            OAMONS and D5 has OrderedSet with 
--R               convert : % -> Symbol
--R               variable : Symbol -> Union(%,"failed")
--R   [10] ((D2 -> D2),XPolynomialRing(D2,D3)) -> XPolynomialRing(D2,D3)
--R            from XPolynomialRing(D2,D3) if D2 has RING and D3 has 
--R            ORDMON
--R
--RExamples of map from AbelianMonoidRing
--R
--R
--RExamples of map from AntiSymm
--R
--R
--RExamples of map from TwoDimensionalArrayCategory
--R
--Radder(a:Integer,b:Integer):Integer == a+b 
--Rarr1 : ARRAY2 INT := new(5,4,10) 
--Rarr2 : ARRAY2 INT := new(3,3,10) 
--Rmap(adder,arr1,arr2,17)
--R
--Radder(a:Integer,b:Integer):Integer == a+b 
--Rarr : ARRAY2 INT := new(5,4,10) 
--Rmap(adder,arr,arr)
--R
--Rarr : ARRAY2 INT := new(5,4,10) 
--Rmap(-,arr) 
--Rmap((x +-> x + x),arr)
--R
--R
--RExamples of map from OneDimensionalArrayFunctions2
--R
--RT1:=OneDimensionalArrayFunctions2(Integer,Integer) 
--Rmap(x+->x+2,[i for i in 1..10])$T1
--R
--R
--RExamples of map from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Rmap(x+->x+10,a) 
--Ra
--R
--R
--RExamples of map from CartesianTensorFunctions2
--R
--R
--RExamples of map from ComplexFunctions2
--R
--R
--RExamples of map from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rmap(x+->x+10,a) 
--Ra
--R
--R
--RExamples of map from DeRhamComplex
--R
--R
--RExamples of map from DirectProductFunctions2
--R
--R
--RExamples of map from EquationFunctions2
--R
--R
--RExamples of map from Equation
--R
--R
--RExamples of map from ExpressionSpaceFunctions1
--R
--R
--RExamples of map from ExpressionSpaceFunctions2
--R
--R
--RExamples of map from ExpressionSpace
--R
--R
--RExamples of map from ExpertSystemToolsPackage2
--R
--R
--RExamples of map from ExpressionFunctions2
--R
--R
--RExamples of map from FiniteAbelianMonoidRingFunctions2
--R
--R
--RExamples of map from FiniteDivisorFunctions2
--R
--R
--RExamples of map from FullyEvalableOver
--R
--R
--RExamples of map from FunctionFieldCategoryFunctions2
--R
--R
--RExamples of map from FiniteLinearAggregateFunctions2
--R
--R
--RExamples of map from FreeModuleCat
--R
--R
--RExamples of map from FactoredFunctions2
--R
--R
--RExamples of map from FractionFunctions2
--R
--R
--RExamples of map from FractionalIdealFunctions2
--R
--R
--RExamples of map from FramedNonAssociativeAlgebraFunctions2
--R
--R
--RExamples of map from Factored
--R
--Rm(a:Factored Polynomial Integer):Factored Polynomial Integer == a^2 
--Rf:=x*y^3-3*x^2*y^2+3*x^3*y-x^4 
--Rmap(m,f) 
--Rg:=makeFR(z,factorList f) 
--Rmap(m,g)
--R
--R
--RExamples of map from FunctionSpaceFunctions2
--R
--R
--RExamples of map from FiniteSetAggregateFunctions2
--R
--R
--RExamples of map from Heap
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--Rmap(x+->x+10,a) 
--Ra
--R
--R
--RExamples of map from HomogeneousAggregate
--R
--R
--RExamples of map from IndexedDirectProductCategory
--R
--R
--RExamples of map from IntegrationResultFunctions2
--R
--R
--RExamples of map from InfiniteTupleFunctions2
--R
--R
--RExamples of map from InfiniteTupleFunctions3
--R
--R
--RExamples of map from InfiniteTuple
--R
--R
--RExamples of map from ListFunctions2
--R
--R
--RExamples of map from ListFunctions3
--R
--R
--RExamples of map from LinearAggregate
--R
--R
--RExamples of map from MatrixCategoryFunctions2
--R
--R
--RExamples of map from MultipleMap
--R
--R
--RExamples of map from MPolyCatFunctions2
--R
--R
--RExamples of map from MPolyCatFunctions3
--R
--R
--RExamples of map from MonoidRingFunctions2
--R
--R
--RExamples of map from MonoidRing
--R
--R
--RExamples of map from NewSparseUnivariatePolynomialFunctions2
--R
--R
--RExamples of map from OctonionCategoryFunctions2
--R
--R
--RExamples of map from OnePointCompletionFunctions2
--R
--R
--RExamples of map from OrderedCompletionFunctions2
--R
--R
--RExamples of map from ParametricPlaneCurveFunctions2
--R
--R
--RExamples of map from ParametricSpaceCurveFunctions2
--R
--R
--RExamples of map from ParametricSurfaceFunctions2
--R
--R
--RExamples of map from PatternMatchResultFunctions2
--R
--R
--RExamples of map from PatternFunctions2
--R
--R
--RExamples of map from PolynomialFunctions2
--R
--R
--RExamples of map from PolynomialCategoryLifting
--R
--R
--RExamples of map from PrimitiveArrayFunctions2
--R
--RT1:=PrimitiveArrayFunctions2(Integer,Integer) 
--Rmap(x+->x+2,[i for i in 1..10])$T1
--R
--R
--RExamples of map from PointFunctions2
--R
--R
--RExamples of map from PushVariables
--R
--R
--RExamples of map from QuotientFieldCategoryFunctions2
--R
--R
--RExamples of map from QuaternionCategoryFunctions2
--R
--Rf(a:FRAC(INT)):COMPLEX(FRAC(INT)) == a::COMPLEX(FRAC(INT)) 
--Rq:=quatern(2/11,-8,3/4,1) 
--Rmap(f,q)
--R
--R
--RExamples of map from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rmap(x+->x+10,a) 
--Ra
--R
--R
--RExamples of map from RectangularMatrixCategory
--R
--R
--RExamples of map from RectangularMatrixCategoryFunctions2
--R
--R
--RExamples of map from SegmentFunctions2
--R
--R
--RExamples of map from SegmentBindingFunctions2
--R
--R
--RExamples of map from SegmentExpansionCategory
--R
--R
--RExamples of map from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rmap(x+->x+10,a) 
--Ra
--R
--R
--RExamples of map from StreamFunctions2
--R
--Rm:=[i for i in 1..] 
--Rf(i:PositiveInteger):PositiveInteger==i**2 
--Rmap(f,m)
--R
--R
--RExamples of map from StreamFunctions3
--R
--Rm:=[i for i in 1..]::Stream(Integer) 
--Rn:=[i for i in 1..]::Stream(Integer) 
--Rf(i:Integer,j:Integer):Integer == i+j 
--Rmap(f,m,n)
--R
--R
--RExamples of map from SparseUnivariatePolynomialFunctions2
--R
--R
--RExamples of map from TableAggregate
--R
--R
--RExamples of map from UnivariateLaurentSeriesFunctions2
--R
--R
--RExamples of map from UniversalSegmentFunctions2
--R
--R
--RExamples of map from UnivariatePolynomialFunctions2
--R
--R
--RExamples of map from UnivariatePolynomialCategoryFunctions2
--R
--R
--RExamples of map from UnivariatePuiseuxSeriesFunctions2
--R
--R
--RExamples of map from UnivariateTaylorSeriesFunctions2
--R
--R
--RExamples of map from VectorFunctions2
--R
--R
--RExamples of map from XFreeAlgebra
--R
--R
--RExamples of map from XPolynomialRing
--R
--E 21

--S 22 of 127
)d op complete
--R 
--R
--RThere are 5 exposed functions called complete :
--R   [1] ContinuedFraction D1 -> ContinuedFraction D1 from 
--R            ContinuedFraction D1
--R            if D1 has EUCDOM
--R   [2] Integer -> SymmetricPolynomial Fraction Integer from 
--R            CycleIndicators
--R   [3] D -> D from D if D has LZSTAGG D1 and D1 has TYPE
--R   [4] D -> D from D if D has PADICCT D1
--R   [5] D -> D from D
--R            if D has PSCAT(D1,D2,D3) and D1 has RING and D2 has OAMON 
--R            and D3 has ORDSET
--R
--RExamples of complete from ContinuedFraction
--R
--R
--RExamples of complete from CycleIndicators
--R
--R
--RExamples of complete from LazyStreamAggregate
--R
--Rm:=[i for i in 1..] 
--Rn:=filterUntil(i+->i>100,m) 
--RnumberOfComputedEntries n 
--Rcomplete n 
--RnumberOfComputedEntries n
--R
--R
--RExamples of complete from PAdicIntegerCategory
--R
--R
--RExamples of complete from PowerSeriesCategory
--R
--E 22

--S 23 of 127
)d op cyclicEqual?
--R 
--R
--RThere is one exposed function called cyclicEqual? :
--R   [1] (Tree D2,Tree D2) -> Boolean from Tree D2 if D2 has SETCAT
--R
--RExamples of cyclicEqual? from Tree
--R
--Rt1:=tree [1,2,3,4] 
--Rt2:=tree [1,2,3,4] 
--RcyclicEqual?(t1,t2)
--R
--E 23

--S 24 of 127
)d op ncols
--R 
--R
--RThere are 2 exposed functions called ncols :
--R   [1] D -> NonNegativeInteger from D
--R            if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has FLAGG
--R            D2 and D4 has FLAGG D2
--R   [2] D -> NonNegativeInteger from D
--R            if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5 has
--R            DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4)
--R
--RExamples of ncols from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,10) 
--Rncols(arr)
--R
--R
--RExamples of ncols from RectangularMatrixCategory
--R
--E 24

--S 25 of 127
)d op inverseIntegralMatrixAtInfinity
--R 
--R
--RThere is one exposed function called inverseIntegralMatrixAtInfinity :
--R   [1]  -> Matrix Fraction D3 from D
--R            if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC 
--R            D2 and D4 has UPOLYC FRAC D3
--R
--RExamples of inverseIntegralMatrixAtInfinity from FunctionFieldCategory
--R
--RP0 := UnivariatePolynomial(x, Integer) 
--RP1 := UnivariatePolynomial(y, Fraction P0) 
--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
--RinverseIntegralMatrixAtInfinity()$R
--R
--E 25

--S 26 of 127
)d op generalizedContinuumHypothesisAssumed
--R 
--R
--RThere is one exposed function called generalizedContinuumHypothesisAssumed :
--R   [1] Boolean -> Boolean from CardinalNumber
--R
--RExamples of generalizedContinuumHypothesisAssumed from CardinalNumber
--R
--RgeneralizedContinuumHypothesisAssumed true 
--Ra:=Aleph 0 
--Rc:=2**a 
--Rf:=2**c
--R
--E 26

--S 27 of 127
)d op cyclic?
--R 
--R
--RThere are 2 exposed functions called cyclic? :
--R   [1] D -> Boolean from D if D has RCAGG D2 and D2 has TYPE
--R   [2] Tree D2 -> Boolean from Tree D2 if D2 has SETCAT
--R
--RExamples of cyclic? from RecursiveAggregate
--R
--R
--RExamples of cyclic? from Tree
--R
--Rt1:=tree [1,2,3,4] 
--Rcyclic? t1
--R
--E 27

--S 28 of 127
)d op nilFactor
--R 
--R
--RThere is one exposed function called nilFactor :
--R   [1] (D1,Integer) -> Factored D1 from Factored D1 if D1 has INTDOM
--R         
--R
--RExamples of nilFactor from Factored
--R
--RnilFactor(24,2) 
--RnilFactor(x-y,3)
--R
--E 28

--S 29 of 127
)d op quote
--R 
--R
--RThere is one exposed function called quote :
--R   [1]  -> Character from Character
--R
--RThere is one unexposed function called quote :
--R   [1] OutputForm -> OutputForm from OutputForm
--R
--RExamples of quote from Character
--R
--Rquote()
--R
--R
--RExamples of quote from OutputForm
--R
--E 29

--S 30 of 127
)d op balancedBinaryTree
--R 
--R
--RThere is one exposed function called balancedBinaryTree :
--R   [1] (NonNegativeInteger,D2) -> BalancedBinaryTree D2
--R            from BalancedBinaryTree D2 if D2 has SETCAT
--R
--RExamples of balancedBinaryTree from BalancedBinaryTree
--R
--RbalancedBinaryTree(4, 0)
--R
--E 30

--S 31 of 127
)d op integralBasisAtInfinity
--R 
--R
--RThere is one exposed function called integralBasisAtInfinity :
--R   [1]  -> Vector D from D
--R            if D2 has UFD and D3 has UPOLYC D2 and D4 has UPOLYC FRAC 
--R            D3 and D has FFCAT(D2,D3,D4)
--R
--RExamples of integralBasisAtInfinity from FunctionFieldCategory
--R
--RP0 := UnivariatePolynomial(x, Integer) 
--RP1 := UnivariatePolynomial(y, Fraction P0) 
--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
--RintegralBasisAtInfinity()$R
--R
--E 31

--S 32 of 127
)d op branchPointAtInfinity?
--R 
--R
--RThere is one exposed function called branchPointAtInfinity? :
--R   [1]  -> Boolean from D
--R            if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC 
--R            D2 and D4 has UPOLYC FRAC D3
--R
--RExamples of branchPointAtInfinity? from FunctionFieldCategory
--R
--RP0 := UnivariatePolynomial(x, Integer) 
--RP1 := UnivariatePolynomial(y, Fraction P0) 
--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
--RbranchPointAtInfinity?()$R 
--RR2 := RadicalFunctionField(INT, P0, P1, 2 * x**2, 4) 
--RbranchPointAtInfinity?()$R
--R
--E 32

--S 33 of 127
)d op transpose
--R 
--R
--RThere are 4 exposed functions called transpose :
--R   [1] (CartesianTensor(D2,D3,D4),Integer,Integer) -> CartesianTensor(
--R            D2,D3,D4)
--R            from CartesianTensor(D2,D3,D4)
--R            if D2: INT and D3: NNI and D4 has COMRING
--R   [2] CartesianTensor(D1,D2,D3) -> CartesianTensor(D1,D2,D3)
--R            from CartesianTensor(D1,D2,D3)
--R            if D1: INT and D2: NNI and D3 has COMRING
--R   [3] D -> D from D
--R            if D has MATCAT(D1,D2,D3) and D1 has RING and D2 has FLAGG 
--R            D1 and D3 has FLAGG D1
--R   [4] D1 -> D from D
--R            if D2 has RING and D has MATCAT(D2,D1,D3) and D1 has FLAGG 
--R            D2 and D3 has FLAGG D2
--R
--RThere is one unexposed function called transpose :
--R   [1] SquareMatrix(D1,D2) -> SquareMatrix(D1,D2) from SquareMatrix(D1,
--R            D2)
--R            if D1: NNI and D2 has RING
--R
--RExamples of transpose from CartesianTensor
--R
--Rm:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]] 
--Rtm:CartesianTensor(1,2,Integer):=m 
--Rtn:CartesianTensor(1,2,Integer):=[tm,tm] 
--Rtranspose(tn,1,2)
--R
--Rm:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]] 
--RTm:CartesianTensor(1,2,Integer):=m 
--Rtranspose(Tm)
--R
--R
--RExamples of transpose from MatrixCategory
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--Rtranspose m
--R
--Rtranspose([1,2,3])@Matrix(INT)
--R
--R
--RExamples of transpose from SquareMatrix
--R
--E 33

--S 34 of 127
)d op setrest!
--R 
--R
--RThere are 2 exposed functions called setrest! :
--R   [1] (Stream D2,Integer,Stream D2) -> Stream D2 from Stream D2 if D2 
--R            has TYPE
--R   [2] (D,D) -> D from D
--R            if D has shallowlyMutable and D has URAGG D1 and D1 has 
--R            TYPE
--R
--RExamples of setrest! from Stream
--R
--Rp:=[i for i in 1..] 
--Rq:=[i for i in 9..] 
--Rsetrest!(p,4,q) 
--Rp
--R
--R
--RExamples of setrest! from UnaryRecursiveAggregate
--R
--E 34

--S 35 of 127
)d op **
--R 
--R
--RThere are 21 exposed functions called ** :
--R   [1] (CardinalNumber,CardinalNumber) -> CardinalNumber from 
--R            CardinalNumber
--R   [2] (DoubleFloat,DoubleFloat) -> DoubleFloat from DoubleFloat
--R   [3] (D,Integer) -> D from D if D has DIVRING
--R   [4] (D,D) -> D from D if D has ELEMFUN
--R   [5] (Float,Float) -> Float from Float
--R   [6] (D,NonNegativeInteger) -> D from D
--R            if D has FS D2 and D2 has ORDSET and D2 has SGROUP
--R   [7] (D,Integer) -> D from D if D has GROUP
--R   [8] (PolynomialIdeals(D2,D3,D4,D5),NonNegativeInteger) -> 
--R            PolynomialIdeals(D2,D3,D4,D5)
--R            from PolynomialIdeals(D2,D3,D4,D5)
--R            if D2 has FIELD and D3 has OAMONS and D4 has ORDSET and D5 
--R            has POLYCAT(D2,D3,D4)
--R   [9] ((D3 -> D3),NonNegativeInteger) -> (D3 -> D3) from 
--R            MappingPackage1 D3
--R            if D3 has SETCAT
--R   [10] (D,Integer) -> D from D
--R            if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG 
--R            D2 and D4 has FLAGG D2 and D2 has FIELD
--R   [11] (D,NonNegativeInteger) -> D from D
--R            if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG 
--R            D2 and D4 has FLAGG D2
--R   [12] (ModuleOperator(D2,D3),Integer) -> ModuleOperator(D2,D3)
--R            from ModuleOperator(D2,D3) if D2 has RING and D3 has 
--R            LMODULE D2
--R   [13] (BasicOperator,Integer) -> ModuleOperator(D3,D4)
--R            from ModuleOperator(D3,D4) if D3 has RING and D4 has 
--R            LMODULE D3
--R   [14] (D,PositiveInteger) -> D from D if D has MONAD
--R   [15] (D,NonNegativeInteger) -> D from D if D has MONADWU
--R   [16] (D,NonNegativeInteger) -> D from D if D has MONOID
--R   [17] (MyExpression(D1,D2),MyExpression(D1,D2)) -> MyExpression(D1,D2
--R            )
--R            from MyExpression(D1,D2)
--R            if D1: SYMBOL and D2 has Join(Ring,OrderedSet,
--R            IntegralDomain)
--R   [18] (D,Fraction Integer) -> D from D if D has RADCAT
--R   [19] (D,PositiveInteger) -> D from D if D has SGROUP
--R   [20] (D,Integer) -> D from D
--R            if D has SMATCAT(D2,D3,D4,D5) and D3 has RING and D4 has 
--R            DIRPCAT(D2,D3) and D5 has DIRPCAT(D2,D3) and D3 has FIELD
--R         
--R   [21] (D,D1) -> D from D
--R            if D has UTSCAT D1 and D1 has RING and D1 has FIELD
--R
--RThere are 18 unexposed functions called ** :
--R   [1] (D1,Fraction Integer) -> D1 from AlgebraicFunction(D3,D1)
--R            if D3 has RETRACT INT and D3 has Join(OrderedSet,
--R            IntegralDomain) and D1 has FS D3
--R   [2] (D1,D1) -> D1 from CombinatorialFunction(D2,D1)
--R            if D2 has Join(OrderedSet,IntegralDomain) and D1 has FS D2
--R            
--R   [3] (D1,Fraction Integer) -> D1
--R            from ElementaryFunctionsUnivariateLaurentSeries(D3,D4,D1)
--R            if D3 has FIELD and D3 has ALGEBRA FRAC INT and D4 has 
--R            UTSCAT D3 and D1 has ULSCCAT(D3,D4)
--R   [4] (D1,Fraction Integer) -> D1
--R            from ElementaryFunctionsUnivariatePuiseuxSeries(D3,D4,D1,D5
--R            )
--R            if D3 has FIELD and D3 has ALGEBRA FRAC INT and D4 has 
--R            ULSCAT D3 and D1 has UPXSCCA(D3,D4) and D5 has PTRANFN D4
--R         
--R   [5] (D1,Integer) -> FreeGroup D1 from FreeGroup D1 if D1 has SETCAT
--R            
--R   [6] (D1,NonNegativeInteger) -> FreeMonoid D1 from FreeMonoid D1
--R            if D1 has SETCAT
--R   [7] (Vector D3,Integer) -> Vector D3 from 
--R            InnerNormalBasisFieldFunctions D3
--R            if D3 has FFIELDC
--R   [8] (InputForm,Integer) -> InputForm from InputForm
--R   [9] (InputForm,NonNegativeInteger) -> InputForm from InputForm
--R   [10] (Matrix D3,NonNegativeInteger) -> Matrix D3
--R            from StorageEfficientMatrixOperations D3 if D3 has RING
--R   [11] (D1,NonNegativeInteger) -> OrderedFreeMonoid D1
--R            from OrderedFreeMonoid D1 if D1 has ORDSET
--R   [12] (Operator D2,Integer) -> Operator D2 from Operator D2 if D2 has
--R            RING
--R   [13] (BasicOperator,Integer) -> Operator D3 from Operator D3 if D3 
--R            has RING
--R   [14] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R   [15] (Pattern D1,Pattern D1) -> Pattern D1 from Pattern D1 if D1 has
--R            SETCAT
--R   [16] (Pattern D2,NonNegativeInteger) -> Pattern D2 from Pattern D2
--R            if D2 has SETCAT
--R   [17] (Stream D2,Stream D2) -> Stream D2
--R            from StreamTranscendentalFunctionsNonCommutative D2
--R            if D2 has ALGEBRA FRAC INT
--R   [18] (Stream D2,Stream D2) -> Stream D2
--R            from StreamTranscendentalFunctions D2 if D2 has ALGEBRA 
--R            FRAC INT
--R
--RExamples of ** from AlgebraicFunction
--R
--R
--RExamples of ** from CardinalNumber
--R
--Rc2:=2::CardinalNumber 
--Rc2**c2 
--RA1:=Aleph 1 
--RA1**c2 
--RgeneralizedContinuumHypothesisAssumed true 
--RA1**A1
--R
--R
--RExamples of ** from CombinatorialFunction
--R
--R
--RExamples of ** from DoubleFloat
--R
--R
--RExamples of ** from DivisionRing
--R
--R
--RExamples of ** from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of ** from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of ** from ElementaryFunctionCategory
--R
--R
--RExamples of ** from FreeGroup
--R
--R
--RExamples of ** from Float
--R
--R
--RExamples of ** from FreeMonoid
--R
--R
--RExamples of ** from FunctionSpace
--R
--R
--RExamples of ** from Group
--R
--R
--RExamples of ** from PolynomialIdeals
--R
--R
--RExamples of ** from InnerNormalBasisFieldFunctions
--R
--R
--RExamples of ** from InputForm
--R
--R
--RExamples of ** from MappingPackage1
--R
--R
--RExamples of ** from MatrixCategory
--R
--R(matrix [[j**i for i in 0..4] for j in 1..5]) ** 2
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--Rm**3
--R
--R
--RExamples of ** from StorageEfficientMatrixOperations
--R
--R
--RExamples of ** from ModuleOperator
--R
--R
--RExamples of ** from Monad
--R
--R
--RExamples of ** from MonadWithUnit
--R
--R
--RExamples of ** from Monoid
--R
--R
--RExamples of ** from MyExpression
--R
--R
--RExamples of ** from OrderedFreeMonoid
--R
--Rm1:=(y**3)$OFMONOID(Symbol)
--R
--R
--RExamples of ** from Operator
--R
--R
--RExamples of ** from OutputForm
--R
--R
--RExamples of ** from Pattern
--R
--R
--RExamples of ** from RadicalCategory
--R
--R
--RExamples of ** from SemiGroup
--R
--R
--RExamples of ** from SquareMatrixCategory
--R
--R
--RExamples of ** from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of ** from StreamTranscendentalFunctions
--R
--R
--RExamples of ** from UnivariateTaylorSeriesCategory
--R
--E 35

--S 36 of 127
)d op plot
--R 
--R
--RThere are 12 unexposed functions called plot :
--R   [1] (D2,Symbol,Segment DoubleFloat) -> Plot from PlotFunctions1 D2
--R            if D2 has KONVERT INFORM
--R   [2] (D2,D2,Symbol,Segment DoubleFloat) -> Plot from PlotFunctions1 
--R            D2
--R            if D2 has KONVERT INFORM
--R   [3] (Plot3D,Segment DoubleFloat) -> Plot3D from Plot3D
--R   [4] ((DoubleFloat -> DoubleFloat),(DoubleFloat -> DoubleFloat),(
--R            DoubleFloat -> DoubleFloat),(DoubleFloat -> DoubleFloat),Segment 
--R            DoubleFloat,Segment DoubleFloat,Segment DoubleFloat,Segment 
--R            DoubleFloat) -> Plot3D
--R            from Plot3D
--R   [5] ((DoubleFloat -> DoubleFloat),(DoubleFloat -> DoubleFloat),(
--R            DoubleFloat -> DoubleFloat),(DoubleFloat -> DoubleFloat),Segment 
--R            DoubleFloat) -> Plot3D
--R            from Plot3D
--R   [6] (Plot,Segment DoubleFloat) -> Plot from Plot
--R   [7] ((DoubleFloat -> DoubleFloat),(DoubleFloat -> DoubleFloat),
--R            Segment DoubleFloat,Segment DoubleFloat,Segment DoubleFloat) -> 
--R            Plot
--R            from Plot
--R   [8] ((DoubleFloat -> DoubleFloat),(DoubleFloat -> DoubleFloat),
--R            Segment DoubleFloat) -> Plot
--R            from Plot
--R   [9] (List (DoubleFloat -> DoubleFloat),Segment DoubleFloat,Segment 
--R            DoubleFloat) -> Plot
--R            from Plot
--R   [10] (List (DoubleFloat -> DoubleFloat),Segment DoubleFloat) -> Plot
--R            from Plot
--R   [11] ((DoubleFloat -> DoubleFloat),Segment DoubleFloat,Segment 
--R            DoubleFloat) -> Plot
--R            from Plot
--R   [12] ((DoubleFloat -> DoubleFloat),Segment DoubleFloat) -> Plot from
--R            Plot
--R
--RExamples of plot from PlotFunctions1
--R
--R
--RExamples of plot from Plot3D
--R
--R
--RExamples of plot from Plot
--R
--Rfp:=(t:DFLOAT):DFLOAT +-> sin(t) 
--Rplot(fp,-1.0..1.0)$PLOT
--R
--E 36

--S 37 of 127
)d op factorList
--R 
--R
--RThere is one exposed function called factorList :
--R   [1] Factored D2 -> List Record(flg: Union("nil","sqfr","irred",
--R            "prime"),fctr: D2,xpnt: Integer)
--R            from Factored D2 if D2 has INTDOM
--R
--RThere is one unexposed function called factorList :
--R   [1] (D2,NonNegativeInteger,NonNegativeInteger,NonNegativeInteger)
--R             -> List SparseUnivariatePolynomial D2
--R            from ChineseRemainderToolsForIntegralBases(D2,D4,D5)
--R            if D2 has FFIELDC and D4 has UPOLYC D2 and D5 has UPOLYC D4
--R            
--R
--RExamples of factorList from Factored
--R
--Rf:=nilFactor(x-y,3) 
--RfactorList f
--R
--R
--RExamples of factorList from ChineseRemainderToolsForIntegralBases
--R
--E 37

--S 38 of 127
)d op physicalLength
--R 
--R
--RThere is one exposed function called physicalLength :
--R   [1] FlexibleArray D2 -> NonNegativeInteger from FlexibleArray D2
--R            if D2 has TYPE
--R
--RThere is one unexposed function called physicalLength :
--R   [1] IndexedFlexibleArray(D2,D3) -> NonNegativeInteger
--R            from IndexedFlexibleArray(D2,D3) if D2 has TYPE and D3: INT
--R            
--R
--RExamples of physicalLength from FlexibleArray
--R
--R
--RExamples of physicalLength from IndexedFlexibleArray
--R
--RT1:=IndexedFlexibleArray(Integer,20) 
--Rt2:=flexibleArray([i for i in 1..10])$T1 
--RphysicalLength t2
--R
--E 38

--S 39 of 127
)d op absolutelyIrreducible?
--R 
--R
--RThere is one exposed function called absolutelyIrreducible? :
--R   [1]  -> Boolean from D
--R            if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC 
--R            D2 and D4 has UPOLYC FRAC D3
--R
--RThere is one unexposed function called absolutelyIrreducible? :
--R   [1]  -> Boolean from FunctionFieldCategory&(D2,D3,D4,D5)
--R            if D3 has UFD and D4 has UPOLYC D3 and D5 has UPOLYC FRAC 
--R            D4 and D2 has FFCAT(D3,D4,D5)
--R
--RExamples of absolutelyIrreducible? from FunctionFieldCategory&
--R
--RP0 := UnivariatePolynomial(x, Integer) 
--RP1 := UnivariatePolynomial(y, Fraction P0) 
--RR2 := RadicalFunctionField(INT, P0, P1, 2 * x**2, 4) 
--RabsolutelyIrreducible?()$R2
--R
--R
--RExamples of absolutelyIrreducible? from FunctionFieldCategory
--R
--RP0 := UnivariatePolynomial(x, Integer) 
--RP1 := UnivariatePolynomial(y, Fraction P0) 
--RR2 := RadicalFunctionField(INT, P0, P1, 2 * x**2, 4) 
--RabsolutelyIrreducible?()$R2
--R
--E 39

--S 40 of 127
)d op repeating?
--R 
--R
--RThere is one exposed function called repeating? :
--R   [1] (List D3,Stream D3) -> Boolean from Stream D3
--R            if D3 has SETCAT and D3 has TYPE
--R
--RExamples of repeating? from Stream
--R
--Rm:=[1,2,3] 
--Rn:=repeating(m) 
--Rrepeating?(m,n)
--R
--E 40

--S 41 of 127
)d op lazy?
--R 
--R
--RThere is one exposed function called lazy? :
--R   [1] D -> Boolean from D if D has LZSTAGG D2 and D2 has TYPE
--R
--RExamples of lazy? from LazyStreamAggregate
--R
--Rm:=[i for i in 0..] 
--Rlazy? m
--R
--E 41

--S 42 of 127
)d op ord
--R 
--R
--RThere is one exposed function called ord :
--R   [1] Character -> Integer from Character
--R
--RExamples of ord from Character
--R
--Rchars := [char "a", char "A", char "X", char "8", char "+"] 
--R[ord c for c in chars]
--R
--E 42

--S 43 of 127
)d op setColumn!
--R 
--R
--RThere is one exposed function called setColumn! :
--R   [1] (D,Integer,D2) -> D from D
--R            if D has ARR2CAT(D3,D4,D2) and D3 has TYPE and D4 has FLAGG
--R            D3 and D2 has FLAGG D3
--R
--RExamples of setColumn! from TwoDimensionalArrayCategory
--R
--RT1:=TwoDimensionalArray Integer 
--Rarr:T1:= new(5,4,0) 
--RT2:=OneDimensionalArray Integer 
--Racol:=construct([1,2,3,4,5]::List(INT))$T2 
--RsetColumn!(arr,1,acol)$T1
--R
--E 43

--S 44 of 127
)d op lowerCase?
--R 
--R
--RThere is one exposed function called lowerCase? :
--R   [1] Character -> Boolean from Character
--R
--RExamples of lowerCase? from Character
--R
--Rchars := [char "a", char "A", char "X", char "8", char "+"] 
--R[lowerCase? c for c in chars]
--R
--E 44

--S 45 of 127
)d op physicalLength!
--R 
--R
--RThere is one exposed function called physicalLength! :
--R   [1] (FlexibleArray D2,Integer) -> FlexibleArray D2 from 
--R            FlexibleArray D2
--R            if D2 has TYPE
--R
--RThere is one unexposed function called physicalLength! :
--R   [1] (IndexedFlexibleArray(D2,D3),Integer) -> IndexedFlexibleArray(D2
--R            ,D3)
--R            from IndexedFlexibleArray(D2,D3) if D2 has TYPE and D3: INT
--R            
--R
--RExamples of physicalLength! from FlexibleArray
--R
--R
--RExamples of physicalLength! from IndexedFlexibleArray
--R
--RT1:=IndexedFlexibleArray(Integer,20) 
--Rt2:=flexibleArray([i for i in 1..10])$T1 
--RphysicalLength!(t2,15)
--R
--E 45

--S 46 of 127
)d op countable?
--R 
--R
--RThere is one exposed function called countable? :
--R   [1] CardinalNumber -> Boolean from CardinalNumber
--R
--RExamples of countable? from CardinalNumber
--R
--Rc2:=2::CardinalNumber 
--Rcountable? c2 
--RA0:=Aleph 0 
--Rcountable? A0 
--RA1:=Aleph 1 
--Rcountable? A1
--R
--E 46

--S 47 of 127
)d op extend
--R 
--R
--RThere are 11 exposed functions called extend :
--R   [1] (ContinuedFraction D2,Integer) -> ContinuedFraction D2
--R            from ContinuedFraction D2 if D2 has EUCDOM
--R   [2] (D,Integer) -> D from D if D has LZSTAGG D2 and D2 has TYPE
--R   [3] (D,NonNegativeInteger) -> D from D
--R            if D has MTSCAT(D2,D3) and D2 has RING and D3 has ORDSET
--R         
--R   [4] (D,Integer) -> D from D if D has PADICCT D2
--R   [5] (D,List D2) -> D from D if D has PTCAT D2 and D2 has RING
--R   [6] (List D6,List D) -> List D from D
--R            if D has RSETCAT(D3,D4,D5,D6) and D3 has GCDDOM and D4 has 
--R            OAMONS and D5 has ORDSET and D6 has RPOLCAT(D3,D4,D5)
--R   [7] (List D6,D) -> List D from D
--R            if D6 has RPOLCAT(D3,D4,D5) and D3 has GCDDOM and D4 has 
--R            OAMONS and D5 has ORDSET and D has RSETCAT(D3,D4,D5,D6)
--R   [8] (D2,List D) -> List D from D
--R            if D has RSETCAT(D3,D4,D5,D2) and D3 has GCDDOM and D4 has 
--R            OAMONS and D5 has ORDSET and D2 has RPOLCAT(D3,D4,D5)
--R   [9] (D2,D) -> List D from D
--R            if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and D2
--R            has RPOLCAT(D3,D4,D5) and D has RSETCAT(D3,D4,D5,D2)
--R   [10] (D,D1) -> D from D
--R            if D has TSETCAT(D2,D3,D4,D1) and D2 has INTDOM and D3 has 
--R            OAMONS and D4 has ORDSET and D1 has RPOLCAT(D2,D3,D4)
--R   [11] (D,D1) -> D from D
--R            if D has UPSCAT(D2,D1) and D2 has RING and D1 has OAMON
--R
--RExamples of extend from ContinuedFraction
--R
--R
--RExamples of extend from LazyStreamAggregate
--R
--Rm:=[i for i in 0..] 
--RnumberOfComputedEntries m 
--Rextend(m,20) 
--RnumberOfComputedEntries m
--R
--R
--RExamples of extend from MultivariateTaylorSeriesCategory
--R
--R
--RExamples of extend from PAdicIntegerCategory
--R
--R
--RExamples of extend from PointCategory
--R
--R
--RExamples of extend from RegularTriangularSetCategory
--R
--R
--RExamples of extend from TriangularSetCategory
--R
--R
--RExamples of extend from UnivariatePowerSeriesCategory
--R
--E 47

--S 48 of 127
)d op length
--R 
--R
--RThere are 5 exposed functions called length :
--R   [1] Dequeue D2 -> NonNegativeInteger from Dequeue D2 if D2 has 
--R            SETCAT
--R   [2] D -> D from D if D has INS
--R   [3] D -> NonNegativeInteger from D if D has QUAGG D2 and D2 has TYPE
--R            
--R   [4] Queue D2 -> NonNegativeInteger from Queue D2 if D2 has SETCAT
--R         
--R   [5] D -> D1 from D
--R            if D has VECTCAT D1 and D1 has TYPE and D1 has RADCAT and 
--R            D1 has RING
--R
--RThere are 6 unexposed functions called length :
--R   [1] D2 -> D1 from GaloisGroupFactorizationUtilities(D3,D2,D1)
--R            if D3 has RING and D1 has Join(FloatingPointSystem,
--R            RetractableTo D3,Field,TranscendentalFunctionCategory,
--R            ElementaryFunctionCategory) and D2 has UPOLYC D3
--R   [2] LyndonWord D2 -> PositiveInteger from LyndonWord D2 if D2 has 
--R            ORDSET
--R   [3] Magma D2 -> PositiveInteger from Magma D2 if D2 has ORDSET
--R   [4] OrderedFreeMonoid D2 -> NonNegativeInteger from 
--R            OrderedFreeMonoid D2
--R            if D2 has ORDSET
--R   [5] PoincareBirkhoffWittLyndonBasis D2 -> NonNegativeInteger
--R            from PoincareBirkhoffWittLyndonBasis D2 if D2 has ORDSET
--R         
--R   [6] Tuple D2 -> NonNegativeInteger from Tuple D2 if D2 has TYPE
--R
--RExamples of length from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rlength a
--R
--R
--RExamples of length from GaloisGroupFactorizationUtilities
--R
--R
--RExamples of length from IntegerNumberSystem
--R
--R
--RExamples of length from LyndonWord
--R
--R
--RExamples of length from Magma
--R
--R
--RExamples of length from OrderedFreeMonoid
--R
--Rm1:=(x*y*y*z)$OFMONOID(Symbol) 
--Rlength m1
--R
--R
--RExamples of length from PoincareBirkhoffWittLyndonBasis
--R
--R
--RExamples of length from QueueAggregate
--R
--R
--RExamples of length from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rlength a
--R
--R
--RExamples of length from Tuple
--R
--Rt1:PrimitiveArray(Integer):= [i for i in 1..10] 
--Rt2:=coerce(t1)$Tuple(Integer) 
--Rlength(t2)
--R
--R
--RExamples of length from VectorCategory
--R
--E 48

--S 49 of 127
)d op viewPosDefault
--R 
--R
--RThere are 2 exposed functions called viewPosDefault :
--R   [1]  -> List NonNegativeInteger from ViewDefaultsPackage
--R   [2] List NonNegativeInteger -> List NonNegativeInteger
--R            from ViewDefaultsPackage
--R
--RExamples of viewPosDefault from ViewDefaultsPackage
--R
--Rand Y position of a viewport window unless overriden explicityly, newly created viewports will have th 
--Rand Y coordinates x, y.
--R
--Rand Y position of a viewport window unless overriden explicityly, newly created viewports will have this 
--Rand Y coordinate.
--R
--E 49

--S 50 of 127
)d op groebner
--R 
--R
--RThere are 5 exposed functions called groebner :
--R   [1] List D5 -> List D5 from GroebnerPackage(D2,D3,D4,D5)
--R            if D5 has POLYCAT(D2,D3,D4) and D2 has GCDDOM and D3 has 
--R            OAMONS and D4 has ORDSET
--R   [2] (List D6,String) -> List D6 from GroebnerPackage(D3,D4,D5,D6)
--R            if D6 has POLYCAT(D3,D4,D5) and D3 has GCDDOM and D4 has 
--R            OAMONS and D5 has ORDSET
--R   [3] (List D6,String,String) -> List D6 from GroebnerPackage(D3,D4,D5
--R            ,D6)
--R            if D6 has POLYCAT(D3,D4,D5) and D3 has GCDDOM and D4 has 
--R            OAMONS and D5 has ORDSET
--R   [4] PolynomialIdeals(D1,D2,D3,D4) -> PolynomialIdeals(D1,D2,D3,D4)
--R            from PolynomialIdeals(D1,D2,D3,D4)
--R            if D1 has FIELD and D2 has OAMONS and D3 has ORDSET and D4 
--R            has POLYCAT(D1,D2,D3)
--R   [5] List D6 -> List D6 from InterfaceGroebnerPackage(D2,D3,D4,D5,D6)
--R            if D6 has POLYCAT(D2,D4,D5) and D2 has FIELD and D4 has 
--R            OAMONS and D5 has ORDSET and D3: LIST SYMBOL
--R
--RThere are 2 unexposed functions called groebner :
--R   [1] List Polynomial D2 -> List Polynomial D2 from FGLMIfCanPackage(
--R            D2,D3)
--R            if D2 has GCDDOM and D3: LIST SYMBOL
--R   [2] List NewSparseMultivariatePolynomial(D2,OrderedVariableList D3)
--R             -> List NewSparseMultivariatePolynomial(D2,OrderedVariableList 
--R            D3)
--R            from LexTriangularPackage(D2,D3)
--R            if D2 has GCDDOM and D3: LIST SYMBOL
--R
--RExamples of groebner from FGLMIfCanPackage
--R
--R
--RExamples of groebner from GroebnerPackage
--R
--Rs1:DMP([w,p,z,t,s,b],FRAC(INT)):= 45*p + 35*s - 165*b - 36 
--Rs2:DMP([w,p,z,t,s,b],FRAC(INT)):= 35*p + 40*z + 25*t - 27*s 
--Rs3:DMP([w,p,z,t,s,b],FRAC(INT)):= 15*w + 25*p*s + 30*z - 18*t - 165*b**2 
--Rs4:DMP([w,p,z,t,s,b],FRAC(INT)):= -9*w + 15*p*t + 20*z*s 
--Rs5:DMP([w,p,z,t,s,b],FRAC(INT)):= w*p + 2*z*t - 11*b**3 
--Rs6:DMP([w,p,z,t,s,b],FRAC(INT)):= 99*w - 11*b*s + 3*b**2 
--Rs7:DMP([w,p,z,t,s,b],FRAC(INT)):= b**2 + 33/50*b + 2673/10000 
--Rsn7:=[s1,s2,s3,s4,s5,s6,s7] 
--Rgroebner(sn7,"info","redcrit")
--R
--Rs1:DMP([w,p,z,t,s,b],FRAC(INT)):= 45*p + 35*s - 165*b - 36 
--Rs2:DMP([w,p,z,t,s,b],FRAC(INT)):= 35*p + 40*z + 25*t - 27*s 
--Rs3:DMP([w,p,z,t,s,b],FRAC(INT)):= 15*w + 25*p*s + 30*z - 18*t - 165*b**2 
--Rs4:DMP([w,p,z,t,s,b],FRAC(INT)):= -9*w + 15*p*t + 20*z*s 
--Rs5:DMP([w,p,z,t,s,b],FRAC(INT)):= w*p + 2*z*t - 11*b**3 
--Rs6:DMP([w,p,z,t,s,b],FRAC(INT)):= 99*w - 11*b*s + 3*b**2 
--Rs7:DMP([w,p,z,t,s,b],FRAC(INT)):= b**2 + 33/50*b + 2673/10000 
--Rsn7:=[s1,s2,s3,s4,s5,s6,s7] 
--Rgroebner(sn7,"info") 
--Rgroebner(sn7,"redcrit")
--R
--Rs1:DMP([w,p,z,t,s,b],FRAC(INT)):= 45*p + 35*s - 165*b - 36 
--Rs2:DMP([w,p,z,t,s,b],FRAC(INT)):= 35*p + 40*z + 25*t - 27*s 
--Rs3:DMP([w,p,z,t,s,b],FRAC(INT)):= 15*w + 25*p*s + 30*z - 18*t - 165*b**2 
--Rs4:DMP([w,p,z,t,s,b],FRAC(INT)):= -9*w + 15*p*t + 20*z*s 
--Rs5:DMP([w,p,z,t,s,b],FRAC(INT)):= w*p + 2*z*t - 11*b**3 
--Rs6:DMP([w,p,z,t,s,b],FRAC(INT)):= 99*w - 11*b*s + 3*b**2 
--Rs7:DMP([w,p,z,t,s,b],FRAC(INT)):= b**2 + 33/50*b + 2673/10000 
--Rsn7:=[s1,s2,s3,s4,s5,s6,s7] 
--Rgroebner(sn7)
--R
--R
--RExamples of groebner from PolynomialIdeals
--R
--R
--RExamples of groebner from InterfaceGroebnerPackage
--R
--R
--RExamples of groebner from LexTriangularPackage
--R
--E 50

--S 51 of 127
)d op primeFactor
--R 
--R
--RThere is one exposed function called primeFactor :
--R   [1] (D1,Integer) -> Factored D1 from Factored D1 if D1 has INTDOM
--R         
--R
--RExamples of primeFactor from Factored
--R
--Ra:=primeFactor(3,4) 
--RnthFlag(a,1)
--R
--E 51

--S 52 of 127
)d op map!
--R 
--R
--RThere are 7 exposed functions called map! :
--R   [1] ((D2 -> D2),D) -> D from D
--R            if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has FLAGG
--R            D2 and D4 has FLAGG D2
--R   [2] ((D2 -> D2),ArrayStack D2) -> ArrayStack D2 from ArrayStack D2
--R            if $ has shallowlyMutable and D2 has SETCAT
--R   [3] ((D2 -> D2),Dequeue D2) -> Dequeue D2 from Dequeue D2
--R            if $ has shallowlyMutable and D2 has SETCAT
--R   [4] ((D2 -> D2),Heap D2) -> Heap D2 from Heap D2
--R            if $ has shallowlyMutable and D2 has ORDSET
--R   [5] ((D2 -> D2),D) -> D from D
--R            if D has shallowlyMutable and D has HOAGG D2 and D2 has 
--R            TYPE
--R   [6] ((D2 -> D2),Queue D2) -> Queue D2 from Queue D2
--R            if $ has shallowlyMutable and D2 has SETCAT
--R   [7] ((D2 -> D2),Stack D2) -> Stack D2 from Stack D2
--R            if $ has shallowlyMutable and D2 has SETCAT
--R
--RExamples of map! from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,10) 
--Rmap!(-,arr)
--R
--R
--RExamples of map! from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Rmap!(x+->x+10,a) 
--Ra
--R
--R
--RExamples of map! from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rmap!(x+->x+10,a) 
--Ra
--R
--R
--RExamples of map! from Heap
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--Rmap!(x+->x+10,a) 
--Ra
--R
--R
--RExamples of map! from HomogeneousAggregate
--R
--R
--RExamples of map! from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rmap!(x+->x+10,a) 
--Ra
--R
--R
--RExamples of map! from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rmap!(x+->x+10,a) 
--Ra
--R
--E 52

--S 53 of 127
)d op setleaves!
--R 
--R
--RThere is one exposed function called setleaves! :
--R   [1] (BalancedBinaryTree D2,List D2) -> BalancedBinaryTree D2
--R            from BalancedBinaryTree D2 if D2 has SETCAT
--R
--RExamples of setleaves! from BalancedBinaryTree
--R
--Rt1:=balancedBinaryTree(4, 0) 
--Rsetleaves!(t1,[1,2,3,4])
--R
--E 53

--S 54 of 127
)d op scan
--R 
--R
--RThere are 8 exposed functions called scan :
--R   [1] (((D5,D4) -> D4),OneDimensionalArray D5,D4) -> 
--R            OneDimensionalArray D4
--R            from OneDimensionalArrayFunctions2(D5,D4)
--R            if D5 has TYPE and D4 has TYPE
--R   [2] (((D6,D4) -> D4),DirectProduct(D5,D6),D4) -> DirectProduct(D5,D4
--R            )
--R            from DirectProductFunctions2(D5,D6,D4)
--R            if D5: NNI and D6 has TYPE and D4 has TYPE
--R   [3] (((D5,D4) -> D4),D3,D4) -> D1
--R            from FiniteLinearAggregateFunctions2(D5,D3,D4,D1)
--R            if D5 has TYPE and D4 has TYPE and D1 has FLAGG D4 and D3 
--R            has FLAGG D5
--R   [4] (((D5,D4) -> D4),D3,D4) -> D1
--R            from FiniteSetAggregateFunctions2(D5,D3,D4,D1)
--R            if D5 has SETCAT and D4 has SETCAT and D1 has FSAGG D4 and 
--R            D3 has FSAGG D5
--R   [5] (((D5,D4) -> D4),List D5,D4) -> List D4 from ListFunctions2(D5,
--R            D4)
--R            if D5 has TYPE and D4 has TYPE
--R   [6] (((D5,D4) -> D4),PrimitiveArray D5,D4) -> PrimitiveArray D4
--R            from PrimitiveArrayFunctions2(D5,D4)
--R            if D5 has TYPE and D4 has TYPE
--R   [7] (D2,((D5,D2) -> D2),Stream D5) -> Stream D2
--R            from StreamFunctions2(D5,D2) if D5 has TYPE and D2 has TYPE
--R            
--R   [8] (((D5,D4) -> D4),Vector D5,D4) -> Vector D4
--R            from VectorFunctions2(D5,D4) if D5 has TYPE and D4 has TYPE
--R            
--R
--RExamples of scan from OneDimensionalArrayFunctions2
--R
--RT1:=OneDimensionalArrayFunctions2(Integer,Integer) 
--Radder(a:Integer,b:Integer):Integer == a+b 
--Rscan(adder,[i for i in 1..10],0)$T1
--R
--R
--RExamples of scan from DirectProductFunctions2
--R
--R
--RExamples of scan from FiniteLinearAggregateFunctions2
--R
--R
--RExamples of scan from FiniteSetAggregateFunctions2
--R
--R
--RExamples of scan from ListFunctions2
--R
--R
--RExamples of scan from PrimitiveArrayFunctions2
--R
--RT1:=PrimitiveArrayFunctions2(Integer,Integer) 
--Radder(a:Integer,b:Integer):Integer == a+b 
--Rscan(adder,[i for i in 1..10],0)$T1
--R
--R
--RExamples of scan from StreamFunctions2
--R
--Rm:=[i for i in 1..]::Stream(Integer) 
--Rf(i:Integer,j:Integer):Integer==i+j 
--Rscan(1,f,m)
--R
--R
--RExamples of scan from VectorFunctions2
--R
--E 54

--S 55 of 127
)d op alphabetic?
--R 
--R
--RThere is one exposed function called alphabetic? :
--R   [1] Character -> Boolean from Character
--R
--RExamples of alphabetic? from Character
--R
--Rchars := [char "a", char "A", char "X", char "8", char "+"] 
--R[alphabetic? c for c in chars]
--R
--E 55

--S 56 of 127
)d op +
--R 
--R
--RThere are 15 exposed functions called + :
--R   [1] (D,D) -> D from D if D has ABELSG
--R   [2] (Color,Color) -> Color from Color
--R   [3] (Database D1,Database D1) -> Database D1 from Database D1
--R            if D1 has OrderedSet with 
--R               ?.? : (%,Symbol) -> String
--R               display : % -> Void
--R               fullDisplay : % -> Void
--R   [4] (Equation D1,D1) -> Equation D1 from Equation D1
--R            if D1 has ABELSG and D1 has TYPE
--R   [5] (D1,Equation D1) -> Equation D1 from Equation D1
--R            if D1 has ABELSG and D1 has TYPE
--R   [6] (D1,D) -> D from D
--R            if D has FAMONC(D1,D2) and D1 has SETCAT and D2 has CABMON
--R            
--R   [7] (D1,FullPartialFractionExpansion(D2,D1)) -> 
--R            FullPartialFractionExpansion(D2,D1)
--R            from FullPartialFractionExpansion(D2,D1)
--R            if D2 has Join(Field,CharacteristicZero) and D1 has UPOLYC 
--R            D2
--R   [8] (D,D) -> D from D
--R            if D has GRMOD(D1,D2) and D1 has COMRING and D2 has ABELMON
--R            
--R   [9] (PolynomialIdeals(D1,D2,D3,D4),PolynomialIdeals(D1,D2,D3,D4))
--R             -> PolynomialIdeals(D1,D2,D3,D4)
--R            from PolynomialIdeals(D1,D2,D3,D4)
--R            if D1 has FIELD and D2 has OAMONS and D3 has ORDSET and D4 
--R            has POLYCAT(D1,D2,D3)
--R   [10] ((D2 -> D3),(D2 -> D3)) -> (D2 -> D3) from MappingPackage4(D2,
--R            D3)
--R            if D2 has SETCAT and D3 has RING
--R   [11] (D,D) -> D from D
--R            if D has MATCAT(D1,D2,D3) and D1 has RING and D2 has FLAGG 
--R            D1 and D3 has FLAGG D1
--R   [12] (D,Divisor D) -> Divisor D from D
--R            if D has PLACESC(D2,D3) and D2 has FIELD and D3 has LOCPOWC
--R            D2
--R   [13] (Divisor D,D) -> Divisor D from D
--R            if D has PLACESC(D2,D3) and D2 has FIELD and D3 has LOCPOWC
--R            D2
--R   [14] (D,D) -> Divisor D from D
--R            if D2 has FIELD and D3 has LOCPOWC D2 and D has PLACESC(D2,
--R            D3)
--R   [15] (D,D) -> D from D
--R            if D has VECTCAT D1 and D1 has TYPE and D1 has ABELSG
--R
--RThere are 5 unexposed functions called + :
--R   [1] (InputForm,InputForm) -> InputForm from InputForm
--R   [2] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R   [3] (Pattern D1,Pattern D1) -> Pattern D1 from Pattern D1 if D1 has 
--R            SETCAT
--R   [4] (Stream D2,Stream D2) -> Stream D2 from 
--R            StreamTaylorSeriesOperations D2
--R            if D2 has RING
--R   [5] (Point DoubleFloat,Point DoubleFloat) -> Point DoubleFloat
--R            from TubePlotTools
--R
--RExamples of + from AbelianSemiGroup
--R
--R
--RExamples of + from Color
--R
--R
--RExamples of + from Database
--R
--R
--RExamples of + from Equation
--R
--R
--RExamples of + from FreeAbelianMonoidCategory
--R
--R
--RExamples of + from FullPartialFractionExpansion
--R
--R
--RExamples of + from GradedModule
--R
--R
--RExamples of + from PolynomialIdeals
--R
--R
--RExamples of + from InputForm
--R
--R
--RExamples of + from MappingPackage4
--R
--Rf:=(x:INT):INT +-> 3*x 
--Rg:=(x:INT):INT +-> 2*x+3 
--R(f+g)(4)
--R
--R
--RExamples of + from MatrixCategory
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--Rm+m
--R
--R
--RExamples of + from OutputForm
--R
--R
--RExamples of + from Pattern
--R
--R
--RExamples of + from PlacesCategory
--R
--R
--RExamples of + from StreamTaylorSeriesOperations
--R
--R
--RExamples of + from TubePlotTools
--R
--R
--RExamples of + from VectorCategory
--R
--E 56

--S 57 of 127
)d op -
--R 
--R
--RThere are 17 exposed functions called - :
--R   [1] (D,D) -> D from D if D has ABELGRP
--R   [2] D -> D from D if D has ABELGRP
--R   [3] (CardinalNumber,CardinalNumber) -> Union(CardinalNumber,"failed"
--R            )
--R            from CardinalNumber
--R   [4] (Database D1,Database D1) -> Database D1 from Database D1
--R            if D1 has OrderedSet with 
--R               ?.? : (%,Symbol) -> String
--R               display : % -> Void
--R               fullDisplay : % -> Void
--R   [5] (Equation D1,D1) -> Equation D1 from Equation D1
--R            if D1 has ABELGRP and D1 has TYPE
--R   [6] (D1,Equation D1) -> Equation D1 from Equation D1
--R            if D1 has ABELGRP and D1 has TYPE
--R   [7] (D,D) -> D from D
--R            if D has GRMOD(D1,D2) and D1 has COMRING and D2 has ABELMON
--R            
--R   [8] D -> D from D
--R            if D has GRMOD(D1,D2) and D1 has COMRING and D2 has ABELMON
--R            
--R   [9] ((D2 -> D3),(D2 -> D3)) -> (D2 -> D3) from MappingPackage4(D2,D3
--R            )
--R            if D2 has SETCAT and D3 has RING
--R   [10] D -> D from D
--R            if D has MATCAT(D1,D2,D3) and D1 has RING and D2 has FLAGG 
--R            D1 and D3 has FLAGG D1
--R   [11] (D,D) -> D from D
--R            if D has MATCAT(D1,D2,D3) and D1 has RING and D2 has FLAGG 
--R            D1 and D3 has FLAGG D1
--R   [12] D -> Divisor D from D
--R            if D2 has FIELD and D3 has LOCPOWC D2 and D has PLACESC(D2,
--R            D3)
--R   [13] (D,Divisor D) -> Divisor D from D
--R            if D has PLACESC(D2,D3) and D2 has FIELD and D3 has LOCPOWC
--R            D2
--R   [14] (Divisor D,D) -> Divisor D from D
--R            if D has PLACESC(D2,D3) and D2 has FIELD and D3 has LOCPOWC
--R            D2
--R   [15] (D,D) -> Divisor D from D
--R            if D2 has FIELD and D3 has LOCPOWC D2 and D has PLACESC(D2,
--R            D3)
--R   [16] (D,D) -> D from D
--R            if D has VECTCAT D1 and D1 has TYPE and D1 has ABELGRP
--R   [17] D -> D from D if D has VECTCAT D1 and D1 has TYPE and D1 has 
--R            ABELGRP
--R
--RThere are 5 unexposed functions called - :
--R   [1] OutputForm -> OutputForm from OutputForm
--R   [2] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R   [3] (Stream D2,Stream D2) -> Stream D2 from 
--R            StreamTaylorSeriesOperations D2
--R            if D2 has RING
--R   [4] Stream D2 -> Stream D2 from StreamTaylorSeriesOperations D2
--R            if D2 has RING
--R   [5] (Point DoubleFloat,Point DoubleFloat) -> Point DoubleFloat
--R            from TubePlotTools
--R
--RExamples of - from AbelianGroup
--R
--R
--RExamples of - from CardinalNumber
--R
--Rc2:=2::CardinalNumber 
--Rc2-c2 
--RA1:=Aleph 1 
--RA1-c2
--R
--R
--RExamples of - from Database
--R
--R
--RExamples of - from Equation
--R
--R
--RExamples of - from GradedModule
--R
--R
--RExamples of - from MappingPackage4
--R
--Rf:=(x:INT):INT +-> 3*x 
--Rg:=(x:INT):INT +-> 2*x+3 
--R(f-g)(4)
--R
--R
--RExamples of - from MatrixCategory
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--R-m
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--Rm-m
--R
--R
--RExamples of - from OutputForm
--R
--R
--RExamples of - from PlacesCategory
--R
--R
--RExamples of - from StreamTaylorSeriesOperations
--R
--R
--RExamples of - from TubePlotTools
--R
--R
--RExamples of - from VectorCategory
--R
--E 57

--S 58 of 127
)d op /
--R 
--R
--RThere are 14 exposed functions called / :
--R   [1] (D,D1) -> D from D
--R            if D has AMR(D1,D2) and D1 has RING and D2 has OAMON and D1
--R            has FIELD
--R   [2] (DoubleFloat,Integer) -> DoubleFloat from DoubleFloat
--R   [3] (D,D) -> D from D
--R            if D = EQ D1 and D1 has FIELD and D1 has TYPE or D = EQ D1 
--R            and D1 has GROUP and D1 has TYPE
--R   [4] (D,D) -> D from D if D has FIELD
--R   [5] (Float,Integer) -> Float from Float
--R   [6] (SparseMultivariatePolynomial(D2,Kernel D),
--R            SparseMultivariatePolynomial(D2,Kernel D)) -> D
--R            from D if D2 has INTDOM and D2 has ORDSET and D has FS D2
--R         
--R   [7] (D,D) -> D from D if D has GROUP
--R   [8] (D,D1) -> D from D
--R            if D has LIECAT D1 and D1 has COMRING and D1 has FIELD
--R   [9] ((D2 -> Expression Integer),(D2 -> Expression Integer)) -> (D2
--R             -> Expression Integer)
--R            from MappingPackage4(D2,D3) if D2 has SETCAT and D3 has 
--R            RING
--R   [10] (D,D1) -> D from D
--R            if D has MATCAT(D1,D2,D3) and D1 has RING and D2 has FLAGG 
--R            D1 and D3 has FLAGG D1 and D1 has FIELD
--R   [11] (MyExpression(D1,D2),MyExpression(D1,D2)) -> MyExpression(D1,D2
--R            )
--R            from MyExpression(D1,D2)
--R            if D1: SYMBOL and D2 has Join(Ring,OrderedSet,
--R            IntegralDomain)
--R   [12] (D1,D1) -> D from D if D has QFCAT D1 and D1 has INTDOM
--R   [13] (D,D1) -> D from D
--R            if D has RMATCAT(D2,D3,D1,D4,D5) and D1 has RING and D4 has
--R            DIRPCAT(D3,D1) and D5 has DIRPCAT(D2,D1) and D1 has FIELD
--R         
--R   [14] (D,D1) -> D from D if D has VSPACE D1 and D1 has FIELD
--R
--RThere are 12 unexposed functions called / :
--R   [1] (Vector D2,Vector D2) -> Vector D2
--R            from InnerNormalBasisFieldFunctions D2 if D2 has FFIELDC
--R         
--R   [2] (InputForm,InputForm) -> InputForm from InputForm
--R   [3] (D1,D2) -> LocalAlgebra(D1,D3,D2) from LocalAlgebra(D1,D3,D2)
--R            if D3 has COMRING and D1 has ALGEBRA D3 and D2 has 
--R            SubsetCategory(Monoid,D3)
--R   [4] (LocalAlgebra(D2,D3,D1),D1) -> LocalAlgebra(D2,D3,D1)
--R            from LocalAlgebra(D2,D3,D1)
--R            if D3 has COMRING and D2 has ALGEBRA D3 and D1 has 
--R            SubsetCategory(Monoid,D3)
--R   [5] (D1,D2) -> Localize(D1,D3,D2) from Localize(D1,D3,D2)
--R            if D3 has COMRING and D1 has MODULE D3 and D2 has 
--R            SubsetCategory(Monoid,D3)
--R   [6] (Localize(D2,D3,D1),D1) -> Localize(D2,D3,D1) from Localize(D2,
--R            D3,D1)
--R            if D3 has COMRING and D2 has MODULE D3 and D1 has 
--R            SubsetCategory(Monoid,D3)
--R   [7] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R   [8] (OrdinaryWeightedPolynomials(D1,D2,D3,D4),
--R            OrdinaryWeightedPolynomials(D1,D2,D3,D4)) -> Union(
--R            OrdinaryWeightedPolynomials(D1,D2,D3,D4),"failed")
--R            from OrdinaryWeightedPolynomials(D1,D2,D3,D4)
--R            if D1 has FIELD and D1 has RING and D2: LIST SYMBOL and D3
--R            : LIST NNI and D4: NNI
--R   [9] (Pattern D1,Pattern D1) -> Pattern D1 from Pattern D1 if D1 has 
--R            SETCAT
--R   [10] (Stream D2,Stream D2) -> Stream D2 from 
--R            StreamTaylorSeriesOperations D2
--R            if D2 has RING
--R   [11] (WeightedPolynomials(D1,D2,D3,D4,D5,D6,D7),WeightedPolynomials(
--R            D1,D2,D3,D4,D5,D6,D7)) -> Union(WeightedPolynomials(D1,D2,D3,D4,
--R            D5,D6,D7),"failed")
--R            from WeightedPolynomials(D1,D2,D3,D4,D5,D6,D7)
--R            if D1 has FIELD and D1 has RING and D2 has ORDSET and D3 
--R            has OAMONS and D5: LIST D2 and D4 has POLYCAT(D1,D3,D2) and
--R            D6: LIST NNI and D7: NNI
--R   [12] (XPolynomialRing(D1,D2),D1) -> XPolynomialRing(D1,D2)
--R            from XPolynomialRing(D1,D2)
--R            if D1 has FIELD and D1 has RING and D2 has ORDMON
--R
--RExamples of / from AbelianMonoidRing
--R
--R
--RExamples of / from DoubleFloat
--R
--R
--RExamples of / from Equation
--R
--R
--RExamples of / from Field
--R
--R
--RExamples of / from Float
--R
--R
--RExamples of / from FunctionSpace
--R
--R
--RExamples of / from Group
--R
--R
--RExamples of / from InnerNormalBasisFieldFunctions
--R
--R
--RExamples of / from InputForm
--R
--R
--RExamples of / from LocalAlgebra
--R
--R
--RExamples of / from LieAlgebra
--R
--R
--RExamples of / from Localize
--R
--R
--RExamples of / from MappingPackage4
--R
--Rp:=(x:EXPR(INT)):EXPR(INT)+->3*x 
--Rq:=(x:EXPR(INT)):EXPR(INT)+->2*x+3 
--R(p/q)(4) 
--R(p/q)(x)
--R
--R
--RExamples of / from MatrixCategory
--R
--Rm:=matrix [[2**i for i in 2..4] for j in 1..5] 
--Rm/4
--R
--R
--RExamples of / from MyExpression
--R
--R
--RExamples of / from OutputForm
--R
--R
--RExamples of / from OrdinaryWeightedPolynomials
--R
--R
--RExamples of / from Pattern
--R
--R
--RExamples of / from QuotientFieldCategory
--R
--R
--RExamples of / from RectangularMatrixCategory
--R
--R
--RExamples of / from StreamTaylorSeriesOperations
--R
--R
--RExamples of / from VectorSpace
--R
--R
--RExamples of / from WeightedPolynomials
--R
--R
--RExamples of / from XPolynomialRing
--R
--E 58

--S 59 of 127
)d op integralBasis
--R 
--R
--RThere is one exposed function called integralBasis :
--R   [1]  -> Vector D from D
--R            if D2 has UFD and D3 has UPOLYC D2 and D4 has UPOLYC FRAC 
--R            D3 and D has FFCAT(D2,D3,D4)
--R
--RThere are 4 unexposed functions called integralBasis :
--R   [1]  -> Record(basis: Matrix D2,basisDen: D2,basisInv: Matrix D2)
--R            from FunctionFieldIntegralBasis(D2,D3,D4)
--R            if D2 has EuclideanDomain with 
--R               squareFree : % -> Factored %and D3 has UPOLYC D2 and
--R            D4 has FRAMALG(D2,D3)
--R   [2]  -> Record(basis: Matrix Integer,basisDen: Integer,basisInv: 
--R            Matrix Integer)
--R            from NumberFieldIntegralBasis(D2,D3)
--R            if D2 has UPOLYC INT and D3 has FRAMALG(INT,D2)
--R   [3]  -> Record(basis: Matrix D3,basisDen: D3,basisInv: Matrix D3)
--R            from PAdicWildFunctionFieldIntegralBasis(D2,D3,D4,D5)
--R            if D2 has FFIELDC and D3 has UPOLYC D2 and D4 has UPOLYC D3
--R            and D5 has MONOGEN(D3,D4)
--R   [4]  -> Record(basis: Matrix D3,basisDen: D3,basisInv: Matrix D3)
--R            from WildFunctionFieldIntegralBasis(D2,D3,D4,D5)
--R            if D2 has FFIELDC and D3 has UPOLYC D2 and D4 has UPOLYC D3
--R            and D5 has FRAMALG(D3,D4)
--R
--RExamples of integralBasis from FunctionFieldCategory
--R
--RP0 := UnivariatePolynomial(x, Integer) 
--RP1 := UnivariatePolynomial(y, Fraction P0) 
--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
--RintegralBasis()$R
--R
--R
--RExamples of integralBasis from FunctionFieldIntegralBasis
--R
--R
--RExamples of integralBasis from NumberFieldIntegralBasis
--R
--R
--RExamples of integralBasis from PAdicWildFunctionFieldIntegralBasis
--R
--R
--RExamples of integralBasis from WildFunctionFieldIntegralBasis
--R
--E 59

--S 60 of 127
)d op split
--R 
--R
--RThere are 9 exposed functions called split :
--R   [1] D2 -> Factored D2 from AlgFactor D2 if D2 has UPOLYC AN
--R   [2] (D2,BinarySearchTree D2) -> Record(less: BinarySearchTree D2,
--R            greater: BinarySearchTree D2)
--R            from BinarySearchTree D2 if D2 has ORDSET
--R   [3] D -> List D from D if D2 has SETCAT and D has DIVCAT D2
--R   [4] IntegrationResult D3 -> IntegrationResult D3
--R            from IntegrationResultToFunction(D2,D3)
--R            if D3 has Join(AlgebraicallyClosedFunctionSpace D2,
--R            TranscendentalFunctionCategory) and D2 has Join(GcdDomain,
--R            RetractableTo Integer,OrderedSet,LinearlyExplicitRingOver 
--R            Integer)
--R   [5] IntegrationResult Fraction Polynomial D2 -> IntegrationResult 
--R            Fraction Polynomial D2
--R            from IntegrationResultRFToFunction D2
--R            if D2 has Join(GcdDomain,RetractableTo Integer,OrderedSet,
--R            LinearlyExplicitRingOver Integer)
--R   [6] (List Matrix D4,Vector D4) -> List List Matrix D4
--R            from RepresentationPackage2 D4 if D4 has FIELD and D4 has 
--R            RING
--R   [7] (List Matrix D4,Vector Vector D4) -> List List Matrix D4
--R            from RepresentationPackage2 D4 if D4 has FIELD and D4 has 
--R            RING
--R   [8] (D,CharacterClass) -> List D from D if D has SRAGG
--R   [9] (D,Character) -> List D from D if D has SRAGG
--R
--RThere is one unexposed function called split :
--R   [1] (D2,(D2 -> D2)) -> Record(normal: D2,special: D2)
--R            from MonomialExtensionTools(D4,D2)
--R            if D2 has UPOLYC D4 and D4 has FIELD
--R
--RExamples of split from AlgFactor
--R
--R
--RExamples of split from BinarySearchTree
--R
--Rt1:=binarySearchTree [1,2,3,4] 
--Rsplit(3,t1)
--R
--R
--RExamples of split from DivisorCategory
--R
--R
--RExamples of split from IntegrationResultToFunction
--R
--R
--RExamples of split from IntegrationResultRFToFunction
--R
--R
--RExamples of split from MonomialExtensionTools
--R
--R
--RExamples of split from RepresentationPackage2
--R
--R
--RExamples of split from StringAggregate
--R
--E 60

--S 61 of 127
)d op qelt
--R 
--R
--RThere are 3 exposed functions called qelt :
--R   [1] (D,Integer,Integer) -> D1 from D
--R            if D has ARR2CAT(D1,D3,D4) and D3 has FLAGG D1 and D4 has 
--R            FLAGG D1 and D1 has TYPE
--R   [2] (D,D2) -> D1 from D
--R            if D has ELTAGG(D2,D1) and D2 has SETCAT and D1 has TYPE
--R         
--R   [3] (D,Integer,Integer) -> D1 from D
--R            if D has RMATCAT(D3,D4,D1,D5,D6) and D5 has DIRPCAT(D4,D1) 
--R            and D6 has DIRPCAT(D3,D1) and D1 has RING
--R
--RExamples of qelt from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,10) 
--Rqelt(arr,1,1)
--R
--R
--RExamples of qelt from EltableAggregate
--R
--R
--RExamples of qelt from RectangularMatrixCategory
--R
--E 61

--S 62 of 127
)d op mapUp!
--R 
--R
--RThere are 2 exposed functions called mapUp! :
--R   [1] (BalancedBinaryTree D2,BalancedBinaryTree D2,((D2,D2,D2,D2) -> 
--R            D2)) -> BalancedBinaryTree D2
--R            from BalancedBinaryTree D2 if D2 has SETCAT
--R   [2] (BalancedBinaryTree D1,((D1,D1) -> D1)) -> D1
--R            from BalancedBinaryTree D1 if D1 has SETCAT
--R
--RExamples of mapUp! from BalancedBinaryTree
--R
--RT1:=BalancedBinaryTree Integer 
--Rt2:=balancedBinaryTree(4, 0)$T1 
--Rsetleaves!(t2,[1,2,3,4]::List(Integer)) 
--Radder4(i:INT,j:INT,k:INT,l:INT):INT == i+j+k+l 
--RmapUp!(t2,t2,adder4) 
--Rt2
--R
--RT1:=BalancedBinaryTree Integer 
--Rt2:=balancedBinaryTree(4, 0)$T1 
--Rsetleaves!(t2,[1,2,3,4]::List(Integer)) 
--Radder(a:Integer,b:Integer):Integer == a+b 
--RmapUp!(t2,adder) 
--Rt2
--R
--E 62

--S 63 of 127
)d op reindex
--R 
--R
--RThere is one exposed function called reindex :
--R   [1] (CartesianTensor(D2,D3,D4),List Integer) -> CartesianTensor(D2,
--R            D3,D4)
--R            from CartesianTensor(D2,D3,D4)
--R            if D2: INT and D3: NNI and D4 has COMRING
--R
--RExamples of reindex from CartesianTensor
--R
--Rn:SquareMatrix(2,Integer):=matrix [[2,3],[0,1]] 
--Rtn:CartesianTensor(1,2,Integer):=n 
--Rp:=product(tn,tn) 
--Rreindex(p,[4,3,2,1])
--R
--E 63

--S 64 of 127
)d op mapDown!
--R 
--R
--RThere are 2 exposed functions called mapDown! :
--R   [1] (BalancedBinaryTree D1,D1,((D1,D1,D1) -> List D1)) -> 
--R            BalancedBinaryTree D1
--R            from BalancedBinaryTree D1 if D1 has SETCAT
--R   [2] (BalancedBinaryTree D1,D1,((D1,D1) -> D1)) -> BalancedBinaryTree
--R            D1
--R            from BalancedBinaryTree D1 if D1 has SETCAT
--R
--RExamples of mapDown! from BalancedBinaryTree
--R
--RT1:=BalancedBinaryTree Integer 
--Rt2:=balancedBinaryTree(4, 0)$T1 
--Rsetleaves!(t2,[1,2,3,4]::List(Integer)) 
--Radder3(i:Integer,j:Integer,k:Integer):List Integer == [i+j,j+k] 
--RmapDown!(t2,4::INT,adder3) 
--Rt2
--R
--RT1:=BalancedBinaryTree Integer 
--Rt2:=balancedBinaryTree(4, 0)$T1 
--Rsetleaves!(t2,[1,2,3,4]::List(Integer)) 
--Radder(i:Integer,j:Integer):Integer == i+j 
--RmapDown!(t2,4::INT,adder) 
--Rt2
--R
--E 64

--S 65 of 127
)d op nrows
--R 
--R
--RThere are 2 exposed functions called nrows :
--R   [1] D -> NonNegativeInteger from D
--R            if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has FLAGG
--R            D2 and D4 has FLAGG D2
--R   [2] D -> NonNegativeInteger from D
--R            if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5 has
--R            DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4)
--R
--RExamples of nrows from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,10) 
--Rnrows(arr)
--R
--R
--RExamples of nrows from RectangularMatrixCategory
--R
--E 65

--S 66 of 127
)d op row
--R 
--R
--RThere are 2 exposed functions called row :
--R   [1] (D,Integer) -> D1 from D
--R            if D has ARR2CAT(D3,D1,D4) and D3 has TYPE and D4 has FLAGG
--R            D3 and D1 has FLAGG D3
--R   [2] (D,Integer) -> D1 from D
--R            if D has RMATCAT(D3,D4,D5,D1,D6) and D5 has RING and D6 has
--R            DIRPCAT(D3,D5) and D1 has DIRPCAT(D4,D5)
--R
--RExamples of row from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,10) 
--Rrow(arr,1)
--R
--R
--RExamples of row from RectangularMatrixCategory
--R
--E 66

--S 67 of 127
)d op ravel
--R 
--R
--RThere is one exposed function called ravel :
--R   [1] CartesianTensor(D2,D3,D4) -> List D4 from CartesianTensor(D2,D3,
--R            D4)
--R            if D2: INT and D3: NNI and D4 has COMRING
--R
--RExamples of ravel from CartesianTensor
--R
--Rn:SquareMatrix(2,Integer):=matrix [[2,3],[0,1]] 
--Rtn:CartesianTensor(1,2,Integer):=n 
--Rravel tn
--R
--E 67

--S 68 of 127
)d op inverseIntegralMatrix
--R 
--R
--RThere is one exposed function called inverseIntegralMatrix :
--R   [1]  -> Matrix Fraction D3 from D
--R            if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC 
--R            D2 and D4 has UPOLYC FRAC D3
--R
--RExamples of inverseIntegralMatrix from FunctionFieldCategory
--R
--RP0 := UnivariatePolynomial(x, Integer) 
--RP1 := UnivariatePolynomial(y, Fraction P0) 
--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
--RinverseIntegralMatrix()$R
--R
--E 68

--S 69 of 127
)d op coerce
--R 
--R
--RThere are 194 exposed functions called coerce :
--R   [1] List D2 -> D from D if D2 has FIELD and D has AFSPCAT D2
--R   [2] D -> List D2 from D if D has AFSPCAT D2 and D2 has FIELD
--R   [3] D1 -> D from D if D has ALGEBRA D1 and D1 has COMRING
--R   [4] Vector D2 -> AlgebraGivenByStructuralConstants(D2,D3,D4,D5)
--R            from AlgebraGivenByStructuralConstants(D2,D3,D4,D5)
--R            if D2 has FIELD and D5: VECTOR MATRIX D2 and D3: PI and D4
--R            : LIST SYMBOL
--R   [5] SparseMultivariatePolynomial(Integer,Kernel AlgebraicNumber) -> 
--R            AlgebraicNumber
--R            from AlgebraicNumber
--R   [6] D2 -> Any from AnyFunctions1 D2 if D2 has TYPE
--R   [7] Vector FortranExpression([construct,QUOTEJINT,QUOTEX,QUOTEELAM],
--R            [construct],MachineFloat) -> Asp10 D2
--R            from Asp10 D2 if D2: SYMBOL
--R   [8] Vector FortranExpression([construct],[construct,QUOTEXC],
--R            MachineFloat) -> Asp19 D2
--R            from Asp19 D2 if D2: SYMBOL
--R   [9] FortranExpression([construct,QUOTEX],[construct],MachineFloat)
--R             -> Asp1 D2
--R            from Asp1 D2 if D2: SYMBOL
--R   [10] Matrix FortranExpression([construct],[construct,QUOTEX,QUOTE
--R            HESS],MachineFloat) -> Asp20 D2
--R            from Asp20 D2 if D2: SYMBOL
--R   [11] FortranExpression([construct],[construct,QUOTEXC],MachineFloat)
--R             -> Asp24 D2
--R            from Asp24 D2 if D2: SYMBOL
--R   [12] Vector FortranExpression([construct,QUOTEX],[construct,QUOTEY],
--R            MachineFloat) -> Asp31 D2
--R            from Asp31 D2 if D2: SYMBOL
--R   [13] Vector FortranExpression([construct],[construct,QUOTEX],
--R            MachineFloat) -> Asp35 D2
--R            from Asp35 D2 if D2: SYMBOL
--R   [14] Vector FortranExpression([construct,QUOTEX,QUOTEEPS],[construct
--R            ,QUOTEY],MachineFloat) -> Asp41(D2,D3,D4)
--R            from Asp41(D2,D3,D4) if D2: SYMBOL and D3: SYMBOL and D4: 
--R            SYMBOL
--R   [15] Vector FortranExpression([construct,QUOTEEPS],[construct,QUOTE
--R            YA,QUOTEYB],MachineFloat) -> Asp42(D2,D3,D4)
--R            from Asp42(D2,D3,D4) if D2: SYMBOL and D3: SYMBOL and D4: 
--R            SYMBOL
--R   [16] FortranExpression([construct],[construct,QUOTEX],MachineFloat)
--R             -> Asp49 D2
--R            from Asp49 D2 if D2: SYMBOL
--R   [17] FortranExpression([construct],[construct,QUOTEX],MachineFloat)
--R             -> Asp4 D2
--R            from Asp4 D2 if D2: SYMBOL
--R   [18] Vector FortranExpression([construct],[construct,QUOTEXC],
--R            MachineFloat) -> Asp50 D2
--R            from Asp50 D2 if D2: SYMBOL
--R   [19] Vector FortranExpression([construct],[construct,QUOTEX],
--R            MachineFloat) -> Asp55 D2
--R            from Asp55 D2 if D2: SYMBOL
--R   [20] Vector FortranExpression([construct],[construct,QUOTEX],
--R            MachineFloat) -> Asp6 D2
--R            from Asp6 D2 if D2: SYMBOL
--R   [21] Vector FortranExpression([construct,QUOTEX,QUOTEY],[construct],
--R            MachineFloat) -> Asp73 D2
--R            from Asp73 D2 if D2: SYMBOL
--R   [22] Matrix FortranExpression([construct,QUOTEX,QUOTEY],[construct],
--R            MachineFloat) -> Asp74 D2
--R            from Asp74 D2 if D2: SYMBOL
--R   [23] Matrix FortranExpression([construct,QUOTEX],[construct],
--R            MachineFloat) -> Asp77 D2
--R            from Asp77 D2 if D2: SYMBOL
--R   [24] Vector FortranExpression([construct,QUOTEX],[construct],
--R            MachineFloat) -> Asp78 D2
--R            from Asp78 D2 if D2: SYMBOL
--R   [25] Vector FortranExpression([construct,QUOTEX],[construct,QUOTEY],
--R            MachineFloat) -> Asp7 D2
--R            from Asp7 D2 if D2: SYMBOL
--R   [26] Matrix FortranExpression([construct,QUOTEXL,QUOTEXR,QUOTEELAM],
--R            [construct],MachineFloat) -> Asp80 D2
--R            from Asp80 D2 if D2: SYMBOL
--R   [27] FortranExpression([construct,QUOTEX],[construct,QUOTEY],
--R            MachineFloat) -> Asp9 D2
--R            from Asp9 D2 if D2: SYMBOL
--R   [28] ArrayStack D2 -> OutputForm from ArrayStack D2
--R            if D2 has SETCAT and D2 has SETCAT
--R   [29] BinaryExpansion -> RadixExpansion 2 from BinaryExpansion
--R   [30] BinaryExpansion -> Fraction Integer from BinaryExpansion
--R   [31] List Integer -> D from D if D has BLMETCT
--R   [32] List CartesianTensor(D2,D3,D4) -> CartesianTensor(D2,D3,D4)
--R            from CartesianTensor(D2,D3,D4)
--R            if D2: INT and D3: NNI and D4 has COMRING
--R   [33] List D4 -> CartesianTensor(D2,D3,D4) from CartesianTensor(D2,D3
--R            ,D4)
--R            if D4 has COMRING and D2: INT and D3: NNI
--R   [34] SquareMatrix(D3,D4) -> CartesianTensor(D2,D3,D4)
--R            from CartesianTensor(D2,D3,D4)
--R            if D3: NNI and D4 has COMRING and D2: INT
--R   [35] DirectProduct(D3,D4) -> CartesianTensor(D2,D3,D4)
--R            from CartesianTensor(D2,D3,D4)
--R            if D3: NNI and D4 has COMRING and D2: INT
--R   [36] List D2 -> Database D2 from Database D2
--R            if D2 has OrderedSet with 
--R               ?.? : (%,Symbol) -> String
--R               display : % -> Void
--R               fullDisplay : % -> Void
--R   [37] DecimalExpansion -> RadixExpansion 10 from DecimalExpansion
--R   [38] DecimalExpansion -> Fraction Integer from DecimalExpansion
--R   [39] Dequeue D2 -> OutputForm from Dequeue D2
--R            if D2 has SETCAT and D2 has SETCAT
--R   [40] DirichletRing D2 -> Stream D2 from DirichletRing D2 if D2 has 
--R            RING
--R   [41] Stream D2 -> DirichletRing D2 from DirichletRing D2 if D2 has 
--R            RING
--R   [42] DirichletRing D2 -> (PositiveInteger -> D2) from DirichletRing 
--R            D2
--R            if D2 has RING
--R   [43] (PositiveInteger -> D2) -> DirichletRing D2 from DirichletRing 
--R            D2
--R            if D2 has RING
--R   [44] DataList D2 -> List D2 from DataList D2 if D2 has ORDSET
--R   [45] List D2 -> DataList D2 from DataList D2 if D2 has ORDSET
--R   [46] SegmentBinding Expression D3 -> SegmentBinding Float
--R            from DrawNumericHack D3
--R            if D3 has Join(OrderedSet,IntegralDomain,ConvertibleTo 
--R            Float)
--R   [47] D1 -> D from D if D has DVARCAT D1 and D1 has ORDSET
--R   [48] FortranCode -> OutputForm from FortranCode
--R   [49] FortranExpression(D2,D3,D4) -> Expression D4
--R            from FortranExpression(D2,D3,D4)
--R            if D2: LIST SYMBOL and D3: LIST SYMBOL and D4 has FMTC
--R   [50] D2 -> D1 from FiniteFieldHomomorphisms(D2,D3,D1)
--R            if D3 has FFIELDC and D1 has FAXF D3 and D2 has FAXF D3
--R   [51] D2 -> D1 from FiniteFieldHomomorphisms(D1,D3,D2)
--R            if D3 has FFIELDC and D1 has FAXF D3 and D2 has FAXF D3
--R   [52] D -> XRecursivePolynomial(D2,D3) from D
--R            if D has FLALG(D2,D3) and D2 has ORDSET and D3 has COMRING
--R            
--R   [53] D -> XDistributedPolynomial(D2,D3) from D
--R            if D has FLALG(D2,D3) and D2 has ORDSET and D3 has COMRING
--R            
--R   [54] D1 -> D from D
--R            if D has FLALG(D1,D2) and D1 has ORDSET and D2 has COMRING
--R            
--R   [55] Record(localSymbols: SymbolTable,code: List FortranCode) -> D 
--R            from D
--R            if D has FMC
--R   [56] FortranCode -> D from D if D has FMC
--R   [57] List FortranCode -> D from D if D has FMC
--R   [58] Matrix MachineFloat -> D from D if D has FMC
--R   [59] Record(localSymbols: SymbolTable,code: List FortranCode) -> D 
--R            from D
--R            if D has FMFUN
--R   [60] FortranCode -> D from D if D has FMFUN
--R   [61] List FortranCode -> D from D if D has FMFUN
--R   [62] D -> String from D if D has FNCAT
--R   [63] String -> D from D if D has FNCAT
--R   [64] D2 -> ScriptFormulaFormat from ScriptFormulaFormat1 D2 if D2 
--R            has SETCAT
--R   [65] OutputForm -> ScriptFormulaFormat from ScriptFormulaFormat
--R   [66] Record(localSymbols: SymbolTable,code: List FortranCode) -> D 
--R            from D
--R            if D has FORTFN
--R   [67] FortranCode -> D from D if D has FORTFN
--R   [68] List FortranCode -> D from D if D has FORTFN
--R   [69] Equation Expression Complex Float -> FortranProgram(D2,D3,D4,D5
--R            )
--R            from FortranProgram(D2,D3,D4,D5)
--R            if D2: SYMBOL and D3: Union(fst: FortranScalarType,void: 
--R            void) and D4: LIST SYMBOL and D5: SYMTAB
--R   [70] Equation Expression Float -> FortranProgram(D2,D3,D4,D5)
--R            from FortranProgram(D2,D3,D4,D5)
--R            if D2: SYMBOL and D3: Union(fst: FortranScalarType,void: 
--R            void) and D4: LIST SYMBOL and D5: SYMTAB
--R   [71] Equation Expression Integer -> FortranProgram(D2,D3,D4,D5)
--R            from FortranProgram(D2,D3,D4,D5)
--R            if D2: SYMBOL and D3: Union(fst: FortranScalarType,void: 
--R            void) and D4: LIST SYMBOL and D5: SYMTAB
--R   [72] Expression Complex Float -> FortranProgram(D2,D3,D4,D5)
--R            from FortranProgram(D2,D3,D4,D5)
--R            if D2: SYMBOL and D3: Union(fst: FortranScalarType,void: 
--R            void) and D4: LIST SYMBOL and D5: SYMTAB
--R   [73] Expression Float -> FortranProgram(D2,D3,D4,D5)
--R            from FortranProgram(D2,D3,D4,D5)
--R            if D2: SYMBOL and D3: Union(fst: FortranScalarType,void: 
--R            void) and D4: LIST SYMBOL and D5: SYMTAB
--R   [74] Expression Integer -> FortranProgram(D2,D3,D4,D5)
--R            from FortranProgram(D2,D3,D4,D5)
--R            if D2: SYMBOL and D3: Union(fst: FortranScalarType,void: 
--R            void) and D4: LIST SYMBOL and D5: SYMTAB
--R   [75] Equation Expression MachineComplex -> FortranProgram(D2,D3,D4,
--R            D5)
--R            from FortranProgram(D2,D3,D4,D5)
--R            if D2: SYMBOL and D3: Union(fst: FortranScalarType,void: 
--R            void) and D4: LIST SYMBOL and D5: SYMTAB
--R   [76] Equation Expression MachineFloat -> FortranProgram(D2,D3,D4,D5)
--R            from FortranProgram(D2,D3,D4,D5)
--R            if D2: SYMBOL and D3: Union(fst: FortranScalarType,void: 
--R            void) and D4: LIST SYMBOL and D5: SYMTAB
--R   [77] Equation Expression MachineInteger -> FortranProgram(D2,D3,D4,
--R            D5)
--R            from FortranProgram(D2,D3,D4,D5)
--R            if D2: SYMBOL and D3: Union(fst: FortranScalarType,void: 
--R            void) and D4: LIST SYMBOL and D5: SYMTAB
--R   [78] Expression MachineComplex -> FortranProgram(D2,D3,D4,D5)
--R            from FortranProgram(D2,D3,D4,D5)
--R            if D2: SYMBOL and D3: Union(fst: FortranScalarType,void: 
--R            void) and D4: LIST SYMBOL and D5: SYMTAB
--R   [79] Expression MachineFloat -> FortranProgram(D2,D3,D4,D5)
--R            from FortranProgram(D2,D3,D4,D5)
--R            if D2: SYMBOL and D3: Union(fst: FortranScalarType,void: 
--R            void) and D4: LIST SYMBOL and D5: SYMTAB
--R   [80] Expression MachineInteger -> FortranProgram(D2,D3,D4,D5)
--R            from FortranProgram(D2,D3,D4,D5)
--R            if D2: SYMBOL and D3: Union(fst: FortranScalarType,void: 
--R            void) and D4: LIST SYMBOL and D5: SYMTAB
--R   [81] Record(localSymbols: SymbolTable,code: List FortranCode) -> 
--R            FortranProgram(D2,D3,D4,D5)
--R            from FortranProgram(D2,D3,D4,D5)
--R            if D2: SYMBOL and D3: Union(fst: FortranScalarType,void: 
--R            void) and D4: LIST SYMBOL and D5: SYMTAB
--R   [82] List FortranCode -> FortranProgram(D2,D3,D4,D5)
--R            from FortranProgram(D2,D3,D4,D5)
--R            if D2: SYMBOL and D3: Union(fst: FortranScalarType,void: 
--R            void) and D4: LIST SYMBOL and D5: SYMTAB
--R   [83] FortranCode -> FortranProgram(D2,D3,D4,D5)
--R            from FortranProgram(D2,D3,D4,D5)
--R            if D2: SYMBOL and D3: Union(fst: FortranScalarType,void: 
--R            void) and D4: LIST SYMBOL and D5: SYMTAB
--R   [84] FourierComponent D3 -> FourierSeries(D2,D3) from FourierSeries(
--R            D2,D3)
--R            if D3 has Join(OrderedSet,AbelianGroup) and D2 has Join(
--R            CommutativeRing,Algebra Fraction Integer)
--R   [85] D1 -> FourierSeries(D1,D2) from FourierSeries(D1,D2)
--R            if D1 has Join(CommutativeRing,Algebra Fraction Integer) 
--R            and D2 has Join(OrderedSet,AbelianGroup)
--R   [86] Fraction Polynomial Fraction D2 -> D from D
--R            if D2 has INTDOM and D2 has ORDSET and D has FS D2
--R   [87] Polynomial Fraction D2 -> D from D
--R            if D2 has INTDOM and D2 has ORDSET and D has FS D2
--R   [88] Fraction D2 -> D from D
--R            if D2 has INTDOM and D2 has ORDSET and D has FS D2
--R   [89] SparseMultivariatePolynomial(D2,Kernel D) -> D from D
--R            if D2 has RING and D2 has ORDSET and D has FS D2
--R   [90] FortranScalarType -> SExpression from FortranScalarType
--R   [91] FortranScalarType -> Symbol from FortranScalarType
--R   [92] Symbol -> FortranScalarType from FortranScalarType
--R   [93] String -> FortranScalarType from FortranScalarType
--R   [94] FortranScalarType -> FortranType from FortranType
--R   [95] FortranType -> OutputForm from FortranType
--R   [96] Record(localSymbols: SymbolTable,code: List FortranCode) -> D 
--R            from D
--R            if D has FVC
--R   [97] FortranCode -> D from D if D has FVC
--R   [98] List FortranCode -> D from D if D has FVC
--R   [99] Vector MachineFloat -> D from D if D has FVC
--R   [100] Record(localSymbols: SymbolTable,code: List FortranCode) -> D 
--R            from D
--R            if D has FVFUN
--R   [101] FortranCode -> D from D if D has FVFUN
--R   [102] List FortranCode -> D from D if D has FVFUN
--R   [103] UnivariatePuiseuxSeries(D2,D3,D4) -> 
--R            GeneralUnivariatePowerSeries(D2,D3,D4)
--R            from GeneralUnivariatePowerSeries(D2,D3,D4)
--R            if D2 has RING and D3: SYMBOL and D4: D2
--R   [104] Variable D3 -> GeneralUnivariatePowerSeries(D2,D3,D4)
--R            from GeneralUnivariatePowerSeries(D2,D3,D4)
--R            if D3: SYMBOL and D2 has RING and D4: D2
--R   [105] Heap D2 -> OutputForm from Heap D2 if D2 has SETCAT and D2 has
--R            ORDSET
--R   [106] HexadecimalExpansion -> RadixExpansion 16 from 
--R            HexadecimalExpansion
--R   [107] HexadecimalExpansion -> Fraction Integer from 
--R            HexadecimalExpansion
--R   [108] OutputForm -> String from HTMLFormat
--R   [109] String -> IndexCard from IndexCard
--R   [110] List D5 -> PolynomialIdeals(D2,D3,D4,D5)
--R            from PolynomialIdeals(D2,D3,D4,D5)
--R            if D5 has POLYCAT(D2,D3,D4) and D2 has FIELD and D3 has 
--R            OAMONS and D4 has ORDSET
--R   [111] D1 -> AssociatedJordanAlgebra(D2,D1)
--R            from AssociatedJordanAlgebra(D2,D1)
--R            if D2 has COMRING and D1 has NAALG D2
--R   [112] D -> D1 from D if D has KOERCE D1 and D1 has TYPE
--R   [113] D1 -> D from D if D has LALG D1 and D1 has RING
--R   [114] D1 -> AssociatedLieAlgebra(D2,D1) from AssociatedLieAlgebra(D2
--R            ,D1)
--R            if D2 has COMRING and D1 has NAALG D2
--R   [115] D -> Stream Record(k: Integer,c: D2) from D
--R            if D has LOCPOWC D2 and D2 has FIELD
--R   [116] Stream Record(k: Integer,c: D2) -> D from D
--R            if D2 has FIELD and D has LOCPOWC D2
--R   [117] ThreeDimensionalMatrix D2 -> PrimitiveArray PrimitiveArray 
--R            PrimitiveArray D2
--R            from ThreeDimensionalMatrix D2 if D2 has SETCAT
--R   [118] PrimitiveArray PrimitiveArray PrimitiveArray D2 -> 
--R            ThreeDimensionalMatrix D2
--R            from ThreeDimensionalMatrix D2 if D2 has SETCAT
--R   [119] D2 -> (() -> D2) from MappingPackage1 D2 if D2 has SETCAT
--R   [120] D1 -> D from D
--R            if D2 has RING and D has MATCAT(D2,D3,D1) and D3 has FLAGG 
--R            D2 and D1 has FLAGG D2
--R   [121] MachineComplex -> Complex Float from MachineComplex
--R   [122] Complex MachineInteger -> MachineComplex from MachineComplex
--R         
--R   [123] Complex MachineFloat -> MachineComplex from MachineComplex
--R   [124] Complex Integer -> MachineComplex from MachineComplex
--R   [125] Complex Float -> MachineComplex from MachineComplex
--R   [126] MachineInteger -> MachineFloat from MachineFloat
--R   [127] MachineFloat -> Float from MachineFloat
--R   [128] Expression Integer -> Expression MachineInteger from 
--R            MachineInteger
--R   [129] OutputForm -> String from MathMLFormat
--R   [130] Fraction MyUnivariatePolynomial(D2,D3) -> MyExpression(D2,D3)
--R            from MyExpression(D2,D3)
--R            if D2: SYMBOL and D3 has Join(Ring,OrderedSet,
--R            IntegralDomain)
--R   [131] Polynomial D3 -> MyUnivariatePolynomial(D2,D3)
--R            from MyUnivariatePolynomial(D2,D3) if D3 has RING and D2: 
--R            SYMBOL
--R   [132] Variable D2 -> MyUnivariatePolynomial(D2,D3)
--R            from MyUnivariatePolynomial(D2,D3) if D2: SYMBOL and D3 has
--R            RING
--R   [133] D1 -> MyUnivariatePolynomial(D2,D1) from 
--R            MyUnivariatePolynomial(D2,D1)
--R            if D2: SYMBOL and D1 has RING
--R   [134] Integer -> D from D if D has NASRING
--R   [135] Union(nia: Record(var: Symbol,fn: Expression DoubleFloat,range
--R            : Segment OrderedCompletion DoubleFloat,abserr: DoubleFloat,
--R            relerr: DoubleFloat),mdnia: Record(fn: Expression DoubleFloat,
--R            range: List Segment OrderedCompletion DoubleFloat,abserr: 
--R            DoubleFloat,relerr: DoubleFloat)) -> NumericalIntegrationProblem
--R            from NumericalIntegrationProblem
--R   [136] Record(fn: Expression DoubleFloat,range: List Segment 
--R            OrderedCompletion DoubleFloat,abserr: DoubleFloat,relerr: 
--R            DoubleFloat) -> NumericalIntegrationProblem
--R            from NumericalIntegrationProblem
--R   [137] Record(var: Symbol,fn: Expression DoubleFloat,range: Segment 
--R            OrderedCompletion DoubleFloat,abserr: DoubleFloat,relerr: 
--R            DoubleFloat) -> NumericalIntegrationProblem
--R            from NumericalIntegrationProblem
--R   [138] NumericalIntegrationProblem -> OutputForm
--R            from NumericalIntegrationProblem
--R   [139] D2 -> None from NoneFunctions1 D2 if D2 has TYPE
--R   [140] Record(xinit: DoubleFloat,xend: DoubleFloat,fn: Vector 
--R            Expression DoubleFloat,yinit: List DoubleFloat,intvals: List 
--R            DoubleFloat,g: Expression DoubleFloat,abserr: DoubleFloat,relerr
--R            : DoubleFloat) -> NumericalODEProblem
--R            from NumericalODEProblem
--R   [141] NumericalODEProblem -> OutputForm from NumericalODEProblem
--R   [142] OrdinaryDifferentialRing(D2,D1,D3) -> D1
--R            from OrdinaryDifferentialRing(D2,D1,D3)
--R            if D1 has PDRING D2 and D2 has SETCAT and D3: D2
--R   [143] D1 -> OrdinaryDifferentialRing(D2,D1,D3)
--R            from OrdinaryDifferentialRing(D2,D1,D3)
--R            if D2 has SETCAT and D3: D2 and D1 has PDRING D2
--R   [144] Symbol -> OpenMathErrorKind from OpenMathErrorKind
--R   [145] Union(noa: Record(fn: Expression DoubleFloat,init: List 
--R            DoubleFloat,lb: List OrderedCompletion DoubleFloat,cf: List 
--R            Expression DoubleFloat,ub: List OrderedCompletion DoubleFloat),
--R            lsa: Record(lfn: List Expression DoubleFloat,init: List 
--R            DoubleFloat)) -> NumericalOptimizationProblem
--R            from NumericalOptimizationProblem
--R   [146] Record(lfn: List Expression DoubleFloat,init: List DoubleFloat
--R            ) -> NumericalOptimizationProblem
--R            from NumericalOptimizationProblem
--R   [147] Record(fn: Expression DoubleFloat,init: List DoubleFloat,lb: 
--R            List OrderedCompletion DoubleFloat,cf: List Expression 
--R            DoubleFloat,ub: List OrderedCompletion DoubleFloat) -> 
--R            NumericalOptimizationProblem
--R            from NumericalOptimizationProblem
--R   [148] NumericalOptimizationProblem -> OutputForm
--R            from NumericalOptimizationProblem
--R   [149] Integer -> OrdSetInts from OrdSetInts
--R   [150] Color -> Palette from Palette
--R   [151] Polynomial AlgebraicNumber -> Expression Integer
--R            from PolynomialAN2Expression
--R   [152] Fraction Polynomial AlgebraicNumber -> Expression Integer
--R            from PolynomialAN2Expression
--R   [153] Record(pde: List Expression DoubleFloat,constraints: List 
--R            Record(start: DoubleFloat,finish: DoubleFloat,grid: 
--R            NonNegativeInteger,boundaryType: Integer,dStart: Matrix 
--R            DoubleFloat,dFinish: Matrix DoubleFloat),f: List List Expression 
--R            DoubleFloat,st: String,tol: DoubleFloat) -> NumericalPDEProblem
--R            from NumericalPDEProblem
--R   [154] NumericalPDEProblem -> OutputForm from NumericalPDEProblem
--R   [155] PendantTree D2 -> Tree D2 from PendantTree D2 if D2 has SETCAT
--R            
--R   [156] List Permutation D2 -> PermutationGroup D2 from 
--R            PermutationGroup D2
--R            if D2 has SETCAT
--R   [157] PermutationGroup D2 -> List Permutation D2 from 
--R            PermutationGroup D2
--R            if D2 has SETCAT
--R   [158] List D2 -> Permutation D2 from Permutation D2 if D2 has SETCAT
--R            
--R   [159] List List D2 -> Permutation D2 from Permutation D2 if D2 has 
--R            SETCAT
--R   [160] Fraction Factored D2 -> PartialFraction D2 from 
--R            PartialFraction D2
--R            if D2 has EUCDOM
--R   [161] PartialFraction D2 -> Fraction D2 from PartialFraction D2
--R            if D2 has EUCDOM
--R   [162] Pi -> Expression D3 from PiCoercions D3
--R            if D3 has Join(OrderedSet,IntegralDomain)
--R   [163] List D2 -> D from D if D2 has FIELD and D has PRSPCAT D2
--R   [164] D -> List D2 from D if D has PRSPCAT D2 and D2 has FIELD
--R   [165] Queue D2 -> OutputForm from Queue D2
--R            if D2 has SETCAT and D2 has SETCAT
--R   [166] RadixExpansion D2 -> Fraction Integer from RadixExpansion D2 
--R            if D2: INT
--R   [167] D2 -> Void from ResolveLatticeCompletion D2 if D2 has TYPE
--R   [168] Exit -> D1 from ResolveLatticeCompletion D1 if D1 has TYPE
--R   [169] D1 -> D from D if D has RETRACT D1 and D1 has TYPE
--R   [170] D2 -> Fraction Polynomial D2 from RationalFunction D2 if D2 
--R            has INTDOM
--R   [171] Integer -> D from D if D has RING
--R   [172] D -> OutputForm from D if D has SPACEC D2 and D2 has RING
--R   [173] Character -> D from D if D has SRAGG
--R   [174] Stack D2 -> OutputForm from Stack D2
--R            if D2 has SETCAT and D2 has SETCAT
--R   [175] List D2 -> Stream D2 from Stream D2 if D2 has TYPE
--R   [176] Symbol -> Switch from Switch
--R   [177] String -> Symbol from Symbol
--R   [178] SymbolTable -> Table(Symbol,FortranType) from SymbolTable
--R   [179] Tableau D2 -> OutputForm from Tableau D2 if D2 has SETCAT
--R   [180] D2 -> TexFormat from TexFormat1 D2 if D2 has SETCAT
--R   [181] OutputForm -> TexFormat from TexFormat
--R   [182] Polynomial D2 -> TaylorSeries D2 from TaylorSeries D2 if D2 
--R            has RING
--R   [183] Symbol -> TaylorSeries D2 from TaylorSeries D2 if D2 has RING
--R            
--R   [184] Variable QUOTE x -> UnivariateFormalPowerSeries D2
--R            from UnivariateFormalPowerSeries D2 if D2 has RING
--R   [185] UnivariatePolynomial(QUOTE x,D2) -> 
--R            UnivariateFormalPowerSeries D2
--R            from UnivariateFormalPowerSeries D2 if D2 has RING
--R   [186] D1 -> D from D
--R            if D2 has RING and D has ULSCCAT(D2,D1) and D1 has UTSCAT 
--R            D2
--R   [187] Segment D2 -> UniversalSegment D2 from UniversalSegment D2
--R            if D2 has TYPE
--R   [188] Variable D2 -> UnivariatePolynomial(D2,D3)
--R            from UnivariatePolynomial(D2,D3) if D2: SYMBOL and D3 has 
--R            RING
--R   [189] D1 -> D from D
--R            if D2 has RING and D has UPXSCCA(D2,D1) and D1 has ULSCAT 
--R            D2
--R   [190] Variable D3 -> UnivariateTaylorSeriesCZero(D2,D3)
--R            from UnivariateTaylorSeriesCZero(D2,D3)
--R            if D3: SYMBOL and D2 has RING
--R   [191] UnivariatePolynomial(D3,D2) -> UnivariateTaylorSeriesCZero(D2,
--R            D3)
--R            from UnivariateTaylorSeriesCZero(D2,D3)
--R            if D2 has RING and D3: SYMBOL
--R   [192] Void -> OutputForm from Void
--R   [193] D1 -> D from D if D has XALG D1 and D1 has RING
--R   [194] D1 -> D from D
--R            if D has XFALG(D1,D2) and D1 has ORDSET and D2 has RING
--R
--RThere are 50 unexposed functions called coerce :
--R   [1] Vector Matrix D3 -> Vector Matrix Fraction Polynomial D3
--R            from CoerceVectorMatrixPackage D3 if D3 has COMRING
--R   [2] List Integer -> ExtAlgBasis from ExtAlgBasis
--R   [3] EuclideanModularRing(D2,D1,D3,D4,D5,D6) -> D1
--R            from EuclideanModularRing(D2,D1,D3,D4,D5,D6)
--R            if D1 has UPOLYC D2 and D2 has COMRING and D3 has ABELMON 
--R            and D4: ((D1,D3) -> D1) and D5: ((D3,D3) -> Union(D3,
--R            "failed")) and D6: ((D1,D1,D3) -> Union(D1,"failed"))
--R   [4] UnivariatePuiseuxSeries(D3,D4,D5) -> ExponentialExpansion(D2,D3,
--R            D4,D5)
--R            from ExponentialExpansion(D2,D3,D4,D5)
--R            if D3 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace D2) and D4: 
--R            SYMBOL and D5: D3 and D2 has Join(OrderedSet,RetractableTo 
--R            Integer,LinearlyExplicitRingOver Integer,GcdDomain)
--R   [5] Vector Fraction Polynomial D2 -> GenericNonAssociativeAlgebra(D2
--R            ,D3,D4,D5)
--R            from GenericNonAssociativeAlgebra(D2,D3,D4,D5)
--R            if D2 has COMRING and D5: VECTOR MATRIX D2 and D3: PI and 
--R            D4: LIST SYMBOL
--R   [6] List List Point DoubleFloat -> GraphImage from GraphImage
--R   [7] GraphImage -> OutputForm from GraphImage
--R   [8] SparseMultivariatePolynomial(Integer,Kernel InnerAlgebraicNumber
--R            ) -> InnerAlgebraicNumber
--R            from InnerAlgebraicNumber
--R   [9] LieExponentials(D2,D3,D4) -> XPBWPolynomial(D2,D3)
--R            from LieExponentials(D2,D3,D4)
--R            if D2 has ORDSET and D3 has Join(CommutativeRing,Module 
--R            Fraction Integer) and D4: PI
--R   [10] LieExponentials(D2,D3,D4) -> XDistributedPolynomial(D2,D3)
--R            from LieExponentials(D2,D3,D4)
--R            if D2 has ORDSET and D3 has Join(CommutativeRing,Module 
--R            Fraction Integer) and D4: PI
--R   [11] LyndonWord D2 -> Magma D2 from LyndonWord D2 if D2 has ORDSET
--R         
--R   [12] LyndonWord D2 -> OrderedFreeMonoid D2 from LyndonWord D2
--R            if D2 has ORDSET
--R   [13] Magma D2 -> OrderedFreeMonoid D2 from Magma D2 if D2 has ORDSET
--R            
--R   [14] D1 -> MakeCachableSet D1 from MakeCachableSet D1 if D1 has 
--R            SETCAT
--R   [15] ModularField(D1,D2,D3,D4,D5) -> D1 from ModularField(D1,D2,D3,
--R            D4,D5)
--R            if D1 has COMRING and D2 has ABELMON and D3: ((D1,D2) -> D1
--R            ) and D4: ((D2,D2) -> Union(D2,"failed")) and D5: ((D1,D1,
--R            D2) -> Union(D1,"failed"))
--R   [16] D1 -> ModMonic(D2,D1) from ModMonic(D2,D1)
--R            if D2 has RING and D1 has UPOLYC D2
--R   [17] ModuleMonomial(D2,D3,D4) -> Record(index: D2,exponent: D3)
--R            from ModuleMonomial(D2,D3,D4)
--R            if D2 has ORDSET and D3 has SETCAT and D4: ((Record(index: 
--R            D2,exponent: D3),Record(index: D2,exponent: D3)) -> Boolean
--R            )
--R   [18] Record(index: D2,exponent: D3) -> ModuleMonomial(D2,D3,D4)
--R            from ModuleMonomial(D2,D3,D4)
--R            if D2 has ORDSET and D3 has SETCAT and D4: ((Record(index: 
--R            D2,exponent: D3),Record(index: D2,exponent: D3)) -> Boolean
--R            )
--R   [19] ModularRing(D1,D2,D3,D4,D5) -> D1 from ModularRing(D1,D2,D3,D4,
--R            D5)
--R            if D1 has COMRING and D2 has ABELMON and D3: ((D1,D2) -> D1
--R            ) and D4: ((D2,D2) -> Union(D2,"failed")) and D5: ((D1,D1,
--R            D2) -> Union(D1,"failed"))
--R   [20] List Record(coef: D2,monom: D3) -> MonoidRing(D2,D3)
--R            from MonoidRing(D2,D3) if D2 has RING and D3 has MONOID
--R   [21] Variable D2 -> UnivariateSkewPolynomial(D2,D3,D4,D5)
--R            from UnivariateSkewPolynomial(D2,D3,D4,D5)
--R            if D2: SYMBOL and D3 has RING and D4: AUTOMOR D3 and D5: (
--R            D3 -> D3)
--R   [22] Polynomial D2 -> OrdinaryWeightedPolynomials(D2,D3,D4,D5)
--R            from OrdinaryWeightedPolynomials(D2,D3,D4,D5)
--R            if D2 has RING and D3: LIST SYMBOL and D4: LIST NNI and D5
--R            : NNI
--R   [23] OrdinaryWeightedPolynomials(D2,D3,D4,D5) -> Polynomial D2
--R            from OrdinaryWeightedPolynomials(D2,D3,D4,D5)
--R            if D2 has RING and D3: LIST SYMBOL and D4: LIST NNI and D5
--R            : NNI
--R   [24] D1 -> PoincareBirkhoffWittLyndonBasis D1
--R            from PoincareBirkhoffWittLyndonBasis D1 if D1 has ORDSET
--R         
--R   [25] PoincareBirkhoffWittLyndonBasis D2 -> OrderedFreeMonoid D2
--R            from PoincareBirkhoffWittLyndonBasis D2 if D2 has ORDSET
--R         
--R   [26] Partition -> List Integer from Partition
--R   [27] D1 -> ResidueRing(D2,D3,D4,D1,D5) from ResidueRing(D2,D3,D4,D1,
--R            D5)
--R            if D2 has FIELD and D3 has OAMONS and D4 has ORDSET and D1 
--R            has POLYCAT(D2,D3,D4) and D5: LIST D1
--R   [28] RectangularMatrix(D2,D3,D4) -> Matrix D4
--R            from RectangularMatrix(D2,D3,D4)
--R            if D2: NNI and D3: NNI and D4 has RING
--R   [29] D1 -> SparseMultivariateTaylorSeries(D2,D3,D1)
--R            from SparseMultivariateTaylorSeries(D2,D3,D1)
--R            if D2 has RING and D3 has ORDSET and D1 has POLYCAT(D2,INDE
--R            D3,D3)
--R   [30] D1 -> SparseMultivariateTaylorSeries(D2,D1,D3)
--R            from SparseMultivariateTaylorSeries(D2,D1,D3)
--R            if D2 has RING and D1 has ORDSET and D3 has POLYCAT(D2,INDE
--R            D1,D1)
--R   [31] SquareMatrix(D2,D3) -> Matrix D3 from SquareMatrix(D2,D3)
--R            if D2: NNI and D3 has RING
--R   [32] D2 -> Stream D2 from StreamTaylorSeriesOperations D2 if D2 has 
--R            RING
--R   [33] Variable D3 -> SparseUnivariateLaurentSeries(D2,D3,D4)
--R            from SparseUnivariateLaurentSeries(D2,D3,D4)
--R            if D3: SYMBOL and D2 has RING and D4: D2
--R   [34] Variable D3 -> SparseUnivariatePuiseuxSeries(D2,D3,D4)
--R            from SparseUnivariatePuiseuxSeries(D2,D3,D4)
--R            if D3: SYMBOL and D2 has RING and D4: D2
--R   [35] Variable D3 -> SparseUnivariateTaylorSeries(D2,D3,D4)
--R            from SparseUnivariateTaylorSeries(D2,D3,D4)
--R            if D3: SYMBOL and D2 has RING and D4: D2
--R   [36] UnivariatePolynomial(D3,D2) -> SparseUnivariateTaylorSeries(D2,
--R            D3,D4)
--R            from SparseUnivariateTaylorSeries(D2,D3,D4)
--R            if D2 has RING and D3: SYMBOL and D4: D2
--R   [37] PrimitiveArray D2 -> Tuple D2 from Tuple D2 if D2 has TYPE
--R   [38] Variable D3 -> UnivariateLaurentSeries(D2,D3,D4)
--R            from UnivariateLaurentSeries(D2,D3,D4)
--R            if D3: SYMBOL and D2 has RING and D4: D2
--R   [39] Variable D3 -> UnivariatePuiseuxSeries(D2,D3,D4)
--R            from UnivariatePuiseuxSeries(D2,D3,D4)
--R            if D3: SYMBOL and D2 has RING and D4: D2
--R   [40] Variable D3 -> UnivariateTaylorSeries(D2,D3,D4)
--R            from UnivariateTaylorSeries(D2,D3,D4)
--R            if D3: SYMBOL and D2 has RING and D4: D2
--R   [41] UnivariatePolynomial(D3,D2) -> UnivariateTaylorSeries(D2,D3,D4)
--R            from UnivariateTaylorSeries(D2,D3,D4)
--R            if D2 has RING and D3: SYMBOL and D4: D2
--R   [42] Variable D2 -> Symbol from Variable D2 if D2: SYMBOL
--R   [43] TwoDimensionalViewport -> OutputForm from 
--R            TwoDimensionalViewport
--R   [44] GraphImage -> TwoDimensionalViewport from ViewportPackage
--R   [45] D1 -> WeightedPolynomials(D2,D3,D4,D1,D5,D6,D7)
--R            from WeightedPolynomials(D2,D3,D4,D1,D5,D6,D7)
--R            if D2 has RING and D3 has ORDSET and D4 has OAMONS and D5: 
--R            LIST D3 and D1 has POLYCAT(D2,D4,D3) and D6: LIST NNI and 
--R            D7: NNI
--R   [46] WeightedPolynomials(D2,D3,D4,D1,D5,D6,D7) -> D1
--R            from WeightedPolynomials(D2,D3,D4,D1,D5,D6,D7)
--R            if D1 has POLYCAT(D2,D4,D3) and D2 has RING and D3 has 
--R            ORDSET and D4 has OAMONS and D5: LIST D3 and D6: LIST NNI 
--R            and D7: NNI
--R   [47] XPBWPolynomial(D2,D3) -> XRecursivePolynomial(D2,D3)
--R            from XPBWPolynomial(D2,D3) if D2 has ORDSET and D3 has 
--R            COMRING
--R   [48] XPBWPolynomial(D2,D3) -> XDistributedPolynomial(D2,D3)
--R            from XPBWPolynomial(D2,D3) if D2 has ORDSET and D3 has 
--R            COMRING
--R   [49] LiePolynomial(D2,D3) -> XPBWPolynomial(D2,D3)
--R            from XPBWPolynomial(D2,D3) if D2 has ORDSET and D3 has 
--R            COMRING
--R   [50] D1 -> XPolynomialRing(D2,D1) from XPolynomialRing(D2,D1)
--R            if D2 has RING and D1 has ORDMON
--R
--RExamples of coerce from AffineSpaceCategory
--R
--R
--RExamples of coerce from Algebra
--R
--R
--RExamples of coerce from AlgebraGivenByStructuralConstants
--R
--R
--RExamples of coerce from AlgebraicNumber
--R
--R
--RExamples of coerce from AnyFunctions1
--R
--R
--RExamples of coerce from Asp10
--R
--R
--RExamples of coerce from Asp19
--R
--R
--RExamples of coerce from Asp1
--R
--R
--RExamples of coerce from Asp20
--R
--R
--RExamples of coerce from Asp24
--R
--R
--RExamples of coerce from Asp31
--R
--R
--RExamples of coerce from Asp35
--R
--R
--RExamples of coerce from Asp41
--R
--R
--RExamples of coerce from Asp42
--R
--R
--RExamples of coerce from Asp49
--R
--R
--RExamples of coerce from Asp4
--R
--R
--RExamples of coerce from Asp50
--R
--R
--RExamples of coerce from Asp55
--R
--R
--RExamples of coerce from Asp6
--R
--R
--RExamples of coerce from Asp73
--R
--R
--RExamples of coerce from Asp74
--R
--R
--RExamples of coerce from Asp77
--R
--R
--RExamples of coerce from Asp78
--R
--R
--RExamples of coerce from Asp7
--R
--R
--RExamples of coerce from Asp80
--R
--R
--RExamples of coerce from Asp9
--R
--R
--RExamples of coerce from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Rcoerce a
--R
--R
--RExamples of coerce from BinaryExpansion
--R
--R
--RExamples of coerce from BlowUpMethodCategory
--R
--R
--RExamples of coerce from CartesianTensor
--R
--Rv:=[2,3] 
--Rtv:CartesianTensor(1,2,Integer):=v 
--Rtm:CartesianTensor(1,2,Integer):=[tv,tv]
--R
--Rv:=[2,3] 
--Rtv:CartesianTensor(1,2,Integer):=v
--R
--Rv:SquareMatrix(2,Integer):=[[1,2],[3,4]] 
--Rtv:CartesianTensor(1,2,Integer):=v
--R
--Rv:DirectProduct(2,Integer):=directProduct [3,4] 
--Rtv:CartesianTensor(1,2,Integer):=v
--R
--R
--RExamples of coerce from CoerceVectorMatrixPackage
--R
--R
--RExamples of coerce from Database
--R
--R
--RExamples of coerce from DecimalExpansion
--R
--R
--RExamples of coerce from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rcoerce a
--R
--R
--RExamples of coerce from DirichletRing
--R
--R
--RExamples of coerce from DataList
--R
--R
--RExamples of coerce from DrawNumericHack
--R
--R
--RExamples of coerce from DifferentialVariableCategory
--R
--R
--RExamples of coerce from ExtAlgBasis
--R
--R
--RExamples of coerce from EuclideanModularRing
--R
--R
--RExamples of coerce from ExponentialExpansion
--R
--R
--RExamples of coerce from FortranCode
--R
--R
--RExamples of coerce from FortranExpression
--R
--R
--RExamples of coerce from FiniteFieldHomomorphisms
--R
--R
--RExamples of coerce from FreeLieAlgebra
--R
--R
--RExamples of coerce from FortranMatrixCategory
--R
--R
--RExamples of coerce from FortranMatrixFunctionCategory
--R
--R
--RExamples of coerce from FileNameCategory
--R
--R
--RExamples of coerce from ScriptFormulaFormat1
--R
--R
--RExamples of coerce from ScriptFormulaFormat
--R
--R
--RExamples of coerce from FortranFunctionCategory
--R
--R
--RExamples of coerce from FortranProgram
--R
--R
--RExamples of coerce from FourierSeries
--R
--R
--RExamples of coerce from FunctionSpace
--R
--R
--RExamples of coerce from FortranScalarType
--R
--R
--RExamples of coerce from FortranType
--R
--R
--RExamples of coerce from FortranVectorCategory
--R
--R
--RExamples of coerce from FortranVectorFunctionCategory
--R
--R
--RExamples of coerce from GenericNonAssociativeAlgebra
--R
--R
--RExamples of coerce from GraphImage
--R
--R
--RExamples of coerce from GeneralUnivariatePowerSeries
--R
--R
--RExamples of coerce from Heap
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--Rcoerce a
--R
--R
--RExamples of coerce from HexadecimalExpansion
--R
--R
--RExamples of coerce from HTMLFormat
--R
--Rcoerce(sqrt(3+x)::OutputForm)$HTMLFORM
--R
--R
--RExamples of coerce from InnerAlgebraicNumber
--R
--R
--RExamples of coerce from IndexCard
--R
--R
--RExamples of coerce from PolynomialIdeals
--R
--R
--RExamples of coerce from AssociatedJordanAlgebra
--R
--R
--RExamples of coerce from CoercibleTo
--R
--R
--RExamples of coerce from LeftAlgebra
--R
--R
--RExamples of coerce from LieExponentials
--R
--R
--RExamples of coerce from AssociatedLieAlgebra
--R
--R
--RExamples of coerce from LocalPowerSeriesCategory
--R
--R
--RExamples of coerce from LyndonWord
--R
--R
--RExamples of coerce from ThreeDimensionalMatrix
--R
--R
--RExamples of coerce from Magma
--R
--R
--RExamples of coerce from MappingPackage1
--R
--R
--RExamples of coerce from MatrixCategory
--R
--Rcoerce([1,2,3])@Matrix(INT)
--R
--R
--RExamples of coerce from MachineComplex
--R
--R
--RExamples of coerce from MachineFloat
--R
--R
--RExamples of coerce from MachineInteger
--R
--R
--RExamples of coerce from MakeCachableSet
--R
--R
--RExamples of coerce from MathMLFormat
--R
--R
--RExamples of coerce from ModularField
--R
--R
--RExamples of coerce from ModMonic
--R
--R
--RExamples of coerce from ModuleMonomial
--R
--R
--RExamples of coerce from ModularRing
--R
--R
--RExamples of coerce from MonoidRing
--R
--R
--RExamples of coerce from MyExpression
--R
--R
--RExamples of coerce from MyUnivariatePolynomial
--R
--R
--RExamples of coerce from NonAssociativeRing
--R
--R
--RExamples of coerce from NumericalIntegrationProblem
--R
--R
--RExamples of coerce from NoneFunctions1
--R
--R
--RExamples of coerce from NumericalODEProblem
--R
--R
--RExamples of coerce from OrdinaryDifferentialRing
--R
--R
--RExamples of coerce from OpenMathErrorKind
--R
--R
--RExamples of coerce from NumericalOptimizationProblem
--R
--R
--RExamples of coerce from UnivariateSkewPolynomial
--R
--R
--RExamples of coerce from OrdSetInts
--R
--R
--RExamples of coerce from OrdinaryWeightedPolynomials
--R
--R
--RExamples of coerce from Palette
--R
--R
--RExamples of coerce from PolynomialAN2Expression
--R
--R
--RExamples of coerce from PoincareBirkhoffWittLyndonBasis
--R
--R
--RExamples of coerce from NumericalPDEProblem
--R
--R
--RExamples of coerce from PendantTree
--R
--Rt1:=ptree([1,2,3]) 
--Rt2:=ptree(t1,ptree([1,2,3])) 
--Rt2::Tree List PositiveInteger
--R
--R
--RExamples of coerce from PermutationGroup
--R
--R
--RExamples of coerce from Permutation
--R
--R
--RExamples of coerce from PartialFraction
--R
--R(13/74)::PFR(INT)
--R
--Ra:=(13/74)::PFR(INT) 
--Ra::FRAC(INT)
--R
--R
--RExamples of coerce from PiCoercions
--R
--R
--RExamples of coerce from ProjectiveSpaceCategory
--R
--R
--RExamples of coerce from Partition
--R
--R
--RExamples of coerce from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rcoerce a
--R
--R
--RExamples of coerce from RadixExpansion
--R
--R
--RExamples of coerce from ResolveLatticeCompletion
--R
--R
--RExamples of coerce from ResidueRing
--R
--R
--RExamples of coerce from RetractableTo
--R
--R
--RExamples of coerce from RationalFunction
--R
--R
--RExamples of coerce from Ring
--R
--R
--RExamples of coerce from RectangularMatrix
--R
--R
--RExamples of coerce from SparseMultivariateTaylorSeries
--R
--R
--RExamples of coerce from ThreeSpaceCategory
--R
--R
--RExamples of coerce from SquareMatrix
--R
--R
--RExamples of coerce from StringAggregate
--R
--R
--RExamples of coerce from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rcoerce a
--R
--R
--RExamples of coerce from Stream
--R
--Rm:=[1,2,3,4,5,6,7,8,9,10,11,12] 
--Rcoerce(m)@Stream(Integer) 
--Rm::Stream(Integer)
--R
--R
--RExamples of coerce from StreamTaylorSeriesOperations
--R
--R
--RExamples of coerce from SparseUnivariateLaurentSeries
--R
--R
--RExamples of coerce from SparseUnivariatePuiseuxSeries
--R
--R
--RExamples of coerce from SparseUnivariateTaylorSeries
--R
--R
--RExamples of coerce from Switch
--R
--R
--RExamples of coerce from Symbol
--R
--R
--RExamples of coerce from SymbolTable
--R
--R
--RExamples of coerce from Tableau
--R
--R
--RExamples of coerce from TexFormat1
--R
--R
--RExamples of coerce from TexFormat
--R
--R
--RExamples of coerce from TaylorSeries
--R
--R
--RExamples of coerce from Tuple
--R
--Rt1:PrimitiveArray(Integer):= [i for i in 1..10] 
--Rt2:=coerce(t1)$Tuple(Integer)
--R
--R
--RExamples of coerce from UnivariateFormalPowerSeries
--R
--R
--RExamples of coerce from UnivariateLaurentSeriesConstructorCategory
--R
--R
--RExamples of coerce from UnivariateLaurentSeries
--R
--R
--RExamples of coerce from UniversalSegment
--R
--R
--RExamples of coerce from UnivariatePolynomial
--R
--R
--RExamples of coerce from UnivariatePuiseuxSeriesConstructorCategory
--R
--R
--RExamples of coerce from UnivariatePuiseuxSeries
--R
--R
--RExamples of coerce from UnivariateTaylorSeries
--R
--R
--RExamples of coerce from UnivariateTaylorSeriesCZero
--R
--R
--RExamples of coerce from Variable
--R
--R
--RExamples of coerce from TwoDimensionalViewport
--R
--R
--RExamples of coerce from ViewportPackage
--R
--R
--RExamples of coerce from Void
--R
--R
--RExamples of coerce from WeightedPolynomials
--R
--R
--RExamples of coerce from XAlgebra
--R
--R
--RExamples of coerce from XFreeAlgebra
--R
--R
--RExamples of coerce from XPBWPolynomial
--R
--R
--RExamples of coerce from XPolynomialRing
--R
--E 69

--S 70 of 127
)d op contract
--R 
--R
--RThere are 3 exposed functions called contract :
--R   [1] (CartesianTensor(D2,D3,D4),Integer,Integer) -> CartesianTensor(
--R            D2,D3,D4)
--R            from CartesianTensor(D2,D3,D4)
--R            if D2: INT and D3: NNI and D4 has COMRING
--R   [2] (CartesianTensor(D2,D3,D4),Integer,CartesianTensor(D2,D3,D4),
--R            Integer) -> CartesianTensor(D2,D3,D4)
--R            from CartesianTensor(D2,D3,D4)
--R            if D2: INT and D3: NNI and D4 has COMRING
--R   [3] (PolynomialIdeals(Fraction Integer,DirectProduct(D4,
--R            NonNegativeInteger),OrderedVariableList D3,
--R            DistributedMultivariatePolynomial(D3,Fraction Integer)),List 
--R            OrderedVariableList D3) -> PolynomialIdeals(Fraction Integer,
--R            DirectProduct(D4,NonNegativeInteger),OrderedVariableList D3,
--R            DistributedMultivariatePolynomial(D3,Fraction Integer))
--R            from IdealDecompositionPackage(D3,D4) if D3: LIST SYMBOL 
--R            and D4: NNI
--R
--RExamples of contract from CartesianTensor
--R
--Rm:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]] 
--RTm:CartesianTensor(1,2,Integer):=m 
--Rv:DirectProduct(2,Integer):=directProduct [3,4] 
--RTv:CartesianTensor(1,2,Integer):=v 
--RTmv:=contract(Tm,2,1)
--R
--Rm:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]] 
--RTm:CartesianTensor(1,2,Integer):=m 
--Rv:DirectProduct(2,Integer):=directProduct [3,4] 
--RTv:CartesianTensor(1,2,Integer):=v 
--RTmv:=contract(Tm,2,Tv,1)
--R
--R
--RExamples of contract from IdealDecompositionPackage
--R
--E 70

--S 71 of 127
)d op irreducibleFactor
--R 
--R
--RThere is one exposed function called irreducibleFactor :
--R   [1] (D1,Integer) -> Factored D1 from Factored D1 if D1 has INTDOM
--R         
--R
--RExamples of irreducibleFactor from Factored
--R
--Ra:=irreducibleFactor(3,1) 
--RnthFlag(a,1)
--R
--E 71

--S 72 of 127
)d op concat
--R 
--R
--RThere are 11 exposed functions called concat :
--R   [1] (D,D) -> D from D if D has DIVCAT D1 and D1 has SETCAT
--R   [2] (Result,Result) -> Result from ExpertSystemToolsPackage
--R   [3] List Result -> Result from ExpertSystemToolsPackage
--R   [4] List D -> D from D if D has LNAGG D2 and D2 has TYPE
--R   [5] (D,D) -> D from D if D has LNAGG D1 and D1 has TYPE
--R   [6] (D1,D) -> D from D if D has LNAGG D1 and D1 has TYPE
--R   [7] (D,D1) -> D from D if D has LNAGG D1 and D1 has TYPE
--R   [8] (RoutinesTable,RoutinesTable) -> RoutinesTable from 
--R            RoutinesTable
--R   [9] Stream Stream D3 -> Stream D3 from StreamFunctions1 D3 if D3 has
--R            TYPE
--R   [10] (D1,D) -> D from D if D has URAGG D1 and D1 has TYPE
--R   [11] (D,D) -> D from D if D has URAGG D1 and D1 has TYPE
--R
--RExamples of concat from DivisorCategory
--R
--R
--RExamples of concat from ExpertSystemToolsPackage
--R
--R
--RExamples of concat from LinearAggregate
--R
--R
--RExamples of concat from RoutinesTable
--R
--R
--RExamples of concat from StreamFunctions1
--R
--Rm:=[i for i in 10..] 
--Rn:=[j for j in 1.. | prime? j] 
--Rp:=[m,n]::Stream(Stream(PositiveInteger)) 
--Rconcat(p)
--R
--R
--RExamples of concat from UnaryRecursiveAggregate
--R
--E 72

--S 73 of 127
)d op binaryTournament
--R 
--R
--RThere is one exposed function called binaryTournament :
--R   [1] List D2 -> BinaryTournament D2 from BinaryTournament D2 if D2 
--R            has ORDSET
--R
--RExamples of binaryTournament from BinaryTournament
--R
--RbinaryTournament [1,2,3,4]
--R
--E 73

--S 74 of 127
)d op upperCase
--R 
--R
--RThere are 3 exposed functions called upperCase :
--R   [1]  -> CharacterClass from CharacterClass
--R   [2] Character -> Character from Character
--R   [3] D -> D from D if D has SRAGG
--R
--RExamples of upperCase from CharacterClass
--R
--R
--RExamples of upperCase from Character
--R
--Rchars := [char "a", char "A", char "X", char "8", char "+"] 
--R[upperCase c for c in chars]
--R
--R
--RExamples of upperCase from StringAggregate
--R
--E 74

--S 75 of 127
)d op exponent
--R 
--R
--RThere are 3 exposed functions called exponent :
--R   [1] D -> Integer from D if D has FPS
--R   [2] Factored D2 -> Integer from Factored D2 if D2 has INTDOM
--R   [3] MachineFloat -> Integer from MachineFloat
--R
--RThere are 2 unexposed functions called exponent :
--R   [1] ExponentialOfUnivariatePuiseuxSeries(D2,D3,D4) -> 
--R            UnivariatePuiseuxSeries(D2,D3,D4)
--R            from ExponentialOfUnivariatePuiseuxSeries(D2,D3,D4)
--R            if D2 has Join(Field,OrderedSet) and D3: SYMBOL and D4: D2
--R            
--R   [2] ModuleMonomial(D2,D1,D3) -> D1 from ModuleMonomial(D2,D1,D3)
--R            if D1 has SETCAT and D2 has ORDSET and D3: ((Record(index: 
--R            D2,exponent: D1),Record(index: D2,exponent: D1)) -> Boolean
--R            )
--R
--RExamples of exponent from ExponentialOfUnivariatePuiseuxSeries
--R
--R
--RExamples of exponent from FloatingPointSystem
--R
--R
--RExamples of exponent from Factored
--R
--Rf:=nilFactor(y-x,3) 
--Rexponent(f)
--R
--R
--RExamples of exponent from MachineFloat
--R
--R
--RExamples of exponent from ModuleMonomial
--R
--E 75

--S 76 of 127
)d op setRow!
--R 
--R
--RThere is one exposed function called setRow! :
--R   [1] (D,Integer,D2) -> D from D
--R            if D has ARR2CAT(D3,D2,D4) and D3 has TYPE and D2 has FLAGG
--R            D3 and D4 has FLAGG D3
--R
--RExamples of setRow! from TwoDimensionalArrayCategory
--R
--RT1:=TwoDimensionalArray Integer 
--Rarr:T1:= new(5,4,0) 
--RT2:=OneDimensionalArray Integer 
--Rarow:=construct([1,2,3,4]::List(INT))$T2 
--RsetRow!(arr,1,arow)$T1
--R
--E 76

--S 77 of 127
)d op generate
--R 
--R
--RThere are 4 exposed functions called generate :
--R   [1] (NonNegativeInteger,NonNegativeInteger) -> Vector List Integer
--R            from HallBasis
--R   [2] ((D2 -> D2),D2) -> InfiniteTuple D2 from InfiniteTuple D2 if D2 
--R            has TYPE
--R   [3] ((D2 -> D2),D2) -> Stream D2 from Stream D2 if D2 has TYPE
--R   [4] (() -> D2) -> Stream D2 from Stream D2 if D2 has TYPE
--R
--RExamples of generate from HallBasis
--R
--R
--RExamples of generate from InfiniteTuple
--R
--R
--RExamples of generate from Stream
--R
--Rf(x:Integer):Integer == x+10 
--Rgenerate(f,10)
--R
--Rf():Integer == 1 
--Rgenerate(f)
--R
--E 77

--S 78 of 127
)d op gcd
--R 
--R
--RThere are 6 exposed functions called gcd :
--R   [1] List D -> D from D if D has GCDDOM
--R   [2] (D,D) -> D from D if D has GCDDOM
--R   [3] (D1,D1,Integer) -> D1 from ModularDistinctDegreeFactorizer D1
--R            if D1 has UPOLYC INT
--R   [4] (NonNegativeInteger,NonNegativeInteger) -> NonNegativeInteger
--R            from NonNegativeInteger
--R   [5] (PositiveInteger,PositiveInteger) -> PositiveInteger
--R            from PositiveInteger
--R   [6] (D1,D) -> D1 from D
--R            if D has RPOLCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET and D1 has GCDDOM
--R
--RThere are 6 unexposed functions called gcd :
--R   [1] List D1 -> D1 from HeuGcd D1 if D1 has UPOLYC INT
--R   [2] (D1,D1) -> D1 from PolynomialGcdPackage(D2,D3,D4,D1)
--R            if D2 has OAMONS and D3 has ORDSET and D4 has EUCDOM and D1
--R            has POLYCAT(D4,D2,D3)
--R   [3] List D1 -> D1 from PolynomialGcdPackage(D3,D4,D5,D1)
--R            if D1 has POLYCAT(D5,D3,D4) and D3 has OAMONS and D4 has 
--R            ORDSET and D5 has EUCDOM
--R   [4] (SparseUnivariatePolynomial D5,SparseUnivariatePolynomial D5)
--R             -> SparseUnivariatePolynomial D5
--R            from PolynomialGcdPackage(D2,D3,D4,D5)
--R            if D5 has POLYCAT(D4,D2,D3) and D2 has OAMONS and D3 has 
--R            ORDSET and D4 has EUCDOM
--R   [5] List SparseUnivariatePolynomial D6 -> SparseUnivariatePolynomial
--R            D6
--R            from PolynomialGcdPackage(D3,D4,D5,D6)
--R            if D3 has OAMONS and D4 has ORDSET and D5 has EUCDOM and D6
--R            has POLYCAT(D5,D3,D4)
--R   [6] (D1,D1) -> D1 from PseudoRemainderSequence(D2,D1)
--R            if D2 has GCDDOM and D2 has INTDOM and D1 has UPOLYC D2
--R
--RExamples of gcd from GcdDomain
--R
--R
--RExamples of gcd from HeuGcd
--R
--Rgcd([671*671*x^2-1,671*671*x^2+2*671*x+1]) 
--Rgcd([7*x^2+1,(7*x^2+1)^2])
--R
--R
--RExamples of gcd from ModularDistinctDegreeFactorizer
--R
--R
--RExamples of gcd from NonNegativeInteger
--R
--R
--RExamples of gcd from PolynomialGcdPackage
--R
--R
--RExamples of gcd from PositiveInteger
--R
--R
--RExamples of gcd from PseudoRemainderSequence
--R
--R
--RExamples of gcd from RecursivePolynomialCategory
--R
--E 78

--S 79 of 127
)d op binary
--R 
--R
--RThere is one exposed function called binary :
--R   [1] Fraction Integer -> BinaryExpansion from BinaryExpansion
--R
--RThere is one unexposed function called binary :
--R   [1] (InputForm,List InputForm) -> InputForm from InputForm
--R
--RExamples of binary from BinaryExpansion
--R
--Rbinary(22/7)
--R
--R
--RExamples of binary from InputForm
--R
--Ra:=[1,2,3]::List(InputForm) 
--Rbinary(_+::InputForm,a)
--R
--E 79

--S 80 of 127
)d op expand
--R 
--R
--RThere are 6 exposed functions called expand :
--R   [1] Factored D1 -> D1 from Factored D1 if D1 has INTDOM
--R   [2] IntegrationResult D4 -> List D4 from IntegrationResultToFunction
--R            (D3,D4)
--R            if D4 has Join(AlgebraicallyClosedFunctionSpace D3,
--R            TranscendentalFunctionCategory) and D3 has Join(GcdDomain,
--R            RetractableTo Integer,OrderedSet,LinearlyExplicitRingOver 
--R            Integer)
--R   [3] IntegrationResult Fraction Polynomial D3 -> List Expression D3
--R            from IntegrationResultRFToFunction D3
--R            if D3 has Join(GcdDomain,RetractableTo Integer,OrderedSet,
--R            LinearlyExplicitRingOver Integer)
--R   [4] D -> D1 from D
--R            if D has SEGXCAT(D2,D1) and D2 has ORDRING and D1 has STAGG
--R            D2
--R   [5] List D -> D1 from D
--R            if D has SEGXCAT(D3,D1) and D3 has ORDRING and D1 has STAGG
--R            D3
--R   [6] D1 -> D1 from TranscendentalManipulations(D2,D1)
--R            if D2 has Join(OrderedSet,GcdDomain) and D1 has Join(
--R            FunctionSpace D2,TranscendentalFunctionCategory)
--R
--RThere are 3 unexposed functions called expand :
--R   [1] (Expression D5,PositiveInteger) -> List Expression D5
--R            from DegreeReductionPackage(D4,D5)
--R            if D5 has Join(IntegralDomain,OrderedSet) and D4 has RING
--R         
--R   [2] XPolynomial D2 -> XDistributedPolynomial(Symbol,D2) from 
--R            XPolynomial D2
--R            if D2 has RING
--R   [3] XRecursivePolynomial(D2,D3) -> XDistributedPolynomial(D2,D3)
--R            from XRecursivePolynomial(D2,D3)
--R            if D2 has ORDSET and D3 has RING
--R
--RExamples of expand from DegreeReductionPackage
--R
--R
--RExamples of expand from Factored
--R
--Rf:=nilFactor(y-x,3) 
--Rexpand(f)
--R
--R
--RExamples of expand from IntegrationResultToFunction
--R
--R
--RExamples of expand from IntegrationResultRFToFunction
--R
--R
--RExamples of expand from SegmentExpansionCategory
--R
--R
--RExamples of expand from TranscendentalManipulations
--R
--R
--RExamples of expand from XPolynomial
--R
--R
--RExamples of expand from XRecursivePolynomial
--R
--E 80

--S 81 of 127
)d op filterWhile
--R 
--R
--RThere are 2 exposed functions called filterWhile :
--R   [1] ((D2 -> Boolean),InfiniteTuple D2) -> InfiniteTuple D2
--R            from InfiniteTuple D2 if D2 has TYPE
--R   [2] ((D2 -> Boolean),Stream D2) -> Stream D2 from Stream D2 if D2 
--R            has TYPE
--R
--RExamples of filterWhile from InfiniteTuple
--R
--R
--RExamples of filterWhile from Stream
--R
--Rm:=[i for i in 1..] 
--Rf(x:PositiveInteger):Boolean == x < 5 
--RfilterWhile(f,m)
--R
--E 81

--S 82 of 127
)d op filterUntil
--R 
--R
--RThere are 2 exposed functions called filterUntil :
--R   [1] ((D2 -> Boolean),InfiniteTuple D2) -> InfiniteTuple D2
--R            from InfiniteTuple D2 if D2 has TYPE
--R   [2] ((D2 -> Boolean),Stream D2) -> Stream D2 from Stream D2 if D2 
--R            has TYPE
--R
--RExamples of filterUntil from InfiniteTuple
--R
--R
--RExamples of filterUntil from Stream
--R
--Rm:=[i for i in 1..] 
--Rf(x:PositiveInteger):Boolean == x < 5 
--RfilterUntil(f,m)
--R
--E 82

--S 83 of 127
)d op select
--R 
--R
--RThere are 4 exposed functions called select :
--R   [1] ((D2 -> Boolean),D) -> D from D
--R            if D has finiteAggregate and D has CLAGG D2 and D2 has TYPE
--R            
--R   [2] ((D2 -> Boolean),InfiniteTuple D2) -> InfiniteTuple D2
--R            from InfiniteTuple D2 if D2 has TYPE
--R   [3] ((D2 -> Boolean),D) -> D from D if D has LZSTAGG D2 and D2 has 
--R            TYPE
--R   [4] (D,D2) -> Union(D1,"failed") from D
--R            if D has TSETCAT(D3,D4,D2,D1) and D3 has INTDOM and D4 has 
--R            OAMONS and D2 has ORDSET and D1 has RPOLCAT(D3,D4,D2)
--R
--RThere is one unexposed function called select :
--R   [1] (Tuple D1,NonNegativeInteger) -> D1 from Tuple D1 if D1 has TYPE
--R            
--R
--RExamples of select from Collection
--R
--R
--RExamples of select from InfiniteTuple
--R
--R
--RExamples of select from LazyStreamAggregate
--R
--Rm:=[i for i in 0..] 
--Rselect(x+->prime? x,m)
--R
--R
--RExamples of select from TriangularSetCategory
--R
--R
--RExamples of select from Tuple
--R
--Rt1:PrimitiveArray(Integer):= [i for i in 1..10] 
--Rt2:=coerce(t1)$Tuple(Integer) 
--Rselect(t2,3)
--R
--E 83

--S 84 of 127
)d op nthFlag
--R 
--R
--RThere is one exposed function called nthFlag :
--R   [1] (Factored D3,Integer) -> Union("nil","sqfr","irred","prime")
--R            from Factored D3 if D3 has INTDOM
--R
--RExamples of nthFlag from Factored
--R
--Ra:=factor 9720000 
--RnthFlag(a,2)
--R
--E 84

--S 85 of 127
)d op makeFR
--R 
--R
--RThere is one exposed function called makeFR :
--R   [1] (D1,List Record(flg: Union("nil","sqfr","irred","prime"),fctr: 
--R            D1,xpnt: Integer)) -> Factored D1
--R            from Factored D1 if D1 has INTDOM
--R
--RThere is one unexposed function called makeFR :
--R   [1] Record(contp: Integer,factors: List Record(irr: D3,pow: Integer)
--R            ) -> Factored D3
--R            from GaloisGroupFactorizer D3 if D3 has UPOLYC INT
--R
--RExamples of makeFR from Factored
--R
--Rf:=nilFactor(x-y,3) 
--Rg:=factorList f 
--RmakeFR(z,g)
--R
--R
--RExamples of makeFR from GaloisGroupFactorizer
--R
--E 85

--S 86 of 127
)d op *
--R 
--R
--RThere are 35 exposed functions called * :
--R   [1] (Integer,D) -> D from D if D has ABELGRP
--R   [2] (NonNegativeInteger,D) -> D from D if D has ABELMON
--R   [3] (PositiveInteger,D) -> D from D if D has ABELSG
--R   [4] (CartesianTensor(D1,D2,D3),CartesianTensor(D1,D2,D3)) -> 
--R            CartesianTensor(D1,D2,D3)
--R            from CartesianTensor(D1,D2,D3)
--R            if D1: INT and D2: NNI and D3 has COMRING
--R   [5] (DoubleFloat,Color) -> Color from Color
--R   [6] (PositiveInteger,Color) -> Color from Color
--R   [7] (DenavitHartenbergMatrix D2,Point D2) -> Point D2
--R            from DenavitHartenbergMatrix D2
--R            if D2 has Join(Field,TranscendentalFunctionCategory)
--R   [8] (D1,Equation D1) -> Equation D1 from Equation D1
--R            if D1 has SGROUP and D1 has TYPE
--R   [9] (Equation D1,D1) -> Equation D1 from Equation D1
--R            if D1 has SGROUP and D1 has TYPE
--R   [10] (D1,D2) -> D from D
--R            if D has FAMONC(D2,D1) and D2 has SETCAT and D1 has CABMON
--R            
--R   [11] (D1,D2) -> D from D
--R            if D has FMCAT(D1,D2) and D1 has RING and D2 has SETCAT
--R   [12] (D,D1) -> D from D
--R            if D has GRMOD(D1,D2) and D1 has COMRING and D2 has ABELMON
--R            
--R   [13] (D1,D) -> D from D
--R            if D has GRMOD(D1,D2) and D1 has COMRING and D2 has ABELMON
--R            
--R   [14] (PolynomialIdeals(D1,D2,D3,D4),PolynomialIdeals(D1,D2,D3,D4))
--R             -> PolynomialIdeals(D1,D2,D3,D4)
--R            from PolynomialIdeals(D1,D2,D3,D4)
--R            if D1 has FIELD and D2 has OAMONS and D3 has ORDSET and D4 
--R            has POLYCAT(D1,D2,D3)
--R   [15] (D1,D) -> D from D if D has LMODULE D1 and D1 has RNG
--R   [16] ((D5 -> D6),(D4 -> D5)) -> (D4 -> D6) from MappingPackage3(D4,
--R            D5,D6)
--R            if D4 has SETCAT and D5 has SETCAT and D6 has SETCAT
--R   [17] ((D2 -> D3),(D2 -> D3)) -> (D2 -> D3) from MappingPackage4(D2,
--R            D3)
--R            if D2 has SETCAT and D3 has RING
--R   [18] (D1,D) -> D1 from D
--R            if D has MATCAT(D2,D1,D3) and D2 has RING and D1 has FLAGG 
--R            D2 and D3 has FLAGG D2
--R   [19] (D,D1) -> D1 from D
--R            if D has MATCAT(D2,D3,D1) and D2 has RING and D3 has FLAGG 
--R            D2 and D1 has FLAGG D2
--R   [20] (Integer,D) -> D from D
--R            if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG 
--R            D2 and D4 has FLAGG D2
--R   [21] (D,D1) -> D from D
--R            if D has MATCAT(D1,D2,D3) and D1 has RING and D2 has FLAGG 
--R            D1 and D3 has FLAGG D1
--R   [22] (D1,D) -> D from D
--R            if D has MATCAT(D1,D2,D3) and D1 has RING and D2 has FLAGG 
--R            D1 and D3 has FLAGG D1
--R   [23] (D,D) -> D from D
--R            if D has MATCAT(D1,D2,D3) and D1 has RING and D2 has FLAGG 
--R            D1 and D3 has FLAGG D1
--R   [24] (D,D) -> D from D if D has MONAD
--R   [25] (MyExpression(D1,D2),MyExpression(D1,D2)) -> MyExpression(D1,D2
--R            )
--R            from MyExpression(D1,D2)
--R            if D1: SYMBOL and D2 has Join(Ring,OrderedSet,
--R            IntegralDomain)
--R   [26] (Integer,D) -> Divisor D from D
--R            if D3 has FIELD and D4 has LOCPOWC D3 and D has PLACESC(D3,
--R            D4)
--R   [27] (D,D1) -> D from D if D has RMODULE D1 and D1 has RNG
--R   [28] (D,D) -> D from D if D has SGROUP
--R   [29] (D1,D) -> D1 from D
--R            if D has SMATCAT(D2,D3,D1,D4) and D3 has RING and D1 has 
--R            DIRPCAT(D2,D3) and D4 has DIRPCAT(D2,D3)
--R   [30] (D,D1) -> D1 from D
--R            if D has SMATCAT(D2,D3,D4,D1) and D3 has RING and D4 has 
--R            DIRPCAT(D2,D3) and D1 has DIRPCAT(D2,D3)
--R   [31] (D,D1) -> D from D
--R            if D has VECTCAT D1 and D1 has TYPE and D1 has MONOID
--R   [32] (D1,D) -> D from D
--R            if D has VECTCAT D1 and D1 has TYPE and D1 has MONOID
--R   [33] (Integer,D) -> D from D
--R            if D has VECTCAT D2 and D2 has TYPE and D2 has ABELGRP
--R   [34] (D1,D) -> D from D
--R            if D has XFALG(D1,D2) and D1 has ORDSET and D2 has RING
--R   [35] (D,D1) -> D from D
--R            if D has XFALG(D2,D1) and D2 has ORDSET and D1 has RING
--R
--RThere are 23 unexposed functions called * :
--R   [1] (FreeGroup D1,D1) -> FreeGroup D1 from FreeGroup D1 if D1 has 
--R            SETCAT
--R   [2] (D1,FreeGroup D1) -> FreeGroup D1 from FreeGroup D1 if D1 has 
--R            SETCAT
--R   [3] (D1,D2) -> FreeModule1(D2,D1) from FreeModule1(D2,D1)
--R            if D2 has RING and D1 has ORDSET
--R   [4] (FreeMonoid D1,D1) -> FreeMonoid D1 from FreeMonoid D1 if D1 has
--R            SETCAT
--R   [5] (D1,FreeMonoid D1) -> FreeMonoid D1 from FreeMonoid D1 if D1 has
--R            SETCAT
--R   [6] (D1,GeneralModulePolynomial(D2,D3,D4,D5,D6,D1)) -> 
--R            GeneralModulePolynomial(D2,D3,D4,D5,D6,D1)
--R            from GeneralModulePolynomial(D2,D3,D4,D5,D6,D1)
--R            if D2: LIST SYMBOL and D3 has COMRING and D5 has DIRPCAT(# 
--R            D2,NNI) and D6: ((Record(index: D4,exponent: D5),Record(
--R            index: D4,exponent: D5)) -> Boolean) and D4 has ORDSET and 
--R            D1 has POLYCAT(D3,D5,OVAR D2)
--R   [7] (Vector D2,Vector D2) -> Vector D2
--R            from InnerNormalBasisFieldFunctions D2 if D2 has FFIELDC
--R         
--R   [8] (InputForm,InputForm) -> InputForm from InputForm
--R   [9] (InnerTaylorSeries D2,Integer) -> InnerTaylorSeries D2
--R            from InnerTaylorSeries D2 if D2 has RING
--R   [10] (InnerTaylorSeries D1,D1) -> InnerTaylorSeries D1
--R            from InnerTaylorSeries D1 if D1 has RING
--R   [11] (D1,InnerTaylorSeries D1) -> InnerTaylorSeries D1
--R            from InnerTaylorSeries D1 if D1 has RING
--R   [12] (Magma D1,Magma D1) -> Magma D1 from Magma D1 if D1 has ORDSET
--R            
--R   [13] (OrderedFreeMonoid D1,D1) -> OrderedFreeMonoid D1
--R            from OrderedFreeMonoid D1 if D1 has ORDSET
--R   [14] (D1,OrderedFreeMonoid D1) -> OrderedFreeMonoid D1
--R            from OrderedFreeMonoid D1 if D1 has ORDSET
--R   [15] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R   [16] (Pattern D1,Pattern D1) -> Pattern D1 from Pattern D1 if D1 has
--R            SETCAT
--R   [17] (D2,Vector D3) -> Vector D3 from PseudoRemainderSequence(D2,D3)
--R            if D3 has UPOLYC D2 and D2 has INTDOM
--R   [18] (D1,SparseMultivariateTaylorSeries(D2,D3,D1)) -> 
--R            SparseMultivariateTaylorSeries(D2,D3,D1)
--R            from SparseMultivariateTaylorSeries(D2,D3,D1)
--R            if D2 has RING and D3 has ORDSET and D1 has POLYCAT(D2,INDE
--R            D3,D3)
--R   [19] (Stream D2,Stream D2) -> Stream D2 from 
--R            StreamTaylorSeriesOperations D2
--R            if D2 has RING
--R   [20] (D2,Stream D2) -> Stream D2 from StreamTaylorSeriesOperations 
--R            D2
--R            if D2 has RING
--R   [21] (Stream D2,D2) -> Stream D2 from StreamTaylorSeriesOperations 
--R            D2
--R            if D2 has RING
--R   [22] (DoubleFloat,Point DoubleFloat) -> Point DoubleFloat from 
--R            TubePlotTools
--R   [23] (XPolynomialRing(D1,D2),D1) -> XPolynomialRing(D1,D2)
--R            from XPolynomialRing(D1,D2) if D1 has RING and D2 has 
--R            ORDMON
--R
--RExamples of * from AbelianGroup
--R
--R
--RExamples of * from AbelianMonoid
--R
--R
--RExamples of * from AbelianSemiGroup
--R
--R
--RExamples of * from CartesianTensor
--R
--Rm:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]] 
--RTm:CartesianTensor(1,2,Integer):=m 
--Rv:DirectProduct(2,Integer):=directProduct [3,4] 
--RTv:CartesianTensor(1,2,Integer):=v 
--RTm*Tv
--R
--R
--RExamples of * from Color
--R
--R
--RExamples of * from DenavitHartenbergMatrix
--R
--R
--RExamples of * from Equation
--R
--R
--RExamples of * from FreeAbelianMonoidCategory
--R
--R
--RExamples of * from FreeGroup
--R
--R
--RExamples of * from FreeModule1
--R
--R
--RExamples of * from FreeModuleCat
--R
--R
--RExamples of * from FreeMonoid
--R
--R
--RExamples of * from GeneralModulePolynomial
--R
--R
--RExamples of * from GradedModule
--R
--R
--RExamples of * from PolynomialIdeals
--R
--R
--RExamples of * from InnerNormalBasisFieldFunctions
--R
--R
--RExamples of * from InputForm
--R
--R
--RExamples of * from InnerTaylorSeries
--R
--R
--RExamples of * from LeftModule
--R
--R
--RExamples of * from Magma
--R
--R
--RExamples of * from MappingPackage3
--R
--R
--RExamples of * from MappingPackage4
--R
--Rf:=(x:INT):INT +-> 3*x 
--Rg:=(x:INT):INT +-> 2*x+3 
--R(f*g)(4)
--R
--R
--RExamples of * from MatrixCategory
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--Rr:=transpose([1,2,3,4,5])@Matrix(INT) 
--Rr*m
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--Rc:=coerce([1,2,3,4,5])@Matrix(INT) 
--Rm*c
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--R3*m
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--Rm*1/3
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--R1/3*m
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--Rm*m
--R
--R
--RExamples of * from Monad
--R
--R
--RExamples of * from MyExpression
--R
--R
--RExamples of * from OrderedFreeMonoid
--R
--Rm1:=(y**3)$OFMONOID(Symbol) 
--Rm1*x
--R
--Rm1:=(x*y*y*z)$OFMONOID(Symbol) 
--Rx*m1
--R
--R
--RExamples of * from OutputForm
--R
--R
--RExamples of * from Pattern
--R
--R
--RExamples of * from PlacesCategory
--R
--R
--RExamples of * from PseudoRemainderSequence
--R
--R
--RExamples of * from RightModule
--R
--R
--RExamples of * from SemiGroup
--R
--R
--RExamples of * from SquareMatrixCategory
--R
--R
--RExamples of * from SparseMultivariateTaylorSeries
--R
--R
--RExamples of * from StreamTaylorSeriesOperations
--R
--R
--RExamples of * from TubePlotTools
--R
--R
--RExamples of * from VectorCategory
--R
--R
--RExamples of * from XFreeAlgebra
--R
--R
--RExamples of * from XPolynomialRing
--R
--E 86

--S 87 of 127
)d op numberOfComponents
--R 
--R
--RThere are 2 exposed functions called numberOfComponents :
--R   [1]  -> NonNegativeInteger from D
--R            if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC 
--R            D2 and D4 has UPOLYC FRAC D3
--R   [2] D -> NonNegativeInteger from D if D has SPACEC D2 and D2 has 
--R            RING
--R
--RThere is one unexposed function called numberOfComponents :
--R   [1]  -> NonNegativeInteger from FunctionFieldCategory&(D2,D3,D4,D5)
--R            if D3 has UFD and D4 has UPOLYC D3 and D5 has UPOLYC FRAC 
--R            D4 and D2 has FFCAT(D3,D4,D5)
--R
--RExamples of numberOfComponents from FunctionFieldCategory&
--R
--RP0 := UnivariatePolynomial(x, Integer) 
--RP1 := UnivariatePolynomial(y, Fraction P0) 
--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
--RnumberOfComponents()$R
--R
--R
--RExamples of numberOfComponents from FunctionFieldCategory
--R
--RP0 := UnivariatePolynomial(x, Integer) 
--RP1 := UnivariatePolynomial(y, Fraction P0) 
--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
--RnumberOfComponents()$R
--R
--R
--RExamples of numberOfComponents from ThreeSpaceCategory
--R
--E 87

--S 88 of 127
)d op tree
--R 
--R
--RThere are 6 exposed functions called tree :
--R   [1] List D2 -> D from D if D2 has SETCAT and D has DSTRCAT D2
--R   [2] D1 -> D from D if D has DSTRCAT D1 and D1 has SETCAT
--R   [3] (D1,List D) -> D from D if D has DSTRCAT D1 and D1 has SETCAT
--R         
--R   [4] D1 -> Tree D1 from Tree D1 if D1 has SETCAT
--R   [5] List D2 -> Tree D2 from Tree D2 if D2 has SETCAT
--R   [6] (D1,List Tree D1) -> Tree D1 from Tree D1 if D1 has SETCAT
--R
--RExamples of tree from DesingTreeCategory
--R
--R
--RExamples of tree from Tree
--R
--Rtree 6
--R
--Rtree [1,2,3,4]
--R
--Rt1:=tree [1,2,3,4] 
--Rtree(5,[t1])
--R
--E 88

--S 89 of 127
)d op Aleph
--R 
--R
--RThere is one exposed function called Aleph :
--R   [1] NonNegativeInteger -> CardinalNumber from CardinalNumber
--R
--RExamples of Aleph from CardinalNumber
--R
--RA0:=Aleph 0
--R
--E 89

--S 90 of 127
)d op unit
--R 
--R
--RThere are 3 exposed functions called unit :
--R   [1] List Float -> DrawOption from DrawOption
--R   [2]  -> Union(D,"failed") from D
--R            if D has FINAALG D1 and D1 has INTDOM and D1 has COMRING
--R         
--R   [3] Factored D1 -> D1 from Factored D1 if D1 has INTDOM
--R
--RExamples of unit from DrawOption
--R
--R
--RExamples of unit from FiniteRankNonAssociativeAlgebra
--R
--R
--RExamples of unit from Factored
--R
--Rf:=x*y^3-3*x^2*y^2+3*x^3*y-x^4 
--Runit f 
--Rg:=makeFR(z,factorList f) 
--Runit g
--R
--E 90

--S 91 of 127
)d op frst
--R 
--R
--RThere is one exposed function called frst :
--R   [1] D -> D1 from D if D has LZSTAGG D1 and D1 has TYPE
--R
--RExamples of frst from LazyStreamAggregate
--R
--Rm:=[i for i in 0..] 
--Rfrst m
--R
--E 91

--S 92 of 127
)d op product
--R 
--R
--RThere are 4 exposed functions called product :
--R   [1] (CartesianTensor(D1,D2,D3),CartesianTensor(D1,D2,D3)) -> 
--R            CartesianTensor(D1,D2,D3)
--R            from CartesianTensor(D1,D2,D3)
--R            if D1: INT and D2: NNI and D3 has COMRING
--R   [2] (D,SegmentBinding D) -> D from D if D has COMBOPC
--R   [3] (D,Symbol) -> D from D if D has COMBOPC
--R   [4] (D,D) -> D from D
--R            if D has GRALG(D1,D2) and D1 has COMRING and D2 has ABELMON
--R            
--R
--RThere are 3 unexposed functions called product :
--R   [1] (D1,Symbol) -> D1 from CombinatorialFunction(D3,D1)
--R            if D3 has Join(OrderedSet,IntegralDomain) and D1 has FS D3
--R            
--R   [2] (D1,SegmentBinding D1) -> D1 from CombinatorialFunction(D3,D1)
--R            if D1 has FS D3 and D3 has Join(OrderedSet,IntegralDomain)
--R            
--R   [3] (XPBWPolynomial(D2,D3),XPBWPolynomial(D2,D3),NonNegativeInteger)
--R             -> XPBWPolynomial(D2,D3)
--R            from XPBWPolynomial(D2,D3) if D2 has ORDSET and D3 has 
--R            COMRING
--R
--RExamples of product from CartesianTensor
--R
--Rm:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]] 
--RTm:CartesianTensor(1,2,Integer):=m 
--Rn:SquareMatrix(2,Integer):=matrix [[2,3],[0,1]] 
--RTn:CartesianTensor(1,2,Integer):=n 
--RTmn:=product(Tm,Tn)
--R
--R
--RExamples of product from CombinatorialFunction
--R
--R
--RExamples of product from CombinatorialOpsCategory
--R
--R
--RExamples of product from GradedAlgebra
--R
--R
--RExamples of product from XPBWPolynomial
--R
--E 92

--S 93 of 127
)d op fill!
--R 
--R
--RThere are 2 exposed functions called fill! :
--R   [1] (D,D1) -> D from D
--R            if D has ARR2CAT(D1,D2,D3) and D1 has TYPE and D2 has FLAGG
--R            D1 and D3 has FLAGG D1
--R   [2] (D,D1) -> D from D
--R            if D has shallowlyMutable and D has IXAGG(D2,D1) and D2 has
--R            SETCAT and D1 has TYPE
--R
--RExamples of fill! from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,0) 
--Rfill!(arr,10)
--R
--R
--RExamples of fill! from IndexedAggregate
--R
--E 93

--S 94 of 127
)d op upperCase?
--R 
--R
--RThere is one exposed function called upperCase? :
--R   [1] Character -> Boolean from Character
--R
--RExamples of upperCase? from Character
--R
--Rchars := [char "a", char "A", char "X", char "8", char "+"] 
--R[upperCase? c for c in chars]
--R
--E 94

--S 95 of 127
)d op integralMatrixAtInfinity
--R 
--R
--RThere is one exposed function called integralMatrixAtInfinity :
--R   [1]  -> Matrix Fraction D3 from D
--R            if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC 
--R            D2 and D4 has UPOLYC FRAC D3
--R
--RExamples of integralMatrixAtInfinity from FunctionFieldCategory
--R
--RP0 := UnivariatePolynomial(x, Integer) 
--RP1 := UnivariatePolynomial(y, Fraction P0) 
--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
--RintegralMatrixAtInfinity()$R
--R
--E 95

--S 96 of 127
)d op finite?
--R 
--R
--RThere are 3 exposed functions called finite? :
--R   [1] CardinalNumber -> Boolean from CardinalNumber
--R   [2] OnePointCompletion D2 -> Boolean from OnePointCompletion D2
--R            if D2 has SETCAT
--R   [3] OrderedCompletion D2 -> Boolean from OrderedCompletion D2
--R            if D2 has SETCAT
--R
--RExamples of finite? from CardinalNumber
--R
--Rc2:=2::CardinalNumber 
--Rfinite? c2 
--RA0:=Aleph 0 
--Rfinite? A0
--R
--R
--RExamples of finite? from OnePointCompletion
--R
--R
--RExamples of finite? from OrderedCompletion
--R
--E 96

--S 97 of 127
)d op rank
--R 
--R
--RThere are 8 exposed functions called rank :
--R   [1] CartesianTensor(D2,D3,D4) -> NonNegativeInteger
--R            from CartesianTensor(D2,D3,D4)
--R            if D2: INT and D3: NNI and D4 has COMRING
--R   [2]  -> PositiveInteger from D if D has FINAALG D2 and D2 has 
--R            COMRING
--R   [3]  -> PositiveInteger from D
--R            if D has FINRALG(D2,D3) and D2 has COMRING and D3 has 
--R            UPOLYC D2
--R   [4] (Matrix D4,Vector D4) -> NonNegativeInteger
--R            from LinearSystemMatrixPackage1 D4 if D4 has FIELD
--R   [5] (D2,D3) -> NonNegativeInteger
--R            from LinearSystemMatrixPackage(D4,D5,D3,D2)
--R            if D4 has FIELD and D5 has FiniteLinearAggregate D4 with 
--R                 shallowlyMutableand D3 has FiniteLinearAggregate D4 
--R            with 
--R                 shallowlyMutableand D2 has MATCAT(D4,D5,D3)
--R   [6] D -> NonNegativeInteger from D
--R            if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG 
--R            D2 and D4 has FLAGG D2 and D2 has INTDOM
--R   [7] D2 -> NonNegativeInteger from MatrixLinearAlgebraFunctions(D3,D4
--R            ,D5,D2)
--R            if D3 has INTDOM and D3 has COMRING and D4 has FLAGG D3 and
--R            D5 has FLAGG D3 and D2 has MATCAT(D3,D4,D5)
--R   [8] D -> NonNegativeInteger from D
--R            if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5 has
--R            DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4) and D4 has INTDOM
--R            
--R
--RThere are 2 unexposed functions called rank :
--R   [1]  -> PositiveInteger from ComplexCategory&(D2,D3)
--R            if D3 has COMRING and D2 has COMPCAT D3
--R   [2] D2 -> NonNegativeInteger
--R            from InnerMatrixLinearAlgebraFunctions(D3,D4,D5,D2)
--R            if D3 has FIELD and D4 has FLAGG D3 and D5 has FLAGG D3 and
--R            D2 has MATCAT(D3,D4,D5)
--R
--RExamples of rank from CartesianTensor
--R
--RCT:=CARTEN(1,2,Integer) 
--Rt0:CT:=8 
--Rrank t0
--R
--R
--RExamples of rank from ComplexCategory&
--R
--R
--RExamples of rank from FiniteRankNonAssociativeAlgebra
--R
--R
--RExamples of rank from FiniteRankAlgebra
--R
--R
--RExamples of rank from InnerMatrixLinearAlgebraFunctions
--R
--R
--RExamples of rank from LinearSystemMatrixPackage1
--R
--R
--RExamples of rank from LinearSystemMatrixPackage
--R
--R
--RExamples of rank from MatrixCategory
--R
--Rrank matrix [[1,2,3],[4,5,6],[7,8,9]]
--R
--R
--RExamples of rank from MatrixLinearAlgebraFunctions
--R
--R
--RExamples of rank from RectangularMatrixCategory
--R
--E 97

--S 98 of 127
)d op numberOfComputedEntries
--R 
--R
--RThere is one exposed function called numberOfComputedEntries :
--R   [1] D -> NonNegativeInteger from D if D has LZSTAGG D2 and D2 has 
--R            TYPE
--R
--RExamples of numberOfComputedEntries from LazyStreamAggregate
--R
--Rm:=[i for i in 0..] 
--RnumberOfComputedEntries m
--R
--E 98

--S 99 of 127
)d op groebnerFactorize
--R 
--R
--RThere are 4 exposed functions called groebnerFactorize :
--R   [1] (List D6,List D6) -> List List D6
--R            from GroebnerFactorizationPackage(D3,D4,D5,D6)
--R            if D3 has Join(EuclideanDomain,CharacteristicZero) and D4 
--R            has OAMONS and D5 has ORDSET and D6 has POLYCAT(D3,D4,D5)
--R         
--R   [2] (List D7,List D7,Boolean) -> List List D7
--R            from GroebnerFactorizationPackage(D4,D5,D6,D7)
--R            if D4 has Join(EuclideanDomain,CharacteristicZero) and D5 
--R            has OAMONS and D6 has ORDSET and D7 has POLYCAT(D4,D5,D6)
--R         
--R   [3] List D6 -> List List D6 from GroebnerFactorizationPackage(D3,D4,
--R            D5,D6)
--R            if D3 has Join(EuclideanDomain,CharacteristicZero) and D4 
--R            has OAMONS and D5 has ORDSET and D6 has POLYCAT(D3,D4,D5)
--R         
--R   [4] (List D7,Boolean) -> List List D7
--R            from GroebnerFactorizationPackage(D4,D5,D6,D7)
--R            if D4 has Join(EuclideanDomain,CharacteristicZero) and D5 
--R            has OAMONS and D6 has ORDSET and D7 has POLYCAT(D4,D5,D6)
--R         
--R
--RExamples of groebnerFactorize from GroebnerFactorizationPackage
--R
--Rmfzn : SQMATRIX(6,DMP([x,y,z],Fraction INT)) := ++X [ [0,1,1,1,1,1], [1,0,1,8/3,x,8/3], [1,1,0,1,8/3,y], ++X [1,8/3,1,0,1,8/3], [1,x,8/3,1,0,1], [1,8/3,y,8/3,1,0] ] 
--Req := determinant mfzn 
--RgroebnerFactorize ++X [eq,eval(eq, [x,y,z],[y,z,x]), eval(eq,[x,y,z],[z,x,y])]
--R
--E 99

--S 100 of 127
)d op lowerCase
--R 
--R
--RThere are 3 exposed functions called lowerCase :
--R   [1]  -> CharacterClass from CharacterClass
--R   [2] Character -> Character from Character
--R   [3] D -> D from D if D has SRAGG
--R
--RExamples of lowerCase from CharacterClass
--R
--R
--RExamples of lowerCase from Character
--R
--Rchars := [char "a", char "A", char "X", char "8", char "+"] 
--R[lowerCase c for c in chars]
--R
--R
--RExamples of lowerCase from StringAggregate
--R
--E 100

--S 101 of 127
)d op showAllElements
--R 
--R
--RThere is one exposed function called showAllElements :
--R   [1] Stream D2 -> OutputForm from Stream D2
--R            if D2 has SETCAT and D2 has TYPE
--R
--RExamples of showAllElements from Stream
--R
--Rm:=[1,2,3,4,5,6,7,8,9,10,11,12] 
--Rn:=m::Stream(PositiveInteger) 
--RshowAllElements n
--R
--E 101

--S 102 of 127
)d op maxColIndex
--R 
--R
--RThere are 2 exposed functions called maxColIndex :
--R   [1] D -> Integer from D
--R            if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has FLAGG
--R            D2 and D4 has FLAGG D2
--R   [2] D -> Integer from D
--R            if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5 has
--R            DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4)
--R
--RExamples of maxColIndex from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,10) 
--RmaxColIndex(arr)
--R
--R
--RExamples of maxColIndex from RectangularMatrixCategory
--R
--E 102

--S 103 of 127
)d op minRowIndex
--R 
--R
--RThere are 2 exposed functions called minRowIndex :
--R   [1] D -> Integer from D
--R            if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has FLAGG
--R            D2 and D4 has FLAGG D2
--R   [2] D -> Integer from D
--R            if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5 has
--R            DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4)
--R
--RExamples of minRowIndex from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,10) 
--RminRowIndex(arr)
--R
--R
--RExamples of minRowIndex from RectangularMatrixCategory
--R
--E 103

--S 104 of 127
)d op space
--R 
--R
--RThere are 2 exposed functions called space :
--R   [1]  -> Character from Character
--R   [2] ThreeSpace DoubleFloat -> DrawOption from DrawOption
--R
--RThere is one unexposed function called space :
--R   [1] List DrawOption -> ThreeSpace DoubleFloat from 
--R            DrawOptionFunctions0
--R
--RExamples of space from Character
--R
--Rspace()
--R
--R
--RExamples of space from DrawOptionFunctions0
--R
--R
--RExamples of space from DrawOption
--R
--E 104

--S 105 of 127
)d op remove
--R 
--R
--RThere are 5 exposed functions called remove :
--R   [1] (D1,D) -> D from D
--R            if D has finiteAggregate and D has CLAGG D1 and D1 has TYPE
--R            and D1 has SETCAT
--R   [2] ((D2 -> Boolean),D) -> D from D
--R            if D has finiteAggregate and D has CLAGG D2 and D2 has TYPE
--R            
--R   [3] ((D2 -> Boolean),D) -> D from D if D has LZSTAGG D2 and D2 has 
--R            TYPE
--R   [4] ((D3 -> Boolean),Multiset D3,Integer) -> Multiset D3 from 
--R            Multiset D3
--R            if D3 has SETCAT
--R   [5] (D1,Multiset D1,Integer) -> Multiset D1 from Multiset D1
--R            if D1 has SETCAT
--R
--RThere is one unexposed function called remove :
--R   [1] (SplittingNode(D2,D3),SplittingTree(D2,D3)) -> SplittingTree(D2,
--R            D3)
--R            from SplittingTree(D2,D3)
--R            if D2 has Join(SetCategory,Aggregate) and D3 has Join(
--R            SetCategory,Aggregate)
--R
--RExamples of remove from Collection
--R
--R
--RExamples of remove from LazyStreamAggregate
--R
--Rm:=[i for i in 1..] 
--Rf(i:PositiveInteger):Boolean == even? i 
--Rremove(f,m)
--R
--R
--RExamples of remove from Multiset
--R
--R
--RExamples of remove from SplittingTree
--R
--E 105

--S 106 of 127
)d op factors
--R 
--R
--RThere is one exposed function called factors :
--R   [1] Factored D2 -> List Record(factor: D2,exponent: Integer)
--R            from Factored D2 if D2 has INTDOM
--R
--RThere are 3 unexposed functions called factors :
--R   [1] FreeGroup D2 -> List Record(gen: D2,exp: Integer) from FreeGroup
--R            D2
--R            if D2 has SETCAT
--R   [2] FreeMonoid D2 -> List Record(gen: D2,exp: NonNegativeInteger)
--R            from FreeMonoid D2 if D2 has SETCAT
--R   [3] OrderedFreeMonoid D2 -> List Record(gen: D2,exp: 
--R            NonNegativeInteger)
--R            from OrderedFreeMonoid D2 if D2 has ORDSET
--R
--RExamples of factors from FreeGroup
--R
--R
--RExamples of factors from FreeMonoid
--R
--R
--RExamples of factors from Factored
--R
--Rf:=x*y^3-3*x^2*y^2+3*x^3*y-x^4 
--Rfactors f 
--Rg:=makeFR(z,factorList f) 
--Rfactors g
--R
--R
--RExamples of factors from OrderedFreeMonoid
--R
--Rm1:=(x*y*y*z)$OFMONOID(Symbol) 
--Rfactors m1
--R
--E 106

--S 107 of 127
)d op output
--R 
--R
--RThere are 4 exposed functions called output :
--R   [1] String -> Void from OutputPackage
--R   [2] OutputForm -> Void from OutputPackage
--R   [3] (String,OutputForm) -> Void from OutputPackage
--R   [4] (Integer,Stream D3) -> Void from Stream D3
--R            if D3 has SETCAT and D3 has TYPE
--R
--RExamples of output from OutputPackage
--R
--R
--RExamples of output from Stream
--R
--Rm:=[1,2,3] 
--Rn:=repeating(m) 
--Routput(5,n)
--R
--E 107

--S 108 of 127
)d op binarySearchTree
--R 
--R
--RThere is one exposed function called binarySearchTree :
--R   [1] List D2 -> BinarySearchTree D2 from BinarySearchTree D2 if D2 
--R            has ORDSET
--R
--RExamples of binarySearchTree from BinarySearchTree
--R
--RbinarySearchTree [1,2,3,4]
--R
--E 108

--S 109 of 127
)d op char
--R 
--R
--RThere are 2 exposed functions called char :
--R   [1] String -> Character from Character
--R   [2] Integer -> Character from Character
--R
--RExamples of char from Character
--R
--R[char c for c in ["a","A","X","8","+"]]
--R
--R[char c for c in [97,65,88,56,43]]
--R
--E 109

--S 110 of 127
)d op shrinkable
--R 
--R
--RThere is one exposed function called shrinkable :
--R   [1] Boolean -> Boolean from FlexibleArray D2 if D2 has TYPE
--R
--RThere is one unexposed function called shrinkable :
--R   [1] Boolean -> Boolean from IndexedFlexibleArray(D2,D3)
--R            if D2 has TYPE and D3: INT
--R
--RExamples of shrinkable from FlexibleArray
--R
--R
--RExamples of shrinkable from IndexedFlexibleArray
--R
--RT1:=IndexedFlexibleArray(Integer,20) 
--Rshrinkable(false)$T1
--R
--E 110

--S 111 of 127
)d op rst
--R 
--R
--RThere is one exposed function called rst :
--R   [1] D -> D from D if D has LZSTAGG D1 and D1 has TYPE
--R
--RExamples of rst from LazyStreamAggregate
--R
--Rm:=[i for i in 0..] 
--Rrst m
--R
--E 111

--S 112 of 127
)d op flexibleArray
--R 
--R
--RThere is one exposed function called flexibleArray :
--R   [1] List D2 -> FlexibleArray D2 from FlexibleArray D2 if D2 has TYPE
--R            
--R
--RThere is one unexposed function called flexibleArray :
--R   [1] List D2 -> IndexedFlexibleArray(D2,D3) from IndexedFlexibleArray
--R            (D2,D3)
--R            if D2 has TYPE and D3: INT
--R
--RExamples of flexibleArray from FlexibleArray
--R
--R
--RExamples of flexibleArray from IndexedFlexibleArray
--R
--RT1:=IndexedFlexibleArray(Integer,20) 
--RflexibleArray([i for i in 1..10])$T1
--R
--E 112

--S 113 of 127
)d op setelt
--R 
--R
--RThere are 14 exposed functions called setelt :
--R   [1] (D,Integer,D1) -> D1 from D if D has AFSPCAT D1 and D1 has FIELD
--R            
--R   [2] (D,Integer,Integer,D1) -> D1 from D
--R            if D has ARR2CAT(D1,D3,D4) and D1 has TYPE and D3 has FLAGG
--R            D1 and D4 has FLAGG D1
--R   [3] (D,right,D) -> D from D
--R            if D has shallowlyMutable and D has BRAGG D2 and D2 has 
--R            TYPE
--R   [4] (D,left,D) -> D from D
--R            if D has shallowlyMutable and D has BRAGG D2 and D2 has 
--R            TYPE
--R   [5] (D,D2,D1) -> D1 from D
--R            if D has shallowlyMutable and D has ELTAGG(D2,D1) and D2 
--R            has SETCAT and D1 has TYPE
--R   [6] (Library,Symbol,Any) -> Any from Library
--R   [7] (D,UniversalSegment Integer,D1) -> D1 from D
--R            if D has shallowlyMutable and D has LNAGG D1 and D1 has 
--R            TYPE
--R   [8] (D,List Integer,List Integer,D) -> D from D
--R            if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG 
--R            D2 and D4 has FLAGG D2
--R   [9] (D,Integer,D1) -> D1 from D if D has PRSPCAT D1 and D1 has FIELD
--R            
--R   [10] (D,value,D1) -> D1 from D
--R            if D has shallowlyMutable and D has RCAGG D1 and D1 has 
--R            TYPE
--R   [11] (D,D2,D1) -> D1 from D
--R            if D has TBAGG(D2,D1) and D2 has SETCAT and D1 has SETCAT
--R         
--R   [12] (D,last,D1) -> D1 from D
--R            if D has shallowlyMutable and D has URAGG D1 and D1 has 
--R            TYPE
--R   [13] (D,rest,D) -> D from D
--R            if D has shallowlyMutable and D has URAGG D2 and D2 has 
--R            TYPE
--R   [14] (D,first,D1) -> D1 from D
--R            if D has shallowlyMutable and D has URAGG D1 and D1 has 
--R            TYPE
--R
--RThere is one unexposed function called setelt :
--R   [1] (Reference D1,D1) -> D1 from Reference D1 if D1 has TYPE
--R
--RExamples of setelt from AffineSpaceCategory
--R
--R
--RExamples of setelt from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,0) 
--Rsetelt(arr,1,1,17)
--R
--R
--RExamples of setelt from BinaryRecursiveAggregate
--R
--R
--RExamples of setelt from EltableAggregate
--R
--R
--RExamples of setelt from Library
--R
--R
--RExamples of setelt from LinearAggregate
--R
--R
--RExamples of setelt from MatrixCategory
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--Rsetelt(m,3,3,10)
--R
--R
--RExamples of setelt from ProjectiveSpaceCategory
--R
--R
--RExamples of setelt from RecursiveAggregate
--R
--R
--RExamples of setelt from Reference
--R
--R
--RExamples of setelt from TableAggregate
--R
--R
--RExamples of setelt from UnaryRecursiveAggregate
--R
--E 113

--S 114 of 127
)d op cyclicParents
--R 
--R
--RThere is one exposed function called cyclicParents :
--R   [1] Tree D2 -> List Tree D2 from Tree D2 if D2 has SETCAT
--R
--RExamples of cyclicParents from Tree
--R
--Rt1:=tree [1,2,3,4] 
--RcyclicParents t1
--R
--E 114

--S 115 of 127
)d op explicitEntries?
--R 
--R
--RThere is one exposed function called explicitEntries? :
--R   [1] D -> Boolean from D if D has LZSTAGG D2 and D2 has TYPE
--R
--RExamples of explicitEntries? from LazyStreamAggregate
--R
--Rm:=[i for i in 0..] 
--RexplicitEntries? m
--R
--E 115

--S 116 of 127
)d op column
--R 
--R
--RThere are 2 exposed functions called column :
--R   [1] (D,Integer) -> D1 from D
--R            if D has ARR2CAT(D3,D4,D1) and D3 has TYPE and D4 has FLAGG
--R            D3 and D1 has FLAGG D3
--R   [2] (D,Integer) -> D1 from D
--R            if D has RMATCAT(D3,D4,D5,D6,D1) and D5 has RING and D6 has
--R            DIRPCAT(D4,D5) and D1 has DIRPCAT(D3,D5)
--R
--RExamples of column from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,10) 
--Rcolumn(arr,1)
--R
--R
--RExamples of column from RectangularMatrixCategory
--R
--E 116

--S 117 of 127
)d op reduce
--R 
--R
--RThere are 21 exposed functions called reduce :
--R   [1] AlgebraicNumber -> AlgebraicNumber from AlgebraicNumber
--R   [2] (((D4,D1) -> D1),OneDimensionalArray D4,D1) -> D1
--R            from OneDimensionalArrayFunctions2(D4,D1)
--R            if D4 has TYPE and D1 has TYPE
--R   [3] (((D1,D1) -> D1),D,D1,D1) -> D1 from D
--R            if D1 has SETCAT and D has finiteAggregate and D has CLAGG 
--R            D1 and D1 has TYPE
--R   [4] (((D1,D1) -> D1),D,D1) -> D1 from D
--R            if D has finiteAggregate and D has CLAGG D1 and D1 has TYPE
--R            
--R   [5] (((D1,D1) -> D1),D) -> D1 from D
--R            if D has finiteAggregate and D has CLAGG D1 and D1 has TYPE
--R            
--R   [6] (((D5,D1) -> D1),DirectProduct(D4,D5),D1) -> D1
--R            from DirectProductFunctions2(D4,D5,D1)
--R            if D4: NNI and D5 has TYPE and D1 has TYPE
--R   [7] Expression D1 -> Expression D1 from Expression D1
--R            if D1 has INTDOM and D1 has ORDSET
--R   [8] D -> D from D
--R            if D has FDIVCAT(D1,D2,D3,D4) and D1 has FIELD and D2 has 
--R            UPOLYC D1 and D3 has UPOLYC FRAC D2 and D4 has FFCAT(D1,D2,
--R            D3)
--R   [9] (((D4,D1) -> D1),D3,D1) -> D1
--R            from FiniteLinearAggregateFunctions2(D4,D3,D1,D5)
--R            if D4 has TYPE and D1 has TYPE and D3 has FLAGG D4 and D5 
--R            has FLAGG D1
--R   [10] (((D4,D1) -> D1),D3,D1) -> D1
--R            from FiniteSetAggregateFunctions2(D4,D3,D1,D5)
--R            if D4 has SETCAT and D1 has SETCAT and D3 has FSAGG D4 and 
--R            D5 has FSAGG D1
--R   [11] (((D4,D1) -> D1),List D4,D1) -> D1 from ListFunctions2(D4,D1)
--R            if D4 has TYPE and D1 has TYPE
--R   [12] (((D5,D2) -> D2),D4,D2) -> D2
--R            from MatrixCategoryFunctions2(D5,D6,D7,D4,D2,D8,D9,D1)
--R            if D5 has RING and D2 has RING and D6 has FLAGG D5 and D7 
--R            has FLAGG D5 and D8 has FLAGG D2 and D9 has FLAGG D2 and D4
--R            has MATCAT(D5,D6,D7) and D1 has MATCAT(D2,D8,D9)
--R   [13] Fraction D3 -> Union(D,"failed") from D
--R            if D3 has UPOLYC D2 and D2 has FIELD and D2 has COMRING and
--R            D has MONOGEN(D2,D3)
--R   [14] D1 -> D from D
--R            if D2 has COMRING and D has MONOGEN(D2,D1) and D1 has 
--R            UPOLYC D2
--R   [15] SparseUnivariatePolynomial D -> D from D if D has PACPERC
--R   [16] List D -> Divisor D from D
--R            if D has PLACESC(D3,D4) and D3 has FIELD and D4 has LOCPOWC
--R            D3
--R   [17] (((D4,D1) -> D1),PrimitiveArray D4,D1) -> D1
--R            from PrimitiveArrayFunctions2(D4,D1)
--R            if D4 has TYPE and D1 has TYPE
--R   [18] (((D9,D4) -> D4),D6,D4) -> D4
--R            from RectangularMatrixCategoryFunctions2(D7,D8,D9,D10,D11,
--R            D6,D4,D1,D2,D3)
--R            if D9 has RING and D4 has RING and D7: NNI and D8: NNI and 
--R            D10 has DIRPCAT(D8,D9) and D11 has DIRPCAT(D7,D9) and D1 
--R            has DIRPCAT(D8,D4) and D2 has DIRPCAT(D7,D4) and D6 has 
--R            RMATCAT(D7,D8,D9,D10,D11) and D3 has RMATCAT(D7,D8,D4,D1,D2
--R            )
--R   [19] (D1,((D4,D1) -> D1),Stream D4) -> D1 from StreamFunctions2(D4,
--R            D1)
--R            if D4 has TYPE and D1 has TYPE
--R   [20] (D1,D,((D1,D1) -> D1),((D1,D1) -> Boolean)) -> D1 from D
--R            if D has TSETCAT(D4,D5,D6,D1) and D4 has INTDOM and D5 has 
--R            OAMONS and D6 has ORDSET and D1 has RPOLCAT(D4,D5,D6)
--R   [21] (((D4,D1) -> D1),Vector D4,D1) -> D1 from VectorFunctions2(D4,
--R            D1)
--R            if D4 has TYPE and D1 has TYPE
--R
--RThere are 7 unexposed functions called reduce :
--R   [1] SparseUnivariatePolynomial D3 -> Record(pol: 
--R            SparseUnivariatePolynomial D3,deg: PositiveInteger)
--R            from DegreeReductionPackage(D3,D4)
--R            if D3 has RING and D4 has Join(IntegralDomain,OrderedSet)
--R         
--R   [2] (D1,D2) -> EuclideanModularRing(D3,D1,D2,D4,D5,D6)
--R            from EuclideanModularRing(D3,D1,D2,D4,D5,D6)
--R            if D3 has COMRING and D1 has UPOLYC D3 and D2 has ABELMON 
--R            and D4: ((D1,D2) -> D1) and D5: ((D2,D2) -> Union(D2,
--R            "failed")) and D6: ((D1,D1,D2) -> Union(D1,"failed"))
--R   [3] InnerAlgebraicNumber -> InnerAlgebraicNumber from 
--R            InnerAlgebraicNumber
--R   [4] (D1,D2) -> ModularField(D1,D2,D3,D4,D5)
--R            from ModularField(D1,D2,D3,D4,D5)
--R            if D1 has COMRING and D2 has ABELMON and D3: ((D1,D2) -> D1
--R            ) and D4: ((D2,D2) -> Union(D2,"failed")) and D5: ((D1,D1,
--R            D2) -> Union(D1,"failed"))
--R   [5] D1 -> ModMonic(D2,D1) from ModMonic(D2,D1)
--R            if D2 has RING and D1 has UPOLYC D2
--R   [6] (D1,D2) -> ModularRing(D1,D2,D3,D4,D5) from ModularRing(D1,D2,D3
--R            ,D4,D5)
--R            if D1 has COMRING and D2 has ABELMON and D3: ((D1,D2) -> D1
--R            ) and D4: ((D2,D2) -> Union(D2,"failed")) and D5: ((D1,D1,
--R            D2) -> Union(D1,"failed"))
--R   [7] D1 -> ResidueRing(D2,D3,D4,D1,D5) from ResidueRing(D2,D3,D4,D1,
--R            D5)
--R            if D2 has FIELD and D3 has OAMONS and D4 has ORDSET and D1 
--R            has POLYCAT(D2,D3,D4) and D5: LIST D1
--R
--RExamples of reduce from AlgebraicNumber
--R
--R
--RExamples of reduce from OneDimensionalArrayFunctions2
--R
--RT1:=OneDimensionalArrayFunctions2(Integer,Integer) 
--Radder(a:Integer,b:Integer):Integer == a+b 
--Rreduce(adder,[i for i in 1..10],0)$T1
--R
--R
--RExamples of reduce from Collection
--R
--Rreduce(+,[C[i]*x**i for i in 1..5])
--R
--R
--RExamples of reduce from DegreeReductionPackage
--R
--R
--RExamples of reduce from DirectProductFunctions2
--R
--R
--RExamples of reduce from EuclideanModularRing
--R
--R
--RExamples of reduce from Expression
--R
--R
--RExamples of reduce from FiniteDivisorCategory
--R
--R
--RExamples of reduce from FiniteLinearAggregateFunctions2
--R
--R
--RExamples of reduce from FiniteSetAggregateFunctions2
--R
--R
--RExamples of reduce from InnerAlgebraicNumber
--R
--R
--RExamples of reduce from ListFunctions2
--R
--R
--RExamples of reduce from MatrixCategoryFunctions2
--R
--R
--RExamples of reduce from ModularField
--R
--R
--RExamples of reduce from ModMonic
--R
--R
--RExamples of reduce from ModularRing
--R
--R
--RExamples of reduce from MonogenicAlgebra
--R
--R
--RExamples of reduce from PseudoAlgebraicClosureOfPerfectFieldCategory
--R
--R
--RExamples of reduce from PlacesCategory
--R
--R
--RExamples of reduce from PrimitiveArrayFunctions2
--R
--RT1:=PrimitiveArrayFunctions2(Integer,Integer) 
--Radder(a:Integer,b:Integer):Integer == a+b 
--Rreduce(adder,[i for i in 1..10],0)$T1
--R
--R
--RExamples of reduce from ResidueRing
--R
--R
--RExamples of reduce from RectangularMatrixCategoryFunctions2
--R
--R
--RExamples of reduce from StreamFunctions2
--R
--Rm:=[i for i in 1..300]::Stream(Integer) 
--Rf(i:Integer,j:Integer):Integer==i+j 
--Rreduce(1,f,m)
--R
--R
--RExamples of reduce from TriangularSetCategory
--R
--R
--RExamples of reduce from VectorFunctions2
--R
--E 117

--S 118 of 127
)d op new
--R 
--R
--RThere are 7 exposed functions called new :
--R   [1] (NonNegativeInteger,NonNegativeInteger,D2) -> D from D
--R            if D2 has TYPE and D has ARR2CAT(D2,D3,D4) and D3 has FLAGG
--R            D2 and D4 has FLAGG D2
--R   [2] (String,String,String) -> D from D if D has FNCAT
--R   [3]  -> ScriptFormulaFormat from ScriptFormulaFormat
--R   [4] (NonNegativeInteger,D2) -> D from D if D has LNAGG D2 and D2 has
--R            TYPE
--R   [5] Symbol -> Symbol from Symbol
--R   [6]  -> Symbol from Symbol
--R   [7]  -> TexFormat from TexFormat
--R
--RThere are 4 unexposed functions called new :
--R   [1]  -> SubSpaceComponentProperty from SubSpaceComponentProperty
--R   [2]  -> PatternMatchListResult(D1,D2,D3)
--R            from PatternMatchListResult(D1,D2,D3)
--R            if D2 has SETCAT and D1 has SETCAT and D3 has LSAGG D2
--R   [3]  -> PatternMatchResult(D1,D2) from PatternMatchResult(D1,D2)
--R            if D1 has SETCAT and D2 has SETCAT
--R   [4]  -> SubSpace(D1,D2) from SubSpace(D1,D2) if D1: PI and D2 has 
--R            RING
--R
--RExamples of new from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,0)
--R
--R
--RExamples of new from SubSpaceComponentProperty
--R
--R
--RExamples of new from FileNameCategory
--R
--R
--RExamples of new from ScriptFormulaFormat
--R
--R
--RExamples of new from LinearAggregate
--R
--R
--RExamples of new from PatternMatchListResult
--R
--R
--RExamples of new from PatternMatchResult
--R
--R
--RExamples of new from SubSpace
--R
--R
--RExamples of new from Symbol
--R
--R
--RExamples of new from TexFormat
--R
--E 118

--S 119 of 127
)d op insertRoot!
--R 
--R
--RThere is one exposed function called insertRoot! :
--R   [1] (D1,BinarySearchTree D1) -> BinarySearchTree D1
--R            from BinarySearchTree D1 if D1 has ORDSET
--R
--RExamples of insertRoot! from BinarySearchTree
--R
--Rt1:=binarySearchTree [1,2,3,4] 
--RinsertRoot!(5,t1)
--R
--E 119

--S 120 of 127
)d op maxRowIndex
--R 
--R
--RThere are 2 exposed functions called maxRowIndex :
--R   [1] D -> Integer from D
--R            if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has FLAGG
--R            D2 and D4 has FLAGG D2
--R   [2] D -> Integer from D
--R            if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5 has
--R            DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4)
--R
--RExamples of maxRowIndex from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,10) 
--RmaxRowIndex(arr)
--R
--R
--RExamples of maxRowIndex from RectangularMatrixCategory
--R
--E 120

--S 121 of 127
)d op escape
--R 
--R
--RThere is one exposed function called escape :
--R   [1]  -> Character from Character
--R
--RExamples of escape from Character
--R
--Rescape()
--R
--E 121

--S 122 of 127
)d op nthExponent
--R 
--R
--RThere is one exposed function called nthExponent :
--R   [1] (Factored D2,Integer) -> Integer from Factored D2 if D2 has 
--R            INTDOM
--R
--RExamples of nthExponent from Factored
--R
--Ra:=factor 9720000 
--RnthExponent(a,2)
--R
--E 122

--S 123 of 127
)d op parts
--R 
--R
--RThere are 7 exposed functions called parts :
--R   [1] D -> List D2 from D
--R            if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has FLAGG
--R            D2 and D4 has FLAGG D2
--R   [2] ArrayStack D2 -> List D2 from ArrayStack D2
--R            if $ has finiteAggregate and D2 has SETCAT
--R   [3] Dequeue D2 -> List D2 from Dequeue D2
--R            if $ has finiteAggregate and D2 has SETCAT
--R   [4] Heap D2 -> List D2 from Heap D2
--R            if $ has finiteAggregate and D2 has ORDSET
--R   [5] D -> List D2 from D
--R            if D has finiteAggregate and D has HOAGG D2 and D2 has TYPE
--R            
--R   [6] Queue D2 -> List D2 from Queue D2
--R            if $ has finiteAggregate and D2 has SETCAT
--R   [7] Stack D2 -> List D2 from Stack D2
--R            if $ has finiteAggregate and D2 has SETCAT
--R
--RExamples of parts from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,10) 
--Rparts(arr)
--R
--R
--RExamples of parts from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Rparts a
--R
--R
--RExamples of parts from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rparts a
--R
--R
--RExamples of parts from Heap
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--Rparts a
--R
--R
--RExamples of parts from HomogeneousAggregate
--R
--R
--RExamples of parts from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rparts a
--R
--R
--RExamples of parts from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rparts a
--R
--E 123

--S 124 of 127
)d op elt
--R 
--R
--RThere are 50 exposed functions called elt :
--R   [1] (D,Integer) -> D1 from D if D has AFSPCAT D1 and D1 has FIELD
--R         
--R   [2] (D,Integer,Integer,D1) -> D1 from D
--R            if D has ARR2CAT(D1,D3,D4) and D1 has TYPE and D3 has FLAGG
--R            D1 and D4 has FLAGG D1
--R   [3] (D,Integer,Integer) -> D1 from D
--R            if D has ARR2CAT(D1,D3,D4) and D3 has FLAGG D1 and D4 has 
--R            FLAGG D1 and D1 has TYPE
--R   [4] (D,right) -> D from D if D has BRAGG D2 and D2 has TYPE
--R   [5] (D,left) -> D from D if D has BRAGG D2 and D2 has TYPE
--R   [6] (CartesianTensor(D3,D4,D1),List Integer) -> D1
--R            from CartesianTensor(D3,D4,D1)
--R            if D1 has COMRING and D3: INT and D4: NNI
--R   [7] (CartesianTensor(D3,D4,D1),Integer,Integer,Integer,Integer) -> 
--R            D1
--R            from CartesianTensor(D3,D4,D1)
--R            if D1 has COMRING and D3: INT and D4: NNI
--R   [8] (CartesianTensor(D3,D4,D1),Integer,Integer,Integer) -> D1
--R            from CartesianTensor(D3,D4,D1)
--R            if D1 has COMRING and D3: INT and D4: NNI
--R   [9] (CartesianTensor(D3,D4,D1),Integer,Integer) -> D1
--R            from CartesianTensor(D3,D4,D1)
--R            if D1 has COMRING and D3: INT and D4: NNI
--R   [10] (CartesianTensor(D3,D4,D1),Integer) -> D1
--R            from CartesianTensor(D3,D4,D1)
--R            if D1 has COMRING and D3: INT and D4: NNI
--R   [11] CartesianTensor(D2,D3,D1) -> D1 from CartesianTensor(D2,D3,D1)
--R            if D1 has COMRING and D2: INT and D3: NNI
--R   [12] (Database D3,Symbol) -> DataList String from Database D3
--R            if D3 has OrderedSet with 
--R               ?.? : (%,Symbol) -> String
--R               display : % -> Void
--R               fullDisplay : % -> Void
--R   [13] (Database D2,QueryEquation) -> Database D2 from Database D2
--R            if D2 has OrderedSet with 
--R               ?.? : (%,Symbol) -> String
--R               display : % -> Void
--R               fullDisplay : % -> Void
--R   [14] (DataList D3,count) -> NonNegativeInteger from DataList D3
--R            if D3 has ORDSET
--R   [15] (DataList D2,sort) -> DataList D2 from DataList D2 if D2 has 
--R            ORDSET
--R   [16] (DataList D2,unique) -> DataList D2 from DataList D2 if D2 has 
--R            ORDSET
--R   [17] (D,D2) -> D1 from D
--R            if D has ELTAB(D2,D1) and D2 has SETCAT and D1 has TYPE
--R   [18] (D,D2,D1) -> D1 from D
--R            if D has ELTAGG(D2,D1) and D2 has SETCAT and D1 has TYPE
--R         
--R   [19] (BasicOperator,List D) -> D from D if D has ES
--R   [20] (BasicOperator,D,D,D,D) -> D from D if D has ES
--R   [21] (BasicOperator,D,D,D) -> D from D if D has ES
--R   [22] (BasicOperator,D,D) -> D from D if D has ES
--R   [23] (BasicOperator,D) -> D from D if D has ES
--R   [24] (D,D1,D1) -> D1 from D
--R            if D has FFCAT(D1,D2,D3) and D1 has UFD and D2 has UPOLYC 
--R            D1 and D3 has UPOLYC FRAC D2
--R   [25] (D,Integer) -> D1 from D if D has FRNAALG D1 and D1 has COMRING
--R            
--R   [26] (IndexCard,Symbol) -> String from IndexCard
--R   [27] (Library,Symbol) -> Any from Library
--R   [28] (D,UniversalSegment Integer) -> D from D
--R            if D has LNAGG D2 and D2 has TYPE
--R   [29] (ThreeDimensionalMatrix D1,NonNegativeInteger,
--R            NonNegativeInteger,NonNegativeInteger) -> D1
--R            from ThreeDimensionalMatrix D1 if D1 has SETCAT
--R   [30] (D,List Integer,List Integer) -> D from D
--R            if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG 
--R            D2 and D4 has FLAGG D2
--R   [31] (D,D1) -> D1 from D if D has PERMCAT D1 and D1 has SETCAT
--R   [32] (PermutationGroup D3,NonNegativeInteger) -> Permutation D3
--R            from PermutationGroup D3 if D3 has SETCAT
--R   [33] (D,Integer) -> D1 from D
--R            if D has PLACESC(D1,D3) and D3 has LOCPOWC D1 and D1 has 
--R            FIELD
--R   [34] (D,Integer) -> D1 from D if D has PRSPCAT D1 and D1 has FIELD
--R         
--R   [35] (QuadraticForm(D3,D1),DirectProduct(D3,D1)) -> D1
--R            from QuadraticForm(D3,D1) if D3: PI and D1 has FIELD
--R   [36] (D,value) -> D1 from D if D has RCAGG D1 and D1 has TYPE
--R   [37] (D,Integer,Integer,D1) -> D1 from D
--R            if D has RMATCAT(D3,D4,D1,D5,D6) and D1 has RING and D5 has
--R            DIRPCAT(D4,D1) and D6 has DIRPCAT(D3,D1)
--R   [38] (D,Integer,Integer) -> D1 from D
--R            if D has RMATCAT(D3,D4,D1,D5,D6) and D5 has DIRPCAT(D4,D1) 
--R            and D6 has DIRPCAT(D3,D1) and D1 has RING
--R   [39] (RewriteRule(D3,D4,D1),D1,PositiveInteger) -> D1
--R            from RewriteRule(D3,D4,D1)
--R            if D3 has SETCAT and D4 has Join(Ring,PatternMatchable D3,
--R            OrderedSet,ConvertibleTo Pattern D3) and D1 has Join(
--R            FunctionSpace D4,PatternMatchable D3,ConvertibleTo Pattern 
--R            D3)
--R   [40] (Ruleset(D3,D4,D1),D1,PositiveInteger) -> D1 from Ruleset(D3,D4
--R            ,D1)
--R            if D3 has SETCAT and D4 has Join(Ring,PatternMatchable D3,
--R            OrderedSet,ConvertibleTo Pattern D3) and D1 has Join(
--R            FunctionSpace D4,PatternMatchable D3,ConvertibleTo Pattern 
--R            D3)
--R   [41] (D,List Integer) -> D from D
--R            if D has SEXCAT(D2,D3,D4,D5,D6) and D2 has SETCAT and D3 
--R            has SETCAT and D4 has SETCAT and D5 has SETCAT and D6 has 
--R            SETCAT
--R   [42] (D,Integer) -> D from D
--R            if D has SEXCAT(D2,D3,D4,D5,D6) and D2 has SETCAT and D3 
--R            has SETCAT and D4 has SETCAT and D5 has SETCAT and D6 has 
--R            SETCAT
--R   [43] (D,D) -> D from D if D has SRAGG
--R   [44] (Symbol,List OutputForm) -> Symbol from Symbol
--R   [45] (Fraction D,D1) -> D1 from D
--R            if D has UPOLYC D1 and D1 has RING and D1 has FIELD
--R   [46] (Fraction D,Fraction D) -> Fraction D from D
--R            if D has UPOLYC D2 and D2 has RING and D2 has INTDOM
--R   [47] (D,D2) -> D1 from D
--R            if D has UPSCAT(D1,D2) and D2 has OAMON and D1 has RING
--R   [48] (D,last) -> D1 from D if D has URAGG D1 and D1 has TYPE
--R   [49] (D,rest) -> D from D if D has URAGG D2 and D2 has TYPE
--R   [50] (D,first) -> D1 from D if D has URAGG D1 and D1 has TYPE
--R
--RThere are 4 unexposed functions called elt :
--R   [1] (EuclideanModularRing(D2,D1,D3,D4,D5,D6),D1) -> D1
--R            from EuclideanModularRing(D2,D1,D3,D4,D5,D6)
--R            if D2 has COMRING and D1 has UPOLYC D2 and D3 has ABELMON 
--R            and D4: ((D1,D3) -> D1) and D5: ((D3,D3) -> Union(D3,
--R            "failed")) and D6: ((D1,D1,D3) -> Union(D1,"failed"))
--R   [2] (OutputForm,List OutputForm) -> OutputForm from OutputForm
--R   [3] (BasicOperator,List Pattern D3) -> Pattern D3 from Pattern D3
--R            if D3 has SETCAT
--R   [4] Reference D1 -> D1 from Reference D1 if D1 has TYPE
--R
--RExamples of elt from AffineSpaceCategory
--R
--R
--RExamples of elt from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,10) 
--Relt(arr,1,1,6) 
--Relt(arr,1,10,6)
--R
--Rarr : ARRAY2 INT := new(5,4,10) 
--Relt(arr,1,1)
--R
--R
--RExamples of elt from BinaryRecursiveAggregate
--R
--R
--RExamples of elt from CartesianTensor
--R
--Rv:=[2,3] 
--Rtv:CartesianTensor(1,2,Integer):=v 
--Rtm:CartesianTensor(1,2,Integer):=[tv,tv] 
--Rtn:CartesianTensor(1,2,Integer):=[tm,tm] 
--Rtp:CartesianTensor(1,2,Integer):=[tn,tn] 
--Rtq:CartesianTensor(1,2,Integer):=[tp,tp] 
--Relt(tq,[2,2,2,2,2])
--R
--Rv:=[2,3] 
--Rtv:CartesianTensor(1,2,Integer):=v 
--Rtm:CartesianTensor(1,2,Integer):=[tv,tv] 
--Rtn:CartesianTensor(1,2,Integer):=[tm,tm] 
--Rtp:CartesianTensor(1,2,Integer):=[tn,tn] 
--Relt(tp,2,2,2,2) 
--Rtp[2,2,2,2]
--R
--Rv:=[2,3] 
--Rtv:CartesianTensor(1,2,Integer):=v 
--Rtm:CartesianTensor(1,2,Integer):=[tv,tv] 
--Rtn:CartesianTensor(1,2,Integer):=[tm,tm] 
--Relt(tn,2,2,2) 
--Rtn[2,2,2]
--R
--Rv:=[2,3] 
--Rtv:CartesianTensor(1,2,Integer):=v 
--Rtm:CartesianTensor(1,2,Integer):=[tv,tv] 
--Relt(tm,2,2) 
--Rtm[2,2]
--R
--Rv:=[2,3] 
--Rtv:CartesianTensor(1,2,Integer):=v 
--Relt(tv,2) 
--Rtv[2]
--R
--Rtv:CartesianTensor(1,2,Integer):=8 
--Relt(tv) 
--Rtv[]
--R
--R
--RExamples of elt from Database
--R
--R
--RExamples of elt from DataList
--R
--R
--RExamples of elt from Eltable
--R
--R
--RExamples of elt from EltableAggregate
--R
--R
--RExamples of elt from EuclideanModularRing
--R
--R
--RExamples of elt from ExpressionSpace
--R
--R
--RExamples of elt from FunctionFieldCategory
--R
--R
--RExamples of elt from FramedNonAssociativeAlgebra
--R
--R
--RExamples of elt from IndexCard
--R
--R
--RExamples of elt from Library
--R
--R
--RExamples of elt from LinearAggregate
--R
--R
--RExamples of elt from ThreeDimensionalMatrix
--R
--R
--RExamples of elt from MatrixCategory
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--Relt(m,3,3)
--R
--R
--RExamples of elt from OutputForm
--R
--R
--RExamples of elt from Pattern
--R
--R
--RExamples of elt from PermutationCategory
--R
--R
--RExamples of elt from PermutationGroup
--R
--R
--RExamples of elt from PlacesCategory
--R
--R
--RExamples of elt from ProjectiveSpaceCategory
--R
--R
--RExamples of elt from QuadraticForm
--R
--R
--RExamples of elt from RecursiveAggregate
--R
--R
--RExamples of elt from Reference
--R
--R
--RExamples of elt from RectangularMatrixCategory
--R
--R
--RExamples of elt from RewriteRule
--R
--R
--RExamples of elt from Ruleset
--R
--R
--RExamples of elt from SExpressionCategory
--R
--R
--RExamples of elt from StringAggregate
--R
--R
--RExamples of elt from Symbol
--R
--R
--RExamples of elt from UnivariatePolynomialCategory
--R
--R
--RExamples of elt from UnivariatePowerSeriesCategory
--R
--R
--RExamples of elt from UnaryRecursiveAggregate
--R
--E 124

--S 125 of 127
)d op minColIndex
--R 
--R
--RThere are 2 exposed functions called minColIndex :
--R   [1] D -> Integer from D
--R            if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has FLAGG
--R            D2 and D4 has FLAGG D2
--R   [2] D -> Integer from D
--R            if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5 has
--R            DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4)
--R
--RExamples of minColIndex from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,10) 
--RminColIndex(arr)
--R
--R
--RExamples of minColIndex from RectangularMatrixCategory
--R
--E 125

--S 126 of 127
)d op numberOfFactors
--R 
--R
--RThere is one exposed function called numberOfFactors :
--R   [1] Factored D2 -> NonNegativeInteger from Factored D2 if D2 has 
--R            INTDOM
--R
--RThere is one unexposed function called numberOfFactors :
--R   [1] List Record(factor: D3,degree: Integer) -> NonNegativeInteger
--R            from GaloisGroupFactorizer D3 if D3 has UPOLYC INT
--R
--RExamples of numberOfFactors from Factored
--R
--Ra:=factor 9720000 
--RnumberOfFactors a
--R
--R
--RExamples of numberOfFactors from GaloisGroupFactorizer
--R
--E 126

--S 127 of 127
)d op cyclicCopy
--R 
--R
--RThere is one exposed function called cyclicCopy :
--R   [1] Tree D1 -> Tree D1 from Tree D1 if D1 has SETCAT
--R
--RExamples of cyclicCopy from Tree
--R
--Rt1:=tree [1,2,3,4] 
--RcyclicCopy t1
--R
--E 127

)spool 
)lisp (bye)
 
\end{chunk}
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
