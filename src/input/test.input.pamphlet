\documentclass{article}
\usepackage{axiom}
\setlength{\textwidth}{400pt}
\begin{document}
\title{\$SPAD/src/input test.input}
\author{Scott Morrison, Bill Burge, Robert Sutor, Timothy Daly}
\maketitle
\begin{abstract}
File of recently fixed interpreter bugs
\end{abstract}
\eject
\tableofcontents
\eject
\section{License}
\begin{chunk}{license}
--Copyright The Numerical Algorithms Group Limited 1991.
\end{chunk}
\begin{chunk}{*}
)sys rm -f test.output
)spool test.output
)set message test on
)set message auto off
)set break resume

\end{chunk} 
Eval a polynomial with EXPR substitution values.
Fixed by SCM, verified on 10/30/90
\begin{chunk}{*}
)clear all

--S 1 of 188
eq1:= A*x^2 + B*x*y + C*y^2 +D*x + E*y + F
--R 
--R
--R           2                   2
--R   (1)  C y  + (B x + E)y + A x  + D x + F
--R                                                    Type: Polynomial(Integer)
--E 1

--S 2 of 188
eq2:= eval(eq1,[x= xdot*cos(t) - ydot*sin(t), y=xdot*sin(t) + ydot*cos(t)])
--R 
--R
--R   (2)
--R            2                       2       2
--R     (A ydot  - B xdot ydot + C xdot )sin(t)
--R   + 
--R               2                              2
--R     ((- B ydot  + (2C - 2A)xdot ydot + B xdot )cos(t) - D ydot + E xdot)sin(t)
--R   + 
--R            2                       2       2
--R     (C ydot  + B xdot ydot + A xdot )cos(t)  + (E ydot + D xdot)cos(t) + F
--R                                                    Type: Expression(Integer)
--E 2

\end{chunk}
UTS coercions.  Fixed by SCM, verified on 10/30/90
\begin{chunk}{*}
)clear all

--S 3 of 188
taylor exp x
--R 
--R
--R   (1)
--R             1  2   1  3    1  4    1   5    1   6     1   7     1    8
--R     1 + x + - x  + - x  + -- x  + --- x  + --- x  + ---- x  + ----- x
--R             2      6      24      120      720      5040      40320
--R   + 
--R        1    9      1     10      11
--R     ------ x  + ------- x   + O(x  )
--R     362880      3628800
--R                        Type: UnivariateTaylorSeries(Expression(Integer),x,0)
--E 3

--S 4 of 188
s := %
--R 
--R
--R   (2)
--R             1  2   1  3    1  4    1   5    1   6     1   7     1    8
--R     1 + x + - x  + - x  + -- x  + --- x  + --- x  + ---- x  + ----- x
--R             2      6      24      120      720      5040      40320
--R   + 
--R        1    9      1     10      11
--R     ------ x  + ------- x   + O(x  )
--R     362880      3628800
--R                        Type: UnivariateTaylorSeries(Expression(Integer),x,0)
--E 4

--S 5 of 188
s::(UTS(EXPR FLOAT, x, 0))
--R 
--R
--R   (3)
--R                    2                            3
--R     1.0 + x + 0.5 x  + 0.1666666666 6666666667 x
--R   + 
--R                                4                               5
--R     0.0416666666 6666666666 7 x  + 0.0083333333 3333333333 34 x
--R   + 
--R                                 6                               7
--R     0.0013888888 8888888888 89 x  + 0.0001984126 9841269841 27 x
--R   + 
--R                                   8                                  9
--R     0.0000248015 8730158730 1587 x  + 0.0000027557 3192239858 90653 x
--R   + 
--R                                   10      11
--R     0.2755731922 3985890653 E -6 x   + O(x  )
--R                        Type: UnivariateTaylorSeries(Expression(Float),x,0.0)
--E 5

--S 6 of 188
s::(UTS(FLOAT, x, 0))
--R 
--R
--R   (4)
--R                    2                            3
--R     1.0 + x + 0.5 x  + 0.1666666666 6666666667 x
--R   + 
--R                                4                               5
--R     0.0416666666 6666666666 7 x  + 0.0083333333 3333333333 34 x
--R   + 
--R                                 6                               7
--R     0.0013888888 8888888888 89 x  + 0.0001984126 9841269841 27 x
--R   + 
--R                                   8                                  9
--R     0.0000248015 8730158730 1587 x  + 0.0000027557 3192239858 90653 x
--R   + 
--R                                   10      11
--R     0.2755731922 3985890653 E -6 x   + O(x  )
--R                                    Type: UnivariateTaylorSeries(Float,x,0.0)
--E 6

--S 7 of 188
eval(s,1)
--R 
--R
--R             5 8 65 163 1957 685 109601 98641
--R   (5)  [1,2,-,-,--,---,----,---,------,-----,...]
--R             2 3 24  60  720 252  40320 36288
--R                                            Type: Stream(Expression(Integer))
--E 7

--S 8 of 188
%::(Stream Float)
--R 
--R
--R   (6)
--R   [1.0, 2.0, 2.5, 2.6666666666 666666667, 2.7083333333 333333333,
--R    2.7166666666 666666667, 2.7180555555 555555556, 2.7182539682 53968254,
--R    2.7182787698 412698413, 2.7182815255 731922399, ...]
--R                                                          Type: Stream(Float)
--E 8

\end{chunk}
Another bug, fixed by adding UPXS2 package,
\begin{chunk}{*}
)clear all

--S 9 of 188
s := series(sin(a*x),x=0)
--R 
--R
--R               3        5        7          9            11
--R              a   3    a   5    a    7     a     9      a      11      12
--R   (1)  a x - -- x  + --- x  - ---- x  + ------ x  - -------- x   + O(x  )
--R               6      120      5040      362880      39916800
--R                       Type: UnivariatePuiseuxSeries(Expression(Integer),x,0)
--E 9

--S 10 of 188
eval(s, 1.0)
--R 
--R
--R   (2)
--R                                          3
--R   [0.0, a, a, - 0.1666666666 6666666667 a  + a,
--R                               3
--R    - 0.1666666666 6666666667 a  + a,
--R                                5                            3
--R    0.0083333333 3333333333 34 a  - 0.1666666666 6666666667 a  + a,
--R                                5                            3
--R    0.0083333333 3333333333 34 a  - 0.1666666666 6666666667 a  + a,
--R
--R                                     7                               5
--R       - 0.0001984126 9841269841 27 a  + 0.0083333333 3333333333 34 a
--R     + 
--R                                  3
--R       - 0.1666666666 6666666667 a  + a
--R     ,
--R
--R                                     7                               5
--R       - 0.0001984126 9841269841 27 a  + 0.0083333333 3333333333 34 a
--R     + 
--R                                  3
--R       - 0.1666666666 6666666667 a  + a
--R     ,
--R
--R                                      9                               7
--R       0.0000027557 3192239858 90653 a  - 0.0001984126 9841269841 27 a
--R     + 
--R                                   5                            3
--R       0.0083333333 3333333333 34 a  - 0.1666666666 6666666667 a  + a
--R     ,
--R    ...]
--R                                              Type: Stream(Expression(Float))
--E 10

--S 11 of 188
s - a*x
--R 
--R
--R   (3)
--R        3        5        7          9            11              13
--R       a   3    a   5    a    7     a     9      a      11       a       13
--R     - -- x  + --- x  - ---- x  + ------ x  - -------- x   + ---------- x
--R        6      120      5040      362880      39916800       6227020800
--R   + 
--R        14
--R     O(x  )
--R                       Type: UnivariatePuiseuxSeries(Expression(Integer),x,0)
--E 11

\end{chunk}
Grand finale, just fixed on 3/23/91
\begin{chunk}{*}

--S 12 of 188
eval(s, 1.0)
--R 
--R
--R   (4)
--R                                          3
--R   [0.0, a, a, - 0.1666666666 6666666667 a  + a,
--R                               3
--R    - 0.1666666666 6666666667 a  + a,
--R                                5                            3
--R    0.0083333333 3333333333 34 a  - 0.1666666666 6666666667 a  + a,
--R                                5                            3
--R    0.0083333333 3333333333 34 a  - 0.1666666666 6666666667 a  + a,
--R
--R                                     7                               5
--R       - 0.0001984126 9841269841 27 a  + 0.0083333333 3333333333 34 a
--R     + 
--R                                  3
--R       - 0.1666666666 6666666667 a  + a
--R     ,
--R
--R                                     7                               5
--R       - 0.0001984126 9841269841 27 a  + 0.0083333333 3333333333 34 a
--R     + 
--R                                  3
--R       - 0.1666666666 6666666667 a  + a
--R     ,
--R
--R                                      9                               7
--R       0.0000027557 3192239858 90653 a  - 0.0001984126 9841269841 27 a
--R     + 
--R                                   5                            3
--R       0.0083333333 3333333333 34 a  - 0.1666666666 6666666667 a  + a
--R     ,
--R    ...]
--R                                              Type: Stream(Expression(Float))
--E 12

\end{chunk}
Generalized resolve. Fixed (enhanced) by SCM in 3/23/91
\begin{chunk}{*}
)clear all

--S 13 of 188
v := vector [1,2,3]
--R 
--R
--R   (1)  [1,2,3]
--R                                                Type: Vector(PositiveInteger)
--E 13

--S 14 of 188
(1/2)*v
--R 
--R
--R         1   3
--R   (2)  [-,1,-]
--R         2   2
--R                                              Type: Vector(Fraction(Integer))
--E 14

--S 15 of 188
eval(x^2, x=1/2)
--R 
--R
--R        1
--R   (3)  -
--R        4
--R                                          Type: Polynomial(Fraction(Integer))
--E 15

--S 16 of 188
eval(x^2, x=0.5)
--R 
--R
--R   (4)  0.25
--R                                                      Type: Polynomial(Float)
--E 16

--S 17 of 188
eval(3^x, x=0.5)
--R 
--R
--R   (5)  1.7320508075 688772935
--R                                                      Type: Expression(Float)
--E 17

\end{chunk}
Overloading interpreter maps on arity. Fixed by SCM, verified on 10/30/90
\begin{chunk}{*}
)clear all

--S 18 of 188
f(x) == x+1
--R 
--R                                                                   Type: Void
--E 18

--S 19 of 188
f(x,y) == x+y
--R 
--R                                                                   Type: Void
--E 19

--S 20 of 188
f 3
--R 
--R   Compiling function f with type PositiveInteger -> PositiveInteger 
--R
--R   (3)  4
--R                                                        Type: PositiveInteger
--E 20

--S 21 of 188
f(3,4)
--R 
--R   Compiling function f with type (PositiveInteger,PositiveInteger) -> 
--R      PositiveInteger 
--R
--R   (4)  7
--R                                                        Type: PositiveInteger
--E 21

--S 22 of 188
f(5)
--R 
--R
--R   (5)  6
--R                                                        Type: PositiveInteger
--E 22

--S 23 of 188
f(1,x)
--R 
--R   Compiling function f with type (PositiveInteger,Variable(x)) -> 
--R      Polynomial(Integer) 
--R
--R   (6)  x + 1
--R                                                    Type: Polynomial(Integer)
--E 23

\end{chunk}
Targetted function requiring a coercion. Fixed by SCM, verified on 10/30/90
\begin{chunk}{*}
)clear all

--S 24 of 188
series(n +-> bernoulli(n)/factorial(n), t=0)
--R 
--R
--R   (1)
--R       1      1  2    1   4     1    6      1     8       1     10      11
--R   1 - - t + -- t  - --- t  + ----- t  - ------- t  + -------- t   + O(t  )
--R       2     12      720      30240      1209600      47900160
--R                       Type: UnivariatePuiseuxSeries(Expression(Integer),t,0)
--E 24

\end{chunk}
In-homogeneous list mapping. Fixed by SCM, verified on 10/30/90
\begin{chunk}{*}
)clear all

--S 25 of 188
l := [1,2,-1]
--R 
--R
--R   (1)  [1,2,- 1]
--R                                                          Type: List(Integer)
--E 25

--S 26 of 188
f : INT -> FRAC INT
--R 
--R                                                                   Type: Void
--E 26

--S 27 of 188
f x == x
--R 
--R                                                                   Type: Void
--E 27

--S 28 of 188
map(f, l)
--R 
--R   Compiling function f with type Integer -> Fraction(Integer) 
--R
--R   (4)  [1,2,- 1]
--R                                                Type: List(Fraction(Integer))
--E 28

\end{chunk}
Function args to interpreter functions. Fixed by SCM, verified on 10/30/90
\begin{chunk}{*}
)clear all

--S 29 of 188
f: INT -> INT
--R 
--R                                                                   Type: Void
--E 29

--S 30 of 188
f x == x+1
--R 
--R                                                                   Type: Void
--E 30

--S 31 of 188
u g == g 3
--R 
--R                                                                   Type: Void
--E 31

--S 32 of 188
u f
--R 
--R   Compiling function u with type (Integer -> Integer) -> Integer 
--R   Compiling function f with type Integer -> Integer 
--R
--R   (4)  4
--R                                                        Type: PositiveInteger
--E 32

\end{chunk}
Category modemap requiring a field to be constructed.
Fixed by SCM, verified on 10/30/90
\begin{chunk}{*}
)clear all

--S 33 of 188
groebner [x^2 - y, y^3+1]
--R 
--R
--R              2  6
--R   (1)  [y - x ,x  + 1]
--R                                              Type: List(Polynomial(Integer))
--E 33

\end{chunk}
Operations requiring polynomials, passed variables.
Fixed by SCM, verified on 10/30/90
\begin{chunk}{*}
)clear all

--S 34 of 188
factor x
--R 
--R
--R   (1)  x
--R                                          Type: Factored(Polynomial(Integer))
--E 34

--draw(x, x=-1..1)

\end{chunk}
Bracket parsing and empty-set types. Fixed by SCM, verified on 10/30/90
\begin{chunk}{*}
)clear all

--S 35 of 188
{}$(List INT)
--R 
--RDaly Bug
--R   The function SEQ is not implemented in List(Integer).
--E 35

--S 36 of 188
brace []  -- {}
--R
--R   (1)  {}
--R                                                              Type: Set(None)
--E 36

--S 37 of 188
brace [1] -- {1}
--R
--R   (2)  {1}
--R                                                   Type: Set(PositiveInteger)
--E 37

--S 38 of 188
union(brace [], brace [1,2])   -- union({}, {1,2})
--R
--R   (3)  {1,2}
--R                                                   Type: Set(PositiveInteger)
--E 38

\end{chunk}
Shouldn't work, but no longer bombs the interpreter.
Fixed by SCM, verified on 10/30/90
\begin{chunk}{*}
)clear all

)set mes test off

--S 39 of 188
map(variable, [x,y])
--R 
--R
--R   (1)  [x,y]
--R                       Type: List(Union(OrderedVariableList([x,y]),"failed"))
--E 39

)set mes test on

\end{chunk}
Recursive map type analysis bug. Fixed by SCM, verified on 10/30/90
\begin{chunk}{*}
)clear all

)set fun recur off

--S 40 of 188
p(n,x) == if n=0 then 1 else (x+n-1)*p(n-1,x)
--R 
--R                                                                   Type: Void
--E 40

--S 41 of 188
pp(n,x) == if n=0 then 1 else if n<0 then (-1)^n/p(-n,1-x) else p(n,x)
--R 
--R                                                                   Type: Void
--E 41

--S 42 of 188
pp(-1,x) -- should be 1/(x-1)
--R 
--R   Compiling function p with type (Integer,Polynomial(Integer)) -> 
--R      Polynomial(Integer) 
--R   Compiling function p with type (Integer,Variable(x)) -> Polynomial(
--R      Integer) 
--R   Compiling function pp with type (Integer,Variable(x)) -> Fraction(
--R      Polynomial(Fraction(Integer))) 
--R
--R          1
--R   (3)  -----
--R        x - 1
--R                                Type: Fraction(Polynomial(Fraction(Integer)))
--E 42

\end{chunk}
Interpret-code mode for iterators is broken
\begin{chunk}{*}
)clear all

--S 43 of 188
f n ==
  for i in 1..n repeat
    j:=2*i
    m:SQMATRIX(j,?):=1
    print m
--R 
--R                                                                   Type: Void
--E 43

--S 44 of 188
g n ==
    j:=2*n
    m:SQMATRIX(j,?):=1
    print m
--R 
--R                                                                   Type: Void
--E 44

--S 45 of 188
g 3
--R 
--R   Cannot compile the declaration for m because its (possible partial) 
--R      type contains a local variable.
--R   Axiom will attempt to step through and interpret the code.
--R   +1  0  0  0  0  0+
--R   |                |
--R   |0  1  0  0  0  0|
--R   |                |
--R   |0  0  1  0  0  0|
--R   |                |
--R   |0  0  0  1  0  0|
--R   |                |
--R   |0  0  0  0  1  0|
--R   |                |
--R   +0  0  0  0  0  1+
--R                                                                   Type: Void
--E 45

--S 46 of 188
f 3
--R 
--R   Cannot compile the declaration for m because its (possible partial) 
--R      type contains a local variable.
--R   Axiom will attempt to step through and interpret the code.
--R   +1  0+
--R   |    |
--R   +0  1+
--R   +1  0  0  0+
--R   |          |
--R   |0  1  0  0|
--R   |          |
--R   |0  0  1  0|
--R   |          |
--R   +0  0  0  1+
--R   +1  0  0  0  0  0+
--R   |                |
--R   |0  1  0  0  0  0|
--R   |                |
--R   |0  0  1  0  0  0|
--R   |                |
--R   |0  0  0  1  0  0|
--R   |                |
--R   |0  0  0  0  1  0|
--R   |                |
--R   +0  0  0  0  0  1+
--R                                                                   Type: Void
--E 46

\end{chunk}
Test interpreter list destructuring
\begin{chunk}{*}
)clear all

--S 47 of 188
mp(x,l) ==
  l is [a,:b] =>
    a*x^(#b)+ mp(x,b)
  0
--R 
--R                                                                   Type: Void
--E 47

--S 48 of 188
mp(x, [1,3,4, 2])
--R 
--R   Compiling function mp with type (Variable(x),List(PositiveInteger))
--R       -> Polynomial(Integer) 
--R
--R         3     2
--R   (2)  x  + 3x  + 4x + 2
--R                                                    Type: Polynomial(Integer)
--E 48

--S 49 of 188
mp(x, [1,2,-3, 4])
--R 
--R   Compiling function mp with type (Variable(x),List(Integer)) -> 
--R      Polynomial(Integer) 
--R
--R         3     2
--R   (3)  x  + 2x  - 3x + 4
--R                                                    Type: Polynomial(Integer)
--E 49

\end{chunk}
Tests compilation of recursive functions
\begin{chunk}{*}
)clear all

--S 50 of 188
f1 n ==
  if n=0 then 1 else if n=1 then 1 else f1(n-1)+f1(n-2)
--R 
--R                                                                   Type: Void
--E 50

--S 51 of 188
f2 n ==
  m:=n
  if n=0 then 1 else if n=1 then 1 else f2(n-1)+f2(n-2)
--R 
--R                                                                   Type: Void
--E 51

--S 52 of 188
f3 n ==
  n=0 => 1
  n=1 => 1
  f3(n-1)+f3(n-2)
--R 
--R                                                                   Type: Void
--E 52

--S 53 of 188
f4 n ==
  m:=n
  n=0 => 1
  n=1 => 1
  m:=n
  f4(n-1)+f4(n-2)
--R 
--R                                                                   Type: Void
--E 53

--S 54 of 188
f5 n == if n=0 or n=1 then 1 else f5(n-1)+f5(n-2)
--R 
--R                                                                   Type: Void
--E 54

--S 55 of 188
[f1 3,f2 3, f3 3,f4 3,f5 3]
--R 
--R   Compiling function f1 with type Integer -> PositiveInteger 
--R   Compiling function f2 with type Integer -> PositiveInteger 
--R   Compiling function f3 with type Integer -> PositiveInteger 
--R   Compiling function f4 with type Integer -> PositiveInteger 
--R   Compiling function f5 with type Integer -> PositiveInteger 
--R
--R   (6)  [3,3,3,3,3]
--R                                                  Type: List(PositiveInteger)
--E 55

\end{chunk}
Input of GDMP types. Fixed by SCM on 1/22/91
\begin{chunk}{*}
)clear all

--S 56 of 188
g: GDMP([x,y], INT, DIRPROD(2, NNI)) := x^2 + y
--R 
--R
--R         2
--R   (1)  x  + y
--RType: GeneralDistributedMultivariatePolynomial([x,y],Integer,DirectProduct(2,NonNegativeInteger))
--E 56

\end{chunk}
Has test with variables. Fixed by SCM on 1/22/91
\begin{chunk}{*}
)clear all

--S 57 of 188
i := INT
--R 
--R
--R   (1)  Integer
--R                                                                 Type: Domain
--E 57

--S 58 of 188
i has Algebra(i)
--R 
--R
--R   (2)  true
--R                                                                Type: Boolean
--E 58

\end{chunk}
Returns in functions. Fixed by SCM on 1/22/91
\begin{chunk}{*}
)clear all

--S 59 of 188
f x == if x<0 then return x else x+1
--R 
--R                                                                   Type: Void
--E 59

--S 60 of 188
f 2 -- should be 3
--R 
--R   Compiling function f with type PositiveInteger -> PositiveInteger 
--R
--R   (2)  3
--R                                                        Type: PositiveInteger
--E 60

--S 61 of 188
f(-2) -- should be -2
--R 
--R   Compiling function f with type Integer -> Integer 
--R
--R   (3)  - 2
--R                                                                Type: Integer
--E 61

\end{chunk}
resolveTT not returning Any. Fixed by SCM 1/30/91
\begin{chunk}{*}
)clear all

--S 62 of 188
m = [[1,2],[2,3]]  -- Should return type EQ POLY SQMATRIX(2, INT)
--R 
--R
--R           +1  2+
--R   (1)  m= |    |
--R           +2  3+
--R                          Type: Equation(Polynomial(SquareMatrix(2,Integer)))
--E 62

--S 63 of 188
[1, "asd"]   -- Should be of type List Any
--R 
--R
--R   (2)  [1,"asd"]
--R                                                              Type: List(Any)
--E 63

)set mes test off

--S 64 of 188
1+"asd"  -- These should both fail in the same way
--R 
--R   There are 15 exposed and 5 unexposed library operations named + 
--R      having 2 argument(s) but none was determined to be applicable. 
--R      Use HyperDoc Browse, or issue
--R                                )display op +
--R      to learn more about the available operations. Perhaps 
--R      package-calling the operation or using coercions on the arguments
--R      will allow you to apply the operation.
--R 
--R   Cannot find a definition or applicable library operation named + 
--R      with argument type(s)
--R                               PositiveInteger
--R                                   String
--R      Perhaps you should use @ to indicate the required return type, or
--R      $ to specify which version of the function you need.
--E 64

--S 65 of 188
1/"asd"
--R 
--R   There are 15 exposed and 12 unexposed library operations named / 
--R      having 2 argument(s) but none was determined to be applicable. 
--R      Use HyperDoc Browse, or issue
--R                                )display op /
--R      to learn more about the available operations. Perhaps 
--R      package-calling the operation or using coercions on the arguments
--R      will allow you to apply the operation.
--R 
--R   Cannot find a definition or applicable library operation named / 
--R      with argument type(s)
--R                               PositiveInteger
--R                                   String
--R      Perhaps you should use @ to indicate the required return type, or
--R      $ to specify which version of the function you need.
--E 65

)set mes test on

\end{chunk}
Passing type variables to )show
\begin{chunk}{*}
)clear all

--S 66 of 188
t := MPOLY([x,y], INT)
--R 
--R
--R   (1)  MultivariatePolynomial([x,y],Integer)
--R                                                                 Type: Domain
--E 66

--S 67 of 188
)show t
--R 
--R MultivariatePolynomial([x,y],Integer) is a domain constructor.
--R Abbreviation for MultivariatePolynomial is MPOLY 
--R This constructor is exposed in this frame.
--R Issue )edit bookvol10.3.pamphlet to see algebra source code for MPOLY 
--R
--R------------------------------- Operations --------------------------------
--R
--R ?*? : (Fraction(Integer),%) -> %      ?*? : (Integer,%) -> %
--R ?*? : (PositiveInteger,%) -> %        ?*? : (%,Fraction(Integer)) -> %
--R ?*? : (%,Integer) -> %                ?*? : (%,%) -> %
--R ?**? : (%,PositiveInteger) -> %       ?+? : (%,%) -> %
--R ?-? : (%,%) -> %                      -? : % -> %
--R ?/? : (%,Integer) -> %                ?<? : (%,%) -> Boolean
--R ?<=? : (%,%) -> Boolean               ?=? : (%,%) -> Boolean
--R ?>? : (%,%) -> Boolean                ?>=? : (%,%) -> Boolean
--R 1 : () -> %                           0 : () -> %
--R ?^? : (%,PositiveInteger) -> %        associates? : (%,%) -> Boolean
--R coefficients : % -> List(Integer)     coerce : % -> OutputForm
--R coerce : Fraction(Integer) -> %       coerce : Integer -> %
--R coerce : % -> %                       content : % -> Integer
--R convert : % -> InputForm              convert : % -> Pattern(Float)
--R convert : % -> Pattern(Integer)       eval : (%,Equation(%)) -> %
--R eval : (%,%,%) -> %                   factor : % -> Factored(%)
--R gcd : List(%) -> %                    gcd : (%,%) -> %
--R ground : % -> Integer                 ground? : % -> Boolean
--R hash : % -> SingleInteger             latex : % -> String
--R lcm : List(%) -> %                    lcm : (%,%) -> %
--R leadingCoefficient : % -> Integer     leadingMonomial : % -> %
--R max : (%,%) -> %                      min : (%,%) -> %
--R monomial? : % -> Boolean              monomials : % -> List(%)
--R one? : % -> Boolean                   prime? : % -> Boolean
--R primitivePart : % -> %                recip : % -> Union(%,"failed")
--R reductum : % -> %                     retract : % -> Fraction(Integer)
--R retract : % -> Integer                sample : () -> %
--R squareFree : % -> Factored(%)         squareFreePart : % -> %
--R unit? : % -> Boolean                  unitCanonical : % -> %
--R zero? : % -> Boolean                  ?~=? : (%,%) -> Boolean
--R ?*? : (NonNegativeInteger,%) -> %
--R ?**? : (%,NonNegativeInteger) -> %
--R D : (%,List(OrderedVariableList([x,y])),List(NonNegativeInteger)) -> %
--R D : (%,List(OrderedVariableList([x,y]))) -> %
--R D : (%,OrderedVariableList([x,y]),NonNegativeInteger) -> %
--R D : (%,OrderedVariableList([x,y])) -> %
--R ?^? : (%,NonNegativeInteger) -> %
--R binomThmExpt : (%,%,NonNegativeInteger) -> %
--R characteristic : () -> NonNegativeInteger
--R charthRoot : % -> Union(%,"failed")
--R coefficient : (%,IndexedExponents(OrderedVariableList([x,y]))) -> Integer
--R coefficient : (%,List(OrderedVariableList([x,y])),List(NonNegativeInteger)) -> %
--R coefficient : (%,OrderedVariableList([x,y]),NonNegativeInteger) -> %
--R coerce : OrderedVariableList([x,y]) -> %
--R conditionP : Matrix(%) -> Union(Vector(%),"failed")
--R content : (%,OrderedVariableList([x,y])) -> %
--R degree : % -> IndexedExponents(OrderedVariableList([x,y]))
--R degree : (%,List(OrderedVariableList([x,y]))) -> List(NonNegativeInteger)
--R degree : (%,OrderedVariableList([x,y])) -> NonNegativeInteger
--R differentiate : (%,List(OrderedVariableList([x,y])),List(NonNegativeInteger)) -> %
--R differentiate : (%,List(OrderedVariableList([x,y]))) -> %
--R differentiate : (%,OrderedVariableList([x,y]),NonNegativeInteger) -> %
--R differentiate : (%,OrderedVariableList([x,y])) -> %
--R discriminant : (%,OrderedVariableList([x,y])) -> %
--R eval : (%,List(Equation(%))) -> %
--R eval : (%,List(OrderedVariableList([x,y])),List(Integer)) -> %
--R eval : (%,List(OrderedVariableList([x,y])),List(%)) -> %
--R eval : (%,List(%),List(%)) -> %
--R eval : (%,OrderedVariableList([x,y]),Integer) -> %
--R eval : (%,OrderedVariableList([x,y]),%) -> %
--R exquo : (%,Integer) -> Union(%,"failed")
--R exquo : (%,%) -> Union(%,"failed")
--R factorPolynomial : SparseUnivariatePolynomial(%) -> Factored(SparseUnivariatePolynomial(%))
--R factorSquareFreePolynomial : SparseUnivariatePolynomial(%) -> Factored(SparseUnivariatePolynomial(%))
--R gcdPolynomial : (SparseUnivariatePolynomial(%),SparseUnivariatePolynomial(%)) -> SparseUnivariatePolynomial(%)
--R isExpt : % -> Union(Record(var: OrderedVariableList([x,y]),exponent: NonNegativeInteger),"failed")
--R isPlus : % -> Union(List(%),"failed")
--R isTimes : % -> Union(List(%),"failed")
--R lcmCoef : (%,%) -> Record(llcmres: %,coeff1: %,coeff2: %)
--R mainVariable : % -> Union(OrderedVariableList([x,y]),"failed")
--R map : ((Integer -> Integer),%) -> %
--R mapExponents : ((IndexedExponents(OrderedVariableList([x,y])) -> IndexedExponents(OrderedVariableList([x,y]))),%) -> %
--R minimumDegree : % -> IndexedExponents(OrderedVariableList([x,y]))
--R minimumDegree : (%,List(OrderedVariableList([x,y]))) -> List(NonNegativeInteger)
--R minimumDegree : (%,OrderedVariableList([x,y])) -> NonNegativeInteger
--R monicDivide : (%,%,OrderedVariableList([x,y])) -> Record(quotient: %,remainder: %)
--R monomial : (Integer,IndexedExponents(OrderedVariableList([x,y]))) -> %
--R monomial : (%,List(OrderedVariableList([x,y])),List(NonNegativeInteger)) -> %
--R monomial : (%,OrderedVariableList([x,y]),NonNegativeInteger) -> %
--R multivariate : (SparseUnivariatePolynomial(Integer),OrderedVariableList([x,y])) -> %
--R multivariate : (SparseUnivariatePolynomial(%),OrderedVariableList([x,y])) -> %
--R numberOfMonomials : % -> NonNegativeInteger
--R patternMatch : (%,Pattern(Float),PatternMatchResult(Float,%)) -> PatternMatchResult(Float,%)
--R patternMatch : (%,Pattern(Integer),PatternMatchResult(Integer,%)) -> PatternMatchResult(Integer,%)
--R pomopo! : (%,Integer,IndexedExponents(OrderedVariableList([x,y])),%) -> %
--R primitiveMonomials : % -> List(%)
--R primitivePart : (%,OrderedVariableList([x,y])) -> %
--R reducedSystem : Matrix(%) -> Matrix(Integer)
--R reducedSystem : (Matrix(%),Vector(%)) -> Record(mat: Matrix(Integer),vec: Vector(Integer))
--R resultant : (%,%,OrderedVariableList([x,y])) -> %
--R retract : % -> OrderedVariableList([x,y])
--R retractIfCan : % -> Union(Fraction(Integer),"failed")
--R retractIfCan : % -> Union(Integer,"failed")
--R retractIfCan : % -> Union(OrderedVariableList([x,y]),"failed")
--R solveLinearPolynomialEquation : (List(SparseUnivariatePolynomial(%)),SparseUnivariatePolynomial(%)) -> Union(List(SparseUnivariatePolynomial(%)),"failed")
--R squareFreePolynomial : SparseUnivariatePolynomial(%) -> Factored(SparseUnivariatePolynomial(%))
--R subtractIfCan : (%,%) -> Union(%,"failed")
--R totalDegree : (%,List(OrderedVariableList([x,y]))) -> NonNegativeInteger
--R totalDegree : % -> NonNegativeInteger
--R unitNormal : % -> Record(unit: %,canonical: %,associate: %)
--R univariate : % -> SparseUnivariatePolynomial(Integer)
--R univariate : (%,OrderedVariableList([x,y])) -> SparseUnivariatePolynomial(%)
--R variables : % -> List(OrderedVariableList([x,y]))
--R
--R
--E 67

\end{chunk}
Caching nullary functions
\begin{chunk}{*}
)clear all

--S 68 of 188
)set fun cache all
--R 
--R   In general, interpreter functions will cache all values.
--E 68

--S 69 of 188
u == 1
--R 
--R                                                                   Type: Void
--E 69

--S 70 of 188
u
--R 
--R   Compiling body of rule u to compute value of type PositiveInteger 
--R   u will cache all previously computed values.
--R
--R   (2)  1
--R                                                        Type: PositiveInteger
--E 70

--S 71 of 188
)set fun cache 0
--R 
--R In general, functions will cache no returned values.
--E 71

\end{chunk}
Interpreter Only mode on collects. Fixed by SCM on 3/1/91
\begin{chunk}{*}
)clear all

--S 72 of 188
factorp: (UP(x,INT),PositiveInteger,PositiveInteger) -> List(UP(x,INT))
--R 
--R                                                                   Type: Void
--E 72

--S 73 of 188
factorp(poly,p,e) ==
   ppoly:UP(x,PF p):=poly
   pl := [rec.factor for rec in factors factor ppoly]
   facl:=pl::List(UP(x,INT))
--R 
--R                                                                   Type: Void
--E 73

--S 74 of 188
factorp(x^2+x+5,7,1)
--R 
--R   Cannot compile the declaration for ppoly because its (possible 
--R      partial) type contains a local variable.
--R   Axiom will attempt to step through and interpret the code.
--R   Compiling function factorp with type (UnivariatePolynomial(x,Integer
--R      ),PositiveInteger,PositiveInteger) -> List(UnivariatePolynomial(x
--R      ,Integer)) 
--R
--R   (3)  [x + 2,x + 6]
--R                                  Type: List(UnivariatePolynomial(x,Integer))
--E 74

\end{chunk}
Using "by" with segments. Fixed by SCM on 2/14/91
\begin{chunk}{*}
)clear all

--S 75 of 188
b:= 1..10
--R 
--R
--R   (1)  1..10
--R                                               Type: Segment(PositiveInteger)
--E 75

--S 76 of 188
for i in b by 2 repeat output i
--R 
--R   1
--R   3
--R   5
--R   7
--R   9
--R                                                                   Type: Void
--E 76

\end{chunk}
DMP resolve bug. Fixed by SCM 3/7/91
\begin{chunk}{*}
)clear all

--S 77 of 188
macro RN == FRAC INT
--R 
--R                                                                   Type: Void
--E 77

--S 78 of 188
a51:=x+y+z+t+u;
--R 
--R
--R                                                    Type: Polynomial(Integer)
--E 78

--S 79 of 188
a52:=x*y+y*z+z*t+x*u+t*u;
--R 
--R
--R                                                    Type: Polynomial(Integer)
--E 79

--S 80 of 188
a53:=x*y*z+y*z*t+x*y*u+x*t*u+z*t*u;
--R 
--R
--R                                                    Type: Polynomial(Integer)
--E 80

--S 81 of 188
a54:=x*y*z*t+x*y*z*u+x*y*t*u+x*z*t*u+y*z*t*u;
--R 
--R
--R                                                    Type: Polynomial(Integer)
--E 81

--S 82 of 188
a55:=x*y*z*t*u-1;
--R 
--R
--R                                                    Type: Polynomial(Integer)
--E 82

--S 83 of 188
arnborg5: List HDMP([x,y,z,t,u],RN):=[a51,a52,a53,a54,a55];
--R 
--R
--RType: List(HomogeneousDistributedMultivariatePolynomial([x,y,z,t,u],Fraction(Integer)))
--E 83

--S 84 of 188
arnborg5l: List DMP([x,y,z,t,u],RN):=[a51,a52,a53,a54,a55];
--R 
--R
--R Type: List(DistributedMultivariatePolynomial([x,y,z,t,u],Fraction(Integer)))
--E 84

\end{chunk}
Construct in interpret-only mode. Fixed by SCM on 3/7/91
\begin{chunk}{*}
)clear all

--S 85 of 188
factorp(poly,p,e) ==
   [rec.factor for rec in factors factor (poly::UP(x, PF p))]::List UP(x, INT)
--R 
--R                                                                   Type: Void
--E 85

--S 86 of 188
factorp(x^2+x+5,7,1)
--R 
--R   Cannot compile conversion for types involving local variables. In 
--R      particular, could not compile the expression involving :: UP(x,PF
--R      (#2))
--R   Axiom will attempt to step through and interpret the code.
--R
--R   (2)  [x + 2,x + 6]
--R                                  Type: List(UnivariatePolynomial(x,Integer))
--E 86

\end{chunk}
Return in interpret-only mode. fixed by SCM 3/11/91
\begin{chunk}{*}
)clear all

--S 87 of 188
f (x) ==
  y: PF x := 1
  x = 3 => return x
  x = 4 => return(-x)
  (x+1)
--R 
--R                                                                   Type: Void
--E 87

--S 88 of 188
f 3
--R 
--R   Cannot compile the declaration for y because its (possible partial) 
--R      type contains a local variable.
--R   Axiom will attempt to step through and interpret the code.
--R
--R   (2)  3
--R                                                        Type: PositiveInteger
--E 88

\end{chunk}
Incorrect handling of type of returns. fixed by SCM 3/11/91
\begin{chunk}{*}
)clear all

--S 89 of 188
f (x) ==
  x = 3 => return x
  x = 4 => return(-x)
  return (x+1)
--R 
--R                                                                   Type: Void
--E 89

--S 90 of 188
f 3
--R 
--R   Compiling function f with type PositiveInteger -> Integer 
--R
--R   (2)  3
--R                                                        Type: PositiveInteger
--E 90

\end{chunk}
SquareMatrix coercion bug. Fixed by SCM on 4/3/91
\begin{chunk}{*}
)clear all

--S 91 of 188
s:SQMATRIX(2, INT) := matrix [[1,2],[2,3]]
--R 
--R
--R        +1  2+
--R   (1)  |    |
--R        +2  3+
--R                                                Type: SquareMatrix(2,Integer)
--E 91

--S 92 of 188
s::SQMATRIX(2, FRAC INT)
--R 
--R
--R        +1  2+
--R   (2)  |    |
--R        +2  3+
--R                                      Type: SquareMatrix(2,Fraction(Integer))
--E 92

\end{chunk}
SquareMatric resolve bug
\begin{chunk}{*}
)clear all

--S 93 of 188
Mat := SquareMatrix(2, Polynomial Integer)
--R 
--R
--R   (1)  SquareMatrix(2,Polynomial(Integer))
--R                                                                 Type: Domain
--E 93

--S 94 of 188
s:Mat := matrix [[ 2*x + 1, x], [x, 1]]
--R 
--R
--R        +2x + 1  x+
--R   (2)  |         |
--R        +  x     1+
--R                                    Type: SquareMatrix(2,Polynomial(Integer))
--E 94

--S 95 of 188
s^3
--R 
--R
--R        +   3      2             3     2     +
--R        |12x  + 15x  + 6x + 1  5x  + 6x  + 3x|
--R   (3)  |                                    |
--R        |     3     2            3     2     |
--R        +   5x  + 6x  + 3x     2x  + 3x  + 1 +
--R                                    Type: SquareMatrix(2,Polynomial(Integer))
--E 95

--S 96 of 188
%::Polynomial(?)
--R 
--R
--R        +12  5+ 3   +15  6+ 2   +6  3+    +1  0+
--R   (4)  |     |x  + |     |x  + |    |x + |    |
--R        +5   2+     +6   3+     +3  0+    +0  1+
--R                                    Type: Polynomial(SquareMatrix(2,Integer))
--E 96

\end{chunk}
Parsing bug. Fixed by BURGE on 4/18/91
\begin{chunk}{*}
)clear all

--S 97 of 188
-2^2  -- Should return -4
--R 
--R
--R   (1)  - 4
--R                                                                Type: Integer
--E 97

\end{chunk}
\# in constructor arguemnt list bug. Fixed by SCM on 4/9/91
\begin{chunk}{*}
)clear all

--S 98 of 188
f: DMP([x,y], INT) := x^2-y^2
--R 
--R
--R         2    2
--R   (1)  x  - y
--R                       Type: DistributedMultivariatePolynomial([x,y],Integer)
--E 98

--S 99 of 188
coefficient(f, degree f)
--R 
--R
--R   (2)  1
--R                                                        Type: PositiveInteger
--E 99

\end{chunk}
Retract from EXPR to POLY. fixed by SCM and SUTOR on 5/1/91
\begin{chunk}{*}
)clear all

--S 100 of 188
x+1::EXPR INT
--R 
--R
--R   (1)  x + 1
--R                                                    Type: Expression(Integer)
--E 100

--S 101 of 188
%::POLY INT
--R 
--R
--R   (2)  x + 1
--R                                                    Type: Polynomial(Integer)
--E 101

\end{chunk}
Fixed by SCM in May
\begin{chunk}{*}
)clear all

--S 102 of 188
solve([[1,2],[2,3]],[-2,3])
--R 
--R
--R   (1)  [particular= [12,- 7],basis= [[0,0]]]
--RType: Record(particular: Union(Vector(Fraction(Integer)),"failed"),basis: List(Vector(Fraction(Integer))))
--E 102

\end{chunk}
Fixed by several people over a period of time
\begin{chunk}{*}
)clear all

--S 103 of 188
eval(m^2, m=[[1,2],[2,3]])
--R 
--R
--R        +5  8 +
--R   (1)  |     |
--R        +8  13+
--R                                    Type: Polynomial(SquareMatrix(2,Integer))
--E 103

\end{chunk}
Filtering various illegal declarations
\begin{chunk}{*}
)clear all

)set mes test off

--S 104 of 188
r: Ring
--R 
--R 
--R   Ring is a category, not a domain, and declarations require domains.
--E 104

--S 105 of 188
w: RF INT
--R 
--R 
--R   RationalFunction(Integer) is a package, not a domain, and 
--R      declarations require domains.
--E 105

)set mes test on

\end{chunk}
Correct representation of length 1 records
\begin{chunk}{*}
)clear all

--S 106 of 188
r:Record(a: INT) := [1]
--R 
--R
--R   (1)  [a= 1]
--R                                                     Type: Record(a: Integer)
--E 106

\end{chunk}
Fast generation of POLY FLOAT graphics code
\begin{chunk}{*}
)clear all

--S 107 of 188
p: POLY FLOAT := (x-1)^30
--R 
--R
--R   (1)
--R      30         29          28           27            26             25
--R     x   - 30.0 x   + 435.0 x   - 4060.0 x   + 27405.0 x   - 142506.0 x
--R   + 
--R               24              23              22               21
--R     593775.0 x   - 2035800.0 x   + 5852925.0 x   - 14307150.0 x
--R   + 
--R                 20               19               18                 17
--R     30045015.0 x   - 54627300.0 x   + 86493225.0 x   - 1 19759850.0 x
--R   + 
--R                   16                 15                 14                 13
--R     1 45422675.0 x   - 1 55117520.0 x   + 1 45422675.0 x   - 1 19759850.0 x
--R   + 
--R                 12               11               10               9
--R     86493225.0 x   - 54627300.0 x   + 30045015.0 x   - 14307150.0 x
--R   + 
--R                8              7             6             5            4
--R     5852925.0 x  - 2035800.0 x  + 593775.0 x  - 142506.0 x  + 27405.0 x
--R   + 
--R               3          2
--R     - 4060.0 x  + 435.0 x  - 30.0 x + 1.0
--R                                                      Type: Polynomial(Float)
--E 107

--draw(p, x=-1..1)

\end{chunk}
Case broken in interpreter. fixed by SCM in early 1991
\begin{chunk}{*}
)clear all

--S 108 of 188
sayBranch x == _
 if x case INT then output "Integer Branch" _
 else if x case STRING then output "String Branch" _
 else if x case FLOAT then output "Float Branch" _
 else output "don't know"
--R 
--R                                                                   Type: Void
--E 108

--S 109 of 188
x:Union(INT,STRING,FLOAT)
--R 
--R                                                                   Type: Void
--E 109

--S 110 of 188
x:=3
--R 
--R
--R   (3)  3
--R                                                     Type: Union(Integer,...)
--E 110

--S 111 of 188
sayBranch(x)
--R 
--R 
--RDaly Bug
--R   case is only used for Unions and the object on the left-hand side 
--R      does not belong to a union.
--E 111

\end{chunk}
Bug in evaluateType. fixed by SCM in May 1991
\begin{chunk}{*}
)clear all

--S 112 of 188
RFI := FRAC POLY INT
--R 
--R
--R   (1)  Fraction(Polynomial(Integer))
--R                                                                 Type: Domain
--E 112

--S 113 of 188
g:DMP([x,y], RFI) := a^2*x^2/b^2 - c^2*y^2/d^2
--R 
--R
--R         2       2
--R        a   2   c   2
--R   (2)  -- x  - -- y
--R         2       2
--R        b       d
--R Type: DistributedMultivariatePolynomial([x,y],Fraction(Polynomial(Integer)))
--E 113

--S 114 of 188
factor g
--R 
--R
--R         2
--R        a       b c        b c
--R   (3)  -- (x - --- y)(x + --- y)
--R         2      a d        a d
--R        b
--RType: Factored(DistributedMultivariatePolynomial([x,y],Fraction(Polynomial(Integer))))
--E 114

\end{chunk}
Bug in resolveTTSpecial. Fixed by SCM 6/2/91
\begin{chunk}{*}
)clear all

--S 115 of 188
f(u:DoubleFloat, v:DoubleFloat):DoubleFloat == u+v
--R 
--R   Function declaration f : (DoubleFloat,DoubleFloat) -> DoubleFloat 
--R      has been added to workspace.
--R                                                                   Type: Void
--E 115

--S 116 of 188
g(u:DoubleFloat, v:DoubleFloat):DoubleFloat == sin(u+v)
--R 
--R   Function declaration g : (DoubleFloat,DoubleFloat) -> DoubleFloat 
--R      has been added to workspace.
--R                                                                   Type: Void
--E 116

--S 117 of 188
h(u:DoubleFloat, v:DoubleFloat):DoubleFloat == u+cos(v)
--R 
--R   Function declaration h : (DoubleFloat,DoubleFloat) -> DoubleFloat 
--R      has been added to workspace.
--R                                                                   Type: Void
--E 117

--draw(surface(f,g,h), 0..4, 0..2*%pi)

\end{chunk}
Check for package calling from categories. fixed by SCM 6/4/91
\begin{chunk}{*}
)clear all

)set mes test off

--S 118 of 188
(1+1)$Ring
--R 
--R 
--R   The right-hand side of the $ operator must be a package or domain 
--R      name, but Ring is a category.
--E 118

)set mes test on

\end{chunk}
UnivariateSeries coercions. Fixed by SCM 6/20/91
\begin{chunk}{*}
)clear all

--S 119 of 188
s := series(sin(a*x), x=0)
--R 
--R
--R               3        5        7          9            11
--R              a   3    a   5    a    7     a     9      a      11      12
--R   (1)  a x - -- x  + --- x  - ---- x  + ------ x  - -------- x   + O(x  )
--R               6      120      5040      362880      39916800
--R                       Type: UnivariatePuiseuxSeries(Expression(Integer),x,0)
--E 119

--S 120 of 188
s - a*x
--R 
--R
--R   (2)
--R        3        5        7          9            11              13
--R       a   3    a   5    a    7     a     9      a      11       a       13
--R     - -- x  + --- x  - ---- x  + ------ x  - -------- x   + ---------- x
--R        6      120      5040      362880      39916800       6227020800
--R   + 
--R        14
--R     O(x  )
--R                       Type: UnivariatePuiseuxSeries(Expression(Integer),x,0)
--E 120

--S 121 of 188
s - sin(a*x)
--R 
--R
--R           21
--R   (3)  O(x  )
--R                       Type: UnivariatePuiseuxSeries(Expression(Integer),x,0)
--E 121

\end{chunk}
Complex \& AlgebraicNumber coercions. fixed by SCM 6/91
\begin{chunk}{*}
)clear all

--S 122 of 188
sin %i
--R 
--R
--R   (1)  sin(%i)
--R                                           Type: Expression(Complex(Integer))
--E 122

--S 123 of 188
sin sqrt 2
--R 
--R
--R             +-+
--R   (2)  sin(\|2 )
--R                                                    Type: Expression(Integer)
--E 123

--S 124 of 188
%i*sqrt(2)
--R 
--R
--R           +-+
--R   (3)  %i\|2
--R                                           Type: Expression(Complex(Integer))
--E 124

--S 125 of 188
sin(%i*sqrt 2)
--R 
--R
--R               +-+
--R   (4)  sin(%i\|2 )
--R                                           Type: Expression(Complex(Integer))
--E 125

--S 126 of 188
%i * sin(x)
--R 
--R
--R   (5)  %i sin(x)
--R                                           Type: Expression(Complex(Integer))
--E 126

--S 127 of 188
sin(x/sqrt(2))
--R 
--R
--R              +-+
--R            x\|2
--R   (6)  sin(-----)
--R              2
--R                                                    Type: Expression(Integer)
--E 127

\end{chunk}
Bug in resolve. fixed by SCM 8/12/91
\begin{chunk}{*}
)clear all

)set msg test off

--S 128 of 188
primaryDecomp xx
--R 
--R   There are 1 exposed and 0 unexposed library operations named 
--R      primaryDecomp having 1 argument(s) but none was determined to be 
--R      applicable. Use HyperDoc Browse, or issue
--R                          )display op primaryDecomp
--R      to learn more about the available operations. Perhaps 
--R      package-calling the operation or using coercions on the arguments
--R      will allow you to apply the operation.
--R 
--RDaly Bug
--R   Cannot find a definition or applicable library operation named 
--R      primaryDecomp with argument type(s)
--R                                Variable(xx)
--R      Perhaps you should use @ to indicate the required return type, or
--R      $ to specify which version of the function you need.
--E 128

)set msg test on

\end{chunk}
Functions with ADEFs were broken. fixed by SCM 8/9/91
\begin{chunk}{*}
)clear all

--S 129 of 188
f l ==
  reduce((x,y) +-> l.1 + x + y, l)
--R 
--R                                                                   Type: Void
--E 129

--S 130 of 188
f [10,2,53]
--R 
--R   Compiling function f with type List(PositiveInteger) -> 
--R      PositiveInteger 
--R
--R   (2)  85
--R                                                        Type: PositiveInteger
--E 130

--S 131 of 188
g l ==
  (x:INT):INT +-> l.x
--R 
--R                                                                   Type: Void
--E 131

--S 132 of 188
w := g [23,1,341,12] ;
--R 
--R   Compiling function g with type List(PositiveInteger) -> (Integer -> 
--R      Integer) 
--R
--R                                                   Type: (Integer -> Integer)
--E 132

--S 133 of 188
w(1) + w(3)
--R 
--R
--R   (5)  364
--R                                                        Type: PositiveInteger
--E 133

--S 134 of 188
w(-1) 
--R 
--R 
--RDaly Bug
--R   >> Error detected within library code:
--R   index out of range
--R
--R   Continuing to read the file...
--R
--E 134

\end{chunk}
Coerces RN to PF and POLY to EXPR. fixed by SCM 8/9/91
\begin{chunk}{*}
)clear all

--S 135 of 188
a := 2/3
--R 
--R
--R        2
--R   (1)  -
--R        3
--R                                                      Type: Fraction(Integer)
--E 135

)set mes test off

--S 136 of 188
a::PF 3
--R 
--R 
--R   Division by zero on conversion to GaloisField.
--E 136

)set mes test on

--S 137 of 188
b := x+1
--R 
--R
--R   (2)  x + 1
--R                                                    Type: Polynomial(Integer)
--E 137

--S 138 of 188
b:: EXPR FLOAT
--R 
--R
--R   (3)  x + 1.0
--R                                                      Type: Expression(Float)
--E 138

\end{chunk}
Minivector use in coercion functions.
\begin{chunk}{*}
)clear all
 
--S 139 of 188
symbol(s:Symbol,i:Integer):Symbol ==
  st0:String:= convert(i)
  st0:= concat(string(s),st0)
  st0::Symbol
--R 
--R   Function declaration symbol : (Symbol,Integer) -> Symbol has been 
--R      added to workspace.
--R                                                                   Type: Void
--E 139

--S 140 of 188
f(a,b) == symbol(a,b)
--R 
--R                                                                   Type: Void
--E 140

--S 141 of 188
f('abc,3)
--R 
--R   Compiling function symbol with type (Symbol,Integer) -> Symbol 
--R   Compiling function f with type (Variable(abc),PositiveInteger) -> 
--R      Symbol 
--R
--R   (3)  abc3
--R                                                                 Type: Symbol
--E 141

\end{chunk}
Coercing undeclared maps to Mapping types. fixed by SCM 9/3/91
\begin{chunk}{*}
)clear all

--S 142 of 188
f := operator 'f
--R 
--R
--R   (1)  f
--R                                                          Type: BasicOperator
--E 412

--S 143 of 188
y := f(x)
--R 
--R
--R   (2)  f(x)
--R                                                    Type: Expression(Integer)
--E 143

--S 144 of 188
foo(u) == sin(u)
--R 
--R                                                                   Type: Void
--E 144

--S 145 of 188
eval(y, 'f, foo)
--R 
--R   There are 2 exposed and 6 unexposed library operations named sin 
--R      having 1 argument(s) but none was determined to be applicable. 
--R      Use HyperDoc Browse, or issue
--R                               )display op sin
--R      to learn more about the available operations. Perhaps 
--R      package-calling the operation or using coercions on the arguments
--R      will allow you to apply the operation.
--R   Compiling function foo with type Expression(Integer) -> Expression(
--R      Integer) 
--R
--R   (4)  sin(x)
--R                                                    Type: Expression(Integer)
--E 145

\end{chunk}
Package calling constants. fixed by SCM 9/3/91
\begin{chunk}{*}
)clear all

--S 146 of 188
init()$(PF 3)
--R 
--R
--R   (1)  0
--R                                                          Type: PrimeField(3)
--E 146

\end{chunk}
Passing ADEFs to functions which require specific mapping types.
\begin{chunk}{*}
)clear all

--draw((x,y) +-> x^2 - y^2, -1..1, -1..1)

\end{chunk}
DP bug.  Don't know where this came from, but its fixed. DP makes problems:
\begin{chunk}{*}
)clear all

--S 147 of 188
dmp := DMP([u1,u2,u3],Fraction INT)
--R 
--R
--R   (1)  DistributedMultivariatePolynomial([u1,u2,u3],Fraction(Integer))
--R                                                                 Type: Domain
--E 147

--S 148 of 188
p : dmp := 2*u1^4*u2*u3
--R 
--R
--R           4
--R   (2)  2u1 u2 u3
--R        Type: DistributedMultivariatePolynomial([u1,u2,u3],Fraction(Integer))
--E 148

--S 149 of 188
e1 := degree p
--R 
--R
--R   (3)  [4,1,1]
--R                                    Type: DirectProduct(3,NonNegativeInteger)
--E 149

--S 150 of 188
e2 : DirectProduct(3,NonNegativeInteger) := e1
--R 
--R
--R   (4)  [4,1,1]
--R                                    Type: DirectProduct(3,NonNegativeInteger)
--E 150

--S 151 of 188
sup(e1,e1)
--R 
--R
--R   (5)  [4,1,1]
--R                                    Type: DirectProduct(3,NonNegativeInteger)
--E 151

\end{chunk}
If you give to many infos to the Interpreter it has problems.
\begin{chunk}{*}

--S 152 of 188
sup(e1,e1)$DirectProduct(3,NonNegativeInteger)
--R 
--R
--R   (6)  [4,1,1]
--R                                    Type: DirectProduct(3,NonNegativeInteger)
--E 152

)clear all

--S 153 of 188
sum:=0
--R 
--R
--R   (1)  0
--R                                                     Type: NonNegativeInteger
--E 153

--S 154 of 188
m:=matrix [[1,2],[3,4]]
--R 
--R
--R        +1  2+
--R   (2)  |    |
--R        +3  4+
--R                                                        Type: Matrix(Integer)
--E 154

--S 155 of 188
lastcol:=ncols(m)
--R 
--R
--R   (3)  2
--R                                                        Type: PositiveInteger
--E 155

--S 156 of 188
for r in 1..nrows(m) repeat
 -- interpreter having a value for "row" would cause it to hide
 -- the system function
 Row:=row(m,r)
 for c in 1..lastcol repeat
  sum:=sum+Row.c
--R 
--R                                                                   Type: Void
--E 156

--S 157 of 188
sum
--R 
--R
--R   (5)  10
--R                                                        Type: PositiveInteger
--E 157

\end{chunk}
interpOnly mode left things in an incosistent state if it failed twice.
fixed by SCM
\begin{chunk}{*}
)clear all

--S 158 of 188
splitPoly(f,var) ==
   map(g +-> multivariate(g,var),monomials univariate(f,var))
--R 
--R                                                                   Type: Void
--E 158

--S 159 of 188
g:=sin(x)+cos(x)
--R 
--R
--R   (2)  sin(x) + cos(x)
--R                                                    Type: Expression(Integer)
--E 159

--S 160 of 188
k:=kernels(g).1
--R 
--R
--R   (3)  sin(x)
--R                                            Type: Kernel(Expression(Integer))
--E 160

)set mes test off

--S 161 of 188
splitPoly([g],k) -- this is an incorrect call
--R 
--R   There are 4 exposed and 1 unexposed library operations named 
--R      univariate having 2 argument(s) but none was determined to be 
--R      applicable. Use HyperDoc Browse, or issue
--R                           )display op univariate
--R      to learn more about the available operations. Perhaps 
--R      package-calling the operation or using coercions on the arguments
--R      will allow you to apply the operation.
--R   Cannot find a definition or applicable library operation named 
--R      univariate with argument type(s)
--R                          List(Expression(Integer))
--R                         Kernel(Expression(Integer))
--R      Perhaps you should use @ to indicate the required return type, or
--R      $ to specify which version of the function you need.
--R   Axiom will attempt to step through and interpret the code.
--R   There are 4 exposed and 1 unexposed library operations named 
--R      univariate having 2 argument(s) but none was determined to be 
--R      applicable. Use HyperDoc Browse, or issue
--R                           )display op univariate
--R      to learn more about the available operations. Perhaps 
--R      package-calling the operation or using coercions on the arguments
--R      will allow you to apply the operation.
--R 
--R   Cannot find a definition or applicable library operation named 
--R      univariate with argument type(s)
--R                          List(Expression(Integer))
--R                         Kernel(Expression(Integer))
--R      Perhaps you should use @ to indicate the required return type, or
--R      $ to specify which version of the function you need.
--E 161

)set mes test on

--S 162 of 188
splitPoly(numer g,k) -- this is a correct call
--R 
--R   Compiling function splitPoly with type (SparseMultivariatePolynomial
--R      (Integer,Kernel(Expression(Integer))),Kernel(Expression(Integer))
--R      ) -> List(SparseMultivariatePolynomial(Integer,Kernel(Expression(
--R      Integer)))) 
--R
--R   (4)  [sin(x),cos(x)]
--RType: List(SparseMultivariatePolynomial(Integer,Kernel(Expression(Integer))))
--E 162

\end{chunk}
Scoping of lambda variables. fixed by SCM in March, 1992
\begin{chunk}{*}
)clear all

--S 163 of 188
f x ==
  g := (y:DoubleFloat):DoubleFloat +-> y+x
  output(y+1)
  g(x)
--R 
--R                                                                   Type: Void
--E 163

--S 164 of 188
f 3
--R 
--R   Compiling function f with type PositiveInteger -> DoubleFloat 
--R   y + 1
--R
--R   (2)  6.
--R                                                            Type: DoubleFloat
--E 164

\end{chunk}
Coercing undeclared interpreter function to mapping type with
target which need to be coerced.
fixed by SCM in March, 1992
\begin{chunk}{*}
)clear all

--S 165 of 188
f x == 1/factorial(x)
--R 
--R                                                                   Type: Void
--E 165

--S 166 of 188
series(f, x=0)
--R 
--R   Compiling function f with type Integer -> Expression(Integer) 
--R
--R   (2)
--R             1  2   1  3    1  4    1   5    1   6     1   7     1    8
--R     1 + x + - x  + - x  + -- x  + --- x  + --- x  + ---- x  + ----- x
--R             2      6      24      120      720      5040      40320
--R   + 
--R        1    9      1     10      11
--R     ------ x  + ------- x   + O(x  )
--R     362880      3628800
--R                       Type: UnivariatePuiseuxSeries(Expression(Integer),x,0)
--E 166

\end{chunk}
Rule dependencies with dependencies on the operator position.
\begin{chunk}{*}
)clear all

--S 167 of 188
node_a == i1+i2+i3-i5+i6=0
--R 
--R                                                                   Type: Void
--E 167

--S 168 of 188
node_b == -i2-i3+i4-i6=0
--R 
--R                                                                   Type: Void
--E 168

--S 169 of 188
i1 == va/r1
--R 
--R                                                                   Type: Void
--E 169

--S 170 of 188
i2 == (va-vb)/r2
--R 
--R                                                                   Type: Void
--E 170

--S 171 of 188
i3 == (va-vb)/r3
--R 
--R                                                                   Type: Void
--E 171

--S 172 of 188
i4 == vb/r4
--R 
--R                                                                   Type: Void
--E 172

--S 173 of 188
node_a
--R 
--R   Compiling body of rule i1 to compute value of type Fraction(
--R      Polynomial(Integer)) 
--R   Compiling body of rule i2 to compute value of type Fraction(
--R      Polynomial(Integer)) 
--R   Compiling body of rule i3 to compute value of type Fraction(
--R      Polynomial(Integer)) 
--R   Compiling body of rule nodea to compute value of type Equation(
--R      Fraction(Polynomial(Integer))) 
--R
--R        (- r1 r3 - r1 r2)vb + ((r2 + r1)r3 + r1 r2)va + (i6 - i5)r1 r2 r3
--R   (7)  -----------------------------------------------------------------= 0
--R                                     r1 r2 r3
--R                                Type: Equation(Fraction(Polynomial(Integer)))
--E 173

--S 174 of 188
node_b
--R 
--R   Compiling body of rule i4 to compute value of type Fraction(
--R      Polynomial(Integer)) 
--R   Compiling body of rule nodeb to compute value of type Equation(
--R      Fraction(Polynomial(Integer))) 
--R
--R        ((r3 + r2)r4 + r2 r3)vb + (- r3 - r2)r4 va - i6 r2 r3 r4
--R   (8)  --------------------------------------------------------= 0
--R                                r2 r3 r4
--R                                Type: Equation(Fraction(Polynomial(Integer)))
--E 174

--S 175 of 188
ans == solve([node_a,node_b],[va,vb]) -- (*)
--R 
--R                                                                   Type: Void
--E 175

--S 176 of 188
x1 == rhs(ans.1.1)
--R 
--R                                                                   Type: Void
--E 176

--S 177 of 188
x2 == rhs(ans.1.2)
--R 
--R                                                                   Type: Void
--E 177

--S 178 of 188
x1       -- (**)
--R 
--R   Compiling body of rule ans to compute value of type List(List(
--R      Equation(Fraction(Polynomial(Integer))))) 
--R   Compiling body of rule x1 to compute value of type Fraction(
--R      Polynomial(Integer)) 
--R
--R         (i5 r1 r3 + i5 r1 r2)r4 + (- i6 + i5)r1 r2 r3
--R   (12)  ---------------------------------------------
--R               (r3 + r2)r4 + (r2 + r1)r3 + r1 r2
--R                                          Type: Fraction(Polynomial(Integer))
--E 178

--S 179 of 188
r1 == 2  -- (***)
--R 
--R   Compiled code for i1 has been cleared.
--R   Compiled code for nodea has been cleared.
--R   Compiled code for ans has been cleared.
--R   Compiled code for x1 has been cleared.
--R                                                                   Type: Void
--E 179

--S 180 of 188
x1       -- (****)
--R 
--R   Compiling body of rule r1 to compute value of type PositiveInteger 
--R   Compiling body of rule i1 to compute value of type Polynomial(
--R      Fraction(Integer)) 
--R   Compiling body of rule nodea to compute value of type Equation(
--R      Fraction(Polynomial(Integer))) 
--R   Compiling body of rule ans to compute value of type List(List(
--R      Equation(Fraction(Polynomial(Integer))))) 
--R   Compiling body of rule x1 to compute value of type Fraction(
--R      Polynomial(Integer)) 
--R
--R         (2i5 r3 + 2i5 r2)r4 + (- 2i6 + 2i5)r2 r3
--R   (14)  ----------------------------------------
--R              (r3 + r2)r4 + (r2 + 2)r3 + 2r2
--R                                          Type: Fraction(Polynomial(Integer))
--E 180

\end{chunk}
Look for immediate data in operator position. 
fixed in March 1992 by SCM and RSS
\begin{chunk}{*}
)clear all

--S 181 of 188
"asd" "sdfsdf" "dfgdfg"
--R 
--R
--R   (1)  "asdsdfsdfdfgdfg"
--R                                                                 Type: String
--E 181

\end{chunk}
Global variables that change type in a loop.
fixed by SCM
\begin{chunk}{*}
)clear all

--S 182 of 188
s := 3.4
--R 
--R
--R   (1)  3.4
--R                                                                  Type: Float
--E 182

--S 183 of 188
while s > 1.0 repeat (s := 1/2; print s)
--R 
--R   1
--R   -
--R   2
--R                                                                   Type: Void
--E 183

--S 184 of 188
s
--R 
--R
--R        1
--R   (3)  -
--R        2
--R                                                      Type: Fraction(Integer)
--E 184

)clear all

--S 185 of 188
f x ==
  free s
  s := x
  while s > 1.0 repeat (s := 1/2; print s)
  s
--R 
--R                                                                   Type: Void
--E 185

--S 186 of 188
f(3.4)
--R 
--R   Compiling function f with type Float -> Float 
--R   Compiled code for f has been cleared.
--R   0.5
--R
--R   (2)  0.5
--R                                                                  Type: Float
--E 186

\end{chunk}
Returns in sequences. fixed by SCM
\begin{chunk}{*}
)clear all

--S 187 of 188
t x ==
  if x = 1 then (1; return [x])
  return [2]
--R 
--R                                                                   Type: Void
--E 187

--S 188 of 188
t 1
--R 
--R   Compiling function t with type PositiveInteger -> List(
--R      PositiveInteger) 
--R
--R   (2)  [1]
--R                                                  Type: List(PositiveInteger)
--E 188
)spool 
)lisp (bye)
 
\end{chunk}
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
