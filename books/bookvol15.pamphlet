\documentclass{book}
\newcommand{\VolumeName}{Volume 15: The Sane Compiler}
\usepackage{etex}    % fix No room for a new \dimen
\reserveinserts{30}  % fix No room for a new \dimen
\usepackage{imakeidx} % for multiple indicies
\makeindex[name=doc,intoc=false]
\makeindex[name=code,intoc=false]
\makeindex[name=cat,intoc=false]
\makeindex[name=dom,intoc=false]
\makeindex[name=pkg,intoc=false]
\usepackage{hyperref}
\hypersetup{colorlinks=true,linkcolor=blue,pdfborderstyle={/S/U/W 1},citecolor=red}
\usepackage[toc,page]{appendix}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{axiom}
\usepackage{enumitem} % for noitemsep in itemize
\usepackage{bussproofs} % for prooftree environment
\usepackage[margin=1in]{geometry} % for white pages
\usepackage{catmac} % for Weber chapter in vol 10.1
\usepackage{dissdef} % for Weber chapter in vol 10.1
\usepackage{stmaryrd} % for llbracket
\usepackage{tikz}     % for finite state diagrams
\usetikzlibrary{automata, positioning, arrows}
\tikzset{
 ->,                     % make the edges directed
 >=stealth',             % make arrow heads bold
 node distance=2cm,      % min distance between nodes
 every state/.style={thick,fill=gray!10},
 initial text=$\epsilon$ % set text on start arrow
}

\newtheorem{DoyeTheorem}[subsection]{Theorem}
\newtheorem{DoyeDefinition}[subsection]{Definition}
\newtheorem{DoyeExample}[subsection]{Example}
\newtheorem{DoyeNotation}[subsection]{Notation}
\newtheorem{DoyeConjecture}[subsection]{Conjecture}
\newtheorem{DoyeCorollary}[subsection]{Corollary}
\newtheorem{DoyeLemma}[subsection]{Lemma}
\newtheorem{DoyeAssumption}[subsection]{Assumption}
\newtheorem{DoyeAlgorithm}[subsection]{Algorithm}
\newcommand*{\QED}{\hfill\ensuremath{\blacksquare}} % for qed

\setlength{\textwidth}{400pt}
%\makeindex
\usepackage{graphicx}
\usepackage{changepage} % for adjustwidth environment
\usepackage{pst-node} % for commutative diagrams
\newwrite\sigfile

%\usepackage{breakurl}
%\def\UrlBreaks{\do\/\do\-} % line-breaking urls

\begin{document}
\immediate\openout\sigfile=signatures.tex
\frontmatter
\setcounter{secnumdepth}{2}
\begin{titlepage}
\center{\includegraphics{ps/axiomfront.ps}}
\vskip 0.1in
\includegraphics{ps/bluebayou.ps}\\
\vskip 0.1in
{\Huge{The 30 Year Horizon}}
\vskip 0.1in
$$
\begin{array}{lll}
Manuel\ Bronstein      & William\ Burge   & Timothy\ Daly \\
James\ Davenport       & Michael\ Dewar   & Martin\ Dunstan \\
Albrecht\ Fortenbacher & Patrizia\ Gianni & Johannes\ Grabmeier \\
Jocelyn\ Guidry        & Richard\ Jenks   & Larry\ Lambe \\
Michael\ Monagan       & Scott\ Morrison  & William\ Sit \\
Jonathan\ Steinbach    & Robert\ Sutor    & Barry\ Trager \\
Stephen\ Watt          & Jim\ Wen         & Clifton\ Williamson
\end{array}
$$
\center{\large{\VolumeName}}
\vskip 0.1in
\center{\today}
\vskip 0.1in
\center{\input{master}}
\end{titlepage}
\pagenumbering{roman}
\begin{verbatim}
Portions Copyright (c) 2005 Timothy Daly

The Blue Bayou image Copyright (c) 2004 Jocelyn Guidry

Portions Copyright (c) 2004 Martin Dunstan
Portions Copyright (c) 2007 Alfredo Portes
Portions Copyright (c) 2007 Arthur Ralfs
Portions Copyright (c) 2005 Timothy Daly

Portions Copyright (c) 1991-2002, 
The Numerical ALgorithms Group Ltd.
All rights reserved.

This book and the Axiom software is licensed as follows:

Redistribution and use in source and binary forms, with or 
without modification, are permitted provided that the following 
conditions are
met:

    - Redistributions of source code must retain the above 
      copyright notice, this list of conditions and the 
      following disclaimer.

    - Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the 
      following disclaimer in the documentation and/or other 
      materials provided with the distribution.

    - Neither the name of The Numerical ALgorithms Group Ltd. 
      nor the names of its contributors may be used to endorse 
      or promote products derived from this software without 
      specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND 
CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
SUCH DAMAGE.

\end{verbatim}

\vfill
\newpage
Inclusion of names in the list of credits is based on historical
information and is as accurate as possible. Inclusion of names
does not in any way imply an endorsement but represents historical
influence on Axiom development.

\begin{tabular}{lll}
Michael Albaugh        & Cyril Alberga          & Roy Adler\\
Christian Aistleitner  & Richard Anderson       & George Andrews\\
Jerry Archibald        & S.J. Atkins            & Jeremy Avigad\\
Knut Bahr              & Henry Baker            & Martin Baker\\
Stephen Balzac         & Yurij Baransky         & David R. Barton\\
Thomas Baruchel        & Gerald Baumgartner     & Gilbert Baumslag\\
Michael Becker         & Nelson H. F. Beebe     & Jay Belanger\\
Siddharth Bhat         & David Bindel           & Fred Blair\\
Vladimir Bondarenko    & Mark Botch             & Raoul Bourquin\\
Alexandre Bouyer       & Karen Braman           & Wolfgang Brehm\\
Peter A. Broadbery     & Martin Brock           & Manuel Bronstein\\
Christopher Brown      & Stephen Buchwald       & Florian Bundschuh\\
Luanne Burns           & William Burge          & Ralph Byers\\
Quentin Carpent        & Jacques Carette        & Pierre Casteran\\
Robert Cavines         & Pablo Cayuela          & Bruce Char\\
Ondrej Certik          & Tzu-Yi Chen            & Bobby Cheng\\
Cheekai Chin           & David V. Chudnovsky    & Gregory V. Chudnovsky\\
Mark Clements          & Roland Coeurjoly       & Emil Cohen\\
Hirsh Cohen            & Josh Cohen             & James Cloos\\
Jia Zhao Cong          & Christophe Conil       & Don Coppersmith\\
George Corliss         & Robert Corless         & Gary Cornell\\
Frank Costa            & Meino Cramer           & Karl Crary\\
Jeremy Du Croz         & David Cyganski         & Nathaniel Daly\\
Timothy Daly Sr.       & Timothy Daly Jr.       & James H. Davenport\\
David Day              & James Demmel           & Didier Deshommes\\
Michael Dewar          & Inderjit Dhillon       & Jack Dongarra\\
Jean Della Dora        & Gabriel Dos Reis       & Claire DiCrescendo\\
Sam Dooley             & Nicolas James Doye     & Zlatko Drmac\\
Lionel Ducos           & Iain Duff              & Lee Duhem\\
Martin Dunstan         & Brian Dupee            & Dominique Duval\\
Robert Edwards         & Hans-Dieter Ehrich     & Heow Eide-Goodman\\
Carl Engelman          & Lars Erickson          & Mark Fahey\\
William Farmer         & Richard Fateman        & Bertfried Fauser\\
Stuart Feldman         & John Fletcher          & Brian Ford\\
Albrecht Fortenbacher  & George Frances         & Constantine Frangos\\
Timothy Freeman        & Korrinn Fu             & Marc Gaetano\\
Rudiger Gebauer        & Van de Geijn           & Kathy Gerber\\
Patricia Gianni        & Gustavo Goertkin       & Samantha Goldrich\\
Max Goldstein          & Holger Gollan          & Teresa Gomez-Diaz\\
Ralph Gomory           & Laureano Gonzalez-Vega & Stephen Gortler\\
Johannes Grabmeier     & Matt Grayson           & Martin Griss\\
Klaus Ebbe Grue        & James Griesmer         & Vladimir Grinberg\\
Oswald Gschnitzer      & Ming Gu                & Fred Gustavson\\
Jocelyn Guidry         & Gaetan Hache           & Steve Hague\\
Satoshi Hamaguchi      & Sven Hammarling        & Mike Hansen\\
Richard Hanson         & Richard Harke          & Joseph Harry\\
Bill Hart              & Vilya Harvey           & Martin Hassner\\
Arthur S. Hathaway     & Dan Hatton             & Waldek Hebisch\\
Karl Hegbloom          & Ralf Hemmecke          & Tony Hearn\\
Henderson              & Antoine Hersen         & Nicholas J. Higham\\
Lou Hodes              & Alan Hoffman           & Hoon Hong\\
Roger House            & Gernot Hueber          & Pietro Iglio\\
Joan Jaffe             & Alejandro Jakubi       & Richard Jenks\\
Bo Kagstrom            & William Kahan          & Kyriakos Kalorkoti\\
Kai Kaminski           & Grant Keady            & Tom Kelsey\\
Wilfrid Kendall        & Tony Kennedy           & David Kincaid\\
Keshav Kini            & Knut Korsvold          & Ted Kosan\\
\end{tabular}
\vfill
\newpage
\begin{tabular}{lll}
Paul Kosinski          & Igor Kozachenko        & Fred Krogh\\
Klaus Kusche           & Bernhard Kutzler       & Tim Lahey\\
Larry Lambe            & Kaj Laurson            & Charles Lawson\\
George L. Legendre     & Franz Lehner           & Frederic Lehobey\\
Michel Levaud          & Howard Levy            & J. Lewis\\
Ren-Cang Li            & John Lipson            & Rudiger Loos\\
Craig Lucas            & Michael Lucks          & Richard Luczak\\
Camm Maguire           & Dave Mainey            & Francois Maltey\\
William Martin         & Ursula Martin          & Osni Marques\\
Alasdair McAndrew      & Bob McElrath           & Michael McGettrick\\
Bob McNeill            & Edi Meier              & Ian Meikle\\
David Mentre           & Jonathan Millen        & Victor S. Miller\\
Gerard Milmeister      & William Miranker       & Mohammed Mobarak\\
H. Michael Moeller     & Michael Monagan        & Marc Moreno-Maza\\
Scott Morrison         & Joel Moses             & Mark Murray\\
William Naylor         & Patrice Naudin         & C. Andrew Neff\\
John Nelder            & Godfrey Nolan          & Arthur Norman\\
Jinzhong Niu           & Michael O'Connor       & Summat Oemrawsingh\\
Kostas Oikonomou       & Humberto Ortiz-Zuazaga & Julian A. Padget\\
Bill Page              & David Parnas           & Norm Pass\\
Susan Pelzel           & Michel Petitot         & Didier Pinchon\\
Ayal Pinkus            & Frederick H. Pitts     & Frank Pfenning\\
Jose Alfredo Portes    & E. Quintana-Orti       & Gregorio Quintana-Orti\\
Beresford Parlett      & A. Petitet             & Andre Platzer\\
Peter Poromaas         & Greg Puhak             & Claude Quitte\\
Arthur C. Ralfs        & Norman Ramsey          & Anatoly Raportirenko\\
Guilherme Reis         & Huan Ren               & Albert D. Rich\\
Michael Richardson     & Jason Riedy            & Renaud Rioboo\\
Robert Risch           & Jean Rivlin            & Nicolas Robidoux\\
Simon Robinson         & Raymond Rogers         & Michael Rothstein\\
Martin Rubey           & Jeff Rutter            & R.W Ryniker II\\
Philip Santas          & David Saunders         & Alfred Scheerhorn\\
William Schelter       & Gerhard Schneider      & Martin Schoenert\\
Marshall Schor         & Frithjof Schulze       & Fritz Schwartz\\
Steven Segletes        & V. Sima                & Nick Simicich\\
William Sit            & Elena Smirnova         & Jacob Nyffeler Smith\\
Matthieu Sozeau        & Srinivasan Seshan      & Ken Stanley\\
Jonathan Steinbach     & Fabio Stumbo           & Christine Sundaresan\\
Klaus Sutner           & Robert Sutor           & Moss E. Sweedler\\
Eugene Surowitz        & Yong Kiam Tan          & Max Tegmark\\
T. Doug Telford        & James Thatcher         & Laurent Thery\\
Balbir Thomas          & Mike Thomas            & Carol Thompson\\
Dylan Thurston         & Francoise Tisseur      & Steve Toleque\\
Dick Toupin            & Raymond Toy            & Barry Trager\\
Hale Trotter           & Themos T. Tsikas       & Gregory Vanuxem\\
Kresimir Veselic       & Christof Voemel        & E.G. Wagner\\
Bernhard Wall          & Paul Wang              & Stephen Watt\\
Andreas Weber          & Jaap Weel              & Al Weis\\
Juergen Weiss          & M. Weller              & Mark Wegman\\
James Wen              & Thorsten Werther       & Michael Wester\\
R. Clint Whaley        & James T. Wheeler       & John M. Wiley\\
Berhard Will           & Clifton J. Williamson  & Stephen Wilson\\
Shmuel Winograd        & Robert Wisbauer        & Sandra Wityak\\
Waldemar Wiwianka      & Knut Wolf              & Yanyang Xiao\\
Liu Xiaojun            & Clifford Yapp          & David Yun\\
Qian Yun               & Vadim Zhytnikov        & Richard Zippel\\
Evelyn Zoernack        & Bruno Zuercher         & Dan Zwillinger\\
\end{tabular}
\newpage

\tableofcontents
\vfill
\eject
\setlength{\parindent}{0em}
\setlength{\parskip}{1ex}
{\Large{\bf New Foreword}}
\vskip .25in

On October 1, 2001 Axiom was withdrawn from the market and ended
life as a commercial product.
On September 3, 2002 Axiom was released under the Modified BSD
license, including this document.
On August 27, 2003 Axiom was released as free and open source
software available for download from the Free Software Foundation's
website, Savannah.

Work on Axiom has had the generous support of the Center for 
Algorithms and Interactive Scientific Computation (CAISS) at
City College of New York. Special thanks go to Dr. Gilbert 
Baumslag for his support of the long term goal.

The online version of this documentation is roughly 1000 pages.
In order to make printed versions we've broken it up into three
volumes. The first volume is tutorial in nature. The second volume
is for programmers. The third volume is reference material. We've
also added a fourth volume for developers. All of these changes
represent an experiment in print-on-demand delivery of documentation.
Time will tell whether the experiment succeeded.

Axiom has been in existence for over thirty years. It is estimated to
contain about three hundred man-years of research and has, as of
September 3, 2003, 143 people listed in the credits. All of these
people have contributed directly or indirectly to making Axiom
available.  Axiom is being passed to the next generation. I'm looking
forward to future milestones.

With that in mind I've introduced the theme of the ``30 year horizon''.
We must invent the tools that support the Computational Mathematician
working 30 years from now. How will research be done when every bit of
mathematical knowledge is online and instantly available? What happens
when we scale Axiom by a factor of 100, giving us 1.1 million domains?
How can we integrate theory with code? How will we integrate theorems
and proofs of the mathematics with space-time complexity proofs and
running code? What visualization tools are needed? How do we support
the conceptual structures and semantics of mathematics in effective
ways? How do we support results from the sciences? How do we teach
the next generation to be effective Computational Mathematicians?

The ``30 year horizon'' is much nearer than it appears.

\vskip .25in
%\noindent
Tim Daly\\
CAISS, City College of New York\\
November 10, 2003 ((iHy))
\vfill
\eject
\pagenumbering{arabic}
\setcounter{chapter}{1} % Chapter 1


%\chapter{A Short Description}
%\chapter{Getting Started}
%\chapter{Tutorial}
%\chapter{A Full Example}
%\chapter{Reference}
%\chapter{Architecture}

\chapter{Motivation}

This literate program contains the actual source code for the new Sane
version of Axiom. One of the key goals is to support understanding and
long-term maintenance of this new version of Axiom.Key ideas as well
as their implementation in code details are discussed.

Axiom support ``First Class Dynamic Types''

\begin{quote}
{\bf Let us change our traditional attitude to the construction of
programs. Instead of imagining that our main task is to instruct a
computer what to do, let us concentrate rather on explaining to 
human beings what we want a computer to do.}\\
-- Donald Knuth
\end{quote}

\begin{quote}
{\bf It would be a good thing to buy books if one could also buy the
time to read them; but one usually confuses the purchase of books with
the acquisition of thier contents. To desire that a man should retain
everything he has ever read, is the same as wishing him to retain in
his stomach all that he has ever eaten.}\\
-- Schopenhauer \cite{Scho16}
\end{quote}

\begin{quote}
{\bf Beware of bugs in the above code. I have only proved it correct,
not tried it.}\\
-- Donald Knuth
\end{quote}

\begin{quote}
{\bf No loop should be written down without providing proof of 
termination nor without stating the invariaant that will not be 
destroyed by the execution of the repeatable statement}\\
-- Edsger Dijkstra \cite{Dijk72}
\end{quote}

\begin{quote}
{\bf The only effective way to raise the confidence level of a program
significantly is to give a convincing proof of its correctness.}\\
-- Edsger Dijkstra \cite{Dijk72}
\end{quote}

\begin{quote}
{\bf The competent programmer is fully aware of the strictly limited
size of his own skull, therefore he approaches the programming task in
full humility.}\\
-- Edsger Dijkstra \cite{Dijk72}
\end{quote}

\begin{quote}
{\bf For any perceived shortcoming of Common Lisp you can write a
macro that fixes it for less effort than it takes to complain about it}
\end{quote}

\begin{quote}
{\bf A program without a specification cannot be incorrect, it can
only be surprising}\\
-- J.J. Horning
\end{quote}

\begin{quote}
{\bf A proof assistant is what happens if you spend all your time
developing a type checker for your language and forget that programs
also need to be run.}\\
-- Vladislav Zavialov \cite{Zavi}
\end{quote}

\begin{quote}
{\bf Mathematicians are notoriously bad at given the complete context
needed for definitions. One definition in the formal proof of the
Kepler conjecture took 40 revisions to get right}\\
-- Thomas Hales 
\end{quote}

Computational Mathematics has two nearly disjoint branches. 
One branch is proof systems, such as Coq, Agda, and Idris.
A second branch is computer algebra systems, such as Axiom,
Mathematica, and Maple.

There is a vast literature in each branch. However, the bibliographic
references are nearly disjoint.

There are attempts to prove various computer algebra algorithms in
proof systems. The dream is to have a full computer algebra system
developed in this manner. The key problem is that computer algebra
systems are very large, containing many thousands of algorithms.

There are almost no attempts to prove computer algebra systems
correct. One key problem is that most systems are not
well-founded. They are ad hoc, "it worked for me" development. Another
key problem is that most of the proof systems cannot handle fully
dependent type theory.

Axiom is unique among computer algebra systems as it has a scaffold
based on abstract algebra. Abstract algebra framework gives a solid
theoretical base that provides obvious places to provide algebraic
axioms.

Extending Axiom to provide these axioms means that they will be
inherited just as signatures are inherited. Proofs of algorithms can
refer to these axioms.

Axiom needs to be extended to include a specification language so that
the algorithms have exact specifications.

Axiom also needs to be extended with a proof language so algorithms
can have associated proofs.

Due to the complexity of these requirements and their need to
interact, it is clear that Axiom's compiler and interpreter need to be
re-architected and re-implemented.

Because all of these goals are based on type theory we have decided to
use the Common Lisp Object System (CLOS). CLOS classes define new
types at the Lisp level, providing a base case for type inference.

Type analysis will require both compile-time typing 
and gradual typing \cite{Bake84}.

\chapter{Why this effort won't succeed}

Ron Pressler \cite{Pres19} has several blog posts about software
verification, making some excellent points. He postulates a theorem:
\begin{verbatim}
   There does not exist a generally useful programming language
   where every program is feasibly verifiable.
\end{verbatim}

On the other hand, Doron Zeilberger \cite{Zeil02} writes:
\begin{quote}
In this process, computer algebra, that great implementer of
high-school algebra, will play a central role. The king (abstract
math) is dead. Long live the King (Concrete Mathematics).
\end{quote}

\chapter{The Problem}
\section{A Brief History}

Axiom\cite{Daly17} is a computer algebra system. It was originally
developed at IBM Research based on a proposal by James
Griesmer\cite{Blai70} in 1965, led to fruition by Richard
Jenks\cite{Dave84}. The project was called Scratchpad. A more complete
history is available in the online documentation.

Around this time the ideas of computational mathematics (CM) were ``in
the air''. There was the beginning of a branch of computer algebra
(CA) with developments, as descibed by Joel Moses \cite{Mose71}, like
SAINT and SIN. Anthony Hearn \cite{HEAR80} created REDUCE.

A second branch of computational mathematics was the development of
automated proof systems (PS). Early work in the area included the
idea, by Robinson \cite{Robi65}, ``resolution'', leading to
resolusion-based theorem proving. De Bruijn \cite{Brui68a} started
work on AUTOMATH.

Scratchpad grew out of the computer algebra branch of computational
mathematics. 

Though they are both areas of computational mathematics, issues such
as equality are treated differently. Davenport \cite{Dave02} addresses
the issue of equality and its several ambiguities.

\section{Parallel Development}

\section{Project Goals}

Computational mathematics has had intense development efforts on both
branches. But the two branches had very little overlap. \cite{Daly18}.

Axiom was released as a free and open source project. One of the
obvious goals, based on the observation that Computer Algebra is a
sub-area of Computational Mathematics, would be to ``prove Axiom
correct''.

This goal languished for many years. There were other goals that
had higher priority. There were various attempts at discussion on the
mailing list but no action.

\section{Visiting Scholar}

Around 2014 I started reading papers in the proof systems area. This
was extremely difficult because, after so many years of independent
development, the proof community had developed a language and notation
that was opaque to the unskilled. The language of Judgments and Rules,
written in what appears to the outsider as classical greek, required a
great deal of education and training to read.

One major impediment was that all of the interesting research papers
were published in paywalled journals. A 4 page paper costs 40
dollars. I needed access to hundreds of papers. This made it nearly
impossible to do research without a University connection.

In 2015 I read a paper by Jeremy Avigad \cite{Avig12a}. Since he was
at Carnegie Mellon, where I had previously worked, I called him to
discuss his paper. It was clear we had the same mathematical ideas but
no common ground for reducing them to practice. We were from different
branches of computational mathematics.

Jeremy invited me to audit a class he was developing around the proof
system LEAN \cite{8}. While probably a frustrating experience for
Jeremy, I found the class enlightening. I finally had a glimpse of the
notation and thought process behind proof systems.

Fortunately, around the beginning of 2016, I started ``dropping onto
campus'' at Carnegie Mellon University. I sat at a hallway table in
the Computer Science department several days a week. I had hoped to
use the local network to access research papers but I needed to be an
active member of the University.

By chance, Frank Pfenning \cite{9} walked by my table on a way to a
meeting. He didn't have time to talk but said I should make an
appointment with this secretary.

I developed a ``beg cycle'' presentation about the parallel
development of computational algebra and proof systems, ending with a
request to have library access by any possible means. Frank arranged
for me to be a ``visiting scholar'', sponsored by Klaus Sutner
\cite{10}. 

Now, as a University person, I could access and read leading edge
research papers. It made all the difference.

Several professors at CMU allowed me to audit courses, including Karl
Crary \cite{11}, Frank Pfenning, Andre Platzer \cite{12}, and others. 

\section{Refining the Project Goals}

I spent a ``survey year'' reading papers in computational mathematics,
trying to understand the areas of overlap. Eventually it was clear
that the subjects were nearly disjoint. Following the bibliography of
proof system papers generated one pile. Doing the same in computer
algebra generated another pile. There was hardly a name that occurred
in both piles.

It also became clear that ``Proving Axiom Correct'' was the wrong view
of the problem. Axiom had no global specification and without that it
made no sense to talk about ``Correct''. 

By 2018 I refined Axiom's project goals. The new goal was to ``Prove
Axiom Sane''. Sane's thesaurus lists synonyms like ``rational'',
``coherent'', ``judicious'', and ``sound'', all words used by the
proof system researchers. 

``Proving Axiom Sane'', the crossover project goal of uniting computer
algebra and proof systems, was the theme originally presented to Frank
Pfenning. It was now refined into a talk given at the International
Conference on Mathematics Software \cite{10} in August of 2018.

\section{Reduction to Practice}

By late 2018 the project goal was more specific. The goal was now
limited to the proving the many Greatest Common Divisor (GCD)
implementations in Axiom correct. There are GCD algorithms for
non-negative integers and GCD algorithms for things like
polynomials. Clearly there was a specific specifications for these
instances. There is also a specification of the general GCD algorithm,
so the notion of correctness made sense.

But there was the question of automation. Axiom needed a language to
express the specifications. It needed a language to express the
semantics of the implementation of GCD. It needed axioms that
expressed the properties of statements in the specification, such as
the commutativity axiom. It needed to hierarchically ``gather'' axioms
that apply from the type hierarchy (called Categories in Axiom) as
well as axioms specific to the instance (called a Domain in Axiom).

Beyond the language, Axiom needed a way to create and manipulate the
associated proofs. It needed a means to access existing proof systems
to carry out the verification of the proof correctness. The compiler
needs access to a proof checker to validate the proof at compile time.

There was much to be done.

\section{Subgoal: A new implementation}

Axiom is a large (about 1.2 million line) system implemented in Common
Lisp. The code base grew ``by accretion'', originally from a MacLisp
\cite{11} base, ported to Lisp/VM \cite{Dave85}, and then ported to Common
Lisp \cite{Stee90}. Since it was born as a research project there was no
real effort to make it into a ``product'' until it was sold to The
Numerical Algorithms Group (NAG) \cite{IBMx91}.

The net result is that the original code base was not really a good
foundation for full computational mathematics. But Axiom has several
thousand working functions, many derived from PhD thesis work, that
could not practically be duplicated from scratch.

So the first step toward a Sane Axiom system would be to restructure
the compiler and interpreter ``from the ground up'' with the
requirement that it could execute the existing algorithms.

After much pondering, the design decision would be to use the Common
Lisp Object System (CLOS) \cite{15} as the new basis for Axiom.

One reason for this choice is that the base is still Common Lisp so it
would be possible to reuse existing pieces of code.

Another reason is the CLOS objects are considered ``types'' so they
could be used in the proof system style of type checking. This gives a
way to introduce type checking at the Lisp level, below the Axiom
Category and Domain abstraction. It also gives a firm basis for
reasoning about dependent types.

\chapter{An Inside-Out Approach}

The traditional approach to compiler development starts with a BNF
\cite{16} definition of the language syntax, followed by an
intermediate representation, and then one of several ``back end''
implementations of the runtime.

Instead, a new approach evolved. It would be possible to re-cast the
Axiom Category and Domain hierarchy as CLOS types. Furthermore, since
the CLOS types are automatically checked for precedence at compile
time, problems in inheritance are caught early.

CLOS classes can be hand-written. This means that the usual
intermediate compiler language could actually be read, constructed,
and modified by hand. 

Constructing Axiom in CLOS ``from the inside'' means that the surface
syntax of Axiom, called Spad (short for Scratchpad), could be created
later with the clear target of a working intermediate.

Since the intermediate CLOS code needed to support the surface
language it should be possible to automatically create the surface
language from the CLOS. That makes it clear that the surface language
was fully supported by the CLOS implementation.

It also means that the traditional parser could be developed later in
the project with a very clear target language that fully supports all
of the surface language features.

\section{AxiomClass}

Axiom has Categories, not the same as the categories of category
theory. The Categories are essentially types from type theory.

In Common Lisp the type hierarchy has a most general type 't'.
In CLOS we define a new type {\bf AxiomClass} to be the most general
\index[code]{AxiomClass!Category}
\index[code]{Category!AxiomClass}
type of our hierarchy. AxiomClass inherits methods from 't', such as
{\bf print-object}.

AxiomClass provides the base definition for slots that every Category,
Domain, and Package will have. Not all of them are in use for every
case but this provides a place to add new features that work for every
class.

AxiomClass provides {\bf print-object} for the classes. The general
case print-object will construct and print the source code that
corresponds to the defclass definition. So, as if by magic, we can
build the source code from the intermediate CLOS defclass.

This leads to the idea of building the compiler 'inside out'. Normally
one would define the language syntax, write a parser, construct an
intermediate abstract syntax tree (AST) that holds the result of the
parse, and then construct a back end to a target machine.

However, CLOS is human readable and constructable. So we have taken
the novel approach of writing the AST in CLOS and 'deriving' the
source code from the AST. Later construct a parser that will accept
the output of 'print-object', parse it, and reconstruct the CLOS
defclass.

This means that we have a 'round trip' test of the parser. Every
defclass prints its source representation. The parser must recreate
the defclass from the printed source.

Refer to the AxiomClass \ref{AxiomClass}
section for more detailed information.

\section{Categories}

We need to construct the Axiom Category (aka type) hierarchy in CLOS.
We will use the term 'type' to signify Axiom objects, since the
defclass definitions are valid Common Lisp types.

We can do this because CLOS support inheritance.

Axiom can print the list of ancestors for a given type. For example,
PolynomialCategory ancestors are:
\begin{verbatim}
getAncestors 'PolynomialCategory

   (3)
   {AbelianGroup, AbelianMonoid, AbelianMonoidRing, 
    AbelianSemiGroup, Algebra, BasicType, BiModule, 
    CancellationAbelianMonoid, CharacteristicNonZero,
    CharacteristicZero, CoercibleTo, CommutativeRing, 
    ConvertibleTo, EntireRing, Evalable, FiniteAbelianMonoidRing,
    FullyLinearlyExplicitRingOver, FullyRetractableTo, GcdDomain,
    InnerEvalable, IntegralDomain, LeftModule, LeftOreRing,
    LinearlyExplicitRingOver, Module, Monoid, OrderedSet,
    PartialDifferentialRing, PatternMatchable, 
    PolynomialFactorizationExplicit, RetractableTo, RightModule, 
    Ring, Rng, SemiGroup, SetCategory, UniqueFactorizationDomain}
                                                            Type: Set(Symbol)
\end{verbatim}

PolynomialCategory is quite high up in the type hierarchy (15 levels up,
actually) so most of these are already inherited. We provide a program
(called {\bf leaves}), that given the above list will compute the
types that are not inherited. For example, given the above Axiom
output,
\begin{verbatim}
(leaves '(|AbelianGroup| |AbelianMonoid| |AbelianMonoidRing| 
    |AbelianSemiGroup| |Algebra| |BasicType| |BiModule| 
    |CancellationAbelianMonoid| |CharacteristicNonZero|
    |CharacteristicZero| |CoercibleTo| |CommutativeRing| 
    |ConvertibleTo| |EntireRing| |Evalable| |FiniteAbelianMonoidRing|
    |FullyLinearlyExplicitRingOver| |FullyRetractableTo| |GcdDomain|
    |InnerEvalable| |IntegralDomain| |LeftModule| |LeftOreRing|
    |LinearlyExplicitRingOver| |Module| |Monoid| |OrderedSet|
    |PartialDifferentialRing| |PatternMatchable| 
    |PolynomialFactorizationExplicit| |RetractableTo| |RightModule| 
    |Ring| |Rng| |SemiGroup| |SetCategory| |UniqueFactorizationDomain|))

(|ConvertibleTo| |Evalable| |FiniteAbelianMonoidRing|
 |FullyLinearlyExplicitRingOver| |OrderedSet| |PartialDifferentialRing|
 |PatternMatchable| |PolynomialFactorizationExplicit|)
\end{verbatim}

The PolynomialCategory class only needs to inherit the types that are
listed by the leaves program.

CLOS computes the precendence of types in the hierarchy. This provides
assurance that the Axiom category hierarchy is, at least at a minimum,
reasonably constructed.

\section{Domains and Packages}

Domains add a representation (called a ``carrier'' in logic).

In addition to the axioms inherited from the category hierarchy,
domains add additional axioms to characterize the properties of
the representation. These additional axioms contribute to the
proof.

\chapter{A Specification Language}

\begin{quote}
{\bf If it compiles, it works {\sl as specified}.}\\
-- Vladislav Zavialov \cite{Zavi}
\end{quote}

\begin{quote}
{\bf Real programming languages are inevitably complex, and any
serious attempt to give a formal treatment of such a language and a
development framework based on it is an ambitious undertaking
bringing a host of problems that do not arise when considering toy
programming languages or when considering specification and formal
development in abstract terms. Our EML experience suggests that, at
least at the present time, tackling the problems of specification
and formal development in a real programming language at a fully
formal level is just too difficult}\\
-- Donald Sannella and Andrzej Tarlecki \cite{Sann99}
\end{quote}

We must distinguish the language used for specification (the 
{\sl what} from the language for implementation the {\sl how}.

Sannella, et al. \cite{Sann91,Sann99} develop a specification language
for Standard ML (SML) \cite{Miln90,Miln91}

Kahrs and Sannella \cite{Kahr98} designed EML to provde a
specification language for ML. They point out that they want a
formal connection between the language (P) and the specifications (S).
They write:
\begin{quote}
Given that aim, it is not possible to come up with a meaningful
specification language for P unless P has a formal semantics.
Without a formal semantics for P we are not certain what P-programs
are supposed to do, making it impossible to establish reliably any 
property of any P-program or to prove interesting relationships
between P-programs and S-specifications. Unfortuately, this
requirement rules out most present-day programming languages.
\end{quote}

The Axiom Sane effort is trying to design a specification language for
the mathematics implemented by Axiom, not a specification language for
Axiom's Spad language.

The notion of ``exceptions'' in mathematics is unclear.  Since Axiom
implements mathematical functions it is not much of a concern. 
Side-effects are also not much of a concern, at least for the
mathematical algorithms.

As such, the Sane effort is a ``domain specific specification'', 
not a ``language specific specification''. If there is a Spad
language construct used to implement a function, all one has to
show is that the language construct ``covers'' the use case in
the particular function.

They raise a series of question about a specification \cite{Sann99}
\begin{enumerate}
\item What is a specifiation?
\item What does a specification mean?
\item When does a program satisfy a specification?
\item When does a specification guarantee a property that it does not
state explicitly?
\item How does one prove this?
\item How are specifications structured?
\item How does the structure of a specification relate to the
structure of programs?
\item When does one specification correctly refine another
specification?
\item How does one prove correctness of refinement steps?
\item When do refinement steps compose?
\item What is the role of information hiding?
\end{enumerate}

The specification language is related to what we wish to prove. 
\cite{Kahr98}. Is it a
\begin{enumerate}
\item proof that a given program satisfies a given specification?
\item proof that one specification is a refinement of another?
\item proof that all programs satisfying a given specification will
satisfy a given property?
\end{enumerate}

John Hughes \cite{Hugh19} identifies several types of specification tests:
\begin{enumerate}
\item invariant properties
\item postconditions
\item metamorphic properties
\item inductive properties
\item model-based properties
\end{enumerate}

\begin{chunk}{ignore}
(defclass specification ()
  ((precondition  :initarg :precondition  :initform nil :accessor spec-precondition)
   (postcondition :initarg :postcondition :initform nil :accessor spec-postcondition)))

\end{chunk}

\chapter{Primitive Support tools}

\noindent
Due to type checking, these functions have to appear early in the file
but we do it by using the literate reference.

\chapter{Overview}

\begin{quote}
{\bf Data are just dumb programs}\\
-- Dan Friedman
\end{quote}

\begin{quote}
{\bf The classic hacker disdain for "bondage and discipline languages"
is short sighted -- the needs of large, long-lived multi-programmer
projects are just different than the quick work you do for yourself.}\\
-- John Carmack
\end{quote}

\begin{quote}
{\bf If you have a large enough codebase, any class of error that is
syntactically legal probably exists there.}\\
-- John Carmack
\end{quote}

\begin{quote}
{\bf Anything that isn't clear to your static analysis tool probably
isn't clear to your fellow programmers either.}\\
-- John Carmack
\end{quote}

\begin{quote}
{\bf A lot of the serious reported errors are due to modifications of
code long after it was written.}\\
-- John Carmack
\end{quote}

\begin{quote}
{\bf The first step is fully admitting that the code you write is
riddled with errors. That is a bitter pill to swallow for a lot
of people, but without it, most suggestions for change will be
viewed with irritation or outright hostility. You have to want
criticism of your code.}\\
-- John Carmack
\end{quote}

\noindent
The {\bf *Categories*} variable contains a list of all defined Categories.
\index[code]{*Category*}
\index[code]{defvar!*Categories*}
\index[code]{*Categories*!defvar}
\begin{chunk}{defvar categories}
(defvar *Categories* nil)

\end{chunk}

\noindent
The {\bf *Domains*} variable contains a list of all defined Domains.
\index[code]{defvar!*Domains*}
\index[code]{*Domains*!defvar}
\begin{chunk}{defvar domains}
(defvar *Domains* nil)

\end{chunk}

\noindent
The {\bf *Packages*} variable contains a list of all defined Packages.
\index[code]{defvar!*Packages*}
\index[code]{*Packages*!defvar}
\begin{chunk}{defvar packages}
(defvar *Packages* nil)

\end{chunk}

\index[code]{defvar!*indent*}
\index[code]{*indent*!defvar}
\begin{chunk}{defvar indent}
(defvar *indent* "    ")

\end{chunk}

\section{The Category Class}

\cite[p4]{Dosr11}
\cite{Daly17}

\begin{itemize}
\item {\bf marker} is a constant to know if something is a category,
a domain, or a package.
\item {\bf parents} is a list of the direct parents of this 
category.
\item {\bf CategoryForm} holds the canonical category form of the expression
whose evaluation produces the category object under consideration
\item {\bf ExportInfoList} holds a list of function signatures exported by the
category
\item {\bf AttributeList} holds a list of attributes and the conditions under
which they hold
\item {\bf CategoryMark} always contains the form (Category). It serves as a
runtime type checking tag
\item {\bf PrincipalAncestorList} is a list of principal ancestor category forms
\item {\bf ExtendedCategoryList} is a list of directly extended category forms
\item {\bf DomainInfoList} is a list of domains explicitly used in that category
\item {\bf UsedDomainList} holds the list of all domain forms mentioned in
the exported signatures
\end{itemize}

%\index[code]{hasclause!defclass}
\index[code]{defclass!hasclause}
\begin{chunk}{defclass hasclause}
(defclass hasclause ()
  ((whichtype :initarg :whichtype :initform nil  :accessor hasclause-whichtype)
   (condition :initarg :condition :initform nil  :accessor hasclause-condition)
   (siglist   :initarg :siglist   :initform nil  :accessor hasclause-siglist)))

\end{chunk}

\index[code]{make-hasclause!defun}
\index[code]{defun!make-hasclause}
\begin{chunk}{defun make-hasclause}
(defun make-hasclause (type condition siglist)
  (make-instance 'hasclause :whichtype type :condition condition :siglist siglist))

\end{chunk}

\index[code]{print-object!defmethod!hasclause}
\index[code]{defmethod!print-object!hasclause}
\index[code]{hasclause!defmethod!print-object}
\begin{chunk}{defmethod print-object}
(defmethod print-object ((clause hasclause) stream)
  (let ((deeper (concatenate 'string "  " *indent*)))
    (format stream "if ~a has ~a then~%~a~a~%" 
      (hasclause-whichtype clause)
      (hasclause-condition clause)
      deeper
      (hasclause-siglist clause))))

\end{chunk}

\index[code]{haslist!defclass}
\index[code]{defclass!haslist}
\begin{chunk}{defclass haslist}
(defclass haslist ()
  ((clauses :initarg :clauses :initform nil :accessor haslist-clauses)))

\end{chunk}

\index[code]{make-haslist!defun}
\index[code]{defun!make-haslist}
\begin{chunk}{defun make-haslist}
(defun make-haslist (clauses)
  (make-instance 'haslist :clauses clauses))

\end{chunk}

The {\bf AxiomClass} is a place to hang Axiom-specific methods.
\label{AxiomClass}
\index[code]{defclass!AxiomClass}
\index[code]{AxiomClass!defclass}
\begin{chunk}{defclass AxiomClass}
(defclass |AxiomClass| ()
  ((marker :initform 'category :accessor marker :initarg :marker)
   (name :initform "AxiomClass" :reader name :allocation :class)
   (parents :initarg :parents 
            :accessor parents 
            :initform nil
            :type (or null list)
            :documentation "A list of direct parents")
   (level        :initarg :level        :reader   level)
   (abbreviation :initarg :abbreviation :reader   abbreviation)
   (macros       :initarg :macros       :accessor macros   :initform nil)
   (comment      :initarg :comment      :accessor comment  :initform nil)
   (argslist     :initarg :arg          :accessor argslist :initform nil)
   (withlist     :initarg :with         :accessor withlist :initform nil)
   (haslist      :initarg :has          :accessor haslist  :initform nil)
   (addlist      :initarg :add          :accessor addlist  :initform nil)))

\end{chunk}

\index[code]{print-object!AxiomClass}
\index[code]{AxiomClass!methods!print-object}

The print-oject method for AxiomClass re-creates the source level
language from the internal data structures. The output of print-object
should exactly mirror the input syntax. This allows ``round-trip'' 
assurance that the source code and its intermediate representation
match.

Format control strings are used to create output from the print-object
function. Because we may want to (dynamically?) change the output of
any AxiomClass object, we provide the control strings as global 
variables. 

\index[code]{print-object!defmethod!AxiomClass}
\index[code]{defmethod!print-object!AxiomClass}
\index[code]{AxiomClass!defmethod!print-object}
\begin{chunk}{defmethod print-object}
(defvar formatCategoryAbbrev "~&)abbrev category ~a ~a")
(defvar formatCategorySIG "~&~a(~{~a~^, ~}) : Category == SIG where~2%")
(defvar formatCategoryComment "~&~{~^++ ~a~%~}~%")

(defvar formatDomainAbbrev   "~&)abbrev domain ~a ~a")
(defvar formatDomainSIG      "~&~a(~{~a~^, ~}) : SIG == CODE where~2%")
(defvar formatDomainComment  "~&~{~^++ ~a~%~}~%")

(defvar formatPackageAbbrev  "~&)abbrev package ~a ~a")
(defvar formatPackageSIG     "~&~a(~{~a~^, ~}) : SIG == CODE where~2%")
(defvar formatPackageComment "~&~{~^++ ~a~%~}~%")

(defvar formatNoSuper        "  SIG ==> () ")
(defvar formatSuper          "  SIG ==> ~a ")
(defvar formatJoin           "  SIG ==> Join(~{~a~^,~%               ~}) ")

(defvar formatWith           "with ~%")
(defvar formatWithNil        "with nil~%")

(defvar formatSig            "    ~a~%")

(defvar formatHas            "~%~aif % has ~a then~%")
  
(defvar formatAdd            "  add ~%")

(defmethod print-object ((cat |AxiomClass|) stream)
  (let (has condition)
   (cond
     ((eq (marker cat) 'category)
       (format stream formatCategoryAbbrev (abbreviation cat) (name cat))
       (format stream formatCategoryComment (comment cat))
       (format stream formatCategorySIG (name cat) (argslist cat)))
     ((eq (marker cat) 'domain)
       (format stream formatDomainAbbrev (abbreviation cat) (name cat))
       (format stream formatDomainComment (comment cat))
       (format stream formatDomainSIG (name cat) (argslist cat)))
     ((eq (marker cat) 'package)
       (format stream formatPackageAbbrev (abbreviation cat) (name cat))
       (format stream formatPackageComment (comment cat))
       (format stream formatPackageSIG (name cat) (argslist cat))))
   (let ((adults (parents cat)))
     (cond
      ((null adults) (format stream formatNoSuper))
      ((= (length adults) 1) (format stream formatSuper (car adults)))
      (t (format stream formatJoin adults))))
   (if (withlist cat)
     (progn
       (format stream formatWith)
       (dolist (sig (withlist cat))
         (format stream formatSig sig)))
     (format stream formatWithNil))
   (if (setq has (car (haslist cat))) 
     (progn
       (setq condition (car (haslist-clauses has)))
       (format stream formatHas *indent* (hasclause-condition condition))
       (let ((*indent* (concatenate 'string *indent* "  ")))
         (dolist (sig (hasclause-siglist condition))
           (format stream formatSig sig)))))
   (when (addlist cat)
     (format stream formatAdd)
     (dolist (sig (addlist cat))
       (format stream "~%    ~a~%" sig)))))

\end{chunk}

\begin{chunk}{defclass typeParam}
(defclass typeParam ()
  ((variable   :initarg :variable  :reader typeParam-variable)
   (paramtype  :initarg :paramtype :reader typeParam-paramtype)))

\end{chunk}

\index[code]{print-object!defmethod!typeParam}
\index[code]{defmethod!print-object!typeParam}
\index[code]{typeParam!defmethod!print-object}
\begin{chunk}{defmethod print-object}
(defmethod print-object ((param typeParam) stream)
  (format stream "~a:~a"
    (typeParam-variable param)
    (typeParam-paramtype param)))

\end{chunk}

\begin{chunk}{defclass WithClass}
(defclass |WithClass| () ())

\end{chunk}

\begin{chunk}{defclass AddClass}
(defclass |AddClass| () ())

\end{chunk}

%\index[code]{showSig!CategoryClass}
\index[code]{CategoryClass!methods!showSig}
The {\bf showSig} method will show a signature of a CategoryClass
object in abbreviated forms. So, for example,
\begin{verbatim}
   (showSig |PAdicIntegerCategory|) ==> PADICCT(EUCDOM,CHARZ)
\end{verbatim}
\begin{chunk}{defgeneric showSig}
(defgeneric showSig (name))

\end{chunk}

\begin{chunk}{defmethod showSig}
(defmethod showSig ((name |AxiomClass|))
  (let ((parents (parents name)) abbrevs)
   (dolist (him parents) (push (abbreviation (symbol-value him)) abbrevs))
   (format t "~a(~{~a~^,~})~%"  (abbreviation name) (nreverse abbrevs))))

\end{chunk}

\section{Helper Functions}

The {\bf defunt} macro allows specifying the type {\tt INT} in
an argument list. For example, these are all valid:
\begin{verbatim}
   (defunt one (p1 p2) ....)
   (defunt one ((int p1) p2) ...)
   (defunt one ((int p1) (int p2)) ...)
\end{verbatim}

\index[code]{defunt}
\begin{chunk}{defmacro defunt}
(defmacro defunt (name (&rest args) &body body)
  "defun with optional type declarations"
  `(progn
     (declaim (ftype
               (function
                ,(let (declares)
                  (dolist (arg args)
                   (push
                    (if (listp arg)
                      (if (equalp (string (first arg)) "int")
                        'fixnum
                        (first arg))
                      t)
                     declares))
                   declares)
                 t) ,name))
     (defun ,name
       ,(loop for arg in args
          collect
            (if (listp arg)
                (second arg)
                arg))
       ,@body)))

\end{chunk}

We usually want lines without leading and trailig spaces. The 
common lisp idiom for this is very wordy so we make a macro.
\begin{chunk}{defmacro trim}
(defmacro trim (arg)
  `(string-trim '(#\space) ,arg))

\end{chunk}

Here we create the Axiom {\bf getAncestors} function. It walks the
tree of ancestors to collect the union of the set. 

This accepts the symbol for the class or the instance.
\begin{chunk}{defun getAncestors}
(defun getAncestors (symbol)
  (labels (
    (theAncestors (name)
      ; look up the ancestors 
      (let (class)
        (cond
         ((and (symbolp name) (setq class (find-class name nil)))
           (parents (make-instance class)))
         (t
           (parents 
             (make-instance 
               (class-name (class-of (symbol-value name))))))))))
  (let (name todo result)
   (setq todo (theAncestors symbol))
   (loop while todo do
     (setq name (pop todo))
     (unless (member name result) (push name result))
     (setq todo (set-difference (union (theAncestors name) todo) result)))
  (sort result #'string<))))
  
\end{chunk}

We need to compute the most immediate ancestors (the leaves) of the 
type tree.
\begin{chunk}{defun leaves}
(defun leaves (survive)
  (let ((l survive))
    (dolist (thing l) (setq survive (set-difference survive (getAncestors thing))))
  survive))

\end{chunk}

We introduce the concept of a {\bf level}
\index[doc]{level}
to order classes based on how deep they are in the inheritance
hierarchy. Level 1 Categories only depend on {\bf CategoryClass}.
Level 2 Categories only depend on Level 1, etc.

We order the class inheritance list based on level.

Here we need to be able to know what level to assign to a Category.
Each level defines a variable, e.g. {\bf level1}, {\bf level2}, etc
that contains all of the Category instance symbols defined at that
level.

\begin{chunk}{defmacro ll}
(defmacro ll (name)
  `(cond
     ((member ',name level1) 'level1)
     ((member ',name level2) 'level2)
     ((member ',name level3) 'level3)
     ((member ',name level4) 'level4)
     ((member ',name level5) 'level5)
     ((member ',name level6) 'level6)
     ((member ',name level7) 'level7)
     ((member ',name level8) 'level8)
     ((member ',name level9) 'level9)
     ((member ',name level10) 'level10)
     ((member ',name level11) 'level11)
     ((member ',name level12) 'level12)
     ((member ',name level13) 'level13)
     ((member ',name level14) 'level14)
     ((member ',name level15) 'level15)
     ((member ',name level16) 'level16)
     ((member ',name level17) 'level17)
     ((member ',name level18) 'level18)
     ((member ',name level19) 'level19)
  ))

\end{chunk}

Here we create the Axiom {\bf getDomains} function. It finds all of the
domains that inherit this class. Given a domain it return an empty set.
\begin{chunk}{defun getDomains}
(defun getDomains ())

\end{chunk}

\subsection{Signatures and OperationAlist}
\index[doc]{Signatures}
\index[doc]{OperationAlist}

The {\bf OperationAlist} is a list of all of the operations that are available
for the domain. Note that if there are two operations with the same name then
they are combined into one operation but with different signatures.

\index[code]{signature!defclass}
\index[code]{defclass!signature}
\begin{chunk}{defclass signature}
(defclass signature ()
  ((name      :initarg :name      :initform ""  :accessor signature-name)
   (returns   :initarg :returns   :initform nil :accessor signature-returns)
   (arguments :initarg :arguments :initform nil :accessor signature-arguments)
   (comment   :initarg :comment   :initform nil :accessor signature-comment)
   (examples  :initarg :examples  :initform nil :accessor signature-examples)
   (infix?    :initarg :infix     :initform nil :accessor signature-infix)))

(defun make-signature (funcname return arglist 
                       &optional (comment nil) (examples nil) (infix? nil))
  (make-instance 'signature :name funcname 
                            :returns return 
                            :arguments arglist 
                            :comment comment
                            :examples examples
                            :infix infix?))

\end{chunk}

\index[code]{print-object!defmethod!signature}
\index[code]{defmethod!print-object!signature}
\index[code]{signature!defmethod!print-object}
\begin{chunk}{defmethod print-object}
(defvar signatureFormatNull       "~&~a~a ")
(defvar signatureFormat1Arg       "~&~a~a : ~{~^~a~^,~} -> ~a")
(defvar signatureFormatArgs       "~&~a~a : (~{~^~a~^,~}) -> ~a")
(defvar signatureFormatListArg    "List(~{~a~^,~})")
(defvar signatureFormatArgsType   "~a(~{~a~^,~})")
(defvar signatureFormatUnion      "Union(~{~s~^,~})")
(defvar signatureFormatRecord     "Record(~{~a: ~a~^,~})")
(defvar signatureFormatReturnList "List(~{~a~^,~})")
(defvar signatureFormatReturnType "~a(~{~s~^,~})")
(defvar signatureFormatComment    "~&~a  ++ ~a")
(defvar signatureFormatExamples   "~&~a  ++X ~a")

(defmethod print-object ((sig signature) stream)
  (labels (
    (singletonList? (args)
      ; change singleton list into a single element
      (loop for arg in args 
        when (and (consp arg) (= (length arg) 1)) do (setq arg (car arg))
        collect arg))
    (argsList? (args) 
      ; Is the args type a List?
 (format t "argsList=~s~%" args)
      (let (result)
        (dolist (arg args (nreverse result))
          (if (and (consp arg) (eq (car arg) '|List|))
            (push (format nil signatureFormatListArg
                      (substitute 'K '|#1| (cdr arg)))
             result)
          (push arg result)))))
    (argsType? (args) 
      ; Is the args type a List?
 (format t "argsType=~s~%" args)
      (let (result)
        (dolist (arg args (nreverse result))
          (if (and (consp arg) (symbolp (car arg)))
            (push (format nil signatureFormatArgsType (car arg)
                      (substitute 'K '|#1| (cdr arg)))
             result)
          (push arg result)))))
    (union? (returns) 
      ; Is the return type a Union?
 (format t "union=~s~%" returns)
      (if (and (consp returns) (eq (car returns) '|Union|))
         (setq returns (format nil signatureFormatUnion
                         (cdr (substitute '% '$  returns))))
         returns))
    (record? (returns) 
      ; Is the return type a Record?
 (format t "record=~s~%" returns)
      (let (result)
        (if (and (consp returns) (eq (car returns) '|Record|))
          (format nil signatureFormatRecord 
            (dolist (field (cdr returns) (nreverse result))
              (setq field (substitute '% '$ field))
              (push (second field) result)
              (push (third field) result)))
          returns)))
    (returnList? (returns) 
      ; Is the return type a List?
 (format t "returnList=~s~%" returns)
      (if (and (consp returns) (eq (car returns) '|List|))
         (setq returns (format nil signatureFormatReturnList
                         (cdr 
                           (substitute 'K '|#1|
                             (substitute '% '$  returns)))))
         returns))
    (returnType? (returns) 
      ; Is the return type a Type?
 (format t "returnType=~s~%" returns)
      (if (and (consp returns) (symbolp (car returns)))
         (setq returns (format nil signatureFormatReturnType (car returns)
                         (cdr 
                           (substitute 'K '|#1|
                             (substitute '% '$  returns)))))
         returns))
    (singletonVar? (returns) 
      ; Is the return type a single temp variable?
 (format t "singleVar=~s~%" returns)
      (if (eq returns '|#1|)
        'K
        returns))
    (infix? (sig)
 (format t "infix ~s ~s~%" (signature-infix sig) (signature-name sig))
      (if (signature-infix sig)
        (format nil "\"~a\"" (signature-name sig))
        (signature-name sig)))
    (formatWithlist (name args returns sig)
      ; for each signature in the list, make it pretty
 (format t "formatWithList name=~s args=~s returns=~s sig=~s~%" name args returns sig)
      (cond
        ((and (null args) (null returns))
          (format stream signatureFormatNull *indent* name))
        ((= (length args) 1) 
          (format stream signatureFormat1Arg *indent* name args returns))
        (t
          (format stream signatureFormatArgs *indent* name args returns)))
      (dolist (comment (signature-comment sig))
        (format stream signatureFormatComment *indent* comment))
      (when (signature-examples sig) 
        (dolist (example (signature-examples sig))
          (format stream signatureFormatExamples *indent* example))))
  )
  (let ((args (signature-arguments sig)) (returns (signature-returns sig)) name)
   (format t "main=~s~%" args)
    (setq name (infix? sig))
    ; handle the arg list cleanup
    (setq args (singletonList? args))
    (setq args (argsType? args))
    (setq args (mapcar #'singletonVar? args))
    ; handle return type cleanup
    (when (and (consp returns) (= (length returns) 1)) (setq returns (car returns)))
    (setq returns (union? returns))
    (setq returns (record? returns))
    (setq returns (returnType? returns))
    (setq returns (singletonVar? returns))
    ; and format the Withlist
    (formatWithlist name args returns sig))))

(defun signature-make (returns argumentlist)
  (make-instance 'signature 
    :returns returns
    :arguments argumentlist))

\end{chunk}

%\index[code]{macros!defclass}
\index[code]{defclass!macros}
\begin{chunk}{defclass amacro}
(defclass amacro ()
  ((name
     :initarg :name
     :initform ""
     :accessor amacro-name
     :type symbol)
   (body
     :initarg :body
     :initform nil
     :accessor amacro-body)))

\end{chunk}

\index[code]{operation!defclass}
\index[code]{defclass!operation}
\begin{chunk}{defclass operation}
(defclass operation ()
  ((name
     :initarg :name
     :initform ""
     :accessor operation-name
     :type string)
   (signatures
     :initarg :signatures
     :initform nil
     :accessor operation-signatures
     :type list)))

\end{chunk}

\index[code]{print-object!defmethod!operation}
\index[code]{defmethod!print-object!operation}
\index[code]{operation!defmethod!print-object}
\begin{chunk}{defmethod print-object}
(defvar *infixOperations* '("*" "**" "+" "<" "<=" "=" ">" ">=" "^"
                            "quo" "rem" "~=" "."))

(defmethod print-object ((op operation) stream)
  (let ((name (operation-name op)) (sigs (operation-signatures op)))
    (cond
      ((eq name '|Zero|) (setq name "0"))
      ((eq name '|One|)  (setq name  "1"))
      ((eq name '|elt|)  (setq name  ".")))
    (dolist (sig sigs)
      (if (member name *infixOperations* :test #'string=)
        (format stream "?~a? : ~a~%" name sig)
        (format stream "~a : ~a~%" name sig)))))

(defgeneric operation-add (operation signature))
(defmethod operation-add ((op operation) signature)
  (setf (operation-signatures op) (cons signature (operation-signatures op))))

(defun operation-make (name)
  (make-instance 'operation :name name))

\end{chunk}

From OperationAlist to Signatures
\begin{verbatim}
   (* (($ (|PositiveInteger|) $) NIL) (($ (|NonNegativeInteger|) $) NIL) (($ $ $) NIL))
                                        -> ?*? : (%,%) -> %
                                        -> ?*? : (NonNegativeInteger,%) -> %
                                        -> ?*? : (PositiveInteger,%) -> %
   (** (($ $ (|NonNegativeInteger|)) NIL) (($ $ (|PositiveInteger|)) NIL))
                                        -> ?**? : (%,PositiveInteger) -> %
                                        -> ?**? : (%,NonNegativeInteger) -> %
   (+ (($ $ $) NIL))                    -> ?+? : (%,%) -> %
   (< (((|Boolean|) $ $) NIL))          -> ?<? : (%,%) -> Boolean
   (<= (((|Boolean|) $ $) NIL))         -> ?<=? : (%,%) -> Boolean
   (= (((|Boolean|) $ $) NIL))          -> ?=? : (%,%) -> Boolean
   (> (((|Boolean|) $ $) NIL))          -> ?>? : (%,%) -> Boolean
   (>= (((|Boolean|) $ $) NIL))         -> ?>=? : (%,%) -> Boolean
   (|One| (($) NIL T CONST))            -> 1 : () -> %
   (|Zero| (($) NIL T CONST))           -> 0 : () -> %
   (^ (($ $ (|NonNegativeInteger|)) NIL) (($ $ (|PositiveInteger|)) NIL))
                                        -> ?^? : (%,PositiveInteger) -> %
                                        -> ?^? : (%,NonNegativeInteger) -> %
   (|coerce| (((|OutputForm|) $) NIL))  -> coerce : % -> OutputForm
   (|gcd| (($ $ $) 11))                 -> gcd : (%,%) -> %
   (|hash| (((|SingleInteger|) $) NIL)) -> hash : % -> SingleInteger
   (|latex| (((|String|) $) NIL))       -> latex : % -> String
   (|max| (($ $ $) NIL))                -> max : (%,%) -> %
   (|min| (($ $ $) NIL))                -> min : (%,%) -> %
   (|one?| (((|Boolean|) $) NIL))       -> one? : % -> Boolean
   (|qcoerce| (($ (|Integer|)) 8))      -> qcoerce : Integer -> %
   (|quo| (($ $ $) NIL))                -> ?quo? : (%,%) -> %
   (|random| (($ $) NIL))               -> random : % -> %
   (|recip| (((|Union| $ "failed") $) NIL))          
                                        -> recip : % -> Union(%,"failed")
   (|rem| (($ $ $) NIL))                -> ?rem? : (%,%) -> %
   (|sample| (($) NIL T CONST))         -> sample : () -> %
   (|shift| (($ $ (|Integer|)) 7))      -> shift : (%,Integer) -> %
   (|sup| (($ $ $) 6))                  -> sup : (%,%) -> %
   (|zero?| (((|Boolean|) $) NIL))      -> zero? : % -> Boolean
   (~= (((|Boolean|) $ $) NIL))         -> ?~=? : (%,%) -> Boolean
   (|divide| (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $) NIL))
                                        -> divide : (%,%) -> Record(quotient: %,remainder: %)
   (|exquo| (((|Union| $ "failed") $ $) NIL))
                                        -> exquo : (%,%) -> Union(%,"failed")
   (|subtractIfCan| (((|Union| $ "failed") $ $) 10))
                                        -> subtractIfCan : (%,%) -> Union(%,"failed")
\end{verbatim}
\begin{chunk}{defun operationToSignature}
(defun operationToSignature (alistEntry) 
  (let (returnType args sig result)
    (setq result (operation-make (car alistEntry)))
    (dolist (item (cdr alistEntry))
      (setq sig (substitute '% '$ (car item)))
      (setq returnType (car sig))
      (setq args (cdr sig))
      (operation-add result (signature-make returnType args)))
    result))

\end{chunk}

As painful as it is, this code strives to reproduce the exact output
of the {\bf )show} command in Axiom.

Functions with the same name but multiple signatures, such as {\bf *},
are stored in a single operation instance. We have to break up the
multiple signatures into single signatures. We do this with the {\bf
  split} function.

Some signatures are in tabular format. Longer signatures are output
after the table.  There are special cases and we keep a list of these
in the {\bf *forceLongs* variable}. Sigh.

The tabular format has two columns, the second column is at character
position 40. The SBCL tabular output in format is broken so we had to
create the {\bf padTo38} function to add pad characters to signatures.

\begin{chunk}{defvar forcelongs}
(defvar *forceLongs* '("exquo"))

\end{chunk}

\begin{chunk}{defun operations-show}
(defun operations-show (operationAlist)
  (labels (
    ; split multiple signatures
    (split (string)
       (splitchar string #\newline))
    ; Axiom wants certain lines delayed for no reason
    (forceLong (sig)
      (let (opname)
        (setq opname (subseq sig 0 (1- (position #\: sig))))
        (member opname *forceLongs* :test #'string=)))
    ; Axiom wants a tabular display
    (padTo38 (string)
      (let ((excess (- 38 (length string)))
            (pad "                                     "))
        (concatenate 'string string (subseq pad 0 excess)))))
  (let (sigs longlines shortlines (column 0))
   (dolist (op operationAlist) 
     ; operationToSignature might return multiple signatures
     (setq sigs (format nil "~a" (operationToSignature op)))
     (setq sigs (split (subseq sigs 0 (1- (length sigs)))))
     ; classify the output by length
     (dolist (sig (nreverse sigs))
       (if (or (>= (length sig) 36) (forceLong sig))
         (push sig longlines)
         (push sig shortlines))))
    ; output the short lines
    (dolist (sig shortlines)
      (if (= column 0)
        (progn (format t " ~a" (padTo38 sig)) (setq column 1))
        (progn (format t "~a~%" sig) (setq column 0))))
   ; output the long lines
   (dolist (sig longlines)
     (format t "~& ~a~%" sig))
   (values))))

\end{chunk}


From Signatures to OperationAlist
\begin{chunk}{defun signatureToOperation}
(defun signatureToOperation (sig)
  (declare (ignore sig))
)
\end{chunk}

\chapter{The Parser}

\noindent
Note that this function is inserted by the primitive support tools
section above.
\begin{chunk}{defun splitchar}
(defun splitchar (string char)
    (loop for i = 0 then (1+ j)
      as j = (position char string :start i :test #'char=)
      collect (subseq string i j)
      while j))

\end{chunk}

\begin{chunk}{defun explode}
(defun explode (string)
  (loop for c across string collect c))

\end{chunk}

\begin{chunk}{defclass ParserClass}
(defclass ParserClass ()
  ((abbrev     :initarg :abbrev     :initform nil :accessor parser-abbrev)
   (topcomment :initarg :topcomment :initform nil :accessor parser-topcomment)
   (macros     :initarg :macros     :initform nil :accessor parser-macros)
   (cdpsig     :initarg :cdpsig     :initform nil :accessor parser-cdpsig)
   (with       :initarg :with       :initform nil :accessor parser-with)
   (add        :initarg :add        :initform nil :accessor parser-add)))

\end{chunk}

\index[code]{print-object!defmethod!ParserClass}
\index[code]{defmethod!print-object!ParserClass}
\index[code]{ParserClass!defmethod!print-object}
\begin{chunk}{defmethod print-object}
(defvar formatabbrev "~a")
(defvar formattopcomment "~a~%")
(defvar formatmacros "~a ==> ~a~%")
(defvar formatcdpsig "~a~%")

(defmethod print-object ((p ParserClass) stream)
  (format stream formatabbrev (parser-abbrev p))
  (format stream formattopcomment (parser-topcomment p))
  (format stream formatcdpsig (parser-cdpsig p)))

;(defmethod print-object ((p ParserClass) stream)
;  (format stream formatabbrev (parser-abbrev p))
;  (format stream formattopcomment (parser-topcomment p))
;  (loop for acons in (parser-macros p) do
;     (format stream formatmacros (car acons) (cdr acons))))

\end{chunk}

\section{The Compiler Function}

Given a {\bf theparse} structure, construct the corresponding
defclass.

\begin{verbatim}
(defclass |BitsType| (|BitAggregateType|)
  ((parents :initform '(|BitAggregate|))
   (name :initform "Bits")
   (marker :initform 'domain)
   (abbreviation :initform 'BITS)
   (comment :initform (list
     "Bits provides logical functions for Indexed Bits."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Bits|
  (progn
    (push '|Bits| *Domains*)
    (make-instance '|BitsType|)))

\end{verbatim}

\begin{chunk}{defun compileSpad}
(defun compileSpad (theparse)
  (let* ((abbrev (parser-abbrev theparse))
        (classname (intern (concatenate 'string (abbreviation-string abbrev) "Type"))))
    (print
     `(progn
        (defclass ,classname ()
          ((name         :initform ,(abbreviation-string abbrev))
           (marker       :initform ,(abbreviation-class abbrev))
           (abbreviation :initform ,(abbreviation-abbrev abbrev))
           (comment      :initform ,(parser-topcomment theparse))))
        (defvar ,(abbreviation-name abbrev)
          (progn
             (push ',(abbreviation-name abbrev) *Domains*)
             (make-instance ',classname)))))
   (values)))

\end{chunk}
\section{The Language}

\begin{verbatim}
FILENAME    ::= PATHNAME
RAWCODE     ::= List(STRING)
PILE        ::= List(STRING)
TREE        ::= Tree(STRING)
SOURCECODE  ::= FILENAME RAWCODE PILE TREE

UCHAR       ::= uppercase character
UABBREV     ::= UCHAR 
              | UCHAR UCHAR 
              | UCHAR UCHAR UCHAR 
              | UCHAR UCHAR UCHAR UCHAR
              | UCHAR UCHAR UCHAR UCHAR UCHAR
              | UCHAR UCHAR UCHAR UCHAR UCHAR UCHAR 
              | UCHAR UCHAR UCHAR UCHAR UCHAR UCHAR UCHAR
              | UCHAR UCHAR UCHAR UCHAR UCHAR UCHAR UCHAR UCHAR
CONSTRUCT   ::= constructorname
ABBREV      ::= ')abbrev' ['category' | 'domain' | 'package'] UABBREV CONSTRUCT

FILE        ::= ABBREV BODY
BODY        ::= CDPSIG MACROS WITH ADD
CDPSIG      ::= CDPNAME ['(' [ CDPARGS ] ')'] '==' 
MACROS      ::= MACNAME '==>' MACBODY
WITH        ::= [PARENTS] with SIGNATURES
ADD         ::= 

COLONTYPE   ::= name : TYPESPEC [',' COLONGTYPE]*
RECORD      ::= 'Record(' COLONTYPE* ')'
UNIONTAG    ::= TYPESPEC | STRING
UNION       ::= 'Union(' UNTIONTAG [',' UNIONTAG]+ ')'

INFIX       ::= + | - * | ** | mod | ^ | / | exquo
PREFIX      ::= + | -
SPECIALNAME ::= "*" | "**" | "^" | "/" | PREFIX | INFIX
SIGNAME     ::= SPECIALNAME | SYMBOL
FSMSIG      ::= INDENT SIGNAME [':' SIGINTYPE '->' SIGOUTTYPE] [SIGIFSEC]
\end{verbatim}

\section{Finite State Machine tools}

The Finite State Machine tools mimic the EBNF in the language
grammar. An example of its use is to recognize the abbreviation
line. The line looks like:
\begin{verbatim}
   )abbrev domain TIM Tim
\end{verbatim}

\noindent
The Finite State Machine code to recognize this and construct an
abbreviation instance would be:
\begin{verbatim}
(defun FSM-abbrev (linelist)
  (let ((split (splitchar (first linelist) #\space)) result)
    (when
      (fsm-and 
        (fsm-match ")abbrev")
        (fsm-or
          (fsm-match "category")
          (fsm-match "domain")
          (fsm-match "package"))
        (fsm-abbname)
        (fsm-word))
      (values
        (rest linelist)
        (make-abbreviation (third result) (second result) (first result))))))

\end{verbatim}

\noindent
Things to note about this code are that the variables {\bf split}
\index[code]{split!variable}
\index[code]{variable!split}
and {\bf result}
\index[code]{result!variable}
\index[code]{variable!result}
are expected to be in the environment of the macros. When this code
successfully recognizes the input line it constructs a class object to
hold the result.

\noindent
The {\bf FSM-OR} 
\index[code]{FSM-OR!defmacro}
\index[code]{defmacro!FSM-OR}
macro mimics the action of the choice vertical bar in
the grammar. It accepts a list of tests and returns if one of the
tests succeeds.
\begin{chunk}{defmacro FSM-OR}
(defmacro FSM-OR (&body FSM-tests)
  `(or ,@FSM-tests))

\end{chunk}

\noindent
The {\bf FSM-AND} 
\index[code]{FSM-AND!defmacro}
\index[code]{defmacro!FSM-AND}
macro mimics the action of a sequence of matches in the grammar. 
It accepts a list of tests and returns if all of the 
tests succeed.
\begin{chunk}{defmacro FSM-AND}
(defmacro FSM-AND (&body FSM-tests)
  `(and ,@FSM-tests))

\end{chunk}

\noindent
The {\bf gather} class holds the result of collecting several
\index[code]{defclass!gather}
\index[code]{gather!defclass}
associated lines.  It is filled by side-effect by {\bf FSM-gather}.
\begin{chunk}{defclass gather}
(defclass gather ()
  ((lines  :initarg :lines :initform nil :accessor gather-lines)))

\end{chunk}

\index[code]{print-object!defmethod!gather}
\index[code]{defmethod!print-object!gather}
\index[code]{gather!defmethod!print-object}
\begin{chunk}{defmethod print-object}
(defvar formatgather "~{~a~%~^~}")

(defmethod print-object ((g gather) stream) 
  (format stream formatgather (gather-lines g)))

\end{chunk}

\noindent
The {\bf FSM-gather} macro rips lines that pass the test
\index[code]{defmacro!FSM-gather}
\index[code]{FSM-gather!defmacro}
from the list of input strings.It expects 3 arguments
\begin{enumerate}
\item {\bf linelist} is a list of input strings from the raw
field of the sourcecode class object.
\item {\bf test} is a test to decide whether this line should
be gathered from the linelist. 
\item {\bf into} is an instance of the {\bf gather} class 
that will hold the lines that pass the test.
\end{enumerate}
Given a linelist that looks like:
\begin{verbatim}
  ("++ Author: Stephen M. Watt"
    "++ Description:"
    "++ \\spadtype{Bits} provides logical functions for Indexed Bits."
    "Bits() : SIG == CODE where"
    "  SIG ==> BitAggregate() with"
    "    bits : (NonNegativeInteger, Boolean) -> %"
    "      ++ bits(n,b) creates bits with n values of b"
    "  CODE ==> IndexedBits(1) add"
    "    bits(n,b)    == new(n,b)")
\end{verbatim}
and the call to gather comments, lines starting the "$++$":
\begin{verbatim}
(defun FSM-comment (linelist)
  (let (comment result)
    (setq comment (make-instance 'gather))
    (values
      (FSM-gather linelist (FSM-match "++") comment)
      comment)))
\end{verbatim}
when invoked with:
\begin{verbatim}
   (multiple-value-setq (t3 t4) (fsm-comment t2))
\end{verbatim}
we end up with t4 as a {\bf gather} instance containing the
lines that passed the {\bf FSM-match} test. For example,
\begin{verbatim}
The object is a STANDARD-OBJECT of type GATHER.
0. LINES:
 ("++ Author: Stephen M. Watt"
  "++ Description:"
  "++ \\spadtype{Bits} provides logical functions for Indexed Bits.")
\end{verbatim}
The t3 variable contains the new linelist without the matching lines:
\begin{verbatim}
   ("Bits() : SIG == CODE where"
    "  SIG ==> BitAggregate() with"
    "    bits : (NonNegativeInteger, Boolean) -> %"
    "      ++ bits(n,b) creates bits with n values of b"
    "  CODE ==> IndexedBits(1) add"
    "    bits(n,b)    == new(n,b)")
\end{verbatim}
\begin{chunk}{defmacro FSM-gather}
(defmacro FSM-gather (linelist test into)
  `(let ((split (splitchar (first ,linelist) #\space)))
     (loop while (and linelist ,test) do
       (setf (gather-lines ,into)
         (append (gather-lines ,into) (list (pop ,linelist)))) 
       (setq split (splitchar (first ,linelist) #\space)))
     ,linelist))

\end{chunk}

\noindent
NOTE: {\bf These macros assume two variables in the environment.}
\index[code]{split!variable}
\index[code]{variable!split}
\index[code]{result!variable}
\index[code]{variable!result}
\begin{enumerate}
\item {\bf split} that is a tokenized list of the input,
usually by calling the {\bf splitchar} function. Each element of the
list is a string.
\item {\bf result} is a variable used to collect matches in a list.
\end{enumerate}

\noindent
The {\bf FSM-startsWith}
\index[code]{defmacro!FSM-startsWith}
\index[code]{FSM-startsWith!defmacro}
occurs in cases where we want to check whether the prefix is a
word we expect, such as looking for the category name, for example,
\begin{verbatim}
   Bits() : Category
   FSM-match "Bits"   
\end{verbatim}
\begin{chunk}{defmacro FSM-startsWith}
(defmacro FSM-startsWith (word)
  `(let ((term (explode (first split))))
     (setq result t)
     (loop for c across ,word do
       (when (and result (char/= c (pop term)))
         (setq result nil)))
     (when result ,word)))

\end{chunk}

\noindent
The {\bf FSM-match}
\index[code]{FSM-match!defmacro}
\index[code]{defmacro!FSM-match}
matches a string with any case and, when successful, it adds the
matched word to the result and pops it off the split.
\begin{chunk}{defmacro FSM-match}
(defmacro FSM-match (word)
  `(when (string-equal (first split) ,word)
     (push (first split) result)
     (pop split)))

\end{chunk}

\noindent
The {\bf FSM-dword}
\index[code]{FSM-dword!defmacro}
\index[code]{defmacro!FSM-dword}
matches the lowercased word, then match. When successful, it adds the
matched word to the result and pops it off the split.
\begin{chunk}{defmacro FSM-dword}
(defmacro FSM-dword (word)
  `(when (string= (string-downcase ,word) (first split))
     (push (first split) result)
     (pop split)))

\end{chunk}

\noindent
The {\bf FSM-uword}
\index[code]{FSM-uword!defmacro}
\index[code]{defmacro!FSM-uword}
matches the uppercased word, then match. When successful, it adds the
matched word to the result and pops it off the split. 
\begin{chunk}{defmacro FSM-uword}
(defmacro FSM-uword (word)
  `(when (string= (string-upcase ,word) (first split))
     (push (first split) result)
     (pop split)))

\end{chunk}

\noindent
The {\bf FSM-word}
\index[code]{FSM-word!defmacro}
\index[code]{defmacro!FSM-word}
simply return the next word. It always succeeds. It adds the word to
the result and pops it off the split.
\begin{chunk}{defmacro FSM-word}
(defmacro FSM-word ()
  '(progn
     (push (first split) result)
     (pop split)))

\end{chunk}

\noindent
The {\bf FSM-cdpname}
\index[code]{FSM-cdpname!defmacro}
\index[code]{defmacro!FSM-cdpname}
checks to see if the next word in the split is a known class. 
For example,
\begin{verbatim}
  (FSM-cdpname *categories*)
\end{verbatim}
will check if the string at the top of the split is in the known list
of category names. (Note that it interns the string first). 
It adds the word to the result and pops it off the split.
\begin{chunk}{defmacro FSM-cdpname}
(defmacro FSM-cdpname (cdplist)
  `(when (member (intern (first split)) ,cdplist)
     (push (first split) result)
     (pop split)))

\end{chunk}

\noindent
Abbreviations of categories, domains, and packages must be 8 or less
characters and all uppercase.

\noindent
The {\bf FSM-abbname}
\index[code]{FSM-abbname!defmacro}
\index[code]{defmacro!FSM-abbname}
performs this check. When successful,
it adds the word to the result and pops it off the split.
\begin{chunk}{defmacro FSM-abbname}
(defmacro FSM-abbname ()
  `(let ((word (first split)))
     (when (and (<= (length word) 8)
                (loop with result 
                      for c across word 
                      while (setq result (or (digit-char-p c) (upper-case-p c)))
                      finally (return result)))
       (push (first split) result)
       (pop split))))

\end{chunk}

This function is called when an open-paren is detected as the next
character in the first line of the linelist. It will walk across the
linelist gathering all of the text between the open-paren and the
balancing closed-paren, even if there are newlines or other parens.
It works character by character. The {\bf result} variable is the
parenthesized object, including the delimiting parens. 
The {\bf depth} variable is used to handle embedded parens. Only a
closed paren at depth 0 is considered a match. The {\bf more} variable
causes the loop to exit when it becomes false. The {\bf instring}
variable is used to ignore parens embedded in strings. The {\bf str}
variable is the current string we are walking. The complication is
that there could be newlines between balancing parens so we have to
move to the next string in the linelist. The {\bf c} character is the
current character we are considering. There are several cases with
associated comments. The {\bf listlen} variable is a counter which
counts how much of the string we need to remove before returning. The
complication is that when we have multiple lines we have to also
consider the leading spaces in indents.

\begin{chunk}{defun FSM-gatherList}
(defun FSM-gatherList (linelist)
  (let (result (depth 0) (more t) instring str c (listlen 0))
     (setq str (explode (first linelist)))
     (loop while more do
       (setq c (pop str))
       (cond
         ; hit a newline?
         ((null c)
           (pop linelist)
           (setq listlen (indent (first linelist)))
           (setq str (explode (trim (first linelist))))
           (push #\space str))
         ; end of string?
         ((and instring (char= c #\"))
           (setq instring nil)
           (incf listlen)
           (push c result))
         ; still in string?
         (instring
           (incf listlen)
           (push c result))
         ; start string?
         ((and (not instring) (char= c #\"))
           (setq instring t)
           (incf listlen)
           (push c result))
         ; start list?
         ((char= c #\()
           (incf depth)
           (incf listlen)
           (push #\( result))
         ; exit nested list?
         ((and (> depth 0) (char= c #\)))
           (decf depth)
           (when (= depth 0) (setq more nil))
           (incf listlen)
           (push #\) result))
         ; end list?
         ((and (= depth 0) (char= c #\)))
           (incf listlen)
           (push #\) result)
           (setq more nil))
         (t
           (incf listlen)
           (push c result))))
    (setq result (coerce (nreverse result) 'string))
    (setf (first linelist) (subseq (first linelist) listlen))
    (values linelist result)
))

\end{chunk}

This function expects a list of arguments to a function. It breaks up
the list based on the top-level commas, ignoring commas in strings and
in embedded arguments that are not top-level. It returns a list of 
strings, one per top level argument.

\begin{chunk}{defun FSM-gatherVars}
;  ARGLIST -> LIST(ARGS)
(defun FSM-gatherVars (argslist)
  (let (result (depth 0) (more t) instring str c vars)
     (setq str (explode (trim (first argslist))))
     (pop str)
     (loop while more do
       (setq c (pop str))
       (cond
         ; hit a newline?
         ((null c)
           (pop argslist)
           (if argslist
             (progn
               (setq str (explode (trim (first argslist))))
               (push #\space str))
             (progn
               (push (trim (coerce (nreverse result) 'string)) vars)
               (setq more nil))))
         ; found a top-level comma?
         ((and (= depth 0) (not instring) (char= c #\,)) 
           (push (trim (coerce (nreverse result) 'string)) vars)
           (setq result nil))
         ; end of string?
         ((and instring (char= c #\"))
           (setq instring nil)
           (push c result))
         ; still in string?
         (instring
           (push c result))
         ; start string?
         ((and (not instring) (char= c #\"))
           (setq instring t)
           (push c result))
         ; start list?
         ((char= c #\()
           (incf depth)
           (push #\( result))
         ; exit nested list?
         ((and (> depth 0) (char= c #\)))
           (decf depth)
           (push #\) result))
         ; end list?
         ((and (= depth 0) (not instring) (char= c #\)))
           (push (trim (coerce (nreverse result) 'string)) vars)
           (setq more nil))
         (t
           (push c result))))
    (nreverse vars)
))

\end{chunk}

\section{Reading the source file}

The {\bf sourcecode} type contains 4 fields:
%\index[code]{sourcecode}
\begin{enumerate}
\item name -- the filename of the source file
\item rawcode -- the exact source text in the file
\item pile -- remove $--$ comments, continued lines
\item tree -- piled strings to a nested tree
\end{enumerate}

\index[code]{defclass!sourcecode}
\index[code]{sourcecode!defclass}
\label{lst:sourcecode}
\begin{chunk}{defclass sourcecode}
(defclass sourcecode ()
  ((name    :initarg :name    :initform nil :accessor sourcecode-name)
   (rawcode :initarg :rawcode :initform nil :accessor sourcecode-rawcode)
   (pile    :initarg :pile    :initform nil :accessor sourcecode-pile)
   (tree    :initarg :tree    :initform nil :accessor sourcecode-tree)))

\end{chunk}

\index[code]{print-object!defmethod!sourcecode}
\index[code]{defmethod!print-object!sourcecode}
\index[code]{sourcecode!defmethod!print-object}
\begin{chunk}{defmethod print-object}
;(defmethod print-object ((source sourcecode) stream)
;  (pretty (sourcecode-tree source)))

\end{chunk}

Spad is indentation sensitive so the rawcode semantics depends
on the indentation.

\section{Sourcecode Tree Utilities}

We process the original source code into a ``clean form'' that
has no $--$ comments, no blank lines, and no line continuations.
We call this the ``{bf pile}'' form of the code. This is just
a list of strings.

Next we convert the pile form into tree form using the indentation.
Elements at the same level of identation are grouped togehter.

The {\bf indent}
\index[doc]{indent}
function tells us how many spaces, aka the indentation, we have
at the beginning of the line.
\begin{verbatim}
   STRING -> DEPTH
\end{verbatim}
\index[code]{defun!indent}
\index[code]{indent!defun}
\begin{chunk}{defun indent}
(defun indent (line)
  (let ((result 0))
    (loop for char across line do 
      (if (char= char #\space)
        (incf result)
        (return)))
    result))

\end{chunk}

Just for mnemonic purposes we create constructors and 
accessor functions. All we are really doing is creating
pairs, the car of which is the indentation and the cdr
is anything.

The {\bf birth} function 
\index[doc]{birth}
expects the indentation count and anything, and just conses
them together.
\begin{verbatim}
   DEPTH, ANY -> BIRTHFORM
\end{verbatim}
\begin{chunk}{defmacro birth}
(defmacro birth (depth name) `(cons ,depth ,name))

\end{chunk}

Naturally, if we have a cons, we need to disassemble it.
The {\bf depthof} function returns the indentation.
\index[doc]{depthof}
\begin{verbatim}
   BIRTHFORM -> DEPTH
\end{verbatim}
\begin{chunk}{defmacro depthof}
(defmacro depthof (node) `(car ,node))

\end{chunk}

And the {\bf nameof}
\index[doc]{nameof}
returns the thing we put in the cdr.
\begin{verbatim}
   BIRTHFORM -> ANY
\end{verbatim}
\begin{chunk}{defmacro nameof}
(defmacro nameof (node) `(cdr ,node))

\end{chunk}

Given a list of strings, each of which has a variable
number of leading blanks, we construct pairs where the
car is the indentation and the cdr is anything, usually
the source string. We call this rewrite the {\bf spawn}
\index[doc]{spawn}
of the tree. From this information we can compute things
like the depth of nesting.
\begin{verbatim}
   PILEFORM -> SPAWNFORM
\end{verbatim}
\begin{chunk}{defun spawn}
(defun spawn (tree)
  (loop for node in tree
    collect (birth (indent node) node)))

\end{chunk}

The {\bf pile2tree} 
\index[code]{pile2tree}
function takes a {\bf sourcecode pile} which looks like:
\begin{verbatim}
(")abbrev domain BITS Bits"
 "++ Author: Stephen M. Watt" "++ Description:"
 "++ \\spadtype{Bits} provides logical functions for Indexed Bits."
 "Bits() : SIG == CODE where"
 "  SIG ==> BitAggregate() with"
 "    bits : (NonNegativeInteger, Boolean) -> %"
 "      ++ bits(n,b) creates bits with n values of b"
 "  CODE ==> IndexedBits(1) add"
 "    bits(n,b)    == new(n,b)")

\end{verbatim}

and inserts parentheses that group the code into a tree form,
called a {\bf sourcecode tree} looks like:
\begin{verbatim}
(")abbrev domain BITS Bits"
 "++ Author: Stephen M. Watt" "++ Description:"
 "++ \\spadtype{Bits} provides logical functions for Indexed Bits."
 "Bits() : SIG == CODE where"
 "  (SIG ==> BitAggregate() with"
 "    (bits : (NonNegativeInteger, Boolean) -> %"
 "      (++ bits(n,b) creates bits with n values of b"
 "      )))"
 "  (CODE ==> IndexedBits(1) add"
 "    (bits(n,b)    == new(n,b)"
 "    ))")

\end{verbatim}

The {\bf deep}
\index[doc]{deep}
function will walk a spawn-ed tree and return a reverse
sorted list of the indentations. We use this to walk the
spawn tree ``inside-out'', handling the most deeply nested
nodes first.

\begin{chunk}{defun pile2tree}
;  PILEFORM -> TREEFORM
(defun pile2tree (pile)
  (labels (
    ; INTEGER -> STRING of PARENS
    (closeparens (count)
      (let (result)
        (coerce (dotimes (i count result) (push #\) result)) 'string)))
    ; INTEGER -> STRING of SPACES
    (spaces (count)
      (let (result)
        (coerce (dotimes (i (* 2 count) result) (push #\space result))
	'string)))
    ; SPAWNFORM -> LIST DEPTH
    (deep (tree)
      (let (result)
        (loop for node in tree do
          (setq result (adjoin (depthof node) result)))
        (sort result #'>)))
    ; PILE -> PILE
    (redepth (pile)
     (let (deeplist thepile)
      (setq thepile (spawn pile))
      (setq deeplist (nreverse (deep thepile)))
      (loop for line in thepile do
        (setf (car line) (position (car line) deeplist)))
      thepile))
    ; PILE -> LIST STRING
    (extract (code)
      (loop for line in code 
        collect (cdr line)))
  )
  (let ((was 0) lastline closers)
    (let (stack)
      (loop for line in (redepth pile) do
        (setf (cdr line) (trim (cdr line)))
        (cond
          ((= (depthof line) was)
            (setf (cdr line) (concatenate 'string (spaces (car line)) " " (cdr line)))
            (push line stack))
          ((> (depthof line) was)
            (setf (cdr line) (concatenate 'string (spaces (car line)) "(" (cdr line)))
            (push line stack))
          ((< (depthof line) was)
            (setq closers (closeparens (car lastline)))
            (push (cons (car lastline) (concatenate 'string (spaces (car lastline)) closers)) stack)
            (setf (cdr line) (concatenate 'string (spaces (car line)) "(" (cdr line)))
            (push line stack))
          )
        (setq was (car line))
        (setq lastline line))
    (setq closers (closeparens (car lastline)))
    (push (cons (car lastline) (concatenate 'string (spaces (car lastline)) closers)) stack)
    (extract (nreverse stack))))))

\end{chunk}

The {\bf pretty} 
\index[doc]{pretty}
function takes a sourcecode-tree, or a sublist thereof, 
and prints it in a form we prefer.
\begin{verbatim}
   TREEFORM -> VOID
\end{verbatim}
\begin{chunk}{defun pretty}
(defun pretty (tree)
  (cond
    ((stringp tree) (format t "~a~%" tree))
    ((consp tree)   (mapcar #'(lambda (tree) (pretty tree)) tree)))
  (values))

\end{chunk}

The {bf make-Sourcecode} function constructs a {\bf sourcecode}
instance containing the original source, the source stripped
of $--$ comments, joining contiued lines, and finally 
converted from pile form to tree form. The signature is
\begin{verbatim}
    FILENAME -> SOURCECODE
\end{verbatim}

The {\bf make-Sourcecode} function
\index[doc]{make-Sourcecode}
reads a spad file in as a list of strings. All minus comments
are deleted, using {\bf noComments}, from the initial $--$ to 
the end of the line.

The result is a {\bf sourcecode} instance contains the raw
contents of the file, the cleaned up version called a pile,
and a tree version, containing parens indicating depth.

Then, using {\bf oneline}, any line that has a trailing escape 
character (the underscore) gets merged with the following line.

The {\bf escaped?} predicate checks for the trailing underscore.
The {\bf oneline} process, when it finds a trailing underscore,
will join the lines(s) until a non-escaped line occurs.

The {\bf blankline?} predicate checks for a blank line. 
These are elimiated as part of the {\bf oneline} process.

A bit of clever optimization is possible if the {\bf oneline}
function processed the list of strings in reverse so the two
calls to nreverse could be removed. 

\label{lst:make-Sourcecode}
\begin{chunk}{defun make-Sourcecode}

(defvar formatMakeSourcecode "make-Sourcecode: ERROR: File ~a does not exist")

; FILENAME -> SOURCECODE
(defun make-Sourcecode (filename)
  (labels (
    ; LINE -> BOOLEAN
    (blankline? (line)
      (string= "" (trim line)))
    ; LINE -> LINE
    (noComments (line)
      (subseq line 0 (search "--" line)))
    ; LINE -> BOOLEAN
    (escaped? (line)
      (let ((len (length line)))
        (and (> len 0) (char= #\_ (char line (1- len))))))
    ; LINELIST -> LINELIST
    (oneline (linelist)
      (let (gather result)
        (dolist (line linelist)
          (let ((underscored? (escaped? line)))
            (cond
              ; skip blank lines
              ((blankline? line))
              ; first time
              ((and (not gather) underscored?)
                (setq gather (string-right-trim '(#\_) line)))
              ; still more
              ((and gather underscored?)
                (setq gather 
                  (concatenate 'string gather " " (string-trim '(#\space #\_) line))))
              ; last one
              ((and gather (not underscored?))
                (push
                  (concatenate 'string gather " " (string-trim '(#\space #\_) line))
                 result)
                (setq gather nil))
              (t 
                (push line result)))))
      result))  )
  (let (rawcode listLine pile)
    (with-open-file (file filename :direction :input :if-does-not-exist nil)
      (if file
        (let ((done (gensym)))
          (do ((line (read-line file nil done) (read-line file nil done)))
              ((eq line done) (setq pile (nreverse (oneline (nreverse listLine)))))
              (push line rawcode)
              (push (noComments line) listLine))
        (make-instance 'sourcecode :name filename 
                                   :rawcode (nreverse rawcode)
                                   :pile pile
                                   :tree (pile2tree pile)))
     (error formatMakeSourcecode filename))))))

\end{chunk}

Spad code is indentation sensitive. This is called 'pile format'. We 
unpile the spad file, recording the indentation.

\begin{verbatim}
FILE        ::= ABBREV BODY
BODY        ::= CDPSIG MACROS WITH ADD
CDPSIG      ::= CDPNAME ['(' [ CDPARGS ] ')'] '==' 
MACROS      ::= MACNAME '==>' MACBODY
WITH        ::= [PARENTS] with SIGNATURES
ADD         ::= 

COLONTYPE   ::= name : TYPESPEC [',' COLONGTYPE]*
RECORD      ::= 'Record(' COLONTYPE* ')'
UNIONTAG    ::= TYPESPEC | STRING
UNION       ::= 'Union(' UNTIONTAG [',' UNIONTAG]+ ')'

INFIX       ::= + | - * | ** | mod | ^ | / | exquo
PREFIX      ::= + | -
SPECIALNAME ::= "*" | "**" | "^" | "/" | PREFIX | INFIX
SIGNAME     ::= SPECIALNAME | SYMBOL

FSMSIG      ::= INDENT SIGNAME [':' SIGINTYPE '->' SIGOUTTYPE] [SIGIFSEC]
\end{verbatim}

\begin{figure}[ht]
\centering
\begin{tikzpicture}

\node[state, initial]                 (q01) {$s_1$};
\node[state, accepting, right of=q01] (q02) {$s_2$};

\node[state, below of=q01, initial]   (q03) {$s_1$};
\node[state, right of=q03]            (q04) {$s_2$};
\node[state, right of=q04]            (q05) {$s_3$};
\node[state, accepting, right of=q05] (q06) {$s_4$};

\node[state, below of=q03, initial]   (q07) {$s_1$};
\node[state, right of=q07]            (q08) {$s_2$};
\node[state, right of=q08]            (q09) {$s_3$};
\node[state, right of=q09]            (q10) {$s_4$};
\node[state, accepting, right of=q10] (q11) {$s_5$};

\draw

(q01) edge[above] node{intype}   (q02)

(q03) edge[above] node{intype}   (q04)
(q04) edge[above] node{{\tt ->}} (q05)
(q05) edge[above] node{outtype}  (q06)

(q07) edge[above] node{intype}   (q08)
(q08) edge[above] node{{\tt ->}} (q09)
(q09) edge[above] node{outtype}  (q10)
(q10) edge[above] node{ifspec}   (q11);

\end{tikzpicture}
\caption{FUNSIG Anonymous function signature}
\label{FSMSIG}
\end{figure}
\begin{verbatim}
  FUNCTIONSPEC ::= INTTYPE
                 | INTYPE -> OUTPUT
                 | INTYPE -> OUTPUT IFSPEC
\end{verbatim}

\begin{figure}[ht]
\centering
\begin{tikzpicture}

\node[state, initial] (q1) {$s_1$};
\node[state, right of=q1] (q2) {$s_2$};
\node[state, accepting, right of=q2] (q3) {$s_3$};
\node[state, below of=q2] (q4) {$s_4$};
\node[state, accepting, right of=q4] (q5) {$s_5$};

\draw
(q1) edge[loop above] node{indent} (q1)
(q1) edge[above] node{name} (q2)
(q2) edge[above] node{eol} (q3)
(q2) edge[left] node{:} (q4)
(q4) edge[above] node{funsig} (q5);

\end{tikzpicture}
\caption{SIGNATURE}
\label{FSMSIG}
\end{figure}
\begin{verbatim}
  SIGNATURE ::= NAME EOF
              | NAME : FUNCTIONSPEC
\end{verbatim}

The Finite State Machine (FSM) walks across a spad signature
character by character. It constructs the syntactic pieces.

The inner loop drives forward character by character, calling
the {\bf classify} function to determine the next state. The
inner loop is a large case statement handling each classified
state. The inner loop is {\bf :accept} at the end of the file.

Both {\bf inttype}, the input type specification 
and {\bf outtype}, the output type specification may both be very
complex type specifications. They are recognized by a separate
finite state machine.

A signature may also have a conditional specification that
is handled by its own finite state machine.

The {\bf look} function just peeks at the next character.
The {\bf eat} function consumes it.

The {\bf next} function updates the {\bf nextstate} variable.

The {\bf here} function outputs debugging information.

\begin{chunk}{defun FSMSIG}
(defun FSMSIG (&optional (debug nil))
  (let (nextstate prev char (eofsym (gensym))
        (indenting? t) (indent 0) 
        inword? word words)
    (labels (
      (classify (char)
        (unless (eq char #\space) (setq indenting? nil))
        (cond
         ((eq char eofsym)    (next :accept))
         ((eq char #\space)   (next :space))
         ((eq char #\:)       (next :colon))
         ((eq char #\$)       (next :dollar))
         ((eq char #\-)       (next :dash))
         ((eq char #\>)       (if (char= #\- prev) (next :arrow) (next :greater)))
         ((lower-case-p char) (next :lowercase))
         ((upper-case-p char) (next :uppercase))
      ))
      (look (in)
        (setq prev char)
        (setq char (peek-char nil in nil eofsym)))
      (eat (in)
        (setq prev char)
        (setq char (read-char in nil eofsym)))
      (next (newstate)
        (setq nextstate newstate))
      (endword () (print 'endword)
        (push (coerce (nreverse word) 'string) words)
        (setq inword? nil)
        (setq word nil))
      (here (&optional (keyword nil))
        (when debug 
          (if keyword
            (format t "~&~a ~a" char keyword)
            (format t "~&~a ~a" char nextstate))))
    )
  (let ()
    (with-open-file (spad "spad" :direction :input)
      (loop until (eq nextstate :accept) do
        (look spad)
        (case (classify char)
          (:space (here)
            (when indenting? (incf indent))
            (when inword? (endword))
            (eat spad))
         (:lowercase (here)
           (setq inword? t)
           (push char word)
           (eat spad))
         (:uppercase (here)
           (setq inword? t)
           (push char word)
           (eat spad))
         (:colon (here)
           (when inword? (endword))
           (eat spad))
         (:dollar (here)
           (push char word)
           (eat spad))
         (:dash (here)
           (push char word)
           (eat spad))
         (:arrow (here)
           (setq prev (pop word))
           (endword)
           (push prev word)
           (push char word)
           (endword)
           (eat spad))
         (:accept (here :accept)
           (endword))
         (t (here :fail) 
            (endword)
            (next :accept))
       )))
    (print (list 'indent indent
                 'words (nreverse words)))
    (values)
  ))))

\end{chunk}
            
\subsection{Recognize abbreviation command line}

An {\bf )abbrev} line consists of 4 tokens, for example,
\begin{verbatim}
   )abbrev domain BITS Bits
\end{verbatim}
where the domain is one of "category", "domain", or "package",
which can be of any case. The BITS field must be less than 8
characters and all uppercase, and the Bits field must be a
valid constructor name.

The {\bf abbreviation}
\index[code]{abbreviation!defclass}
\index[code]{defclass!abbreviation}
holds the result of parsing an )abbrev line.

The {\bf FSM-abbrev} 
\index[code]{FSM-abbrev!function}
\index[code]{function!FSM-abbrev}
function parses an )abbrev line.

\begin{chunk}{defclass abbreviation}
(defclass abbreviation ()
  ((class  :initarg :class  :initform nil :accessor abbreviation-class)
   (abbrev :initarg :abbrev :initform nil :accessor abbreviation-abbrev)
   (string :initarg :string :initform ""  :accessor abbreviation-string)
   (name   :initarg :name   :initform nil :accessor abbreviation-name)))

(defun make-abbreviation (class abbrev string)
  (make-instance 'abbreviation :class class :abbrev abbrev :string string
                               :name (intern string)))

\end{chunk}

\index[code]{print-object!defmethod!abbreviation}
\index[code]{defmethod!print-object!abbreviation}
\index[code]{abbreviation!defmethod!print-object}
\begin{chunk}{defmethod print-object}
(defvar formatAbbreviation ")abbrev ~a ~a ~a~%")

(defmethod print-object ((abb abbreviation) stream)
  (format stream formatAbbreviation
    (abbreviation-class abb) 
    (abbreviation-abbrev abb)
    (abbreviation-string abb)))

\end{chunk}

\begin{chunk}{defun FSM-abbrev}
(defun FSM-abbrev (linelist)
  (let ((split (splitchar (first linelist) #\space)) result)
    (when
      (fsm-and 
        (fsm-match ")abbrev")
        (fsm-or
          (fsm-match "category")
          (fsm-match "domain")
          (fsm-match "package"))
        (fsm-abbname)
        (fsm-word))
      (values
        (rest linelist)
        (make-abbreviation (third result) (second result) (first result))))))

\end{chunk}

\begin{chunk}{defun FSM-cdpsig}
(defun FSM-cdpsig (linelist theparse)
  (let ((split (splitchar (first linelist) #\space)) result cdpname argslist)
    (when (FSM-startsWith (first split))
      (setq result (make-instance 'CDPSigClass))
      (setf (CDPSigClass-cdptag result) (abbreviation-class (parser-abbrev theparse)))
      (setq cdpname (abbreviation-string (parser-abbrev theparse)))
      (setf (CDPSigClass-cdpname result) cdpname)
      (setq linelist (cons (subseq (pop linelist) (length cdpname)) linelist))
      (multiple-value-setq (linelist argslist) (FSM-gatherList linelist))
      (setf (CDPSigClass-argslist result) argslist)
      (values linelist result))))

\end{chunk}

\subsection{Parse Comments}

The {\bf FSM-comment} function strips off the comments from linelist,
gathering them together. It returns 2 values, the first is a new
linelist without the comments. The second is a gather object
containing the comment lines.
\begin{chunk}{defun FSM-comment}
(defun FSM-comment (linelist)
  (let (comment result)
    (setq comment (make-instance 'gather))
    (values
      (FSM-gather linelist (FSM-startsWith "++") comment)
      comment)))

\end{chunk}

\subsection{Gather Macros}

\begin{chunk}{defun FSM-extract1Macro}
(defun FSM-extract1Macro (linelist)
  (let (pre middle indent)
    (setq pre
      (loop while (not (search "==>" (first linelist)))
            collect (pop linelist)))
    (setq middle (make-instance 'gather))
    (when (search "==>" (first linelist))
      (setq indent (indent (first linelist)))
      (setf (gather-lines middle) (list (pop linelist)))
      (FSM-gather linelist (> (indent (first linelist)) indent) middle))
    (values
      (append pre linelist)
      middle)))

\end{chunk}

\begin{chunk}{defun FSM-macros}
(defun FSM-macros (linelist)
  (labels (
    (hasMacros? (linelist)
     (loop for line in linelist
       when (search "==>" line) return t))
    (join (stringlist)
      (format nil "~{~a~^ ~}" stringlist))
    (makeAlist (gather)
      (let (alllines line name def)
       (setq alllines (gather-lines gather))
       (setq line (splitchar (trim (pop alllines)) #\space))
       (setq name (intern (first line)))
       (setq def (cons (join (cddr line)) alllines))
       (cons name def)))
  )
  (let (macro environ)
    (loop while (hasMacros? linelist) do
      (multiple-value-setq (linelist macro) (FSM-extract1Macro linelist))
      (push (makeAlist macro) environ)) 
    (values linelist environ))))

\end{chunk}

\begin{chunk}{defun FSM-macroNames}
(defun FSM-macroNames (theparse)
  (mapcar #'(lambda (x) (car x)) (parser-macros theparse)))

\end{chunk}

\begin{chunk}{defclass CDPSigClass}
(defclass CDPSigClass ()
  ((cdpname  :initarg :classname :initform nil :accessor CDPSigClass-cdpname)
   (argslist :initarg :argslist  :initform nil :accessor CDPSigClass-argslist)
   (cdptag   :initarg :cdptag    :initform nil :accessor CDPSigClass-cdptag)))

\end{chunk}

\index[code]{print-object!defmethod!CDPSigClass}
\index[code]{defmethod!print-object!CDPSigClass}
\index[code]{CDPSigClass!defmethod!print-object}
\begin{chunk}{defmethod print-object}
(defvar formatcat "~a~a : Category == ~%")
(defvar formatdp "~a~a : ~%")

(defmethod print-object ((cdp CDPSigClass) stream)
  (if (string-equal "category" (CDPSigClass-cdptag cdp))
    (format stream formatcat (CDPSigClass-cdpname cdp) (CDPSigClass-argslist cdp))
    (format stream formatdp  (CDPSigClass-cdpname cdp) (CDPSigClass-argslist cdp))))

\end{chunk}

\subsection{parseSignature}
\index[code]{parseSignature!parser}
\index[code]{parser!parseSignature}
\begin{chunk}{defun parseSignature}
(defun parseSignature (lines)
  (let (funcname return argslist comment colon arrow line control plusplus)
    (labels (
      (substring (line start &optional end)
        (trim (subseq line start end)))
      (nospad (line)
        (let (pos)
          (cond
            ((setq pos (search "spad{" line))
              (concatenate 'string 
                (subseq line 0 pos)
                (subseq line (+ 5 pos) (setq pos (search "}" line :start2 pos)))
                (subseq line (1+ pos))))
            ((setq pos (search "spadtype{" line))
              (concatenate 'string 
                (subseq line 0 pos)
                (subseq line (+ 9 pos) (setq pos (search "}" line :start2 pos)))
                (subseq line (1+ pos))))
           (t line))))
      (mangle (str)
        (cond
          ((string= str "()") str)
          ((string= str "%") str)
          (t (intern str))))
    )
    ; the first line is the signature
    (setq line     (first lines))
    ; find the delimiters if they exist
    (setq colon    (search ":" line))
    (setq arrow    (search "->" line))
    ; parse out the pieces
    (setq funcname (intern (substring line 0 colon)))
    (setq argslist  (mangle (substring line (1+ colon) arrow)))
    (setq return   (mangle (substring line (+ 2 arrow))))
    ; collect the comment lines
    (dolist (line (cdr lines))
      (setq plusplus (search "++" line))
      (push (nospad (substring line (+ 2 plusplus))) comment))
    ; construct a format control string
    (setq control "(make-signature '|~a|"))
    (cond
       ((string= return "()")
         (setq control (concatenate 'string control " '~a ")))
       ((string= return "%")
         (setq control (concatenate 'string control " '(~a) ")))
       (t
         (setq control (concatenate 'string control " '(|~a|)"))))
    (cond
       ((string= argslist "()")
         (setq control (concatenate 'string control " '~a ")))
       ((string= argslist "%")
         (setq control (concatenate 'string control " '(~a) ")))
       (t
         (setq control (concatenate 'string control " '(|~a|)"))))
    (setq control (concatenate 'string control " '~s)~%"))
    (format t control funcname return argslist (nreverse comment))
    (values)))

\end{chunk}

\section{The Parse Function}

\index[code]{defvar!*place*}
\index[code]{*place*!defvar}
\begin{chunk}{defvar place}
(defvar *place* "/research/20191011/src/algebra/")
; "/research/fricas/waldek/fricasNew/src/algebra/"

\end{chunk}

\index[code]{defvar!theparse}
\index[code]{theparse!defvar}
\begin{chunk}{defvar theparse}
(defvar theparse nil)

\end{chunk}


\begin{chunk}{defun FSM-isCategory?}
(defun FSM-isCategory? (linelist theparse)
  (let ((split (splitchar (first linelist) #\space)) result tmp)
     (FSM-match ":")
     (setq tmp (abbreviation-class (parser-abbrev theparse)))
     (if (and (string-equal tmp "category") (FSM-match tmp))
       (values split t)
       (values split nil))))

\end{chunk}

\begin{chunk}{defun FSM-catBody}
(defun FSM-catBody (linelist theparse) 
  (let ((split (splitchar (first linelist) #\space)) result)
    (FSM-match "==")
    split))

\end{chunk}

\begin{chunk}{defun FSM-dpBody}
(defun FSM-dpBody (linelist theparser) 
  (declare (ignore linelist theparser)))

\end{chunk}

The parser operates on the input stream step by step.

The {\bf make-Sourcecode} [p\pageref{lst:make-Sourcecode}]
\index[doc]{make-sourcecode!caller}
\index[all]{caller!make-sourcecode}
reads the file and constructs a 
{\bf sourcecode} [p\pageref{lst:sourcecode}] object.

The {bf make-Sourcecode} function constructs a {\bf sourcecode-pile}
field containing a ``useful'' version of the original source,
(e.g. the source stripped of $--$ comments and joining contiued lines)
so we can easily parse the result.

\begin{chunk}{defun Parse}
(defvar t1 nil "a copy of the source code for debugging")

(defvar formatParse1 "Parse 1: ~%    In ~a~%    Missing )abbrev line~%")

(defun Parse (filename)
  (unwind-protect 
    (let (pile object alist iscat?)
      (setq t1 (make-Sourcecode (concatenate 'string *place* filename ".spad")))
      (setq pile (sourcecode-pile t1))
      (setq theparse (make-instance 'ParserClass))
      (multiple-value-setq (pile object) (FSM-abbrev pile)) 
      (unless object
        (error formatParse1 (concatenate 'string *place* filename ".spad")))
      (setf (parser-abbrev theparse) object) 
      (multiple-value-setq (pile object) (FSM-comment pile))
      (setf (parser-topcomment theparse) object)
      (multiple-value-setq (pile alist) (FSM-macros pile)) 
      (setf (parser-macros theparse) alist)
      (multiple-value-setq (pile object) (FSM-cdpsig pile theparse))
      (setf (parser-cdpsig theparse) object)
      (multiple-value-setq (pile iscat?) (FSM-isCategory? pile theparse))
      (if iscat?
        (multiple-value-setq (pile object) (FSM-catBody pile theparse))
        (multiple-value-setq (pile object) (FSM-dpBody pile theparse)) )
      (values theparse pile))
  (print (list 'gotit))))


(defun expandMacro (name) 
  (cdr (assoc name (parser-macros theparse))))

(defun P (filename)
 (setq t1 (make-sourcecode (concatenate 'string *place* filename ".spad")))
 (pretty (sourcecode-tree t1))
 (values))

(defun q (filename)
 (setq t1 (make-sourcecode 
             (concatenate 'string filename ".spad")))
 (pretty (sourcecode-tree t1))
 (values))

\end{chunk}


\chapter{The Categories}

There are patterns in the following code. Violating these patterns
will generate obscure bugs so be careful. Lets assume a given class.

\begin{verbatim}
(defclass |GcdDomainType| (|LeftOreRingType| |IntegralDomainType|)
  ((parents :initform '(|LeftOreRing| |IntegralDomain|))
   (name :initform "GcdDomain")
   (level :initform 12)
   (abbreviation :initform 'GCDDOM)))

(defvar |GcdDomain|
  (progn
    (push '|GcdDomain| *Categories*)
    (make-instance '|GcdDomainType|)))

\end{verbatim}

Notice the following properties:

The classname {\bf GcdDomainType} is escaped so that it will 
retain its case no matter which lisp is used.

The classname {\bf GcdDomainType} ends with ``Type''.

The classes it depends on all end with ``Type''.

The parent attribute list is in the same order as the list
used for inheritance. Failure to do this will result in 
an incorrect ordering of lookups.

The parent attributes do NOT end in with ``Type'' as they
are instances. Putting ``Type'' in the name will result in
an obscure circular reference error at compile time.

The name is given at the class level. It must be provided
as it is used in printing the object.

The level attribute is read-only.

The {\bf GcdDomain} variable adds its name to the global
variable *Categories* so we maintain a current list.

We need to call make-instance at compile time in order
to force MOP::finalize-inheritance, otherwise the 
compiler will find some random reason to complain.


\section{Level 1}

This is a searchable list of all of the Categories in level 1.
\begin{chunk}{defvar level1}
(defvar level1
 '(|AdditiveValuationAttribute| |ApproximateAttribute|
   |ArbitraryExponentAttribute| |ArbitraryPrecisionAttribute|
   |ArcHyperbolicFunctionCategory| |ArcTrigonometricFunctionCategory|
   |AttributeRegistry| |BasicType| |CanonicalAttribute|
   |CanonicalClosedAttribute| |CanonicalUnitNormalAttribute| |CentralAttribute|
   |CoercibleTo| |CombinatorialFunctionCategory| |CommutativeStarAttribute|
   |ConvertibleTo| |ElementaryFunctionCategory| |Eltable|
   |FiniteAggregateAttribute| |HyperbolicFunctionCategory| |InnerEvalable|
   |JacobiIdentityAttribute| |LazyRepresentationAttribute| |LeftUnitaryAttribute|
   |ModularAlgebraicGcdOperations| |MultiplicativeValuationAttribute|
   |NoZeroDivisorsAttribute| |NotherianAttribute| |NullSquareAttribute|
   |OpenMath| |PartialTranscendentalFunctions| |PartiallyOrderedSetAttribute|
   |PrimitiveFunctionCategory| |RadicalCategory| |RetractableTo|
   |RightUnitaryAttribute| |ShallowlyMutableAttribute| |SpecialFunctionCategory|
   |TrigonometricFunctionCategory| |Type| |UnitsKnownAttribute|))

\end{chunk}

\subsection{AdditiveValuationAttribute}
\index[cat]{AdditiveValuationAttribute!Category}
\index[cat]{Category!AdditiveValuationAttribute}
\index[cat]{ATADDVA}
\begin{chunk}{defclass AdditiveValuationAttributeType}
(defclass |AdditiveValuationAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AdditiveValuationAttributeType")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATADDVA)
   (comment :initform (list
     "The class of all euclidean domains such that"
     "euclideanSize(a*b) = EuclideanSize(a)+euclideanSize(b)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AdditiveValuationAttribute|
  (progn
    (push '|AdditiveValuationAttribute| *Categories*)
    (make-instance '|AdditiveValuationAttributeType|)))

\end{chunk}

\subsection{ApproximateAttribute}
\index[cat]{ApproximateAttribute!Category}
\index[cat]{Category!ApproximateAttribute}
\index[cat]{ATAPPRO}
\begin{chunk}{defclass ApproximateAttributeType}
(defclass |ApproximateAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ApproximateAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATAPPRO)
   (comment :initform (list
     "An approximation to the real numbers."))))

(defvar |ApproximateAttribute|
  (progn
    (push '|ApproximateAttribute| *Categories*)
    (make-instance '|ApproximateAttributeType|)))

\end{chunk}

\subsection{ArbitraryExponentAttribute}
\index[cat]{ArbitraryExponentAttribute!Category}
\index[cat]{Category!ArbitraryExponentAttribute}
\index[cat]{ATARBEX}
\begin{chunk}{defclass ArbitraryExponentAttributeType}
(defclass |ArbitraryExponentAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ArbitraryExponentAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATARBEX)
   (comment :initform (list
     "Approximate numbers with arbitrarily large exponents"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ArbitraryExponentAttribute|
  (progn
    (push '|ArbitraryExponentAttribute| *Categories*)
    (make-instance '|ArbitraryExponentAttributeType|)))

\end{chunk}

\subsection{ArbitraryPrecisionAttribute}
\index[cat]{ArbitraryPrecisionAttribute!Category}
\index[cat]{Category!ArbitraryPrecisionAttribute}
\index[cat]{ATARBPR}
\begin{chunk}{defclass ArbitraryPrecisionAttributeType}
(defclass |ArbitraryPrecisionAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ArbitraryPrecisionAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATARBPR)
   (comment :initform (list
     "Approximate numbers for which the user can set the precision"
     "for subsequent calculations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ArbitraryPrecisionAttribute|
  (progn
    (push '|ArbitraryPrecisionAttribute| *Categories*)
    (make-instance '|ArbitraryPrecisionAttributeType|)))

\end{chunk}

\subsection{ArcHyperbolicFunctionCategory}
\index[cat]{ArcHyperbolicFunctionCategory!Category}
\index[cat]{Category!ArcHyperbolicFunctionCategory}
\index[cat]{AHYP}
\begin{chunk}{defclass ArcHyperbolicFunctionCategoryType}
(defclass |ArcHyperbolicFunctionCategoryType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ArcHyperbolicFunctionCategory")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'AHYP)
   (comment :initform (list
     "Category for the inverse hyperbolic trigonometric functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list 
     (make-signature '|acosh| '(%) '(%)
       '("acosh(x) returns the hyperbolic arc-cosine of x."))
     (make-signature '|acoth| '(%) '(%)
       '("acoth(x) returns the hyperbolic arc-cotangent of x."))
     (make-signature '|acsch| '(%) '(%)
       '("acsch(x) returns the hyperbolic arc-cosecant of x."))
     (make-signature '|asech| '(%) '(%)
       '("asech(x) returns the hyperbolic arc-secant of x."))
     (make-signature '|asinh| '(%) '(%)
       '("asinh(x) returns the hyperbolic arc-sine of x."))
     (make-signature '|atanh| '(%) '(%)
       '("atanh(x) returns the hyperbolic arc-tangent of x."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ArcHyperbolicFunctionCategory|
  (progn
    (push '|ArcHyperbolicFunctionCategory| *Categories*)
    (make-instance '|ArcHyperbolicFunctionCategoryType|)))

\end{chunk}

\subsection{ArcTrigonometricFunctionCategory}
\index[cat]{ArcTrigonometricFunctionCategory!Category}
\index[cat]{Category!ArcTrigonometricFunctionCategory}
\index[cat]{ATRIG}
\begin{chunk}{defclass ArcTrigonometricFunctionCategoryType}
(defclass |ArcTrigonometricFunctionCategoryType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ArcTrigonometricFunctionCategory")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATRIG)
   (comment :initform (list
     "Category for the inverse trigonometric functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list 
     (make-signature '|acos| '(%) '(%)
       '("acos(x) returns the arc-cosine of x. When evaluated"
         "into some subset of the complex numbers, one"
         "branch cut for acos lies along the negative real axis"
         "to the left of -1 (inclusive), continuous with the"
         "upper half plane, the other along the positive real axis to"
         "the right of 1 (inclusive), continuous with the lower half"
         "plane."))
     (make-signature '|acot| '(%) '(%)
       '("acot(x) returns the arc-cotangent of x."))
     (make-signature '|acsc| '(%) '(%)
       '("acsc(x) returns the arc-cosecant of x."))
     (make-signature '|asec| '(%) '(%)
       '("asec(x) returns the arc-secant of x."))
     (make-signature '|asin| '(%) '(%)
       '("asin(x) returns the arc-sine of x. When evaluated into some"
         "subset of the complex numbers, one branch cut for asin lies"
         "along the negative real axis to the left of -1 (inclusive),"
         "continuous with the upper half plane, the other along the"
         "positive real axis to the right of 1 (inclusive), continuous"
         "with the lower half plane."))
     (make-signature '|atan| '(%) '(%)
       '("atan(x) returns the arc-tangent of x. When evaluated into some"
         "subset of the complex numbers, one branch cut for atan lies"
         "along the positive imaginary axis above %i (exclusive),"
         "continuous with the left half plane, the other along the"
         "negative imaginary axis below -%i (exclusive) continuous"
         "with the right half plane. The domain does not contain %i and -%i"))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ArcTrigonometricFunctionCategory|
  (progn
    (push '|ArcTrigonometricFunctionCategory| *Categories*)
    (make-instance '|ArcTrigonometricFunctionCategoryType|)))

\end{chunk}

\subsection{AttributeRegistry}
\index[cat]{AttributeRegistry!Category}
\index[cat]{Category!AttributeRegistry}
\index[cat]{ATTREG}
\begin{chunk}{defclass AttributeRegistryType}
(defclass |AttributeRegistryType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AttributeRegistry")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATTREG)
   (comment :initform (list
     "This category exports the attributes in the AXIOM Library"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list 
     (make-signature '|finiteAggregate| () ()
       '("finiteAggregate is true if it is an aggregate with a"
         "finite number of elements."))
     (make-signature '|commutative("*")| () ()
       '("commutative(\"*\") is true if it has an operation"
         "\"*\": (D,D) -> D} which is commutative."))
     (make-signature '|shallowlyMutable| () ()
       '("shallowlyMutable is true if its values"
         "have immediate components that are updateable (mutable)."
         "Note that the properties of any component domain are"
         "irrevelant to the shallowlyMutable proper."))
     (make-signature '|unitsKnown| () ()
       '("unitsKnown is true if a monoid (a multiplicative semigroup"
         "with a 1) has unitsKnown means that"
         "the operation recip can only return \"failed\""
         "if its argument is not a unit."))
     (make-signature '|leftUnitary| () ()
       '("leftUnitary is true if 1 * x = x for all x."))
     (make-signature '|rightUnitary| () ()
       '("rightUnitary is true if x * 1 = x for all x."))
     (make-signature '|noZeroDivisors| () ()
       '("noZeroDivisors is true if x * y ~= 0 implies"
         "both x and y are non-zero."))
     (make-signature '|canonicalUnitNormal| () ()
       '("canonicalUnitNormal is true if we can choose a canonical"
         "representative for each class of associate elements, that is"
         "associates?(a,b) returns true if and only if"
         "unitCanonical(a) = unitCanonical(b)."))
     (make-signature '|canonicalsClosed| () ()
       '("canonicalsClosed is true if"
         "unitCanonical(a)*unitCanonical(b) = unitCanonical(a*b)."))
     (make-signature '|arbitraryPrecision| () ()
       '("arbitraryPrecision means the user can set the"
         "precision for subsequent calculations."))
     (make-signature '|partiallyOrderedSet| () ()
       '("partiallyOrderedSet is true if"
         "a set with < which is transitive,"
         "but not(a < b or a = b)"
         "does not necessarily imply b<a."))
     (make-signature '|central| () ()
       '("central is true if, given an algebra over a ring R,"
         "the image of R is the center of the algebra, For example,"
         "the set of members of the algebra which commute with all"
         "others is precisely the image of R in the algebra."))
     (make-signature '|noetherian| () ()
       '("noetherian is true if all of its ideals are"
         "finitely generated."))
     (make-signature '|additiveValuation| () ()
       '("additiveValuation implies"
         "euclideanSize(a*b)=euclideanSize(a)+euclideanSize(b)."))
     (make-signature '|multiplicativeValuation| () ()
       '("multiplicativeValuation implies"
         "euclideanSize(a*b)=euclideanSize(a)*euclideanSize(b)."))
     (make-signature '|NullSquare| () ()
       '("NullSquare means that [x,x] = 0 holds."
         "See LieAlgebra."))
     (make-signature '|JacobiIdentity| () ()
       '("JacobiIdentity means that"
         "[x,[y,z]]+[y,[z,x]]+[z,[x,y]] = 0 holds."
         "See LieAlgebra."))
     (make-signature '|canonical| () ()
       '("canonical is true if and only if distinct elements have"
         "distinct data structures. For example, a domain of mathematical"
         "objects  which has the canonical attribute means that two"
         "objects are mathematically equal if and only if their data"
         "structures are equal."))
     (make-signature '|approximate| () ()
       '("approximate means 'is an approximation to the"
         "real numbers'."))
     ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AttributeRegistry|
  (progn
    (push '|AttributeRegistry| *Categories*)
    (make-instance '|AttributeRegistryType|)))

\end{chunk}

\subsection{BasicType}
\index[cat]{BasicType!Category}
\index[cat]{Category!BasicType}
\index[cat]{BASTYPE}
\begin{chunk}{defclass BasicTypeType}
(defclass |BasicTypeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "BasicType")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'BASTYPE)
   (comment :initform (list
     "BasicType is the basic category for describing a collection"
     "of elements with = (equality)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|=| '(|Boolean|) '(% %)
       '("x=y tests if x and y are equal.") () t)
     (make-signature '|~=| '(|Boolean|) '(% %)
       '("x~=y tests if x and y are not equal.") () t)
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BasicType|
  (progn
    (push '|BasicType| *Categories*)
    (make-instance '|BasicTypeType|)))

\end{chunk}
\begin{verbatim}
(
 ?~=? : (%,%) -> Boolean
 (~= (((|Boolean|) $ $) 7))

 ?=? : (%,%) -> Boolean
 (= (((|Boolean|) $ $) 6)))
\end{verbatim}

\subsubsection{BASTYPE Source Code}
\begin{verbatim}
)abbrev category BASTYPE BasicType
--% BasicType
++ Description:
++ BasicType is the basic category for describing a collection
++ of elements with = (equality).

BasicType() : Category == SIG where

  SIG ==> with

    "=" : (%,%) -> Boolean
      ++ x=y tests if x and y are equal.

    "~=" : (%,%) -> Boolean   
      ++ x~=y tests if x and y are not equal.

   add

     _~_=(x:%,y:%) : Boolean == not(x=y)

\end{verbatim}

\subsubsection{BASTYPE Lisp Code (other)}
\begin{verbatim}
BasicType : Category == Type with
  =: (%,%) -> Boolean
  ~=: (%,%) -> Boolean

(def BasicType;AL nil)
(def BasicType;
  (lambda ()
    (bind ((g (Join (Type)
               (mkCategory domain
	         '(((= ((Boolean) $ $)) true)
		   ((~= ((Boolean) $ $)) true)
		   ((before? ((Boolean $ $)) true))
		 nil '((Boolean)) nil))))
          (store (tref g 0) '(BasicType))
	  g))))

(def BasicType
  (lambda ()
    (when ((not (eq BasicType;AL nil)) BasicType;AL)
          (t (store BasicType;AL (BasicType;))))))

\end{verbatim}

\subsubsection{BASTYPE.lsp}
\begin{verbatim}
(/VERSIONCHECK 2) 

(SETQ |BasicType;AL| (QUOTE NIL)) 

(DEFUN |BasicType| NIL
 (LET (#:G1588)
   (COND 
     (|BasicType;AL|) 
     (T (SETQ |BasicType;AL| (|BasicType;|)))))) 

(DEFUN |BasicType;| NIL
 (PROG (#0=#1=#:G1586)
   (RETURN
     (PROG1 
       (LETT #0#
         (|Join| 
           (|mkCategory| 
             (QUOTE |domain|) 
             (QUOTE (((= ((|Boolean|) $ $)) T)
                     ((~= ((|Boolean|) $ $)) T)))
             NIL
             (QUOTE ((|Boolean|))) NIL))
         |BasicType|)
       (SETELT #0# 0 (QUOTE (|BasicType|))))))) 

(SETF (GET (QUOTE |BasicType|) (QUOTE NILADIC)) T) 

\end{verbatim}

\subsubsection{BASTYPE index.kaf}
\begin{verbatim}
1057                
(SETQ |$CategoryFrame|
  (|put| 
    (QUOTE |BasicType|) 
    (QUOTE |isCategory|) 
    T 
    (|addModemap| 
      (QUOTE |BasicType|) 
      (QUOTE (|BasicType|)) 
      (QUOTE ((|Category|))) 
      T 
      (QUOTE |BasicType|) 
      |$CategoryFrame|)))
(SETF (GET (QUOTE |BasicType|) (QUOTE NILADIC)) T)
(|BasicType|)
|category|
(((|BasicType|) (|Category|)) (T |BasicType|))
(|Join| (CATEGORY |domain| (SIGNATURE = ((|Boolean|) $ $)) (SIGNATURE ~= ((|Boolean|) $ $))))
"/research/20190531/mnt/ubuntu/../../src/algebra/BASTYPE.spad"
((~= (*1 *2 *1 *1) (AND (|ofCategory| *1 (|BasicType|)) (|isDomain| *2 (|Boolean|))))
  (= (*1 *2 *1 *1) (AND (|ofCategory| *1 (|BasicType|)) (|isDomain| *2 (|Boolean|)))))
((~= (((|Boolean|) $ $) 7)) (= (((|Boolean|) $ $) 6)))
((|BASTYPE-;~=;2SB;1| ((|Boolean|) S S)))
BASTYPE
((|constructor| 
 (NIL "BasicType is the basic category for describing a collection of elements with = (equality)."))
 (~= (((|Boolean|) $ $) "\\spad{x~=y} tests if \\spad{x} and \\spad{y} are not equal."))
 (= (((|Boolean|) $ $) "\\spad{x=y} tests if \\spad{x} and \\spad{y} are equal.")))
(("slot1Info" 0 NIL)
 ("documentation" 0 770)
 ("ancestors" 0 NIL)
 ("parents" 0 NIL)
 ("abbreviation" 0 762)
 ("predicates" 0 NIL)
 ("attributes" 0 NIL)
 ("signaturesAndLocals" 0 720)
 ("superDomain" 0 NIL)
 ("operationAlist" 0 665)
 ("modemaps" 0 494)
 ("sourceFile" 0 431)
 ("constructorCategory" 0 337)
 ("constructorModemap" 0 290)
 ("constructorKind" 0 279)
 ("constructorForm" 0 265)
 ("NILADIC" 0 214)
 ("compilerInfo" 0 20))

\end{verbatim}

\subsubsection{BASICTYPE database struct}
\begin{verbatim}
)lisp (showdatabase '|BasicType|)
getdatabase call: BasicType            CONSTRUCTORKIND
CONSTRUCTORKIND: category
getdatabase call: BasicType            COSIG
COSIG: (NIL)
getdatabase call: BasicType            OPERATION
OPERATION: NIL
CONSTRUCTORMODEMAP: 
getdatabase call: BasicType            CONSTRUCTORMODEMAP
getdatabase miss: BasicType            CONSTRUCTORMODEMAP

(((|BasicType|) (|Category|)) (T |BasicType|))
CONSTRUCTORCATEGORY: 
getdatabase call: BasicType            CONSTRUCTORCATEGORY
getdatabase miss: BasicType            CONSTRUCTORCATEGORY

(|Join| (CATEGORY |domain| (SIGNATURE = ((|Boolean|) $ $))
            (SIGNATURE ~= ((|Boolean|) $ $))))
OPERATIONALIST: 
getdatabase call: BasicType            OPERATIONALIST
getdatabase miss: BasicType            OPERATIONALIST

((~= (((|Boolean|) $ $) 7)) (= (((|Boolean|) $ $) 6)))
MODEMAPS: 
getdatabase call: BasicType            MODEMAPS
getdatabase miss: BasicType            MODEMAPS

((~= (*1 *2 *1 *1)
     (AND (|ofCategory| *1 (|BasicType|)) (|isDomain| *2 (|Boolean|))))
 (= (*1 *2 *1 *1)
    (AND (|ofCategory| *1 (|BasicType|))
         (|isDomain| *2 (|Boolean|)))))
getdatabase call: BasicType            HASCATEGORY
HASCATEGORY: NIL
getdatabase call: BasicType            OBJECT
OBJECT: /mnt/c/Users/markb/EXE/axiom/mnt/ubuntu/algebra/BASTYPE.o
getdatabase call: BasicType            NILADIC
NILADIC: T
getdatabase call: BasicType            ABBREVIATION
ABBREVIATION: BASTYPE
getdatabase call: BasicType            CONSTRUCTOR?
CONSTRUCTOR?: T
getdatabase call: BasicType            CONSTRUCTOR
CONSTRUCTOR: NIL
getdatabase call: BasicType            DEFAULTDOMAIN
DEFAULTDOMAIN: NIL
getdatabase call: BasicType            ANCESTORS
ANCESTORS: NIL
getdatabase call: BasicType            SOURCEFILE
SOURCEFILE: bookvol10.2.pamphlet
getdatabase call: BasicType            CONSTRUCTORFORM
getdatabase miss: BasicType            CONSTRUCTORFORM
CONSTRUCTORFORM: (BasicType)
getdatabase call: BasicType            CONSTRUCTORARGS
getdatabase call: BasicType            CONSTRUCTORFORM
CONSTRUCTORARGS: NIL
getdatabase call: BasicType            ATTRIBUTES
getdatabase miss: BasicType            ATTRIBUTES
ATTRIBUTES: NIL
PREDICATES: 
getdatabase call: BasicType            PREDICATES
getdatabase miss: BasicType            PREDICATES

NILgetdatabase call: BasicType            DOCUMENTATION
getdatabase miss: BasicType            DOCUMENTATION
DOCUMENTATION: 
  ((constructor (NIL BasicType is the basic category for describing a collection of elements with = (equality).))
   (~= (((Boolean) $ $) \spad{x~=y} tests if \spad{x} and \spad{y} are not equal.))
   (= (((Boolean) $ $) \spad{x=y} tests if \spad{x} and \spad{y} are equal.)))
getdatabase call: BasicType            PARENTS
PARENTS: NIL
Value = NIL

\end{verbatim}

\subsubsection{BASTYPE-.lsp}
\begin{verbatim}

(/VERSIONCHECK 2) 

(DEFUN |BASTYPE-;~=;2SB;1| (|x| |y| $)
  (COND
    ((SPADCALL |x| |y| (QREFELT $ 8)) (QUOTE NIL))
    ((QUOTE T) (QUOTE T)))) 

(DEFUN |BasicType&| (|#1|) 
  (PROG (DV$1 |dv$| $ |pv$|)
    (RETURN 
      (PROGN 
        (LETT DV$1 (|devaluate| |#1|) . #0=(|BasicType&|)) 
        (LETT |dv$| (LIST (QUOTE |BasicType&|) DV$1) . #0#)
        (LETT $ (MAKE-ARRAY 10) . #0#)
        (QSETREFV $ 0 |dv$|)
        (QSETREFV $ 3 (LETT |pv$| (|buildPredVector| 0 0 NIL) . #0#))
        (|stuffDomainSlots| $) (QSETREFV $ 6 |#1|)
        $)))) 

(SETF 
  (GET (QUOTE |BasicType&|) (QUOTE |infovec|))
  (LIST
   (QUOTE #(NIL NIL NIL NIL NIL NIL (|local| |#1|) (|Boolean|) (0 . =) |BASTYPE-;~=;2SB;1|))
   (QUOTE #(~= 6))
   (QUOTE NIL)
   (CONS 
     (|makeByteWordVec2| 1 (QUOTE NIL))
     (CONS 
       (QUOTE #())
       (CONS (QUOTE #()) (|makeByteWordVec2| 9 (QUOTE (2 6 7 0 0 8 2 0 7 0 0 9))))))
   (QUOTE |lookupComplete|))) 

\end{verbatim}

\subsubsection{BASTYPE- index.kaf}
\begin{verbatim}
1540                
(|updateSlot1DataBase| (QUOTE (|BasicType&| (NIL (~= ((7 0 0) 9))))))

(SETF 
  (GET (QUOTE |BasicType&|) (QUOTE |infovec|))
  (LIST 
    (QUOTE #(NIL NIL NIL NIL NIL NIL (|local| |#1|) (|Boolean|) (0 . =) |BASTYPE-;~=;2SB;1|))
    (QUOTE #(~= 6))
    (QUOTE NIL)
    (CONS
      (|makeByteWordVec2| 1 (QUOTE NIL))
      (CONS
        (QUOTE #())
        (CONS
          (QUOTE #())
          (|makeByteWordVec2| 9 (QUOTE (2 6 7 0 0 8 2 0 7 0 0 9))))))
    (QUOTE |lookupComplete|)))

(SETQ |$CategoryFrame|
  (|put| 
    (QUOTE |BasicType&|) 
    (QUOTE |isFunctor|) 
    (QUOTE (((~= ((|Boolean|) $ $)) T (ELT $ 9))))
  (|addModemap|
    (QUOTE |BasicType&|)
    (QUOTE (|BasicType&| |#1|))
    (QUOTE ((CATEGORY |domain| (SIGNATURE ~= ((|Boolean|) |#1| |#1|))) (|BasicType|)))
    T
    (QUOTE |BasicType&|)
    (|put| 
      (QUOTE |BasicType&|) 
      (QUOTE |mode|) 
      (QUOTE (|Mapping| (CATEGORY |domain| (SIGNATURE ~= ((|Boolean|) |#1| |#1|))) (|BasicType|)))
      |$CategoryFrame|))))
  (|BasicType&| S)
  |domain|
  (((|BasicType&| |#1|) 
    (CATEGORY |domain| (SIGNATURE ~= ((|Boolean|) |#1| |#1|)))
    (|BasicType|))
   (T |BasicType&|))
  (CATEGORY |domain| (SIGNATURE ~= ((|Boolean|) |#1| |#1|)))
  "/research/20190531/mnt/ubuntu/../../src/algebra/BASTYPE.spad"
  ((~= (((|Boolean|) $ $) 9)))
  ((|BASTYPE-;~=;2SB;1| ((|Boolean|) S S)))
  BASTYPE-
  ((|constructor|
     (NIL "BasicType is the basic category for describing a collection of elements with = (equality)."))
   (~= (((|Boolean|) $ $) "\\spad{x~=y} tests if \\spad{x} and \\spad{y} are not equal."))
   (= (((|Boolean|) $ $) "\\spad{x=y} tests if \\spad{x} and \\spad{y} are equal.")))
  (|BasicType&| (NIL (~= ((7 0 0) 9))))
  (("slot1Info" 0 1502)
   ("documentation" 0 1215)
   ("ancestors" 0 NIL)
   ("parents" 0 NIL)
   ("abbreviation" 0 1206)
   ("predicates" 0 NIL)
   ("attributes" 0 NIL)
   ("signaturesAndLocals" 0 1164)
   ("superDomain" 0 NIL)
   ("operationAlist" 0 1135)
   ("modemaps" 0 NIL)
   ("sourceFile" 0 1072)
   ("constructorCategory" 0 1013)
   ("constructorModemap" 0 899)
   ("constructorKind" 0 890)
   ("constructorForm" 0 873)
   ("compilerInfo" 0 429)
   ("loadTimeStuff" 0 90)
   ("slot1DataBase" 0 20))

\end{verbatim}

\subsubsection{BASICTYPE database struct}
\begin{verbatim}
)lisp (showdatabase '|BasicType&|)
getdatabase call: BasicType&           CONSTRUCTORKIND
CONSTRUCTORKIND: domain
getdatabase call: BasicType&           COSIG
COSIG: (NIL T)
getdatabase call: BasicType&           OPERATION
OPERATION: NIL
CONSTRUCTORMODEMAP: 
getdatabase call: BasicType&           CONSTRUCTORMODEMAP
getdatabase miss: BasicType&           CONSTRUCTORMODEMAP

(((|BasicType&| |#1|)
  (CATEGORY |domain| (SIGNATURE ~= ((|Boolean|) |#1| |#1|)))
  (|BasicType|))
 (T |BasicType&|))
CONSTRUCTORCATEGORY: 
getdatabase call: BasicType&           CONSTRUCTORCATEGORY
getdatabase miss: BasicType&           CONSTRUCTORCATEGORY

(CATEGORY |domain| (SIGNATURE ~= ((|Boolean|) |#1| |#1|)))
OPERATIONALIST: 
getdatabase call: BasicType&           OPERATIONALIST
getdatabase miss: BasicType&           OPERATIONALIST

((~= (((|Boolean|) $ $) 9)))
MODEMAPS: 
getdatabase call: BasicType&           MODEMAPS
getdatabase miss: BasicType&           MODEMAPS

NILgetdatabase call: BasicType&           HASCATEGORY
HASCATEGORY: NIL
getdatabase call: BasicType&           OBJECT
OBJECT: /mnt/c/Users/markb/EXE/axiom/mnt/ubuntu/algebra/BASTYPE-.o
getdatabase call: BasicType&           NILADIC
NILADIC: NIL
getdatabase call: BasicType&           ABBREVIATION
ABBREVIATION: BASTYPE-
getdatabase call: BasicType&           CONSTRUCTOR?
CONSTRUCTOR?: T
getdatabase call: BasicType&           CONSTRUCTOR
CONSTRUCTOR: NIL
getdatabase call: BasicType&           DEFAULTDOMAIN
DEFAULTDOMAIN: NIL
getdatabase call: BasicType&           ANCESTORS
ANCESTORS: NIL
getdatabase call: BasicType&           SOURCEFILE
SOURCEFILE: NIL
getdatabase call: BasicType&           CONSTRUCTORFORM
getdatabase miss: BasicType&           CONSTRUCTORFORM
CONSTRUCTORFORM: (BasicType& S)
getdatabase call: BasicType&           CONSTRUCTORARGS
getdatabase call: BasicType&           CONSTRUCTORFORM
CONSTRUCTORARGS: (S)
getdatabase call: BasicType&           ATTRIBUTES
getdatabase miss: BasicType&           ATTRIBUTES
ATTRIBUTES: NIL
PREDICATES: 
getdatabase call: BasicType&           PREDICATES
getdatabase miss: BasicType&           PREDICATES

NILgetdatabase call: BasicType&           DOCUMENTATION
getdatabase miss: BasicType&           DOCUMENTATION
DOCUMENTATION: ((constructor (NIL BasicType is the basic category for describing a collection of elements with = (equality).)) (~= (((Boolean) $ $) \spad{x~=y} tests if \spad{x} and \spad{y} are not equal.)) (= (((Boolean) $ $) \spad{x=y} tests if \spad{x} and \spad{y} are equal.)))
getdatabase call: BasicType&           PARENTS
PARENTS: NIL
Value = NIL

\end{verbatim}

\subsection{CanonicalAttribute}
\index[cat]{CanonicalAttribute!Category}
\index[cat]{Category!CanonicalAttribute}
\index[cat]{ATCANON}
\begin{chunk}{defclass CanonicalAttributeType}
(defclass |CanonicalAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CanonicalAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATCANON)
   (comment :initform (list
     "The class of all domains which have canonical represenntation,"
     "that is, mathematically equal elements have the same data structure."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CanonicalAttribute|
  (progn
    (push '|CanonicalAttribute| *Categories*)
    (make-instance '|CanonicalAttributeType|)))

\end{chunk}

\subsection{CanonicalClosedAttribute}
\index[cat]{CanonicalClosedAttribute!Category}
\index[cat]{Category!CanonicalClosedAttribute}
\index[cat]{ATCANCL}
\begin{chunk}{defclass CanonicalClosedAttributeType}
(defclass |CanonicalClosedAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CanonicalClosedAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATCANCL)
   (comment :initform (list
     "The class of all integral domains such that"
     "unitCanonical(a)*unitCanonical(b) = unitCanonical(a*b)}"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CanonicalClosedAttribute|
  (progn
    (push '|CanonicalClosedAttribute| *Categories*)
    (make-instance '|CanonicalClosedAttributeType|)))

\end{chunk}

\subsection{CanonicalUnitNormalAttribute}
\index[cat]{CanonicalUnitNormalAttribute!Category}
\index[cat]{Category!CanonicalUnitNormalAttribute}
\index[cat]{ATCUNOR}
\begin{chunk}{defclass CanonicalUnitNormalAttributeType}
(defclass |CanonicalUnitNormalAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CanonicalUnitNormalAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATCUNOR)
   (comment :initform (list
     "The class of all integral domains such that we can choose a canonical"
     "representative for each class of associate elements. That is,"
     "associates?(a,b) returns true if and only if"
     "unitCanonical(a) = unitCanonical(b)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CanonicalUnitNormalAttribute|
  (progn
    (push '|CanonicalUnitNormalAttribute| *Categories*)
    (make-instance '|CanonicalUnitNormalAttributeType|)))

\end{chunk}

\subsection{CentralAttribute}
\index[cat]{CentralAttribute!Category}
\index[cat]{Category!CentralAttribute}
\index[cat]{ATCENRL}
\begin{chunk}{defclass CentralAttributeType}
(defclass |CentralAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CentralAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATCENRL)
   (comment :initform (list
     "Central is true if, given an algebra over a ring R, the image of R"
     "is the center of the algebra. For example, the set of members of the"
     "algebra which commute with all others is precisely the image of R"
     "in the algebra."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CentralAttribute|
  (progn
    (push '|CentralAttribute| *Categories*)
    (make-instance '|CentralAttributeType|)))

\end{chunk}

\subsection{CoercibleTo}
\index[cat]{CoercibleTo!Category}
\index[cat]{Category!CoercibleTo}
\index[cat]{KOERCE}
\begin{chunk}{defclass CoercibleToType}
(defclass |CoercibleToType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CoercibleTo")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'KOERCE)
   (comment :initform (list
     "A is coercible to B means any element of A can automatically be"
     "converted into an element of B by the interpreter."))
   (argslist :initform (list (make-instance 'typeParam :variable 'S :paramtype '|Type|)))
   (macros :initform nil)
   (withlist :initform (list 
     (make-signature '|coerce| 'S '(%)
       '("coerce(a) transforms a into an element of S."))))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CoercibleTo|
  (progn
    (push '|CoercibleTo| *Categories*)
    (make-instance '|CoercibleToType|)))

\end{chunk}

\subsection{CombinatorialFunctionCategory}
\index[cat]{CombinatorialFunctionCategory!Category}
\index[cat]{Category!CombinatorialFunctionCategory}
\index[cat]{CFCAT}
\begin{chunk}{defclass CombinatorialFunctionCategoryType}
(defclass |CombinatorialFunctionCategoryType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CombinatorialFunctionCategory")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'CFCAT)
   (comment :initform (list
     "Category for the usual combinatorial functions;"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list 
     (make-signature '|binomial| '% '(% %)
       '("binomial(n,r) returns the \spad{(n,r)} binomial coefficient"
         "(often denoted in the literature by \spad{C(n,r)})."
         "Note that \spad{C(n,r) = n!/(r!(n-r)!)} where \spad{n >= r >= 0}.")
       '("[binomial(5,i) for i in 0..5]"))
     (make-signature '|factorial| '% '(%)
       '("factorial(n) computes the factorial of n"
         "(denoted in the literature by \spad{n!})"
         "Note that \spad{n! = n (n-1)! when n > 0}; also, \spad{0! = 1}."))
     (make-signature '|permutation| '% '(% %)
       '("permutation(n, m) returns the number of"
         "permutations of n objects taken m at a time."
         "Note that \spad{permutation(n,m) = n!/(n-m)!}."))))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CombinatorialFunctionCategory|
  (progn
    (push '|CombinatorialFunctionCategory| *Categories*)
    (make-instance '|CombinatorialFunctionCategoryType|)))

\end{chunk}

\subsection{CommutativeStarAttribute}
\index[cat]{CommutativeStarAttribute!Category}
\index[cat]{Category!CommutativeStarAttribute}
\index[cat]{ATCS}
\begin{chunk}{defclass CommutativeStarAttributeType}
(defclass |CommutativeStarAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CommutativeStarAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATCS)
   (comment :initform (list
     "The class of all commutative semigroups in multiplicative notation."
     "In other words domain D with '*': (D,D) -> D} which is"
     "commutative. Typically applied to rings."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CommutativeStarAttribute|
  (progn
    (push '|CommutativeStarAttribute| *Categories*)
    (make-instance '|CommutativeStarAttributeType|)))

\end{chunk}

\subsection{ConvertibleTo}
\index[cat]{ConvertibleTo!Category}
\index[cat]{Category!ConvertibleTo}
\index[cat]{KONVERT}
\begin{chunk}{defclass ConvertibleToType}
(defclass |ConvertibleToType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ConvertibleTo")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'KONVERT)
   (comment :initform (list
     "A is convertible to B means any element of A"
     "can be converted into an element of B,"
     "but not automatically by the interpreter."))
   (argslist :initform (list (make-instance 'typeParam :variable 'S :paramtype '|Type|)))
   (macros :initform nil)
   (withlist :initform (list 
     (make-signature '|convert| 'S '(%) 
       '("convert(a) transforms a into an element of S."))))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ConvertibleTo|
  (progn
    (push '|ConvertibleTo| *Categories*)
    (make-instance '|ConvertibleToType|)))

\end{chunk}

\subsection{ElementaryFunctionCategory}
\index[cat]{ElementaryFunctionCategory!Category}
\index[cat]{Category!ElementaryFunctionCategory}
\index[cat]{ELEMFUN}
\begin{chunk}{defclass ElementaryFunctionCategoryType}
(defclass |ElementaryFunctionCategoryType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ElementaryFunctionCategory")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ELEMFUN)
   (comment :initform (list
     "Category for the elementary functions;"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list 
     (make-signature '|log| '% '(%)
       '("log(x) returns the natural logarithm of x. When evaluated"
        "into some subset of the complex numbers, the branch cut lies"
        "along the negative real axis, continuous with quadrant II. The"
        "domain does not contain the origin."))
     (make-signature '|exp| '% '(%)
       '("exp(x) returns %e to the power x."))
     (make-signature '|**| '% '(% %)
       '("x**y returns x to the power y.") () t)))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ElementaryFunctionCategory|
  (progn
    (push '|ElementaryFunctionCategory| *Categories*)
    (make-instance '|ElementaryFunctionCategoryType|)))

\end{chunk}

\subsection{Eltable}
\index[cat]{Eltable!Category}
\index[cat]{Category!Eltable}
\index[cat]{ELTAB}
\begin{chunk}{defclass EltableType}
(defclass |EltableType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "Eltable")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ELTAB)
   (comment :initform (list
     "An eltable over domains D and I is a structure which can be viewed"
     "as a function from D to I. Examples of eltable structures range from"
     "data structures, For example, those of type List, to algebraic"
     "structures like Polynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|elt| '(|Index|) '(% S)
       '("elt(u,i) (also written: u . i) returns the element of u indexed by i."
         "Error: if i is not an index of u."))))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Eltable|
  (progn
    (push '|Eltable| *Categories*)
    (make-instance '|EltableType|)))

\end{chunk}

\subsection{FiniteAggregateAttribute}
\index[cat]{FiniteAggregateAttribute!Category}
\index[cat]{Category!FiniteAggregateAttribute}
\index[cat]{ATFINAG}
\begin{chunk}{defclass FiniteAggregateAttributeType}
(defclass |FiniteAggregateAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FiniteAggregateAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATFINAG)
   (comment :initform (list
     "The class of all aggregates with a finite number of arguments"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteAggregateAttribute|
  (progn
    (push '|FiniteAggregateAttribute| *Categories*)
    (make-instance '|FiniteAggregateAttributeType|)))

\end{chunk}

\subsection{HyperbolicFunctionCategory}
\index[cat]{HyperbolicFunctionCategory!Category}
\index[cat]{Category!HyperbolicFunctionCategory}
\index[cat]{HYPCAT}
\begin{chunk}{defclass HyperbolicFunctionCategoryType}
(defclass |HyperbolicFunctionCategoryType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "HyperbolicFunctionCategory")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'HYPCAT)
   (comment :initform (list
     "Category for the hyperbolic trigonometric functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|cosh| '(%) '(%)
       '("cosh(x) returns the hyperbolic cosine of x."))
     (make-signature '|coth| '(%) '(%)
       '("coth(x) returns the hyperbolic cotangent of x."))
     (make-signature '|csch| '(%) '(%)
       '("csch(x) returns the hyperbolic cosecant of x."))
     (make-signature '|sech| '(%) '(%)
       '("sech(x) returns the hyperbolic secant of x."))
     (make-signature '|sinh| '(%) '(%)
       '("sinh(x) returns the hyperbolic sine of x."))
     (make-signature '|tanh| '(%) '(%)
       '("tanh(x) returns the hyperbolic tangent of x."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |HyperbolicFunctionCategory|
  (progn
    (push '|HyperbolicFunctionCategory| *Categories*)
    (make-instance '|HyperbolicFunctionCategoryType|)))

\end{chunk}

\subsection{InnerEvalable}
\index[cat]{InnerEvalable!Category}
\index[cat]{Category!InnerEvalable}
\index[cat]{IEVALAB}
\begin{chunk}{defclass InnerEvalableType}
(defclass |InnerEvalableType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InnerEvalable")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'IEVALAB)
   (comment :initform (list
     "This category provides eval operations."
     "A domain may belong to this category if it is possible to make"
     "'evaluation' substitutions.  The difference between this"
     "and Evalable is that the operations in this category"
     "specify the substitution as a pair of arguments rather than as"
     "an equation."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|eval| '(%) '(% A B)
       '("eval(f, x, v) replaces x by v in f."))
     (make-signature '|eval| '(%) '(% (|List| A) (|List| B))
       '("eval(f, [x1,...,xn], [v1,...,vn]) replaces xi by vi in f."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerEvalable|
  (progn
    (push '|InnerEvalable| *Categories*)
    (make-instance '|InnerEvalableType|)))

\end{chunk}

\subsection{JacobiIdentityAttribute}
\index[cat]{JacobiIdentityAttribute!Category}
\index[cat]{Category!JacobiIdentityAttribute}
\index[cat]{ATJACID}
\begin{chunk}{defclass JacobiIdentityAttributeType}
(defclass |JacobiIdentityAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "JacobiIdentityAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATJACID)
   (comment :initform (list
     "JacobiIdentity means that [x,[y,z]]+[y,[z,x]]+[z,[x,y]] = 0 holds."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |JacobiIdentityAttribute|
  (progn
    (push '|JacobiIdentityAttribute| *Categories*)
    (make-instance '|JacobiIdentityAttributeType|)))

\end{chunk}

\subsection{LazyRepresentationAttribute}
\index[cat]{LazyRepresentationAttribute!Category}
\index[cat]{Category!LazyRepresentationAttribute}
\index[cat]{ATLR}
\begin{chunk}{defclass LazyRepresentationAttributeType}
(defclass |LazyRepresentationAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LazyRepresentationAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATLR)
   (comment :initform (list
     "The class of all domains which have a lazy representation"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LazyRepresentationAttribute|
  (progn
    (push '|LazyRepresentationAttribute| *Categories*)
    (make-instance '|LazyRepresentationAttributeType|)))

\end{chunk}

\subsection{LeftUnitaryAttribute}
\index[cat]{LeftUnitaryAttribute!Category}
\index[cat]{Category!LeftUnitaryAttribute}
\index[cat]{ATLUNIT}
\begin{chunk}{defclass LeftUnitaryAttributeType}
(defclass |LeftUnitaryAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LeftUnitaryAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATLUNIT)
   (comment :initform (list
     "LeftUnitary is true if 1 * x = x for all x."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LeftUnitaryAttribute|
  (progn
    (push '|LeftUnitaryAttribute| *Categories*)
    (make-instance '|LeftUnitaryAttributeType|)))

\end{chunk}

\subsection{ModularAlgebraicGcdOperations}
\index[cat]{ModularAlgebraicGcdOperations!Category}
\index[cat]{Category!ModularAlgebraicGcdOperations}
\index[cat]{MAGCDOC}
\begin{chunk}{defclass ModularAlgebraicGcdOperationsType}
(defclass |ModularAlgebraicGcdOperationsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ModularAlgebraicGcdOperations")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'MAGCDOC)
   (comment :initform (list
     "This category specifies operations needed by"
     "ModularAlgebraicGcd package.  Since we have multiple"
     "implementations we specify interface here and put"
     "implementations in separate packages.  Most operations"
     "are done using special purpose abstract representation."
     "Apropriate types are passesd as parametes: MPT is type"
     "of modular polynomials in one variable with coefficients"
     "in some algebraic extension.  MD is type of modulus."
     "Final results are converted to packed representation,"
     "with coefficients (from prime field) stored in one"
     "array and exponents (in main variable and in auxilary"
     "variables representing generators of algebrac extension)"
     "stored in parallel array."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|pseudoRem| 'MPT '(MPT MPT MD)
       '("pseudoRem(x, y, m) computes pseudoremainder of x by y"
         "modulo m."))
     (make-signature '|canonicalIfCan| '(|Union| MPT "failed") '(MPT MD)
       '("canonicalIfCan(x, m) tries to divide x by its leading"
         "coefficient modulo m."))
     (make-signature '|packModulus| '(|Union| MD "failed")
                                    '((|List| MP) (|List| |Symbol|) |Integer|)
       '("packModulus(lp, ls, p) converts lp, ls and prime p which"
         "together describe algebraic extension to packed"
         "representation."))
     (make-signature '|MPtoMPT| '(MPT) '(MP |Symbol| (|List| |Symbol|) MD)
       '("MPtoMPT(p, s, ls, m) coverts p to packed represntation."))
     (make-signature '|zero?| '(|Boolean|) '(MPT)
       '("zero?(x) checks if x is zero."))
     (make-signature '|degree| '(|Integer|) '(MPT)
       '("degree(x) gives degree of x."))
     (make-signature '|packExps| '(|SortedExponentVector|) '(|Integer| |Integer| MD)
       '("packExps(d, s, m) produces vector of exponents up"
         "to degree d.  s is size (degree) of algebraic extension."
         "Use together with repack1."))
     (make-signature '|repacke1| '(|Void|) '(MPT PA |Integer| MD)
       '("repack1(x, a, d, m) stores coefficients of x in a."
         "d is degree of x.  Corresponding exponents are given"
         "by packExps."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ModularAlgebraicGcdOperations|
  (progn
    (push '|ModularAlgebraicGcdOperations| *Categories*)
    (make-instance '|ModularAlgebraicGcdOperationsType|)))

\end{chunk}

\subsection{MultiplicativeValuationAttribute}
\index[cat]{MultiplicativeValuationAttribute!Category}
\index[cat]{Category!MultiplicativeValuationAttribute}
\index[cat]{ATMULVA}
\begin{chunk}{defclass MultiplicativeValuationAttributeType}
(defclass |MultiplicativeValuationAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MultiplicativeValuationAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATMULVA)
   (comment :initform (list
     "The class of all euclidean domains such that"
     "euclideanSize(a*b)=euclideanSize(a)*euclideanSize(b)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MultiplicativeValuationAttribute|
  (progn
    (push '|MultiplicativeValuationAttribute| *Categories*)
    (make-instance '|MultiplicativeValuationAttributeType|)))

\end{chunk}

\subsection{NoZeroDivisorsAttribute}
\index[cat]{NoZeroDivisorsAttribute!Category}
\index[cat]{Category!NoZeroDivisorsAttribute}
\index[cat]{ATNZDIV}
\begin{chunk}{defclass NoZeroDivisorsAttributeType}
(defclass |NoZeroDivisorsAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NoZeroDivisorsAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATNZDIV)
   (comment :initform (list
     "The class of all semirings such that x * y ~= 0 implies"
     "both x and y are non-zero."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NoZeroDivisorsAttribute|
  (progn
    (push '|NoZeroDivisorsAttribute| *Categories*)
    (make-instance '|NoZeroDivisorsAttributeType|)))

\end{chunk}

\subsection{NotherianAttribute}
\index[cat]{NotherianAttribute!Category}
\index[cat]{Category!NotherianAttribute}
\index[cat]{ATNOTHR}
\begin{chunk}{defclass NotherianAttributeType}
(defclass |NotherianAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NotherianAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATNOTHR)
   (comment :initform (list
     "Notherian is true if all of its ideals are finitely generated."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NotherianAttribute|
  (progn
    (push '|NotherianAttribute| *Categories*)
    (make-instance '|NotherianAttributeType|)))

\end{chunk}

\subsection{NullSquareAttribute}
\index[cat]{NullSquareAttribute!Category}
\index[cat]{Category!NullSquareAttribute}
\index[cat]{ATNULSQ}
\begin{chunk}{defclass NullSquareAttributeType}
(defclass |NullSquareAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NullSquareAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATNULSQ)
   (comment :initform (list
     "NullSquare means that [x,x] = 0 holds. See LieAlgebra."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NullSquareAttribute|
  (progn
    (push '|NullSquareAttribute| *Categories*)
    (make-instance '|NullSquareAttributeType|)))

\end{chunk}

\subsection{OpenMath}
\index[cat]{OpenMath!Category}
\index[cat]{Category!OpenMath}
\index[cat]{OM}
\begin{chunk}{defclass OpenMathType}
(defclass |OpenMathType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "OpenMath")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'OM)
   (comment :initform (list
     "OpenMath provides operations for exporting an object"
     "in OpenMath format."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|OMwrite| '(|String|) '(%)
       '("OMwrite(u) returns the OpenMath XML encoding of u as a"
         "complete OpenMath object."))
     (make-signature '|OMwrite| '(|String|) '(% |Boolean|)
       '("OMwrite(u, true) returns the OpenMath XML encoding of u"
         "as a complete OpenMath object; OMwrite(u, false) returns the"
         "OpenMath XML encoding of u as an OpenMath fragment."))
     (make-signature '|OMwrite| '(|Void|) '(|OpenMathDevice| %)
       '("OMwrite(dev, u) writes the OpenMath form of u to the"
         "OpenMath device dev as a complete OpenMath object."))
     (make-signature '|OMwrite| '(|Void|) '(|OpenMathDevice| % |Boolean|)
       '("OMwrite(dev, u, true) writes the OpenMath form of u to"
         "the OpenMath device dev as a complete OpenMath object;"
         "OMwrite(dev, u, false) writes the object as an OpenMath fragment."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OpenMath|
  (progn
    (push '|OpenMath| *Categories*)
    (make-instance '|OpenMathType|)))

\end{chunk}

\subsection{PartialTranscendentalFunctions}
\index[cat]{PartialTranscendentalFunctions!Category}
\index[cat]{Category!PartialTranscendentalFunctions}
\index[cat]{PTRANFN}
\begin{chunk}{defclass PartialTranscendentalFunctionsType}
(defclass |PartialTranscendentalFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PartialTranscendentalFunctions")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'PTRANFN)
   (comment :initform (list
     "A package which provides partial transcendental"
     "functions, for example, functions which return an answer or 'failed'"
     "This is the description of any package which provides partial"
     "functions on a domain belonging to TranscendentalFunctionCategory."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|nthRootIfCan| '(|Union| K "failed") '(K NNI)
       '("nthRootIfCan(z,n) returns the nth root of z if possible,"
         "and \"failed\" otherwise."))
     (make-signature '|expIfCan| '(|Union| K "failed") '(K)
       '("expIfCan(z) returns exp(z) if possible, and \"failed\" otherwise."))
     (make-signature '|logIfCan| '(|Union| K "failed") '(K)
       '("logIfCan(z) returns log(z) if possible, and \"failed\" otherwise."))
     (make-signature '|sinIfCan| '(|Union| K "failed") '(K)
       '("sinIfCan(z) returns sin(z) if possible, and \"failed\" otherwise."))
     (make-signature '|cosIfCan| '(|Union| K "failed") '(K)
       '("cosIfCan(z) returns cos(z) if possible, and \"failed\" otherwise."))
     (make-signature '|tanIfCan| '(|Union| K "failed") '(K)
       '("tanIfCan(z) returns tan(z) if possible, and \"failed\" otherwise."))
     (make-signature '|cotIfCan| '(|Union| K "failed") '(K)
       '("cotIfCan(z) returns cot(z) if possible, and \"failed\" otherwise."))
     (make-signature '|secIfCan| '(|Union| K "failed") '(K)
       '("secIfCan(z) returns sec(z) if possible, and \"failed\" otherwise."))
     (make-signature '|cscIfCan| '(|Union| K "failed") '(K)
       '("cscIfCan(z) returns csc(z) if possible, and \"failed\" otherwise."))
     (make-signature '|asinIfCan| '(|Union| K "failed") '(K)
       '("asinIfCan(z) returns asin(z) if possible, and \"failed\" otherwise."))
     (make-signature '|acosIfCan| '(|Union| K "failed") '(K)
       '("acosIfCan(z) returns acos(z) if possible, and \"failed\" otherwise."))
     (make-signature '|atanIfCan| '(|Union| K "failed") '(K)
       '("atanIfCan(z) returns atan(z) if possible, and \"failed\" otherwise."))
     (make-signature '|acotIfCan| '(|Union| K "failed") '(K)
       '("acotIfCan(z) returns acot(z) if possible, and \"failed\" otherwise."))
     (make-signature '|asecIfCan| '(|Union| K "failed") '(K)
       '("asecIfCan(z) returns asec(z) if possible, and \"failed\" otherwise."))
     (make-signature '|acscIfCan| '(|Union| K "failed") '(K)
       '("acscIfCan(z) returns acsc(z) if possible, and \"failed\" otherwise."))
     (make-signature '|sinhIfCan| '(|Union| K "failed") '(K)
       '("sinhIfCan(z) returns sinh(z) if possible, and \"failed\" otherwise."))
     (make-signature '|coshIfCan| '(|Union| K "failed") '(K)
       '("coshIfCan(z) returns cosh(z) if possible, and \"failed\" otherwise."))
     (make-signature '|tanhIfCan| '(|Union| K "failed") '(K)
       '("tanhIfCan(z) returns tanh(z) if possible, and \"failed\" otherwise."))
     (make-signature '|cothIfCan| '(|Union| K "failed") '(K)
       '("cothIfCan(z) returns coth(z) if possible, and \"failed\" otherwise."))
     (make-signature '|sechIfCan| '(|Union| K "failed") '(K)
       '("sechIfCan(z) returns sech(z) if possible, and \"failed\" otherwise."))
     (make-signature '|cschIfCan| '(|Union| K "failed") '(K)
       '("cschIfCan(z) returns csch(z) if possible, and \"failed\" otherwise."))
     (make-signature '|asinhIfCan| '(|Union| K "failed") '(K)
       '("asinhIfCan(z) returns asinh(z) if possible, and \"failed\" otherwise."))
     (make-signature '|acoshIfCan| '(|Union| K "failed") '(K)
       '("acoshIfCan(z) returns acosh(z) if possible, and \"failed\" otherwise."))
     (make-signature '|atanhIfCan| '(|Union| K "failed") '(K)
       '("atanhIfCan(z) returns atanh(z) if possible, and \"failed\" otherwise."))
     (make-signature '|acothIfCan| '(|Union| K "failed") '(K)
       '("acothIfCan(z) returns acoth(z) if possible, and \"failed\" otherwise."))
     (make-signature '|asechIfCan| '(|Union| K "failed") '(K)
       '("asechIfCan(z) returns asech(z) if possible, and \"failed\" otherwise."))
     (make-signature '|acschIfCan| '(|Union| K "failed") '(K)
       '("acschIfCan(z) returns acsch(z) if possible, and \"failed\" otherwise."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PartialTranscendentalFunctions|
  (progn
    (push '|PartialTranscendentalFunctions| *Categories*)
    (make-instance '|PartialTranscendentalFunctionsType|)))

\end{chunk}

\subsection{PartiallyOrderedSetAttribute}
\index[cat]{PartiallyOrderedSetAttribute!Category}
\index[cat]{Category!PartiallyOrderedSetAttribute}
\index[cat]{ATPOSET}
\begin{chunk}{defclass PartiallyOrderedSetAttributeType}
(defclass |PartiallyOrderedSetAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PartiallyOrderedSetAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATPOSET)
   (comment :initform (list
     "PartiallyOrderedSet is true if a set with < is transitive,"
     "but not(a <b or a = b). It does not imply b < a"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PartiallyOrderedSetAttribute|
  (progn
    (push '|PartiallyOrderedSetAttribute| *Categories*)
    (make-instance '|PartiallyOrderedSetAttributeType|)))

\end{chunk}

\subsection{PrimitiveFunctionCategory}
\index[cat]{PrimitiveFunctionCategory!Category}
\index[cat]{Category!PrimitiveFunctionCategory}
\index[cat]{PRIMCAT}
\begin{chunk}{defclass PrimitiveFunctionCategoryType}
(defclass |PrimitiveFunctionCategoryType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PrimitiveFunctionCategory")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'PRIMCAT)
   (comment :initform (list
     "Category for the functions defined by integrals"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|integral| '(%) '(% |Symbol|)
       '("integral(f, x) returns the formal integral of f dx."))
     (make-signature '|integral| '(%) '(% (|SegmentBinding| %))
       '("integral(f, x = a..b) returns the formal definite integral"
         "of f dx for x between a and b."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PrimitiveFunctionCategory|
  (progn
    (push '|PrimitiveFunctionCategory| *Categories*)
    (make-instance '|PrimitiveFunctionCategoryType|)))

\end{chunk}

\subsection{RadicalCategory}
\index[cat]{RadicalCategory!Category}
\index[cat]{Category!RadicalCategory}
\index[cat]{RADCAT}
\begin{chunk}{defclass RadicalCategoryType}
(defclass |RadicalCategoryType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RadicalCategory")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'RADCAT)
   (comment :initform (list
     "The RadicalCategory is a model for the rational numbers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|sqrt| '(%) '(%)
       '("sqrt(x) returns the square root of x. The branch cut lies along"
         "the negative real axis, continuous with quadrant II."))
     (make-signature '|nthRoot| '(%) '(% |Integer|)
       '("nthRoot(x,n) returns the nth root of x."))
     (make-signature '|**| '(%) '(% (|Fraction| |Integer|))
       '("x ** y is the rational exponentiation of x by the power y.") () t)
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RadicalCategory|
  (progn
    (push '|RadicalCategory| *Categories*)
    (make-instance '|RadicalCategoryType|)))

\end{chunk}

\subsection{RetractableTo}
\index[cat]{RetractableTo!Category}
\index[cat]{Category!RetractableTo}
\index[cat]{RETRACT}
\begin{chunk}{defclass RetractableToType}
(defclass |RetractableToType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RetractableTo")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'RETRACT)
   (comment :initform (list
     "A is retractable to B means that some elements if A can be converted"
     "into elements of B and any element of B can be converted into an"
     "element of A."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|coerce| '(%) '(S)
       '("coerce(a) transforms a into an element of %."))
     (make-signature '|retractIfCan| '(|Union| S "failed") '(%)
       '("retractIfCan(a) transforms a into an element of S if possible."
         "Returns \"failed\" if a cannot be made into an element of S."))
     (make-signature '|retract| '(S) '(%)
       '("retract(a) transforms a into an element of S if possible."
         "Error: if a cannot be made into an element of S."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RetractableTo|
  (progn
    (push '|RetractableTo| *Categories*)
    (make-instance '|RetractableToType|)))

\end{chunk}

\subsection{RightUnitaryAttribute}
\index[cat]{RightUnitaryAttribute!Category}
\index[cat]{Category!RightUnitaryAttribute}
\index[cat]{ATRUNIT}
\begin{chunk}{defclass RightUnitaryAttributeType}
(defclass |RightUnitaryAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RightUnitaryAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATRUNIT)
   (comment :initform (list
     "RightUnitary is true if x * 1 = x for all x."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RightUnitaryAttribute|
  (progn
    (push '|RightUnitaryAttribute| *Categories*)
    (make-instance '|RightUnitaryAttributeType|)))

\end{chunk}

\subsection{ShallowlyMutableAttribute}
\index[cat]{ShallowlyMutableAttribute!Category}
\index[cat]{Category!ShallowlyMutableAttribute}
\index[cat]{ATSHMUT}
\begin{chunk}{defclass ShallowlyMutableAttributeType}
(defclass |ShallowlyMutableAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ShallowlyMutableAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATSHMUT)
   (comment :initform (list
     "The class of all domains which have immediate components that"
     "are updateable in place (mutable). The properties of any component"
     "domain are irrevelant to the ShallowlyMutableAttribute."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ShallowlyMutableAttribute|
  (progn
    (push '|ShallowlyMutableAttribute| *Categories*)
    (make-instance '|ShallowlyMutableAttributeType|)))

\end{chunk}

\subsection{SpecialFunctionCategory}
\index[cat]{SpecialFunctionCategory!Category}
\index[cat]{Category!SpecialFunctionCategory}
\index[cat]{SPFCAT}
\begin{chunk}{defclass SpecialFunctionCategoryType}
(defclass |SpecialFunctionCategoryType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SpecialFunctionCategory")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'SPFCAT)
   (comment :initform (list
     "Category for the other special functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|abs| '(%) '(%)
       '("abs(x) returns the absolute value of x."))
     (make-signature '|Gamma| '(%) '(%)
       '("Gamma(x) is the Euler Gamma function."))
     (make-signature '|Beta| '(%) '(% %)
       '("Beta(x,y) is Gamma(x) * Gamma(y)/Gamma(x+y)."))
     (make-signature '|digamma| '(%) '(%)
       '("digamma(x) is the logarithmic derivative of Gamma(x)"
         "(often written psi(x) in the literature)."))
     (make-signature '|polygamma| '(%) '(% %)
       '("polygamma(k,x) is the \spad{k-th} derivative of digamma(x),"
         "(often written psi(k,x) in the literature)."))
     (make-signature '|Gamma| '(%) '(% %)
       '("Gamma(a,x) is the incomplete Gamma function."))
     (make-signature '|besselJ| '(%) '(% %)
       '("besselJ(v,z) is the Bessel function of the first kind."))
     (make-signature '|besselY| '(%) '(% %)
       '("besselY(v,z) is the Bessel function of the second kind."))
     (make-signature '|besselI| '(%) '(% %)
       '("besselI(v,z) is the modified Bessel function of the first kind."))
     (make-signature '|besselK| '(%) '(% %)
       '("besselK(v,z) is the modified Bessel function of the second kind."))
     (make-signature '|airyAi| '(%) '(%)
       '("airyAi(x) is the Airy function Ai(x)."))
     (make-signature '|airyBi| '(%) '(%)
       '("airyBi(x) is the Airy function Bi(x)."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SpecialFunctionCategory|
  (progn
    (push '|SpecialFunctionCategory| *Categories*)
    (make-instance '|SpecialFunctionCategoryType|)))

\end{chunk}

\subsection{TrigonometricFunctionCategory}
\index[cat]{TrigonometricFunctionCategory!Category}
\index[cat]{Category!TrigonometricFunctionCategory}
\index[cat]{TRIGCAT}
\begin{chunk}{defclass TrigonometricFunctionCategoryType}
(defclass |TrigonometricFunctionCategoryType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TrigonometricFunctionCategory")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'TRIGCAT)
   (comment :initform (list
     "Category for the trigonometric functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|cos| '(%) '(%)
       '("cos(x) returns the cosine of x."))
     (make-signature '|cot| '(%) '(%)
       '("cot(x) returns the cotangent of x."))
     (make-signature '|csc| '(%) '(%)
       '("csc(x) returns the cosecant of x."))
     (make-signature '|sec| '(%) '(%)
       '("sec(x) returns the secant of x."))
     (make-signature '|sin| '(%) '(%)
       '("sin(x) returns the sine of x."))
     (make-signature '|tan| '(%) '(%)
       '("tan(x) returns the tangent of x."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TrigonometricFunctionCategory|
  (progn
    (push '|TrigonometricFunctionCategory| *Categories*)
    (make-instance '|TrigonometricFunctionCategoryType|)))

\end{chunk}

\subsection{Type}
\index[cat]{Type!Category}
\index[cat]{Category!Type}
\index[cat]{TYPE}
\begin{chunk}{defclass TypeType}
(defclass |TypeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "Type")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'TYPE)
   (comment :initform (list
     "The fundamental Type."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Type|
  (progn
    (push '|Type| *Categories*)
    (make-instance '|TypeType|)))

\end{chunk}

\subsection{UnitsKnownAttribute}
\index[cat]{UnitsKnownAttribute!Category}
\index[cat]{Category!UnitsKnownAttribute}
\index[cat]{ATUNIKN}
\begin{chunk}{defclass UnitsKnownAttributeType}
(defclass |UnitsKnownAttributeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UnitsKnownAttribute")
   (marker :initform 'category)
   (level :initform 1)
   (abbreviation :initform 'ATUNIKN)
   (comment :initform (list
     "The class of all monoids (multiplicative semigroups with a 1)"
     "such that the operation recop can only return 'failed'"
     "if its argument is not a unit."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnitsKnownAttribute|
  (progn
    (push '|UnitsKnownAttribute| *Categories*)
    (make-instance '|UnitsKnownAttributeType|)))

\end{chunk}

\section{Level 2}

\begin{chunk}{defvar level2}
(defvar level2
 '(|Aggregate| |CombinatorialOpsCategory| |EltableAggregate| |Evalable|
   |FortranProgramCategory| |FullyRetractableTo| |Logic| |Patternable| 
   |PlottablePlaneCurveCategory| |PlottableSpaceCurveCategory| |RealConstant|
   |SegmentCategory| |SetCategory| |TranscendentalFunctionCategory|))

\end{chunk}

\subsection{Aggregate}
\index[cat]{Aggregate!Category}
\index[cat]{Category!Aggregate}
\index[cat]{AGG}
\begin{chunk}{defclass AggregateType}
(defclass |AggregateType| (|TypeType|)
  ((parents :initform '(|Type|))
   (name :initform "Aggregate")
   (marker :initform 'category)
   (level :initform 2)
   (abbreviation :initform 'AGG)
   (comment :initform (list
     "The notion of aggregate serves to model any data structure aggregate,"
     "designating any collection of objects, with heterogenous or homogeneous"
     "members, with a finite or infinite number of members, explicitly or"
     "implicitly represented. An aggregate can in principle represent"
     "everything from a string of characters to abstract sets such"
     "as 'the set of x satisfying relation r(x)'"
     "An attribute 'finiteAggregate' is used to assert that a domain"
     "has a finite number of elements."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|eq?| '(|Boolean|) '(% %)
       '("eq?(u,v) tests if u and v are same objects."))
     (make-signature '|copy| '(%) '(%)
       '("copy(u) returns a top-level (non-recursive) copy of u."
         "Note that for collections, copy(u) == [x for x in u]."))
     (make-signature '|empty| '(%) ()
       '("empty()$D creates an aggregate of type D with 0 elements."
         "Note that The $D can be dropped if understood by context,"
         "for example u: D := empty()."))
     (make-signature '|empty?| '(|Boolean|) '(%)
       '("empty?(u) tests if u has 0 elements."))
     (make-signature '|less?| '(|Boolean|) '(% |NonNegativeInteger|)
       '("less?(u,n) tests if u has less than n elements."))
     (make-signature '|more?| '(|Boolean|) '(% |NonNegativeInteger|)
       '("more?(u,n) tests if u has greater than n elements."))
     (make-signature '|size?| '(|Boolean|) '(% |NonNegativeInteger|)
       '("size?(u,n) tests if u has exactly n elements."))
     (make-signature '|sample| '(%) '(|constant|)
       '("sample yields a value of type %"))))
   (haslist :initform (list
     (make-haslist (list
       (make-hasclause '|%| '|finiteAggregate|
         (list
           (make-signature '|#| '(|NonNegativeInteger|) '(%)
             '("# u returns the number of items in u.") () t)))))))
   (addlist :initform nil)))

(defvar |Aggregate|
  (progn
    (push '|Aggregate| *Categories*)
    (make-instance '|AggregateType|)))

\end{chunk}

\subsection{CombinatorialOpsCategory}
\index[cat]{CombinatorialOpsCategory!Category}
\index[cat]{Category!CombinatorialOpsCategory}
\index[cat]{COMBOPC}
\begin{chunk}{defclass CombinatorialOpsCategoryType}
(defclass |CombinatorialOpsCategoryType| (|CombinatorialFunctionCategoryType|)
  ((parents :initform '(|CombinatorialFunctionCategory|))
   (name :initform "CombinatorialOpsCategory")
   (marker :initform 'category)
   (level :initform 2)
   (abbreviation :initform 'COMBOPC)
   (comment :initform (list
     "CombinatorialOpsCategory is the category obtaining by adjoining"
     "summations and products to the usual combinatorial operations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|factorials| '(%) '(%)
       '("factorials(f) rewrites the permutations and binomials in f"
         "in terms of factorials"))
     (make-signature '|factorials| '(%) '(% |Symbol|)
       '("factorials(f, x) rewrites the permutations and binomials in f"
         "involving x in terms of factorials"))
     (make-signature '|summation| '(%) '(% |Symbol|)
       '("summation(f(n), n) returns the formal sum S(n) which verifies"
         "S(n+1) - S(n) = f(n)"))
     (make-signature '|summation| '(%) '(% (|SegmentBinding| %))
       '("summation(f(n), n = a..b) returns f(a) + ... + f(b) as a"
         "formal sum"))
     (make-signature '|product| '(%) '(% |Symbol|)
       '("product(f(n), n) returns the formal product P(n) which verifies"
         "P(n+1)/P(n) = f(n)"))
     (make-signature '|product| '(%) '(% (|SegmentBinding| %))
       '("product(f(n), n = a..b) returns f(a) * ... * f(b) as a"
         "formal product"))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CombinatorialOpsCategory|
  (progn
    (push '|CombinatorialOpsCategory| *Categories*)
    (make-instance '|CombinatorialOpsCategoryType|)))

\end{chunk}

\subsection{EltableAggregate}
\index[cat]{EltableAggregate!Category}
\index[cat]{Category!EltableAggregate}
\index[cat]{ELTAGG}
\begin{chunk}{defclass EltableAggregateType}
(defclass |EltableAggregateType| (|EltableType|)
  ((parents :initform '(|Eltable|))
   (name :initform "EltableAggregate")
   (marker :initform 'category)
   (level :initform 2)
   (abbreviation :initform 'ELTAGG)
   (comment :initform (list
     "An eltable aggregate is one which can be viewed as a function."
     "For example, the list [1,7,4] can applied to 0,1, and 2 respectively"
     "will return the integers 1, 7, and 4; thus this list may be viewed as"
     "mapping 0 to 1, 1 to 7 and 2 to 4. In general, an aggregate"
     "can map members of a domain Dom to an image domain Im."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|elt| '(|Im|) '(% |Dom| |Im|)
       '("elt(u, x, y) applies u to x if x is in the domain of u,"
         "and returns y otherwise."
         "For example, if u is a polynomial in \axiom{x} over the rationals,"
         "elt(u,n,0) may define the coefficient of x"
         "to the power n, returning 0 when n is out of range."))
     (make-signature '|qelt| '(|Im|) '(% |Dom|)
       '("qelt(u, x) applies u to x without checking whether"
         "x is in the domain of u. If x is not"
         "in the domain of u a memory-access violation may occur."
         "If a check on whether x is in the domain of u"
         "is required, use the function elt."))
   ))
   (haslist :initform (list
     (make-haslist (list
       (make-hasclause '|%| '|shallowlyMutable|
         (list
           (make-signature '|setelt| '(|Im|) '(% |Dom| |Im|)
             '("setelt(u,x,y) sets the image of x to be y under u,"
               "assuming x is in the domain of u."
               "Error: if x is not in the domain of u."))
           (make-signature '|qsetelt_!| '(|Im|) '(% |Dom| |Im|)
             '("qsetelt!(u,x,y) sets the image of x to be y"
               "under u, without checking that x is in"
               "the domain of u."
               "If such a check is required use the function setelt."))))))))
   (addlist :initform nil)))

(defvar |EltableAggregate|
  (progn
    (push '|EltableAggregate| *Categories*)
    (make-instance '|EltableAggregateType|)))

\end{chunk}

\subsection{Evalable}
\index[cat]{Evalable!Category}
\index[cat]{Category!Evalable}
\index[cat]{EVALAB}
\begin{chunk}{defclass EvalableType}
(defclass |EvalableType| (|InnerEvalableType|)
  ((parents :initform '(|InnerEvalable|))
   (name :initform "Evalable")
   (marker :initform 'category)
   (level :initform 2)
   (abbreviation :initform 'EVALAB)
   (comment :initform (list
     "This category provides eval operations."
     "A domain may belong to this category if it is possible to make"
     "'evaluation' substitutions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|eval| '(%) '(% (|Equation| R))
       '("eval(f,x = v) replaces x by v in f."))
     (make-signature '|eval| '(%) '($ (List (Equation R)))
       '("eval(f, [x1 = v1,...,xn = vn]) replaces xi by vi in f."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Evalable|
  (progn
    (push '|Evalable| *Categories*)
    (make-instance '|EvalableType|)))

\end{chunk}

\subsection{FortranProgramCategory}
\index[cat]{FortranProgramCategory!Category}
\index[cat]{Category!FortranProgramCategory}
\index[cat]{FORTCAT}
\begin{chunk}{defclass FortranProgramCategoryType}
(defclass |FortranProgramCategoryType| (|TypeType| |CoercibleToType|)
  ((parents :initform '(|Type| |CoercibleTo|))
   (name :initform "FortranProgramCategory")
   (marker :initform 'category)
   (level :initform 2)
   (abbreviation :initform 'FORTCAT)
   (comment :initform (list
     "FortranProgramCategory provides various models of FORTRAN subprograms."
     "These can be transformed into actual FORTRAN code."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|outputAsFortran| '(|Void|) '(%)
       '("outputAsFortran(u) translates u into a legal FORTRAN subprogram."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranProgramCategory|
  (progn
    (push '|FortranProgramCategory| *Categories*)
    (make-instance '|FortranProgramCategoryType|)))

\end{chunk}

\subsection{FullyRetractableTo}
\index[cat]{FullyRetractableTo!Category}
\index[cat]{Category!FullyRetractableTo}
\index[cat]{FRETRCT}
\begin{chunk}{defclass FullyRetractableToType}
(defclass |FullyRetractableToType| (|RetractableToType|)
  ((parents :initform '(|RetractableTo|))
   (name :initform "FullyRetractableTo")
   (marker :initform 'category)
   (level :initform 2)
   (abbreviation :initform 'FRETRCT)
   (comment :initform (list
     "A is fully retractable to B means that A is retractable to B and"
     "if B is retractable to the integers or rational numbers then so is A."
     "In particular, what we are asserting is that there are no integers"
     "(rationals) in A which don't retract into B."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FullyRetractableTo|
  (progn
    (push '|FullyRetractableTo| *Categories*)
    (make-instance '|FullyRetractableToType|)))

\end{chunk}

\subsection{Logic}
\index[cat]{Logic!Category}
\index[cat]{Category!Logic}
\index[cat]{LOGIC}
\begin{chunk}{defclass LogicType}
(defclass |LogicType| (|BasicTypeType|)
  ((parents :initform '(|BasicType|))
   (name :initform "Logic")
   (marker :initform 'category)
   (level :initform 2)
   (abbreviation :initform 'LOGIC)
   (comment :initform (list
     "Logic provides the basic operations for lattices,"
     "for example, boolean algebra."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|-| '(%) '(%)
       '("~(x) returns the logical complement of x.") () t)
     (make-signature '|/\\| '(%) '(% %)
       '("/\\ returns the logical `meet', for example, `and'.") () t)
     (make-signature '|\\/| '(%) '(% %)
       '("\\/ returns the logical `join', for example, `or'.") () t)
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Logic|
  (progn
    (push '|Logic| *Categories*)
    (make-instance '|LogicType|)))

\end{chunk}

\subsection{Patternable}
\index[cat]{Patternable!Category}
\index[cat]{Category!Patternable}
\index[cat]{PATAB}
\begin{chunk}{defclass PatternableType}
(defclass |PatternableType| (|ConvertibleToType|)
  ((parents :initform '(|ConvertibleTo|))
   (name :initform "Patternable")
   (marker :initform 'category)
   (level :initform 2)
   (abbreviation :initform 'PATAB)
   (comment :initform (list
     "Category of sets that can be converted to useful patterns"
     "An object S is Patternable over an object R if S can"
     "lift the conversions from R into Pattern(Integer) and"
     "Pattern(Float) to itself"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Patternable|
  (progn
    (push '|Patternable| *Categories*)
    (make-instance '|PatternableType|)))

\end{chunk}

\subsection{PlottablePlaneCurveCategory}
\index[cat]{PlottablePlaneCurveCategory!Category}
\index[cat]{Category!PlottablePlaneCurveCategory}
\index[cat]{PPCURVE}
\begin{chunk}{defclass PlottablePlaneCurveCategoryType}
(defclass |PlottablePlaneCurveCategoryType| (|CoercibleToType|)
  ((parents :initform '(|CoercibleTo|))
   (name :initform "PlottablePlaneCurveCategory")
   (marker :initform 'category)
   (level :initform 2)
   (abbreviation :initform 'PPCURVE)
   (comment :initform (list
     "PlotablePlaneCurveCategory is the category of curves in the plane"
     "which may be plotted via the graphics facilities. Functions are"
     "provided for obtaining lists of lists of points, representing the"
     "branches of the curve, and for determining the ranges of the"
     "x-coordinates and y-coordinates of the points on the curve."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|listBranches| '(L L (POINT)) '(%)
       '("listBranches(c) returns a list of lists of points, representing the"
         "branches of the curve c."))
     (make-signature '|xRange| '((SEG SF)) '(%)
       '("xRange(c) returns the range of the x-coordinates of the points"
         "on the curve c."))
     (make-signature '|yRange| '((SEG SF)) '(%)
       '("yRange(c) returns the range of the y-coordinates of the points"
         "on the curve c."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PlottablePlaneCurveCategory|
  (progn
    (push '|PlottablePlaneCurveCategory| *Categories*)
    (make-instance '|PlottablePlaneCurveCategoryType|)))

\end{chunk}

\subsection{PlottableSpaceCurveCategory}
\index[cat]{PlottableSpaceCurveCategory!Category}
\index[cat]{Category!PlottableSpaceCurveCategory}
\index[cat]{PSCURVE}
\begin{chunk}{defclass PlottableSpaceCurveCategoryType}
(defclass |PlottableSpaceCurveCategoryType| (|CoercibleToType|)
  ((parents :initform '(|CoercibleTo|))
   (name :initform "PlottableSpaceCurveCategory")
   (marker :initform 'category)
   (level :initform 2)
   (abbreviation :initform 'PSCURVE)
   (comment :initform (list
     "PlottableSpaceCurveCategory is the category of curves in"
     "3-space which may be plotted via the graphics facilities.  Functions are"
     "provided for obtaining lists of lists of points, representing the"
     "branches of the curve, and for determining the ranges of the"
     "x-, y-, and z-coordinates of the points on the curve."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|listBranches| '(L L POINT) '(%)
       '("listBranches(c) returns a list of lists of points, representing the"
         "branches of the curve c."))
     (make-signature '|xRange| '((SEG SF)) '(%)
       '("xRange(c) returns the range of the x-coordinates of the points"
         "on the curve c."))
     (make-signature '|yRange| '((SEG SF)) '(%)
       '("yRange(c) returns the range of the y-coordinates of the points"
         "on the curve c."))
     (make-signature '|zRange| '((SEG SF)) '(%)
       '("zRange(c) returns the range of the z-coordinates of the points"
         "on the curve c."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PlottableSpaceCurveCategory|
  (progn
    (push '|PlottableSpaceCurveCategory| *Categories*)
    (make-instance '|PlottableSpaceCurveCategoryType|)))

\end{chunk}

\subsection{RealConstant}
\index[cat]{RealConstant!Category}
\index[cat]{Category!RealConstant}
\index[cat]{REAL}
\begin{chunk}{defclass RealConstantType}
(defclass |RealConstantType| (|ConvertibleToType|)
  ((parents :initform '(|ConvertibleTo|))
   (name :initform "RealConstant")
   (marker :initform 'category)
   (level :initform 2)
   (abbreviation :initform 'REAL)
   (comment :initform (list
     "The category of real numeric domains, that is, convertible to floats."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RealConstant|
  (progn
    (push '|RealConstant| *Categories*)
    (make-instance '|RealConstantType|)))

\end{chunk}

\subsection{SegmentCategory}
\index[cat]{SegmentCategory!Category}
\index[cat]{Category!SegmentCategory}
\index[cat]{SEGCAT}
\begin{chunk}{defclass SegmentCategoryType}
(defclass |SegmentCategoryType| (|TypeType|)
  ((parents :initform '(|Type|))
   (name :initform "SegmentCategory")
   (marker :initform 'category)
   (level :initform 2)
   (abbreviation :initform 'SEGCAT)
   (comment :initform (list
     "This category provides operations on ranges, or segments"
     "as they are called."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|SEGMENT| '(%) '(S S)
       '("l..h creates a segment with l and h as the endpoints."))
     (make-signature '|BY| '(%) '(% |Integer|)
       '("s by n creates a new segment in which only every"
         "n-th element is used."))
     (make-signature '|lo| '(S) '(%)
       '("lo(s) returns the first endpoint of s."
         "Note that lo(l..h) = l."))
     (make-signature '|hi| '(S) '(%)
       '("hi(s) returns the second endpoint of s."
         "Note that hi(l..h) = h."))
     (make-signature '|low| '(S) '(%)
       '("low(s) returns the first endpoint of s."
         "Note that low(l..h) = l."))
     (make-signature '|high| '(S) '(%)
       '("high(s) returns the second endpoint of s."
         "Note that high(l..h) = h."))
     (make-signature '|incr| '(|Integer|) '(%)
       '("incr(s) returns n, where s is a segment in which every"
         "n-th element is used."
         "Note that incr(l..h by n) = n."))
     (make-signature '|segment| '(%) '(S S)
       '("segment(i,j) is an alternate way to create the segment i..j."))
     (make-signature '|convert| '(%) '(S)
       '("convert(i) creates the segment i..i."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SegmentCategory|
  (progn
    (push '|SegmentCategory| *Categories*)
    (make-instance '|SegmentCategoryType|)))

\end{chunk}

\subsection{SetCategory}
\index[cat]{SetCategory!Category}
\index[cat]{Category!SetCategory}
\index[cat]{SETCAT}
\begin{chunk}{defclass SetCategoryType}
(defclass |SetCategoryType| (|BasicTypeType| |CoercibleToType|)
  ((parents :initform '(|BasicType| |CoercibleTo|))
   (name :initform "SetCategory")
   (marker :initform 'category)
   (level :initform 2)
   (abbreviation :initform 'SETCAT)
   (comment :initform (list
     "SetCategory is the basic category for describing a collection"
     "of elements with = (equality) and coerce to output form."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|hash| '(|SingleInteger|) '(%)
       '("hash(s) calculates a hash code for s."))
     (make-signature '|latex| '(|String|) '(%)
       '("latex(s) returns a LaTeX-printable output representation of s."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SetCategory|
  (progn
    (push '|SetCategory| *Categories*)
    (make-instance '|SetCategoryType|)))

\end{chunk}

\subsection{TranscendentalFunctionCategory}
\index[cat]{TranscendentalFunctionCategory!Category}
\index[cat]{Category!TranscendentalFunctionCategory}
\index[cat]{TRANFUN}
\begin{chunk}{defclass TranscendentalFunctionCategoryType}
(defclass |TranscendentalFunctionCategoryType| (|ArcHyperbolicFunctionCategoryType| 
                                                |ArcTrigonometricFunctionCategoryType|
                                                |ElementaryFunctionCategoryType| 
                                                |HyperbolicFunctionCategoryType|
                                                |TrigonometricFunctionCategoryType|)
  ((parents :initform '(|ArcHyperbolicFunctionCategory| 
                          |ArcTrigonometricFunctionCategory| 
                          |ElementaryFunctionCategory| 
                          |HyperbolicFunctionCategory| 
                          |TrigonometricFunctionCategory|))
   (name :initform "TranscendentalFunctionCategory")
   (marker :initform 'category)
   (level :initform 2)
   (abbreviation :initform 'TRANFUN)
   (comment :initform (list
     "Category for the transcendental elementary functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|pi| '(%) ()
       '("pi() returns the constant pi."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TranscendentalFunctionCategory|
  (progn
    (push '|TranscendentalFunctionCategory| *Categories*)
    (make-instance '|TranscendentalFunctionCategoryType|)))

\end{chunk}

\section{Level 3}

\begin{chunk}{defvar level3}
(defvar level3
 '(|AbelianSemiGroup| |BlowUpMethodCategory| |Comparable| |FileCategory|
   |FileNameCategory| |Finite| |FortranFunctionCategory| |FortranMatrixCategory|
   |FortranMatrixFunctionCategory| |FortranVectorCategory|
   |FortranVectorFunctionCategory| |FullyEvalableOver| |GradedModule|
   |HomogeneousAggregate| |IndexedDirectProductCategory|
   |LiouvillianFunctionCategory| |Monad| |NumericalIntegrationCategory|
   |NumericalOptimizationCategory| |OrderedSet|
   |OrdinaryDifferentialEquationsSolverCategory|
   |PartialDifferentialEquationsSolverCategory| |PatternMatchable|
   |RealRootCharacterizationCategory| |SExpressionCategory|
   |SegmentExpansionCategory| |SemiGroup| |SetCategoryWithDegree| |StepThrough|
   |ThreeSpaceCategory|))

\end{chunk}

\subsection{AbelianSemiGroup}
\index[cat]{AbelianSemiGroup!Category}
\index[cat]{Category!AbelianSemiGroup}
\index[cat]{ABELSG}
\begin{chunk}{defclass AbelianSemiGroupType}
(defclass |AbelianSemiGroupType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "AbelianSemiGroup")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'ABELSG)
   (comment :initform (list
     "The class of all additive (commutative) semigroups, that is,"
     "a set with a commutative and associative operation +."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|+| '(%) '(% %)
       '("x+y computes the sum of x and y.") () t)
     (make-signature '|*| '(%) '(|PositiveInteger| %)
       '("n*x computes the left-multiplication of x by the positive"
         "integer n. This is equivalent to adding x to itself n times.")
       () t)
   )) 
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AbelianSemiGroup|
  (progn
    (push '|AbelianSemiGroup| *Categories*)
    (make-instance '|AbelianSemiGroupType|)))

\end{chunk}

\subsection{BlowUpMethodCategory}
\index[cat]{BlowUpMethodCategory!Category}
\index[cat]{Category!BlowUpMethodCategory}
\index[cat]{BLMETCT}
\begin{chunk}{defclass BlowUpMethodCategoryType}
(defclass |BlowUpMethodCategoryType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "BlowUpMethodCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'BLMETCT)
   (comment :initform nil)
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|coerce| '(%) '((|List| |Integer|)) ())
     (make-signature '|excepCoord| '(|Integer|) '(%) ())
     (make-signature '|chartCoord| '(|Integer|) '(%) ())
     (make-signature '|transCoord| '(|Integer|) '(%) ())
     (make-signature '|createHN| '(%) '(|Integer| |Integer| |Integer|
                                        |Integer| |Integer| |Boolean|
       (|Union| "left" "center" "right" "vertical" "horizontal")) ())
     (make-signature '|ramifMult| '(|Integer|) '(%) ())
     (make-signature '|infClsPt?| '(|Boolean|) '(%) ())
     (make-signature '|quotValuation| '(|Integer|) '(%) ())
     (make-signature '|type| '(%) '((|Union| "left" "center" "right"
                                             "vertical" "horizontal")) ())
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BlowUpMethodCategory|
  (progn
    (push '|BlowUpMethodCategory| *Categories*)
    (make-instance '|BlowUpMethodCategoryType|)))

\end{chunk}

\subsection{Comparable}
\index[cat]{Comparable!Category}
\index[cat]{Category!Comparable}
\index[cat]{COMPAR}
\begin{chunk}{defclass ComparableType}
(defclass |ComparableType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "Comparable")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'COMPAR)
   (comment :initform (list
     "The class of set equipped with possibly unnatural linear order"
     "(needed for technical reasons)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|smaller?| '(|Boolean|) '(% %)
       '("smaller?(x,y) is a strict local total ordering on the elements of the set"))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Comparable|
  (progn
    (push '|Comparable| *Categories*)
    (make-instance '|ComparableType|)))

\end{chunk}

\subsection{FileCategory}
\index[cat]{FileCategory!Category}
\index[cat]{Category!FileCategory}
\index[cat]{FILECAT}
\begin{chunk}{defclass FileCategoryType}
(defclass |FileCategoryType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "FileCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'FILECAT)
   (comment :initform (list
     "This category provides an interface to operate on files in the"
     "computer's file system.  The precise method of naming files"
     "is determined by the Name parameter.  The type of the contents"
     "of the file is determined by S."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|open| '(%) '(|Name|)
       '("open(s) returns the file s open for input."))
     (make-signature '|open| '(%) '(|Name| |IOMode|)
       '("open(s,mode) returns a file s open for operation in the"
         "indicated mode: \"input\" or \"output\"."))
     (make-signature '|reopen!| '(%) '(% |IOMode|)
       '("reopen!(f,mode) returns a file f reopened for operation in the"
         "indicated mode: \"input\" or \"output\"."
         "reopen!(f,\"input\") will reopen the file f for input."))
     (make-signature '|close!| '(%) '(%)
       '("close!(f) returns the file f closed to input and output."))
     (make-signature '|name| '(|Name|) '(%)
       '("name(f) returns the external name of the file f."))
     (make-signature '|iomode| '(|IOMode|) '(%)
       '("iomode(f) returns the status of the file f. The input/output"
         "status of f may be \"input\", \"output\" or \"closed\" mode."))
     (make-signature '|read!| '(S) '(%)
       '("read!(f) extracts a value from file f. The state of f is"
         "modified so a subsequent call to read! will return"
         "the next element."))
     (make-signature '|write!| '(S) '(% S)
       '("write!(f,s) puts the value s into the file f."
         "The state of f is modified so subsequents call to write!"
         "will append one after another."))
     (make-signature '|flush| '(|Void|) '(%)
       '("flush(f) makes sure that buffered data is written out."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FileCategory|
  (progn
    (push '|FileCategory| *Categories*)
    (make-instance '|FileCategoryType|)))

\end{chunk}

\subsection{FileNameCategory}
\index[cat]{FileNameCategory!Category}
\index[cat]{Category!FileNameCategory}
\index[cat]{FNCAT}
\begin{chunk}{defclass FileNameCategoryType}
(defclass |FileNameCategoryType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "FileNameCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'FNCAT)
   (comment :initform (list
     "This category provides an interface to names in the file system."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|coerce| '(|IOMode|) '(%)
       '("iomode(f) returns the status of the file f. The input/output"
         "status of f may be \"input\", \"output\" or \"closed\" mode."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FileNameCategory|
  (progn
    (push '|FileNameCategory| *Categories*)
    (make-instance '|FileNameCategoryType|)))

\end{chunk}

\subsection{Finite}
\index[cat]{Finite!Category}
\index[cat]{Category!Finite}
\index[cat]{FINITE}
\begin{chunk}{defclass FiniteType}
(defclass |FiniteType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "Finite")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'FINITE)
   (comment :initform (list
     "The category of domains composed of a finite set of elements."
     "We include the functions lookup and index" 
     "to give a bijection between the finite set and an initial"
     "segment of positive integers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|size| '(|NonNegativeInteger|) () 
       '("size() returns the number of elements in the set."))
     (make-signature '|index| '(%)  '(|PositiveInteger|)
       '("index(i) takes a positive integer i less than or equal"
         "to size() and"
         "returns the i-th element of the set."
         "This operation establishs a bijection"
         "between the elements of the finite set and 1..size()."))
     (make-signature '|lookup| '(|PositiveInteger|) '(%)
      '("lookup(x) returns a positive integer such that"
        "x = index lookup x."))
     (make-signature '|random| '(%)  '()
       '("random() returns a random element from the set."))
     (make-signature '|enumerate| '(|List %|) '()
       '("enumerate() returns a list of elements of the set")
       '("enumerate()$OrderedVariableList([p,q])"))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Finite|
  (progn
    (push '|Finite| *Categories*)
    (make-instance '|FiniteType|)))

\end{chunk}

\subsection{FortranFunctionCategory}
\index[cat]{FortranFunctionCategory!Category}
\index[cat]{Category!FortranFunctionCategory}
\index[cat]{FORTFN}
\begin{chunk}{defclass FortranFunctionCategoryType}
(defclass |FortranFunctionCategoryType| (|FortranProgramCategoryType|)
  ((parents :initform '(|FortranProgramCategory|))
   (name :initform "FortranFunctionCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'FORTFN)
   (comment :initform (list
     "FortranFunctionCategory is the category of arguments to"
     "NAG Library routines which return (sets of) function values."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|coerce| '(%) '((|List| |FortranCode|))
       '("coerce(e) takes an object from List FortranCode and"
         "uses it as the body of an ASP."))
     (make-signature '|coerce| '(%)  '(|FortranCode|)
       '("coerce(e) takes an object from FortranCode and"
         "uses it as the body of an ASP."))
     (make-signature '|coerce| '(%)
                     '(|Record(localSymbols:SymbolTable,code:List(FortranCode))|)
       '("coerce(e) takes the component of e from"
         "List FortranCode and uses it as the body of the ASP,"
         "making the declarations in the SymbolTable component."))
     (make-signature '|retract| '(%) '((|Expression| |Float|))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) '((|Expression| |Float|))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retract| '(%)  '((|Expression| |Integer|)) 
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) '((|Expression| |Integer|))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retract| '(%) '((|Polynomial| |Float|))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) '((|Polynomial| |Float|))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retract| '(%) '((|Polynomial| |Integer|))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) '((|Polynomial| |Integer|))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retract| '(%) '((|Fraction| (|Polynomial| |Float|)))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed"))
                                     '((|Fraction| (|Polynomial| |Float|)))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retract| '(%) '((|Fraction| (|Polynomial| |Integer|)))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) 
                                     '((|Fraction| (|Polynomial| |Integer|)))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))

   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranFunctionCategory|
  (progn
    (push '|FortranFunctionCategory| *Categories*)
    (make-instance '|FortranFunctionCategoryType|)))

\end{chunk}

\subsection{FortranMatrixCategory}
\index[cat]{FortranMatrixCategory!Category}
\index[cat]{Category!FortranMatrixCategory}
\index[cat]{FMC}
\begin{chunk}{defclass FortranMatrixCategoryType}
(defclass |FortranMatrixCategoryType| (|FortranProgramCategoryType|)
  ((parents :initform '(|FortranProgramCategory|))
   (name :initform "FortranMatrixCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'FMC)
   (comment :initform (list
     "FortranMatrixCategory provides support for"
     "producing Functions and Subroutines when the input to these"
     "is an AXIOM object of type Matrix or in domains"
     "involving FortranCode."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|coerce| '(%)  '((|Matrix| |MachineFloat|))
       '("coerce(v) produces an ASP which returns the value of v."))
     (make-signature '|coerce| '(%) '((|List| |FortranCode|))
       '("coerce(e) takes an object from List FortranCode and"
         "uses it as the body of an ASP."))
     (make-signature '|coerce| '(%) '(|FortranCode|)
       '("coerce(e) takes an object from List FortranCode and"
         "uses it as the body of an ASP."))
     (make-signature '|coerce| '(%) 
                     '((|Record| |localSymbols:SymbolTable| |code:List(FortranCode)|))
      '("coerce(e) takes the component of e from"
        "List FortranCode and uses it as the body of the ASP,"
        "making the declarations in the SymbolTable component."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranMatrixCategory|
  (progn
    (push '|FortranMatrixCategory| *Categories*)
    (make-instance '|FortranMatrixCategoryType|)))

\end{chunk}

\subsection{FortranMatrixFunctionCategory}
\index[cat]{FortranMatrixFunctionCategory!Category}
\index[cat]{Category!FortranMatrixFunctionCategory}
\index[cat]{FMFUN}
\begin{chunk}{defclass FortranMatrixFunctionCategoryType}
(defclass |FortranMatrixFunctionCategoryType| (|FortranProgramCategoryType|)
  ((parents :initform '(|FortranProgramCategory|))
   (name :initform "FortranMatrixFunctionCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'FMFUN)
   (comment :initform (list
     "FortranMatrixFunctionCategory provides support for"
     "producing Functions and Subroutines representing matrices of"
     "expressions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|coerce| '(%) '((|List| |FortranCode|))
       '("coerce(e) takes an object from List FortranCode and"
         "uses it as the body of an ASP."))
     (make-signature '|coerce| '(%) '(|FortranCode|)
       '("coerce(e) takes an object from FortranCode and"
         "uses it as the body of an ASP."))
     (make-signature '|coerce| '(%)
                     '((|Record| |localSymbols:SymbolTable| |code:List(FortranCode)|))
      '("coerce(e) takes the component of e from"
        "List FortranCode and uses it as the body of the ASP,"
        "making the declarations in the SymbolTable component."))
     (make-signature '|retract| '(%) '((|Matrix| |Expression| |Float|))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) 
                                     '((|Matrix| |Expression| |Float|))
       '("d retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retract| '(%) '((|Matrix| |Expression| |Integer|))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) 
                                     '((|Matrix| |Expression| |Integer|))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retract| '(%) '((|Matrix| |Polynomial| |Float|))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) 
                                     '((|Matrix| |Polynomial| |Float|))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retract| '(%) '((|Matrix| |Polynomial| |Integer|))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) 
                                     '((|Matrix| |Polynomial| |Integer|))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retract| '(%) '((|Matrix| |Fraction| |Polynomial| |Float|))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) 
                                     '((|Matrix| |Fraction| |Polynomial| |Float|))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retract| '(%) '((|Matrix| |Fraction| |Polynomial| |Integer|))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) 
                                     '((|Matrix| |Fraction| |Polynomial| |Integer|))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranMatrixFunctionCategory|
  (progn
    (push '|FortranMatrixFunctionCategory| *Categories*)
    (make-instance '|FortranMatrixFunctionCategoryType|)))

\end{chunk}

\subsection{FortranVectorCategory}
\index[cat]{FortranVectorCategory!Category}
\index[cat]{Category!FortranVectorCategory}
\index[cat]{FVC}
\begin{chunk}{defclass FortranVectorCategoryType}
(defclass |FortranVectorCategoryType| (|FortranProgramCategoryType|)
  ((parents :initform '(|FortranProgramCategory|))
   (name :initform "FortranVectorCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'FVC)
   (comment :initform (list
     "FortranVectorCategory provides support for"
     "producing Functions and Subroutines when the input to these"
     "is an AXIOM object of type Vector or in domains"
     "involving FortranCode."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|coerce| '(%)  '((|Vector| |MachineFloat|))
       '("coerce(v) produces an ASP which returns the value of v."))
     (make-signature '|coerce| '(%) '((|List| |FortranCode|))
       '("coerce(e) takes an object from List FortranCode and"
         "uses it as the body of an ASP."))
     (make-signature '|coerce| '(%) '(|FortranCode|)
       '("coerce(e) takes an object from FortranCode and"
         "uses it as the body of an ASP."))
     (make-signature '|coerce| '(%) 
                     '((|Record| |localSymbols:SymbolTable| |code:List(FortranCode)|))
      '("coerce(e) takes the component of e from"
        "List FortranCode and uses it as the body of the ASP,"
        "making the declarations in the SymbolTable component."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranVectorCategory|
  (progn
    (push '|FortranVectorCategory| *Categories*)
    (make-instance '|FortranVectorCategoryType|)))

\end{chunk}

\subsection{FortranVectorFunctionCategory}
\index[cat]{FortranVectorFunctionCategory!Category}
\index[cat]{Category!FortranVectorFunctionCategory}
\index[cat]{FVFUN}
\begin{chunk}{defclass FortranVectorFunctionCategoryType}
(defclass |FortranVectorFunctionCategoryType| (|FortranProgramCategoryType|)
  ((parents :initform '(|FortranProgramCategory|))
   (name :initform "FortranVectorFunctionCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'FVFUN)
   (comment :initform (list
     "FortranVectorFunctionCategory is the catagory of arguments"
     "to NAG Library routines which return the values of vectors of functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|coerce| '(%) '((|List| |FortranCode|))
       '("coerce(e) takes an object from List FortranCode and"
         "uses it as the body of an ASP."))
     (make-signature '|coerce| '(%) '(|FortranCode|)
       '("coerce(e) takes an object from FortranCode and"
         "uses it as the body of an ASP."))
     (make-signature '|coerce| '(%)
                     '((|Record| |localSymbols:SymbolTable| |code:List(FortranCode)|))
      '("coerce(e) takes the component of e from"
        "List FortranCode and uses it as the body of the ASP,"
        "making the declarations in the SymbolTable component."))
     (make-signature '|retract| '(%) '((|Vector| |Expression| |Float|))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) 
                                     '((|Vector| |Expression| |Float|))
       '("d retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retract| '(%) '((|Vector| |Expression| |Integer|))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) 
                                     '((|Vector| |Expression| |Integer|))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retract| '(%) '((|Vector| |Polynomial| |Float|))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) 
                                     '((|Vector| |Polynomial| |Float|))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retract| '(%) '((|Vector| |Polynomial| |Integer|))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) 
                                     '((|Vector| |Polynomial| |Integer|))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retract| '(%) '((|Vector| |Fraction| |Polynomial| |Float|))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) 
                                     '((|Vector| |Fraction| |Polynomial| |Float|))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retract| '(%) '((|Vector| |Fraction| |Polynomial| |Integer|))
       '("retract(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
     (make-signature '|retractIfCan| '((|Union| % "failed")) 
                                     '((|Vector| |Fraction| |Polynomial| |Integer|))
       '("retractIfCan(e) tries to convert e into an ASP, checking that"
         "legal Fortran-77 is produced."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranVectorFunctionCategory|
  (progn
    (push '|FortranVectorFunctionCategory| *Categories*)
    (make-instance '|FortranVectorFunctionCategoryType|)))

\end{chunk}

\subsection{FullyEvalableOver}
\index[cat]{FullyEvalableOver!Category}
\index[cat]{Category!FullyEvalableOver}
\index[cat]{FEVALAB}
\begin{chunk}{defclass FullyEvalableOverType}
(defclass |FullyEvalableOverType| (|EltableType| |EvalableType|)
  ((parents :initform '(|Eltable| |Evalable|))
   (name :initform "FullyEvalableOver")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'FEVALAB)
   (comment :initform (list
     "This category provides a selection of evaluation operations"
     "depending on what the argument type R provides."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FullyEvalableOver|
  (progn
    (push '|FullyEvalableOver| *Categories*)
    (make-instance '|FullyEvalableOverType|)))

\end{chunk}

\subsection{GradedModule}
\index[cat]{GradedModule!Category}
\index[cat]{Category!GradedModule}
\index[cat]{GRMOD}
\begin{chunk}{defclass GradedModuleType}
(defclass |GradedModuleType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "GradedModule")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'GRMOD)
   (comment :initform (list
     "GradedModule(R,E) denotes 'E-graded R-module', that is, collection of"
     "R-modules indexed by an abelian monoid E."
     "An element g of G[s] for some specific s in E"
     "is said to be an element of G with degree s."
     "Sums are defined in each module G[s] so two elements of G"
     "have a sum if they have the same degree."
     " "
     "Morphisms can be defined and composed by degree to give the"
     "mathematical category of graded modules."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|degree| '(|E|) '(%)
       '("degree(g) names the degree of g.  The set of all elements"
         "of a given degree form an R-module."))
     (make-signature '|0| '(%)  '(|constant|)
       '("0 denotes the zero of degree 0."))
     (make-signature '|*| '(%)  '(|(R, %)|)
       '("r*g is left module multiplication.") () t)
     (make-signature '|*| '(%)  '(|(%, R)|)
       '("g*r is right module multiplication.") () t)
     (make-signature '|-| '(%)  '(%)
       '("-g is the additive inverse of g in the module of elements"
         "of the same grade as g.") () t)
     (make-signature '|+| '(%)  '(|(%, %)|)
       '("g+h is the sum of g and h in the module of elements of"
         "the same degree as g and h.  Error: if g and h"
         "have different degrees." () t))
     (make-signature '|-| '(%)  '(|(%, %)|)
       '("g-h is the difference of g and h in the module of elements of"
         "the same degree as g and h.  Error: if g and h" 
         "have different degrees.") () t)
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GradedModule|
  (progn
    (push '|GradedModule| *Categories*)
    (make-instance '|GradedModuleType|)))

\end{chunk}

\subsection{HomogeneousAggregate}
\index[cat]{HomogeneousAggregate!Category}
\index[cat]{Category!HomogeneousAggregate}
\index[cat]{HOAGG}
\begin{chunk}{defclass HomogeneousAggregateType}
(defclass |HomogeneousAggregateType| (|AggregateType| |EvalableType| |SetCategoryType|)
  ((parents  :initform '(|SetCategory| |Aggregate| |Evalable|))
   (name :initform "HomogeneousAggregate")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'HOAGG)
   (comment :initform (list
     "A homogeneous aggregate is an aggregate of elements all of the"
     "same type."
     "In the current system, all aggregates are homogeneous."
     "Two attributes characterize classes of aggregates."
     "Aggregates from domains with attribute finiteAggregate"
     "have a finite number of members."
     "Those with attribute shallowlyMutable allow an element"
     "to be modified or updated without changing its overall value."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |HomogeneousAggregate|
  (progn
    (push '|HomogeneousAggregate| *Categories*)
    (make-instance '|HomogeneousAggregateType|)))

\end{chunk}

\subsection{IndexedDirectProductCategory}
\index[cat]{IndexedDirectProductCategory!Category}
\index[cat]{Category!IndexedDirectProductCategory}
\index[cat]{IDPC}
\begin{chunk}{defclass IndexedDirectProductCategoryType}
(defclass |IndexedDirectProductCategoryType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "IndexedDirectProductCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'IDPC)
   (comment :initform (list
     "This category represents the direct product of some set with"
     "respect to an ordered indexing set."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|map| '|%| '((|->| A A))
       '("map(f,z) returns the new element created by applying the"
         "function f to each component of the direct product element z."))
     (make-signature '|monomial| '(|%|) '(A S)
       '("monomial(a,s) constructs a direct product element with the s"
         "component set to a"))
     (make-signature '|leadingCoefficient| '(A) '(|%|)
       '("leadingCoefficient(z) returns the coefficient of the leading"
         "(with respect to the ordering on the indexing set)"
         "monomial of z."
         "Error: if z has no support."))
     (make-signature '|leadingSupport| '(S) '(|%|)
       '("leadingSupport(z) returns the index of leading"
         "(with respect to the ordering on the indexing set) monomial of z."
         "Error: if z has no support."))
     (make-signature '|reductum| '(|%|) '(|%|)
       '("reductum(z) returns a new element created by removing the"
         "leading coefficient/support pair from the element z."
         "Error: if z has no support."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedDirectProductCategory|
  (progn
    (push '|IndexedDirectProductCategory| *Categories*)
    (make-instance '|IndexedDirectProductCategoryType|)))

\end{chunk}

\subsection{LiouvillianFunctionCategory}
\index[cat]{LiouvillianFunctionCategory!Category}
\index[cat]{Category!LiouvillianFunctionCategory}
\index[cat]{LFCAT}
\begin{chunk}{defclass LiouvillianFunctionCategoryType}
(defclass |LiouvillianFunctionCategoryType| (|PrimitiveFunctionCategoryType| 
                                             |TranscendentalFunctionCategoryType|)
  ((parents :initform '(|PrimitiveFunctionCategory| |TranscendentalFunctionCategory|))
   (name :initform "LiouvillianFunctionCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'LFCAT)
   (comment :initform (list
     "Category for the transcendental Liouvillian functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|Ei| '(|%|) '(|%|)
      '("Ei(x) returns the exponential integral of x, that is,"
        "the integral of exp(x)/x dx."))
 
    (make-signature '|Si| '(|%|) '(|%|)
      '("Si(x) returns the sine integral of x, that is,"
        "the integral of sin(x) / x dx."))

    (make-signature '|Ci| '(|%|) '(|%|)
      '("Ci(x) returns the cosine integral of x, that is,"
        "the integral of cos(x) / x dx."))

    (make-signature '|li| '(|%|) '(|%|)
      '("li(x) returns the logarithmic integral of x, that is,"
        "the integral of dx / log(x)."))

    (make-signature '|dilog| '(|%|) '(|%|)
      '("dilog(x) returns the dilogarithm of x, that is,"
        "the integral of log(x) / (1 - x) dx."))

    (make-signature '|erf| '(|%|) '(|%|)
      '("erf(x) returns the error function of x, that is,"
        "2 / sqrt(%pi) times the integral of exp(-x**2) dx."))

    (make-signature '|fresnelS| '(|%|) '(|%|)
      '("fresnelS(x) is the Fresnel integral S, defined by"
        "S(x) = integrate(sin(t^2),t=0..x)"))

    (make-signature '|fresnelC| '(|%|) '(|%|)
      '("fresnelC(x) is the Fresnel integral C, defined by"
        "C(x) = integrate(cos(t^2),t=0..x)"))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LiouvillianFunctionCategory|
  (progn
    (push '|LiouvillianFunctionCategory| *Categories*)
    (make-instance '|LiouvillianFunctionCategoryType|)))

\end{chunk}

\subsection{Monad}
\index[cat]{Monad!Category}
\index[cat]{Category!Monad}
\index[cat]{MONAD}
\begin{chunk}{defclass MonadType}
(defclass |MonadType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "Monad")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'MONAD)
   (comment :initform (list
     "Monad is the class of all multiplicative monads, that is sets"
     "with a binary operation."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
    (make-signature '|*| '(|%|) '(|%| |%|)
      '("a*b is the product of a and b in a set with"
        "a binary operation.") () t)
    (make-signature '|rightPower| '(|%|) '(|%| |PositiveInteger|)
      '("rightPower(a,n) returns the n-th right power of a,"
        "that is, rightPower(a,n) := rightPower(a,n-1) * a and"
        "rightPower(a,1) := a."))
    (make-signature '|leftPower| '(|%|) '(|%| |PositiveInteger|)
      '("leftPower(a,n) returns the n-th left power of a,"
        "that is, leftPower(a,n) := a * leftPower(a,n-1) and"
        "leftPower(a,1) := a."))
    (make-signature '|**| '(|%|) '(|%| |PositiveInteger|)
       '("a**n returns the n-th power of a,"
         "defined by repeated squaring.") () t)
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Monad|
  (progn
    (push '|Monad| *Categories*)
    (make-instance '|MonadType|)))

\end{chunk}

\subsection{NumericalIntegrationCategory}
\index[cat]{NumericalIntegrationCategory!Category}
\index[cat]{Category!NumericalIntegrationCategory}
\index[cat]{NUMINT}
\begin{chunk}{defclass NumericalIntegrationCategoryType}
(defclass |NumericalIntegrationCategoryType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "NumericalIntegrationCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'NUMINT)
   (comment :initform (list
     "NumericalIntegrationCategory is the category for"
     "describing the set of Numerical Integration domains with"
     "measure and numericalIntegration."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NumericalIntegrationCategory|
  (progn
    (push '|NumericalIntegrationCategory| *Categories*)
    (make-instance '|NumericalIntegrationCategoryType|)))

\end{chunk}

\subsection{NumericalOptimizationCategory}
\index[cat]{NumericalOptimizationCategory!Category}
\index[cat]{Category!NumericalOptimizationCategory}
\index[cat]{OPTCAT}
\begin{chunk}{defclass NumericalOptimizationCategoryType}
(defclass |NumericalOptimizationCategoryType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "NumericalOptimizationCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'OPTCAT)
   (comment :initform (list
     "NumericalOptimizationCategory is the category for"
     "describing the set of Numerical Optimization domains with"
     "measure and optimize."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NumericalOptimizationCategory|
  (progn
    (push '|NumericalOptimizationCategory| *Categories*)
    (make-instance '|NumericalOptimizationCategoryType|)))

\end{chunk}

\subsection{OrderedSet}
\index[cat]{OrderedSet!Category}
\index[cat]{Category!OrderedSet}
\index[cat]{ORDSET}
\begin{chunk}{defclass OrderedSetType}
(defclass |OrderedSetType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "OrderedSet")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'ORDSET)
   (comment :initform (list
     "The class of totally ordered sets, that is, sets such that for each "
     "pair of elements (a,b)"
     "exactly one of the following relations holds a<b or a=b or b<a"
     "and the relation is transitive, that is, a<b and b<c => a<c."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
    (make-signature '|<| '(|Boolean|) '(|%| |%|)
      '("x < y is a strict total ordering on the elements of the set.") () t)
    (make-signature '|>| '(|Boolean|) '(|%| |%|)
      '("x > y is a greater than test.") () t)
    (make-signature '|>=| '(|Boolean|) '(|%| |%|)
      '("x >= y is a greater than or equal test.") () t)
    (make-signature '|<=| '(|Boolean|) '(|%| |%|)
      '("x <= y is a less than or equal test.") () t)
    (make-signature '|max| '(|%|) '(|%| |%|)
      '("max(x,y) returns the maximum of x and y relative to '<'"))
    (make-signature '|min| '(|%|) '(|%| |%|)
      '("min(x,y) returns the minimum of x and y relative to '<'"))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedSet|
  (progn
    (push '|OrderedSet| *Categories*)
    (make-instance '|OrderedSetType|)))

\end{chunk}

\subsection{OrdinaryDifferentialEquationsSolverCategory}
\index[cat]{OrdinaryDifferentialEquationsSolverCategory!Category}
\index[cat]{Category!OrdinaryDifferentialEquationsSolverCategory}
\index[cat]{ODECAT}
\begin{chunk}{defclass OrdinaryDifferentialEquationsSolverCategoryType}
(defclass |OrdinaryDifferentialEquationsSolverCategoryType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "OrdinaryDifferentialEquationsSolverCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'ODECAT)
   (comment :initform (list
     "OrdinaryDifferentialEquationsSolverCategory is the"
     "category for describing the set of ODE solver domains"
     "with measure and ODEsolve."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrdinaryDifferentialEquationsSolverCategory|
  (progn
    (push '|OrdinaryDifferentialEquationsSolverCategory| *Categories*)
    (make-instance '|OrdinaryDifferentialEquationsSolverCategoryType|)))

\end{chunk}

\subsection{PartialDifferentialEquationsSolverCategory}
\index[cat]{PartialDifferentialEquationsSolverCategory!Category}
\index[cat]{Category!PartialDifferentialEquationsSolverCategory}
\index[cat]{PDECAT}
\begin{chunk}{defclass PartialDifferentialEquationsSolverCategoryType}
(defclass |PartialDifferentialEquationsSolverCategoryType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "PartialDifferentialEquationsSolverCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'PDECAT)
   (comment :initform (list
     "PartialDifferentialEquationsSolverCategory is the"
     "category for describing the set of PDE solver domains"
     "with measure and PDEsolve."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PartialDifferentialEquationsSolverCategory|
  (progn
    (push '|PartialDifferentialEquationsSolverCategory| *Categories*)
    (make-instance '|PartialDifferentialEquationsSolverCategoryType|)))

\end{chunk}

\subsection{PatternMatchable}
\index[cat]{PatternMatchable!Category}
\index[cat]{Category!PatternMatchable}
\index[cat]{PATMAB}
\begin{chunk}{defclass PatternMatchableType}
(defclass |PatternMatchableType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "PatternMatchable")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'PATMAB)
   (comment :initform (list
     "A set R is PatternMatchable over S if elements of R can"
     "be matched to patterns over S."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
    (make-signature '|sign| '(Z) '(|ThePols| |%|)
      '("sign(pol,aRoot) gives the sign of pol interpreted as aRoot"))
    (make-signature '|zero?| '(|Boolean|) '(|ThePols| |%|)
      '("zero?(pol,aRoot) answers if pol interpreted as aRoot is 0"))
    (make-signature '|negative?| '(|Boolean|) '(|ThePols| |%|)
      '("negative?(pol,aRoot) answers if pol interpreted as aRoot is negative"))
    (make-signature '|positive?| '(|Boolean|) '(|ThePols| |%|)
      '("positive?(pol,aRoot) answers if pol interpreted as aRoot is positive"))
    (make-signature '|recip| '((|Union| |ThePols| "failed")) '(|ThePols| |%|)
      '("recip(pol,aRoot) tries to inverse pol interpreted as aRoot"))
    (make-signature '|definingPolynomial| '(|ThePols|) '(|%|)
      '("definingPolynomial(aRoot) gives a polynomial"
        "such that definingPolynomial(aRoot).aRoot = 0")) 
    (make-signature '|allRootsOf| '((|List| |%|))  '(|ThePols|)
      '("allRootsOf(pol) creates all the roots of pol" 
        "in the Real Closure, assumed in order."))
    (make-signature '|rootOf| '(|Union| $ "failed") '(|ThePols| N) 
      '("rootOf(pol,n) gives the nth root for the order of the Real Closure"))
    (make-signature '|approximate| '(|TheField|) '(|ThePols| $ |TheField|)
      '("approximate(term,root,prec) gives an approximation"
        "of term over root with precision prec"))
    (make-signature '|relativeApprox| '(|TheField|) '(|ThePols| $ |TheField|)
      '("approximate(term,root,prec) gives an approximation"
        "of term over root with precision prec"))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatchable|
  (progn
    (push '|PatternMatchable| *Categories*)
    (make-instance '|PatternMatchableType|)))

\end{chunk}

\subsection{RealRootCharacterizationCategory}
\index[cat]{RealRootCharacterizationCategory!Category}
\index[cat]{Category!RealRootCharacterizationCategory}
\index[cat]{RRCC}
\begin{chunk}{defclass RealRootCharacterizationCategoryType}
(defclass |RealRootCharacterizationCategoryType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "RealRootCharacterizationCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'RRCC)
   (comment :initform (list
     "RealRootCharacterizationCategory provides common access"
     "functions for all real roots of polynomials"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|sign| '(Z) '(|ThePols| %)
       '("sign(pol,aRoot) gives the sign of pol"
         "interpreted as aRoot"))
     (make-signature '|zero?| '(|Boolean|) '(|ThePols| %)
       '("zero?(pol,aRoot) answers if pol"
         "interpreted as aRoot is 0"))
     (make-signature '|negative?| '(|Boolean|) '(|ThePols| %)
       '("negative?(pol,aRoot) answers if pol"
         "interpreted as aRoot is negative"))
     (make-signature '|positive?| '(|Boolean|) '(|ThePols| %)
       '("positive?(pol,aRoot) answers if pol"
         "interpreted as aRoot is positive"))
     (make-signature '|recip| '((|Union| |ThePols| "failed")) '(|ThePols| %)
       '("recip(pol,aRoot) tries to inverse pol"
         "interpreted as aRoot"))
     (make-signature '|definingPolynomial| '(|ThePols|) '(%)
       '("definingPolynomial(aRoot) gives a polynomial"
         "such that definingPolynomial(aRoot).aRoot = 0")) 
     (make-signature '|allRootsOf| '((|List| %)) '(|ThePols|)
       '("allRootsOf(pol) creates all the roots of pol"
         "in the Real Closure, assumed in order."))
     (make-signature '|rootOf| '((|Union| % "failed")) '(|ThePols| N)
       '("rootOf(pol,n) gives the nth root for the order of the"
         "Real Closure"))
     (make-signature '|approximate| '(|TheField|) '(|ThePols| % |TheField|)
       '("approximate(term,root,prec) gives an approximation"
         "of term over root with precision prec"))
     (make-signature '|relativeApprox| '(|TheField|) '(|ThePols| % |TheField|)
       '("approximate(term,root,prec) gives an approximation"
         "of term over root with precision prec"))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RealRootCharacterizationCategory|
  (progn
    (push '|RealRootCharacterizationCategory| *Categories*)
    (make-instance '|RealRootCharacterizationCategoryType|)))

\end{chunk}

\subsection{SExpressionCategory}
\index[cat]{SExpressionCategory!Category}
\index[cat]{Category!SExpressionCategory}
\index[cat]{SEXCAT}
\begin{chunk}{defclass SExpressionCategoryType}
(defclass |SExpressionCategoryType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "SExpressionCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'SEXCAT)
   (comment :initform (list
     "This category allows the manipulation of Lisp values while keeping"
     "the grunge fairly localized."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|eq| '(|Boolean|) '(% %)
       '("eq(s, t) is true if EQ(s,t) is true in Lisp."))

     (make-signature '|null?| '(|Boolean|) '(%)
       '("null?(s) is true if s is the S-expression ()."))

     (make-signature '|atom?| '(|Boolean|) '(%)
       '("atom?(s) is true if s is a Lisp atom."))

     (make-signature '|pair?| '(|Boolean|) '(%)
       '("pair?(s) is true if s has is a non-null Lisp list."))

     (make-signature '|list?| '(|Boolean|) '(%)
       '("list?(s) is true if s is a Lisp list, possibly ()."))

     (make-signature '|string?| '(|Boolean|) '(%)
       '("string?(s) is true if s is an atom and belong to Str."))

     (make-signature '|symbol?| '(|Boolean|) '(%)
       '("symbol?(s) is true if s is an atom and belong to Sym."))

     (make-signature '|integer?| '(|Boolean|) '(%)
       '("integer?(s) is true if s is an atom and belong to Int."))

     (make-signature '|float?| '(|Boolean|) '(%)
       '("float?(s) is true if s is an atom and belong to Flt."))

     (make-signature '|destruct| '(|List %|) '(%)
       '("destruct((a1,...,an)) returns the list [a1,...,an]."))

     (make-signature '|string| '(|Str|) '(%)
       '("string(s) returns s as an element of Str."
         "Error: if s is not an atom that also belongs to Str."))

    (make-signature '| symbol| '(|Sym|) '(%)
       '("symbol(s) returns s as an element of Sym."
         "Error: if s is not an atom that also belongs to Sym."))

    (make-signature '| integer| '(|Int|) '(%)
       '("integer(s) returns s as an element of Int."
         "Error: if s is not an atom that also belongs to Int."))

    (make-signature '| float| '(|Flt|) '(%)
       '("float(s) returns s as an element of Flt;"
         "Error: if s is not an atom that also belongs to Flt."))

    (make-signature '| expr| '(|Expr|) '(%)
       '("expr(s) returns s as an element of Expr;"
         "Error: if s is not an atom that also belongs to Expr."))

    (make-signature '| convert| '(%) '(|List| %)
       '("convert([a1,...,an]) returns an S-expression (a1,...,an)."))

     (make-signature '|convert| '(%) '(|Str|)
       '("convert(x) returns the Lisp atom x;"))

     (make-signature '|convert| '(%) '(|Sym|)
       '("convert(x) returns the Lisp atom x."))

     (make-signature '|convert| '(%) '(|Int|)
       '("convert(x) returns the Lisp atom x."))

     (make-signature '|convert| '(%) '(|Flt|)
       '("convert(x) returns the Lisp atom x."))

     (make-signature '|convert| '(%) '(|Expr|)
       '("convert(x) returns the Lisp atom x."))

     (make-signature '|car| '(%) '(%)
       '("car((a1,...,an)) returns a1."))

     (make-signature '|cdr| '(%) '(%)
       '("cdr((a1,...,an)) returns (a2,...,an)."))

     (make-signature '|"#"| '(|Integer|) '(%)
       '("#((a1,...,an)) returns n."))

     (make-signature '|elt| '(%) '(% |Integer|)
       '("elt((a1,...,an), i) returns ai."))

     (make-signature '|elt| '(%) '(% (|List| |Integer|))
       '("elt((a1,...,an), [i1,...,im]) returns (a_i1,...,a_im)."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SExpressionCategory|
  (progn
    (push '|SExpressionCategory| *Categories*)
    (make-instance '|SExpressionCategoryType|)))

\end{chunk}

\subsection{SegmentExpansionCategory}
\index[cat]{SegmentExpansionCategory!Category}
\index[cat]{Category!SegmentExpansionCategory}
\index[cat]{SEGXCAT}
\begin{chunk}{defclass SegmentExpansionCategoryType}
(defclass |SegmentExpansionCategoryType| (|SegmentCategoryType|)
  ((parents :initform '(|SegmentCategory|))
   (name :initform "SegmentExpansionCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'SEGXCAT)
   (comment :initform (list
     "This category provides an interface for expanding segments to"
     "a stream of elements."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|expand| '(L) '(|List| %)
       '("expand(l) creates a new value of type L in which each segment"
         "l..h by k is replaced with l, l+k, ... lN,"
         "where lN <= h < lN+k."
         "For example, expand [1..4, 7..9] = [1,2,3,4,7,8,9]."))
     (make-signature '|expand| '(L) '(%)
       '("expand(l..h by k) creates value of type L with elements"
         "l, l+k, ... lN where lN <= h < lN+k."
         "For example, expand(1..5 by 2) = [1,3,5]."))
     (make-signature '|map| '(L) '(|S -> S| %) 
       '("map(f,l..h by k) produces a value of type L by applying f"
         "to each of the succesive elements of the segment, that is,"
         "[f(l), f(l+k), ..., f(lN)], where lN <= h < lN+k."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SegmentExpansionCategory|
  (progn
    (push '|SegmentExpansionCategory| *Categories*)
    (make-instance '|SegmentExpansionCategoryType|)))

\end{chunk}

\subsection{SemiGroup}
\index[cat]{SemiGroup!Category}
\index[cat]{Category!SemiGroup}
\index[cat]{SGROUP}
\begin{chunk}{defclass SemiGroupType}
(defclass |SemiGroupType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "SemiGroup")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'SGROUP)
   (comment :initform (list
     "The class of all multiplicative semigroups, that is, a set"
     "with an associative operation *."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|*| '(%) '(% %)
       '("x*y returns the product of x and y.") () t)

     (make-signature '|**| '(%) '(% |PositiveInteger|)
       '("x**n returns the repeated product of x n times, exponentiation.") () t)

     (make-signature '|^| '(%) '(% |PositiveInteger|)
       '("x^n returns the repeated product of x n times, exponentiation.") () t)
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SemiGroup|
  (progn
    (push '|SemiGroup| *Categories*)
    (make-instance '|SemiGroupType|)))

\end{chunk}

\subsection{SetCategoryWithDegree}
\index[cat]{SetCategoryWithDegree!Category}
\index[cat]{Category!SetCategoryWithDegree}
\index[cat]{SETCATD}
\begin{chunk}{defclass SetCategoryWithDegreeType}
(defclass |SetCategoryWithDegreeType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "SetCategoryWithDegree")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'SETCATD)
   (comment :initform (list
     "This is part of the PAFF package, related to projective space."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|degree| '(|PositiveInteger|) '(%) ())
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SetCategoryWithDegree|
  (progn
    (push '|SetCategoryWithDegree| *Categories*)
    (make-instance '|SetCategoryWithDegreeType|)))

\end{chunk}

\subsection{StepThrough}
\index[cat]{StepThrough!Category}
\index[cat]{Category!StepThrough}
\index[cat]{STEP}
\begin{chunk}{defclass StepThroughType}
(defclass |StepThroughType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "StepThrough")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'STEP)
   (comment :initform (list
     "A class of objects which can be 'stepped through'."
     "Repeated applications of nextItem is guaranteed never to"
     "return duplicate items and only return 'failed' after exhausting"
     "all elements of the domain."
     "This assumes that the sequence starts with init()."
     "For infinite domains, repeated application"
     "of nextItem is not required to reach all possible domain elements"
     "starting from any initial element."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|init| '(%) '(|constant|)
       '("init() chooses an initial object for stepping."))
  
     (make-signature '|nextItem| '(|Union| % "failed") '(%)
       '("nextItem(x) returns the next item, or \"failed\""
         "if domain is exhausted."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StepThrough|
  (progn
    (push '|StepThrough| *Categories*)
    (make-instance '|StepThroughType|)))

\end{chunk}

\subsection{ThreeSpaceCategory}
\index[cat]{ThreeSpaceCategory!Category}
\index[cat]{Category!ThreeSpaceCategory}
\index[cat]{SPACEC}
\begin{chunk}{defclass ThreeSpaceCategoryType}
(defclass |ThreeSpaceCategoryType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "ThreeSpaceCategory")
   (marker :initform 'category)
   (level :initform 3)
   (abbreviation :initform 'SPACEC)
   (comment :initform (list
     "The category ThreeSpaceCategory is used for creating" 
     "three dimensional objects using functions for defining points, curves,"
     "polygons, constructs and the subspaces containing them."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list
     (make-signature '|create3Space| '(%) '() 
       '("create3Space() creates a ThreeSpace object capable of "
         "holding point, curve, mesh components and any combination."))

     (make-signature '|create3Space| '(%) '(SUBSPACE)
       '("create3Space(s) creates a ThreeSpace object containing"
         "objects pre-defined within some SubSpace s."))

     (make-signature '|numberOfComponents| '(NNI) '(%)
       '("numberOfComponents(s) returns the number of distinct"
         "object components in the indicated ThreeSpace, s, such"
         "as points, curves, polygons, and constructs."))

     (make-signature '|numberOfComposites| '(NNI) '(%)
       '("numberOfComposites(s) returns the number of supercomponents,"
         "or composites, in the ThreeSpace, s; Composites are "
         "arbitrary groupings of otherwise distinct and unrelated components;"
         "A ThreeSpace need not have any composites defined at all"
         "and, outside of the requirement that no component can belong"
         "to more than one composite at a time, the definition and"
         "interpretation of composites are unrestricted."))

     (make-signature '|merge| '(%) '((|List| %))
       '("merge([s1,s2,...,sn]) will create a new ThreeSpace that"
         "has the components of all the ones in the list; Groupings of "
         "components into composites are maintained."))

     (make-signature '|merge| '(%) '(% %)
       '("merge(s1,s2) will create a new ThreeSpace that has the"
         "components of s1 and s2; Groupings of components"
         "into composites are maintained."))

     (make-signature '|composite| '(%) '((|List| %))
       '("composite([s1,s2,...,sn]) will create a new ThreeSpace"
         "that is a union of all the components from each "
         "ThreeSpace in the parameter list, grouped as a composite."))

     (make-signature '|components| '(|List| %) '(%)
       '("components(s) takes the ThreeSpace s, and creates a list "
         "containing a unique ThreeSpace for each single component "
         "of s. If s has no components defined, the list returned is empty."))

     (make-signature '|composites| '((|List| %)) '(%)
       '("composites(s) takes the ThreeSpace s, and creates a list "
         "containing a unique ThreeSpace for each single composite "
         "of s. If s has no composites defined (composites need to be "
         "explicitly created), the list returned is empty. Note that not all "
         "the components need to be part of a composite."))

     (make-signature '|copy| '(%) '(%)
       '("copy(s) returns a new ThreeSpace that is an exact copy "
         "of s."))

     (make-signature '|enterPointData| '(NNI) '(% (|List| POINT))
       '("enterPointData(s,[p0,p1,...,pn]) adds a list of points from p0 "
         "through pn to the ThreeSpace, s, and returns the index, "
         "to the starting point of the list;"))

     (make-signature '|modifyPointData| '(%) '(% NNI POINT)
       '("modifyPointData(s,i,p) changes the point at the indexed "
         "location i in the ThreeSpace, s, to that of point p."
         "This is useful for making changes to a point which has been "
         "transformed."))

     (make-signature '|point| '(%) '(% POINT)
       '("point(s,p) adds a point component defined by the point, p, "
         "specified as a list from List(R), to the "
         "ThreeSpace, s, where R is the Ring over "
         "which the point is defined."))

     (make-signature '|point| '(%) '(% (|List| R))
       '("point(s,[x,y,z]) adds a point component defined by a list of "
         "elements which are from the PointDomain(R) to the "
         "ThreeSpace, s, where R is the Ring over "
         "which the point elements are defined."))

     (make-signature '|point| '(%) '(% NNI)
       '("point(s,i) adds a point component which is placed into a component"
         "list of the ThreeSpace, s, at the index given by i."))

     (make-signature '|point| '(%) '(POINT)
       '("point(p) returns a ThreeSpace object which is composed "
         "of one component, the point p."))

     (make-signature '|point| '(POINT) '(%)
       '("point(s) checks to see if the ThreeSpace, s, is "
         "composed of only a single point and if so, returns the point. "
         "An error is signaled otherwise."))

     (make-signature '|point?| '(B) '(%)
       '("point?(s) queries whether the ThreeSpace, s, is "
         "composed of a single component which is a point and returns the "
         "boolean result."))

     (make-signature '|curve| '(%) '(% (|List| POINT))
       '("curve(s,[p0,p1,...,pn]) adds a space curve component defined by a "
         "list of points p0 through pn, to the "
         "ThreeSpace s."))

     (make-signature '|curve| '(%) '(% (|List| |List| R))
       '("curve(s,[[p0],[p1],...,[pn]]) adds a space curve which is a list of "
         "points p0 through pn defined by lists of elements from the domain "
         "PointDomain(m,R), where R is the Ring over which "
         "the point elements are defined and m is the dimension of the "
         "points, to the ThreeSpace s."))

;     (make-signature '|curve| '(%) '(|List| POINT)
;       '("curve([p0,p1,p2,...,pn]) creates a space curve defined"
;         "by the list of points p0 through pn, and returns the "
;         "ThreeSpace whose component is the curve."))
;
;     (make-signature '|curve| '(|List| POINT) '(%)
;       '("curve(s) checks to see if the ThreeSpace, s, is "
;         "composed of a single curve defined by a list of points and if so, "
;         "returns the curve, that is, list of points. An error is signaled "
;         "otherwise."))
;
;     (make-signature '|curve?| '(B) '(%)
;       '("curve?(s) queries whether the ThreeSpace, s, is a curve, "
;         "that is, has one component, a list of list of points, and returns "
;         "true if it is, or false otherwise."))
;
;     (make-signature '|closedCurve| '(%) '(% (|List| POINT))
;       '("closedCurve(s,[p0,p1,...,pn,p0]) adds a closed curve component "
;         "which is a list of points defined by the first element p0 through "
;         "the last element pn and back to the first element p0 again, to the "
;         "ThreeSpace s."))
;
;     (make-signature '|closedCurve| '(%) '(|List| (|List| R))
;       '("closedCurve(s,[[lr0],[lr1],...,[lrn],[lr0]]) adds a closed curve "
;         "component defined by a list of points lr0 through "
;         "lrn, which are lists of elements from the domain "
;         "PointDomain(m,R), where R is the Ring over which "
;         "the point elements are defined and m is the dimension of the "
;         "points, in which the last element of the list of points contains "
;         "a copy of the first element list, lr0."
;         "The closed curve is added to the ThreeSpace, s."))
;
;     (make-signature '|closedCurve| '(%) '(|List| POINT)
;       '("closedCurve(lp) sets a list of points defined by the first element"
;         "of lp through the last element of lp and back to the first elelment"
;         "again and returns a ThreeSpace whose component is the"
;         "closed curve defined by lp."))
;
;     (make-signature '|closedCurve| '(List| POINT) '(%)
;       '("closedCurve(s) checks to see if the ThreeSpace, s, is "
;         "composed of a single closed curve component defined by a list of "
;         "points in which the first point is also the last point, all of "
;         "which are from the domain PointDomain(m,R) and if so, "
;         "returns the list of points.  An error is signaled otherwise."))
;
;     (make-signature '|closedCurve?| '(B) '(%)
;       '("closedCurve?(s) returns true if the ThreeSpace s "))
;      ++ contains a single closed curve component, that is, the first element 
;      ++ of the curve is also the last element, or false otherwise.
;
;     (make-signature '|polygon| '(%) '(|List| POINT)
;       '("polygon(s,[p0,p1,...,pn]) adds a polygon component defined by a "
;         "list of points, p0 throught pn, to the ThreeSpace s."))
;
;     (make-signature '|polygon| '(%) '(% |List| (|List| R))
;       '("polygon(s,[[r0],[r1],...,[rn]]) adds a polygon component defined"
;         "by a list of points r0 through rn, which are lists of"
;         "elements from the domain PointDomain(m,R) to the "
;         "ThreeSpace s, where m is the dimension of the points"
;         "and R is the Ring over which the points are defined."))
;
;     (make-signature '|polygon| '(%) '(|List| POINT)
;       '("polygon([p0,p1,...,pn]) creates a polygon defined by a list of "
;         "points, p0 through pn, and returns a ThreeSpace whose "
;         "component is the polygon."))
;
;     (make-signature '|polygon| '(|List| POINT) '(%)
;       '("polygon(s) checks to see if the ThreeSpace, s, is "
;         "composed of a single polygon component defined by a list of "
;         "points, and if so, returns the list of points;  An error is "
;         "signaled otherwise."))
;
;     (make-signature '|polygon?| '(B) '(%)
;       '("polygon?(s) returns true if the ThreeSpace s contains "
;         "a single polygon component, or false otherwise."))
;
;     (make-signature '|mesh| '(%) '(% (|List| (|List POINT)) (|List| PROP) PROP)
;       '("mesh(s,[[p0],[p1],...,[pn]],[props],prop) adds a surface component, "
;         "defined over a list curves which contains lists of points, to the "
;         "ThreeSpace s; props is a list which contains the "
;         "subspace component properties for each surface parameter, and "
;         "prop is the subspace component property by which the points are "
;         "defined."))
;
;     (make-signature '|mesh| '(%) '(% (|List| (|List| (|List| R))) (|List| PROP) PROP)
;       '("mesh(s, LLLR, [props], prop)"
;         "where LLLR is of the form:"
;         "[[[r10]...,[r1m]],[[r20]...,[r2m]],...,[[rn0]...,[rnm]]],"
;         "adds a surface component to the ThreeSpace s, which is "
;         "defined over a rectangular domain of size WxH where W is the number "
;         "of lists of points from the domain PointDomain(R) and H is "
;         "the number of elements in each of those lists; lprops is the list "
;         "of the subspace component properties for each curve list, and "
;         "prop is the subspace component property by which the points are "
;         "defined."))
;
;     (make-signature '|mesh| '(%) '(% (|List| (|List| POINT)) B B)
;       '("mesh(s, LLP, close1, close2) "
;         "where LLP is of the form [[p0],[p1],...,[pn]] adds a surface "
;         "component to the ThreeSpace, which is defined over a "
;         "list of curves, in which each of these curves is a list of points. "
;         "The boolean arguments close1 and close2 indicate how the surface "
;         "is to be closed. Argument close1 equal true"
;         "means that each individual list (a curve) is to be closed, that is,"
;         "the last point of the list is to be connected to the first point."
;         "Argument close2 equal true "
;         "means that the boundary at one end of the surface is to be"
;         "connected to the boundary at the other end, that is, the boundaries "
;         "are defined as the first list of points (curve) and "
;         "the last list of points (curve)."))
;
;     (make-signature '|mesh| '(%) '(% (|List| (|List| (|List| R))) B B)
;       '("mesh(s, LLLR, close1, close2)"
;         "where LLLR is of the form"
;         "[[[r10]...,[r1m]],[[r20]...,[r2m]],...,[[rn0]...,[rnm]]],"
;         "adds a surface component to the ThreeSpace s, which is "
;         "defined over a rectangular domain of size WxH where W is the number "
;         "of lists of points from the domain PointDomain(R) and H is "
;         "the number of elements in each of those lists; the booleans close1 "
;         "and close2 indicate how the surface is to be closed: if close1 is "
;         "true this means that each individual list (a curve) is to be "
;         "closed (that is,"
;         "the last point of the list is to be connected to the first point);"
;         "if close2 is true, this means that the boundary at one end of the"
;         "surface is to be connected to the boundary at the other end"
;         "(the boundaries are defined as the first list of points (curve)"
;         "and the last list of points (curve))."))
;
;     (make-signature '|mesh| '(%) '(|List| (|List| POINT))
;       '("mesh([[p0],[p1],...,[pn]]) creates a surface defined by a list of "
;         "curves which are lists, p0 through pn, of points, and returns a "
;         "ThreeSpace whose component is the surface."))
;
;     (make-signature '|mesh| '(%) '(|List| (|List| POINT) B B)
;       '("mesh([[p0],[p1],...,[pn]], close1, close2) creates a surface "
;         "defined over a list of curves, p0 through pn, which are lists of "
;         "points; the booleans close1 and close2 indicate how the surface is "
;         "to be closed: close1 set to true means that each individual list "
;         "(a curve) is to be closed (that is, the last point of the list is "
;         "to be connected to the first point); close2 set to true means "
;         "that the boundary at one end of the surface is to be connected to "
;         "the boundary at the other end (the boundaries are defined as the "
;         "first list of points (curve) and the last list of points (curve)); "
;         "the ThreeSpace containing this surface is returned."))
;
;     (make-signature '|mesh| '(|List| (|List| POINT)) '(%)
;       '("mesh(s) checks to see if the ThreeSpace, s, is "
;         "composed of a single surface component defined by a list curves "
;         "which contain lists of points, and if so, returns the list of "
;         "lists of points;  An error is signaled otherwise."))
;
;     (make-signature '|mesh?| '(B) '(%)
;       '("mesh?(s) returns true if the ThreeSpace s is composed "
;         "of one component, a mesh comprising a list of curves which are lists"
;         "of points, or returns false if otherwise"))
;
;     (make-signature '|lp| '(|List| POINT) '(%)
;       '("lp(s) returns the list of points component which the "
;         "ThreeSpace, s, contains; these points are used by "
;         "reference, that is, the component holds indices referring to the "
;         "points rather than the points themselves. This allows for sharing "
;         "of the points."))
;
;     (make-signature '|lllip| '(|List| (|List| (|List| NNI))) '(%)
;       '("lllip(s) checks to see if the ThreeSpace, s, is "
;         "composed of a list of components, which are lists of curves, "
;         "which are lists of indices to points, and if so, returns the list "
;         "of lists of lists;  An error is signaled otherwise."))
;
;     (make-signature '|lllp| '(|List| (|List| (|List| POINT))) '(%)
;       '("lllp(s) checks to see if the ThreeSpace, s, is "
;         "composed of a list of components, which are lists of curves, "
;         "which are lists of points, and if so, returns the list of "
;         "lists of lists;  An error is signaled otherwise."))
;
;     (make-signature '|llprop| '(|List| (|List| PROP)) '(%)
;       '("llprop(s) checks to see if the ThreeSpace, s, is "
;         "composed of a list of curves which are lists of the"
;         "subspace component properties of the curves, and if so, returns the "
;         "list of lists;  An error is signaled otherwise."))
;
;     (make-signature '|lprop| '(|List| PROP) '(%)
;       '("lprop(s) checks to see if the ThreeSpace, s, is "
;         "composed of a list of subspace component properties, and if so, "
;         "returns the list;  An error is signaled otherwise."))
;
;     (make-signature '|objects| '(OBJ3D) '(%)
;       '("objects(s) returns the ThreeSpace, s, in the form of a "
;         "3D object record containing information on the number of points, "
;         "curves, polygons and constructs comprising the "
;         "ThreeSpace.."))
;
;     (make-signature '|check| '(%) '(%)
;       '("check(s) returns lllpt, list of lists of lists of point information "
;         "about the ThreeSpace} s.")
;
;     (make-signature '|subspace| '(SUBSPACE) '(%)
;       '("subspace(s) returns the SubSpace which holds all the "
;         "point information in the ThreeSpace, s."))
;
;     (make-signature '|coerce| '(O) '(%)
;       '("coerce(s) returns the ThreeSpace s to Output format."))
   ))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ThreeSpaceCategory|
  (progn
    (push '|ThreeSpaceCategory| *Categories*)
    (make-instance '|ThreeSpaceCategoryType|)))

\end{chunk}

\section{Level 4}

\begin{chunk}{defvar level4}
(defvar level4
 '(|AbelianMonoid| |AffineSpaceCategory| |BagAggregate| |CachableSet|
   |Collection| |DifferentialVariableCategory| |ExpressionSpace|
   |FullyPatternMatchable| |GradedAlgebra| |IndexedAggregate|
   |InfinitlyClosePointCategory| |MonadWithUnit| |Monoid|
   |OrderedAbelianSemiGroup| |OrderedFinite| |PlacesCategory|
   |ProjectiveSpaceCategory| |RecursiveAggregate| |TwoDimensionalArrayCategory|))

\end{chunk}

\subsection{AbelianMonoid}
\index[cat]{AbelianMonoid!Category}
\index[cat]{Category!AbelianMonoid}
\index[cat]{ABELMON}
\begin{chunk}{defclass AbelianMonoidType}
(defclass |AbelianMonoidType| (|AbelianSemiGroupType|)
  ((parents :initform '(|AbelianSemiGroup|))
   (name :initform "AbelianMonoid")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'ABELMON)
   (comment :initform (list
     "The class of multiplicative monoids, that is, semigroups with an"
     "additive identity element."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AbelianMonoid|
  (progn
    (push '|AbelianMonoid| *Categories*)
    (make-instance '|AbelianMonoidType|)))

\end{chunk}

\subsection{AffineSpaceCategory}
\index[cat]{AffineSpaceCategory!Category}
\index[cat]{Category!AffineSpaceCategory}
\index[cat]{AFSPCAT}
\begin{chunk}{defclass AffineSpaceCategoryType}
(defclass |AffineSpaceCategoryType| (|SetCategoryWithDegreeType|)
  ((parents :initform '(|SetCategoryWithDegree|))
   (name :initform "AffineSpaceCategory")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'AFSPCAT)
   (comment :initform (list
     "The following is all the categories and domains related to projective"
     "space and part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AffineSpaceCategory|
  (progn
    (push '|AffineSpaceCategory| *Categories*)
    (make-instance '|AffineSpaceCategoryType|)))

\end{chunk}

\subsection{BagAggregate}
\index[cat]{BagAggregate!Category}
\index[cat]{Category!BagAggregate}
\index[cat]{BGAGG}
\begin{chunk}{defclass BagAggregateType}
(defclass |BagAggregateType| (|HomogeneousAggregateType|)
  ((parents :initform '(|HomogeneousAggregate|))
   (name :initform "BagAggregate")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'BGAGG)
   (comment :initform (list
     "A bag aggregate is an aggregate for which one can insert and extract"
     "objects, and where the order in which objects are inserted determines"
     "the order of extraction."
     "Examples of bags are stacks, queues, and dequeues."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BagAggregate|
  (progn
    (push '|BagAggregate| *Categories*)
    (make-instance '|BagAggregateType|)))

\end{chunk}

\subsection{CachableSet}
\index[cat]{CachableSet!Category}
\index[cat]{Category!CachableSet}
\index[cat]{CACHSET}
\begin{chunk}{defclass CachableSetType}
(defclass |CachableSetType| (|OrderedSetType|)
  ((parents :initform '(|OrderedSet|))
   (name :initform "CachableSet")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'CACHSET)
   (comment :initform (list
     "A cachable set is a set whose elements keep an integer as part"
     "of their structure."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CachableSet|
  (progn
    (push '|CachableSet| *Categories*)
    (make-instance '|CachableSetType|)))

\end{chunk}

\subsection{Collection}
\index[cat]{Collection!Category}
\index[cat]{Category!Collection}
\index[cat]{CLAGG}
\begin{chunk}{defclass CollectionType}
(defclass |CollectionType| (|ConvertibleToType| |HomogeneousAggregateType|)
  ((parents  :initform '(|ConvertibleTo| |HomogeneousAggregate|))
   (name :initform "Collection")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'CLAGG)
   (comment :initform (list
     "A collection is a homogeneous aggregate which can built from"
     "list of members. The operation used to build the aggregate is"
     "generically named construct. However, each collection"
     "provides its own special function with the same name as the"
     "data type, except with an initial lower case letter, For example,"
     "list for List, flexibleArray for FlexibleArray, and so on."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Collection|
  (progn
    (push '|Collection| *Categories*)
    (make-instance '|CollectionType|)))

\end{chunk}

\subsection{DifferentialVariableCategory}
\index[cat]{DifferentialVariableCategory!Category}
\index[cat]{Category!DifferentialVariableCategory}
\index[cat]{DVARCAT}
\begin{chunk}{defclass DifferentialVariableCategoryType}
(defclass |DifferentialVariableCategoryType| (|RetractableToType| |OrderedSetType|)
  ((parents :initform '(|RetractableTo| |OrderedSet|))
   (name :initform "DifferentialVariableCategory")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'DVARCAT)
   (comment :initform (list
     "DifferentialVariableCategory constructs the"
     "set of derivatives of a given set of"
     "(ordinary) differential indeterminates."
     "If x,...,y is an ordered set of differential indeterminates,"
     "and the prime notation is used for differentiation, then"
     "the set of derivatives (including"
     "zero-th order) of the differential indeterminates is"
     "x,x',x'',..., y,y',y'',..."
     "(Note that in the interpreter, the n-th derivative of y is displayed as"
     "y with a subscript n.)  This set is"
     "viewed as a set of algebraic indeterminates, totally ordered in a"
     "way compatible with differentiation and the given order on the"
     "differential indeterminates.  Such a total order is called a"
     "ranking of the differential indeterminates."
     " "
     "A domain in this category is needed to construct a differential"
     "polynomial domain.  Differential polynomials are ordered"
     "by a ranking on the derivatives,  and by an order (extending the"
     "ranking) on"
     "on the set of differential monomials.  One may thus associate"
     "a domain in this category with a ranking of the differential"
     "indeterminates, just as one associates a domain in the category"
     "OrderedAbelianMonoidSup with an ordering of the set of"
     "monomials in a set of algebraic indeterminates.  The ranking"
     "is specified through the binary relation <."
     "For example, one may define"
     "one derivative to be less than another by lexicographically comparing"
     "first the order, then the given order of the differential"
     "indeterminates appearing in the derivatives.  This is the default"
     "implementation."
     " "
     "The notion of weight generalizes that of degree.  A"
     "polynomial domain may be made into a graded ring"
     "if a weight function is given on the set of indeterminates,"
     "Very often, a grading is the first step in ordering the set of"
     "monomials.  For differential polynomial domains, this"
     "constructor provides a function weight, which"
     "allows the assignment of a non-negative number to each derivative of a"
     "differential indeterminate.  For example, one may define"
     "the weight of a derivative to be simply its order"
     "(this is the default assignment)."
     "This weight function can then be extended to the set of"
     "all differential polynomials, providing a graded ring structure."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DifferentialVariableCategory|
  (progn
    (push '|DifferentialVariableCategory| *Categories*)
    (make-instance '|DifferentialVariableCategoryType|)))

\end{chunk}

\subsection{ExpressionSpace}
\index[cat]{ExpressionSpace!Category}
\index[cat]{Category!ExpressionSpace}
\index[cat]{ES}
\begin{chunk}{defclass ExpressionSpaceType}
(defclass |ExpressionSpaceType| (|RetractableToType| |EvalableType| |OrderedSetType|)
  ((parents :initform '(|RetractableTo| |Evalable| |OrderedSet|))
   (name :initform "ExpressionSpace")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'ES)
   (comment :initform (list
     "An expression space is a set which is closed under certain operators"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExpressionSpace|
  (progn
    (push '|ExpressionSpace| *Categories*)
    (make-instance '|ExpressionSpaceType|)))

\end{chunk}

\subsection{FullyPatternMatchable}
\index[cat]{FullyPatternMatchable!Category}
\index[cat]{Category!FullyPatternMatchable}
\index[cat]{FPATMAB}
\begin{chunk}{defclass FullyPatternMatchableType}
(defclass |FullyPatternMatchableType| (|TypeType| |PatternMatchableType|)
  ((parents :initform '(|Type| |PatternMatchable|))
   (name :initform "FullyPatternMatchable")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'FPATMAB)
   (comment :initform (list
     "A set S is PatternMatchable over R if S can lift the"
     "pattern-matching functions of S over the integers and float"
     "to itself (necessary for matching in towers)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FullyPatternMatchable|
  (progn
    (push '|FullyPatternMatchable| *Categories*)
    (make-instance '|FullyPatternMatchableType|)))

\end{chunk}

\subsection{GradedAlgebra}
\index[cat]{GradedAlgebra!Category}
\index[cat]{Category!GradedAlgebra}
\index[cat]{GRALG}
\begin{chunk}{defclass GradedAlgebraType}
(defclass |GradedAlgebraType| (|RetractableToType| |GradedModuleType|)
  ((parents :initform '(|RetractableTo| |GradedModule|))
   (name :initform "GradedAlgebra")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'GRALG)
   (comment :initform (list
     "GradedAlgebra(R,E) denotes 'E-graded R-algebra'."
     "A graded algebra is a graded module together with a degree preserving"
     "R-linear map, called the product."
     " "
     "The name 'product' is written out in full so inner and outer products"
     "with the same mapping type can be distinguished by name."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GradedAlgebra|
  (progn
    (push '|GradedAlgebra| *Categories*)
    (make-instance '|GradedAlgebraType|)))

\end{chunk}

\subsection{IndexedAggregate}
\index[cat]{IndexedAggregate!Category}
\index[cat]{Category!IndexedAggregate}
\index[cat]{IXAGG}
\begin{chunk}{defclass IndexedAggregateType}
(defclass |IndexedAggregateType| (|EltableAggregateType| |HomogeneousAggregateType|)
  ((parents  :initform '(|EltableAggregate| |HomogeneousAggregate|))
   (name :initform "IndexedAggregate")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'IXAGG)
   (comment :initform (list
     "An indexed aggregate is a many-to-one mapping of indices to entries."
     "For example, a one-dimensional-array is an indexed aggregate where"
     "the index is an integer.  Also, a table is an indexed aggregate"
     "where the indices and entries may have any type."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedAggregate|
  (progn
    (push '|IndexedAggregate| *Categories*)
    (make-instance '|IndexedAggregateType|)))

\end{chunk}

\subsection{InfinitlyClosePointCategory}
\index[cat]{InfinitlyClosePointCategory!Category}
\index[cat]{Category!InfinitlyClosePointCategory}
\index[cat]{INFCLCT}
\begin{chunk}{defclass InfinitlyClosePointCategoryType}
(defclass |InfinitlyClosePointCategoryType| (|SetCategoryWithDegreeType|)
  ((parents :initform '(|SetCategoryWithDegree|))
   (name :initform "InfinitlyClosePointCategory")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'INFCLCT)
   (comment :initform (list
     "This category is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InfinitlyClosePointCategory|
  (progn
    (push '|InfinitlyClosePointCategory| *Categories*)
    (make-instance '|InfinitlyClosePointCategoryType|)))

\end{chunk}

\subsection{MonadWithUnit}
\index[cat]{MonadWithUnit!Category}
\index[cat]{Category!MonadWithUnit}
\index[cat]{MONADWU}
\begin{chunk}{defclass MonadWithUnitType}
(defclass |MonadWithUnitType| (|MonadType|)
  ((parents :initform '(|Monad|))
   (name :initform "MonadWithUnit")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'MONADWU)
   (comment :initform (list
     "MonadWithUnit is the class of multiplicative monads with unit,"
     "that is, sets with a binary operation and a unit element."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MonadWithUnit|
  (progn
    (push '|MonadWithUnit| *Categories*)
    (make-instance '|MonadWithUnitType|)))

\end{chunk}

\subsection{Monoid}
\index[cat]{Monoid!Category}
\index[cat]{Category!Monoid}
\index[cat]{MONOID}
\begin{chunk}{defclass MonoidType}
(defclass |MonoidType| (|SemiGroupType|)
  ((parents :initform '(|SemiGroup|))
   (name :initform "Monoid")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'MONOID)
   (comment :initform (list
     "The class of multiplicative monoids, that is, semigroups with a"
     "multiplicative identity element."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Monoid|
  (progn
    (push '|Monoid| *Categories*)
    (make-instance '|MonoidType|)))

\end{chunk}

\subsection{OrderedAbelianSemiGroup}
\index[cat]{OrderedAbelianSemiGroup!Category}
\index[cat]{Category!OrderedAbelianSemiGroup}
\index[cat]{OASGP}
\begin{chunk}{defclass |OrderedAbelianSemiGroupType}
(defclass |OrderedAbelianSemiGroupType| (|AbelianSemiGroupType| |OrderedSetType|)
  ((parents :initform '(|AbelianSemiGroup| |OrderedSet|))
   (name :initform "OrderedAbelianSemiGroup")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'OASGP)
   (comment :initform (list
     "Ordered sets which are also abelian semigroups, such that the addition"
     "preserves the ordering."
     " "
     "Axiom x < y => x+z < y+z"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedAbelianSemiGroup|
  (progn
    (push '|OrderedAbelianSemiGroup| *Categories*)
    (make-instance '|OrderedAbelianSemiGroupType|)))

\end{chunk}

\subsection{OrderedFinite}
\index[cat]{OrderedFinite!Category}
\index[cat]{Category!OrderedFinite}
\index[cat]{ORDFIN}
\begin{chunk}{defclass OrderedFiniteType}
(defclass |OrderedFiniteType| (|OrderedSetType| |FiniteType|)
  ((parents :initform '(|OrderedSet| |Finite|))
   (name :initform "OrderedFinite")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'ORDFIN)
   (comment :initform (list
     "Ordered finite sets."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedFinite|
  (progn
    (push '|OrderedFinite| *Categories*)
    (make-instance '|OrderedFiniteType|)))

\end{chunk}

\subsection{PlacesCategory}
\index[cat]{PlacesCategory!Category}
\index[cat]{Category!PlacesCategory}
\index[cat]{PLACESC}
\begin{chunk}{defclass PlacesCategoryType}
(defclass |PlacesCategoryType| (|SetCategoryWithDegreeType|)
  ((parents :initform '(|SetCategoryWithDegree|))
   (name :initform "PlacesCategory")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'PLACESC)
   (comment :initform (list
     "This is part of the PAFF package, related to projective space."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PlacesCategory|
  (progn
    (push '|PlacesCategory| *Categories*)
    (make-instance '|PlacesCategoryType|)))

\end{chunk}

\subsection{ProjectiveSpaceCategory}
\index[cat]{ProjectiveSpaceCategory!Category}
\index[cat]{Category!ProjectiveSpaceCategory}
\index[cat]{PRSPCAT}
\begin{chunk}{defclass ProjectiveSpaceCategoryType}
(defclass |ProjectiveSpaceCategoryType| (|SetCategoryWithDegreeType|)
  ((parents :initform '(|SetCategoryWithDegree|))
   (name :initform "ProjectiveSpaceCategory")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'PRSPCAT)
   (comment :initform (list
     "This is part of the PAFF package, related to projective space."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ProjectiveSpaceCategory|
  (progn
    (push '|ProjectiveSpaceCategory| *Categories*)
    (make-instance '|ProjectiveSpaceCategoryType|)))

\end{chunk}

\subsection{RecursiveAggregate}
\index[cat]{RecursiveAggregate!Category}
\index[cat]{Category!RecursiveAggregate}
\index[cat]{RCAGG}
\begin{chunk}{defclass RecursiveAggregateType}
(defclass |RecursiveAggregateType| (|HomogeneousAggregateType|)
  ((parents :initform '(|HomogeneousAggregate|))
   (name :initform "RecursiveAggregate")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'RCAGG)
   (comment :initform (list
     "A recursive aggregate over a type S is a model for a"
     "a directed graph containing values of type S."
     "Recursively, a recursive aggregate is a node"
     "consisting of a value from S and 0 or more children"
     "which are recursive aggregates."
     "A node with no children is called a leaf node."
     "A recursive aggregate may be cyclic for which some operations as noted"
     "may go into an infinite loop."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RecursiveAggregate|
  (progn
    (push '|RecursiveAggregate| *Categories*)
    (make-instance '|RecursiveAggregateType|)))

\end{chunk}

\subsection{TwoDimensionalArrayCategory}
\index[cat]{TwoDimensionalArrayCategory!Category}
\index[cat]{Category!TwoDimensionalArrayCategory}
\index[cat]{ARR2CAT}
\begin{chunk}{defclass TwoDimensionalArrayCategoryType}
(defclass |TwoDimensionalArrayCategoryType| (|HomogeneousAggregateType|)
  ((parents :initform '(|HomogeneousAggregate|))
   (name :initform "TwoDimensionalArrayCategory")
   (marker :initform 'category)
   (level :initform 4)
   (abbreviation :initform 'ARR2CAT)
   (comment :initform (list
     "Two dimensional array categories and domains"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TwoDimensionalArrayCategory|
  (progn
    (push '|TwoDimensionalArrayCategory| *Categories*)
    (make-instance '|TwoDimensionalArrayCategoryType|)))

\end{chunk}

\section{Level 5}

\begin{chunk}{defvar level5}
(defvar level5 
 '(|BinaryRecursiveAggregate| |CancellationAbelianMonoid| |DesingTreeCategory|
   |DoublyLinkedAggregate| |Group| |LinearAggregate| |MatrixCategory|
   |OrderedAbelianMonoid| |OrderedMonoid| |PolynomialSetCategory|
   |PriorityQueueAggregate| |QueueAggregate| |SetAggregate| |StackAggregate|
   |UnaryRecursiveAggregate|))

\end{chunk}

\subsection{BinaryRecursiveAggregate}
\index[cat]{BinaryRecursiveAggregate!Category}
\index[cat]{Category!BinaryRecursiveAggregate}
\index[cat]{BRAGG}
\begin{chunk}{defclass BinaryRecursiveAggregateType}
(defclass |BinaryRecursiveAggregateType| (|RecursiveAggregateType|)
  ((parents :initform '(|RecursiveAggregate|))
   (name :initform "BinaryRecursiveAggregate")
   (marker :initform 'category)
   (level :initform 5)
   (abbreviation :initform 'BRAGG)
   (comment :initform (list
     "A binary-recursive aggregate has 0, 1 or 2 children and serves"
     "as a model for a binary tree or a doubly-linked aggregate structure"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BinaryRecursiveAggregate|
  (progn
    (push '|BinaryRecursiveAggregate| *Categories*)
    (make-instance '|BinaryRecursiveAggregateType|)))

\end{chunk}

\subsection{CancellationAbelianMonoid}
\index[cat]{CancellationAbelianMonoid!Category}
\index[cat]{Category!CancellationAbelianMonoid}
\index[cat]{CABMON}
\begin{chunk}{defclass CancellationAbelianMonoidType}
(defclass |CancellationAbelianMonoidType| (|AbelianMonoidType|)
  ((parents :initform '(|AbelianMonoid|))
   (name :initform "CancellationAbelianMonoid")
   (marker :initform 'category)
   (level :initform 5)
   (abbreviation :initform 'CABMON)
   (comment :initform (list
     "This is an AbelianMonoid with the cancellation property,"
     "   a+b = a+c => b=c "
     "This is formalised by the partial subtraction operator,"
     "which satisfies the  Axioms"
     "   c = a+b <=> c-b = a"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CancellationAbelianMonoid|
  (progn
    (push '|CancellationAbelianMonoid| *Categories*)
    (make-instance '|CancellationAbelianMonoidType|)))

\end{chunk}

\subsection{DesingTreeCategory}
\index[cat]{DesingTreeCategory!Category}
\index[cat]{Category!DesingTreeCategory}
\index[cat]{DSTRCAT}
\begin{chunk}{defclass DesingTreeCategoryType}
(defclass |DesingTreeCategoryType| (|RecursiveAggregateType|)
  ((parents :initform '(|RecursiveAggregate|))
   (name :initform "DesingTreeCategory")
   (marker :initform 'category)
   (level :initform 5)
   (abbreviation :initform 'DSTRCAT)
   (comment :initform (list
     "This category is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DesingTreeCategory|
  (progn
    (push '|DesingTreeCategory| *Categories*)
    (make-instance '|DesingTreeCategoryType|)))

\end{chunk}

\subsection{DoublyLinkedAggregate}
\index[cat]{DoublyLinkedAggregate!Category}
\index[cat]{Category!DoublyLinkedAggregate}
\index[cat]{DLAGG}
\begin{chunk}{defclass DoublyLinkedAggregateType}
(defclass |DoublyLinkedAggregateType| (|RecursiveAggregateType|)
  ((parents :initform '(|RecursiveAggregate|))
   (name :initform "DoublyLinkedAggregate")
   (marker :initform 'category)
   (level :initform 5)
   (abbreviation :initform 'DLAGG)
   (comment :initform (list
     "A doubly-linked aggregate serves as a model for a doubly-linked"
     "list, that is, a list which can has links to both next and previous"
     "nodes and thus can be efficiently traversed in both directions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DoublyLinkedAggregate|
  (progn
    (push '|DoublyLinkedAggregate| *Categories*)
    (make-instance '|DoublyLinkedAggregateType|)))

\end{chunk}

\subsection{Group}
\index[cat]{Group!Category}
\index[cat]{Category!Group}
\index[cat]{GROUP}
\begin{chunk}{defclass GroupType}
(defclass |GroupType| (|MonoidType|)
  ((parents :initform '(|Monoid|))
   (name :initform "Group")
   (marker :initform 'category)
   (level :initform 5)
   (abbreviation :initform 'GROUP)
   (comment :initform (list
     "The class of multiplicative groups, that is, monoids with"
     "multiplicative inverses."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Group|
  (progn
    (push '|Group| *Categories*)
    (make-instance '|GroupType|)))

\end{chunk}

\subsection{LinearAggregate}
\index[cat]{LinearAggregate!Category}
\index[cat]{Category!LinearAggregate}
\index[cat]{LNAGG}
\begin{chunk}{defclass LinearAggregateType}
(defclass |LinearAggregateType| (|CollectionType| |IndexedAggregateType|)
  ((parents :initform '(|Collection| |IndexedAggregate|))
   (name :initform "LinearAggregate")
   (marker :initform 'category)
   (level :initform 5)
   (abbreviation :initform 'LNAGG)
   (comment :initform (list
     "A linear aggregate is an aggregate whose elements are indexed by integers."
     "Examples of linear aggregates are strings, lists, and"
     "arrays."
     "Most of the exported operations for linear aggregates are non-destructive"
     "but are not always efficient for a particular aggregate."
     "For example, concat of two lists needs only to copy its first"
     "argument, whereas concat of two arrays needs to copy both"
     "arguments. Most of the operations exported here apply to infinite"
     "objects (for example, streams) as well to finite ones."
     "For finite linear aggregates, see FiniteLinearAggregate."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinearAggregate|
  (progn
    (push '|LinearAggregate| *Categories*)
    (make-instance '|LinearAggregateType|)))

\end{chunk}

\subsection{MatrixCategory}
\index[cat]{MatrixCategory!Category}
\index[cat]{Category!MatrixCategory}
\index[cat]{MATCAT}
\begin{chunk}{defclass MatrixCategoryType}
(defclass |MatrixCategoryType| (|TwoDimensionalArrayCategoryType|)
  ((parents :initform '(|TwoDimensionalArrayCategory|))
   (name :initform "MatrixCategory")
   (marker :initform 'category)
   (level :initform 5)
   (abbreviation :initform 'MATCAT)
   (comment :initform (list
     "MatrixCategory is a general matrix category which allows"
     "different representations and indexing schemes.  Rows and"
     "columns may be extracted with rows returned as objects of"
     "type Row and colums returned as objects of type Col."
     "A domain belonging to this category will be shallowly mutable."
     "The index of the 'first' row may be obtained by calling the"
     "function minRowIndex.  The index of the 'first' column may"
     "be obtained by calling the function minColIndex.  The index of"
     "the first element of a Row is the same as the index of the"
     "first column in a matrix and vice versa."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MatrixCategory|
  (progn
    (push '|MatrixCategory| *Categories*)
    (make-instance '|MatrixCategoryType|)))

\end{chunk}

\subsection{OrderedAbelianMonoid}
\index[cat]{OrderedAbelianMonoid!Category}
\index[cat]{Category!OrderedAbelianMonoid}
\index[cat]{OAMON}
\begin{chunk}{defclass OrderedAbelianMonoidType}
(defclass |OrderedAbelianMonoidType| (|AbelianMonoidType| |OrderedAbelianSemiGroupType|)
  ((parents :initform '(|AbelianMonoid| |OrderedAbelianSemiGroup|))
   (name :initform "OrderedAbelianMonoid")
   (marker :initform 'category)
   (level :initform 5)
   (abbreviation :initform 'OAMON)
   (comment :initform (list
     "Ordered sets which are also abelian monoids, such that the addition"
     "preserves the ordering."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedAbelianMonoid|
  (progn
    (push '|OrderedAbelianMonoid| *Categories*)
    (make-instance '|OrderedAbelianMonoidType|)))

\end{chunk}

\subsection{OrderedMonoid}
\index[cat]{OrderedMonoid!Category}
\index[cat]{Category!OrderedMonoid}
\index[cat]{ORDMON}
\begin{chunk}{defclass OrderedMonoidType}
(defclass |OrderedMonoidType| (|OrderedSetType| |MonoidType|)
  ((parents :initform '(|OrderedSet| |Monoid|))
   (name :initform "OrderedMonoid")
   (marker :initform 'category)
   (level :initform 5)
   (abbreviation :initform 'ORDMON)
   (comment :initform (list
     "Ordered sets which are also monoids, such that multiplication"
     "preserves the ordering."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedMonoid|
  (progn
    (push '|OrderedMonoid| *Categories*)
    (make-instance '|OrderedMonoidType|)))

\end{chunk}

\subsection{PolynomialSetCategory}
\index[cat]{PolynomialSetCategory!Category}
\index[cat]{Category!PolynomialSetCategory}
\index[cat]{PSETCAT}
\begin{chunk}{defclass PolynomialSetCategoryType}
(defclass |PolynomialSetCategoryType| (|CollectionType|)
  ((parents :initform '(|Collection|))
   (name :initform "PolynomialSetCategory")
   (marker :initform 'category)
   (level :initform 5)
   (abbreviation :initform 'PSETCAT)
   (comment :initform (list
     "A category for finite subsets of a polynomial ring."
     "Such a set is only regarded as a set of polynomials and not"
     "identified to the ideal it generates. So two distinct sets may"
     "generate the same the ideal. Furthermore, for R being an"
     "integral domain, a set of polynomials may be viewed as a representation"
     "of the ideal it generates in the polynomial ring R)^(-1) P,"
     "or the set of its zeros (described for instance by the radical of the"
     "previous ideal, or a split of the associated affine variety) and so on."
     "So this category provides operations about those different notions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialSetCategory|
  (progn
    (push '|PolynomialSetCategory| *Categories*)
    (make-instance '|PolynomialSetCategoryType|)))

\end{chunk}

\subsection{PriorityQueueAggregate}
\index[cat]{PriorityQueueAggregate!Category}
\index[cat]{Category!PriorityQueueAggregate}
\index[cat]{PRQAGG}
\begin{chunk}{defclass PriorityQueueAggregateType}
(defclass |PriorityQueueAggregateType| (|BagAggregateType|)
  ((parents :initform '(|BagAggregate|))
   (name :initform "PriorityQueueAggregate")
   (marker :initform 'category)
   (level :initform 5)
   (abbreviation :initform 'PRQAGG)
   (comment :initform (list
     "A priority queue is a bag of items from an ordered set where the item"
     "extracted is always the maximum element."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PriorityQueueAggregate|
  (progn
    (push '|PriorityQueueAggregate| *Categories*)
    (make-instance '|PriorityQueueAggregateType|)))

\end{chunk}

\subsection{QueueAggregate}
\index[cat]{QueueAggregate!Category}
\index[cat]{Category!QueueAggregate}
\index[cat]{QUAGG}
\begin{chunk}{defclass QueueAggregateType}
(defclass |QueueAggregateType| (|BagAggregateType|)
  ((parents :initform '(|BagAggregate|))
   (name :initform "QueueAggregate")
   (marker :initform 'category)
   (level :initform 5)
   (abbreviation :initform 'QUAGG)
   (comment :initform (list
     "A queue is a bag where the first item inserted is the first"
     "item extracted."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |QueueAggregate|
  (progn
    (push '|QueueAggregate| *Categories*)
    (make-instance '|QueueAggregateType|)))

\end{chunk}

\subsection{SetAggregate}
\index[cat]{SetAggregate!Category}
\index[cat]{Category!SetAggregate}
\index[cat]{SETAGG}
\begin{chunk}{defclass SetAggregateType}
(defclass |SetAggregateType| (|CollectionType|)
  ((parents :initform '(|Collection|))
   (name :initform "SetAggregate")
   (marker :initform 'category)
   (level :initform 5)
   (abbreviation :initform 'SETAGG)
   (comment :initform (list
     "A set category lists a collection of set-theoretic operations"
     "useful for both finite sets and multisets."
     "Note however that finite sets are distinct from multisets."
     "Although the operations defined for set categories are"
     "common to both, the relationship between the two cannot"
     "be described by inclusion or inheritance."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SetAggregate|
  (progn
    (push '|SetAggregate| *Categories*)
    (make-instance '|SetAggregateType|)))

\end{chunk}

\subsection{StackAggregate}
\index[cat]{StackAggregate!Category}
\index[cat]{Category!StackAggregate}
\index[cat]{SKAGG}
\begin{chunk}{defclass StackAggregateType}
(defclass |StackAggregateType| (|BagAggregateType|)
  ((parents :initform '(|BagAggregate|))
   (name :initform "StackAggregate")
   (marker :initform 'category)
   (level :initform 5)
   (abbreviation :initform 'SKAGG)
   (comment :initform (list
     "A stack is a bag where the last item inserted is the first item extracted."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StackAggregate|
  (progn
    (push '|StackAggregate| *Categories*)
    (make-instance '|StackAggregateType|)))

\end{chunk}

\subsection{UnaryRecursiveAggregate}
\index[cat]{UnaryRecursiveAggregate!Category}
\index[cat]{Category!UnaryRecursiveAggregate}
\index[cat]{URAGG}
\begin{chunk}{defclass UnaryRecursiveAggregateType}
(defclass |UnaryRecursiveAggregateType| (|RecursiveAggregateType|)
  ((parents :initform '(|RecursiveAggregate|))
   (name :initform "UnaryRecursiveAggregate")
   (marker :initform 'category)
   (level :initform 5)
   (abbreviation :initform 'URAGG)
   (comment :initform (list
     "A unary-recursive aggregate is a one where nodes may have either"
     "0 or 1 children."
     "This aggregate models, though not precisely, a linked"
     "list possibly with a single cycle."
     "A node with one children models a non-empty list, with the"
     "value of the list designating the head, or first,"
     "of the list, and the child designating the tail, or rest,"
     "of the list. A node with no child then designates the empty list."
     "Since these aggregates are recursive aggregates, they may be cyclic."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnaryRecursiveAggregate|
  (progn
    (push '|UnaryRecursiveAggregate| *Categories*)
    (make-instance '|UnaryRecursiveAggregateType|)))

\end{chunk}

\section{Level 6}

\begin{chunk}{defvar level6}
(defvar level6
 '(|AbelianGroup| |BinaryTreeCategory| |DequeueAggregate| |DictionaryOperations|
   |ExtensibleLinearAggregate| |FiniteLinearAggregate|
   |FreeAbelianMonoidCategory| 
   |OrderedCancellationAbelianMonoid| |PermutationCategory| |StreamAggregate|
   |TriangularSetCategory|))

\end{chunk}

\subsection{AbelianGroup}
\index[cat]{AbelianGroup!Category}
\index[cat]{Category!AbelianGroup}
\index[cat]{ABELGRP}
\begin{chunk}{defclass AbelianGroupType}
(defclass |AbelianGroupType| (|CancellationAbelianMonoidType|)
  ((parents :initform '(|CancellationAbelianMonoid|))
   (name :initform "AbelianGroup")
   (marker :initform 'category)
   (level :initform 6)
   (abbreviation :initform 'ABELGRP)
   (comment :initform (list
     "The class of abelian groups, additive monoids where"
     "each element has an additive inverse."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AbelianGroup|
  (progn
    (push '|AbelianGroup| *Categories*)
    (make-instance '|AbelianGroupType|)))

\end{chunk}

\subsection{BinaryTreeCategory}
\index[cat]{BinaryTreeCategory!Category}
\index[cat]{Category!BinaryTreeCategory}
\index[cat]{BTCAT}
\begin{chunk}{defclass BinaryTreeCategoryType}
(defclass |BinaryTreeCategoryType| (|BinaryRecursiveAggregateType|)
  ((parents :initform '(|BinaryRecursiveAggregate|))
   (name :initform "BinaryTreeCategory")
   (marker :initform 'category)
   (level :initform 6)
   (abbreviation :initform 'BTCAT)
   (comment :initform (list
     "BinaryTreeCategory(S) is the category of"
     "binary trees: a tree which is either empty or else is a"
     "node consisting of a value and a left and"
     "right, both binary trees. "))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BinaryTreeCategory|
  (progn
    (push '|BinaryTreeCategory| *Categories*)
    (make-instance '|BinaryTreeCategoryType|)))

\end{chunk}

\subsection{DequeueAggregate}
\index[cat]{DequeueAggregate!Category}
\index[cat]{Category!DequeueAggregate}
\index[cat]{DQAGG}
\begin{chunk}{defclass DequeueAggregateType}
(defclass |DequeueAggregateType| (|QueueAggregateType| |StackAggregateType|)
  ((parents :initform '(|QueueAggregate| |StackAggregate|))
   (name :initform "DequeueAggregate")
   (marker :initform 'category)
   (level :initform 6)
   (abbreviation :initform 'DQAGG)
   (comment :initform (list
     "A dequeue is a doubly ended stack, that is, a bag where first items"
     "inserted are the first items extracted, at either the front or"
     "the back end of the data structure."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DequeueAggregate|
  (progn
    (push '|DequeueAggregate| *Categories*)
    (make-instance '|DequeueAggregateType|)))

\end{chunk}

\subsection{DictionaryOperations}
\index[cat]{DictionaryOperations!Category}
\index[cat]{Category!DictionaryOperations}
\index[cat]{DIOPS}
\begin{chunk}{defclass DictionaryOperationsType}
(defclass |DictionaryOperationsType| (|BagAggregateType| |CollectionType|)
  ((parents :initform '(|BagAggregate| |Collection|))
   (name :initform "DictionaryOperations")
   (marker :initform 'category)
   (level :initform 6)
   (abbreviation :initform 'DIOPS)
   (comment :initform (list
     "This category is a collection of operations common to both"
     "categories Dictionary and MultiDictionary"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DictionaryOperations|
  (progn
    (push '|DictionaryOperations| *Categories*)
    (make-instance '|DictionaryOperationsType|)))

\end{chunk}

\subsection{ExtensibleLinearAggregate}
\index[cat]{ExtensibleLinearAggregate!Category}
\index[cat]{Category!ExtensibleLinearAggregate}
\index[cat]{ELAGG}
\begin{chunk}{defclass ExtensibleLinearAggregateType}
(defclass |ExtensibleLinearAggregateType| (|LinearAggregateType|)
  ((parents :initform '(|LinearAggregate|))
   (name :initform "ExtensibleLinearAggregate")
   (marker :initform 'category)
   (level :initform 6)
   (abbreviation :initform 'ELAGG)
   (comment :initform (list
     "An extensible aggregate is one which allows insertion and deletion of"
     "entries. These aggregates are models of lists and streams which are"
     "represented by linked structures so as to make insertion, deletion, and"
     "concatenation efficient. However, access to elements of these"
     "extensible aggregates is generally slow since access is made from the end."
     "See FlexibleArray for an exception."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExtensibleLinearAggregate|
  (progn
    (push '|ExtensibleLinearAggregate| *Categories*)
    (make-instance '|ExtensibleLinearAggregateType|)))

\end{chunk}

\subsection{FiniteLinearAggregate}
\index[cat]{FiniteLinearAggregate!Category}
\index[cat]{Category!FiniteLinearAggregate}
\index[cat]{FLAGG}
\begin{chunk}{defclass FiniteLinearAggregateType}
(defclass |FiniteLinearAggregateType| (|OrderedSetType| |LinearAggregateType|)
  ((parents :initform '(|OrderedSet| |LinearAggregate|))
   (name :initform "FiniteLinearAggregate")
   (marker :initform 'category)
   (level :initform 6)
   (abbreviation :initform 'FLAGG)
   (comment :initform (list
     "A finite linear aggregate is a linear aggregate of finite length."
     "The finite property of the aggregate adds several exports to the"
     "list of exports from LinearAggregate such as"
     "reverse, sort, and so on."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteLinearAggregate|
  (progn
    (push '|FiniteLinearAggregate| *Categories*)
    (make-instance '|FiniteLinearAggregateType|)))

\end{chunk}

\subsection{FreeAbelianMonoidCategory}
\index[cat]{FreeAbelianMonoidCategory!Category}
\index[cat]{Category!FreeAbelianMonoidCategory}
\index[cat]{FAMONC}
\begin{chunk}{defclass FreeAbelianMonoidCategoryType}
(defclass |FreeAbelianMonoidCategoryType| (|RetractableToType| |CancellationAbelianMonoidType|)
  ((parents :initform '(|RetractableTo| |CancellationAbelianMonoid|))
   (name :initform "FreeAbelianMonoidCategory")
   (marker :initform 'category)
   (level :initform 6)
   (abbreviation :initform 'FAMONC)
   (comment :initform (list
     "A free abelian monoid on a set S is the monoid of finite sums of"
     "the form reduce(+,[ni * si]) where the si's are in S, and the ni's"
     "are in a given abelian monoid. The operation is commutative."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FreeAbelianMonoidCategory|
  (progn
    (push '|FreeAbelianMonoidCategory| *Categories*)
    (make-instance '|FreeAbelianMonoidCategoryType|)))

\end{chunk}

\subsection{OrderedCancellationAbelianMonoid}
\index[cat]{OrderedCancellationAbelianMonoid!Category}
\index[cat]{Category!OrderedCancellationAbelianMonoid}
\index[cat]{OCAMON}
\begin{chunk}{defclass OrderedCancellationAbelianMonoidType}
(defclass |OrderedCancellationAbelianMonoidType| (|CancellationAbelianMonoidType|
                                                  |OrderedAbelianMonoidType|)
  ((parents :initform '(|CancellationAbelianMonoid|
                        |OrderedAbelianMonoid|))
   (name :initform "OrderedCancellationAbelianMonoid")
   (marker :initform 'category)
   (level :initform 6)
   (abbreviation :initform 'OCAMON)
   (comment :initform (list
     "Ordered sets which are also abelian cancellation monoids,"
     "such that the addition preserves the ordering."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedCancellationAbelianMonoid|
  (progn
    (push '|OrderedCancellationAbelianMonoid| *Categories*)
    (make-instance '|OrderedCancellationAbelianMonoidType|)))

\end{chunk}

\subsection{PermutationCategory}
\index[cat]{PermutationCategory!Category}
\index[cat]{Category!PermutationCategory}
\index[cat]{PERMCAT}
\begin{chunk}{defclass PermutationCategoryType}
(defclass |PermutationCategoryType| (|OrderedSetType| |GroupType|)
  ((parents :initform '(|OrderedSet| |Group|))
   (name :initform "PermutationCategory")
   (marker :initform 'category)
   (level :initform 6)
   (abbreviation :initform 'PERMCAT)
   (comment :initform (list
     "PermutationCategory provides a categorial environment"
     "for subgroups of bijections of a set (that is, permutations)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PermutationCategory|
  (progn
    (push '|PermutationCategory| *Categories*)
    (make-instance '|PermutationCategoryType|)))

\end{chunk}

\subsection{StreamAggregate}
\index[cat]{StreamAggregate!Category}
\index[cat]{Category!StreamAggregate}
\index[cat]{STAGG}
\begin{chunk}{defclass StreamAggregateType}
(defclass |StreamAggregateType| (|LinearAggregateType| |UnaryRecursiveAggregateType|)
  ((parents :initform '(|LinearAggregate| |UnaryRecursiveAggregate|))
   (name :initform "StreamAggregate")
   (marker :initform 'category)
   (level :initform 6)
   (abbreviation :initform 'STAGG)
   (comment :initform (list
     "A stream aggregate is a linear aggregate which possibly has an infinite"
     "number of elements. A basic domain constructor which builds stream"
     "aggregates is Stream. From streams, a number of infinite"
     "structures such power series can be built. A stream aggregate may"
     "also be infinite since it may be cyclic."
     "For example, see DecimalExpansion."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StreamAggregate|
  (progn
    (push '|StreamAggregate| *Categories*)
    (make-instance '|StreamAggregateType|)))

\end{chunk}

\subsection{TriangularSetCategory}
\index[cat]{TriangularSetCategory!Category}
\index[cat]{Category!TriangularSetCategory}
\index[cat]{TSETCAT}
\begin{chunk}{defclass TriangularSetCategoryType}
(defclass |TriangularSetCategoryType| (|PolynomialSetCategoryType|)
  ((parents :initform '(|PolynomialSetCategory|))
   (name :initform "TriangularSetCategory")
   (marker :initform 'category)
   (level :initform 6)
   (abbreviation :initform 'TSETCAT)
   (comment :initform (list
     "The category of triangular sets of multivariate polynomials"
     "with coefficients in an integral domain."
     "Let R be an integral domain and V a finite ordered set of"
     "variables, say X1 < X2 < ... < Xn."
     "A set S of polynomials in R[X1,X2,...,Xn] is triangular"
     "if no elements of S lies in R, and if two distinct"
     "elements of S have distinct main variables."
     "Note that the empty set is a triangular set. A triangular set is not"
     "necessarily a (lexicographical) Groebner basis and the notion of"
     "reduction related to triangular sets is based on the recursive view"
     "of polynomials. We recall this notion here and refer to [1] for more"
     "details."
     "A polynomial P is reduced w.r.t a non-constant polynomial"
     "Q if the degree of P in the main variable of Q" 
     "is less than the main degree of Q."
     "A polynomial P is reduced w.r.t a triangular set T"
     "if it is reduced w.r.t. every polynomial of T."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TriangularSetCategory|
  (progn
    (push '|TriangularSetCategory| *Categories*)
    (make-instance '|TriangularSetCategoryType|)))

\end{chunk}

\section{Level 7}

\begin{chunk}{defvar level7}
(defvar level7
 '(|Dictionary| |FiniteDivisorCategory| |LazyStreamAggregate| |LeftModule|
   |ListAggregate| |MultiDictionary| |MultisetAggregate| |NonAssociativeRng|
   |OneDimensionalArrayAggregate| |OrderedAbelianGroup| |OrderedAbelianMonoidSup|
   |RegularTriangularSetCategory| |RightModule| |Rng|))

\end{chunk}

\subsection{Dictionary}
\index[cat]{Dictionary!Category}
\index[cat]{Category!Dictionary}
\index[cat]{DIAGG}
\begin{chunk}{defclass DictionaryType}
(defclass |DictionaryType| (|DictionaryOperationsType|)
  ((parents :initform '(|DictionaryOperations|))
   (name :initform "Dictionary")
   (marker :initform 'category)
   (level :initform 7)
   (abbreviation :initform 'DIAGG)
   (comment :initform (list
     "A dictionary is an aggregate in which entries can be inserted,"
     "searched for and removed. Duplicates are thrown away on insertion."
     "This category models the usual notion of dictionary which involves"
     "large amounts of data where copying is impractical."
     "Principal operations are thus destructive (non-copying) ones."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Dictionary|
  (progn
    (push '|Dictionary| *Categories*)
    (make-instance '|DictionaryType|)))

\end{chunk}

\subsection{FiniteDivisorCategory}
\index[cat]{FiniteDivisorCategory!Category}
\index[cat]{Category!FiniteDivisorCategory}
\index[cat]{FDIVCAT}
\begin{chunk}{defclass FiniteDivisorCategoryType}
(defclass |FiniteDivisorCategoryType| (|AbelianGroupType|)
  ((parents :initform '(|AbelianGroup|))
   (name :initform "FiniteDivisorCategory")
   (marker :initform 'category)
   (level :initform 7)
   (abbreviation :initform 'FDIVCAT)
   (comment :initform (list
     "This category describes finite rational divisors on a curve, that"
     "is finite formal sums SUM(n * P) where the n's are integers and the"
     "P's are finite rational points on the curve."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteDivisorCategory|
  (progn
    (push '|FiniteDivisorCategory| *Categories*)
    (make-instance '|FiniteDivisorCategoryType|)))

\end{chunk}

\subsection{LazyStreamAggregate}
\index[cat]{LazyStreamAggregate!Category}
\index[cat]{Category!LazyStreamAggregate}
\index[cat]{LZSTAGG}
\begin{chunk}{defclass LazyStreamAggregateType}
(defclass |LazyStreamAggregateType| (|StreamAggregateType|)
  ((parents :initform '(|StreamAggregate|))
   (name :initform "LazyStreamAggregate")
   (marker :initform 'category)
   (level :initform 7)
   (abbreviation :initform 'LZSTAGG)
   (comment :initform (list
     "LazyStreamAggregate is the category of streams with lazy"
     "evaluation.  It is understood that the function 'empty?' will"
     "cause lazy evaluation if necessary to determine if there are"
     "entries.  Functions which call 'empty?', for example 'first' and 'rest',"
     "will also cause lazy evaluation if necessary."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LazyStreamAggregate|
  (progn
    (push '|LazyStreamAggregate| *Categories*)
    (make-instance '|LazyStreamAggregateType|)))

\end{chunk}

\subsection{LeftModule}
\index[cat]{LeftModule!Category}
\index[cat]{Category!LeftModule}
\index[cat]{LMODULE}
\begin{chunk}{defclass LeftModuleType}
(defclass |LeftModuleType| (|AbelianGroupType|)
  ((parents :initform '(|AbelianGroup|))
   (name :initform "LeftModule")
   (marker :initform 'category)
   (level :initform 7)
   (abbreviation :initform 'LMODULE)
   (comment :initform (list
     "This is an abelian group which supports left multiplication by elements of"
     "the rng."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LeftModule|
  (progn
    (push '|LeftModule| *Categories*)
    (make-instance '|LeftModuleType|)))

\end{chunk}

\subsection{ListAggregate}
\index[cat]{ListAggregate!Category}
\index[cat]{Category!ListAggregate}
\index[cat]{LSAGG}
\begin{chunk}{defclass ListAggregateType}
(defclass |ListAggregateType| (|ExtensibleLinearAggregateType|
                               |FiniteLinearAggregateType|
                               |StreamAggregateType|)
  ((parents :initform '(|ExtensibleLinearAggregate| 
                          |FiniteLinearAggregate| 
                          |StreamAggregate|))
   (name :initform "ListAggregate")
   (marker :initform 'category)
   (level :initform 7)
   (abbreviation :initform 'LSAGG)
   (comment :initform (list
     "A list aggregate is a model for a linked list data structure."
     "A linked list is a versatile"
     "data structure. Insertion and deletion are efficient and"
     "searching is a linear operation."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ListAggregate|
  (progn
    (push '|ListAggregate| *Categories*)
    (make-instance '|ListAggregateType|)))

\end{chunk}

\subsection{MultiDictionary}
\index[cat]{MultiDictionary!Category}
\index[cat]{Category!MultiDictionary}
\index[cat]{MDAGG}
\begin{chunk}{defclass MultiDictionaryType}
(defclass |MultiDictionaryType| (|DictionaryOperationsType|)
  ((parents :initform '(|DictionaryOperations|))
   (name :initform "MultiDictionary")
   (marker :initform 'category)
   (level :initform 7)
   (abbreviation :initform 'MDAGG)
   (comment :initform (list
     "A multi-dictionary is a dictionary which may contain duplicates."
     "As for any dictionary, its size is assumed large so that"
     "copying (non-destructive) operations are generally to be avoided."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MultiDictionary|
  (progn
    (push '|MultiDictionary| *Categories*)
    (make-instance '|MultiDictionaryType|)))

\end{chunk}

\subsection{MultisetAggregate}
\index[cat]{MultisetAggregate!Category}
\index[cat]{Category!MultisetAggregate}
\index[cat]{MSETAGG}
\begin{chunk}{defclass MultisetAggregateType}
(defclass |MultisetAggregateType| (|SetAggregateType| |MultiDictionaryType|)
  ((parents :initform '(|SetAggregate| |MultiDictionary|))
   (name :initform "MultisetAggregate")
   (marker :initform 'category)
   (level :initform 7)
   (abbreviation :initform 'MSETAGG)
   (comment :initform (list
     "A multi-set aggregate is a set which keeps track of the multiplicity"
     "of its elements."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MultisetAggregate|
  (progn
    (push '|MultisetAggregate| *Categories*)
    (make-instance '|MultisetAggregateType|)))

\end{chunk}

\subsection{NonAssociativeRng}
\index[cat]{NonAssociativeRng!Category}
\index[cat]{Category!NonAssociativeRng}
\index[cat]{NARNG}
\begin{chunk}{defclass NonAssociativeRngType}
(defclass |NonAssociativeRngType| (|MonadType| |AbelianGroupType|)
  ((parents :initform '(|Monad| |AbelianGroup|))
   (name :initform "NonAssociativeRng")
   (marker :initform 'category)
   (level :initform 7)
   (abbreviation :initform 'NARGN)
   (comment :initform (list
     "NonAssociativeRng is a basic ring-type structure, not necessarily"
     "commutative or associative, and not necessarily with unit."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NonAssociativeRng|
  (progn
    (push '|NonAssociativeRng| *Categories*)
    (make-instance '|NonAssociativeRngType|)))

\end{chunk}

\subsection{OneDimensionalArrayAggregate}
\index[cat]{OneDimensionalArrayAggregate!Category}
\index[cat]{Category!OneDimensionalArrayAggregate}
\index[cat]{A1AGG}
\begin{chunk}{defclass OneDimensionalArrayAggregateType}
(defclass |OneDimensionalArrayAggregateType| (|FiniteLinearAggregateType|)
  ((parents  :initform '(|FiniteLinearAggregate|))
   (name :initform "OneDimensionalArrayAggregate")
   (marker :initform 'category)
   (level :initform 7)
   (abbreviation :initform 'A1AGG)
   (comment :initform (list
     "One-dimensional-array aggregates serves as models for one-dimensional"
     "arrays. Categorically, these aggregates are finite linear aggregates"
     "with the shallowlyMutable property, that is, any component of"
     "the array may be changed without affecting the"
     "identity of the overall array."
     "Array data structures are typically represented by a fixed area in"
     "storage and cannot efficiently grow or shrink on demand as can list"
     "structures (see however FlexibleArray for a data structure"
     "which is a cross between a list and an array)."
     "Iteration over, and access to, elements of arrays is extremely fast"
     "(and often can be optimized to open-code)."
     "Insertion and deletion however is generally slow since an entirely new"
     "data structure must be created for the result."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OneDimensionalArrayAggregate|
  (progn
    (push '|OneDimensionalArrayAggregate| *Categories*)
    (make-instance '|OneDimensionalArrayAggregateType|)))

\end{chunk}

\subsection{OrderedAbelianGroup}
\index[cat]{OrderedAbelianGroup!Category}
\index[cat]{Category!OrderedAbelianGroup}
\index[cat]{OAGROUP}
\begin{chunk}{defclass OrderedAbelianGroupType}
(defclass |OrderedAbelianGroupType| (|AbelianGroupType| |OrderedCancellationAbelianMonoidType|)
  ((parents :initform '(|AbelianGroup| |OrderedCancellationAbelianMonoid|))
   (name :initform "OrderedAbelianGroup")
   (marker :initform 'category)
   (level :initform 7)
   (abbreviation :initform 'OAGROUP)
   (comment :initform (list
     "Ordered sets which are also abelian groups, such that the"
     "addition preserves the ordering."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedAbelianGroup|
  (progn
    (push '|OrderedAbelianGroup| *Categories*)
    (make-instance '|OrderedAbelianGroupType|)))

\end{chunk}

\subsection{OrderedAbelianMonoidSup}
\index[cat]{OrderedAbelianMonoidSup!Category}
\index[cat]{Category!OrderedAbelianMonoidSup}
\index[cat]{OAMONS}
\begin{chunk}{defclass OrderedAbelianMonoidSupType}
(defclass |OrderedAbelianMonoidSupType| (|OrderedCancellationAbelianMonoidType|)
  ((parents  :initform '(|OrderedCancellationAbelianMonoid|))
   (name :initform "OrderedAbelianMonoidSup")
   (marker :initform 'category)
   (level :initform 7)
   (abbreviation :initform 'OAMONS)
   (comment :initform (list
     "This domain is an OrderedAbelianMonoid with a sup"
     "operation added. The purpose of the sup operator"
     "in this domain is to act as a supremum with respect to the"
     "partial order imposed by `-`, rather than with respect to"
     "the total > order (since that is 'max')."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedAbelianMonoidSup|
  (progn
    (push '|OrderedAbelianMonoidSup| *Categories*)
    (make-instance '|OrderedAbelianMonoidSupType|)))

\end{chunk}

\subsection{RegularTriangularSetCategory}
\index[cat]{RegularTriangularSetCategory!Category}
\index[cat]{Category!RegularTriangularSetCategory}
\index[cat]{RSETCAT}
\begin{chunk}{defclass RegularTriangularSetCategoryType}
(defclass |RegularTriangularSetCategoryType| (|TriangularSetCategoryType|)
  ((parents :initform '(|TriangularSetCategory|))
   (name :initform "RegularTriangularSetCategory")
   (marker :initform 'category)
   (level :initform 7)
   (abbreviation :initform 'RSETCAT)
   (comment :initform (list
     "The category of regular triangular sets, introduced under"
     "the name regular chains in [1] (and other papers)."
     "In [3] it is proved that regular triangular sets and towers of simple"
     "extensions of a field are equivalent notions."
     "In the following definitions, all polynomials and ideals"
     "are taken from the polynomial ring k[x1,...,xn] where k"
     "is the fraction field of R."
     "The triangular set [t1,...,tm] is regular"
     "iff for every id} the initial of ti+1 is invertible"
     "in the tower of simple extensions associated with [t1,...,ti]."
     "A family [T1,...,Ts] of regular triangular sets"
     "is a split of Kalkbrener of a given ideal I"
     "iff the radical of I is equal to the intersection"
     "of the radical ideals generated by the saturated ideals"
     "of the [T1,...,Ti]."
     "A family [T1,...,Ts] of regular triangular sets"
     "is a split of Kalkbrener of a given triangular set T"
     "iff it is a split of Kalkbrener of the saturated ideal of T."
     "Let K be an algebraic closure of k."
     "Assume that V is finite with cardinality"
     "n and let A be the affine space K^n."
     "For a regular triangular set T let denote by W(T) the"
     "set of regular zeros of T."
     "A family [T1,...,Ts] of regular triangular sets"
     "is a split of Lazard of a given subset S of A"
     "iff the union of the W(Ti) contains S and"
     "is contained in the closure of S (w.r.t. Zariski topology)."
     "A family [T1,...,Ts] of regular triangular sets"
     "is a split of Lazard of a given triangular set T"
     "if it is a split of Lazard of W(T)."
     "Note that if [T1,...,Ts] is a split of Lazard of"
     "T then it is also a split of Kalkbrener of T."
     "The converse is false."
     "This category provides operations related to both kinds of"
     "splits, the former being related to ideals decomposition whereas"
     "the latter deals with varieties decomposition."
     "See the example illustrating the RegularTriangularSet constructor for more"
     "explanations about decompositions by means of regular triangular sets."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RegularTriangularSetCategory|
  (progn
    (push '|RegularTriangularSetCategory| *Categories*)
    (make-instance '|RegularTriangularSetCategoryType|)))

\end{chunk}

\subsection{RightModule}
\index[cat]{RightModule!Category}
\index[cat]{Category!RightModule}
\index[cat]{RMODULE}
\begin{chunk}{defclass RightModuleType}
(defclass |RightModuleType| (|AbelianGroupType|)
  ((parents :initform '(|AbelianGroup|))
   (name :initform "RightModule")
   (marker :initform 'category)
   (level :initform 7)
   (abbreviation :initform 'RMODULE)
   (comment :initform (list
     "The category of right modules over an rng (ring not necessarily"
     "with unit). This is an abelian group which supports right"
     "multiplication by elements of the rng."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RightModule|
  (progn
    (push '|RightModule| *Categories*)
    (make-instance '|RightModuleType|)))

\end{chunk}

\subsection{Rng}
\index[cat]{Rng!Category}
\index[cat]{Category!Rng}
\index[cat]{RNG}
\begin{chunk}{defclass RngType}
(defclass |RngType| (|SemiGroupType| |AbelianGroupType|)
  ((parents :initform '(|SemiGroup| |AbelianGroup|))
   (name :initform "Rng")
   (marker :initform 'category)
   (level :initform 7)
   (abbreviation :initform 'RNG)
   (comment :initform (list
     "The category of associative rings, not necessarily commutative, and not"
     "necessarily with a 1. This is a combination of an abelian group"
     "and a semigroup, with multiplication distributing over addition."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Rng|
  (progn
    (push '|Rng| *Categories*)
    (make-instance '|RngType|)))

\end{chunk}

\section{Level 8}

\begin{chunk}{defvar level8}
(defvar level8
 '(|BiModule| |BitAggregate| |FiniteSetAggregate| |KeyedDictionary|
   |NonAssociativeRing| |NormalizedTriangularSetCategory|
   |OrderedMultisetAggregate| |Ring| |SquareFreeRegularTriangularSetCategory|
   |StringAggregate| |VectorCategory|))

\end{chunk}

\subsection{BiModule}
\index[cat]{BiModule!Category}
\index[cat]{Category!BiModule}
\index[cat]{BMODULE}
\begin{chunk}{defclass BiModuleType}
(defclass |BiModuleType| (|LeftModuleType| |RightModuleType|)
  ((parents :initform '(|LeftModule| |RightModule|))
   (name :initform "BiModule")
   (marker :initform 'category)
   (level :initform 8)
   (abbreviation :initform 'BMODULE)
   (comment :initform (list
     "A BiModule is both a left and right module with respect"
     "to potentially different rings."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BiModule|
  (progn
    (push '|BiModule| *Categories*)
    (make-instance '|BiModuleType|)))

\end{chunk}

\subsection{BitAggregate}
\index[cat]{BitAggregate!Category}
\index[cat]{Category!BitAggregate}
\index[cat]{BTAGG}
\begin{chunk}{defclass |BitAggregateType}
(defclass |BitAggregateType| (|LogicType| |OneDimensionalArrayAggregateType|)
  ((parents :initform '(|Logic| |OneDimensionalArrayAggregate|))
   (name :initform "BitAggregate")
   (marker :initform 'category)
   (level :initform 8)
   (abbreviation :initform 'BTAGG)
   (comment :initform (list
     "The bit aggregate category models aggregates representing large"
     "quantities of Boolean data."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BitAggregate|
  (progn
    (push '|BitAggregate| *Categories*)
    (make-instance '|BitAggregateType|)))

\end{chunk}

\subsection{FiniteSetAggregate}
\index[cat]{FiniteSetAggregate!Category}
\index[cat]{Category!FiniteSetAggregate}
\index[cat]{FSAGG}
\begin{chunk}{defclass FiniteSetAggregateType}
(defclass |FiniteSetAggregateType| (|FiniteType| |SetAggregateType| |DictionaryType|)
  ((parents :initform '(|Finite| |SetAggregate| |Dictionary|))
   (name :initform "FiniteSetAggregate")
   (marker :initform 'category)
   (level :initform 8)
   (abbreviation :initform 'FSAGG)
   (comment :initform (list
     "A finite-set aggregate models the notion of a finite set, that is,"
     "a collection of elements characterized by membership, but not"
     "by order or multiplicity."
     "See Set for an example."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteSetAggregate|
  (progn
    (push '|FiniteSetAggregate| *Categories*)
    (make-instance '|FiniteSetAggregateType|)))

\end{chunk}

\subsection{KeyedDictionary}
\index[cat]{KeyedDictionary!Category}
\index[cat]{Category!KeyedDictionary}
\index[cat]{KDAGG}
\begin{chunk}{defclass KeyedDictionaryType}
(defclass |KeyedDictionaryType| (|DictionaryType|)
  ((parents :initform '(|Dictionary|))
   (name :initform "KeyedDictionary")
   (marker :initform 'category)
   (level :initform 8)
   (abbreviation :initform 'KDAGG)
   (comment :initform (list
     "A keyed dictionary is a dictionary of key-entry pairs for which there is"
     "a unique entry for each key."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |KeyedDictionary|
  (progn
    (push '|KeyedDictionary| *Categories*)
    (make-instance '|KeyedDictionaryType|)))

\end{chunk}

\subsection{NonAssociativeRing}
\index[cat]{NonAssociativeRing!Category}
\index[cat]{Category!NonAssociativeRing}
\index[cat]{NASRING}
\begin{chunk}{defclass NonAssociativeRingType}
(defclass |NonAssociativeRingType| (|MonadWithUnitType| |NonAssociativeRngType|)
  ((parents :initform '(|MonadWithUnit| |NonAssociativeRng|))
   (name :initform "NonAssociativeRing")
   (marker :initform 'category)
   (level :initform 8)
   (abbreviation :initform 'NASRING)
   (comment :initform (list
     "A NonAssociativeRing is a non associative rng which has a unit,"
     "the multiplication is not necessarily commutative or associative."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NonAssociativeRing|
  (progn
    (push '|NonAssociativeRing| *Categories*)
    (make-instance '|NonAssociativeRingType|)))

\end{chunk}

\subsection{NormalizedTriangularSetCategory}
\index[cat]{NormalizedTriangularSetCategory!Category}
\index[cat]{Category!NormalizedTriangularSetCategory}
\index[cat]{NTSCAT}
\begin{chunk}{defclass NormalizedTriangularSetCategoryType}
(defclass |NormalizedTriangularSetCategoryType| (|RegularTriangularSetCategoryType|)
  ((parents :initform '(|RegularTriangularSetCategory|))
   (name :initform "NormalizedTriangularSetCategory")
   (marker :initform 'category)
   (level :initform 8)
   (abbreviation :initform 'NTSCAT)
   (comment :initform (list
     "The category of normalized triangular sets. A triangular"
     "set ts is said normalized if for every algebraic"
     "variable v of ts the polynomial select(ts,v)"
     "is normalized w.r.t. every polynomial in collectUnder(ts,v)."
     "A polynomial p is said normalized w.r.t. a non-constant"
     "polynomial q if p is constant or degree(p,mdeg(q)) = 0"
     "and init(p) is normalized w.r.t. q. One of the important"
     "features of normalized triangular sets is that they are regular sets."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NormalizedTriangularSetCategory|
  (progn
    (push '|NormalizedTriangularSetCategory| *Categories*)
    (make-instance '|NormalizedTriangularSetCategoryType|)))

\end{chunk}

\subsection{OrderedMultisetAggregate}
\index[cat]{OrderedMultisetAggregate!Category}
\index[cat]{Category!OrderedMultisetAggregate}
\index[cat]{OMSAGG}
\begin{chunk}{defclass OrderedMultisetAggregateType}
(defclass |OrderedMultisetAggregateType| (|MultisetAggregateType| |PriorityQueueAggregateType|)
  ((parents :initform '(|MultisetAggregate| |PriorityQueueAggregate|))
   (name :initform "OrderedMultisetAggregate")
   (marker :initform 'category)
   (level :initform 8)
   (abbreviation :initform 'OMSAGG)
   (comment :initform (list
     "An ordered-multiset aggregate is a multiset built over an ordered set S"
     "so that the relative sizes of its entries can be assessed."
     "These aggregates serve as models for priority queues."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedMultisetAggregate|
  (progn
    (push '|OrderedMultisetAggregate| *Categories*)
    (make-instance '|OrderedMultisetAggregateType|)))

\end{chunk}

\subsection{Ring}
\index[cat]{Ring!Category}
\index[cat]{Category!Ring}
\index[cat]{RING}
\begin{chunk}{defclass RingType}
(defclass |RingType| (|MonoidType| |LeftModuleType| |RngType|)
  ((parents :initform '(|Monoid| |LeftModule| |Rng|))
   (name :initform "Ring")
   (marker :initform 'category)
   (level :initform 8)
   (abbreviation :initform 'RING)
   (comment :initform (list
     "The category of rings with unity, always associative, but"
     "not necessarily commutative."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Ring|
  (progn
    (push '|Ring| *Categories*)
    (make-instance '|RingType|)))

\end{chunk}

\subsection{SquareFreeRegularTriangularSetCategory}
\index[cat]{SquareFreeRegularTriangularSetCategory!Category}
\index[cat]{Category!SquareFreeRegularTriangularSetCategory}
\index[cat]{SFRTCAT}
\begin{chunk}{defclass SquareFreeRegularTriangularSetCategoryType}
(defclass |SquareFreeRegularTriangularSetCategoryType| (|RegularTriangularSetCategoryType|)
  ((parents :initform '(|RegularTriangularSetCategory|))
   (name :initform "SquareFreeRegularTriangularSetCategory")
   (marker :initform 'category)
   (level :initform 8)
   (abbreviation :initform 'SFRTCAT)
   (comment :initform (list
     "The category of square-free regular triangular sets."
     "A regular triangular set ts is square-free if"
     "the gcd of any polynomial p in ts and"
     "differentiate(p,mvar(p)) w.r.t. collectUnder(ts,mvar(p))"
     "has degree zero w.r.t. mvar(p). Thus any square-free regular"
     "set defines a tower of square-free simple extensions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SquareFreeRegularTriangularSetCategory|
  (progn
    (push '|SquareFreeRegularTriangularSetCategory| *Categories*)
    (make-instance '|SquareFreeRegularTriangularSetCategoryType|)))

\end{chunk}

\subsection{StringAggregate}
\index[cat]{StringAggregate!Category}
\index[cat]{Category!StringAggregate}
\index[cat]{SRAGG}
\begin{chunk}{defclass StringAggregateType}
(defclass |StringAggregateType| (|OneDimensionalArrayAggregateType|)
  ((parents :initform '(|OneDimensionalArrayAggregate|))
   (name :initform "StringAggregate")
   (marker :initform 'category)
   (level :initform 8)
   (abbreviation :initform 'SRAGG)
   (comment :initform (list
     "A string aggregate is a category for strings, that is,"
     "one dimensional arrays of characters."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StringAggregate|
  (progn
    (push '|StringAggregate| *Categories*)
    (make-instance '|StringAggregateType|)))

\end{chunk}

\subsection{VectorCategory}
\index[cat]{VectorCategory!Category}
\index[cat]{Category!VectorCategory}
\index[cat]{VECTCAT}
\begin{chunk}{defclass |VectorCategoryType}
(defclass |VectorCategoryType| (|OneDimensionalArrayAggregateType|)
  ((parents :initform '(|OneDimensionalArrayAggregate|))
   (name :initform "VectorCategory")
   (marker :initform 'category)
   (level :initform 8)
   (abbreviation :initform 'VECTCAT)
   (comment :initform (list
     "VectorCategory represents the type of vector like objects,"
     "that is, finite sequences indexed by some finite segment of the"
     "integers. The operations available on vectors depend on the structure"
     "of the underlying components. Many operations from the component domain"
     "are defined for vectors componentwise. It can by assumed that extraction or"
     "updating components can be done in constant time."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |VectorCategory|
  (progn
    (push '|VectorCategory| *Categories*)
    (make-instance '|VectorCategoryType|)))

\end{chunk}

\section{Level 9}

\begin{chunk}{defvar level9}
(defvar level9
 '(|CharacteristicNonZero| |CharacteristicZero| |CommutativeRing|
   |DifferentialRing| |EntireRing| |LeftAlgebra| |LinearlyExplicitRingOver|
   |Module| |OrderedRing| |PartialDifferentialRing| |PointCategory|
   |SquareFreeNormalizedTriangularSetCategory| |StringCategory| |TableAggregate|))

\end{chunk}

\subsection{CharacteristicNonZero}
\index[cat]{CharacteristicNonZero!Category}
\index[cat]{Category!CharacteristicNonZero}
\index[cat]{CHARNZ}
\begin{chunk}{defclass CharacteristicNonZeroType}
(defclass |CharacteristicNonZeroType| (|RingType|)
  ((parents :initform '(|Ring|))
   (name :initform "CharacteristicNonZero")
   (marker :initform 'category)
   (level :initform 9)
   (abbreviation :initform 'CHARNZ)
   (comment :initform (list
     "Rings of Characteristic Non Zero"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CharacteristicNonZero|
  (progn
    (push '|CharacteristicNonZero| *Categories*)
    (make-instance '|CharacteristicNonZeroType|)))

\end{chunk}

\subsection{CharacteristicZero}
\index[cat]{CharacteristicZero!Category}
\index[cat]{Category!CharacteristicZero}
\index[cat]{CHARZ}
\begin{chunk}{defclass CharacteristicZeroType}
(defclass |CharacteristicZeroType| (|RingType|)
  ((parents :initform '(|Ring|))
   (name :initform "CharacteristicZero")
   (marker :initform 'category)
   (level :initform 9)
   (abbreviation :initform 'CHARZ)
   (comment :initform (list
     "Rings of Characteristic Zero."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CharacteristicZero|
  (progn
    (push '|CharacteristicZero| *Categories*)
    (make-instance '|CharacteristicZeroType|)))

\end{chunk}

\subsection{CommutativeRing}
\index[cat]{CommutativeRing!Category}
\index[cat]{Category!CommutativeRing}
\index[cat]{COMRING}
\begin{chunk}{defclass CommutativeRingType}
(defclass |CommutativeRingType| (|RingType| |BiModuleType|)
  ((parents :initform '(|Ring| |BiModule|))
   (name :initform "CommutativeRing")
   (marker :initform 'category)
   (level :initform 9)
   (abbreviation :initform 'COMRING)
   (comment :initform (list
     "The category of commutative rings with unity, rings where"
     "* is commutative, and which have a multiplicative identity"
     "element."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CommutativeRing|
  (progn
    (push '|CommutativeRing| *Categories*)
    (make-instance '|CommutativeRingType|)))

\end{chunk}

\subsection{DifferentialRing}
\index[cat]{DifferentialRing!Category}
\index[cat]{Category!DifferentialRing}
\index[cat]{DIFRING}
\begin{chunk}{defclass DifferentialRingType}
(defclass |DifferentialRingType| (|RingType|)
  ((parents :initform '(|Ring|))
   (name :initform "DifferentialRing")
   (marker :initform 'category)
   (level :initform 9)
   (abbreviation :initform 'DIFRING)
   (comment :initform (list
     "An ordinary differential ring, that is, a ring with an operation"
     "differentiate."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DifferentialRing|
  (progn
    (push '|DifferentialRing| *Categories*)
    (make-instance '|DifferentialRingType|)))

\end{chunk}

\subsection{EntireRing}
\index[cat]{EntireRing!Category}
\index[cat]{Category!EntireRing}
\index[cat]{ENTIRER}
\begin{chunk}{defclass EntireRingType}
(defclass |EntireRingType| (|RingType| |BiModuleType|)
  ((parents :initform '(|Ring| |BiModule|))
   (name :initform "EntireRing")
   (marker :initform 'category)
   (level :initform 9)
   (abbreviation :initform 'ENTIRER)
   (comment :initform (list
     "Entire Rings (non-commutative Integral Domains), a ring"
     "not necessarily commutative which has no zero divisors."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |EntireRing|
  (progn
    (push '|EntireRing| *Categories*)
    (make-instance '|EntireRingType|)))

\end{chunk}

\subsection{LeftAlgebra}
\index[cat]{LeftAlgebra!Category}
\index[cat]{Category!LeftAlgebra}
\index[cat]{LALG}
\begin{chunk}{defclass LeftAlgebraType}
(defclass |LeftAlgebraType| (|RingType|)
  ((parents :initform '(|Ring|))
   (name :initform "LeftAlgebra")
   (marker :initform 'category)
   (level :initform 9)
   (abbreviation :initform 'LALG)
   (comment :initform (list
     "The category of all left algebras over an arbitrary ring."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LeftAlgebra|
  (progn
    (push '|LeftAlgebra| *Categories*)
    (make-instance '|LeftAlgebraType|)))

\end{chunk}

\subsection{LinearlyExplicitRingOver}
\index[cat]{LinearlyExplicitRingOver!Category}
\index[cat]{Category!LinearlyExplicitRingOver}
\index[cat]{LINEXP}
\begin{chunk}{defclass LinearlyExplicitRingOverType}
(defclass |LinearlyExplicitRingOverType| (|RingType|)
  ((parents :initform '(|Ring|))
   (name :initform "LinearlyExplicitRingOver")
   (marker :initform 'category)
   (level :initform 9)
   (abbreviation :initform 'LINEXP)
   (comment :initform (list
     "An extension ring with an explicit linear dependence test."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinearlyExplicitRingOver|
  (progn
    (push '|LinearlyExplicitRingOver| *Categories*)
    (make-instance '|LinearlyExplicitRingOverType|)))

\end{chunk}

\subsection{Module}
\index[cat]{Module!Category}
\index[cat]{Category!Module}
\index[cat]{MODULE}
\begin{chunk}{defclass ModuleType}
(defclass |ModuleType| (|BiModuleType|)
  ((parents :initform '(|BiModule|))
   (name :initform "Module")
   (marker :initform 'category)
   (level :initform 9)
   (abbreviation :initform 'MODULE)
   (comment :initform (list
     "The category of modules over a commutative ring."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Module|
  (progn
    (push '|Module| *Categories*)
    (make-instance '|ModuleType|)))

\end{chunk}

\subsection{OrderedRing}
\index[cat]{OrderedRing!Category}
\index[cat]{Category!OrderedRing}
\index[cat]{ORDRING}
\begin{chunk}{defclass OrderedRingType}
(defclass |OrderedRingType| (|OrderedAbelianGroupType| |RingType|)
  ((parents :initform '(|OrderedAbelianGroup| |Ring|))
   (name :initform "OrderedRing")
   (marker :initform 'category)
   (level :initform 9)
   (abbreviation :initform 'ORDRING)
   (comment :initform (list
     "Ordered sets which are also rings, that is, domains where the ring"
     "operations are compatible with the ordering."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedRing|
  (progn
    (push '|OrderedRing| *Categories*)
    (make-instance '|OrderedRingType|)))

\end{chunk}

\subsection{PartialDifferentialRing}
\index[cat]{PartialDifferentialRing!Category}
\index[cat]{Category!PartialDifferentialRing}
\index[cat]{PDRING}
\begin{chunk}{defclass PartialDifferentialRingType}
(defclass |PartialDifferentialRingType| (|RingType|)
  ((parents :initform '(|Ring|))
   (name :initform "PartialDifferentialRing")
   (marker :initform 'category)
   (level :initform 9)
   (abbreviation :initform 'PDRING)
   (comment :initform (list
     "A partial differential ring with differentiations indexed by a"
     "parameter type S."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PartialDifferentialRing|
  (progn
    (push '|PartialDifferentialRing| *Categories*)
    (make-instance '|PartialDifferentialRingType|)))

\end{chunk}

\subsection{PointCategory}
\index[cat]{PointCategory!Category}
\index[cat]{Category!PointCategory}
\index[cat]{PTCAT}
\begin{chunk}{defclass PointCategoryType}
(defclass |PointCategoryType| (|VectorCategoryType|)
  ((parents :initform '(|VectorCategory|))
   (name :initform "PointCategory")
   (marker :initform 'category)
   (level :initform 9)
   (abbreviation :initform 'PTCAT)
   (comment :initform (list
     "PointCategory is the category of points in space which"
     "may be plotted via the graphics facilities.  Functions are provided for"
     "defining points and handling elements of points."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PointCategory|
  (progn
    (push '|PointCategory| *Categories*)
    (make-instance '|PointCategoryType|)))

\end{chunk}

\subsection{SquareFreeNormalizedTriangularSetCategory}
\index[cat]{SquareFreeNormalizedTriangularSetCategory!Category}
\index[cat]{Category!SquareFreeNormalizedTriangularSetCategory}
\index[cat]{SNTSCAT}
\begin{chunk}{defclass SquareFreeNormalizedTriangularSetCategoryType}
(defclass |SquareFreeNormalizedTriangularSetCategoryType| (|NormalizedTriangularSetCategoryType| 
                                                           |SquareFreeRegularTriangularSetCategoryType|)
  ((parents :initform '(|NormalizedTriangularSetCategory| |SquareFreeRegularTriangularSetCategory|))
   (name :initform "SquareFreeNormalizedTriangularSetCategory")
   (marker :initform 'category)
   (level :initform 9)
   (abbreviation :initform 'SNTSCAT)
   (comment :initform (list
     "The category of square-free and normalized triangular sets."
     "Thus, up to the primitivity axiom of [1], these sets are Lazard"
     "triangular sets."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SquareFreeNormalizedTriangularSetCategory|
  (progn
    (push '|SquareFreeNormalizedTriangularSetCategory| *Categories*)
    (make-instance '|SquareFreeNormalizedTriangularSetCategoryType|)))

\end{chunk}

\subsection{StringCategory}
\index[cat]{StringCategory!Category}
\index[cat]{Category!StringCategory}
\index[cat]{STRICAT}
\begin{chunk}{defclass StringCategoryType}
(defclass |StringCategoryType| (|OpenMathType| |StringAggregateType|)
  ((parents :initform '(|OpenMath| |StringAggregate|))
   (name :initform "StringCategory")
   (marker :initform 'category)
   (level :initform 9)
   (abbreviation :initform 'STRICAT)
   (comment :initform (list
     "A category for string-like objects"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StringCategory|
  (progn
    (push '|StringCategory| *Categories*)
    (make-instance '|StringCategoryType|)))

\end{chunk}

\subsection{TableAggregate}
\index[cat]{TableAggregate!Category}
\index[cat]{Category!TableAggregate}
\index[cat]{TBAGG}
\begin{chunk}{defclass TableAggregateType}
(defclass |TableAggregateType| (|KeyedDictionaryType| |IndexedAggregateType|)
  ((parents :initform '(|KeyedDictionary| |IndexedAggregate|))
   (name :initform "TableAggregate")
   (marker :initform 'category)
   (level :initform 9)
   (abbreviation :initform 'TBAGG)
   (comment :initform (list
     "A table aggregate is a model of a table, that is, a discrete many-to-one"
     "mapping from keys to entries."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TableAggregate|
  (progn
    (push '|TableAggregate| *Categories*)
    (make-instance '|TableAggregateType|)))

\end{chunk}

\section{Level 10}

\begin{chunk}{defvar level10}
(defvar level10
 '(|Algebra| |AssociationListAggregate| |DifferentialExtension| |DivisorCategory|
   |FreeModuleCat| |FullyLinearlyExplicitRingOver| |LeftOreRing| |LieAlgebra|
   |NonAssociativeAlgebra| |RectangularMatrixCategory| |VectorSpace|))

\end{chunk}

\subsection{Algebra}
\index[cat]{Algebra!Category}
\index[cat]{Category!Algebra}
\index[cat]{ALGEBRA}
\begin{chunk}{defclass AlgebraType}
(defclass |AlgebraType| (|RingType| |ModuleType|)
  ((parents :initform '(|Ring| |Module|))
   (name :initform "Algebra")
   (marker :initform 'category)
   (level :initform 10)
   (abbreviation :initform 'ALGEBRA)
   (comment :initform (list
     "The category of associative algebras (modules which are themselves rings)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Algebra|
  (progn
    (push '|Algebra| *Categories*)
    (make-instance '|AlgebraType|)))

\end{chunk}

\subsection{AssociationListAggregate}
\index[cat]{AssociationListAggregate!Category}
\index[cat]{Category!AssociationListAggregate}
\index[cat]{ALAGG}
\begin{chunk}{defclass AssociationListAggregateType}
(defclass |AssociationListAggregateType| (|ListAggregateType| |TableAggregateType|)
  ((parents :initform '(|ListAggregate| |TableAggregate|))
   (name :initform "AssociationListAggregate")
   (marker :initform 'category)
   (level :initform 10)
   (abbreviation :initform 'ALAGG)
   (comment :initform (list
     "An association list is a list of key entry pairs which may be viewed"
     "as a table. It is a poor mans version of a table:"
     "searching for a key is a linear operation."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AssociationListAggregate|
  (progn
    (push '|AssociationListAggregate| *Categories*)
    (make-instance '|AssociationListAggregateType|)))

\end{chunk}

\subsection{DifferentialExtension}
\index[cat]{DifferentialExtension!Category}
\index[cat]{Category!DifferentialExtension}
\index[cat]{DIFEXT}
\begin{chunk}{defclass DifferentialExtensionType}
(defclass |DifferentialExtensionType| (|DifferentialRingType| |PartialDifferentialRingType|)
  ((parents :initform '(|DifferentialRing| |PartialDifferentialRing|))
   (name :initform "DifferentialExtension")
   (marker :initform 'category)
   (level :initform 10)
   (abbreviation :initform 'DIFEXT)
   (comment :initform (list
     "Differential extensions of a ring R."
     "Given a differentiation on R, extend it to a differentiation on %."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DifferentialExtension|
  (progn
    (push '|DifferentialExtension| *Categories*)
    (make-instance '|DifferentialExtensionType|)))

\end{chunk}

\subsection{DivisorCategory}
\index[cat]{DivisorCategory!Category}
\index[cat]{Category!DivisorCategory}
\index[cat]{DIVCAT}
\begin{chunk}{defclass DivisorCategoryType}
(defclass |DivisorCategoryType| (|FreeAbelianMonoidCategoryType| |ModuleType|)
  ((parents :initform '(|FreeAbelianMonoidCategory| |Module|))
   (name :initform "DivisorCategory")
   (marker :initform 'category)
   (level :initform 10)
   (abbreviation :initform 'DIVCAT)
   (comment :initform (list
     "This category exports the function for domains "))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DivisorCategory|
  (progn
    (push '|DivisorCategory| *Categories*)
    (make-instance '|DivisorCategoryType|)))

\end{chunk}

\subsection{FreeModuleCat}
\index[cat]{FreeModuleCat!Category}
\index[cat]{Category!FreeModuleCat}
\index[cat]{FMCAT}
\begin{chunk}{defclass FreeModuleCatType}
(defclass |FreeModuleCatType| (|RetractableToType| |ModuleType|)
  ((parents :initform '(|RetractableTo| |Module|))
   (name :initform "FreeModuleCat")
   (marker :initform 'category)
   (level :initform 10)
   (abbreviation :initform 'FMCAT)
   (comment :initform (list
     "A domain of this category"
     "implements formal linear combinations"
     "of elements from a domain Basis with coefficients"
     "in a domain R. The domain Basis needs only"
     "to belong to the category SetCategory and R"
     "to the category Ring. Thus the coefficient ring"
     "may be non-commutative."
     "See the XDistributedPolynomial constructor"
     "for examples of domains built with the FreeModuleCat"
     "category constructor."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FreeModuleCat|
  (progn
    (push '|FreeModuleCat| *Categories*)
    (make-instance '|FreeModuleCatType|)))

\end{chunk}

\subsection{FullyLinearlyExplicitRingOver}
\index[cat]{FullyLinearlyExplicitRingOver!Category}
\index[cat]{Category!FullyLinearlyExplicitRingOver}
\index[cat]{FLINEXP}
\begin{chunk}{defclass FullyLinearlyExplicitRingOverType}
(defclass |FullyLinearlyExplicitRingOverType| (|LinearlyExplicitRingOverType|)
  ((parents :initform '(|LinearlyExplicitRingOver|))
   (name :initform "FullyLinearlyExplicitRingOver")
   (marker :initform 'category)
   (level :initform 10)
   (abbreviation :initform 'FLINEXP)
   (comment :initform (list
     "S is FullyLinearlyExplicitRingOver R means that S is a"
     "LinearlyExplicitRingOver R and, in addition, if R is a"
     "LinearlyExplicitRingOver Integer, then so is S"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FullyLinearlyExplicitRingOver|
  (progn
    (push '|FullyLinearlyExplicitRingOver| *Categories*)
    (make-instance '|FullyLinearlyExplicitRingOverType|)))

\end{chunk}

\subsection{LeftOreRing}
\index[cat]{LeftOreRing!Category}
\index[cat]{Category!LeftOreRing}
\index[cat]{LORER}
\begin{chunk}{defclass LeftOreRingType}
(defclass |LeftOreRingType| (|EntireRingType|)
  ((parents :initform '(|EntireRing|))
   (name :initform "LeftOreRing")
   (marker :initform 'category)
   (level :initform 10)
   (abbreviation :initform 'LORER)
   (comment :initform (list
     "This is the category of left ore rings, that is noncommutative"
     "rings without zero divisors where we can compute the least left"
     "common multiple."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LeftOreRing|
  (progn
    (push '|LeftOreRing| *Categories*)
    (make-instance '|LeftOreRingType|)))

\end{chunk}

\subsection{LieAlgebra}
\index[cat]{LieAlgebra!Category}
\index[cat]{Category!LieAlgebra}
\index[cat]{LIECAT}
\begin{chunk}{defclass LieAlgebraType}
(defclass |LieAlgebraType| (|ModuleType|)
  ((parents :initform '(|Module|))
   (name :initform "LieAlgebra")
   (marker :initform 'category)
   (level :initform 10)
   (abbreviation :initform 'LIECAT)
   (comment :initform (list
     "The category of Lie Algebras."
     "It is used by the domains of non-commutative algebra,"
     "LiePolynomial and XPBWPolynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LieAlgebra|
  (progn
    (push '|LieAlgebra| *Categories*)
    (make-instance '|LieAlgebraType|)))

\end{chunk}

\subsection{NonAssociativeAlgebra}
\index[cat]{NonAssociativeAlgebra!Category}
\index[cat]{Category!NonAssociativeAlgebra}
\index[cat]{NAALG}
\begin{chunk}{defclass NonAssociativeAlgebraType}
(defclass |NonAssociativeAlgebraType| (|NonAssociativeRngType| |ModuleType|)
  ((parents :initform '(|NonAssociativeRng| |Module|))
   (name :initform "NonAssociativeAlgebra")
   (marker :initform 'category)
   (level :initform 10)
   (abbreviation :initform 'NAALG)
   (comment :initform (list
     "NonAssociativeAlgebra is the category of non associative algebras"
     "(modules which are themselves non associative rngs)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NonAssociativeAlgebra|
  (progn
    (push '|NonAssociativeAlgebra| *Categories*)
    (make-instance '|NonAssociativeAlgebraType|)))

\end{chunk}

\subsection{RectangularMatrixCategory}
\index[cat]{RectangularMatrixCategory!Category}
\index[cat]{Category!RectangularMatrixCategory}
\index[cat]{RMATCAT}
\begin{chunk}{defclass RectangularMatrixCategoryType}
(defclass |RectangularMatrixCategoryType| (|ModuleType| |HomogeneousAggregateType|)
  ((parents :initform '(|Module| |HomogeneousAggregate|))
   (name :initform "RectangularMatrixCategory")
   (marker :initform 'category)
   (level :initform 10)
   (abbreviation :initform 'RMATCAT)
   (comment :initform (list
     "RectangularMatrixCategory is a category of matrices of fixed"
     "dimensions. The dimensions of the matrix will be parameters of the"
     "domain. Domains in this category will be R-modules and will be non-mutable."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RectangularMatrixCategory|
  (progn
    (push '|RectangularMatrixCategory| *Categories*)
    (make-instance '|RectangularMatrixCategoryType|)))

\end{chunk}

\subsection{VectorSpace}
\index[cat]{VectorSpace!Category}
\index[cat]{Category!VectorSpace}
\index[cat]{VSPACE}
\begin{chunk}{defclass VectorSpaceType}
(defclass |VectorSpaceType| (|ModuleType|)
  ((parents :initform '(|Module|))
   (name :initform "VectorSpace")
   (marker :initform 'category)
   (level :initform 10)
   (abbreviation :initform 'VSPACE)
   (comment :initform (list
     "Vector Spaces (not necessarily finite dimensional) over a field."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |VectorSpace|
  (progn
    (push '|VectorSpace| *Categories*)
    (make-instance '|VectorSpaceType|)))

\end{chunk}

\section{Level 11}

\begin{chunk}{defvar level11}
(defvar level11
 '(|DirectProductCategory| |DivisionRing| |FiniteRankAlgebra|
   |FiniteRankNonAssociativeAlgebra| |FreeLieAlgebra| |IntegralDomain|
   |MonogenicLinearOperator| |OctonionCategory| |SquareMatrixCategory|
   |UnivariateSkewPolynomialCategory| |XAlgebra|))

\end{chunk}

\subsection{DirectProductCategory}
\index[cat]{DirectProductCategory!Category}
\index[cat]{Category!DirectProductCategory}
\index[cat]{DIRPCAT}
\begin{chunk}{defclass DirectProductCategoryType}
(defclass |DirectProductCategoryType| (|FullyRetractableToType|
                                       |FiniteType|
                                       |IndexedAggregateType|
                                       |OrderedAbelianMonoidSupType|
                                       |CommutativeRingType|
                                       |OrderedRingType|
                                       |AlgebraType|
                                       |DifferentialExtensionType|
                                       |FullyLinearlyExplicitRingOverType|
                                       |VectorSpaceType|)
  ((parents :initform '(|FullyRetractableTo|
                        |Finite|
                        |IndexedAggregate|
                        |OrderedAbelianMonoidSup|
                        |CommutativeRing|
                        |OrderedRing|
                        |Algebra|
                        |DifferentialExtension|
                        |FullyLinearlyExplicitRingOver|
                        |VectorSpace|))
   (name :initform "DirectProductCategory")
   (marker :initform 'category)
   (level :initform 11)
   (abbreviation :initform 'DIRPCAT)
   (comment :initform (list
     "This category represents a finite cartesian product of a given type."
     "Many categorical properties are preserved under this construction."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DirectProductCategory|
  (progn
    (push '|DirectProductCategory| *Categories*)
    (make-instance '|DirectProductCategoryType|)))

\end{chunk}

\subsection{DivisionRing}
\index[cat]{DivisionRing!Category}
\index[cat]{Category!DivisionRing}
\index[cat]{DIVRING}
\begin{chunk}{defclass DivisionRingType}
(defclass |DivisionRingType| (|AlgebraType| |EntireRingType|)
  ((parents :initform '(|Algebra| |EntireRing|))
   (name :initform "DivisionRing")
   (marker :initform 'category)
   (level :initform 11)
   (abbreviation :initform 'DIVRING)
   (comment :initform (list
     "A division ring (sometimes called a skew field),"
     "a not necessarily commutative ring where"
     "all non-zero elements have multiplicative inverses."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DivisionRing|
  (progn
    (push '|DivisionRing| *Categories*)
    (make-instance '|DivisionRingType|)))

\end{chunk}

\subsection{FiniteRankAlgebra}
\index[cat]{FiniteRankAlgebra!Category}
\index[cat]{Category!FiniteRankAlgebra}
\index[cat]{FINRALG}
\begin{chunk}{defclass FiniteRankAlgebraType}
(defclass |FiniteRankAlgebraType| (|CharacteristicNonZeroType| |CharacteristicZeroType| 
                                   |AlgebraType|)
  ((parents :initform '(|CharacteristicNonZero| |CharacteristicZero| 
                          |Algebra|))
   (name :initform "FiniteRankAlgebra")
   (marker :initform 'category)
   (level :initform 11)
   (abbreviation :initform 'FINRALG)
   (comment :initform (list
     "A FiniteRankAlgebra is an algebra over a commutative ring R which"
     "is a free R-module of finite rank."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteRankAlgebra|
  (progn
    (push '|FiniteRankAlgebra| *Categories*)
    (make-instance '|FiniteRankAlgebraType|)))

\end{chunk}

\subsection{FiniteRankNonAssociativeAlgebra}
\index[cat]{FiniteRankNonAssociativeAlgebra!Category}
\index[cat]{Category!FiniteRankNonAssociativeAlgebra}
\index[cat]{FINAALG}
\begin{chunk}{defclass FiniteRankNonAssociativeAlgebraType}
(defclass |FiniteRankNonAssociativeAlgebraType| (|NonAssociativeAlgebraType|)
  ((parents :initform '(|NonAssociativeAlgebra|))
   (name :initform "FiniteRankNonAssociativeAlgebra")
   (marker :initform 'category)
   (level :initform 11)
   (abbreviation :initform 'FINAALG)
   (comment :initform (list
     "A FiniteRankNonAssociativeAlgebra is a non associative algebra over"
     "a commutative ring R which is a free R-module of finite rank."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteRankNonAssociativeAlgebra|
  (progn
    (push '|FiniteRankNonAssociativeAlgebra| *Categories*)
    (make-instance '|FiniteRankNonAssociativeAlgebraType|)))

\end{chunk}

\subsection{FreeLieAlgebra}
\index[cat]{FreeLieAlgebra!Category}
\index[cat]{Category!FreeLieAlgebra}
\index[cat]{FLALG}
\begin{chunk}{defclass FreeLieAlgebraType}
(defclass |FreeLieAlgebraType| (|LieAlgebraType|)
  ((parents :initform '(|LieAlgebra|))
   (name :initform "FreeLieAlgebra")
   (marker :initform 'category)
   (level :initform 11)
   (abbreviation :initform 'FLALG)
   (comment :initform (list
     "The category of free Lie algebras."
     "It is used by domains of non-commutative algebra:"
     "LiePolynomial and XPBWPolynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FreeLieAlgebra|
  (progn
    (push '|FreeLieAlgebra| *Categories*)
    (make-instance '|FreeLieAlgebraType|)))

\end{chunk}

\subsection{IntegralDomain}
\index[cat]{IntegralDomain!Category}
\index[cat]{Category!IntegralDomain}
\index[cat]{INTDOM}
\begin{chunk}{defclass IntegralDomainType}
(defclass |IntegralDomainType| (|CommutativeRingType| |AlgebraType| |EntireRingType|)
  ((parents :initform '(|CommutativeRing| |Algebra| |EntireRing|))
   (name :initform "IntegralDomain")
   (marker :initform 'category)
   (level :initform 11)
   (abbreviation :initform 'INTDOM)
   (comment :initform (list
     "The category of commutative integral domains, commutative"
     "rings with no zero divisors."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegralDomain|
  (progn
    (push '|IntegralDomain| *Categories*)
    (make-instance '|IntegralDomainType|)))

\end{chunk}

\subsection{MonogenicLinearOperator}
\index[cat]{MonogenicLinearOperator!Category}
\index[cat]{Category!MonogenicLinearOperator}
\index[cat]{MLO}
\begin{chunk}{defclass MonogenicLinearOperatorType}
(defclass |MonogenicLinearOperatorType| (|AlgebraType|)
  ((parents :initform '(|Algebra|))
   (name :initform "MonogenicLinearOperator")
   (marker :initform 'category)
   (level :initform 11)
   (abbreviation :initform 'MLO)
   (comment :initform (list
     "This is the category of linear operator rings with one generator."
     "The generator is not named by the category but can always be"
     "constructed as monomial(1,1)."
     " "
     "For convenience, call the generator G."
     "Then each value is equal to"
     "sum(a(i)*G**i, i = 0..n)"
     "for some unique n and a(i) in R."
     " "
     "Note that multiplication is not necessarily commutative."
     "In fact,  if a is in R, it is quite normal"
     "to have a*G ^= G*a."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MonogenicLinearOperator|
  (progn
    (push '|MonogenicLinearOperator| *Categories*)
    (make-instance '|MonogenicLinearOperatorType|)))

\end{chunk}

\subsection{OctonionCategory}
\index[cat]{OctonionCategory!Category}
\index[cat]{Category!OctonionCategory}
\index[cat]{OC}
\begin{chunk}{defclass OctonionCategoryType}
(defclass |OctonionCategoryType| (|ConvertibleToType|
                                  |FullyRetractableToType| 
                                  |FiniteType| 
                                  |FullyEvalableOverType| 
                                  |OrderedSetType| 
                                  |CharacteristicNonZeroType|
                                  |CharacteristicZeroType| 
                                  |AlgebraType|)
  ((parents :initform '(|ConvertibleTo|
                        |FullyRetractableTo| 
                        |Finite| 
                        |FullyEvalableOver| 
                        |OrderedSet| 
                        |CharacteristicNonZero|
                        |CharacteristicZero| 
                        |Algebra|))
   (name :initform "OctonionCategory")
   (marker :initform 'category)
   (level :initform 11)
   (abbreviation :initform 'OC)
   (comment :initform (list
     "OctonionCategory gives the categorial frame for the"
     "octonions, and eight-dimensional non-associative algebra,"
     "doubling the the quaternions in the same way as doubling"
     "the Complex numbers to get the quaternions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OctonionCategory|
  (progn
    (push '|OctonionCategory| *Categories*)
    (make-instance '|OctonionCategoryType|)))

\end{chunk}

\subsection{SquareMatrixCategory}
\index[cat]{SquareMatrixCategory!Category}
\index[cat]{Category!SquareMatrixCategory}
\index[cat]{SMATCAT}
\begin{chunk}{defclass SquareMatrixCategoryType}
(defclass |SquareMatrixCategoryType| (|FullyRetractableToType| |AlgebraType| |DifferentialExtensionType| 
                                      |FullyLinearlyExplicitRingOverType|
                                      |RectangularMatrixCategoryType|)
  ((parents :initform '(|FullyRetractableTo| |Algebra| |DifferentialExtension| 
                          |FullyLinearlyExplicitRingOver|
                          |RectangularMatrixCategory|))
   (name :initform "SquareMatrixCategory")
   (marker :initform 'category)
   (level :initform 11)
   (abbreviation :initform 'SMATCAT)
   (comment :initform (list
     "SquareMatrixCategory is a general square matrix category which"
     "allows different representations and indexing schemes.  Rows and"
     "columns may be extracted with rows returned as objects of"
     "type Row and colums returned as objects of type Col."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SquareMatrixCategory|
  (progn
    (push '|SquareMatrixCategory| *Categories*)
    (make-instance '|SquareMatrixCategoryType|)))

\end{chunk}

\subsection{UnivariateSkewPolynomialCategory}
\index[cat]{UnivariateSkewPolynomialCategory!Category}
\index[cat]{Category!UnivariateSkewPolynomialCategory}
\index[cat]{OREPCAT}
\begin{chunk}{defclass UnivariateSkewPolynomialCategoryType}
(defclass |UnivariateSkewPolynomialCategoryType| (|FullyRetractableToType| |AlgebraType|)
  ((parents :initform '(|FullyRetractableTo| |Algebra|))
   (name :initform "UnivariateSkewPolynomialCategory")
   (marker :initform 'category)
   (level :initform 11)
   (abbreviation :initform 'OREPCAT)
   (comment :initform (list
     "This is the category of univariate skew polynomials over an Ore"
     "coefficient ring."
     "The multiplication is given by x a = sigma(a) x + delta a."
     "This category is an evolution of the types"
     "MonogenicLinearOperator, OppositeMonogenicLinearOperator, and"
     "NonCommutativeOperatorDivision"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateSkewPolynomialCategory|
  (progn
    (push '|UnivariateSkewPolynomialCategory| *Categories*)
    (make-instance '|UnivariateSkewPolynomialCategoryType|)))

\end{chunk}

\subsection{XAlgebra}
\index[cat]{XAlgebra!Category}
\index[cat]{Category!XAlgebra}
\index[cat]{XALG}
\begin{chunk}{defclass XAlgebraType}
(defclass |XAlgebraType| (|AlgebraType|)
  ((parents :initform '(|Algebra|))
   (name :initform "XAlgebra")
   (marker :initform 'category)
   (level :initform 11)
   (abbreviation :initform 'XALG)
   (comment :initform (list
     "This is the category of algebras over non-commutative rings."
     "It is used by constructors of non-commutative algebras such as"
     "XPolynomialRing and XFreeAlgebra"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |XAlgebra|
  (progn
    (push '|XAlgebra| *Categories*)
    (make-instance '|XAlgebraType|)))

\end{chunk}

\section{Level 12}

\begin{chunk}{defvar level12}
(defvar level12
 '(|AbelianMonoidRing| |FortranMachineTypeCategory| |FramedAlgebra|
   |FramedNonAssociativeAlgebra| |GcdDomain|
   |LinearOrdinaryDifferentialOperatorCategory| |OrderedIntegralDomain|
   |QuaternionCategory| |XFreeAlgebra|))

\end{chunk}

\subsection{AbelianMonoidRing}
\index[cat]{AbelianMonoidRing!Category}
\index[cat]{Category!AbelianMonoidRing}
\index[cat]{AMR}
\begin{chunk}{defclass AbelianMonoidRingType}
(defclass |AbelianMonoidRingType| (|CharacteristicNonZeroType| |CharacteristicZeroType| |IntegralDomainType|)
  ((parents :initform '(|CharacteristicNonZero| |CharacteristicZero| |IntegralDomain|))
   (name :initform "AbelianMonoidRing")
   (marker :initform 'category)
   (level :initform 12)
   (abbreviation :initform 'AMR)
   (comment :initform (list
     "Abelian monoid ring elements (not necessarily of finite support)"
     "of this ring are of the form formal SUM (r_i * e_i)"
     "where the r_i are coefficents and the e_i, elements of the"
     "ordered abelian monoid, are thought of as exponents or monomials."
     "The monomials commute with each other, and with"
     "the coefficients (which themselves may or may not be commutative)."
     "See FiniteAbelianMonoidRing for the case of finite support"
     "a useful common model for polynomials and power series."
     "Conceptually at least, only the non-zero terms are ever operated on."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AbelianMonoidRing|
  (progn
    (push '|AbelianMonoidRing| *Categories*)
    (make-instance '|AbelianMonoidRingType|)))

\end{chunk}

\subsection{FortranMachineTypeCategory}
\index[cat]{FortranMachineTypeCategory!Category}
\index[cat]{Category!FortranMachineTypeCategory}
\index[cat]{FMTC}
\begin{chunk}{defclass FortranMachineTypeCategoryType}
(defclass |FortranMachineTypeCategoryType| (|RetractableToType| |OrderedSetType| 
                                            |IntegralDomainType|)
  ((parents :initform '(|RetractableTo| |OrderedSet| 
                          |IntegralDomain|))
   (name :initform "FortranMachineTypeCategory")
   (marker :initform 'category)
   (level :initform 12)
   (abbreviation :initform 'FMTC)
   (comment :initform (list
     "A category of domains which model machine arithmetic"
     "used by machines in the AXIOM-NAG link."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranMachineTypeCategory|
  (progn
    (push '|FortranMachineTypeCategory| *Categories*)
    (make-instance '|FortranMachineTypeCategoryType|)))

\end{chunk}

\subsection{FramedAlgebra}
\index[cat]{FramedAlgebra!Category}
\index[cat]{Category!FramedAlgebra}
\index[cat]{FRAMALG}
\begin{chunk}{defclass FramedAlgebraType}
(defclass |FramedAlgebraType| (|FiniteRankAlgebraType|)
  ((parents :initform '(|FiniteRankAlgebra|))
   (name :initform "FramedAlgebra")
   (marker :initform 'category)
   (level :initform 12)
   (abbreviation :initform 'FRAMALG)
   (comment :initform (list
     "A FramedAlgebra is a FiniteRankAlgebra together"
     "with a fixed R-module basis."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FramedAlgebra|
  (progn
    (push '|FramedAlgebra| *Categories*)
    (make-instance '|FramedAlgebraType|)))

\end{chunk}

\subsection{FramedNonAssociativeAlgebra}
\index[cat]{FramedNonAssociativeAlgebra!Category}
\index[cat]{Category!FramedNonAssociativeAlgebra}
\index[cat]{FRNAALG}
\begin{chunk}{defclass FramedNonAssociativeAlgebraType}
(defclass |FramedNonAssociativeAlgebraType| (|FiniteRankNonAssociativeAlgebraType|)
  ((parents :initform '(|FiniteRankNonAssociativeAlgebra|))
   (name :initform "FramedNonAssociativeAlgebra")
   (marker :initform 'category)
   (level :initform 12)
   (abbreviation :initform 'FRNAALG)
   (comment :initform (list
     "FramedNonAssociativeAlgebra(R) is a"
     "FiniteRankNonAssociativeAlgebra (a non associative"
     "algebra over R which is a free R-module of finite rank)"
     "over a commutative ring R together with a fixed R-module basis."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FramedNonAssociativeAlgebra|
  (progn
    (push '|FramedNonAssociativeAlgebra| *Categories*)
    (make-instance '|FramedNonAssociativeAlgebraType|)))

\end{chunk}

\subsection{GcdDomain}
\index[cat]{GcdDomain!Category}
\index[cat]{Category!GcdDomain}
\index[cat]{GCDDOM}
\begin{chunk}{defclass GcdDomainType}
(defclass |GcdDomainType| (|IntegralDomainType| |LeftOreRingType|)
  ((parents :initform '(|IntegralDomain| |LeftOreRing|))
   (name :initform "GcdDomain")
   (marker :initform 'category)
   (level :initform 12)
   (abbreviation :initform 'GCDDOM)
   (comment :initform (list
     "This category describes domains where"
     "gcd can be computed but where there is no guarantee"
     "of the existence of factor operation for factorisation"
     "into irreducibles. However, if such a factor operation exist,"
     "factorization will be unique up to order and units."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GcdDomain|
  (progn
    (push '|GcdDomain| *Categories*)
    (make-instance '|GcdDomainType|)))

\end{chunk}
\begin{verbatim}
( ?~=? : (%,%) -> Boolean
 (~= (((|Boolean|) $ $) 7))

 zero? : % -> Boolean
 (|zero?| (((|Boolean|) $) 15))

 unitNormal : % -> Record(unit: %,canonical: %,associate: %)
 (|unitNormal| (((|Record| (|:| |unit| $) (|:| |canonical| $) (|:| |associate| $)) $) 40))

 unitCanonical : % -> %
 (|unitCanonical| (($ $) 39))

 unit? : % -> Boolean
 (|unit?| (((|Boolean|) $) 37))

 subtractIfCan : (%,%) -> Union(%,"failed")
 (|subtractIfCan| (((|Union| $ "failed") $ $) 18))

 sample : () -> %
 (|sample| (($) 16 T CONST))

 recip : % -> Union(%,"failed")
 (|recip| (((|Union| $ "failed") $) 33))

 one? : % -> Boolean
 (|one?| (((|Boolean|) $) 30))

 lcmCoef : (%,%) -> Record(llcmres: %,coeff1: %,coeff2: %)
 (|lcmCoef| (((|Record| (|:| |llcmres| $) (|:| |coeff1| $) (|:| |coeff2| $)) $ $) 48))

 lcm : (%,%) -> %
 lcm : List(%) -> %
 (|lcm| (($ $ $) 45) (($ (|List| $)) 44))

 latex : % -> String
 (|latex| (((|String|) $) 9))

 hash : % -> SingleInteger
 (|hash| (((|SingleInteger|) $) 10))

 gcdPolynomial : (SparseUnivariatePolynomial(%),SparseUnivariatePolynomial(%)) -> SparseUnivariatePolynomial(%)
 (|gcdPolynomial| (((|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $)) 43))

 gcd : (%,%) -> %
 gcd : List(%) -> %
 (|gcd| (($ $ $) 47) (($ (|List| $)) 46))

 exquo : (%,%) -> Union(%,"failed")
 (|exquo| (((|Union| $ "failed") $ $) 41))

 coerce : % -> OutputForm
 coerce : Integer -> %
 coerce : % -> %
 (|coerce| (((|OutputForm|) $) 11) (($ (|Integer|)) 27) (($ $) 42))

 characteristic : () -> NonNegativeInteger
 (|characteristic| (((|NonNegativeInteger|)) 28))

 associates? : (%,%) -> Boolean
 (|associates?| (((|Boolean|) $ $) 38))

 ?^? : (%,PositiveInteger) -> %
 ?^? : (%,NonNegativeInteger) -> %
 (^ (($ $ (|PositiveInteger|)) 25) (($ $ (|NonNegativeInteger|)) 32))

 0 : () -> %
 (|Zero| (($) 17 T CONST))

 1 : () -> %
 (|One| (($) 29 T CONST))

 ?=? : (%,%) -> Boolean
 (= (((|Boolean|) $ $) 6))

 -? : % -> %
 ?-? : (%,%) -> %
 (- (($ $) 21) (($ $ $) 20))

 ?+? : (%,%) -> %
 (+ (($ $ $) 13))

 ?**? : (%,PositiveInteger) -> %
 ?**? : (%,NonNegativeInteger) -> %
 (** (($ $ (|PositiveInteger|)) 24) (($ $ (|NonNegativeInteger|)) 31))
 
 ?*? : (PositiveInteger,%) -> %
 ?*? : (NonNegativeInteger,%) -> %
 ?*? : (Integer,%) -> %
 ?*? : (%,%) -> %
 (* (($ (|PositiveInteger|) $) 12) (($ (|NonNegativeInteger|) $) 14) (($ (|Integer|) $) 19) (($ $ $) 23)))
\end{verbatim}

\subsection{LinearOrdinaryDifferentialOperatorCategory}
\index[cat]{LinearOrdinaryDifferentialOperatorCategory!Category}
\index[cat]{Category!LinearOrdinaryDifferentialOperatorCategory}
\index[cat]{LODOCAT}
\begin{chunk}{defclass LinearOrdinaryDifferentialOperatorCategoryType}
(defclass |LinearOrdinaryDifferentialOperatorCategoryType| (
                   |EltableType| |UnivariateSkewPolynomialCategoryType|)
  ((parents :initform '(|Eltable| |UnivariateSkewPolynomialCategory|))
   (name :initform "LinearOrdinaryDifferentialOperatorCategory")
   (marker :initform 'category)
   (level :initform 12)
   (abbreviation :initform 'LODOCAT)
   (comment :initform (list
     "LinearOrdinaryDifferentialOperatorCategory is the category"
     "of differential operators with coefficients in a ring A with a given"
     "derivation."
     " "
     "Multiplication of operators corresponds to functional composition:"
     "   (L1 * L2).(f) = L1 L2 f"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinearOrdinaryDifferentialOperatorCategory|
  (progn
    (push '|LinearOrdinaryDifferentialOperatorCategory| *Categories*)
    (make-instance '|LinearOrdinaryDifferentialOperatorCategoryType|)))

\end{chunk}

\subsection{OrderedIntegralDomain}
\index[cat]{OrderedIntegralDomain!Category}
\index[cat]{Category!OrderedIntegralDomain}
\index[cat]{OINTDOM}
\begin{chunk}{defclass OrderedIntegralDomainType}
(defclass |OrderedIntegralDomainType| (|OrderedRingType| |IntegralDomainType|)
  ((parents :initform '(|OrderedRing| |IntegralDomain|))
   (name :initform "OrderedIntegralDomain")
   (marker :initform 'category)
   (level :initform 12)
   (abbreviation :initform 'OINTDOM)
   (comment :initform (list
     "The category of ordered commutative integral domains, where ordering"
     "and the arithmetic operations are compatible"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedIntegralDomain|
  (progn
    (push '|OrderedIntegralDomain| *Categories*)
    (make-instance '|OrderedIntegralDomainType|)))

\end{chunk}

\subsection{QuaternionCategory}
\index[cat]{QuaternionCategory!Category}
\index[cat]{Category!QuaternionCategory}
\index[cat]{QUATCAT}
\begin{chunk}{defclass QuaternionCategoryType}
(defclass |QuaternionCategoryType| (|ConvertibleToType|
                                    |FullyRetractableToType|
                                    |FullyEvalableOverType|
                                    |OrderedSetType|
                                    |CharacteristicNonZeroType|
                                    |CharacteristicZeroType|
                                    |DifferentialExtensionType|
                                    |FullyLinearlyExplicitRingOverType|
                                    |DivisionRingType|)
  ((parents :initform '(|ConvertibleTo|
                        |FullyRetractableTo|
                        |FullyEvalableOver|
                        |OrderedSet|
                        |CharacteristicNonZero|
                        |CharacteristicZero|
                        |DifferentialExtension|
                        |FullyLinearlyExplicitRingOver|
                        |DivisionRing|))
   (name :initform "QuaternionCategory")
   (marker :initform 'category)
   (level :initform 12)
   (abbreviation :initform 'QUATCAT)
   (comment :initform (list
     "QuaternionCategory describes the category of quaternions"
     "and implements functions that are not representation specific."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |QuaternionCategory|
  (progn
    (push '|QuaternionCategory| *Categories*)
    (make-instance '|QuaternionCategoryType|)))

\end{chunk}

\subsection{XFreeAlgebra}
\index[cat]{XFreeAlgebra!Category}
\index[cat]{Category!XFreeAlgebra}
\index[cat]{XFALG}
\begin{chunk}{defclass XFreeAlgebraType}
(defclass |XFreeAlgebraType| (|RetractableToType| |XAlgebraType|)
  ((parents :initform '(|RetractableTo| |XAlgebra|))
   (name :initform "XFreeAlgebra")
   (marker :initform 'category)
   (level :initform 12)
   (abbreviation :initform 'XFALG)
   (comment :initform (list
     "This category specifies opeations for  polynomials"
     "and formal series with non-commutative variables."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |XFreeAlgebra|
  (progn
    (push '|XFreeAlgebra| *Categories*)
    (make-instance '|XFreeAlgebraType|)))

\end{chunk}

\section{Level 13}

\begin{chunk}{defvar level13}
(defvar level13
 '(|FiniteAbelianMonoidRing| |IntervalCategory| |PowerSeriesCategory|
   |PrincipalIdealDomain| |UniqueFactorizationDomain| |XPolynomialsCat|))

\end{chunk}

\subsection{FiniteAbelianMonoidRing}
\index[cat]{FiniteAbelianMonoidRing!Category}
\index[cat]{Category!FiniteAbelianMonoidRing}
\index[cat]{FAMR}
\begin{chunk}{defclass FiniteAbelianMonoidRingType}
(defclass |FiniteAbelianMonoidRingType| (|FullyRetractableToType| |AbelianMonoidRingType|)
  ((parents :initform '(|FullyRetractableTo| |AbelianMonoidRing|))
   (name :initform "FiniteAbelianMonoidRing")
   (marker :initform 'category)
   (level :initform 13)
   (abbreviation :initform 'FAMR)
   (comment :initform (list
     "This category is similar to AbelianMonoidRing, except that the sum is"
     "assumed to be finite. It is a useful model for polynomials,"
     "but is somewhat more general."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteAbelianMonoidRing|
  (progn
    (push '|FiniteAbelianMonoidRing| *Categories*)
    (make-instance '|FiniteAbelianMonoidRingType|)))

\end{chunk}

\subsection{IntervalCategory}
\index[cat]{IntervalCategory!Category}
\index[cat]{Category!IntervalCategory}
\index[cat]{INTCAT}
\begin{chunk}{defclass IntervalCategoryType}
(defclass |IntervalCategoryType| (|RadicalCategoryType| |RetractableToType|
                                  |TranscendentalFunctionCategoryType|
                                  |OrderedSetType| |GcdDomainType|)
  ((parents :initform '(|RadicalCategory| |RetractableTo|
                          |TranscendentalFunctionCategory|
                          |OrderedSet| |GcdDomain|))
   (name :initform "IntervalCategory")
   (marker :initform 'category)
   (level :initform 13)
   (abbreviation :initform 'INTCAT)
   (comment :initform (list
     "This category implements of interval arithmetic and transcendental"
     "functions over intervals."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntervalCategory|
  (progn
    (push '|IntervalCategory| *Categories*)
    (make-instance '|IntervalCategoryType|)))

\end{chunk}

\subsection{PowerSeriesCategory}
\index[cat]{PowerSeriesCategory!Category}
\index[cat]{Category!PowerSeriesCategory}
\index[cat]{PSCAT}
\begin{chunk}{defclass PowerSeriesCategoryType}
(defclass |PowerSeriesCategoryType| (|AbelianMonoidRingType|)
  ((parents :initform '(|AbelianMonoidRing|))
   (name :initform "PowerSeriesCategory")
   (marker :initform 'category)
   (level :initform 13)
   (abbreviation :initform 'PSCAT)
   (comment :initform (list
     "PowerSeriesCategory is the most general power series"
     "category with exponents in an ordered abelian monoid."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PowerSeriesCategory|
  (progn
    (push '|PowerSeriesCategory| *Categories*)
    (make-instance '|PowerSeriesCategoryType|)))

\end{chunk}

\subsection{PrincipalIdealDomain}
\index[cat]{PrincipalIdealDomain!Category}
\index[cat]{Category!PrincipalIdealDomain}
\index[cat]{PID}
\begin{chunk}{defclass PrincipalIdealDomainType}
(defclass |PrincipalIdealDomainType| (|GcdDomainType|)
  ((parents :initform '(|GcdDomain|))
   (name :initform "PrincipalIdealDomain")
   (marker :initform 'category)
   (level :initform 13)
   (abbreviation :initform 'PID)
   (comment :initform (list
     "The category of constructive principal ideal domains, that is,"
     "where a single generator can be constructively found for"
     "any ideal given by a finite set of generators."
     "Note that this constructive definition only implies that"
     "finitely generated ideals are principal. It is not clear"
     "what we would mean by an infinitely generated ideal."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PrincipalIdealDomain|
  (progn
    (push '|PrincipalIdealDomain| *Categories*)
    (make-instance '|PrincipalIdealDomainType|)))

\end{chunk}

\subsection{UniqueFactorizationDomain}
\index[cat]{UniqueFactorizationDomain!Category}
\index[cat]{Category!UniqueFactorizationDomain}
\index[cat]{UFD}
\begin{chunk}{defclass UniqueFactorizationDomainType}
(defclass |UniqueFactorizationDomainType| (|GcdDomainType|)
  ((parents :initform '(|GcdDomain|))
   (name :initform "UniqueFactorizationDomain")
   (marker :initform 'category)
   (level :initform 13)
   (abbreviation :initform 'UFD)
   (comment :initform (list
     "A constructive unique factorization domain, where"
     "we can constructively factor members into a product of"
     "a finite number of irreducible elements."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UniqueFactorizationDomain|
  (progn
    (push '|UniqueFactorizationDomain| *Categories*)
    (make-instance '|UniqueFactorizationDomainType|)))

\end{chunk}

\subsection{XPolynomialsCat}
\index[cat]{XPolynomialsCat!Category}
\index[cat]{Category!XPolynomialsCat}
\index[cat]{XPOLYC}
\begin{chunk}{defclass XPolynomialsCatType}
(defclass |XPolynomialsCatType| (|XFreeAlgebraType|)
  ((parents :initform '(|XFreeAlgebra|))
   (name :initform "XPolynomialsCat")
   (marker :initform 'category)
   (level :initform 13)
   (abbreviation :initform 'XPOLYC)
   (comment :initform (list
     "The Category of polynomial rings with non-commutative variables."
     "The coefficient ring may be non-commutative too."
     "However coefficients commute with variables."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |XPolynomialsCat|
  (progn
    (push '|XPolynomialsCat| *Categories*)
    (make-instance '|XPolynomialsCatType|)))

\end{chunk}

\section{Level 14}

\begin{chunk}{defvar level14}
(defvar level14
  '(|EuclideanDomain| |MultivariateTaylorSeriesCategory| 
    |PolynomialFactorizationExplicit| |UnivariatePowerSeriesCategory|))

\end{chunk}

\subsection{EuclideanDomain}
\index[cat]{EuclideanDomain!Category}
\index[cat]{Category!EuclideanDomain}
\index[cat]{EUCDOM}
\begin{chunk}{defclass EuclideanDomainType}
(defclass |EuclideanDomainType| (|PrincipalIdealDomainType|)
  ((parents :initform '(|PrincipalIdealDomain|))
   (name :initform "EuclideanDomain")
   (marker :initform 'category)
   (level :initform 14)
   (abbreviation :initform 'EUCDOM)
   (comment :initform (list
     "A constructive euclidean domain, one can divide producing"
     "a quotient and a remainder where the remainder is either zero"
     "or is smaller (euclideanSize) than the divisor."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |EuclideanDomain|
  (progn
    (push '|EuclideanDomain| *Categories*)
    (make-instance '|EuclideanDomainType|)))

\end{chunk}

\subsection{MultivariateTaylorSeriesCategory}
\index[cat]{MultivariateTaylorSeriesCategory!Category}
\index[cat]{Category!MultivariateTaylorSeriesCategory}
\index[cat]{MTSCAT}
\begin{chunk}{defclass MultivariateTaylorSeriesCategoryType}
(defclass |MultivariateTaylorSeriesCategoryType| (|RadicalCategoryType| 
                                                  |EvalableType| 
                                                  |TranscendentalFunctionCategoryType| 
                                                  |PartialDifferentialRingType| 
                                                  |PowerSeriesCategoryType|)
  ((parents :initform '(|RadicalCategory| 
                        |Evalable| 
                        |TranscendentalFunctionCategory| 
                        |PartialDifferentialRing| 
                        |PowerSeriesCategory|))
   (name :initform "MultivariateTaylorSeriesCategory")
   (marker :initform 'category)
   (level :initform 14)
   (abbreviation :initform 'MTSCAT)
   (comment :initform (list
     "MultivariateTaylorSeriesCategory is the most general"
     "multivariate Taylor series category."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MultivariateTaylorSeriesCategory|
  (progn
    (push '|MultivariateTaylorSeriesCategory| *Categories*)
    (make-instance '|MultivariateTaylorSeriesCategoryType|)))

\end{chunk}

\subsection{PolynomialFactorizationExplicit}
\index[cat]{PolynomialFactorizationExplicit!Category}
\index[cat]{Category!PolynomialFactorizationExplicit}
\index[cat]{PFECAT}
\begin{chunk}{defclass PolynomialFactorizationExplicitType}
(defclass |PolynomialFactorizationExplicitType| (|UniqueFactorizationDomainType|)
  ((parents :initform '(|UniqueFactorizationDomain|))
   (name :initform "PolynomialFactorizationExplicit")
   (marker :initform 'category)
   (level :initform 14)
   (abbreviation :initform 'PFECAT)
   (comment :initform (list
     "This is the category of domains that know 'enough' about"
     "themselves in order to factor univariate polynomials over themselves."
     "This will be used in future releases for supporting factorization"
     "over finitely generated coefficient fields, it is not yet available"
     "in the current release of axiom."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialFactorizationExplicit|
  (progn
    (push '|PolynomialFactorizationExplicit| *Categories*)
    (make-instance '|PolynomialFactorizationExplicitType|)))

\end{chunk}

\subsection{UnivariatePowerSeriesCategory}
\index[cat]{UnivariatePowerSeriesCategory!Category}
\index[cat]{Category!UnivariatePowerSeriesCategory}
\index[cat]{UPSCAT}
\begin{chunk}{defclass UnivariatePowerSeriesCategoryType}
(defclass |UnivariatePowerSeriesCategoryType| (|EltableType|
                                               |PowerSeriesCategoryType|
                                               |DifferentialRingType|
                                               |PartialDifferentialRingType|)
  ((parents :initform '(|Eltable|
                        |PowerSeriesCategory|
                        |DifferentialRing|
                        |PartialDifferentialRing|))
   (name :initform "UnivariatePowerSeriesCategory")
   (marker :initform 'category)
   (level :initform 14)
   (abbreviation :initform 'UPSCAT)
   (comment :initform (list
     "UnivariatePowerSeriesCategory is the most general"
     "univariate power series category with exponents in an ordered"
     "abelian monoid."
     "Note that this category exports a substitution function if it is"
     "possible to multiply exponents."
     "Also note that this category exports a derivative operation if it is"
     "possible to multiply coefficients by exponents."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePowerSeriesCategory|
  (progn
    (push '|UnivariatePowerSeriesCategory| *Categories*)
    (make-instance '|UnivariatePowerSeriesCategoryType|)))

\end{chunk}

\section{Level 15}

\begin{chunk}{defvar level15}
(defvar level15
  '(|Field| |IntegerNumberSystem| |PAdicIntegerCategory|
    |PolynomialCategory| |UnivariateTaylorSeriesCategory|))

\end{chunk}

\subsection{Field}
\index[cat]{Field!Category}
\index[cat]{Category!Field}
\index[cat]{FIELD}
\begin{chunk}{defclass FieldType}
(defclass |FieldType| (|DivisionRingType| |UniqueFactorizationDomainType| |EuclideanDomainType|)
  ((parents :initform '(|DivisionRing| 
                          |UniqueFactorizationDomain| |EuclideanDomain|))
   (name :initform "Field")
   (marker :initform 'category)
   (level :initform 15)
   (abbreviation :initform 'FIELD)
   (comment :initform (list
     "The category of commutative fields, commutative rings"
     "where all non-zero elements have multiplicative inverses."
     "The factor operation while trivial is useful to have defined."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Field|
  (progn
    (push '|Field| *Categories*)
    (make-instance '|FieldType|)))

\end{chunk}

\subsection{IntegerNumberSystem}
\index[cat]{IntegerNumberSystem!Category}
\index[cat]{Category!IntegerNumberSystem}
\index[cat]{INS}
\begin{chunk}{defclass IntegerNumberSystemType}
(defclass |IntegerNumberSystemType| (|CombinatorialFunctionCategoryType|
                                     |RetractableToType|
                                     |RealConstantType|
                                     |PatternMatchableType|
                                     |StepThroughType| 
                                     |CharacteristicZeroType|
                                     |DifferentialRingType|
                                     |LinearlyExplicitRingOverType|
                                     |OrderedIntegralDomainType| 
                                     |UniqueFactorizationDomainType|
                                     |EuclideanDomainType|)
  ((parents :initform '(|CombinatorialFunctionCategory|
                        |RetractableTo|
                        |RealConstant|
                        |PatternMatchable|
                        |StepThrough| 
                        |CharacteristicZero|
                        |DifferentialRing|
                        |LinearlyExplicitRingOver|
                        |OrderedIntegralDomain| 
                        |UniqueFactorizationDomain|
                        |EuclideanDomain|))
   (name :initform "IntegerNumberSystem")
   (marker :initform 'category)
   (level :initform 15)
   (abbreviation :initform 'INS)
   (comment :initform (list
     "An IntegerNumberSystem is a model for the integers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegerNumberSystem|
  (progn
    (push '|IntegerNumberSystem| *Categories*)
    (make-instance '|IntegerNumberSystemType|)))

\end{chunk}

\subsection{PAdicIntegerCategory}
\index[cat]{PAdicIntegerCategory!Category}
\index[cat]{Category!PAdicIntegerCategory}
\index[cat]{PADICCT}
\begin{chunk}{defclass PAdicIntegerCategoryType}
(defclass |PAdicIntegerCategoryType| (|CharacteristicZeroType| |EuclideanDomainType|)
  ((parents :initform '(|CharacteristicZero| |EuclideanDomain|))
   (name :initform "PAdicIntegerCategory")
   (marker :initform 'category)
   (level :initform 15)
   (abbreviation :initform 'PADICCT)
   (comment :initform (list
     "This is the category of stream-based representations of"
     "the p-adic integers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PAdicIntegerCategory|
  (progn
    (push '|PAdicIntegerCategory| *Categories*)
    (make-instance '|PAdicIntegerCategoryType|)))

\end{chunk}

\subsection{PolynomialCategory}
\index[cat]{PolynomialCategory!Category}
\index[cat]{Category!PolynomialCategory}
\index[cat]{POLYCAT}
\begin{chunk}{defclass PolynomialCategoryType}
(defclass |PolynomialCategoryType| (|ConvertibleToType|
                                    |EvalableType| 
                                    |OrderedSetType|
                                    |PatternMatchableType| 
                                    |PartialDifferentialRingType|
                                    |FullyLinearlyExplicitRingOverType|
                                    |FiniteAbelianMonoidRingType| 
                                    |PolynomialFactorizationExplicitType|)
  ((parents :initform '(|ConvertibleTo|
                        |Evalable| 
                        |OrderedSet|
                        |PatternMatchable| 
                        |PartialDifferentialRing|
                        |FullyLinearlyExplicitRingOver|
                        |FiniteAbelianMonoidRing| 
                        |PolynomialFactorizationExplicit|))
   (name :initform "PolynomialCategory")
   (marker :initform 'category)
   (level :initform 15)
   (abbreviation :initform 'POLYCAT)
   (comment :initform (list
     "The category for general multi-variate polynomials over a ring"
     "R, in variables from VarSet, with exponents from the OrderedAbelianMonoidSup."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialCategory|
  (progn
    (push '|PolynomialCategory| *Categories*)
    (make-instance '|PolynomialCategoryType|)))

\end{chunk}

\subsection{UnivariateTaylorSeriesCategory}
\index[cat]{UnivariateTaylorSeriesCategory!Category}
\index[cat]{Category!UnivariateTaylorSeriesCategory}
\index[cat]{UTSCAT}
\begin{chunk}{defclass UnivariateTaylorSeriesCategoryType}
(defclass |UnivariateTaylorSeriesCategoryType| (|RadicalCategoryType| 
                                                |TranscendentalFunctionCategoryType| 
                                                |UnivariatePowerSeriesCategoryType|)
  ((parents :initform '(|RadicalCategory| 
                        |TranscendentalFunctionCategory|
                        |UnivariatePowerSeriesCategory|))
   (name :initform "UnivariateTaylorSeriesCategory")
   (marker :initform 'category)
   (level :initform 15)
   (abbreviation :initform 'UTSCAT)
   (comment :initform (list
     "UnivariateTaylorSeriesCategory is the category of Taylor"
     "series in one variable."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateTaylorSeriesCategory|
  (progn
    (push '|UnivariateTaylorSeriesCategory| *Categories*)
    (make-instance '|UnivariateTaylorSeriesCategoryType|)))

\end{chunk}

\section{Level 16}

\begin{chunk}{defvar level16}
(defvar level16
 '(|AlgebraicallyClosedField| |DifferentialPolynomialCategory|
   |FieldOfPrimeCharacteristic| |FunctionSpace| |LocalPowerSeriesCategory|
   |PseudoAlgebraicClosureOfPerfectFieldCategory| |QuotientFieldCategory|
   |RealClosedField| |RealNumberSystem| |RecursivePolynomialCategory|
   |UnivariateLaurentSeriesCategory| |UnivariatePolynomialCategory|
   |UnivariatePuiseuxSeriesCategory|))

\end{chunk}

\subsection{AlgebraicallyClosedField}
\index[cat]{AlgebraicallyClosedField!Category}
\index[cat]{Category!AlgebraicallyClosedField}
\index[cat]{ACF}
\begin{chunk}{defclass AlgebraicallyClosedFieldType}
(defclass |AlgebraicallyClosedFieldType| (|RadicalCategoryType| |FieldType|)
  ((parents :initform '(|RadicalCategory| |Field|))
   (name :initform "AlgebraicallyClosedField")
   (marker :initform 'category)
   (level :initform 16)
   (abbreviation :initform 'ACF)
   (comment :initform (list
     "Model for algebraically closed fields."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AlgebraicallyClosedField|
  (progn
    (push '|AlgebraicallyClosedField| *Categories*)
    (make-instance '|AlgebraicallyClosedFieldType|)))

\end{chunk}

\subsection{DifferentialPolynomialCategory}
\index[cat]{DifferentialPolynomialCategory!Category}
\index[cat]{Category!DifferentialPolynomialCategory}
\index[cat]{DPOLCAT}
\begin{chunk}{defclass DifferentialPolynomialCategoryType}
(defclass |DifferentialPolynomialCategoryType| (|DifferentialExtensionType| |PolynomialCategoryType|)
  ((parents :initform '(|DifferentialExtension| 
                        |PolynomialCategory|))
   (name :initform "DifferentialPolynomialCategory")
   (marker :initform 'category)
   (level :initform 16)
   (abbreviation :initform 'DPOLCAT)
   (comment :initform (list
     "DifferentialPolynomialCategory is a category constructor"
     "specifying basic functions in an ordinary differential polynomial"
     "ring with a given ordered set of differential indeterminates."
     "In addition, it implements defaults for the basic functions."
     "The functions order and weight are extended"
     "from the set of derivatives of differential indeterminates"
     "to the set of differential polynomials.  Other operations"
     "provided on differential polynomials are"
     "leader, initial,"
     "separant, differentialVariables, and"
     "isobaric?.   Furthermore, if the ground ring is"
     "a differential ring, then evaluation (substitution"
     "of differential indeterminates by elements of the ground ring"
     "or by differential polynomials) is"
     "provided by eval."
     "A convenient way of referencing derivatives is provided by"
     "the functions makeVariable."
     " "
     "To construct a domain using this constructor, one needs"
     "to provide a ground ring R, an ordered set S of differential"
     "indeterminates, a ranking V on the set of derivatives"
     "of the differential indeterminates, and a set E of"
     "exponents in bijection with the set of differential monomials"
     "in the given differential indeterminates."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DifferentialPolynomialCategory|
  (progn
    (push '|DifferentialPolynomialCategory| *Categories*)
    (make-instance '|DifferentialPolynomialCategoryType|)))

\end{chunk}

\subsection{FieldOfPrimeCharacteristic}
\index[cat]{FieldOfPrimeCharacteristic!Category}
\index[cat]{Category!FieldOfPrimeCharacteristic}
\index[cat]{FPC}
\begin{chunk}{defclass FieldOfPrimeCharacteristicType}
(defclass |FieldOfPrimeCharacteristicType| (|CharacteristicNonZeroType| |FieldType|)
  ((parents :initform '(|CharacteristicNonZero| |Field|))
   (name :initform "FieldOfPrimeCharacteristic")
   (marker :initform 'category)
   (level :initform 16)
   (abbreviation :initform 'FPC)
   (comment :initform (list
     "FieldOfPrimeCharacteristic is the category of fields of prime"
     "characteristic, for example, finite fields, algebraic closures of"
     "fields of prime characteristic, transcendental extensions of"
     "of fields of prime characteristic."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FieldOfPrimeCharacteristic|
  (progn
    (push '|FieldOfPrimeCharacteristic| *Categories*)
    (make-instance '|FieldOfPrimeCharacteristicType|)))

\end{chunk}

\subsection{FunctionSpace}
\index[cat]{FunctionSpace!Category}
\index[cat]{Category!FunctionSpace}
\index[cat]{FS}
\begin{chunk}{defclass FunctionSpaceType}
(defclass |FunctionSpaceType| (|PatternableType|
                               |FullyRetractableToType|
                               |ExpressionSpaceType|
                               |FullyPatternMatchableType|
                               |GroupType|
                               |CharacteristicNonZeroType|
                               |CharacteristicZeroType| 
                               |PartialDifferentialRingType| 
                               |FullyLinearlyExplicitRingOverType| 
                               |FieldType|)
  ((parents :initform '(|Patternable|
                        |FullyRetractableTo|
                        |ExpressionSpace|
                        |FullyPatternMatchable|
                        |Group|
                        |CharacteristicNonZero|
                        |CharacteristicZero| 
                        |PartialDifferentialRing| 
                        |FullyLinearlyExplicitRingOver| 
                        |Field|))
   (name :initform "FunctionSpace")
   (marker :initform 'category)
   (level :initform 16)
   (abbreviation :initform 'FS)
   (comment :initform (list
     "A space of formal functions with arguments in an arbitrary ordered set."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionSpace|
  (progn
    (push '|FunctionSpace| *Categories*)
    (make-instance '|FunctionSpaceType|)))

\end{chunk}

\subsection{LocalPowerSeriesCategory}
\index[cat]{LocalPowerSeriesCategory!Category}
\index[cat]{Category!LocalPowerSeriesCategory}
\index[cat]{LOCPOWC}
\begin{chunk}{defclass LocalPowerSeriesCategoryType}
(defclass |LocalPowerSeriesCategoryType| (|UnivariatePowerSeriesCategoryType| |FieldType|)
  ((parents :initform '(|UnivariatePowerSeriesCategory| |Field|))
   (name :initform "LocalPowerSeriesCategory")
   (marker :initform 'category)
   (level :initform 16)
   (abbreviation :initform 'LOCPOWC)
   (comment :initform nil)
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LocalPowerSeriesCategory|
  (progn
    (push '|LocalPowerSeriesCategory| *Categories*)
    (make-instance '|LocalPowerSeriesCategoryType|)))

\end{chunk}

\subsection{PseudoAlgebraicClosureOfPerfectFieldCategory}
\index[cat]{PseudoAlgebraicClosureOfPerfectFieldCategory!Category}
\index[cat]{Category!PseudoAlgebraicClosureOfPerfectFieldCategory}
\index[cat]{PACPERC}
\begin{chunk}{defclass PseudoAlgebraicClosureOfPerfectFieldCategoryType}
(defclass |PseudoAlgebraicClosureOfPerfectFieldCategoryType| (|FieldType|)
  ((parents :initform '(|Field|))
   (name :initform "PseudoAlgebraicClosureOfPerfectFieldCategory")
   (marker :initform 'category)
   (level :initform 16)
   (abbreviation :initform 'PACPERC)
   (comment :initform (list
     "This category exports the function for domains"
     "which implement dynamic extension using the simple notion of tower"
     "extensions."
     "A tower extension T of the ground"
     "field K is any sequence of field extension "
     "(T : K_0, K_1, ..., K_i...,K_n) where K_0 = K"
     "and for i =1,2,...,n, K_i is an extension of K_{i-1} of degree > 1"
     "and defined by an irreducible polynomial p(Z) in K_{i-1}."
     "Two towers (T_1: K_01, K_11,...,K_i1,...,K_n1)"
     "and (T_2: K_02, K_12,...,K_i2,...,K_n2)"
     "are said to be related if T_1 <= T_2 (or T_1 >= T_2),"
     "that is if K_i1 = K_i2 for i=1,2,...,n1 (or i=1,2,...,n2)."
     "Any algebraic operations defined for several elements" 
     "are only defined if all of the concerned elements are coming from"
     "a set of related tower extensions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PseudoAlgebraicClosureOfPerfectFieldCategory|
  (progn
    (push '|PseudoAlgebraicClosureOfPerfectFieldCategory| *Categories*)
    (make-instance '|PseudoAlgebraicClosureOfPerfectFieldCategoryType|)))

\end{chunk}

\subsection{QuotientFieldCategory}
\index[cat]{QuotientFieldCategory!Category}
\index[cat]{Category!QuotientFieldCategory}
\index[cat]{QFCAT}
\begin{chunk}{defclass QuotientFieldCategoryType}
(defclass |QuotientFieldCategoryType| (|PatternableType| 
                                       |RetractableToType| 
                                       |RealConstantType| 
                                       |FullyEvalableOverType| 
                                       |StepThroughType|
                                       |FullyPatternMatchableType|
                                       |CharacteristicNonZeroType| 
                                       |CharacteristicZeroType| 
                                       |DifferentialExtensionType|
                                       |FullyLinearlyExplicitRingOverType| 
                                       |OrderedIntegralDomainType| 
                                       |PolynomialFactorizationExplicitType|
                                       |FieldType|)
  ((parents :initform '(|Patternable| 
                        |RetractableTo| 
                        |RealConstant| 
                        |FullyEvalableOver| 
                        |StepThrough|
                        |FullyPatternMatchable|
                        |CharacteristicNonZero| 
                        |CharacteristicZero| 
                        |DifferentialExtension|
                        |FullyLinearlyExplicitRingOver| 
                        |OrderedIntegralDomain| 
                        |PolynomialFactorizationExplicit|
                        |Field|))
   (name :initform "QuotientFieldCategory")
   (marker :initform 'category)
   (level :initform 16)
   (abbreviation :initform 'QFCAT)
   (comment :initform (list
     "QuotientField(S) is the category of fractions of an Integral Domain S."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |QuotientFieldCategory|
  (progn
    (push '|QuotientFieldCategory| *Categories*)
    (make-instance '|QuotientFieldCategoryType|)))

\end{chunk}

\subsection{RealClosedField}
\index[cat]{RealClosedField!Category}
\index[cat]{Category!RealClosedField}
\index[cat]{RCFIELD}
\begin{chunk}{defclass RealClosedFieldType}
(defclass |RealClosedFieldType| (|RadicalCategoryType| |FullyRetractableToType| 
                                 |CharacteristicZeroType| |OrderedRingType| 
                                 |FieldType|)
  ((parents :initform '(|RadicalCategory| |FullyRetractableTo| 
                        |CharacteristicZero| |OrderedRing| 
                        |Field|))
   (name :initform "RealClosedField")
   (marker :initform 'category)
   (level :initform 16)
   (abbreviation :initform 'RCFIELD)
   (comment :initform (list
     "RealClosedField provides common access"
     "functions for all real closed fields."
     "provides computations with generic real roots of polynomials"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RealClosedField|
  (progn
    (push '|RealClosedField| *Categories*)
    (make-instance '|RealClosedFieldType|)))

\end{chunk}

\subsection{RealNumberSystem}
\index[cat]{RealNumberSystem!Category}
\index[cat]{Category!RealNumberSystem}
\index[cat]{RNS}
\begin{chunk}{defclass RealNumberSystemType}
(defclass |RealNumberSystemType| (|RadicalCategoryType| |RetractableToType| 
                                  |RealConstantType| |PatternMatchableType|
                                  |CharacteristicZeroType| |OrderedRingType| |FieldType|)
  ((parents :initform '(|RadicalCategory| |RetractableTo| 
                        |RealConstant| |PatternMatchable|
                        |CharacteristicZero| |OrderedRing| |Field|))
   (name :initform "RealNumberSystem")
   (marker :initform 'category)
   (level :initform 16)
   (abbreviation :initform 'RNS)
   (comment :initform (list
     "The real number system category is intended as a model for the real"
     "numbers.  The real numbers form an ordered normed field.  Note that"
     "we have purposely not included DifferentialRing or"
     "the elementary functions (see TranscendentalFunctionCategory)"
     "in the definition."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RealNumberSystem|
  (progn
    (push '|RealNumberSystem| *Categories*)
    (make-instance '|RealNumberSystemType|)))

\end{chunk}

\subsection{RecursivePolynomialCategory}
\index[cat]{RecursivePolynomialCategory!Category}
\index[cat]{Category!RecursivePolynomialCategory}
\index[cat]{RPOLCAT}
\begin{chunk}{defclass RecursivePolynomialCategoryType}
(defclass |RecursivePolynomialCategoryType| (|PolynomialCategoryType|)
  ((parents :initform '(|PolynomialCategory|))
   (name :initform "RecursivePolynomialCategory")
   (marker :initform 'category)
   (level :initform 16)
   (abbreviation :initform 'RPOLCAT)
   (comment :initform nil)
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RecursivePolynomialCategory|
  (progn
    (push '|RecursivePolynomialCategory| *Categories*)
    (make-instance '|RecursivePolynomialCategoryType|)))

\end{chunk}

\subsection{UnivariateLaurentSeriesCategory}
\index[cat]{UnivariateLaurentSeriesCategory!Category}
\index[cat]{Category!UnivariateLaurentSeriesCategory}
\index[cat]{ULSCAT}
\begin{chunk}{defclass UnivariateLaurentSeriesCategoryType}
(defclass |UnivariateLaurentSeriesCategoryType| (|RadicalCategoryType| 
                                                 |TranscendentalFunctionCategoryType|
                                                 |UnivariatePowerSeriesCategoryType|
                                                 |FieldType|)
  ((parents :initform '(|RadicalCategory| 
                        |TranscendentalFunctionCategory|
                        |UnivariatePowerSeriesCategory|
                        |Field|))
   (name :initform "UnivariateLaurentSeriesCategory")
   (marker :initform 'category)
   (level :initform 16)
   (abbreviation :initform 'ULSCAT)
   (comment :initform (list
     "UnivariateLaurentSeriesCategory is the category of"
     "Laurent series in one variable."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateLaurentSeriesCategory|
  (progn
    (push '|UnivariateLaurentSeriesCategory| *Categories*)
    (make-instance '|UnivariateLaurentSeriesCategoryType|)))

\end{chunk}

\subsection{UnivariatePolynomialCategory}
\index[cat]{UnivariatePolynomialCategory!Category}
\index[cat]{Category!UnivariatePolynomialCategory}
\index[cat]{UPOLYC}
\begin{chunk}{defclass UnivariatePolynomialCategoryType}
(defclass |UnivariatePolynomialCategoryType| (|EltableType| |StepThroughType|
                                              |DifferentialExtensionType| 
                                              |EuclideanDomainType|
                                              |PolynomialCategoryType|)
  ((parents :initform '(|Eltable| |StepThrough| 
                        |DifferentialExtension| 
                        |EuclideanDomain|
                        |PolynomialCategory|))
   (name :initform "UnivariatePolynomialCategory")
   (marker :initform 'category)
   (level :initform 16)
   (abbreviation :initform 'UPOLYC)
   (comment :initform (list
     "The category of univariate polynomials over a ring R."
     "No particular model is assumed - implementations can be either"
     "sparse or dense."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePolynomialCategory|
  (progn
    (push '|UnivariatePolynomialCategory| *Categories*)
    (make-instance '|UnivariatePolynomialCategoryType|)))

\end{chunk}

\subsection{UnivariatePuiseuxSeriesCategory}
\index[cat]{UnivariatePuiseuxSeriesCategory!Category}
\index[cat]{Category!UnivariatePuiseuxSeriesCategory}
\index[cat]{UPXSCAT}
\begin{chunk}{defclass UnivariatePuiseuxSeriesCategoryType}
(defclass |UnivariatePuiseuxSeriesCategoryType| (|RadicalCategoryType| 
                                                 |TranscendentalFunctionCategoryType|
                                                 |UnivariatePowerSeriesCategoryType|
                                                 |FieldType|)
  ((parents :initform '(|RadicalCategory| 
                        |TranscendentalFunctionCategory|
                        |UnivariatePowerSeriesCategory|
                        |Field|))
   (name :initform "UnivariatePuiseuxSeriesCategory")
   (marker :initform 'category)
   (level :initform 16)
   (abbreviation :initform 'UPXSCAT)
   (comment :initform (list
     "UnivariatePuiseuxSeriesCategory is the category of Puiseux"
     "series in one variable."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePuiseuxSeriesCategory|
  (progn
    (push '|UnivariatePuiseuxSeriesCategory| *Categories*)
    (make-instance '|UnivariatePuiseuxSeriesCategoryType|)))

\end{chunk}

\section{Level 17}

\begin{chunk}{defvar level17}
(defvar level17
  '(|AlgebraicallyClosedFunctionSpace| |ExtensionField| |FiniteFieldCategory|
    |FloatingPointSystem| |UnivariateLaurentSeriesConstructorCategory|
    |UnivariatePuiseuxSeriesConstructorCategory|))

\end{chunk}

\subsection{AlgebraicallyClosedFunctionSpace}
\index[cat]{AlgebraicallyClosedFunctionSpace!Category}
\index[cat]{Category!AlgebraicallyClosedFunctionSpace}
\index[cat]{ACFS}
\begin{chunk}{defclass AlgebraicallyClosedFunctionSpaceType}
(defclass |AlgebraicallyClosedFunctionSpaceType| (|AlgebraicallyClosedFieldType| |FunctionSpaceType|)
  ((parents :initform '(|AlgebraicallyClosedField| |FunctionSpace|))
   (name :initform "AlgebraicallyClosedFunctionSpace")
   (marker :initform 'category)
   (level :initform 17)
   (abbreviation :initform 'ACFS)
   (comment :initform (list
     "Model for algebraically closed function spaces."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AlgebraicallyClosedFunctionSpace|
  (progn
    (push '|AlgebraicallyClosedFunctionSpace| *Categories*)
    (make-instance '|AlgebraicallyClosedFunctionSpaceType|)))

\end{chunk}

\subsection{ExtensionField}
\index[cat]{ExtensionField!Category}
\index[cat]{Category!ExtensionField}
\index[cat]{XF}
\begin{chunk}{defclass ExtensionFieldType}
(defclass |ExtensionFieldType| (|RetractableToType|
                                |CharacteristicZeroType| 
                                |VectorSpaceType| 
                                |FieldOfPrimeCharacteristicType|)
  ((parents :initform '(|RetractableTo|
                        |CharacteristicZero| 
                        |VectorSpace|
                        |FieldOfPrimeCharacteristic|))
   (name :initform "ExtensionField")
   (marker :initform 'category)
   (level :initform 17)
   (abbreviation :initform 'XF)
   (comment :initform (list
     "ExtensionField F is the category of fields which extend the field F"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExtensionField|
  (progn
    (push '|ExtensionField| *Categories*)
    (make-instance '|ExtensionFieldType|)))

\end{chunk}

\subsection{FiniteFieldCategory}
\index[cat]{FiniteFieldCategory!Category}
\index[cat]{Category!FiniteFieldCategory}
\index[cat]{FFIELDC}
\begin{chunk}{defclass FiniteFieldCategoryType}
(defclass |FiniteFieldCategoryType| (|FiniteType| |StepThroughType| 
                                     |DifferentialRingType| 
                                     |FieldOfPrimeCharacteristicType|)
  ((parents :initform '(|Finite| |StepThrough| 
                        |DifferentialRing| 
                        |FieldOfPrimeCharacteristic|))
   (name :initform "FiniteFieldCategory")
   (marker :initform 'category)
   (level :initform 17)
   (abbreviation :initform 'FFIELDC)
   (comment :initform (list
     "FiniteFieldCategory is the category of finite fields"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldCategory|
  (progn
    (push '|FiniteFieldCategory| *Categories*)
    (make-instance '|FiniteFieldCategoryType|)))

\end{chunk}

\subsection{FloatingPointSystem}
\index[cat]{FloatingPointSystem!Category}
\index[cat]{Category!FloatingPointSystem}
\index[cat]{FPS}
\begin{chunk}{defclass FloatingPointSystemType}
(defclass |FloatingPointSystemType| (|RealNumberSystemType|)
  ((parents :initform '(|RealNumberSystem|))
   (name :initform "FloatingPointSystem")
   (marker :initform 'category)
   (level :initform 17)
   (abbreviation :initform 'FPS)
   (comment :initform (list
     "This category is intended as a model for floating point systems."
     "A floating point system is a model for the real numbers.  In fact,"
     "it is an approximation in the sense that not all real numbers are"
     "exactly representable by floating point numbers."
     "A floating point system is characterized by the following:"
     " "
     "1: base of the exponent where the actual implemenations are" 
     "usually binary or decimal)"
     "2: precision of the mantissa (arbitrary or fixed)"
     "3: rounding error for operations"
      " "
     "Because a Float is an approximation to the real numbers, even though"
     "it is defined to be a join of a Field and OrderedRing, some of"
     "the attributes do not hold.  In particular associative('+')"
     "does not hold.  Algorithms defined over a field need special"
     "considerations when the field is a floating point system."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FloatingPointSystem|
  (progn
    (push '|FloatingPointSystem| *Categories*)
    (make-instance '|FloatingPointSystemType|)))

\end{chunk}

\subsection{UnivariateLaurentSeriesConstructorCategory}
\index[cat]{UnivariateLaurentSeriesConstructorCategory!Category}
\index[cat]{Category!UnivariateLaurentSeriesConstructorCategory}
\index[cat]{ULSCCAT}
\begin{chunk}{defclass UnivariateLaurentSeriesConstructorCategoryType}
(defclass |UnivariateLaurentSeriesConstructorCategoryType| (
     |QuotientFieldCategoryType| |UnivariateLaurentSeriesCategoryType|)
  ((parents :initform '(
     |QuotientFieldCategory| |UnivariateLaurentSeriesCategory|))
   (name :initform "UnivariateLaurentSeriesConstructorCategory")
   (marker :initform 'category)
   (level :initform 17)
   (abbreviation :initform 'ULSCCAT)
   (comment :initform (list
     "This is a category of univariate Laurent series constructed from"
     "univariate Taylor series.  A Laurent series is represented by a pair"
     "[n,f(x)], where n is an arbitrary integer and f(x)"
     "is a Taylor series.  This pair represents the Laurent series"
     "x**n * f(x)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateLaurentSeriesConstructorCategory|
  (progn
    (push '|UnivariateLaurentSeriesConstructorCategory| *Categories*)
    (make-instance '|UnivariateLaurentSeriesConstructorCategoryType|)))

\end{chunk}

\subsection{UnivariatePuiseuxSeriesConstructorCategory}
\index[cat]{UnivariatePuiseuxSeriesConstructorCategory!Category}
\index[cat]{Category!UnivariatePuiseuxSeriesConstructorCategory}
\index[cat]{UPXSCCA}
\begin{chunk}{defclass UnivariatePuiseuxSeriesConstructorCategoryType}
(defclass |UnivariatePuiseuxSeriesConstructorCategoryType| (|RetractableToType|
                                                            |UnivariatePuiseuxSeriesCategoryType|)
  ((parents :initform '(|RetractableTo| |UnivariatePuiseuxSeriesCategory|))
   (name :initform "UnivariatePuiseuxSeriesConstructorCategory")
   (marker :initform 'category)
   (level :initform 17)
   (abbreviation :initform 'UPXSCCA)
   (comment :initform (list
     "This is a category of univariate Puiseux series constructed"
     "from univariate Laurent series.  A Puiseux series is represented"
     "by a pair [r,f(x)], where r is a positive rational number and"
     "f(x) is a Laurent series.  This pair represents the Puiseux"
     "series f(x^r)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePuiseuxSeriesConstructorCategory|
  (progn
    (push '|UnivariatePuiseuxSeriesConstructorCategory| *Categories*)
    (make-instance '|UnivariatePuiseuxSeriesConstructorCategoryType|)))

\end{chunk}

\section{Level 18}

\begin{chunk}{defvar level18}
(defvar level18
  '(|FiniteAlgebraicExtensionField| |MonogenicAlgebra|
    |PseudoAlgebraicClosureOfFiniteFieldCategory|
    |PseudoAlgebraicClosureOfRationalNumberCategory|))

\end{chunk}

\subsection{FiniteAlgebraicExtensionField}
\index[cat]{FiniteAlgebraicExtensionField!Category}
\index[cat]{Category!FiniteAlgebraicExtensionField}
\index[cat]{FAXF}
\begin{chunk}{defclass FiniteAlgebraicExtensionFieldType}
(defclass |FiniteAlgebraicExtensionFieldType| (|FiniteFieldCategoryType| |ExtensionFieldType|)
  ((parents :initform '(|FiniteFieldCategory| |ExtensionField|))
   (name :initform "FiniteAlgebraicExtensionField")
   (marker :initform 'category)
   (level :initform 18)
   (abbreviation :initform 'FAXF)
   (comment :initform (list
     "FiniteAlgebraicExtensionField F is the category of fields"
     "which are finite algebraic extensions of the field F."
     "If F is finite then any finite algebraic extension of F"
     "is finite, too. Let K be a finite algebraic extension of the"
     "finite field F. The exponentiation of elements of K"
     "defines a Z-module structure on the multiplicative group of K."
     "The additive group of K becomes a module over the ring of"
     "polynomials over F via the operation"
     "linearAssociatedExp(a:K,f:SparseUnivariatePolynomial F)"
     "which is linear over F, that is, for elements a from K,"
     "c,d from F and f,g univariate polynomials over F"
     "we have linearAssociatedExp(a,cf+dg) equals c times"
     "linearAssociatedExp(a,f) plus d times"
     "linearAssociatedExp(a,g)."
     "Therefore linearAssociatedExp is defined completely by"
     "its action on  monomials from F[X]:"
     "linearAssociatedExp(a,monomial(1,k)$SUP(F)) is defined to be"
     "Frobenius(a,k) which is a**(q**k) where q=size()$F."
     "The operations order and discreteLog associated with the multiplicative"
     "exponentiation have additive analogues associated to the operation"
     "linearAssociatedExp. These are the functions"
     "linearAssociatedOrder and linearAssociatedLog,"
     "respectively."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteAlgebraicExtensionField|
  (progn
    (push '|FiniteAlgebraicExtensionField| *Categories*)
    (make-instance '|FiniteAlgebraicExtensionFieldType|)))

\end{chunk}

\subsection{MonogenicAlgebra}
\index[cat]{MonogenicAlgebra!Category}
\index[cat]{Category!MonogenicAlgebra}
\index[cat]{MONOGEN}
\begin{chunk}{defclass MonogenicAlgebraType}
(defclass |MonogenicAlgebraType| (|ConvertibleToType| |FullyRetractableToType|
                                  |DifferentialExtensionType|
                                  |FullyLinearlyExplicitRingOverType|
                                  |FramedAlgebraType| |FiniteFieldCategoryType|)
  ((parents :initform '(|ConvertibleTo| |FullyRetractableTo|
                        |DifferentialExtension|
                        |FullyLinearlyExplicitRingOver|
                        |FramedAlgebra| |FiniteFieldCategory|))
   (name :initform "MonogenicAlgebra")
   (marker :initform 'category)
   (level :initform 18)
   (abbreviation :initform 'MONOGEN)
   (comment :initform (list
     "A MonogenicAlgebra is an algebra of finite rank which"
     "can be generated by a single element."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MonogenicAlgebra|
  (progn
    (push '|MonogenicAlgebra| *Categories*)
    (make-instance '|MonogenicAlgebraType|)))

\end{chunk}

\subsection{PseudoAlgebraicClosureOfFiniteFieldCategory}
\index[cat]{PseudoAlgebraicClosureOfFiniteFieldCategory!Category}
\index[cat]{Category!PseudoAlgebraicClosureOfFiniteFieldCategory}
\index[cat]{PACFFC}
\begin{chunk}{defclass PseudoAlgebraicClosureOfFiniteFieldCategoryType}
(defclass |PseudoAlgebraicClosureOfFiniteFieldCategoryType| (
    |PseudoAlgebraicClosureOfPerfectFieldCategoryType| |FiniteFieldCategoryType|)
  ((parents :initform '(
     |PseudoAlgebraicClosureOfPerfectFieldCategory| |FiniteFieldCategory|))
   (name :initform "PseudoAlgebraicClosureOfFiniteFieldCategory")
   (marker :initform 'category)
   (level :initform 18)
   (abbreviation :initform 'PACFFC)
   (comment :initform (list
     "This category exports the function for the domain"
     "PseudoAlgebraicClosureOfFiniteField which implement dynamic extension"
     "using the simple notion of tower extensions."
     "A tower extension T of the ground"
     "field K is any sequence of field extension (T : K_0, K_1, ..., K_i...,K_n)"
     "where K_0 = K and for i =1,2,...,n, K_i is an extension"
     "of K_{i-1} of degree > 1 and defined by an irreducible polynomial"
     "p(Z) in K_{i-1}."
     "Two towers (T_1: K_01, K_11,...,K_i1,...,K_n1)"
     "and (T_2: K_02, K_12,...,K_i2,...,K_n2)"
     "are said to be related if T_1 <= T_2 (or T_1 >= T_2),"
     "that is if K_i1 = K_i2 for i=1,2,...,n1"
     "(or i=1,2,...,n2). Any algebraic operations defined for several elements"
     "are only defined if all of the concerned elements are comming from"
     "a set of related tour extensions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PseudoAlgebraicClosureOfFiniteFieldCategory|
  (progn
    (push '|PseudoAlgebraicClosureOfFiniteFieldCategory| *Categories*)
    (make-instance '|PseudoAlgebraicClosureOfFiniteFieldCategoryType|)))

\end{chunk}

\subsection{PseudoAlgebraicClosureOfRationalNumberCategory}
\index[cat]{PseudoAlgebraicClosureOfRationalNumberCategory!Category}
\index[cat]{Category!PseudoAlgebraicClosureOfRationalNumberCategory}
\index[cat]{PACRATC}
\begin{chunk}{defclass PseudoAlgebraicClosureOfRationalNumberCategoryType}
(defclass |PseudoAlgebraicClosureOfRationalNumberCategoryType| (
                 |ExtensionFieldType| |PseudoAlgebraicClosureOfPerfectFieldCategoryType|)
  ((parents :initform '(|ExtensionField| |PseudoAlgebraicClosureOfPerfectFieldCategory|))
   (name :initform "PseudoAlgebraicClosureOfRationalNumberCategory")
   (marker :initform 'category)
   (level :initform 18)
   (abbreviation :initform 'PACRATC)
   (comment :initform (list
     "This category exports the function for the domain"
     "PseudoAlgebraicClosureOfRationalNumber"
     "which implement dynamic extension using the simple notion of tower"
     "extensions. A tower extension T of the ground"
     "field K is any sequence of field extension (T : K_0, K_1, ..., K_i...,K_n)"
     "where K_0 = K and for i =1,2,...,n, K_i is an extension"
     "of K_{i-1} of degree > 1 and defined by an irreducible polynomial"
     "p(Z) in K_{i-1}."
     "Two towers (T_1: K_01, K_11,...,K_i1,...,K_n1)"
     "and (T_2: K_02, K_12,...,K_i2,...,K_n2)"
     "are said to be related if T_1 <= T_2 (or T_1 >= T_2),"
     "that is if K_i1 = K_i2 for i=1,2,...,n1"
     "(or i=1,2,...,n2). Any algebraic operations defined for several elements"
     "are only defined if all of the concerned elements are comming from"
     "a set of related tour extensions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PseudoAlgebraicClosureOfRationalNumberCategory|
  (progn
    (push '|PseudoAlgebraicClosureOfRationalNumberCategory| *Categories*)
    (make-instance '|PseudoAlgebraicClosureOfRationalNumberCategoryType|)))

\end{chunk}

\section{Level 19}

\begin{chunk}{defvar level19}
(defvar level19
  '(|ComplexCategory| |FunctionFieldCategory|
    |PseudoAlgebraicClosureOfAlgExtOfRationalNumberCategory|))

\end{chunk}

\subsection{ComplexCategory}
\index[cat]{ComplexCategory!Category}
\index[cat]{Category!ComplexCategory}
\index[cat]{COMPCAT}
\begin{chunk}{defclass ComplexCategoryType}
(defclass |ComplexCategoryType| (|PatternableType| |RadicalCategoryType| 
                                 |TranscendentalFunctionCategoryType| 
                                 |FullyEvalableOverType| |OrderedSetType| 
                                 |FullyPatternMatchableType| 
                                 |PolynomialFactorizationExplicitType| 
                                 |MonogenicAlgebraType|)
  ((parents :initform '(|Patternable| |RadicalCategory| 
                        |TranscendentalFunctionCategory| 
                        |FullyEvalableOver| |OrderedSet| 
                        |FullyPatternMatchable| 
                        |PolynomialFactorizationExplicit| 
                        |MonogenicAlgebra|))
   (name :initform "ComplexCategory")
   (marker :initform 'category)
   (level :initform 19)
   (abbreviation :initform 'COMPCAT)
   (comment :initform (list
     "This category represents the extension of a ring by a square root of -1."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ComplexCategory|
  (progn
    (push '|ComplexCategory| *Categories*)
    (make-instance '|ComplexCategoryType|)))

\end{chunk}

\subsection{FunctionFieldCategory}
\index[cat]{FunctionFieldCategory!Category}
\index[cat]{Category!FunctionFieldCategory}
\index[cat]{FFCAT}
\begin{chunk}{defclass FunctionFieldCategoryType}
(defclass |FunctionFieldCategoryType| (|MonogenicAlgebraType|)
  ((parents :initform '(|MonogenicAlgebra|))
   (name :initform "FunctionFieldCategory")
   (marker :initform 'category)
   (level :initform 19)
   (abbreviation :initform 'FFCAT)
   (comment :initform (list
     "This category is a model for the function field of a"
     "plane algebraic curve."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionFieldCategory|
  (progn
    (push '|FunctionFieldCategory| *Categories*)
    (make-instance '|FunctionFieldCategoryType|)))

\end{chunk}

\subsection{PseudoAlgebraicClosureOfAlgExtOfRationalNumberCategory}
\index[cat]{PseudoAlgebraicClosureOfAlgExtOfRationalNumberCategory!Category}
\index[cat]{Category!PseudoAlgebraicClosureOfAlgExtOfRationalNumberCategory}
\index[cat]{PACEXTC}
\begin{chunk}{defclass PseudoAlgebraicClosureOfAlgExtOfRationalNumberCategoryType}
(defclass |PseudoAlgebraicClosureOfAlgExtOfRationalNumberCategoryType| (
             |PseudoAlgebraicClosureOfRationalNumberCategoryType|)
  ((parents :initform '(|PseudoAlgebraicClosureOfRationalNumberCategory|))
   (name :initform "PseudoAlgebraicClosureOfAlgExtOfRationalNumberCategory")
   (marker :initform 'category)
   (level :initform 19)
   (abbreviation :initform 'PACEXTC)
   (comment :initform (list
     "This category exports the function for the domain"
     "PseudoAlgebraicClosureOfAlgExtOfRationalNumber which implement dynamic"
     "extension using the simple notion of tower extensions. A tower extension"
     "T of the ground field K is any sequence of field extension"
     "(T : K0, K1, ..., Ki...,Kn) where K0 = K and for i =1,2,...,n,"
     "Ki is an extension of K{i-1} of degree > 1 and defined by an"
     "irreducible polynomial p(Z) in K{i-1}."
     "Two towers (T1: K01, K11,...,Ki1,...,Kn1) and"
     "(T2: K02, K12,...,Ki2,...,Kn2)"
     "are said to be related if T1 <= T2 (or T1 >= T2),"
     "that is if Ki1 = Ki2 for i=1,2,...,n1 (or i=1,2,...,n2)."
     "Any algebraic operations defined for several elements"
     "are only defined if all of the concerned elements are comming from"
     "a set of related tour extensions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PseudoAlgebraicClosureOfAlgExtOfRationalNumberCategory|
  (progn
    (push '|PseudoAlgebraicClosureOfAlgExtOfRationalNumberCategory| *Categories*)
    (make-instance '|PseudoAlgebraicClosureOfAlgExtOfRationalNumberCategoryType|)))

\end{chunk}



\chapter{The NonNegativeInteger Domain}

\begin{verbatim}
)show NNI
 NonNegativeInteger is a domain constructor
 Abbreviation for NonNegativeInteger is NNI 
 This constructor is exposed in this frame.
 Issue )edit bookvol10.3.pamphlet to see algebra source code for NNI 

------------------------------- Operations --------------------------------
 ?*? : (%,%) -> %                      ?*? : (NonNegativeInteger,%) -> %
 ?*? : (PositiveInteger,%) -> %        ?**? : (%,PositiveInteger) -> %
 ?**? : (%,NonNegativeInteger) -> %    ?+? : (%,%) -> %
 ?<? : (%,%) -> Boolean                ?<=? : (%,%) -> Boolean
 ?=? : (%,%) -> Boolean                ?>? : (%,%) -> Boolean
 ?>=? : (%,%) -> Boolean               1 : () -> %
 0 : () -> %                           ?^? : (%,PositiveInteger) -> %
 ?^? : (%,NonNegativeInteger) -> %     coerce : % -> OutputForm
 gcd : (%,%) -> %                      hash : % -> SingleInteger
 latex : % -> String                   max : (%,%) -> %
 min : (%,%) -> %                      one? : % -> Boolean
 qcoerce : Integer -> %                ?quo? : (%,%) -> %
 random : % -> %                       recip : % -> Union(%,"failed")
 ?rem? : (%,%) -> %                    sample : () -> %
 shift : (%,Integer) -> %              sup : (%,%) -> %
 zero? : % -> Boolean                  ?~=? : (%,%) -> Boolean
 divide : (%,%) -> Record(quotient: %,remainder: %)
 exquo : (%,%) -> Union(%,"failed")
 subtractIfCan : (%,%) -> Union(%,"failed")

\end{verbatim}

\subsection{Database Files}

Database files are very similar to kaf files except that there
is an optimization (currently broken) which makes the first
item a pair of two numbers. The first number in the pair is
the offset of the key-value table, the second is a time stamp.
If the time stamp in the database matches the time stamp in
the image the database is not needed (since the internal hash
tables already contain all of the information). When the database
is built the time stamp is saved in both the gcl image and the
database.

Regarding the 'ancestors field in a category: At database build
time there exists a *ancestors-hash* hash table that gets filled
with CATEGORY (not domain) ancestor information. This later provides
the information that goes into interp.daase This *ancestors-hash*
does not exist at normal runtime (it can be made by a call to
genCategoryTable). Note that the ancestor information in
*ancestors-hash* (and hence interp.daase) involves \verb|#1|, \verb|#2|, etc
instead of R, Coef, etc. The latter thingies appear in all
.nrlib/index.kaf files. So we need to be careful when we )lib
categories and update the ancestor info.

This file contains the code to build, open and access the .daase
files. This file contains the code to )library nrlibs and asy files

There is a major issue about the data that resides in these
databases.  the fundamental problem is that the system requires more
information to build the databases than it needs to run the
interpreter.  in particular, modemap.daase is constructed using
properties like "modemaps" but the interpreter will never ask for
this information.

So, the design is as follows:
\begin{itemize}
\item the modemap.daase needs to be built. this is done by doing
a )library on ALL of the nrlib files that are going into the system.
this will bring in "modemap" information and add it to the
*modemaps-hash* hashtable.
\item database build proceeds, accessing the "modemap" property
from the hashtables. once this completes this information is never
used again.
\item the interp.daase database is built. this contains only the
information necessary to run the interpreter. note that during the
running of the interpreter users can extend the system by do a
)library on a new nrlib file. this will cause fields such as "modemap"
to be read and hashed.
\end{itemize}

Each constructor (e.g. LIST) had one library directory (e.g. LIST.nrlib). 
This directory contained a random access file called the index.kaf file. 
These files contain runtime information such as the operationAlist and
the ConstructorModemap. At system build time we merge all of these 
.nrlib/index.kaf files into one database, INTERP.daase.  Requests to 
get information from this database are cached so that multiple 
references do not cause additional disk i/o.

This database is left open at all times as it is used frequently by
the interpreter. one minor complication is that newly compiled files
need to override information that exists in this database.

The design calls for constructing a random read (kaf format) file
that is accessed by functions that cache their results. when the
database is opened the list of constructor-index pairs is hashed
by constructor name. a request for information about a constructor
causes the information to replace the index in the hash table. since
the index is a number and the data is a non-numeric sexpr there is
no source of confusion about when the data needs to be read.

The format of this new database is as follows:
\begin{verbatim}
 first entry:
   an integer giving the byte offset to the constructor alist
   at the bottom of the file
 second and subsequent entries (one per constructor)
   (operationAlist)
   (constructorModemap)
   ....
 last entry: (pointed at by the first entry)
   an alist of (constructor . index) e.g.
      ( (PI offset-of-operationAlist offset-of-constructorModemap)
      (NNI offset-of-operationAlist offset-of-constructorModemap)
       ....)
  This list is read at open time and hashed by the car of each item.
\end{verbatim}

The system has been changed to use the property list of the
symbols rather than hash tables. since we already hashed once
to get the symbol we need only an offset to get the property
list. this also has the advantage that eq hash tables no longer
need to be moved during garbage collection.

There are 3 potential speedups that could be done. 
\begin{itemize}
\item the best would be to use the value cell of the symbol rather than the
property list but i'm unable to determine all uses of the
value cell at the present time.
\item a second speedup is to guarantee that the property list is
a single item, namely the database structure. this removes
an assoc but leaves one open to breaking the system if someone
adds something to the property list. this was not done because
of the danger mentioned.
\item a third speedup is to make the getdatabase call go away, either
by making it a macro or eliding it entirely. this was not done
because we want to keep the flexibility of changing the database forms.
\end{itemize}

The new design does not use hash tables. the database structure
contains an entry for each item that used to be in a hash table.
initially the structure contains file-position pointers and
these are replaced by real data when they are first looked up.
the database structure is kept on the property list of the
constructor, thus, (get '|DenavitHartenbergMatrix| 'database)
will return the database structure object.

Each operation has a property on its symbol name called 'operation
which is a list of all of the signatures of operations with that name.

\index[code]{defstruct!database}
\index[code]{database!defstruct}
\begin{chunk}{initvars}
(defstruct database
 abbreviation               ; interp.
 ancestors                  ; interp.
 constructor                ; interp.
 constructorcategory        ; interp.
 constructorkind            ; interp.
 constructormodemap         ; interp.
 cosig                      ; interp.
 defaultdomain              ; interp.
 modemaps                   ; interp.
 niladic                    ; interp.
 object                     ; interp.
 operationalist             ; interp.
 documentation              ; browse.
 constructorform            ; browse.
 attributes                 ; browse.
 predicates                 ; browse.
 sourcefile                 ; browse.
 parents                    ; browse.
 users                      ; browse.
 dependents                 ; browse.
 spare                      ; superstition
 ) ; database structure

\end{chunk}

\index[code]{defvar!*defaultdomain-list*}
\index[code]{*defaultdomain-list*!defvar}
There are only a small number of domains that have default domains.
rather than keep this slot in every domain we maintain a list here.
\begin{chunk}{initvars}
(defvar *defaultdomain-list* '(
  (|MultisetAggregate| |Multiset|)
  (|FunctionSpace| |Expression|)
  (|AlgebraicallyClosedFunctionSpace| |Expression|)
  (|ThreeSpaceCategory| |ThreeSpace|)
  (|DequeueAggregate| |Dequeue|)
  (|ComplexCategory| |Complex|)
  (|LazyStreamAggregate| |Stream|)
  (|AssociationListAggregate| |AssociationList|)
  (|QuaternionCategory| |Quaternion|)
  (|PriorityQueueAggregate| |Heap|)
  (|PointCategory| |Point|)
  (|PlottableSpaceCurveCategory| |Plot3D|)
  (|PermutationCategory| |Permutation|)
  (|StringCategory| |String|)
  (|FileNameCategory| |FileName|)
  (|OctonionCategory| |Octonion|)))

\end{chunk}

\index[code]{*operation-hash*}
\begin{chunk}{initvars}
(defvar *operation-hash* nil "given an operation name, what are its modemaps?")

\end{chunk}

\index[all]{*hasCategory-hash*}
This hash table is used to answer the question``does domain x
have category y?''. this is answered by constructing a pair of
(x . y) and doing an equal hash into this table.
\begin{chunk}{initvars}
(defvar *hasCategory-hash* nil "answers x has y category questions")

\end{chunk}

\index[all]{*miss*}
This variable is used for debugging. If a hash table lookup fails
and this variable is non-nil then a message is printed.
\begin{chunk}{initvars}
(defvar *miss* nil "print out cache misses on getdatabase calls")

\end{chunk}

Note that constructorcategory information need only be kept for
items of type category. this will be fixed in the next iteration
when the need for the various caches are reviewed

Note that the *modemaps-hash* information does not need to be kept
for system files. these are precomputed and kept in modemap.daase
however, for user-defined files these are needed.
Currently these are added to the database for 2 reasons;
there is a still-unresolved issue of user database extensions and
this information is used during database build time

\begin{verbatim}
)lisp (showdatabase '|NonNegativeInteger|)
getdatabase call: NonNegativeInteger   CONSTRUCTORKIND
CONSTRUCTORKIND: domain
getdatabase call: NonNegativeInteger   COSIG
COSIG: (NIL)
getdatabase call: NonNegativeInteger   OPERATION
OPERATION: NIL
CONSTRUCTORMODEMAP: 
getdatabase call: NonNegativeInteger   CONSTRUCTORMODEMAP

(((|NonNegativeInteger|)
  (|Join| (|OrderedAbelianMonoidSup|) (|Monoid|)
          (CATEGORY |domain| (SIGNATURE |quo| ($ $ $))
              (SIGNATURE |rem| ($ $ $)) (SIGNATURE |gcd| ($ $ $))
              (SIGNATURE |divide|
                  ((|Record| (|:| |quotient| $) (|:| |remainder| $)) $
                   $))
              (SIGNATURE |exquo| ((|Union| $ "failed") $ $))
              (SIGNATURE |shift| ($ $ (|Integer|)))
              (SIGNATURE |random| ($ $))
              (SIGNATURE |qcoerce| ($ (|Integer|))))))
 (T |NonNegativeInteger|))
CONSTRUCTORCATEGORY: 
getdatabase call: NonNegativeInteger   CONSTRUCTORCATEGORY
getdatabase miss: NonNegativeInteger   CONSTRUCTORCATEGORY

(|Join| (|OrderedAbelianMonoidSup|) (|Monoid|)
        (CATEGORY |domain| (SIGNATURE |quo| ($ $ $))
            (SIGNATURE |rem| ($ $ $)) (SIGNATURE |gcd| ($ $ $))
            (SIGNATURE |divide|
                ((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $))
            (SIGNATURE |exquo| ((|Union| $ "failed") $ $))
            (SIGNATURE |shift| ($ $ (|Integer|)))
            (SIGNATURE |random| ($ $))
            (SIGNATURE |qcoerce| ($ (|Integer|)))))
OPERATIONALIST: 
getdatabase call: NonNegativeInteger   OPERATIONALIST

((~= (((|Boolean|) $ $) NIL)) (|zero?| (((|Boolean|) $) NIL))
 (|sup| (($ $ $) 6)) (|subtractIfCan| (((|Union| $ "failed") $ $) 10))
 (|shift| (($ $ (|Integer|)) 7)) (|sample| (($) NIL T CONST))
 (|rem| (($ $ $) NIL)) (|recip| (((|Union| $ "failed") $) NIL))
 (|random| (($ $) NIL)) (|quo| (($ $ $) NIL))
 (|qcoerce| (($ (|Integer|)) 8)) (|one?| (((|Boolean|) $) NIL))
 (|min| (($ $ $) NIL)) (|max| (($ $ $) NIL))
 (|latex| (((|String|) $) NIL)) (|hash| (((|SingleInteger|) $) NIL))
 (|gcd| (($ $ $) 11)) (|exquo| (((|Union| $ "failed") $ $) NIL))
 (|divide|
     (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $) NIL))
 (|coerce| (((|OutputForm|) $) NIL))
 (^ (($ $ (|NonNegativeInteger|)) NIL) (($ $ (|PositiveInteger|)) NIL))
 (|Zero| (($) NIL T CONST)) (|One| (($) NIL T CONST))
 (>= (((|Boolean|) $ $) NIL)) (> (((|Boolean|) $ $) NIL))
 (= (((|Boolean|) $ $) NIL)) (<= (((|Boolean|) $ $) NIL))
 (< (((|Boolean|) $ $) NIL)) (+ (($ $ $) NIL))
 (** (($ $ (|NonNegativeInteger|)) NIL)
     (($ $ (|PositiveInteger|)) NIL))
 (* (($ (|PositiveInteger|) $) NIL) (($ (|NonNegativeInteger|) $) NIL)
    (($ $ $) NIL)))
MODEMAPS: 
getdatabase call: NonNegativeInteger   MODEMAPS
getdatabase miss: NonNegativeInteger   MODEMAPS

((|quo| (*1 *1 *1 *1) (|isDomain| *1 (|NonNegativeInteger|)))
 (|rem| (*1 *1 *1 *1) (|isDomain| *1 (|NonNegativeInteger|)))
 (|gcd| (*1 *1 *1 *1) (|isDomain| *1 (|NonNegativeInteger|)))
 (|divide| (*1 *2 *1 *1)
     (AND (|isDomain| *2
              (|Record| (|:| |quotient| (|NonNegativeInteger|))
                  (|:| |remainder| (|NonNegativeInteger|))))
          (|isDomain| *1 (|NonNegativeInteger|))))
 (|exquo| (*1 *1 *1 *1)
          (|partial| |isDomain| *1 (|NonNegativeInteger|)))
 (|shift| (*1 *1 *1 *2)
          (AND (|isDomain| *2 (|Integer|))
               (|isDomain| *1 (|NonNegativeInteger|))))
 (|random| (*1 *1 *1) (|isDomain| *1 (|NonNegativeInteger|)))
 (|qcoerce| (*1 *1 *2)
     (AND (|isDomain| *2 (|Integer|))
          (|isDomain| *1 (|NonNegativeInteger|)))))getdatabase call: NonNegativeInteger   HASCATEGORY
HASCATEGORY: NIL
getdatabase call: NonNegativeInteger   OBJECT
OBJECT: /mnt/c/Users/markb/EXE/axiom/mnt/ubuntu/algebra/NNI.o
getdatabase call: NonNegativeInteger   NILADIC
NILADIC: T
getdatabase call: NonNegativeInteger   ABBREVIATION
ABBREVIATION: NNI
getdatabase call: NonNegativeInteger   CONSTRUCTOR?
CONSTRUCTOR?: T
getdatabase call: NonNegativeInteger   CONSTRUCTOR
CONSTRUCTOR: NIL
getdatabase call: NonNegativeInteger   DEFAULTDOMAIN
DEFAULTDOMAIN: NIL
getdatabase call: NonNegativeInteger   ANCESTORS
ANCESTORS: NIL
getdatabase call: NonNegativeInteger   SOURCEFILE
SOURCEFILE: bookvol10.3.pamphlet
getdatabase call: NonNegativeInteger   CONSTRUCTORFORM
CONSTRUCTORFORM: (NonNegativeInteger)
getdatabase call: NonNegativeInteger   CONSTRUCTORARGS
getdatabase call: NonNegativeInteger   CONSTRUCTORFORM
CONSTRUCTORARGS: NIL
getdatabase call: NonNegativeInteger   ATTRIBUTES
getdatabase miss: NonNegativeInteger   ATTRIBUTES
ATTRIBUTES: NIL
PREDICATES: 
getdatabase call: NonNegativeInteger   PREDICATES
getdatabase miss: NonNegativeInteger   PREDICATES

NILgetdatabase call: NonNegativeInteger   DOCUMENTATION
getdatabase miss: NonNegativeInteger   DOCUMENTATION
DOCUMENTATION: ((constructor (NIL \spadtype{NonNegativeInteger} provides functions for non negative integers.)) (qcoerce (($ (Integer)) \spad{qcoerce(n)} coerces \spad{n} to \spad{\%} trusting that \spad{n} is nonnegative)) (random (($ $) \spad{random(n)} returns a random integer from 0 to \spad{n-1}.)) (shift (($ $ (Integer)) \spad{shift(a, i)} shift \spad{a} by \spad{i} bits.)) (exquo (((Union $ failed) $ $) \spad{exquo(a,b)} returns the quotient of \spad{a} and \spad{b,} or "failed" if \spad{b} is zero or \spad{a} rem \spad{b} is zero.)) (divide (((Record (: quotient $) (: remainder $)) $ $) \spad{divide(a, \spad{b)}} returns a record containing both remainder and quotient.)) (gcd (($ $ $) \spad{gcd(a, \spad{b)}} computes the greatest common divisor of two \indented{1}{non negative integers \spad{a} and \spad{b.}} \blankline \spad{X} gcd(2415,945) \spad{X} gcd(945,2415) \spad{X} gcd(2415,0) \spad{X} gcd(0,945) \spad{X} gcd(15,15) \spad{X} gcd(0,0))) (rem (($ $ $) \spad{a rem \spad{b}} returns the remainder of \spad{a} and \spad{b.})) (quo (($ $ $) \spad{a quo \spad{b}} returns the quotient of \spad{a} and \spad{b,} forgetting the remainder.)))
getdatabase call: NonNegativeInteger   PARENTS
PARENTS: NIL
Value = NIL
\end{verbatim}

\begin{verbatim}
#S(DATABASE 
   ABBREVIATION NNI 
   ANCESTORS NIL 
   CONSTRUCTOR NIL 
   CONSTRUCTORCATEGORY 3449807 
   CONSTRUCTORKIND |domain| 
   CONSTRUCTORMODEMAP 
    (((|NonNegativeInteger|)
      (|Join|
        (|OrderedAbelianMonoidSup|)
        (|Monoid|)
        (CATEGORY 
          |domain|
          (SIGNATURE |quo| ($ $ $))
          (SIGNATURE |rem| ($ $ $))
          (SIGNATURE |gcd| ($ $ $))
          (SIGNATURE |divide| ((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $))
          (SIGNATURE |exquo| ((|Union| $ "failed") $ $))
          (SIGNATURE |shift| ($ $ (|Integer|)))
          (SIGNATURE |random| ($ $))
          (SIGNATURE |qcoerce| ($ (|Integer|))))))
      (T |NonNegativeInteger|))
     COSIG (NIL) 
     DEFAULTDOMAIN NIL 
     MODEMAPS 3449116 
     NILADIC T 
     OBJECT "NNI" 
     OPERATIONALIST (
       (~= (((|Boolean|) $ $) NIL))
       (|zero?| (((|Boolean|) $) NIL))
       (|sup| (($ $ $) 6))
       (|subtractIfCan| (((|Union| $ "failed") $ $) 10))
       (|shift| (($ $ (|Integer|)) 7))
       (|sample| (($) NIL T CONST))
       (|rem| (($ $ $) NIL)) 
       (|recip| (((|Union| $ "failed") $) NIL)) 
       (|random| (($ $) NIL)) 
       (|quo| (($ $ $) NIL))
       (|qcoerce| (($ (|Integer|)) 8)) 
       (|one?| (((|Boolean|) $) NIL))
       (|min| (($ $ $) NIL)) 
       (|max| (($ $ $) NIL))
       (|latex| (((|String|) $) NIL)) 
       (|hash| (((|SingleInteger|) $) NIL))
       (|gcd| (($ $ $) 11)) 
       (|exquo| (((|Union| $ "failed") $ $) NIL))
       (|divide| (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $) NIL))
       (|coerce| (((|OutputForm|) $) NIL))
       (^ (($ $ (|NonNegativeInteger|)) NIL) (($ $ (|PositiveInteger|)) NIL))
       (|Zero| (($) NIL T CONST))
       (|One| (($) NIL T CONST))
       (>= (((|Boolean|) $ $) NIL))
       (> (((|Boolean|) $ $) NIL))
       (= (((|Boolean|) $ $) NIL))
       (<= (((|Boolean|) $ $) NIL))
       (< (((|Boolean|) $ $) NIL))
       (+ (($ $ $) NIL))
       (** (($ $ (|NonNegativeInteger|)) NIL) (($ $ (|PositiveInteger|)) NIL))
       (* (($ (|PositiveInteger|) $) NIL) (($ (|NonNegativeInteger|) $) NIL) (($ $ $) NIL)))
   DOCUMENTATION 1437684 
   CONSTRUCTORFORM (|NonNegativeInteger|) 
   ATTRIBUTES 1438930 
   PREDICATES 1438935 
   SOURCEFILE "bookvol10.3.pamphlet" 
   PARENTS NIL 
   USERS NIL 
   DEPENDENTS NIL 
   SPARE NIL)

\end{verbatim}

\chapter{The Domains}
\section{A}

\subsection{AffinePlane}
\index[dom]{AffinePlane!Domain}
\index[dom]{Domain!AffinePlane}
\index[dom]{AFFPL}
\begin{chunk}{defclass AffinePlaneType}
(defclass |AffinePlaneType| (|AffineSpaceCategoryType|)
  ((parents :initform '(|AffineSpaceCategory|))
   (name :initform "AffinePlane")
   (marker :initform 'domain)
   (abbreviation :initform 'AFFPL)
   (comment :initform (list
     "The following is all the categories and domains related to projective"
     "space and part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AffinePlane|
  (progn
    (push '|AffinePlane| *Domains*)
    (make-instance '|AffinePlaneType|)))

\end{chunk}

\subsection{AffinePlaneOverPseudoAlgebraicClosureOfFiniteField}
\index[dom]{AffinePlaneOverPseudoAlgebraicClosureOfFiniteField!Domain}
\index[dom]{Domain!AffinePlaneOverPseudoAlgebraicClosureOfFiniteField}
\index[dom]{AFFPLPS}
\begin{chunk}{defclass AffinePlaneOverPseudoAlgebraicClosureOfFiniteFieldType}
(defclass |AffinePlaneOverPseudoAlgebraicClosureOfFiniteFieldType| (|AffineSpaceCategoryType|)
  ((parents :initform '(|AffineSpaceCategory|))
   (name :initform "AffinePlaneOverPseudoAlgebraicClosureOfFiniteField")
   (marker :initform 'domain)
   (abbreviation :initform 'AFFPLPS)
   (comment :initform (list
     "The following is all the categories and domains related to projective"
     "space and part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AffinePlaneOverPseudoAlgebraicClosureOfFiniteField|
  (progn
    (push '|AffinePlaneOverPseudoAlgebraicClosureOfFiniteField| *Domains*)
    (make-instance '|AffinePlaneOverPseudoAlgebraicClosureOfFiniteFieldType|)))

\end{chunk}

\subsection{AffineSpace}
\index[dom]{AffineSpace!Domain}
\index[dom]{Domain!AffineSpace}
\index[dom]{AFFSP}
\begin{chunk}{defclass AffineSpaceType}
(defclass |AffineSpaceType| (|AffineSpaceCategoryType|)
  ((parents :initform '(|AffineSpaceCategory|))
   (name :initform "AffineSpace")
   (marker :initform 'domain)
   (abbreviation :initform 'AFFSP)
   (comment :initform (list
     "The following is all the categories and domains related to projective"
     "space and part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AffineSpace|
  (progn
    (push '|AffineSpace| *Domains*)
    (make-instance '|AffineSpaceType|)))

\end{chunk}

\subsection{AlgebraGivenByStructuralConstants}
\index[dom]{AlgebraGivenByStructuralConstants!Domain}
\index[dom]{Domain!AlgebraGivenByStructuralConstants}
\index[dom]{ALGSC}
\begin{chunk}{defclass AlgebraGivenByStructuralConstantsType}
(defclass |AlgebraGivenByStructuralConstantsType| (|FramedNonAssociativeAlgebraType|)
  ((parents :initform '(|FramedNonAssociativeAlgebra|))
   (name :initform "AlgebraGivenByStructuralConstants")
   (marker :initform 'domain)
   (abbreviation :initform 'ALGSC)
   (comment :initform (list
     "The following is all the categories and domains related to projective"
     "space and part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AlgebraGivenByStructuralConstants|
  (progn
    (push '|AlgebraGivenByStructuralConstants| *Domains*)
    (make-instance '|AlgebraGivenByStructuralConstantsType|)))

\end{chunk}

\subsection{AlgebraicFunctionField}
\index[dom]{AlgebraicFunctionField!Domain}
\index[dom]{Domain!AlgebraicFunctionField}
\index[dom]{ALGFF}
\begin{chunk}{defclass AlgebraicFunctionFieldType}
(defclass |AlgebraicFunctionFieldType| (|FunctionFieldCategoryType|)
  ((parents :initform '(|FunctionFieldCategory|))
   (name :initform "AlgebraicFunctionField")
   (marker :initform 'domain)
   (abbreviation :initform 'ALGFF)
   (comment :initform (list
     "Function field defined by f(x, y) = 0."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AlgebraicFunctionField|
  (progn
    (push '|AlgebraicFunctionField| *Domains*)
    (make-instance '|AlgebraicFunctionFieldType|)))

\end{chunk}

\subsection{AlgebraicNumber}
\index[dom]{AlgebraicNumber!Domain}
\index[dom]{Domain!AlgebraicNumber}
\index[dom]{AN}
\begin{chunk}{defclass AlgebraicNumberType}
(defclass |AlgebraicNumberType| (|AlgebraicallyClosedFieldType| 
                                 |CharacteristicZeroType| 
                                 |DifferentialRingType|
                                 |ExpressionSpaceType| 
                                 |LinearlyExplicitRingOverType| 
                                 |RealConstantType|)
  ((parents :initform '(|AlgebraicallyClosedField| 
                        |CharacteristicZero| 
                        |DifferentialRing|
                        |ExpressionSpace| 
                        |LinearlyExplicitRingOver| 
                        |RealConstant|))
   (name :initform "AlgebraicNumber")
   (marker :initform 'domain)
   (abbreviation :initform 'AN)
   (comment :initform (list
     "Algebraic closure of the rational numbers, with mathematical ="))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AlgebraicNumber|
  (progn
    (push '|AlgebraicNumber| *Domains*)
    (make-instance '|AlgebraicNumberType|)))

\end{chunk}

\subsection{AnonymousFunction}
\index[dom]{AnonymousFunction!Domain}
\index[dom]{Domain!AnonymousFunction}
\index[dom]{ANON}
\begin{chunk}{defclass AnonymousFunctionType}
(defclass |AnonymousFunctionType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "AnonymousFunction")
   (marker :initform 'domain)
   (abbreviation :initform 'ANON)
   (comment :initform (list
     "This domain implements anonymous functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AnonymousFunction|
  (progn
    (push '|AnonymousFunction| *Domains*)
    (make-instance '|AnonymousFunctionType|)))

\end{chunk}

\subsection{AntiSymm}
\index[dom]{AntiSymm!Domain}
\index[dom]{Domain!AntiSymm}
\index[dom]{ANTISYM}
\begin{chunk}{defclass AntiSymmType}
(defclass |AntiSymmType| (|RetractableToType| |LeftAlgebraType|)
  ((parents :initform '(|RetractableTo| |LeftAlgebra|))
   (name :initform "AntiSymm")
   (marker :initform 'domain)
   (abbreviation :initform 'ANTISYM)
   (comment :initform (list
     "The domain of antisymmetric polynomials."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AntiSymm|
  (progn
    (push '|AntiSymm| *Domains*)
    (make-instance '|AntiSymmType|)))

\end{chunk}

\subsection{Any}
\index[dom]{Any!Domain}
\index[dom]{Domain!Any}
\index[dom]{ANY}
\begin{chunk}{defclass AnyType}
(defclass |AnyType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "Any")
   (marker :initform 'domain)
   (abbreviation :initform 'ANY)
   (comment :initform (list
     "Any implements a type that packages up objects and their"
     "types in objects of Any. Roughly speaking that means"
     "that if s : S then when converted to Any, the new"
     "object will include both the original object and its type. This is"
     "a way of converting arbitrary objects into a single type without"
     "losing any of the original information. Any object can be converted"
     "to one of Any."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Any|
  (progn
    (push '|Any| *Domains*)
    (make-instance '|AnyType|)))

\end{chunk}

\subsection{ArrayStack}
\index[dom]{ArrayStack!Domain}
\index[dom]{Domain!ArrayStack}
\index[dom]{ASTACK}
\begin{chunk}{defclass ArrayStackType}
(defclass |ArrayStackType| (|StackAggregateType|)
  ((parents :initform '(|StackAggregate|))
   (name :initform "ArrayStack")
   (marker :initform 'domain)
   (abbreviation :initform 'ASTACK)
   (comment :initform (list
     "A stack represented as a flexible array."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ArrayStack|
  (progn
    (push '|ArrayStack| *Domains*)
    (make-instance '|ArrayStackType|)))

\end{chunk}

\subsection{Asp1}
\index[dom]{Asp1!Domain}
\index[dom]{Domain!Asp1}
\index[dom]{Asp1}
\begin{chunk}{defclass Asp1Type}
(defclass |Asp1Type| (|FortranFunctionCategoryType|)
  ((parents :initform '(|FortranFunctionCategory|))
   (name :initform "Asp1")
   (marker :initform 'domain)
   (abbreviation :initform 'Asp1)
   (comment :initform (list
     "Asp1 produces Fortran for Type 1 ASPs, needed for various"
     "NAG routines. Type 1 ASPs take a univariate expression (in the symbol x)"
     "and turn it into a Fortran Function like the following:"
     " "
     "     DOUBLE PRECISION FUNCTION F(X)"
     "     DOUBLE PRECISION X"
     "     F=DSIN(X)"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp1|
  (progn
    (push '|Asp1| *Domains*)
    (make-instance '|Asp1Type|)))

\end{chunk}

\subsection{Asp10}
\index[dom]{Asp10!Domain}
\index[dom]{Domain!Asp10}
\index[dom]{ASP10}
\begin{chunk}{defclass Asp10Type}
(defclass |Asp10Type| (|FortranVectorFunctionCategoryType|)
  ((parents :initform '(|FortranVectorFunctionCategory|))
   (name :initform "Asp10")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP10)
   (comment :initform (list
     "ASP10 produces Fortran for Type 10 ASPs, needed for NAG routine"
     "d02kef. This ASP computes the values of a set of functions, for example:"
     " "
     "     SUBROUTINE COEFFN(P,Q,DQDL,X,ELAM,JINT)"
     "     DOUBLE PRECISION ELAM,P,Q,X,DQDL"
     "     INTEGER JINT"
     "     P=1.0D0"
     "     Q=((-1.0D0*X**3)+ELAM*X*X-2.0D0)/(X*X)"
     "     DQDL=1.0D0"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp10|
  (progn
    (push '|Asp10| *Domains*)
    (make-instance '|Asp10Type|)))

\end{chunk}

\subsection{Asp12}
\index[dom]{Asp12!Domain}
\index[dom]{Domain!Asp12}
\index[dom]{ASP12}
\begin{chunk}{defclass |Asp12Type}
(defclass |Asp12Type| (|FortranProgramCategoryType|)
  ((parents :initform '(|FortranProgramCategory|))
   (name :initform "Asp12")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP12)
   (comment :initform (list
     "Asp12 produces Fortran for Type 12 ASPs, needed for NAG routine"
     "d02kef etc., for example:"
     " "
     "     SUBROUTINE MONIT (MAXIT,IFLAG,ELAM,FINFO)"
     "     DOUBLE PRECISION ELAM,FINFO(15)"
     "     INTEGER MAXIT,IFLAG"
     "     IF(MAXIT.EQ.-1)THEN"
     "     PRINT*,\"Output from Monit\""
     "     ENDIF"
     "     PRINT*,MAXIT,IFLAG,ELAM,(FINFO(I),I=1,4)"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp12|
  (progn
    (push '|Asp12| *Domains*)
    (make-instance '|Asp12Type|)))

\end{chunk}

\subsection{Asp19}
\index[dom]{Asp19!Domain}
\index[dom]{Domain!Asp19}
\index[dom]{ASP19}
\begin{chunk}{defclass Asp19Type}
(defclass |Asp19Type| (|FortranVectorFunctionCategoryType|)
  ((parents :initform '(|FortranVectorFunctionCategory|))
   (name :initform "Asp19")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP19)
   (comment :initform (list
     "Asp19 produces Fortran for Type 19 ASPs, evaluating a set of"
     "functions and their jacobian at a given point, for example:"
     " "
     "     SUBROUTINE LSFUN2(M,N,XC,FVECC,FJACC,LJC)"
     "     DOUBLE PRECISION FVECC(M),FJACC(LJC,N),XC(N)"
     "     INTEGER M,N,LJC"
     "     INTEGER I,J"
     "     DO 25003 I=1,LJC"
     "       DO 25004 J=1,N"
     "         FJACC(I,J)=0.0D0"
     "25004   CONTINUE"
     "25003 CONTINUE"
     "     FVECC(1)=((XC(1)-0.14D0)*XC(3)+(15.0D0*XC(1)-2.1D0)*XC(2)+1.0D0)/("
     "    &XC(3)+15.0D0*XC(2))"
     "     FVECC(2)=((XC(1)-0.18D0)*XC(3)+(7.0D0*XC(1)-1.26D0)*XC(2)+1.0D0)/("
     "    &XC(3)+7.0D0*XC(2))"
     "     FVECC(3)=((XC(1)-0.22D0)*XC(3)+(4.333333333333333D0*XC(1)-0.953333"
     "    &3333333333D0)*XC(2)+1.0D0)/(XC(3)+4.333333333333333D0*XC(2))"
     "     FVECC(4)=((XC(1)-0.25D0)*XC(3)+(3.0D0*XC(1)-0.75D0)*XC(2)+1.0D0)/("
     "    &XC(3)+3.0D0*XC(2))"
     "     FVECC(5)=((XC(1)-0.29D0)*XC(3)+(2.2D0*XC(1)-0.6379999999999999D0)*"
     "    &XC(2)+1.0D0)/(XC(3)+2.2D0*XC(2))"
     "     FVECC(6)=((XC(1)-0.32D0)*XC(3)+(1.666666666666667D0*XC(1)-0.533333"
     "    &3333333333D0)*XC(2)+1.0D0)/(XC(3)+1.666666666666667D0*XC(2))"
     "     FVECC(7)=((XC(1)-0.35D0)*XC(3)+(1.285714285714286D0*XC(1)-0.45D0)*"
     "    &XC(2)+1.0D0)/(XC(3)+1.285714285714286D0*XC(2))"
     "     FVECC(8)=((XC(1)-0.39D0)*XC(3)+(XC(1)-0.39D0)*XC(2)+1.0D0)/(XC(3)+"
     "    &XC(2))"
     "     FVECC(9)=((XC(1)-0.37D0)*XC(3)+(XC(1)-0.37D0)*XC(2)+1.285714285714"
     "    &286D0)/(XC(3)+XC(2))"
     "     FVECC(10)=((XC(1)-0.58D0)*XC(3)+(XC(1)-0.58D0)*XC(2)+1.66666666666"
     "    &6667D0)/(XC(3)+XC(2))"
     "     FVECC(11)=((XC(1)-0.73D0)*XC(3)+(XC(1)-0.73D0)*XC(2)+2.2D0)/(XC(3)"
     "    &+XC(2))"
     "     FVECC(12)=((XC(1)-0.96D0)*XC(3)+(XC(1)-0.96D0)*XC(2)+3.0D0)/(XC(3)"
     "    &+XC(2))"
     "     FVECC(13)=((XC(1)-1.34D0)*XC(3)+(XC(1)-1.34D0)*XC(2)+4.33333333333"
     "    &3333D0)/(XC(3)+XC(2))"
     "     FVECC(14)=((XC(1)-2.1D0)*XC(3)+(XC(1)-2.1D0)*XC(2)+7.0D0)/(XC(3)+X"
     "    &C(2))"
     "     FVECC(15)=((XC(1)-4.39D0)*XC(3)+(XC(1)-4.39D0)*XC(2)+15.0D0)/(XC(3"
     "    &)+XC(2))"
     "     FJACC(1,1)=1.0D0"
     "     FJACC(1,2)=-15.0D0/(XC(3)**2+30.0D0*XC(2)*XC(3)+225.0D0*XC(2)**2)"
     "     FJACC(1,3)=-1.0D0/(XC(3)**2+30.0D0*XC(2)*XC(3)+225.0D0*XC(2)**2)"
     "     FJACC(2,1)=1.0D0"
     "     FJACC(2,2)=-7.0D0/(XC(3)**2+14.0D0*XC(2)*XC(3)+49.0D0*XC(2)**2)"
     "     FJACC(2,3)=-1.0D0/(XC(3)**2+14.0D0*XC(2)*XC(3)+49.0D0*XC(2)**2)"
     "     FJACC(3,1)=1.0D0"
     "     FJACC(3,2)=((-0.1110223024625157D-15*XC(3))-4.333333333333333D0)/("
     "    &XC(3)**2+8.666666666666666D0*XC(2)*XC(3)+18.77777777777778D0*XC(2)"
     "    &**2)"
     "     FJACC(3,3)=(0.1110223024625157D-15*XC(2)-1.0D0)/(XC(3)**2+8.666666"
     "    &666666666D0*XC(2)*XC(3)+18.77777777777778D0*XC(2)**2)"
     "     FJACC(4,1)=1.0D0"
     "     FJACC(4,2)=-3.0D0/(XC(3)**2+6.0D0*XC(2)*XC(3)+9.0D0*XC(2)**2)"
     "     FJACC(4,3)=-1.0D0/(XC(3)**2+6.0D0*XC(2)*XC(3)+9.0D0*XC(2)**2)"
     "     FJACC(5,1)=1.0D0"
     "     FJACC(5,2)=((-0.1110223024625157D-15*XC(3))-2.2D0)/(XC(3)**2+4.399"
     "    &999999999999D0*XC(2)*XC(3)+4.839999999999998D0*XC(2)**2)"
     "     FJACC(5,3)=(0.1110223024625157D-15*XC(2)-1.0D0)/(XC(3)**2+4.399999"
     "    &999999999D0*XC(2)*XC(3)+4.839999999999998D0*XC(2)**2)"
     "     FJACC(6,1)=1.0D0"
     "     FJACC(6,2)=((-0.2220446049250313D-15*XC(3))-1.666666666666667D0)/("
     "    &XC(3)**2+3.333333333333333D0*XC(2)*XC(3)+2.777777777777777D0*XC(2)"
     "    &**2)"
     "     FJACC(6,3)=(0.2220446049250313D-15*XC(2)-1.0D0)/(XC(3)**2+3.333333"
     "    &333333333D0*XC(2)*XC(3)+2.777777777777777D0*XC(2)**2)"
     "     FJACC(7,1)=1.0D0"
     "     FJACC(7,2)=((-0.5551115123125783D-16*XC(3))-1.285714285714286D0)/("
     "    &XC(3)**2+2.571428571428571D0*XC(2)*XC(3)+1.653061224489796D0*XC(2)"
     "    &**2)"
     "     FJACC(7,3)=(0.5551115123125783D-16*XC(2)-1.0D0)/(XC(3)**2+2.571428"
     "    &571428571D0*XC(2)*XC(3)+1.653061224489796D0*XC(2)**2)"
     "     FJACC(8,1)=1.0D0"
     "     FJACC(8,2)=-1.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)"
     "     FJACC(8,3)=-1.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)"
     "     FJACC(9,1)=1.0D0"
     "     FJACC(9,2)=-1.285714285714286D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)*"
     "    &*2)"
     "     FJACC(9,3)=-1.285714285714286D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)*"
     "    &*2)"
     "     FJACC(10,1)=1.0D0"
     "     FJACC(10,2)=-1.666666666666667D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)"
     "    &**2)"
     "     FJACC(10,3)=-1.666666666666667D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)"
     "    &**2)"
     "     FJACC(11,1)=1.0D0"
     "     FJACC(11,2)=-2.2D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)"
     "     FJACC(11,3)=-2.2D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)"
     "     FJACC(12,1)=1.0D0"
     "     FJACC(12,2)=-3.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)"
     "     FJACC(12,3)=-3.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)"
     "     FJACC(13,1)=1.0D0"
     "     FJACC(13,2)=-4.333333333333333D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)"
     "    &**2)"
     "     FJACC(13,3)=-4.333333333333333D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)"
     "    &**2)"
     "     FJACC(14,1)=1.0D0"
     "     FJACC(14,2)=-7.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)"
     "     FJACC(14,3)=-7.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)"
     "     FJACC(15,1)=1.0D0"
     "     FJACC(15,2)=-15.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)"
     "     FJACC(15,3)=-15.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp19|
  (progn
    (push '|Asp19| *Domains*)
    (make-instance '|Asp19Type|)))

\end{chunk}

\subsection{Asp20}
\index[dom]{Asp20!Domain}
\index[dom]{Domain!Asp20}
\index[dom]{ASP20}
\begin{chunk}{defclass Asp20Type}
(defclass |Asp20Type| (|FortranMatrixFunctionCategoryType|)
  ((parents :initform '(|FortranMatrixFunctionCategory|))
   (name :initform "Asp20")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP20)
   (comment :initform (list
     "Asp20 produces Fortran for Type 20 ASPs, for example:"
     " "
     "     SUBROUTINE QPHESS(N,NROWH,NCOLH,JTHCOL,HESS,X,HX)"
     "     DOUBLE PRECISION HX(N),X(N),HESS(NROWH,NCOLH)"
     "     INTEGER JTHCOL,N,NROWH,NCOLH"
     "     HX(1)=2.0D0*X(1)"
     "     HX(2)=2.0D0*X(2)"
     "     HX(3)=2.0D0*X(4)+2.0D0*X(3)"
     "     HX(4)=2.0D0*X(4)+2.0D0*X(3)"
     "     HX(5)=2.0D0*X(5)"
     "     HX(6)=(-2.0D0*X(7))+(-2.0D0*X(6))"
     "     HX(7)=(-2.0D0*X(7))+(-2.0D0*X(6))"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp20|
  (progn
    (push '|Asp20| *Domains*)
    (make-instance '|Asp20Type|)))

\end{chunk}

\subsection{Asp24}
\index[dom]{Asp24!Domain}
\index[dom]{Domain!Asp24}
\index[dom]{ASP24}
\begin{chunk}{defclass Asp24Type}
(defclass |Asp24Type| (|FortranFunctionCategoryType|)
  ((parents :initform '(|FortranFunctionCategory|))
   (name :initform "Asp24")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP24)
   (comment :initform (list
     "Asp24 produces Fortran for Type 24 ASPs which evaluate a"
     "multivariate function at a point (needed for NAG routine e04jaf),"
     "for example:"
     " "
     "     SUBROUTINE FUNCT1(N,XC,FC)"
     "     DOUBLE PRECISION FC,XC(N)"
     "     INTEGER N"
     "     FC=10.0D0*XC(4)**4+(-40.0D0*XC(1)*XC(4)**3)+(60.0D0*XC(1)**2+5"
     "    &.0D0)*XC(4)**2+((-10.0D0*XC(3))+(-40.0D0*XC(1)**3))*XC(4)+16.0D0*X"
     "    &C(3)**4+(-32.0D0*XC(2)*XC(3)**3)+(24.0D0*XC(2)**2+5.0D0)*XC(3)**2+"
     "    &(-8.0D0*XC(2)**3*XC(3))+XC(2)**4+100.0D0*XC(2)**2+20.0D0*XC(1)*XC("
     "    &2)+10.0D0*XC(1)**4+XC(1)**2"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp24|
  (progn
    (push '|Asp24| *Domains*)
    (make-instance '|Asp24Type|)))

\end{chunk}

\subsection{Asp27}
\index[dom]{Asp27!Domain}
\index[dom]{Domain!Asp27}
\index[dom]{ASP27}
\begin{chunk}{defclass Asp27Type}
(defclass |Asp27Type| (|FortranMatrixCategoryType|)
  ((parents :initform '(|FortranMatrixCategory|))
   (name :initform "Asp27")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP27)
   (comment :initform (list
     "Asp27 produces Fortran for Type 27 ASPs, needed for NAG routine"
     "f02fjf ,for example:"
     " "
     "     FUNCTION DOT(IFLAG,N,Z,W,RWORK,LRWORK,IWORK,LIWORK)"
     "     DOUBLE PRECISION W(N),Z(N),RWORK(LRWORK)"
     "     INTEGER N,LIWORK,IFLAG,LRWORK,IWORK(LIWORK)"
     "     DOT=(W(16)+(-0.5D0*W(15)))*Z(16)+((-0.5D0*W(16))+W(15)+(-0.5D0*W(1"
     "    &4)))*Z(15)+((-0.5D0*W(15))+W(14)+(-0.5D0*W(13)))*Z(14)+((-0.5D0*W("
     "    &14))+W(13)+(-0.5D0*W(12)))*Z(13)+((-0.5D0*W(13))+W(12)+(-0.5D0*W(1"
     "    &1)))*Z(12)+((-0.5D0*W(12))+W(11)+(-0.5D0*W(10)))*Z(11)+((-0.5D0*W("
     "    &11))+W(10)+(-0.5D0*W(9)))*Z(10)+((-0.5D0*W(10))+W(9)+(-0.5D0*W(8))"
     "    &)*Z(9)+((-0.5D0*W(9))+W(8)+(-0.5D0*W(7)))*Z(8)+((-0.5D0*W(8))+W(7)"
     "    &+(-0.5D0*W(6)))*Z(7)+((-0.5D0*W(7))+W(6)+(-0.5D0*W(5)))*Z(6)+((-0."
     "    &5D0*W(6))+W(5)+(-0.5D0*W(4)))*Z(5)+((-0.5D0*W(5))+W(4)+(-0.5D0*W(3"
     "    &)))*Z(4)+((-0.5D0*W(4))+W(3)+(-0.5D0*W(2)))*Z(3)+((-0.5D0*W(3))+W("
     "    &2)+(-0.5D0*W(1)))*Z(2)+((-0.5D0*W(2))+W(1))*Z(1)"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp27|
  (progn
    (push '|Asp27| *Domains*)
    (make-instance '|Asp27Type|)))

\end{chunk}

\subsection{Asp28}
\index[dom]{Asp28!Domain}
\index[dom]{Domain!Asp28}
\index[dom]{ASP28}
\begin{chunk}{defclass Asp28Type}
(defclass |Asp28Type| (|FortranMatrixCategoryType|)
  ((parents :initform '(|FortranMatrixCategory|))
   (name :initform "Asp28")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP28)
   (comment :initform (list
     "Asp28 produces Fortran for Type 28 ASPs, used in NAG routine"
     "f02fjf, for example:"
     " "
     "     SUBROUTINE IMAGE(IFLAG,N,Z,W,RWORK,LRWORK,IWORK,LIWORK)"
     "     DOUBLE PRECISION Z(N),W(N),IWORK(LRWORK),RWORK(LRWORK)"
     "     INTEGER N,LIWORK,IFLAG,LRWORK"
     "     W(1)=0.01707454969713436D0*Z(16)+0.001747395874954051D0*Z(15)+0.00"
     "    &2106973900813502D0*Z(14)+0.002957434991769087D0*Z(13)+(-0.00700554"
     "    &0882865317D0*Z(12))+(-0.01219194009813166D0*Z(11))+0.0037230647365"
     "    &3087D0*Z(10)+0.04932374658377151D0*Z(9)+(-0.03586220812223305D0*Z("
     "    &8))+(-0.04723268012114625D0*Z(7))+(-0.02434652144032987D0*Z(6))+0."
     "    &2264766947290192D0*Z(5)+(-0.1385343580686922D0*Z(4))+(-0.116530050"
     "    &8238904D0*Z(3))+(-0.2803531651057233D0*Z(2))+1.019463911841327D0*Z"
     "    &(1)"
     "     W(2)=0.0227345011107737D0*Z(16)+0.008812321197398072D0*Z(15)+0.010"
     "    &94012210519586D0*Z(14)+(-0.01764072463999744D0*Z(13))+(-0.01357136"
     "    &72105995D0*Z(12))+0.00157466157362272D0*Z(11)+0.05258889186338282D"
     "    &0*Z(10)+(-0.01981532388243379D0*Z(9))+(-0.06095390688679697D0*Z(8)"
     "    &)+(-0.04153119955569051D0*Z(7))+0.2176561076571465D0*Z(6)+(-0.0532"
     "    &5555586632358D0*Z(5))+(-0.1688977368984641D0*Z(4))+(-0.32440166056"
     "    &67343D0*Z(3))+0.9128222941872173D0*Z(2)+(-0.2419652703415429D0*Z(1"
     "    &))"
     "     W(3)=0.03371198197190302D0*Z(16)+0.02021603150122265D0*Z(15)+(-0.0"
     "    &06607305534689702D0*Z(14))+(-0.03032392238968179D0*Z(13))+0.002033"
     "    &305231024948D0*Z(12)+0.05375944956767728D0*Z(11)+(-0.0163213312502"
     "    &9967D0*Z(10))+(-0.05483186562035512D0*Z(9))+(-0.04901428822579872D"
     "    &0*Z(8))+0.2091097927887612D0*Z(7)+(-0.05760560341383113D0*Z(6))+(-"
     "    &0.1236679206156403D0*Z(5))+(-0.3523683853026259D0*Z(4))+0.88929961"
     "    &32269974D0*Z(3)+(-0.2995429545781457D0*Z(2))+(-0.02986582812574917"
     "    &D0*Z(1))"
     "     W(4)=0.05141563713660119D0*Z(16)+0.005239165960779299D0*Z(15)+(-0."
     "    &01623427735779699D0*Z(14))+(-0.01965809746040371D0*Z(13))+0.054688"
     "    &97337339577D0*Z(12)+(-0.014224695935687D0*Z(11))+(-0.0505181779315"
     "    &6355D0*Z(10))+(-0.04353074206076491D0*Z(9))+0.2012230497530726D0*Z"
     "    &(8)+(-0.06630874514535952D0*Z(7))+(-0.1280829963720053D0*Z(6))+(-0"
     "    &.305169742604165D0*Z(5))+0.8600427128450191D0*Z(4)+(-0.32415033802"
     "    &68184D0*Z(3))+(-0.09033531980693314D0*Z(2))+0.09089205517109111D0*"
     "    &Z(1)"
     "     W(5)=0.04556369767776375D0*Z(16)+(-0.001822737697581869D0*Z(15))+("
     "    &-0.002512226501941856D0*Z(14))+0.02947046460707379D0*Z(13)+(-0.014"
     "    &45079632086177D0*Z(12))+(-0.05034242196614937D0*Z(11))+(-0.0376966"
     "    &3291725935D0*Z(10))+0.2171103102175198D0*Z(9)+(-0.0824949256021352"
     "    &4D0*Z(8))+(-0.1473995209288945D0*Z(7))+(-0.315042193418466D0*Z(6))"
     "    &+0.9591623347824002D0*Z(5)+(-0.3852396953763045D0*Z(4))+(-0.141718"
     "    &5427288274D0*Z(3))+(-0.03423495461011043D0*Z(2))+0.319820917706851"
     "    &6D0*Z(1)"
     "     W(6)=0.04015147277405744D0*Z(16)+0.01328585741341559D0*Z(15)+0.048"
     "    &26082005465965D0*Z(14)+(-0.04319641116207706D0*Z(13))+(-0.04931323"
     "    &319055762D0*Z(12))+(-0.03526886317505474D0*Z(11))+0.22295383396730"
     "    &01D0*Z(10)+(-0.07375317649315155D0*Z(9))+(-0.1589391311991561D0*Z("
     "    &8))+(-0.328001910890377D0*Z(7))+0.952576555482747D0*Z(6)+(-0.31583"
     "    &09975786731D0*Z(5))+(-0.1846882042225383D0*Z(4))+(-0.0703762046700"
     "    &4427D0*Z(3))+0.2311852964327382D0*Z(2)+0.04254083491825025D0*Z(1)"
     "     W(7)=0.06069778964023718D0*Z(16)+0.06681263884671322D0*Z(15)+(-0.0"
     "    &2113506688615768D0*Z(14))+(-0.083996867458326D0*Z(13))+(-0.0329843"
     "    &8523869648D0*Z(12))+0.2276878326327734D0*Z(11)+(-0.067356038933017"
     "    &95D0*Z(10))+(-0.1559813965382218D0*Z(9))+(-0.3363262957694705D0*Z("
     "    &8))+0.9442791158560948D0*Z(7)+(-0.3199955249404657D0*Z(6))+(-0.136"
     "    &2463839920727D0*Z(5))+(-0.1006185171570586D0*Z(4))+0.2057504515015"
     "    &423D0*Z(3)+(-0.02065879269286707D0*Z(2))+0.03160990266745513D0*Z(1"
     "    &)"
     "     W(8)=0.126386868896738D0*Z(16)+0.002563370039476418D0*Z(15)+(-0.05"
     "    &581757739455641D0*Z(14))+(-0.07777893205900685D0*Z(13))+0.23117338"
     "    &45834199D0*Z(12)+(-0.06031581134427592D0*Z(11))+(-0.14805474755869"
     "    &52D0*Z(10))+(-0.3364014128402243D0*Z(9))+0.9364014128402244D0*Z(8)"
     "    &+(-0.3269452524413048D0*Z(7))+(-0.1396841886557241D0*Z(6))+(-0.056"
     "    &1733845834199D0*Z(5))+0.1777789320590069D0*Z(4)+(-0.04418242260544"
     "    &359D0*Z(3))+(-0.02756337003947642D0*Z(2))+0.07361313110326199D0*Z("
     "    &1)"
     "     W(9)=0.07361313110326199D0*Z(16)+(-0.02756337003947642D0*Z(15))+(-"
     "    &0.04418242260544359D0*Z(14))+0.1777789320590069D0*Z(13)+(-0.056173"
     "    &3845834199D0*Z(12))+(-0.1396841886557241D0*Z(11))+(-0.326945252441"
     "    &3048D0*Z(10))+0.9364014128402244D0*Z(9)+(-0.3364014128402243D0*Z(8"
     "    &))+(-0.1480547475586952D0*Z(7))+(-0.06031581134427592D0*Z(6))+0.23"
     "    &11733845834199D0*Z(5)+(-0.07777893205900685D0*Z(4))+(-0.0558175773"
     "    &9455641D0*Z(3))+0.002563370039476418D0*Z(2)+0.126386868896738D0*Z("
     "    &1)"
     "     W(10)=0.03160990266745513D0*Z(16)+(-0.02065879269286707D0*Z(15))+0"
     "    &.2057504515015423D0*Z(14)+(-0.1006185171570586D0*Z(13))+(-0.136246"
     "    &3839920727D0*Z(12))+(-0.3199955249404657D0*Z(11))+0.94427911585609"
     "    &48D0*Z(10)+(-0.3363262957694705D0*Z(9))+(-0.1559813965382218D0*Z(8"
     "    &))+(-0.06735603893301795D0*Z(7))+0.2276878326327734D0*Z(6)+(-0.032"
     "    &98438523869648D0*Z(5))+(-0.083996867458326D0*Z(4))+(-0.02113506688"
     "    &615768D0*Z(3))+0.06681263884671322D0*Z(2)+0.06069778964023718D0*Z("
     "    &1)"
     "     W(11)=0.04254083491825025D0*Z(16)+0.2311852964327382D0*Z(15)+(-0.0"
     "    &7037620467004427D0*Z(14))+(-0.1846882042225383D0*Z(13))+(-0.315830"
     "    &9975786731D0*Z(12))+0.952576555482747D0*Z(11)+(-0.328001910890377D"
     "    &0*Z(10))+(-0.1589391311991561D0*Z(9))+(-0.07375317649315155D0*Z(8)"
     "    &)+0.2229538339673001D0*Z(7)+(-0.03526886317505474D0*Z(6))+(-0.0493"
     "    &1323319055762D0*Z(5))+(-0.04319641116207706D0*Z(4))+0.048260820054"
     "    &65965D0*Z(3)+0.01328585741341559D0*Z(2)+0.04015147277405744D0*Z(1)"
     "     W(12)=0.3198209177068516D0*Z(16)+(-0.03423495461011043D0*Z(15))+(-"
     "    &0.1417185427288274D0*Z(14))+(-0.3852396953763045D0*Z(13))+0.959162"
     "    &3347824002D0*Z(12)+(-0.315042193418466D0*Z(11))+(-0.14739952092889"
     "    &45D0*Z(10))+(-0.08249492560213524D0*Z(9))+0.2171103102175198D0*Z(8"
     "    &)+(-0.03769663291725935D0*Z(7))+(-0.05034242196614937D0*Z(6))+(-0."
     "    &01445079632086177D0*Z(5))+0.02947046460707379D0*Z(4)+(-0.002512226"
     "    &501941856D0*Z(3))+(-0.001822737697581869D0*Z(2))+0.045563697677763"
     "    &75D0*Z(1)"
     "     W(13)=0.09089205517109111D0*Z(16)+(-0.09033531980693314D0*Z(15))+("
     "    &-0.3241503380268184D0*Z(14))+0.8600427128450191D0*Z(13)+(-0.305169"
     "    &742604165D0*Z(12))+(-0.1280829963720053D0*Z(11))+(-0.0663087451453"
     "    &5952D0*Z(10))+0.2012230497530726D0*Z(9)+(-0.04353074206076491D0*Z("
     "    &8))+(-0.05051817793156355D0*Z(7))+(-0.014224695935687D0*Z(6))+0.05"
     "    &468897337339577D0*Z(5)+(-0.01965809746040371D0*Z(4))+(-0.016234277"
     "    &35779699D0*Z(3))+0.005239165960779299D0*Z(2)+0.05141563713660119D0"
     "    &*Z(1)"
     "     W(14)=(-0.02986582812574917D0*Z(16))+(-0.2995429545781457D0*Z(15))"
     "    &+0.8892996132269974D0*Z(14)+(-0.3523683853026259D0*Z(13))+(-0.1236"
     "    &679206156403D0*Z(12))+(-0.05760560341383113D0*Z(11))+0.20910979278"
     "    &87612D0*Z(10)+(-0.04901428822579872D0*Z(9))+(-0.05483186562035512D"
     "    &0*Z(8))+(-0.01632133125029967D0*Z(7))+0.05375944956767728D0*Z(6)+0"
     "    &.002033305231024948D0*Z(5)+(-0.03032392238968179D0*Z(4))+(-0.00660"
     "    &7305534689702D0*Z(3))+0.02021603150122265D0*Z(2)+0.033711981971903"
     "    &02D0*Z(1)"
     "     W(15)=(-0.2419652703415429D0*Z(16))+0.9128222941872173D0*Z(15)+(-0"
     "    &.3244016605667343D0*Z(14))+(-0.1688977368984641D0*Z(13))+(-0.05325"
     "    &555586632358D0*Z(12))+0.2176561076571465D0*Z(11)+(-0.0415311995556"
     "    &9051D0*Z(10))+(-0.06095390688679697D0*Z(9))+(-0.01981532388243379D"
     "    &0*Z(8))+0.05258889186338282D0*Z(7)+0.00157466157362272D0*Z(6)+(-0."
     "    &0135713672105995D0*Z(5))+(-0.01764072463999744D0*Z(4))+0.010940122"
     "    &10519586D0*Z(3)+0.008812321197398072D0*Z(2)+0.0227345011107737D0*Z"
     "    &(1)"
     "     W(16)=1.019463911841327D0*Z(16)+(-0.2803531651057233D0*Z(15))+(-0."
     "    &1165300508238904D0*Z(14))+(-0.1385343580686922D0*Z(13))+0.22647669"
     "    &47290192D0*Z(12)+(-0.02434652144032987D0*Z(11))+(-0.04723268012114"
     "    &625D0*Z(10))+(-0.03586220812223305D0*Z(9))+0.04932374658377151D0*Z"
     "    &(8)+0.00372306473653087D0*Z(7)+(-0.01219194009813166D0*Z(6))+(-0.0"
     "    &07005540882865317D0*Z(5))+0.002957434991769087D0*Z(4)+0.0021069739"
     "    &00813502D0*Z(3)+0.001747395874954051D0*Z(2)+0.01707454969713436D0*"
     "    &Z(1)"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp28|
  (progn
    (push '|Asp28| *Domains*)
    (make-instance '|Asp28Type|)))

\end{chunk}

\subsection{Asp29}
\index[dom]{Asp29!Domain}
\index[dom]{Domain!Asp29}
\index[dom]{ASP29}
\begin{chunk}{defclass Asp29Type}
(defclass |Asp29Type| (|FortranProgramCategoryType|)
  ((parents :initform '(|FortranProgramCategory|))
   (name :initform "Asp29")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP29)
   (comment :initform (list
     "Asp29 produces Fortran for Type 29 ASPs, needed for NAG routine"
     "f02fjf, for example:"
     " "
     "     SUBROUTINE MONIT(ISTATE,NEXTIT,NEVALS,NEVECS,K,F,D)"
     "     DOUBLE PRECISION D(K),F(K)"
     "     INTEGER K,NEXTIT,NEVALS,NVECS,ISTATE"
     "     CALL F02FJZ(ISTATE,NEXTIT,NEVALS,NEVECS,K,F,D)"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp29|
  (progn
    (push '|Asp29| *Domains*)
    (make-instance '|Asp29Type|)))

\end{chunk}

\subsection{Asp30}
\index[dom]{Asp30!Domain}
\index[dom]{Domain!Asp30}
\index[dom]{ASP30}
\begin{chunk}{defclass Asp30Type}
(defclass |Asp30Type| (|FortranMatrixCategoryType|)
  ((parents :initform '(|FortranMatrixCategory|))
   (name :initform "Asp30")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP30)
   (comment :initform (list
     "Asp30 produces Fortran for Type 30 ASPs, needed for NAG routine"
     "f04qaf, for example:"
     " "
     "     SUBROUTINE APROD(MODE,M,N,X,Y,RWORK,LRWORK,IWORK,LIWORK)"
     "     DOUBLE PRECISION X(N),Y(M),RWORK(LRWORK)"
     "     INTEGER M,N,LIWORK,IFAIL,LRWORK,IWORK(LIWORK),MODE"
     "     DOUBLE PRECISION A(5,5)"
     "     EXTERNAL F06PAF"
     "     A(1,1)=1.0D0"
     "     A(1,2)=0.0D0"
     "     A(1,3)=0.0D0"
     "     A(1,4)=-1.0D0"
     "     A(1,5)=0.0D0"
     "     A(2,1)=0.0D0"
     "     A(2,2)=1.0D0"
     "     A(2,3)=0.0D0"
     "     A(2,4)=0.0D0"
     "     A(2,5)=-1.0D0"
     "     A(3,1)=0.0D0"
     "     A(3,2)=0.0D0"
     "     A(3,3)=1.0D0"
     "     A(3,4)=-1.0D0"
     "     A(3,5)=0.0D0"
     "     A(4,1)=-1.0D0"
     "     A(4,2)=0.0D0"
     "     A(4,3)=-1.0D0"
     "     A(4,4)=4.0D0"
     "     A(4,5)=-1.0D0"
     "     A(5,1)=0.0D0"
     "     A(5,2)=-1.0D0"
     "     A(5,3)=0.0D0"
     "     A(5,4)=-1.0D0"
     "     A(5,5)=4.0D0"
     "     IF(MODE.EQ.1)THEN"
     "       CALL F06PAF('N',M,N,1.0D0,A,M,X,1,1.0D0,Y,1)"
     "     ELSEIF(MODE.EQ.2)THEN"
     "       CALL F06PAF('T',M,N,1.0D0,A,M,Y,1,1.0D0,X,1)"
     "     ENDIF"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp30|
  (progn
    (push '|Asp30| *Domains*)
    (make-instance '|Asp30Type|)))

\end{chunk}

\subsection{Asp31}
\index[dom]{Asp31!Domain}
\index[dom]{Domain!Asp31}
\index[dom]{ASP31}
\begin{chunk}{defclass Asp31Type}
(defclass |Asp31Type| (|FortranVectorFunctionCategoryType|)
  ((parents :initform '(|FortranVectorFunctionCategory|))
   (name :initform "Asp31")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP31)
   (comment :initform (list
     "Asp31 produces Fortran for Type 31 ASPs, needed for NAG routine"
     "d02ejf, for example:"
     " "
     "     SUBROUTINE PEDERV(X,Y,PW)"
     "     DOUBLE PRECISION X,Y(*)"
     "     DOUBLE PRECISION PW(3,3)"
     "     PW(1,1)=-0.03999999999999999D0"
     "     PW(1,2)=10000.0D0*Y(3)"
     "     PW(1,3)=10000.0D0*Y(2)"
     "     PW(2,1)=0.03999999999999999D0"
     "     PW(2,2)=(-10000.0D0*Y(3))+(-60000000.0D0*Y(2))"
     "     PW(2,3)=-10000.0D0*Y(2)"
     "     PW(3,1)=0.0D0"
     "     PW(3,2)=60000000.0D0*Y(2)"
     "     PW(3,3)=0.0D0"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp31|
  (progn
    (push '|Asp31| *Domains*)
    (make-instance '|Asp31Type|)))

\end{chunk}

\subsection{Asp33}
\index[dom]{Asp33!Domain}
\index[dom]{Domain!Asp33}
\index[dom]{ASP33}
\begin{chunk}{defclass Asp33Type}
(defclass |Asp33Type| (|FortranProgramCategoryType|)
  ((parents :initform '(|FortranProgramCategory|))
   (name :initform "Asp33")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP33)
   (comment :initform (list
     "Asp33 produces Fortran for Type 33 ASPs, needed for NAG routine"
     "d02kef.  The code is a dummy ASP:"
     " "
     "     SUBROUTINE REPORT(X,V,JINT)"
     "     DOUBLE PRECISION V(3),X"
     "     INTEGER JINT"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp33|
  (progn
    (push '|Asp33| *Domains*)
    (make-instance '|Asp33Type|)))

\end{chunk}

\subsection{Asp34}
\index[dom]{Asp34!Domain}
\index[dom]{Domain!Asp34}
\index[dom]{ASP34}
\begin{chunk}{defclass Asp34Type}
(defclass |Asp34Type| (|FortranMatrixCategoryType|)
  ((parents :initform '(|FortranMatrixCategory|))
   (name :initform "Asp34")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP34)
   (comment :initform (list
     "Asp34 produces Fortran for Type 34 ASPs, needed for NAG routine"
     "f04mbf, for example:"
     " "
     "     SUBROUTINE MSOLVE(IFLAG,N,X,Y,RWORK,LRWORK,IWORK,LIWORK)"
     "     DOUBLE PRECISION RWORK(LRWORK),X(N),Y(N)"
     "     INTEGER I,J,N,LIWORK,IFLAG,LRWORK,IWORK(LIWORK)"
     "     DOUBLE PRECISION W1(3),W2(3),MS(3,3)"
     "     IFLAG=-1"
     "     MS(1,1)=2.0D0"
     "     MS(1,2)=1.0D0"
     "     MS(1,3)=0.0D0"
     "     MS(2,1)=1.0D0"
     "     MS(2,2)=2.0D0"
     "     MS(2,3)=1.0D0"
     "     MS(3,1)=0.0D0"
     "     MS(3,2)=1.0D0"
     "     MS(3,3)=2.0D0"
     "     CALL F04ASF(MS,N,X,N,Y,W1,W2,IFLAG)"
     "     IFLAG=-IFLAG"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp34|
  (progn
    (push '|Asp34| *Domains*)
    (make-instance '|Asp34Type|)))

\end{chunk}

\subsection{Asp35}
\index[dom]{Asp35!Domain}
\index[dom]{Domain!Asp35}
\index[dom]{ASP35}
\begin{chunk}{defclass Asp35Type}
(defclass |Asp35Type| (|FortranVectorFunctionCategoryType|)
  ((parents :initform '(|FortranVectorFunctionCategory|))
   (name :initform "Asp35")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP35)
   (comment :initform (list
     "Asp35 produces Fortran for Type 35 ASPs, needed for NAG routines"
     "c05pbf, c05pcf, for example:"
     " "
     "     SUBROUTINE FCN(N,X,FVEC,FJAC,LDFJAC,IFLAG)"
     "     DOUBLE PRECISION X(N),FVEC(N),FJAC(LDFJAC,N)"
     "     INTEGER LDFJAC,N,IFLAG"
     "     IF(IFLAG.EQ.1)THEN"
     "       FVEC(1)=(-1.0D0*X(2))+X(1)"
     "       FVEC(2)=(-1.0D0*X(3))+2.0D0*X(2)"
     "       FVEC(3)=3.0D0*X(3)"
     "     ELSEIF(IFLAG.EQ.2)THEN"
     "       FJAC(1,1)=1.0D0"
     "       FJAC(1,2)=-1.0D0"
     "       FJAC(1,3)=0.0D0"
     "       FJAC(2,1)=0.0D0"
     "       FJAC(2,2)=2.0D0"
     "       FJAC(2,3)=-1.0D0"
     "       FJAC(3,1)=0.0D0"
     "       FJAC(3,2)=0.0D0"
     "       FJAC(3,3)=3.0D0"
     "     ENDIF"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp35|
  (progn
    (push '|Asp35| *Domains*)
    (make-instance '|Asp35Type|)))

\end{chunk}

\subsection{Asp4}
\index[dom]{Asp4!Domain}
\index[dom]{Domain!Asp4}
\index[dom]{ASP4}
\begin{chunk}{defclass Asp4Type}
(defclass |Asp4Type| (|FortranFunctionCategoryType|)
  ((parents :initform '(|FortranFunctionCategory|))
   (name :initform "Asp4")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP4)
   (comment :initform (list
     "Asp4 produces Fortran for Type 4 ASPs, which take an expression"
     "in X(1) .. X(NDIM) and produce a real function of the form:"
     " "
     "     DOUBLE PRECISION FUNCTION FUNCTN(NDIM,X)"
     "     DOUBLE PRECISION X(NDIM)"
     "     INTEGER NDIM"
     "     FUNCTN=(4.0D0*X(1)*X(3)**2*DEXP(2.0D0*X(1)*X(3)))/(X(4)**2+(2.0D0*"
     "    &X(2)+2.0D0)*X(4)+X(2)**2+2.0D0*X(2)+1.0D0)"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp4|
  (progn
    (push '|Asp4| *Domains*)
    (make-instance '|Asp4Type|)))

\end{chunk}

\subsection{Asp41}
\index[dom]{Asp41!Domain}
\index[dom]{Domain!Asp41}
\index[dom]{ASP41}
\begin{chunk}{defclass Asp41Type}
(defclass |Asp41Type| (|FortranVectorFunctionCategoryType|)
  ((parents :initform '(|FortranVectorFunctionCategory|))
   (name :initform "Asp41")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP41)
   (comment :initform (list
     "Asp41 produces Fortran for Type 41 ASPs, needed for NAG"
     "routines d02raf and d02saf in particular.  These ASPs are in fact"
     "three Fortran routines which return a vector of functions, and their"
     "derivatives wrt Y(i) and also a continuation parameter EPS, for example:"
     " "
     "     SUBROUTINE FCN(X,EPS,Y,F,N)"
     "     DOUBLE PRECISION EPS,F(N),X,Y(N)"
     "     INTEGER N"
     "     F(1)=Y(2)"
     "     F(2)=Y(3)"
     "     F(3)=(-1.0D0*Y(1)*Y(3))+2.0D0*EPS*Y(2)**2+(-2.0D0*EPS)"
     "     RETURN"
     "     END"
     "     SUBROUTINE JACOBF(X,EPS,Y,F,N)"
     "     DOUBLE PRECISION EPS,F(N,N),X,Y(N)"
     "     INTEGER N"
     "     F(1,1)=0.0D0"
     "     F(1,2)=1.0D0"
     "     F(1,3)=0.0D0"
     "     F(2,1)=0.0D0"
     "     F(2,2)=0.0D0"
     "     F(2,3)=1.0D0"
     "     F(3,1)=-1.0D0*Y(3)"
     "     F(3,2)=4.0D0*EPS*Y(2)"
     "     F(3,3)=-1.0D0*Y(1)"
     "     RETURN"
     "     END"
     "     SUBROUTINE JACEPS(X,EPS,Y,F,N)"
     "     DOUBLE PRECISION EPS,F(N),X,Y(N)"
     "     INTEGER N"
     "     F(1)=0.0D0"
     "     F(2)=0.0D0"
     "     F(3)=2.0D0*Y(2)**2-2.0D0"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp41|
  (progn
    (push '|Asp41| *Domains*)
    (make-instance '|Asp41Type|)))

\end{chunk}

\subsection{Asp42}
\index[dom]{Asp42!Domain}
\index[dom]{Domain!Asp42}
\index[dom]{ASP42}
\begin{chunk}{defclass Asp42Type}
(defclass |Asp42Type| (|FortranVectorFunctionCategoryType|)
  ((parents :initform '(|FortranVectorFunctionCategory|))
   (name :initform "Asp42")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP42)
   (comment :initform (list
     "Asp42 produces Fortran for Type 42 ASPs, needed for NAG"
     "routines d02raf and d02saf"
     "in particular.  These ASPs are in fact"
     "three Fortran routines which return a vector of functions, and their"
     "derivatives wrt Y(i) and also a continuation parameter EPS, for example:"
     " "
     "     SUBROUTINE G(EPS,YA,YB,BC,N)"
     "     DOUBLE PRECISION EPS,YA(N),YB(N),BC(N)"
     "     INTEGER N"
     "     BC(1)=YA(1)"
     "     BC(2)=YA(2)"
     "     BC(3)=YB(2)-1.0D0"
     "     RETURN"
     "     END"
     "     SUBROUTINE JACOBG(EPS,YA,YB,AJ,BJ,N)"
     "     DOUBLE PRECISION EPS,YA(N),AJ(N,N),BJ(N,N),YB(N)"
     "     INTEGER N"
     "     AJ(1,1)=1.0D0"
     "     AJ(1,2)=0.0D0"
     "     AJ(1,3)=0.0D0"
     "     AJ(2,1)=0.0D0"
     "     AJ(2,2)=1.0D0"
     "     AJ(2,3)=0.0D0"
     "     AJ(3,1)=0.0D0"
     "     AJ(3,2)=0.0D0"
     "     AJ(3,3)=0.0D0"
     "     BJ(1,1)=0.0D0"
     "     BJ(1,2)=0.0D0"
     "     BJ(1,3)=0.0D0"
     "     BJ(2,1)=0.0D0"
     "     BJ(2,2)=0.0D0"
     "     BJ(2,3)=0.0D0"
     "     BJ(3,1)=0.0D0"
     "     BJ(3,2)=1.0D0"
     "     BJ(3,3)=0.0D0"
     "     RETURN"
     "     END"
     "     SUBROUTINE JACGEP(EPS,YA,YB,BCEP,N)"
     "     DOUBLE PRECISION EPS,YA(N),YB(N),BCEP(N)"
     "     INTEGER N"
     "     BCEP(1)=0.0D0"
     "     BCEP(2)=0.0D0"
     "     BCEP(3)=0.0D0"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp42|
  (progn
    (push '|Asp42| *Domains*)
    (make-instance '|Asp42Type|)))

\end{chunk}

\subsection{Asp49}
\index[dom]{Asp49!Domain}
\index[dom]{Domain!Asp49}
\index[dom]{ASP49}
\begin{chunk}{defclass Asp49Type}
(defclass |Asp49Type| (|FortranFunctionCategoryType|)
  ((parents :initform '(|FortranFunctionCategory|))
   (name :initform "Asp49")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP49)
   (comment :initform (list
     "Asp49 produces Fortran for Type 49 ASPs, needed for NAG routines"
     "e04dgf, e04ucf, for example:"
     " "
     "     SUBROUTINE OBJFUN(MODE,N,X,OBJF,OBJGRD,NSTATE,IUSER,USER)"
     "     DOUBLE PRECISION X(N),OBJF,OBJGRD(N),USER(*)"
     "     INTEGER N,IUSER(*),MODE,NSTATE"
     "     OBJF=X(4)*X(9)+((-1.0D0*X(5))+X(3))*X(8)+((-1.0D0*X(3))+X(1))*X(7)"
     "    &+(-1.0D0*X(2)*X(6))"
     "     OBJGRD(1)=X(7)"
     "     OBJGRD(2)=-1.0D0*X(6)"
     "     OBJGRD(3)=X(8)+(-1.0D0*X(7))"
     "     OBJGRD(4)=X(9)"
     "     OBJGRD(5)=-1.0D0*X(8)"
     "     OBJGRD(6)=-1.0D0*X(2)"
     "     OBJGRD(7)=(-1.0D0*X(3))+X(1)"
     "     OBJGRD(8)=(-1.0D0*X(5))+X(3)"
     "     OBJGRD(9)=X(4)"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp49|
  (progn
    (push '|Asp49| *Domains*)
    (make-instance '|Asp49Type|)))

\end{chunk}

\subsection{Asp50}
\index[dom]{Asp50!Domain}
\index[dom]{Domain!Asp50}
\index[dom]{ASP50}
\begin{chunk}{defclass Asp50Type}
(defclass |Asp50Type| (|FortranVectorFunctionCategoryType|)
  ((parents :initform '(|FortranVectorFunctionCategory|))
   (name :initform "Asp50")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP50)
   (comment :initform (list
     "Asp50 produces Fortran for Type 50 ASPs, needed for NAG routine"
     "e04fdf, for example:"
     " "
     "     SUBROUTINE LSFUN1(M,N,XC,FVECC)"
     "     DOUBLE PRECISION FVECC(M),XC(N)"
     "     INTEGER I,M,N"
     "     FVECC(1)=((XC(1)-2.4D0)*XC(3)+(15.0D0*XC(1)-36.0D0)*XC(2)+1.0D0)/("
     "    &XC(3)+15.0D0*XC(2))"
     "     FVECC(2)=((XC(1)-2.8D0)*XC(3)+(7.0D0*XC(1)-19.6D0)*XC(2)+1.0D0)/(X"
     "    &C(3)+7.0D0*XC(2))"
     "     FVECC(3)=((XC(1)-3.2D0)*XC(3)+(4.333333333333333D0*XC(1)-13.866666"
     "    &66666667D0)*XC(2)+1.0D0)/(XC(3)+4.333333333333333D0*XC(2))"
     "     FVECC(4)=((XC(1)-3.5D0)*XC(3)+(3.0D0*XC(1)-10.5D0)*XC(2)+1.0D0)/(X"
     "    &C(3)+3.0D0*XC(2))"
     "     FVECC(5)=((XC(1)-3.9D0)*XC(3)+(2.2D0*XC(1)-8.579999999999998D0)*XC"
     "    &(2)+1.0D0)/(XC(3)+2.2D0*XC(2))"
     "     FVECC(6)=((XC(1)-4.199999999999999D0)*XC(3)+(1.666666666666667D0*X"
     "    &C(1)-7.0D0)*XC(2)+1.0D0)/(XC(3)+1.666666666666667D0*XC(2))"
     "     FVECC(7)=((XC(1)-4.5D0)*XC(3)+(1.285714285714286D0*XC(1)-5.7857142"
     "    &85714286D0)*XC(2)+1.0D0)/(XC(3)+1.285714285714286D0*XC(2))"
     "     FVECC(8)=((XC(1)-4.899999999999999D0)*XC(3)+(XC(1)-4.8999999999999"
     "    &99D0)*XC(2)+1.0D0)/(XC(3)+XC(2))"
     "     FVECC(9)=((XC(1)-4.699999999999999D0)*XC(3)+(XC(1)-4.6999999999999"
     "    &99D0)*XC(2)+1.285714285714286D0)/(XC(3)+XC(2))"
     "     FVECC(10)=((XC(1)-6.8D0)*XC(3)+(XC(1)-6.8D0)*XC(2)+1.6666666666666"
     "    &67D0)/(XC(3)+XC(2))"
     "     FVECC(11)=((XC(1)-8.299999999999999D0)*XC(3)+(XC(1)-8.299999999999"
     "    &999D0)*XC(2)+2.2D0)/(XC(3)+XC(2))"
     "     FVECC(12)=((XC(1)-10.6D0)*XC(3)+(XC(1)-10.6D0)*XC(2)+3.0D0)/(XC(3)"
     "    &+XC(2))"
     "     FVECC(13)=((XC(1)-1.34D0)*XC(3)+(XC(1)-1.34D0)*XC(2)+4.33333333333"
     "    &3333D0)/(XC(3)+XC(2))"
     "     FVECC(14)=((XC(1)-2.1D0)*XC(3)+(XC(1)-2.1D0)*XC(2)+7.0D0)/(XC(3)+X"
     "    &C(2))"
     "     FVECC(15)=((XC(1)-4.39D0)*XC(3)+(XC(1)-4.39D0)*XC(2)+15.0D0)/(XC(3"
     "    &)+XC(2))"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp50|
  (progn
    (push '|Asp50| *Domains*)
    (make-instance '|Asp50Type|)))

\end{chunk}

\subsection{Asp55}
\index[dom]{Asp55!Domain}
\index[dom]{Domain!Asp55}
\index[dom]{ASP55}
\begin{chunk}{defclass Asp55Type}
(defclass |Asp55Type| (|FortranVectorFunctionCategoryType|)
  ((parents :initform '(|FortranVectorFunctionCategory|))
   (name :initform "Asp55")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP55)
   (comment :initform (list
     "Asp55 produces Fortran for Type 55 ASPs, needed for NAG routines"
     "e04dgf and e04ucf, for example:"
     " "
     "     SUBROUTINE CONFUN(MODE,NCNLN,N,NROWJ,NEEDC,X,C,CJAC,NSTATE,IUSER"
     "    &,USER)"
     "     DOUBLE PRECISION C(NCNLN),X(N),CJAC(NROWJ,N),USER(*)"
     "     INTEGER N,IUSER(*),NEEDC(NCNLN),NROWJ,MODE,NCNLN,NSTATE"
     "     IF(NEEDC(1).GT.0)THEN"
     "       C(1)=X(6)**2+X(1)**2"
     "       CJAC(1,1)=2.0D0*X(1)"
     "       CJAC(1,2)=0.0D0"
     "       CJAC(1,3)=0.0D0"
     "       CJAC(1,4)=0.0D0"
     "       CJAC(1,5)=0.0D0"
     "       CJAC(1,6)=2.0D0*X(6)"
     "     ENDIF"
     "     IF(NEEDC(2).GT.0)THEN"
     "       C(2)=X(2)**2+(-2.0D0*X(1)*X(2))+X(1)**2"
     "       CJAC(2,1)=(-2.0D0*X(2))+2.0D0*X(1)"
     "       CJAC(2,2)=2.0D0*X(2)+(-2.0D0*X(1))"
     "       CJAC(2,3)=0.0D0"
     "       CJAC(2,4)=0.0D0"
     "       CJAC(2,5)=0.0D0"
     "       CJAC(2,6)=0.0D0"
     "     ENDIF"
     "     IF(NEEDC(3).GT.0)THEN"
     "       C(3)=X(3)**2+(-2.0D0*X(1)*X(3))+X(2)**2+X(1)**2"
     "       CJAC(3,1)=(-2.0D0*X(3))+2.0D0*X(1)"
     "       CJAC(3,2)=2.0D0*X(2)"
     "       CJAC(3,3)=2.0D0*X(3)+(-2.0D0*X(1))"
     "       CJAC(3,4)=0.0D0"
     "       CJAC(3,5)=0.0D0"
     "       CJAC(3,6)=0.0D0"
     "     ENDIF"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp55|
  (progn
    (push '|Asp55| *Domains*)
    (make-instance '|Asp55Type|)))

\end{chunk}

\subsection{Asp6}
\index[dom]{Asp6!Domain}
\index[dom]{Domain!Asp6}
\index[dom]{ASP6}
\begin{chunk}{defclass Asp6Type}
(defclass |Asp6Type| (|FortranVectorFunctionCategoryType|)
  ((parents :initform '(|FortranVectorFunctionCategory|))
   (name :initform "Asp6")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP6)
   (comment :initform (list
     "Asp6 produces Fortran for Type 6 ASPs, needed for NAG routines"
     "c05nbf, c05ncf. These represent vectors of functions of X(i) and look like:"
     " "
     "     SUBROUTINE FCN(N,X,FVEC,IFLAG)"
     "     DOUBLE PRECISION X(N),FVEC(N)"
     "     INTEGER N,IFLAG"
     "     FVEC(1)=(-2.0D0*X(2))+(-2.0D0*X(1)**2)+3.0D0*X(1)+1.0D0"
     "     FVEC(2)=(-2.0D0*X(3))+(-2.0D0*X(2)**2)+3.0D0*X(2)+(-1.0D0*X(1))+1."
     "    &0D0"
     "     FVEC(3)=(-2.0D0*X(4))+(-2.0D0*X(3)**2)+3.0D0*X(3)+(-1.0D0*X(2))+1."
     "    &0D0"
     "     FVEC(4)=(-2.0D0*X(5))+(-2.0D0*X(4)**2)+3.0D0*X(4)+(-1.0D0*X(3))+1."
     "    &0D0"
     "     FVEC(5)=(-2.0D0*X(6))+(-2.0D0*X(5)**2)+3.0D0*X(5)+(-1.0D0*X(4))+1."
     "    &0D0"
     "     FVEC(6)=(-2.0D0*X(7))+(-2.0D0*X(6)**2)+3.0D0*X(6)+(-1.0D0*X(5))+1."
     "    &0D0"
     "     FVEC(7)=(-2.0D0*X(8))+(-2.0D0*X(7)**2)+3.0D0*X(7)+(-1.0D0*X(6))+1."
     "    &0D0"
     "     FVEC(8)=(-2.0D0*X(9))+(-2.0D0*X(8)**2)+3.0D0*X(8)+(-1.0D0*X(7))+1."
     "    &0D0"
     "     FVEC(9)=(-2.0D0*X(9)**2)+3.0D0*X(9)+(-1.0D0*X(8))+1.0D0"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp6|
  (progn
    (push '|Asp6| *Domains*)
    (make-instance '|Asp6Type|)))

\end{chunk}

\subsection{Asp7}
\index[dom]{Asp7!Domain}
\index[dom]{Domain!Asp7}
\index[dom]{ASP7}
\begin{chunk}{defclass Asp7Type}
(defclass |Asp7Type| (|FortranVectorFunctionCategoryType|)
  ((parents :initform '(|FortranVectorFunctionCategory|))
   (name :initform "Asp7")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP7)
   (comment :initform (list
     "Asp7 produces Fortran for Type 7 ASPs, needed for NAG routines"
     "d02bbf, d02gaf. These represent a vector of functions of the scalar X and"
     "the array Z, and look like:"
     " "
     "     SUBROUTINE FCN(X,Z,F)"
     "     DOUBLE PRECISION F(*),X,Z(*)"
     "     F(1)=DTAN(Z(3))"
     "     F(2)=((-0.03199999999999999D0*DCOS(Z(3))*DTAN(Z(3)))+(-0.02D0*Z(2)"
     "    &**2))/(Z(2)*DCOS(Z(3)))"
     "     F(3)=-0.03199999999999999D0/(X*Z(2)**2)"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp7|
  (progn
    (push '|Asp7| *Domains*)
    (make-instance '|Asp7Type|)))

\end{chunk}

\subsection{Asp73}
\index[dom]{Asp73!Domain}
\index[dom]{Domain!Asp73}
\index[dom]{ASP73}
\begin{chunk}{defclass Asp73Type}
(defclass |Asp73Type| (|FortranVectorFunctionCategoryType|)
  ((parents :initform '(|FortranVectorFunctionCategory|))
   (name :initform "Asp73")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP73)
   (comment :initform (list
     "Asp73 produces Fortran for Type 73 ASPs, needed for NAG routine"
     "d03eef, for example:"
     " "
     "     SUBROUTINE PDEF(X,Y,ALPHA,BETA,GAMMA,DELTA,EPSOLN,PHI,PSI)"
     "     DOUBLE PRECISION ALPHA,EPSOLN,PHI,X,Y,BETA,DELTA,GAMMA,PSI"
     "     ALPHA=DSIN(X)"
     "     BETA=Y"
     "     GAMMA=X*Y"
     "     DELTA=DCOS(X)*DSIN(Y)"
     "     EPSOLN=Y+X"
     "     PHI=X"
     "     PSI=Y"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp73|
  (progn
    (push '|Asp73| *Domains*)
    (make-instance '|Asp73Type|)))

\end{chunk}

\subsection{Asp74}
\index[dom]{Asp74!Domain}
\index[dom]{Domain!Asp74}
\index[dom]{ASp74}
\begin{chunk}{defclass Asp74Type}
(defclass |Asp74Type| (|FortranMatrixFunctionCategoryType|)
  ((parents :initform '(|FortranMatrixFunctionCategory|))
   (name :initform "Asp74")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP74)
   (comment :initform (list
     "Asp74 produces Fortran for Type 74 ASPs, needed for NAG routine"
     "d03eef, for example:"
     " "
     "     SUBROUTINE BNDY(X,Y,A,B,C,IBND)"
     "     DOUBLE PRECISION A,B,C,X,Y"
     "     INTEGER IBND"
     "     IF(IBND.EQ.0)THEN"
     "       A=0.0D0"
     "       B=1.0D0"
     "       C=-1.0D0*DSIN(X)"
     "     ELSEIF(IBND.EQ.1)THEN"
     "       A=1.0D0"
     "       B=0.0D0"
     "       C=DSIN(X)*DSIN(Y)"
     "     ELSEIF(IBND.EQ.2)THEN"
     "       A=1.0D0"
     "       B=0.0D0"
     "       C=DSIN(X)*DSIN(Y)"
     "     ELSEIF(IBND.EQ.3)THEN"
     "       A=0.0D0"
     "       B=1.0D0"
     "       C=-1.0D0*DSIN(Y)"
     "     ENDIF"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp74|
  (progn
    (push '|Asp74| *Domains*)
    (make-instance '|Asp74Type|)))

\end{chunk}

\subsection{Asp77}
\index[dom]{Asp77!Domain}
\index[dom]{Domain!Asp77}
\index[dom]{ASP77}
\begin{chunk}{defclass Asp77Type}
(defclass |Asp77Type| (|FortranMatrixFunctionCategoryType|)
  ((parents :initform '(|FortranMatrixFunctionCategory|))
   (name :initform "Asp77")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP77)
   (comment :initform (list
     "Asp77 produces Fortran for Type 77 ASPs, needed for NAG routine"
     "d02gbf, for example:"
     " "
     "     SUBROUTINE FCNF(X,F)"
     "     DOUBLE PRECISION X"
     "     DOUBLE PRECISION F(2,2)"
     "     F(1,1)=0.0D0"
     "     F(1,2)=1.0D0"
     "     F(2,1)=0.0D0"
     "     F(2,2)=-10.0D0"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp77|
  (progn
    (push '|Asp77| *Domains*)
    (make-instance '|Asp77Type|)))

\end{chunk}

\subsection{Asp78}
\index[dom]{Asp78!Domain}
\index[dom]{Domain!Asp78}
\index[dom]{ASP78}
\begin{chunk}{defclass Asp78Type}
(defclass |Asp78Type| (|FortranVectorFunctionCategoryType|)
  ((parents :initform '(|FortranVectorFunctionCategory|))
   (name :initform "Asp78")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP78)
   (comment :initform (list
     "Asp78 produces Fortran for Type 78 ASPs, needed for NAG routine"
     "d02gbf, for example:"
     " "
     "     SUBROUTINE FCNG(X,G)"
     "     DOUBLE PRECISION G(*),X"
     "     G(1)=0.0D0"
     "     G(2)=0.0D0"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp78|
  (progn
    (push '|Asp78| *Domains*)
    (make-instance '|Asp78Type|)))

\end{chunk}

\subsection{Asp8}
\index[dom]{Asp8!Domain}
\index[dom]{Domain!Asp8}
\index[dom]{ASP8}
\begin{chunk}{defclass Asp8Type}
(defclass |Asp8Type| (|FortranVectorCategoryType|)
  ((parents :initform '(|FortranVectorCategory|))
   (name :initform "Asp8")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP8)
   (comment :initform (list
     "Asp8 produces Fortran for Type 8 ASPs, needed for NAG routine"
     "d02bbf.  This ASP prints intermediate values of the computed solution of"
     "an ODE and might look like:"
     " "
     "     SUBROUTINE OUTPUT(XSOL,Y,COUNT,M,N,RESULT,FORWRD)"
     "     DOUBLE PRECISION Y(N),RESULT(M,N),XSOL"
     "     INTEGER M,N,COUNT"
     "     LOGICAL FORWRD"
     "     DOUBLE PRECISION X02ALF,POINTS(8)"
     "     EXTERNAL X02ALF"
     "     INTEGER I"
     "     POINTS(1)=1.0D0"
     "     POINTS(2)=2.0D0"
     "     POINTS(3)=3.0D0"
     "     POINTS(4)=4.0D0"
     "     POINTS(5)=5.0D0"
     "     POINTS(6)=6.0D0"
     "     POINTS(7)=7.0D0"
     "     POINTS(8)=8.0D0"
     "     COUNT=COUNT+1"
     "     DO 25001 I=1,N"
     "        RESULT(COUNT,I)=Y(I)"
     "25001 CONTINUE"
     "     IF(COUNT.EQ.M)THEN"
     "       IF(FORWRD)THEN"
     "         XSOL=X02ALF()"
     "       ELSE"
     "         XSOL=-X02ALF()"
     "       ENDIF"
     "     ELSE"
     "        XSOL=POINTS(COUNT)"
     "     ENDIF"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp8|
  (progn
    (push '|Asp8| *Domains*)
    (make-instance '|Asp8Type|)))

\end{chunk}

\subsection{Asp80}
\index[dom]{Asp80!Domain}
\index[dom]{Domain!Asp80}
\index[dom]{ASP80}
\begin{chunk}{defclass Asp80Type}
(defclass |Asp80Type| (|FortranMatrixFunctionCategoryType|)
  ((parents :initform '(|FortranMatrixFunctionCategory|))
   (name :initform "Asp80")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP80)
   (comment :initform (list
     "Asp80 produces Fortran for Type 80 ASPs, needed for NAG routine"
     "d02kef, for example:"
     " "
     "     SUBROUTINE BDYVAL(XL,XR,ELAM,YL,YR)"
     "     DOUBLE PRECISION ELAM,XL,YL(3),XR,YR(3)"
     "     YL(1)=XL"
     "     YL(2)=2.0D0"
     "     YR(1)=1.0D0"
     "     YR(2)=-1.0D0*DSQRT(XR+(-1.0D0*ELAM))"
     "     RETURN"
     "     END"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp80|
  (progn
    (push '|Asp80| *Domains*)
    (make-instance '|Asp80Type|)))

\end{chunk}

\subsection{Asp9}
\index[dom]{Asp9!Domain}
\index[dom]{Domain!Asp9}
\index[dom]{ASP9}
\begin{chunk}{defclass Asp9Type}
(defclass |Asp9Type| (|FortranFunctionCategoryType|)
  ((parents :initform '(|FortranFunctionCategory|))
   (name :initform "Asp9")
   (marker :initform 'domain)
   (abbreviation :initform 'ASP9)
   (comment :initform (list
     "Asp9 produces Fortran for Type 9 ASPs, needed for NAG routines"
     "d02bhf, d02cjf, d02ejf."
     "These ASPs represent a function of a scalar X and a vector Y, for example:"
     " "
     "     DOUBLE PRECISION FUNCTION G(X,Y)"
     "     DOUBLE PRECISION X,Y(*)"
     "     G=X+Y(1)"
     "     RETURN"
     "     END"
     " "
     "If the user provides a constant value for G, then extra information is added"
     "via COMMON blocks used by certain routines.  This specifies that the value"
     "returned by G in this case is to be ignored."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Asp9|
  (progn
    (push '|Asp9| *Domains*)
    (make-instance '|Asp9Type|)))

\end{chunk}

\subsection{AssociatedJordanAlgebra}
\index[dom]{AssociatedJordanAlgebra!Domain}
\index[dom]{Domain!AssociatedJordanAlgebra}
\index[dom]{JORDAN}
\begin{chunk}{defclass AssociatedJordanAlgebraType}
(defclass |AssociatedJordanAlgebraType| (|FramedNonAssociativeAlgebraType|)
  ((parents :initform '(|FramedNonAssociativeAlgebra|))
   (name :initform "AssociatedJordanAlgebra")
   (marker :initform 'domain)
   (abbreviation :initform 'JORDAN)
   (comment :initform (list
     "AssociatedJordanAlgebra takes an algebra A and uses *$A"
     "to define the new multiplications a*b := (a *$A b + b *$A a)/2"
     "(anticommutator)."
     "The usual notation {a,b}_+ cannot be used due to"
     "restrictions in the current language."
     "This domain only gives a Jordan algebra if the"
     "Jordan-identity (a*b)*c + (b*c)*a + (c*a)*b = 0 holds"
     "for all a,b,c in A."
     "This relation can be checked by"
     "jordanAdmissible?()$A."
     " "
     "If the underlying algebra is of type"
     "FramedNonAssociativeAlgebra(R) (a non"
     "associative algebra over R which is a free R-module of finite"
     "rank, together with a fixed R-module basis), then the same"
     "is true for the associated Jordan algebra."
     "Moreover, if the underlying algebra is of type"
     "FiniteRankNonAssociativeAlgebra(R) (a non"
     "associative algebra over R which is a free R-module of finite"
     "rank), then the same true for the associated Jordan algebra."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AssociatedJordanAlgebra|
  (progn
    (push '|AssociatedJordanAlgebra| *Domains*)
    (make-instance '|AssociatedJordanAlgebraType|)))

\end{chunk}

\subsection{AssociatedLieAlgebra}
\index[dom]{AssociatedLieAlgebra!Domain}
\index[dom]{Domain!AssociatedLieAlgebra}
\index[dom]{LIE}
\begin{chunk}{defclass AssociatedLieAlgebraType}
(defclass |AssociatedLieAlgebraType| (|FramedNonAssociativeAlgebraType|)
  ((parents :initform '(|FramedNonAssociativeAlgebra|))
   (name :initform "AssociatedLieAlgebra")
   (marker :initform 'domain)
   (abbreviation :initform 'LIE)
   (comment :initform (list
     "AssociatedLieAlgebra takes an algebra A"
     "and uses *$A to define the"
     "Lie bracket a*b := (a *$A b - b *$A a) (commutator). Note that"
     "the notation [a,b] cannot be used due to"
     "restrictions of the current compiler."
     "This domain only gives a Lie algebra if the"
     "Jacobi-identity (a*b)*c + (b*c)*a + (c*a)*b = 0 holds"
     "for all a,b,c in A."
     "This relation can be checked by"
     "lieAdmissible?()$A."
     " "
     "If the underlying algebra is of type"
     "FramedNonAssociativeAlgebra(R) (a non"
     "associative algebra over R which is a free R-module of finite"
     "rank, together with a fixed R-module basis), then the same"
     "is true for the associated Lie algebra."
     "Also, if the underlying algebra is of type"
     "FiniteRankNonAssociativeAlgebra(R) (a non"
     "associative algebra over R which is a free R-module of finite"
     "rank), then the same is true for the associated Lie algebra."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AssociatedLieAlgebra|
  (progn
    (push '|AssociatedLieAlgebra| *Domains*)
    (make-instance '|AssociatedLieAlgebraType|)))

\end{chunk}

\subsection{AssociationList}
\index[dom]{AssociationList!Domain}
\index[dom]{Domain!AssociationList}
\index[dom]{ALIST}
\begin{chunk}{defclass AssociationListType}
(defclass |AssociationListType| (|AssociationListAggregateType|)
  ((parents :initform '(|AssociationListAggregate|))
   (name :initform "AssociationList")
   (marker :initform 'domain)
   (abbreviation :initform 'ALIST)
   (comment :initform (list
     "AssociationList implements association lists. These"
     "may be viewed as lists of pairs where the first part is a key"
     "and the second is the stored value. For example, the key might"
     "be a string with a persons employee identification number and"
     "the value might be a record with personnel data."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AssociationList|
  (progn
    (push '|AssociationList| *Domains*)
    (make-instance '|AssociationListType|)))

\end{chunk}

\subsection{AttributeButtons}
\index[dom]{AttributeButtons!Domain}
\index[dom]{Domain!AttributeButtons}
\index[dom]{ATTRBUT}
\begin{chunk}{defclass AttributeButtonsType}
(defclass |AttributeButtonsType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "AttributeButtons")
   (marker :initform 'domain)
   (abbreviation :initform 'ATTRBUT)
   (comment :initform (list
     "AttributeButtons implements a database and associated"
     "adjustment mechanisms for a set of attributes."
     " "
     "For ODEs these attributes are 'stiffness', 'stability' (how much"
     "affect the cosine or sine component of the solution has on the stability of"
     "the result), 'accuracy' and 'expense' (how expensive is the evaluation"
     "of the ODE).  All these have bearing on the cost of calculating the"
     "solution given that reducing the step-length to achieve greater accuracy"
     "requires considerable number of evaluations and calculations."
     " "
     "The effect of each of these attributes can be altered by increasing or"
     "decreasing the button value."
     " "
     "For Integration there is a button for increasing and decreasing the preset"
     "number of function evaluations for each method.  This is automatically used"
     "by ANNA when a method fails due to insufficient workspace or where the"
     "limit of function evaluations has been reached before the required"
     "accuracy is achieved."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AttributeButtons|
  (progn
    (push '|AttributeButtons| *Domains*)
    (make-instance '|AttributeButtonsType|)))

\end{chunk}

\subsection{Automorphism}
\index[dom]{Automorphism!Domain}
\index[dom]{Domain!Automorphism}
\index[dom]{AUTOMOR}
\begin{chunk}{defclass AutomorphismType}
(defclass |AutomorphismType| (|EltableType| |GroupType|)
  ((parents :initform '(|Eltable| |Group|))
   (name :initform "Automorphism")
   (marker :initform 'domain)
   (abbreviation :initform 'AUTOMOR)
   (comment :initform (list
     "Automorphism R is the multiplicative group of automorphisms of R."
     "In fact, non-invertible endomorphism are allowed as partial functions."
     "This domain is noncanonical in that f*f^{-1} will be the identity"
     "function but won't be equal to 1."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Automorphism|
  (progn
    (push '|Automorphism| *Domains*)
    (make-instance '|AutomorphismType|)))

\end{chunk}

\section{B}

\subsection{BalancedBinaryTree}
\index[dom]{BalancedBinaryTree!Domain}
\index[dom]{Domain!BalancedBinaryTree}
\index[dom]{BBTREE}
\begin{chunk}{defclass BalancedBinaryTreeType}
(defclass |BalancedBinaryTreeType| (|BinaryTreeCategoryType|)
  ((parents :initform '(|BinaryTreeCategory|))
   (name :initform "BalancedBinaryTree")
   (marker :initform 'domain)
   (abbreviation :initform 'BBTREE)
   (comment :initform (list
     "BalancedBinaryTree(S) is the domain of balanced"
     "binary trees (bbtree). A balanced binary tree of 2**k leaves,"
     "for some k > 0, is symmetric, that is, the left and right"
     "subtree of each interior node have identical shape."
     "In general, the left and right subtree of a given node can differ"
     "by at most leaf node."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BalancedBinaryTree|
  (progn
    (push '|BalancedBinaryTree| *Domains*)
    (make-instance '|BalancedBinaryTreeType|)))

\end{chunk}

\subsection{BalancedPAdicInteger}
\index[dom]{BalancedPAdicInteger!Domain}
\index[dom]{Domain!BalancedPAdicInteger}
\index[dom]{BPADIC}
\begin{chunk}{defclass BalancedPAdicIntegerType}
(defclass |BalancedPAdicIntegerType| (|PAdicIntegerCategoryType|)
  ((parents :initform '(|PAdicIntegerCategory|))
   (name :initform "BalancedPAdicInteger")
   (marker :initform 'domain)
   (abbreviation :initform 'BPADIC)
   (comment :initform (list
     "Stream-based implementation of Zp: p-adic numbers are represented as"
     "sum(i = 0.., a[i] * p^i), where the a[i] lie in -(p - 1)/2,...,(p - 1)/2."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BalancedPAdicInteger|
  (progn
    (push '|BalancedPAdicInteger| *Domains*)
    (make-instance '|BalancedPAdicIntegerType|)))

\end{chunk}

\subsection{BalancedPAdicRational}
\index[dom]{BalancedPAdicRational!Domain}
\index[dom]{Domain!BalancedPAdicRational}
\index[dom]{BPADICRT}
\begin{chunk}{defclass BalancedPAdicRationalType}
(defclass |BalancedPAdicRationalType| (|QuotientFieldCategoryType|)
  ((parents :initform '(|QuotientFieldCategory|))
   (name :initform "BalancedPAdicRational")
   (marker :initform 'domain)
   (abbreviation :initform 'BPADICRT)
   (comment :initform (list
     "Stream-based implementation of Qp: numbers are represented as"
     "sum(i = k.., a[i] * p^i), where the a[i] lie in -(p - 1)/2,...,(p - 1)/2."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BalancedPAdicRational|
  (progn
    (push '|BalancedPAdicRational| *Domains*)
    (make-instance '|BalancedPAdicRationalType|)))

\end{chunk}

\subsection{BasicFunctions}
\index[dom]{BasicFunctions!Domain}
\index[dom]{Domain!BasicFunctions}
\index[dom]{BFUNCT}
\begin{chunk}{defclass BasicFunctionsType}
(defclass |BasicFunctionsType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "BasicFunctions")
   (marker :initform 'domain)
   (abbreviation :initform 'BFUNCT)
   (comment :initform (list
     "A Domain which implements a table containing details of"
     "points at which particular functions have evaluation problems."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BasicFunctions|
  (progn
    (push '|BasicFunctions| *Domains*)
    (make-instance '|BasicFunctionsType|)))

\end{chunk}

\subsection{BasicOperator}
\index[dom]{BasicOperator!Domain}
\index[dom]{Domain!BasicOperator}
\index[dom]{BOP}
\begin{chunk}{defclass BasicOperatorType}
(defclass |BasicOperatorType| (|OrderedSetType|)
  ((parents :initform '(|OrderedSet|))
   (name :initform "BasicOperator")
   (marker :initform 'domain)
   (abbreviation :initform 'BOP)
   (comment :initform (list
     "A basic operator is an object that can be applied to a list of"
     "arguments from a set, the result being a kernel over that set."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BasicOperator|
  (progn
    (push '|BasicOperator| *Domains*)
    (make-instance '|BasicOperatorType|)))

\end{chunk}

\subsection{BasicStochasticDifferential}
\index[dom]{BasicStochasticDifferential!Domain}
\index[dom]{Domain!BasicStochasticDifferential}
\index[dom]{BSD}
\begin{chunk}{defclass BasicStochasticDifferentialType}
(defclass |BasicStochasticDifferentialType| (|ConvertibleToType| |OrderedSetType|)
  ((parents :initform '(|ConvertibleTo| |OrderedSet|))
   (name :initform "BasicStochasticDifferential")
   (marker :initform 'domain)
   (abbreviation :initform 'BSD)
   (comment :initform (list
     "Based on Symbol: a domain of symbols representing basic stochastic"
     "differentials, used in StochasticDifferential(R) in the underlying"
     "sparse multivariate polynomial representation."
     " "
     "We create new BSD only by coercion from Symbol using a special"
     "function introduce! first of all to add to a private set SDset."
     "We allow a separate function convertIfCan which will check whether the"
     "argument has previously been declared as a BSD."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BasicStochasticDifferential|
  (progn
    (push '|BasicStochasticDifferential| *Domains*)
    (make-instance '|BasicStochasticDifferentialType|)))

\end{chunk}

\subsection{BinaryExpansion}
\index[dom]{BinaryExpansion!Domain}
\index[dom]{Domain!BinaryExpansion}
\index[dom]{BINARY}
\begin{chunk}{defclass BinaryExpansionType}
(defclass |BinaryExpansionType| (|QuotientFieldCategoryType|)
  ((parents :initform '(|QuotientFieldCategory|))
   (name :initform "BinaryExpansion")
   (marker :initform 'domain)
   (abbreviation :initform 'BINARY)
   (comment :initform (list
     "This domain allows rational numbers to be presented as repeating"
     "binary expansions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BinaryExpansion|
  (progn
    (push '|BinaryExpansion| *Domains*)
    (make-instance '|BinaryExpansionType|)))

\end{chunk}

\subsection{BinaryFile}
\index[dom]{BinaryFile!Domain}
\index[dom]{Domain!BinaryFile}
\index[dom]{BINFILE}
\begin{chunk}{defclass BinaryFileType}
(defclass |BinaryFileType| (|FileCategoryType|)
  ((parents :initform '(|FileCategory|))
   (name :initform "BinaryFile")
   (marker :initform 'domain)
   (abbreviation :initform 'BINFILE)
   (comment :initform (list
     "This domain provides an implementation of binary files. Data is"
     "accessed one byte at a time as a small integer."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BinaryFile|
  (progn
    (push '|BinaryFile| *Domains*)
    (make-instance '|BinaryFileType|)))

\end{chunk}

\subsection{BinarySearchTree}
\index[dom]{BinarySearchTree!Domain}
\index[dom]{Domain!BinarySearchTree}
\index[dom]{BSTREE}
\begin{chunk}{defclass BinarySearchTreeType}
(defclass |BinarySearchTreeType| (|BinaryTreeCategoryType|)
  ((parents :initform '(|BinaryTreeCategory|))
   (name :initform "BinarySearchTree")
   (marker :initform 'domain)
   (abbreviation :initform 'BSTREE)
   (comment :initform (list
     "BinarySearchTree(S) is the domain of"
     "a binary trees where elements are ordered across the tree."
     "A binary search tree is either empty or has"
     "a value which is an S, and a"
     "right and left which are both BinaryTree(S)"
     "Elements are ordered across the tree."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BinarySearchTree|
  (progn
    (push '|BinarySearchTree| *Domains*)
    (make-instance '|BinarySearchTreeType|)))

\end{chunk}

\subsection{BinaryTournament}
\index[dom]{BinaryTournament!Domain}
\index[dom]{Domain!BinaryTournament}
\index[dom]{BTOURN}
\begin{chunk}{defclass BinaryTournamentType}
(defclass |BinaryTournamentType| (|BinaryTreeCategoryType|)
  ((parents :initform '(|BinaryTreeCategory|))
   (name :initform "BinaryTournament")
   (marker :initform 'domain)
   (abbreviation :initform 'BTOURN)
   (comment :initform (list
     "BinaryTournament creates a binary tournament with the"
     "elements of ls as values at the nodes."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BinaryTournament|
  (progn
    (push '|BinaryTournament| *Domains*)
    (make-instance '|BinaryTournamentType|)))

\end{chunk}

\subsection{BinaryTree}
\index[dom]{BinaryTree!Domain}
\index[dom]{Domain!BinaryTree}
\index[dom]{BTREE}
\begin{chunk}{defclass BinaryTreeType}
(defclass |BinaryTreeType| (|BinaryTreeCategoryType|)
  ((parents :initform '(|BinaryTreeCategory|))
   (name :initform "BinaryTree")
   (marker :initform 'domain)
   (abbreviation :initform 'BTREE)
   (comment :initform (list
     "BinaryTree(S) is the domain of all"
     "binary trees. A binary tree over S is either empty or has"
     "a value which is an S and a right"
     "and left which are both binary trees."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BinaryTree|
  (progn
    (push '|BinaryTree| *Domains*)
    (make-instance '|BinaryTreeType|)))

\end{chunk}

\subsection{Bits}
\index[dom]{Bits!Domain}
\index[dom]{Domain!Bits}
\index[dom]{BITS}
\begin{chunk}{defclass BitsType}
(defclass |BitsType| (|BitAggregateType|)
  ((parents :initform '(|BitAggregate|))
   (name :initform "Bits")
   (marker :initform 'domain)
   (abbreviation :initform 'BITS)
   (comment :initform (list
     "Bits provides logical functions for Indexed Bits."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Bits|
  (progn
    (push '|Bits| *Domains*)
    (make-instance '|BitsType|)))

\end{chunk}

\subsection{BlowUpWithHamburgerNoether}
\index[dom]{BlowUpWithHamburgerNoether!Domain}
\index[dom]{Domain!BlowUpWithHamburgerNoether}
\index[dom]{BLHN}
\begin{chunk}{defclass BlowUpWithHamburgerNoetherType}
(defclass |BlowUpWithHamburgerNoetherType| (|BlowUpMethodCategoryType|)
  ((parents :initform '(|BlowUpMethodCategory|))
   (name :initform "BlowUpWithHamburgerNoether")
   (marker :initform 'domain)
   (abbreviation :initform 'BLHN)
   (comment :initform (list
     "This domain is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BlowUpWithHamburgerNoether|
  (progn
    (push '|BlowUpWithHamburgerNoether| *Domains*)
    (make-instance '|BlowUpWithHamburgerNoetherType|)))

\end{chunk}

\subsection{BlowUpWithQuadTrans}
\index[dom]{BlowUpWithQuadTrans!Domain}
\index[dom]{Domain!BlowUpWithQuadTrans}
\index[dom]{BLQT}
\begin{chunk}{defclass BlowUpWithQuadTransType}
(defclass |BlowUpWithQuadTransType| (|BlowUpMethodCategoryType|)
  ((parents :initform '(|BlowUpMethodCategory|))
   (name :initform "BlowUpWithQuadTrans")
   (marker :initform 'domain)
   (abbreviation :initform 'BLQT)
   (comment :initform (list
     "This domain is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BlowUpWithQuadTrans|
  (progn
    (push '|BlowUpWithQuadTrans| *Domains*)
    (make-instance '|BlowUpWithQuadTransType|)))

\end{chunk}

\subsection{Boolean}
\index[dom]{Boolean!Domain}
\index[dom]{Domain!Boolean}
\index[dom]{BOOLEAN}
\begin{chunk}{defclass BooleanType}
(defclass |BooleanType| (|ConvertibleToType| |FiniteType| |LogicType| |OrderedSetType|)
  ((parents :initform '(|ConvertibleTo| |Finite| |Logic| |OrderedSet|))
   (name :initform "Boolean")
   (marker :initform 'domain)
   (abbreviation :initform 'BOOLEAN)
   (comment :initform (list
     "Boolean is the elementary logic with 2 values:"
     "true and false"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Boolean|
  (progn
    (push '|Boolean| *Domains*)
    (make-instance '|BooleanType|)))

\end{chunk}

\section{C}

\subsection{CardinalNumber}
\index[dom]{CardinalNumber!Domain}
\index[dom]{Domain!CardinalNumber}
\index[dom]{CARD}
\begin{chunk}{defclass CardinalNumberType}
(defclass |CardinalNumberType| (|AbelianMonoidType| |MonoidType| |OrderedSetType| |RetractableToType|)
  ((parents :initform '(|AbelianMonoid| |Monoid| |OrderedSet| |RetractableTo|))
   (name :initform "CardinalNumber")
   (marker :initform 'domain)
   (abbreviation :initform 'CARD)
   (comment :initform (list
     "Members of the domain CardinalNumber are values indicating the"
     "cardinality of sets, both finite and infinite.  Arithmetic operations"
     "are defined on cardinal numbers as follows."
     " "
     "If x = #X and y = #Y then"
     "   x+y  = #(X+Y) disjoint union"
     "   x-y  = #(X-Y) relative complement"
     "   x*y  = #(X*Y) cartesian product"
     "   x**y = #(X**Y) X**Y = g \| g:Y->X"
     " "
     "The non-negative integers have a natural construction as cardinals"
     "  0 = #{}, 1 = {0},"
     " 2 = {0, 1}}, ..., n = {i\| 0 <= i < n}."
     " "
     "That 0 acts as a zero for the multiplication of cardinals is"
     "equivalent to the axiom of choice."
     " "
     "The generalized continuum hypothesis asserts"
     "2**Aleph i = Aleph(i+1)"
     "and is independent of the axioms of set theory [Goedel 1940]"
     " "
     "Three commonly encountered cardinal numbers are"
     "  a = #Z countable infinity"
     "  c = #R the continuum"
     "  f = # g \| g:[0,1]->R"
     " "
     "In this domain, these values are obtained using"
     "  a := Aleph 0, c := 2**a, f := 2**c."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CardinalNumber|
  (progn
    (push '|CardinalNumber| *Domains*)
    (make-instance '|CardinalNumberType|)))

\end{chunk}

\subsection{CartesianTensor}
\index[dom]{CartesianTensor!Domain}
\index[dom]{Domain!CartesianTensor}
\index[dom]{CARTEN}
\begin{chunk}{defclass CartesianTensorType}
(defclass |CartesianTensorType| (|GradedAlgebraType|)
  ((parents :initform '(|GradedAlgebra|))
   (name :initform "CartesianTensor")
   (marker :initform 'domain)
   (abbreviation :initform 'CARTEN)
   (comment :initform (list
     "CartesianTensor(minix,dim,R) provides Cartesian tensors with"
     "components belonging to a commutative ring R.  These tensors"
     "can have any number of indices.  Each index takes values from"
     "minix to minix + dim - 1."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CartesianTensor|
  (progn
    (push '|CartesianTensor| *Domains*)
    (make-instance '|CartesianTensorType|)))

\end{chunk}

\subsection{Cell}
\index[dom]{Cell!Domain}
\index[dom]{Domain!Cell}
\index[dom]{CELL}
\begin{chunk}{defclass CellType}
(defclass |CellType| (|CoercibleToType|)
  ((parents :initform '(|CoercibleTo|))
   (name :initform "Cell")
   (marker :initform 'domain)
   (abbreviation :initform 'CELL)
   (comment :initform nil)
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Cell|
  (progn
    (push '|Cell| *Domains*)
    (make-instance '|CellType|)))

\end{chunk}

\subsection{Character}
\index[dom]{Character!Domain}
\index[dom]{Domain!Character}
\index[dom]{CHAR}
\begin{chunk}{defclass CharacterType}
(defclass |CharacterType| (|OrderedFiniteType|)
  ((parents :initform '(|OrderedFinite|))
   (name :initform "Character")
   (marker :initform 'domain)
   (abbreviation :initform 'CHAR)))

(defvar |Character|
  (progn
    (push '|Character| *Domains*)
    (make-instance '|CharacterType|)))

\end{chunk}

\subsection{CharacterClass}
\index[dom]{CharacterClass!Domain}
\index[dom]{Domain!CharacterClass}
\index[dom]{CCLASS}
\begin{chunk}{defclass CharacterClassType}
(defclass |CharacterClassType| (|FiniteSetAggregateType|)
  ((parents :initform '(|FiniteSetAggregate|))
   (name :initform "CharacterClass")
   (marker :initform 'domain)
   (abbreviation :initform 'CCLASS)
   (comment :initform (list
     "This domain allows classes of characters to be defined and manipulated"
     "efficiently."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CharacterClass|
  (progn
    (push '|CharacterClass| *Domains*)
    (make-instance '|CharacterClassType|)))

\end{chunk}

\subsection{CliffordAlgebra}
\index[dom]{CliffordAlgebra!Domain}
\index[dom]{Domain!CliffordAlgebra}
\index[dom]{CLIF}
\begin{chunk}{defclass CliffordAlgebraType}
(defclass |CliffordAlgebraType| (|VectorSpaceType| |AlgebraType|)
  ((parents :initform '(|VectorSpace| |Algebra|))
   (name :initform "CliffordAlgebra")
   (marker :initform 'domain)
   (abbreviation :initform 'CLIF)
   (comment :initform (list
     "CliffordAlgebra(n, K, Q) defines a vector space of dimension 2**n"
     "over K, given a quadratic form Q on K**n."
     " "
     "If e[i], 1<=i<=n is a basis for K**n then"
     "   1, e[i] (1<=i<=n), e[i1]*e[i2]"
     "   (1<=i1<i2<=n},...,e[1]*e[2]*..*e[n]"
     "is a basis for the Clifford Algebra."
     " "
     "The algebra is defined by the relations"
     "   e[i]*e[j] = -e[j]*e[i]}  (i \~~= j),"
     "   e[i]*e[i] = Q(e[i])"
     " "
     "Examples of Clifford Algebras are: gaussians, quaternions, exterior"
     "algebras and spin algebras."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CliffordAlgebra|
  (progn
    (push '|CliffordAlgebra| *Domains*)
    (make-instance '|CliffordAlgebraType|)))

\end{chunk}

\subsection{Color}
\index[dom]{Color!Domain}
\index[dom]{Domain!Color}
\index[dom]{COLOR}
\begin{chunk}{defclass ColorType}
(defclass |ColorType| (|AbelianSemiGroupType|)
  ((parents :initform '(|AbelianSemiGroup|))
   (name :initform "Color")
   (marker :initform 'domain)
   (abbreviation :initform 'COLOR)
   (comment :initform (list
     "Color() specifies a domain of 27 colors provided in the"
     "Axiom system (the colors mix additively)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Color|
  (progn
    (push '|Color| *Domains*)
    (make-instance '|ColorType|)))

\end{chunk}

\subsection{Commutator}
\index[dom]{Commutator!Domain}
\index[dom]{Domain!Commutator}
\index[dom]{COMM}
\begin{chunk}{defclass CommutatorType}
(defclass |CommutatorType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "Commutator")
   (marker :initform 'domain)
   (abbreviation :initform 'COMM)
   (comment :initform (list
     "A type for basic commutators"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Commutator|
  (progn
    (push '|Commutator| *Domains*)
    (make-instance '|CommutatorType|)))

\end{chunk}

\subsection{Complex}
\index[dom]{Complex!Domain}
\index[dom]{Domain!Complex}
\index[dom]{COMPLEX}
\begin{chunk}{defclass ComplexType}
(defclass |ComplexType| (|ComplexCategoryType| |OpenMathType|)
  ((parents :initform '(|ComplexCategory| |OpenMath|))
   (name :initform "Complex")
   (marker :initform 'domain)
   (abbreviation :initform 'COMPLEX)
   (comment :initform (list
     "Complex(R) creates the domain of elements of the form"
     "a + b * i where a and b come from the ring R,"
     "and i is a new element such that i**2 = -1."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Complex|
  (progn
    (push '|Complex| *Domains*)
    (make-instance '|ComplexType|)))

\end{chunk}

\subsection{ComplexDoubleFloatMatrix}
\index[dom]{ComplexDoubleFloatMatrix!Domain}
\index[dom]{Domain!ComplexDoubleFloatMatrix}
\index[dom]{CDFMAT}
\begin{chunk}{defclass ComplexDoubleFloatMatrixType}
(defclass |ComplexDoubleFloatMatrixType| (|MatrixCategoryType|)
  ((parents :initform '(|MatrixCategory|))
   (name :initform "ComplexDoubleFloatMatrix")
   (marker :initform 'domain)
   (abbreviation :initform 'CDFMAT)
   (comment :initform (list
     "This is a low-level domain which implements matrices"
     "(two dimensional arrays) of complex double precision floating point"
     "numbers.  Indexing is 0 based, there is no bound checking (unless"
     "provided by lower level)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ComplexDoubleFloatMatrix|
  (progn
    (push '|ComplexDoubleFloatMatrix| *Domains*)
    (make-instance '|ComplexDoubleFloatMatrixType|)))

\end{chunk}

\subsection{ComplexDoubleFloatVector}
\index[dom]{ComplexDoubleFloatVector!Domain}
\index[dom]{Domain!ComplexDoubleFloatVector}
\index[dom]{CDFVEC}
\begin{chunk}{defclass ComplexDoubleFloatVectorType}
(defclass |ComplexDoubleFloatVectorType| (|VectorCategoryType|)
  ((parents :initform '(|VectorCategory|))
   (name :initform "ComplexDoubleFloatVector")
   (marker :initform 'domain)
   (abbreviation :initform 'CDFVEC)
   (comment :initform (list
     "This is a low-level domain which implements vectors"
     "(one dimensional arrays) of complex double precision floating point"
     "numbers.  Indexing is 0 based, there is no bound checking (unless"
     "provided by lower level)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ComplexDoubleFloatVector|
  (progn
    (push '|ComplexDoubleFloatVector| *Domains*)
    (make-instance '|ComplexDoubleFloatVectorType|)))

\end{chunk}

\subsection{ContinuedFraction}
\index[dom]{ContinuedFraction!Domain}
\index[dom]{Domain!ContinuedFraction}
\index[dom]{CONTFRAC}
\begin{chunk}{defclass ContinuedFractionType}
(defclass |ContinuedFractionType| (|FieldType|)
  ((parents :initform '(|Field|))
   (name :initform "ContinuedFraction")
   (marker :initform 'domain)
   (abbreviation :initform 'CONTFRAC)
   (comment :initform (list
     "ContinuedFraction implements general"
     "continued fractions.  This version is not restricted to simple,"
     "finite fractions and uses the Stream as a"
     "representation.  The arithmetic functions assume that the"
     "approximants alternate below/above the convergence point."
     "This is enforced by ensuring the partial numerators and partial"
     "denominators are greater than 0 in the Euclidean domain view of R"
     "(sizeLess?(0, x))."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ContinuedFraction|
  (progn
    (push '|ContinuedFraction| *Domains*)
    (make-instance '|ContinuedFractionType|)))

\end{chunk}

\section{D}

\subsection{Database}
\index[dom]{Database!Domain}
\index[dom]{Domain!Database}
\index[dom]{DBASE}
\begin{chunk}{defclass DatabaseType}
(defclass |DatabaseType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "Database")
   (marker :initform 'domain)
   (abbreviation :initform 'DBASE)
   (comment :initform (list
     "This domain implements a simple view of a database whose fields are"
     "indexed by symbols"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Database|
  (progn
    (push '|Database| *Domains*)
    (make-instance '|DatabaseType|)))

\end{chunk}

\subsection{DataList}
\index[dom]{DataList!Domain}
\index[dom]{Domain!DataList}
\index[dom]{DLIST}
\begin{chunk}{defclass DataListType}
(defclass |DataListType| (|ListAggregateType|)
  ((parents :initform '(|ListAggregate|))
   (name :initform "DataList")
   (marker :initform 'domain)
   (abbreviation :initform 'DLIST)
   (comment :initform (list
     "This domain provides some nice functions on lists"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DataList|
  (progn
    (push '|DataList| *Domains*)
    (make-instance '|DataListType|)))

\end{chunk}

\subsection{DecimalExpansion}
\index[dom]{DecimalExpansion!Domain}
\index[dom]{Domain!DecimalExpansion}
\index[dom]{DECIMAL}
\begin{chunk}{defclass DecimalExpansionType}
(defclass |DecimalExpansionType| (|QuotientFieldCategoryType|)
  ((parents :initform '(|QuotientFieldCategory|))
   (name :initform "DecimalExpansion")
   (marker :initform 'domain)
   (abbreviation :initform 'DECIMAL)
   (comment :initform (list
     "This domain allows rational numbers to be presented as repeating"
     "decimal expansions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DecimalExpansion|
  (progn
    (push '|DecimalExpansion| *Domains*)
    (make-instance '|DecimalExpansionType|)))

\end{chunk}

\subsection{DenavitHartenbergMatrix}
\index[dom]{DenavitHartenbergMatrix!Domain}
\index[dom]{Domain!DenavitHartenbergMatrix}
\index[dom]{DHMATRIX}
\begin{chunk}{defclass DenavitHartenbergMatrixType}
(defclass |DenavitHartenbergMatrixType| (|MatrixCategoryType|)
  ((parents :initform '(|MatrixCategory|))
   (name :initform "DenavitHartenbergMatrix")
   (marker :initform 'domain)
   (abbreviation :initform 'DHMATRIX)
   (comment :initform (list
     "4x4 Matrices for coordinate transformations"
     "This package contains functions to create 4x4 matrices"
     "useful for rotating and transforming coordinate systems."
     "These matrices are useful for graphics and robotics."
     "(Reference: Robot Manipulators Richard Paul MIT Press 1981)"
     " "
     "A Denavit-Hartenberg Matrix is a 4x4 Matrix of the form:"
     "     nx ox ax px"
     "     ny oy ay py"
     "     nz oz az pz"
     "     0  0  0  1"
     "(n, o, and a are the direction cosines)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DenavitHartenbergMatrix|
  (progn
    (push '|DenavitHartenbergMatrix| *Domains*)
    (make-instance '|DenavitHartenbergMatrixType|)))

\end{chunk}

\subsection{Dequeue}
\index[dom]{Dequeue!Domain}
\index[dom]{Domain!Dequeue}
\index[dom]{DEQUEUE}
\begin{chunk}{defclass DequeueType}
(defclass |DequeueType| (|DequeueAggregateType|)
  ((parents :initform '(|DequeueAggregate|))
   (name :initform "Dequeue")
   (marker :initform 'domain)
   (abbreviation :initform 'DEQUEUE)
   (comment :initform (list
     "Linked list implementation of a Dequeue"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Dequeue|
  (progn
    (push '|Dequeue| *Domains*)
    (make-instance '|DequeueType|)))

\end{chunk}

\subsection{DeRhamComplex}
\index[dom]{DeRhamComplex!Domain}
\index[dom]{Domain!DeRhamComplex}
\index[dom]{DERHAM}
\begin{chunk}{defclass DeRhamComplexType}
(defclass |DeRhamComplexType| (|RetractableToType| |LeftAlgebraType|)
  ((parents :initform '(|RetractableTo| |LeftAlgebra|))
   (name :initform "DeRhamComplex")
   (marker :initform 'domain)
   (abbreviation :initform 'DERHAM)
   (comment :initform (list
     "The deRham complex of Euclidean space, that is, the"
     "class of differential forms of arbitary degree over a coefficient ring."
     "See Flanders, Harley, Differential Forms, With Applications to the Physical"
     "Sciences, New York, Academic Press, 1963."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DeRhamComplex|
  (progn
    (push '|DeRhamComplex| *Domains*)
    (make-instance '|DeRhamComplexType|)))

\end{chunk}

\subsection{DesingTree}
\index[dom]{DesingTree!Domain}
\index[dom]{Domain!DesingTree}
\index[dom]{DSTREE}
\begin{chunk}{defclass DesingTreeType}
(defclass |DesingTreeType| (|DesingTreeCategoryType|)
  ((parents :initform '(|DesingTreeCategory|))
   (name :initform "DesingTree")
   (marker :initform 'domain)
   (abbreviation :initform 'DSTREE)
   (comment :initform (list
     "This category is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DesingTree|
  (progn
    (push '|DesingTree| *Domains*)
    (make-instance '|DesingTreeType|)))

\end{chunk}

\subsection{DifferentialSparseMultivariatePolynomial}
\index[dom]{DifferentialSparseMultivariatePolynomial!Domain}
\index[dom]{Domain!DifferentialSparseMultivariatePolynomial}
\index[dom]{DSMP}
\begin{chunk}{defclass DifferentialSparseMultivariatePolynomialType}
(defclass |DifferentialSparseMultivariatePolynomialType| (|DifferentialPolynomialCategoryType|)
  ((parents :initform '(|DifferentialPolynomialCategory|))
   (name :initform "DifferentialSparseMultivariatePolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'DSMP)
   (comment :initform (list
     "DifferentialSparseMultivariatePolynomial implements"
     "an ordinary differential polynomial ring by combining a"
     "domain belonging to the category DifferentialVariableCategory"
     "with the domain SparseMultivariatePolynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DifferentialSparseMultivariatePolynomial|
  (progn
    (push '|DifferentialSparseMultivariatePolynomial| *Domains*)
    (make-instance '|DifferentialSparseMultivariatePolynomialType|)))

\end{chunk}

\subsection{DirectProduct}
\index[dom]{DirectProduct!Domain}
\index[dom]{Domain!DirectProduct}
\index[dom]{DIRPROD}
\begin{chunk}{defclass DirectProductType}
(defclass |DirectProductType| (|DirectProductCategoryType|)
  ((parents :initform '(|DirectProductCategory|))
   (name :initform "DirectProduct")
   (marker :initform 'domain)
   (abbreviation :initform 'DIRPROD)
   (comment :initform (list
     "This type represents the finite direct or cartesian product of an"
     "underlying component type. This contrasts with simple vectors in that"
     "the members can be viewed as having constant length. Thus many"
     "categorical properties can by lifted from the underlying component type."
     "Component extraction operations are provided but no updating operations."
     "Thus new direct product elements can either be created by converting"
     "vector elements using the directProduct function"
     "or by taking appropriate linear combinations of basis vectors provided"
     "by the unitVector operation."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DirectProduct|
  (progn
    (push '|DirectProduct| *Domains*)
    (make-instance '|DirectProductType|)))

\end{chunk}

\subsection{DirectProductMatrixModule}
\index[dom]{DirectProductMatrixModule!Domain}
\index[dom]{Domain!DirectProductMatrixModule}
\index[dom]{DPMM}
\begin{chunk}{defclass DirectProductMatrixModuleType}
(defclass |DirectProductMatrixModuleType| (|DirectProductCategoryType|)
  ((parents :initform '(|DirectProductCategory|))
   (name :initform "DirectProductMatrixModule")
   (marker :initform 'domain)
   (abbreviation :initform 'DPMM)
   (comment :initform (list
     "This constructor provides a direct product type with a"
     "left matrix-module view."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DirectProductMatrixModule|
  (progn
    (push '|DirectProductMatrixModule| *Domains*)
    (make-instance '|DirectProductMatrixModuleType|)))

\end{chunk}

\subsection{DirectProductModule}
\index[dom]{DirectProductModule!Domain}
\index[dom]{Domain!DirectProductModule}
\index[dom]{DPMO}
\begin{chunk}{defclass DirectProductModuleType}
(defclass |DirectProductModuleType| (|DirectProductCategoryType|)
  ((parents :initform '(|DirectProductCategory|))
   (name :initform "DirectProductModule")
   (marker :initform 'domain)
   (abbreviation :initform 'DPMO)
   (comment :initform (list
     "This constructor provides a direct product of R-modules"
     "with an R-module view."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DirectProductModule|
  (progn
    (push '|DirectProductModule| *Domains*)
    (make-instance '|DirectProductModuleType|)))

\end{chunk}

\subsection{DirichletRing}
\index[dom]{DirichletRing!Domain}
\index[dom]{Domain!DirichletRing}
\index[dom]{DIRRING}
\begin{chunk}{defclass DirichletRingType}
(defclass |DirichletRingType| (|IntegralDomainType| |EltableType|)
  ((parents :initform '(|IntegralDomain| |Eltable|))
   (name :initform "DirichletRing")
   (marker :initform 'domain)
   (abbreviation :initform 'DIRRING)
   (comment :initform (list
     "DirichletRing is the ring of arithmetical functions"
     "with Dirichlet convolution as multiplication"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DirichletRing|
  (progn
    (push '|DirichletRing| *Domains*)
    (make-instance '|DirichletRingType|)))

\end{chunk}

\subsection{DistributedMultivariatePolynomial}
\index[dom]{DistributedMultivariatePolynomial!Domain}
\index[dom]{Domain!DistributedMultivariatePolynomial}
\index[dom]{DMP}
\begin{chunk}{defclass DistributedMultivariatePolynomialType}
(defclass |DistributedMultivariatePolynomialType| (|PolynomialCategoryType|)
  ((parents :initform '(|PolynomialCategory|))
   (name :initform "DistributedMultivariatePolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'DMP)
   (comment :initform (list
     "This type supports distributed multivariate polynomials"
     "whose variables are from a user specified list of symbols."
     "The coefficient ring may be non commutative,"
     "but the variables are assumed to commute."
     "The term ordering is lexicographic specified by the variable"
     "list parameter with the most significant variable first in the list."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DistributedMultivariatePolynomial|
  (progn
    (push '|DistributedMultivariatePolynomial| *Domains*)
    (make-instance '|DistributedMultivariatePolynomialType|)))

\end{chunk}

\subsection{Divisor}
\index[dom]{Divisor!Domain}
\index[dom]{Domain!Divisor}
\index[dom]{DIV}
\begin{chunk}{defclass DivisorType}
(defclass |DivisorType| (|DivisorCategoryType|)
  ((parents :initform '(|DivisorCategory|))
   (name :initform "Divisor")
   (marker :initform 'domain)
   (abbreviation :initform 'DIV)
   (comment :initform (list
     "The following is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Divisor|
  (progn
    (push '|Divisor| *Domains*)
    (make-instance '|DivisorType|)))

\end{chunk}

\subsection{DoubleFloat}
\index[dom]{DoubleFloat!Domain}
\index[dom]{Domain!DoubleFloat}
\index[dom]{DFLOAT}
\begin{chunk}{defclass DoubleFloatType}
(defclass |DoubleFloatType| (|TranscendentalFunctionCategoryType|
                             |SpecialFunctionCategoryType|
                             |OpenMathType|
                             |FloatingPointSystemType|
                             |DifferentialRingType|)
  ((parents :initform '(|TranscendentalFunctionCategory|
                        |SpecialFunctionCategory|
                        |OpenMath|
                        |FloatingPointSystem|
                        |DifferentialRing|))
   (name :initform "DoubleFloat")
   (marker :initform 'domain)
   (abbreviation :initform 'DFLOAT)
   (comment :initform (list
     "DoubleFloat is intended to make accessible"
     "hardware floating point arithmetic in Axiom, either native double"
     "precision, or IEEE. On most machines, there will be hardware support for"
     "the arithmetic operations: +, *, / and possibly also the"
     "sqrt operation."
     "The operations exp, log, sin, cos, atan are normally coded in"
     "software based on minimax polynomial/rational approximations."
     " "
     "Some general comments about the accuracy of the operations:"
     "the operations +, *, / and sqrt are expected to be fully accurate."
     "The operations exp, log, sin, cos and atan are not expected to be"
     "fully accurate.  In particular, sin and cos"
     "will lose all precision for large arguments."
     " "
     "The Float domain provides an alternative to the DoubleFloat domain."
     "It provides an arbitrary precision model of floating point arithmetic."
     "This means that accuracy problems like those above are eliminated"
     "by increasing the working precision where necessary. Float"
     "provides some special functions such as erf, the error function"
     "in addition to the elementary functions.  The disadvantage of Float is that"
     "it is much more expensive than small floats when the latter can be used."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DoubleFloat|
  (progn
    (push '|DoubleFloat| *Domains*)
    (make-instance '|DoubleFloatType|)))

\end{chunk}

\subsection{DoubleFloatMatrix}
\index[dom]{DoubleFloatMatrix!Domain}
\index[dom]{Domain!DoubleFloatMatrix}
\index[dom]{DFMAT}
\begin{chunk}{defclass DoubleFloatMatrixType}
(defclass |DoubleFloatMatrixType| (|MatrixCategoryType|)
  ((parents :initform '(|MatrixCategory|))
   (name :initform "DoubleFloatMatrix")
   (marker :initform 'domain)
   (abbreviation :initform 'DFMAT)
   (comment :initform (list
     "This is a low-level domain which implements matrices"
     "(two dimensional arrays) of double precision floating point"
     "numbers.  Indexing is 0 based, there is no bound checking (unless"
     "provided by lower level)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DoubleFloatMatrix|
  (progn
    (push '|DoubleFloatMatrix| *Domains*)
    (make-instance '|DoubleFloatMatrixType|)))

\end{chunk}

\subsection{DoubleFloatVector}
\index[dom]{DoubleFloatVector!Domain}
\index[dom]{Domain!DoubleFloatVector}
\index[dom]{DFVEC}
\begin{chunk}{defclass DoubleFloatVectorType}
(defclass |DoubleFloatVectorType| (|VectorCategoryType|)
  ((parents :initform '(|VectorCategory|))
   (name :initform "DoubleFloatVector")
   (marker :initform 'domain)
   (abbreviation :initform 'DFVEC)
   (comment :initform (list
     "This is a low-level domain which implements vectors"
     "(one dimensional arrays) of double precision floating point"
     "numbers.  Indexing is 0 based, there is no bound checking (unless"
     "provided by lower level)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DoubleFloatVector|
  (progn
    (push '|DoubleFloatVector| *Domains*)
    (make-instance '|DoubleFloatVectorType|)))

\end{chunk}

\subsection{DrawOption}
\index[dom]{DrawOption!Domain}
\index[dom]{Domain!DrawOption}
\index[dom]{DROPT}
\begin{chunk}{defclass DrawOptionType}
(defclass |DrawOptionType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "DrawOption")
   (marker :initform 'domain)
   (abbreviation :initform 'DROPT)
   (comment :initform (list
     "DrawOption allows the user to specify defaults for the"
     "creation and rendering of plots."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DrawOption|
  (progn
    (push '|DrawOption| *Domains*)
    (make-instance '|DrawOptionType|)))

\end{chunk}

\subsection{d01ajfAnnaType}
\index[dom]{d01ajfAnnaType!Domain}
\index[dom]{Domain!d01ajfAnnaType}
\index[dom]{D01AJFA}
\begin{chunk}{defclass d01ajfAnnaTypeType}
(defclass |d01ajfAnnaTypeType| (|NumericalIntegrationCategoryType|)
  ((parents :initform '(|NumericalIntegrationCategory|))
   (name :initform "d01ajfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D01AJFA)
   (comment :initform (list
     "d01ajfAnnaType is a domain of"
     "NumericalIntegrationCategory"
     "for the NAG routine D01AJF, a general numerical integration routine which"
     "can handle some singularities in the input function.  The function"
     "measure measures the usefulness of the routine D01AJF"
     "for the given problem.  The function numericalIntegration"
     "performs the integration by using NagIntegrationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d01ajfAnnaType|
  (progn
    (push '|d01ajfAnnaType| *Domains*)
    (make-instance '|d01ajfAnnaTypeType|)))

\end{chunk}

\subsection{d01akfAnnaType}
\index[dom]{d01akfAnnaType!Domain}
\index[dom]{Domain!d01akfAnnaType}
\index[dom]{D01AKFA}
\begin{chunk}{defclass d01akfAnnaTypeType}
(defclass |d01akfAnnaTypeType| (|NumericalIntegrationCategoryType|)
  ((parents :initform '(|NumericalIntegrationCategory|))
   (name :initform "d01akfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D01AKFA)
   (comment :initform (list
     "d01akfAnnaType is a domain of"
     "NumericalIntegrationCategory"
     "for the NAG routine D01AKF, a numerical integration routine which is"
     "is suitable for oscillating, non-singular functions.  The function"
     "measure measures the usefulness of the routine D01AKF"
     "for the given problem.  The function numericalIntegration"
     "performs the integration by using NagIntegrationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d01akfAnnaType|
  (progn
    (push '|d01akfAnnaType| *Domains*)
    (make-instance '|d01akfAnnaTypeType|)))

\end{chunk}

\subsection{d01alfAnnaType}
\index[dom]{d01alfAnnaType!Domain}
\index[dom]{Domain!d01alfAnnaType}
\index[dom]{D01ALFA}
\begin{chunk}{defclass d01alfAnnaTypeType}
(defclass |d01alfAnnaTypeType| (|NumericalIntegrationCategoryType|)
  ((parents :initform '(|NumericalIntegrationCategory|))
   (name :initform "d01alfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D01ALFA)
   (comment :initform (list
     "d01alfAnnaType is a domain of"
     "NumericalIntegrationCategory"
     "for the NAG routine D01ALF, a general numerical integration routine which"
     "can handle a list of singularities.  The"
     "function measure measures the usefulness of the routine D01ALF"
     "for the given problem.  The function numericalIntegration"
     "performs the integration by using NagIntegrationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d01alfAnnaType|
  (progn
    (push '|d01alfAnnaType| *Domains*)
    (make-instance '|d01alfAnnaTypeType|)))

\end{chunk}

\subsection{d01amfAnnaType}
\index[dom]{d01amfAnnaType!Domain}
\index[dom]{Domain!d01amfAnnaType}
\index[dom]{D01AMFA}
\begin{chunk}{defclass d01amfAnnaTypeType}
(defclass |d01amfAnnaTypeType| (|NumericalIntegrationCategoryType|)
  ((parents :initform '(|NumericalIntegrationCategory|))
   (name :initform "d01amfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D01AMFA)
   (comment :initform (list
     "d01amfAnnaType is a domain of"
     "NumericalIntegrationCategory"
     "for the NAG routine D01AMF, a general numerical integration routine which"
     "can handle infinite or semi-infinite range of the input function.  The"
     "function measure measures the usefulness of the routine D01AMF"
     "for the given problem.  The function numericalIntegration"
     "performs the integration by using NagIntegrationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d01amfAnnaType|
  (progn
    (push '|d01amfAnnaType| *Domains*)
    (make-instance '|d01amfAnnaTypeType|)))

\end{chunk}

\subsection{d01anfAnnaType}
\index[dom]{d01anfAnnaType!Domain}
\index[dom]{Domain!d01anfAnnaType}
\index[dom]{D01ANFA}
\begin{chunk}{defclass d01anfAnnaTypeType}
(defclass |d01anfAnnaTypeType| (|NumericalIntegrationCategoryType|)
  ((parents :initform '(|NumericalIntegrationCategory|))
   (name :initform "d01anfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D01ANFA)
   (comment :initform (list
     "d01anfAnnaType is a domain of"
     "NumericalIntegrationCategory"
     "for the NAG routine D01ANF, a numerical integration routine which can"
     "handle weight functions of the form cos(omega x) or sin(omega x).  The"
     "function measure measures the usefulness of the routine D01ANF"
     "for the given problem.  The function numericalIntegration"
     "performs the integration by using NagIntegrationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d01anfAnnaType|
  (progn
    (push '|d01anfAnnaType| *Domains*)
    (make-instance '|d01anfAnnaTypeType|)))

\end{chunk}

\subsection{d01apfAnnaType}
\index[dom]{d01apfAnnaType!Domain}
\index[dom]{Domain!d01apfAnnaType}
\index[dom]{D01APFA}
\begin{chunk}{defclass d01apfAnnaTypeType}
(defclass |d01apfAnnaTypeType| (|NumericalIntegrationCategoryType|)
  ((parents :initform '(|NumericalIntegrationCategory|))
   (name :initform "d01apfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D01APFA)
   (comment :initform (list
     "d01apfAnnaType is a domain of"
     "NumericalIntegrationCategory"
     "for the NAG routine D01APF, a general numerical integration routine which"
     "can handle end point singularities of the algebraico-logarithmic form"
     "   w(x) = (x-a)^c * (b-x)^d.  The"
     "function measure measures the usefulness of the routine D01APF"
     "for the given problem.  The function numericalIntegration"
     "performs the integration by using NagIntegrationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d01apfAnnaType|
  (progn
    (push '|d01apfAnnaType| *Domains*)
    (make-instance '|d01apfAnnaTypeType|)))

\end{chunk}

\subsection{d01aqfAnnaType}
\index[dom]{d01aqfAnnaType!Domain}
\index[dom]{Domain!d01aqfAnnaType}
\index[dom]{D01AQFA}
\begin{chunk}{defclass d01aqfAnnaTypeType}
(defclass |d01aqfAnnaTypeType| (|NumericalIntegrationCategoryType|)
  ((parents :initform '(|NumericalIntegrationCategory|))
   (name :initform "d01aqfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D01AQFA)
   (comment :initform (list
     "d01aqfAnnaType is a domain of"
     "NumericalIntegrationCategory"
     "for the NAG routine D01AQF, a general numerical integration routine which"
     "can solve an integral of the form"
     "/home/bjd/Axiom/anna/hypertex/bitmaps/d01aqf.xbm"
     "The function measure measures the usefulness of the routine"
     "D01AQF for the given problem.  The function numericalIntegration"
     "performs the integration by using NagIntegrationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d01aqfAnnaType|
  (progn
    (push '|d01aqfAnnaType| *Domains*)
    (make-instance '|d01aqfAnnaTypeType|)))

\end{chunk}

\subsection{d01asfAnnaType}
\index[dom]{d01asfAnnaType!Domain}
\index[dom]{Domain!d01asfAnnaType}
\index[dom]{D01ASFA}
\begin{chunk}{defclass d01asfAnnaTypeType}
(defclass |d01asfAnnaTypeType| (|NumericalIntegrationCategoryType|)
  ((parents :initform '(|NumericalIntegrationCategory|))
   (name :initform "d01asfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D01ASFA)
   (comment :initform (list
     "d01asfAnnaType is a domain of"
     "NumericalIntegrationCategory"
     "for the NAG routine D01ASF, a numerical integration routine which can"
     "handle weight functions of the form cos(omega x) or sin(omega x) on an"
     "semi-infinite range.  The"
     "function measure measures the usefulness of the routine D01ASF"
     "for the given problem.  The function numericalIntegration"
     "performs the integration by using NagIntegrationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d01asfAnnaType|
  (progn
    (push '|d01asfAnnaType| *Domains*)
    (make-instance '|d01asfAnnaTypeType|)))

\end{chunk}

\subsection{d01fcfAnnaType}
\index[dom]{d01fcfAnnaType!Domain}
\index[dom]{Domain!d01fcfAnnaType}
\index[dom]{D01FCFA}
\begin{chunk}{defclass d01fcfAnnaTypeType}
(defclass |d01fcfAnnaTypeType| (|NumericalIntegrationCategoryType|)
  ((parents :initform '(|NumericalIntegrationCategory|))
   (name :initform "d01fcfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D01FCFA)
   (comment :initform (list
     "d01fcfAnnaType is a domain of"
     "NumericalIntegrationCategory"
     "for the NAG routine D01FCF, a numerical integration routine which can"
     "handle multi-dimensional quadrature over a finite region.  The"
     "function measure measures the usefulness of the routine D01GBF"
     "for the given problem.  The function numericalIntegration"
     "performs the integration by using NagIntegrationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d01fcfAnnaType|
  (progn
    (push '|d01fcfAnnaType| *Domains*)
    (make-instance '|d01fcfAnnaTypeType|)))

\end{chunk}

\subsection{d01gbfAnnaType}
\index[dom]{d01gbfAnnaType!Domain}
\index[dom]{Domain!d01gbfAnnaType}
\index[dom]{D01GBFA}
\begin{chunk}{defclass d01gbfAnnaTypeType}
(defclass |d01gbfAnnaTypeType| (|NumericalIntegrationCategoryType|)
  ((parents :initform '(|NumericalIntegrationCategory|))
   (name :initform "d01gbfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D01GBFA)
   (comment :initform (list
     "d01gbfAnnaType is a domain of"
     "NumericalIntegrationCategory"
     "for the NAG routine D01GBF, a numerical integration routine which can"
     "handle multi-dimensional quadrature over a finite region.  The"
     "function measure measures the usefulness of the routine D01GBF"
     "for the given problem.  The function numericalIntegration"
     "performs the integration by using NagIntegrationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d01gbfAnnaType|
  (progn
    (push '|d01gbfAnnaType| *Domains*)
    (make-instance '|d01gbfAnnaTypeType|)))

\end{chunk}

\subsection{d01TransformFunctionType}
\index[dom]{d01TransformFunctionType!Domain}
\index[dom]{Domain!d01TransformFunctionType}
\index[dom]{D01TRNS}
\begin{chunk}{defclass d01TransformFunctionTypeType}
(defclass |d01TransformFunctionTypeType| (|NumericalIntegrationCategoryType|)
  ((parents :initform '(|NumericalIntegrationCategory|))
   (name :initform "d01TransformFunctionType")
   (marker :initform 'domain)
   (abbreviation :initform 'D01TRNS)
   (comment :initform (list
     "Since an infinite integral cannot be evaluated numerically"
     "it is necessary to transform the integral onto finite ranges."
     "d01TransformFunctionType uses the mapping x -> 1/x"
     "and contains the functions measure and"
     "numericalIntegration."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d01TransformFunctionType|
  (progn
    (push '|d01TransformFunctionType| *Domains*)
    (make-instance '|d01TransformFunctionTypeType|)))

\end{chunk}

\subsection{d02bbfAnnaType}
\index[dom]{d02bbfAnnaType!Domain}
\index[dom]{Domain!d02bbfAnnaType}
\index[dom]{D02BBFA}
\begin{chunk}{defclass d02bbfAnnaTypeType}
(defclass |d02bbfAnnaTypeType| (|OrdinaryDifferentialEquationsSolverCategoryType|)
  ((parents :initform '(|OrdinaryDifferentialEquationsSolverCategory|))
   (name :initform "d02bbfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D02BBFA)
   (comment :initform (list
     "d02bbfAnnaType is a domain of"
     "OrdinaryDifferentialEquationsInitialValueProblemSolverCategory"
     "for the NAG routine D02BBF, a ODE routine which uses an"
     "Runge-Kutta method to solve a system of differential"
     "equations.  The function measure measures the"
     "usefulness of the routine D02BBF for the given problem.  The"
     "function ODESolve performs the integration by using"
     "NagOrdinaryDifferentialEquationsPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d02bbfAnnaType|
  (progn
    (push '|d02bbfAnnaType| *Domains*)
    (make-instance '|d02bbfAnnaTypeType|)))

\end{chunk}

\subsection{d02bhfAnnaType}
\index[dom]{d02bhfAnnaType!Domain}
\index[dom]{Domain!d02bhfAnnaType}
\index[dom]{D02BHFA}
\begin{chunk}{defclass d02bhfAnnaTypeType}
(defclass |d02bhfAnnaTypeType| (|OrdinaryDifferentialEquationsSolverCategoryType|)
  ((parents :initform '(|OrdinaryDifferentialEquationsSolverCategory|))
   (name :initform "d02bhfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D02BHFA)
   (comment :initform (list
     "d02bhfAnnaType is a domain of"
     "OrdinaryDifferentialEquationsInitialValueProblemSolverCategory"
     "for the NAG routine D02BHF, a ODE routine which uses an"
     "Runge-Kutta method to solve a system of differential"
     "equations.  The function measure measures the"
     "usefulness of the routine D02BHF for the given problem.  The"
     "function ODESolve performs the integration by using"
     "NagOrdinaryDifferentialEquationsPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d02bhfAnnaType|
  (progn
    (push '|d02bhfAnnaType| *Domains*)
    (make-instance '|d02bhfAnnaTypeType|)))

\end{chunk}

\subsection{d02cjfAnnaType}
\index[dom]{d02cjfAnnaType!Domain}
\index[dom]{Domain!d02cjfAnnaType}
\index[dom]{D02CJFA}
\begin{chunk}{defclass d02cjfAnnaTypeType}
(defclass |d02cjfAnnaTypeType| (|OrdinaryDifferentialEquationsSolverCategoryType|)
  ((parents :initform '(|OrdinaryDifferentialEquationsSolverCategory|))
   (name :initform "d02cjfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D02CJFA)
   (comment :initform (list
     "d02cjfAnnaType is a domain of"
     "OrdinaryDifferentialEquationsInitialValueProblemSolverCategory"
     "for the NAG routine D02CJF, a ODE routine which uses an"
     "Adams-Moulton-Bashworth method to solve a system of differential"
     "equations.  The function measure measures the"
     "usefulness of the routine D02CJF for the given problem.  The"
     "function ODESolve performs the integration by using"
     "NagOrdinaryDifferentialEquationsPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d02cjfAnnaType|
  (progn
    (push '|d02cjfAnnaType| *Domains*)
    (make-instance '|d02cjfAnnaTypeType|)))

\end{chunk}

\subsection{d02ejfAnnaType}
\index[dom]{d02ejfAnnaType!Domain}
\index[dom]{Domain!d02ejfAnnaType}
\index[dom]{D02EJFA}
\begin{chunk}{defclass d02ejfAnnaTypeType}
(defclass |d02ejfAnnaTypeType| (|OrdinaryDifferentialEquationsSolverCategoryType|)
  ((parents :initform '(|OrdinaryDifferentialEquationsSolverCategory|))
   (name :initform "d02ejfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D02EJFA)
   (comment :initform (list
     "d02ejfAnnaType is a domain of"
     "OrdinaryDifferentialEquationsInitialValueProblemSolverCategory"
     "for the NAG routine D02EJF, a ODE routine which uses a backward"
     "differentiation formulae method to handle a stiff system"
     "of differential equations.  The function measure measures"
     "the usefulness of the routine D02EJF for the given problem.  The"
     "function ODESolve performs the integration by using"
     "NagOrdinaryDifferentialEquationsPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d02ejfAnnaType|
  (progn
    (push '|d02ejfAnnaType| *Domains*)
    (make-instance '|d02ejfAnnaTypeType|)))

\end{chunk}

\subsection{d03eefAnnaType}
\index[dom]{d03eefAnnaType!Domain}
\index[dom]{Domain!d03eefAnnaType}
\index[dom]{D03EEFA}
\begin{chunk}{defclass d03eefAnnaTypeType}
(defclass |d03eefAnnaTypeType| (|PartialDifferentialEquationsSolverCategoryType|)
  ((parents :initform '(|PartialDifferentialEquationsSolverCategory|))
   (name :initform "d03eefAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D03EEFA)
   (comment :initform (list
     "d03eefAnnaType is a domain of"
     "PartialDifferentialEquationsSolverCategory"
     "for the NAG routines D03EEF/D03EDF."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d03eefAnnaType|
  (progn
    (push '|d03eefAnnaType| *Domains*)
    (make-instance '|d03eefAnnaTypeType|)))

\end{chunk}

\subsection{d03fafAnnaType}
\index[dom]{d03fafAnnaType!Domain}
\index[dom]{Domain!d03fafAnnaType}
\index[dom]{D03FAFA}
\begin{chunk}{defclass d03fafAnnaTypeType}
(defclass |d03fafAnnaTypeType| (|PartialDifferentialEquationsSolverCategoryType|)
  ((parents :initform '(|PartialDifferentialEquationsSolverCategory|))
   (name :initform "d03fafAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'D03FAFA)
   (comment :initform (list
     "d03fafAnnaType is a domain of"
     "PartialDifferentialEquationsSolverCategory"
     "for the NAG routine D03FAF."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d03fafAnnaType|
  (progn
    (push '|d03fafAnnaType| *Domains*)
    (make-instance '|d03fafAnnaTypeType|)))

\end{chunk}

\section{E}

\subsection{ElementaryFunctionsUnivariateLaurentSeries}
\index[dom]{ElementaryFunctionsUnivariateLaurentSeries!Domain}
\index[dom]{Domain!ElementaryFunctionsUnivariateLaurentSeries}
\index[dom]{EFULS}
\begin{chunk}{defclass ElementaryFunctionsUnivariateLaurentSeriesType}
(defclass |ElementaryFunctionsUnivariateLaurentSeriesType| (|PartialTranscendentalFunctionsType|)
  ((parents :initform '(|PartialTranscendentalFunctions|))
   (name :initform "ElementaryFunctionsUnivariateLaurentSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'EFULS)
   (comment :initform (list
     "This domain provides elementary functions on any Laurent series"
     "domain over a field which was constructed from a Taylor series"
     "domain.  These functions are implemented by calling the"
     "corresponding functions on the Taylor series domain.  We also"
     "provide 'partial functions' which compute transcendental"
     "functions of Laurent series when possible and return 'failed'"
     "when this is not possible."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ElementaryFunctionsUnivariateLaurentSeries|
  (progn
    (push '|ElementaryFunctionsUnivariateLaurentSeries| *Domains*)
    (make-instance '|ElementaryFunctionsUnivariateLaurentSeriesType|)))

\end{chunk}

\subsection{ElementaryFunctionsUnivariatePuiseuxSeries}
\index[dom]{ElementaryFunctionsUnivariatePuiseuxSeries!Domain}
\index[dom]{Domain!ElementaryFunctionsUnivariatePuiseuxSeries}
\index[dom]{EFUPXS}
\begin{chunk}{defclass ElementaryFunctionsUnivariatePuiseuxSeriesType}
(defclass |ElementaryFunctionsUnivariatePuiseuxSeriesType| (|PartialTranscendentalFunctionsType|)
  ((parents :initform '(|PartialTranscendentalFunctions|))
   (name :initform "ElementaryFunctionsUnivariatePuiseuxSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'EFUPXS)
   (comment :initform (list
     "This package provides elementary functions on any Laurent series"
     "domain over a field which was constructed from a Taylor series"
     "domain.  These functions are implemented by calling the"
     "corresponding functions on the Taylor series domain.  We also"
     "provide 'partial functions' which compute transcendental"
     "functions of Laurent series when possible and return 'failed'"
     "when this is not possible."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ElementaryFunctionsUnivariatePuiseuxSeries|
  (progn
    (push '|ElementaryFunctionsUnivariatePuiseuxSeries| *Domains*)
    (make-instance '|ElementaryFunctionsUnivariatePuiseuxSeriesType|)))

\end{chunk}

\subsection{Equation}
\index[dom]{Equation!Domain}
\index[dom]{Domain!Equation}
\index[dom]{EQ}
\begin{chunk}{defclass EquationType}
(defclass |EquationType| (|GroupType|
                          |InnerEvalableType|
                          |PartialDifferentialRingType|
                          |TypeType|
                          |VectorSpaceType|)
  ((parents :initform '(|Group|
                        |InnerEvalable|
                        |PartialDifferentialRing|
                        |Type|
                        |VectorSpace|))
   (name :initform "Equation")
   (marker :initform 'domain)
   (abbreviation :initform 'EQ)
   (comment :initform (list
     "Equations as mathematical objects.  All properties of the basis domain,"
     "for example being an abelian group are carried over the equation domain,"
     "by performing the structural operations on the left and on the"
     "right hand side."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Equation|
  (progn
    (push '|Equation| *Domains*)
    (make-instance '|EquationType|)))

\end{chunk}

\subsection{EqTable}
\index[dom]{EqTable!Domain}
\index[dom]{Domain!EqTable}
\index[dom]{EQTBL}
\begin{chunk}{defclass EqTableType}
(defclass |EqTableType| (|TableAggregateType|)
  ((parents :initform '(|TableAggregate|))
   (name :initform "EqTable")
   (marker :initform 'domain)
   (abbreviation :initform 'EQTBL)
   (comment :initform (list
     "This domain provides tables where the keys are compared using"
     "eq?.  Thus keys are considered equal only if they"
     "are the same instance of a structure."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |EqTable|
  (progn
    (push '|EqTable| *Domains*)
    (make-instance '|EqTableType|)))

\end{chunk}

\subsection{EuclideanModularRing}
\index[dom]{EuclideanModularRing!Domain}
\index[dom]{Domain!EuclideanModularRing}
\index[dom]{EMR}
\begin{chunk}{defclass EuclideanModularRingType}
(defclass |EuclideanModularRingType| (|EuclideanDomainType|)
  ((parents :initform '(|EuclideanDomain|))
   (name :initform "EuclideanModularRing")
   (marker :initform 'domain)
   (abbreviation :initform 'EMR)
   (comment :initform (list
     "These domains are used for the factorization and gcds"
     "of univariate polynomials over the integers in order to work modulo"
     "different  primes."
     "See ModularRing, ModularField"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |EuclideanModularRing|
  (progn
    (push '|EuclideanModularRing| *Domains*)
    (make-instance '|EuclideanModularRingType|)))

\end{chunk}

\subsection{Exit}
\index[dom]{Exit!Domain}
\index[dom]{Domain!Exit}
\index[dom]{EXIT}
\begin{chunk}{defclass ExitType}
(defclass |ExitType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "Exit")
   (marker :initform 'domain)
   (abbreviation :initform 'EXIT)
   (comment :initform (list
     "A function which does not return directly to its caller should"
     "have Exit as its return type."
     " "
     "Note that It is convenient to have a formal coerce into each type"
     "from type Exit. This allows, for example, errors to be raised in"
     "one half of a type-balanced if."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Exit|
  (progn
    (push '|Exit| *Domains*)
    (make-instance '|ExitType|)))

\end{chunk}

\subsection{ExponentialExpansion}
\index[dom]{ExponentialExpansion!Domain}
\index[dom]{Domain!ExponentialExpansion}
\index[dom]{EXPEXPAN}
\begin{chunk}{defclass ExponentialExpansionType}
(defclass |ExponentialExpansionType| (|QuotientFieldCategoryType|)
  ((parents :initform '(|QuotientFieldCategory|))
   (name :initform "ExponentialExpansion")
   (marker :initform 'domain)
   (abbreviation :initform 'EXPEXPAN)
   (comment :initform (list
     "UnivariatePuiseuxSeriesWithExponentialSingularity is a domain used to"
     "represent essential singularities of functions.  Objects in this domain"
     "are quotients of sums, where each term in the sum is a univariate Puiseux"
     "series times the exponential of a univariate Puiseux series."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExponentialExpansion|
  (progn
    (push '|ExponentialExpansion| *Domains*)
    (make-instance '|ExponentialExpansionType|)))

\end{chunk}

\subsection{Expression}
\index[dom]{Expression!Domain}
\index[dom]{Domain!Expression}
\index[dom]{EXPR}
\begin{chunk}{defclass ExpressionType}
(defclass |ExpressionType| (|SpecialFunctionCategoryType|
                            |LiouvillianFunctionCategoryType|
                            |CombinatorialOpsCategoryType|
                            |AlgebraicallyClosedFunctionSpaceType|)
  ((parents :initform '(|SpecialFunctionCategory|
                        |LiouvillianFunctionCategory|
                        |CombinatorialOpsCategory|
                        |AlgebraicallyClosedFunctionSpace|))
   (name :initform "Expression")
   (marker :initform 'domain)
   (abbreviation :initform 'EXPR)
   (comment :initform (list
     "Top-level mathematical expressions involving symbolic functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Expression|
  (progn
    (push '|Expression| *Domains*)
    (make-instance '|ExpressionType|)))

\end{chunk}

\subsection{ExponentialOfUnivariatePuiseuxSeries}
\index[dom]{ExponentialOfUnivariatePuiseuxSeries!Domain}
\index[dom]{Domain!ExponentialOfUnivariatePuiseuxSeries}
\index[dom]{EXPUPXS}
\begin{chunk}{defclass ExponentialOfUnivariatePuiseuxSeriesType}
(defclass |ExponentialOfUnivariatePuiseuxSeriesType| (|OrderedAbelianMonoidType|
                                                      |UnivariatePuiseuxSeriesCategoryType|)
  ((parents :initform '(|OrderedAbelianMonoid| |UnivariatePuiseuxSeriesCategory|))
   (name :initform "ExponentialOfUnivariatePuiseuxSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'EXPUPXS)
   (comment :initform (list
     "ExponentialOfUnivariatePuiseuxSeries is a domain used to represent"
     "essential singularities of functions.  An object in this domain is a"
     "function of the form exp(f(x)), where f(x) is a Puiseux"
     "series with no terms of non-negative degree.  Objects are ordered"
     "according to order of singularity, with functions which tend more"
     "rapidly to zero or infinity considered to be larger.  Thus, if"
     "order(f(x)) < order(g(x)), the first non-zero term of"
     "f(x) has lower degree than the first non-zero term of g(x),"
     "then exp(f(x)) > exp(g(x)).  If order(f(x)) = order(g(x)),"
     "then the ordering is essentially random.  This domain is used"
     "in computing limits involving functions with essential singularities."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExponentialOfUnivariatePuiseuxSeries|
  (progn
    (push '|ExponentialOfUnivariatePuiseuxSeries| *Domains*)
    (make-instance '|ExponentialOfUnivariatePuiseuxSeriesType|)))

\end{chunk}

\subsection{ExtAlgBasis}
\index[dom]{ExtAlgBasis!Domain}
\index[dom]{Domain!ExtAlgBasis}
\index[dom]{EAB}
\begin{chunk}{defclass ExtAlgBasisType}
(defclass |ExtAlgBasisType| (|OrderedSetType|)
  ((parents :initform '(|OrderedSet|))
   (name :initform "ExtAlgBasis")
   (marker :initform 'domain)
   (abbreviation :initform 'EAB)
   (comment :initform (list
     "A domain used in the construction of the exterior algebra on a set"
     "X over a ring R.  This domain represents the set of all ordered"
     "subsets of the set X, assumed to be in correspondance with"
     "{1,2,3, ...}.  The ordered subsets are themselves ordered"
     "lexicographically and are in bijective correspondance with an ordered"
     "basis of the exterior algebra.  In this domain we are dealing strictly"
     "with the exponents of basis elements which can only be 0 or 1."
     " "
     "The multiplicative identity element of the exterior algebra corresponds"
     "to the empty subset of X.  A coerce from List Integer to an"
     "ordered basis element is provided to allow the convenient input of"
     "expressions. Another exported function forgets the ordered structure"
     "and simply returns the list corresponding to an ordered subset."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExtAlgBasis|
  (progn
    (push '|ExtAlgBasis| *Domains*)
    (make-instance '|ExtAlgBasisType|)))

\end{chunk}

\subsection{e04dgfAnnaType}
\index[dom]{e04dgfAnnaType!Domain}
\index[dom]{Domain!e04dgfAnnaType}
\index[dom]{E04DGFA}
\begin{chunk}{defclass e04dgfAnnaTypeType}
(defclass |e04dgfAnnaTypeType| (|NumericalOptimizationCategoryType|)
  ((parents :initform '(|NumericalOptimizationCategory|))
   (name :initform "e04dgfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'E04DGFA)
   (comment :initform (list
     "e04dgfAnnaType is a domain of NumericalOptimization"
     "for the NAG routine E04DGF, a general optimization routine which"
     "can handle some singularities in the input function.  The function"
     "measure measures the usefulness of the routine E04DGF"
     "for the given problem.  The function numericalOptimization"
     "performs the optimization by using NagOptimisationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |e04dgfAnnaType|
  (progn
    (push '|e04dgfAnnaType| *Domains*)
    (make-instance '|e04dgfAnnaTypeType|)))

\end{chunk}

\subsection{e04fdfAnnaType}
\index[dom]{e04fdfAnnaType!Domain}
\index[dom]{Domain!e04fdfAnnaType}
\index[dom]{E04FDFA}
\begin{chunk}{defclass e04fdfAnnaTypeType}
(defclass |e04fdfAnnaTypeType| (|NumericalOptimizationCategoryType|)
  ((parents :initform '(|NumericalOptimizationCategory|))
   (name :initform "e04fdfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'E04FDFA)
   (comment :initform (list
     "e04fdfAnnaType is a domain of NumericalOptimization"
     "for the NAG routine E04FDF, a general optimization routine which"
     "can handle some singularities in the input function.  The function"
     "measure measures the usefulness of the routine E04FDF"
     "for the given problem.  The function numericalOptimization"
     "performs the optimization by using NagOptimisationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |e04fdfAnnaType|
  (progn
    (push '|e04fdfAnnaType| *Domains*)
    (make-instance '|e04fdfAnnaTypeType|)))

\end{chunk}

\subsection{e04gcfAnnaType}
\index[dom]{e04gcfAnnaType!Domain}
\index[dom]{Domain!e04gcfAnnaType}
\index[dom]{E04GCFA}
\begin{chunk}{defclass e04gcfAnnaTypeType}
(defclass |e04gcfAnnaTypeType| (|NumericalOptimizationCategoryType|)
  ((parents :initform '(|NumericalOptimizationCategory|))
   (name :initform "e04gcfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'E04GCFA)
   (comment :initform (list
     "e04gcfAnnaType is a domain of NumericalOptimization"
     "for the NAG routine E04GCF, a general optimization routine which"
     "can handle some singularities in the input function.  The function"
     "measure measures the usefulness of the routine E04GCF"
     "for the given problem.  The function numericalOptimization"
     "performs the optimization by using NagOptimisationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |e04gcfAnnaType|
  (progn
    (push '|e04gcfAnnaType| *Domains*)
    (make-instance '|e04gcfAnnaTypeType|)))

\end{chunk}

\subsection{e04jafAnnaType}
\index[dom]{e04jafAnnaType!Domain}
\index[dom]{Domain!e04jafAnnaType}
\index[dom]{E04JAFA}
\begin{chunk}{defclass e04jafAnnaTypeType}
(defclass |e04jafAnnaTypeType| (|NumericalOptimizationCategoryType|)
  ((parents :initform '(|NumericalOptimizationCategory|))
   (name :initform "e04jafAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'E04JAFA)
   (comment :initform (list
     "e04jafAnnaType is a domain of NumericalOptimization"
     "for the NAG routine E04JAF, a general optimization routine which"
     "can handle some singularities in the input function.  The function"
     "measure measures the usefulness of the routine E04JAF"
     "for the given problem.  The function numericalOptimization"
     "performs the optimization by using NagOptimisationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |e04jafAnnaType|
  (progn
    (push '|e04jafAnnaType| *Domains*)
    (make-instance '|e04jafAnnaTypeType|)))

\end{chunk}

\subsection{e04mbfAnnaType}
\index[dom]{e04mbfAnnaType!Domain}
\index[dom]{Domain!e04mbfAnnaType}
\index[dom]{E04MBFA}
\begin{chunk}{defclass e04mbfAnnaTypeType}
(defclass |e04mbfAnnaTypeType| (|NumericalOptimizationCategoryType|)
  ((parents :initform '(|NumericalOptimizationCategory|))
   (name :initform "e04mbfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'E04MBFA)
   (comment :initform (list
     "e04mbfAnnaType is a domain of NumericalOptimization"
     "for the NAG routine E04MBF, an optimization routine for Linear functions."
     "The function"
     "measure measures the usefulness of the routine E04MBF"
     "for the given problem.  The function numericalOptimization"
     "performs the optimization by using NagOptimisationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |e04mbfAnnaType|
  (progn
    (push '|e04mbfAnnaType| *Domains*)
    (make-instance '|e04mbfAnnaTypeType|)))

\end{chunk}

\subsection{e04nafAnnaType}
\index[dom]{e04nafAnnaType!Domain}
\index[dom]{Domain!e04nafAnnaType}
\index[dom]{E04NAFA}
\begin{chunk}{defclass e04nafAnnaTypeType}
(defclass |e04nafAnnaTypeType| (|NumericalOptimizationCategoryType|)
  ((parents :initform '(|NumericalOptimizationCategory|))
   (name :initform "e04nafAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'E04NAFA)
   (comment :initform (list
     "e04nafAnnaType is a domain of NumericalOptimization"
     "for the NAG routine E04NAF, an optimization routine for Quadratic functions."
     "The function"
     "measure measures the usefulness of the routine E04NAF"
     "for the given problem.  The function numericalOptimization"
     "performs the optimization by using NagOptimisationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |e04nafAnnaType|
  (progn
    (push '|e04nafAnnaType| *Domains*)
    (make-instance '|e04nafAnnaTypeType|)))

\end{chunk}

\subsection{e04ucfAnnaType}
\index[dom]{e04ucfAnnaType!Domain}
\index[dom]{Domain!e04ucfAnnaType}
\index[dom]{E04UCFA}
\begin{chunk}{defclass e04ucfAnnaTypeType}
(defclass |e04ucfAnnaTypeType| (|NumericalOptimizationCategoryType|)
  ((parents :initform '(|NumericalOptimizationCategory|))
   (name :initform "e04ucfAnnaType")
   (marker :initform 'domain)
   (abbreviation :initform 'E04UCFA)
   (comment :initform (list
     "e04ucfAnnaType is a domain of NumericalOptimization"
     "for the NAG routine E04UCF, a general optimization routine which"
     "can handle some singularities in the input function.  The function"
     "measure measures the usefulness of the routine E04UCF"
     "for the given problem.  The function numericalOptimization"
     "performs the optimization by using NagOptimisationPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |e04ucfAnnaType|
  (progn
    (push '|e04ucfAnnaType| *Domains*)
    (make-instance '|e04ucfAnnaTypeType|)))

\end{chunk}

\section{F}

\subsection{Factored}
\index[dom]{Factored!Domain}
\index[dom]{Domain!Factored}
\index[dom]{FR}
\begin{chunk}{defclass FactoredType}
(defclass |FactoredType| (|UniqueFactorizationDomainType|
                          |RealConstantType|
                          |FullyRetractableToType|
                          |FullyEvalableOverType|
                          |DifferentialExtensionType|)
  ((parents :initform '(|UniqueFactorizationDomain|
                        |RealConstant|
                        |FullyRetractableTo|
                        |FullyEvalableOver|
                        |DifferentialExtension|))
   (name :initform "Factored")
   (marker :initform 'domain)
   (abbreviation :initform 'FR)
   (comment :initform (list
     "Factored creates a domain whose objects are kept in"
     "factored form as long as possible.  Thus certain operations like"
     "multiplication and gcd are relatively easy to do.  Others, like"
     "addition require somewhat more work, and unless the argument"
     "domain provides a factor function, the result may not be"
     "completely factored.  Each object consists of a unit and a list of"
     "factors, where a factor has a member of R (the 'base'), and"
     "exponent and a flag indicating what is known about the base.  A"
     "flag may be one of 'nil', 'sqfr', 'irred' or 'prime', which respectively mean"
     "that nothing is known about the base, it is square-free, it is"
     "irreducible, or it is prime.  The current"
     "restriction to integral domains allows simplification to be"
     "performed without worrying about multiplication order."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Factored|
  (progn
    (push '|Factored| *Domains*)
    (make-instance '|FactoredType|)))

\end{chunk}

\subsection{File}
\index[dom]{File!Domain}
\index[dom]{Domain!File}
\index[dom]{FILE}
\begin{chunk}{defclass FileType}
(defclass |FileType| (|FileCategoryType|)
  ((parents :initform '(|FileCategory|))
   (name :initform "File")
   (marker :initform 'domain)
   (abbreviation :initform 'FILE)
   (comment :initform (list
     "This domain provides a basic model of files to save arbitrary values."
     "The operations provide sequential access to the contents."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |File|
  (progn
    (push '|File| *Domains*)
    (make-instance '|FileType|)))

\end{chunk}

\subsection{FileName}
\index[dom]{FileName!Domain}
\index[dom]{Domain!FileName}
\index[dom]{FNAME}
\begin{chunk}{defclass FileNameType}
(defclass |FileNameType| (|FileNameCategoryType|)
  ((parents :initform '(|FileNameCategory|))
   (name :initform "FileName")
   (marker :initform 'domain)
   (abbreviation :initform 'FNAME)
   (comment :initform (list
     "This domain provides an interface to names in the file system."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FileName|
  (progn
    (push '|FileName| *Domains*)
    (make-instance '|FileNameType|)))

\end{chunk}

\subsection{FiniteDivisor}
\index[dom]{FiniteDivisor!Domain}
\index[dom]{Domain!FiniteDivisor}
\index[dom]{FDIV}
\begin{chunk}{defclass FiniteDivisorType}
(defclass |FiniteDivisorType| (|FiniteDivisorCategoryType|)
  ((parents :initform '(|FiniteDivisorCategory|))
   (name :initform "FiniteDivisor")
   (marker :initform 'domain)
   (abbreviation :initform 'FDIV)
   (comment :initform (list
     "This domains implements finite rational divisors on a curve, that"
     "is finite formal sums SUM(n * P) where the n's are integers and the"
     "P's are finite rational points on the curve."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteDivisor|
  (progn
    (push '|FiniteDivisor| *Domains*)
    (make-instance '|FiniteDivisorType|)))

\end{chunk}

\subsection{FiniteField}
\index[dom]{FiniteField!Domain}
\index[dom]{Domain!FiniteField}
\index[dom]{FF}
\begin{chunk}{defclass FiniteFieldType}
(defclass |FiniteFieldType| (|FiniteAlgebraicExtensionFieldType|)
  ((parents :initform '(|FiniteAlgebraicExtensionField|))
   (name :initform "FiniteField")
   (marker :initform 'domain)
   (abbreviation :initform 'FF)
   (comment :initform (list
     "FiniteField(p,n) implements finite fields with p**n elements."
     "This packages checks that p is prime."
     "For a non-checking version, see InnerFiniteField."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteField|
  (progn
    (push '|FiniteField| *Domains*)
    (make-instance '|FiniteFieldType|)))

\end{chunk}

\subsection{FiniteFieldCyclicGroup}
\index[dom]{FiniteFieldCyclicGroup!Domain}
\index[dom]{Domain!FiniteFieldCyclicGroup}
\index[dom]{FFCG}
\begin{chunk}{defclass FiniteFieldCyclicGroupType}
(defclass |FiniteFieldCyclicGroupType| (|FiniteAlgebraicExtensionFieldType|)
  ((parents :initform '(|FiniteAlgebraicExtensionField|))
   (name :initform "FiniteFieldCyclicGroup")
   (marker :initform 'domain)
   (abbreviation :initform 'FFCG)
   (comment :initform (list
     "FiniteFieldCyclicGroup(p,n) implements a finite field extension of degee n"
     "over the prime field with p elements. Its elements are represented by"
     "powers of a primitive element, a generator of the multiplicative"
     "(cyclic) group. As primitive element we choose the root of the extension"
     "polynomial, which is created by createPrimitivePoly from"
     "FiniteFieldPolynomialPackage. The Zech logarithms are stored"
     "in a table of size half of the field size, and use SingleInteger"
     "for representing field elements, hence, there are restrictions"
     "on the size of the field."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldCyclicGroup|
  (progn
    (push '|FiniteFieldCyclicGroup| *Domains*)
    (make-instance '|FiniteFieldCyclicGroupType|)))

\end{chunk}

\subsection{FiniteFieldCyclicGroupExtension}
\index[dom]{FiniteFieldCyclicGroupExtension!Domain}
\index[dom]{Domain!FiniteFieldCyclicGroupExtension}
\index[dom]{FFCGX}
\begin{chunk}{defclass FiniteFieldCyclicGroupExtensionType}
(defclass |FiniteFieldCyclicGroupExtensionType| (|FiniteAlgebraicExtensionFieldType|)
  ((parents :initform '(|FiniteAlgebraicExtensionField|))
   (name :initform "FiniteFieldCyclicGroupExtension")
   (marker :initform 'domain)
   (abbreviation :initform 'FFCGX)
   (comment :initform (list
     "FiniteFieldCyclicGroupExtension(GF,n)  implements a extension of degree n"
     "over the ground field GF. Its elements are represented by powers of"
     "a primitive element, a generator of the multiplicative (cyclic) group."
     "As primitive element we choose the root of the extension polynomial, which"
     "is created by createPrimitivePoly from"
     "FiniteFieldPolynomialPackage. Zech logarithms are stored"
     "in a table of size half of the field size, and use SingleInteger"
     "for representing field elements, hence, there are restrictions"
     "on the size of the field."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldCyclicGroupExtension|
  (progn
    (push '|FiniteFieldCyclicGroupExtension| *Domains*)
    (make-instance '|FiniteFieldCyclicGroupExtensionType|)))

\end{chunk}

\subsection{FiniteFieldCyclicGroupExtensionByPolynomial}
\index[dom]{FiniteFieldCyclicGroupExtensionByPolynomial!Domain}
\index[dom]{Domain!FiniteFieldCyclicGroupExtensionByPolynomial}
\index[dom]{FFCGP}
\begin{chunk}{defclass FiniteFieldCyclicGroupExtensionByPolynomialType}
(defclass |FiniteFieldCyclicGroupExtensionByPolynomialType| (|FiniteAlgebraicExtensionFieldType|)
  ((parents :initform '(|FiniteAlgebraicExtensionField|))
   (name :initform "FiniteFieldCyclicGroupExtensionByPolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'FFCGP)
   (comment :initform (list
     "FiniteFieldCyclicGroupExtensionByPolynomial(GF,defpol)  implements a"
     "finite extension field of the ground field GF. Its elements are"
     "represented by powers of a primitive element, a generator of the"
     "multiplicative (cyclic) group. As primitive"
     "element we choose the root of the extension polynomial defpol,"
     "which MUST be primitive (user responsibility). Zech logarithms are stored"
     "in a table of size half of the field size, and use SingleInteger"
     "for representing field elements, hence, there are restrictions"
     "on the size of the field."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldCyclicGroupExtensionByPolynomial|
  (progn
    (push '|FiniteFieldCyclicGroupExtensionByPolynomial| *Domains*)
    (make-instance '|FiniteFieldCyclicGroupExtensionByPolynomialType|)))

\end{chunk}

\subsection{FiniteFieldExtension}
\index[dom]{FiniteFieldExtension!Domain}
\index[dom]{Domain!FiniteFieldExtension}
\index[dom]{FFX}
\begin{chunk}{defclass FiniteFieldExtensionType}
(defclass |FiniteFieldExtensionType| (|FiniteAlgebraicExtensionFieldType|)
  ((parents :initform '(|FiniteAlgebraicExtensionField|))
   (name :initform "FiniteFieldExtension")
   (marker :initform 'domain)
   (abbreviation :initform 'FFX)
   (comment :initform (list
     "FiniteFieldExtensionByPolynomial(GF, n) implements an extension"
     "of the finite field GF of degree n generated by the extension"
     "polynomial constructed by createIrreduciblePoly from"
     "FiniteFieldPolynomialPackage."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldExtension|
  (progn
    (push '|FiniteFieldExtension| *Domains*)
    (make-instance '|FiniteFieldExtensionType|)))

\end{chunk}

\subsection{FiniteFieldExtensionByPolynomial}
\index[dom]{FiniteFieldExtensionByPolynomial!Domain}
\index[dom]{Domain!FiniteFieldExtensionByPolynomial}
\index[dom]{FFP}
\begin{chunk}{defclass FiniteFieldExtensionByPolynomialType}
(defclass |FiniteFieldExtensionByPolynomialType| (|FiniteAlgebraicExtensionFieldType|)
  ((parents :initform '(|FiniteAlgebraicExtensionField|))
   (name :initform "FiniteFieldExtensionByPolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'FFP)
   (comment :initform (list
     "FiniteFieldExtensionByPolynomial(GF, defpol) implements the extension"
     "of the finite field GF generated by the extension polynomial"
     "defpol which MUST be irreducible."
     "Note: the user has the responsibility to ensure that"
     "defpol is irreducible."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldExtensionByPolynomial|
  (progn
    (push '|FiniteFieldExtensionByPolynomial| *Domains*)
    (make-instance '|FiniteFieldExtensionByPolynomialType|)))

\end{chunk}

\subsection{FiniteFieldNormalBasis}
\index[dom]{FiniteFieldNormalBasis!Domain}
\index[dom]{Domain!FiniteFieldNormalBasis}
\index[dom]{FFNB}
\begin{chunk}{defclass FiniteFieldNormalBasisType}
(defclass |FiniteFieldNormalBasisType| (|FiniteAlgebraicExtensionFieldType|)
  ((parents :initform '(|FiniteAlgebraicExtensionField|))
   (name :initform "FiniteFieldNormalBasis")
   (marker :initform 'domain)
   (abbreviation :initform 'FFNB)
   (comment :initform (list
     "FiniteFieldNormalBasis(p,n) implements a"
     "finite extension field of degree n over the prime field with p elements."
     "The elements are represented by coordinate vectors with respect to"
     "a normal basis,"
     "a basis consisting of the conjugates (q-powers) of an element, in"
     "this case called normal element."
     "This is chosen as a root of the extension polynomial"
     "created by createNormalPoly"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldNormalBasis|
  (progn
    (push '|FiniteFieldNormalBasis| *Domains*)
    (make-instance '|FiniteFieldNormalBasisType|)))

\end{chunk}

\subsection{FiniteFieldNormalBasisExtension}
\index[dom]{FiniteFieldNormalBasisExtension!Domain}
\index[dom]{Domain!FiniteFieldNormalBasisExtension}
\index[dom]{FFNBX}
\begin{chunk}{defclass FiniteFieldNormalBasisExtensionType}
(defclass |FiniteFieldNormalBasisExtensionType| (|FiniteAlgebraicExtensionFieldType|)
  ((parents :initform '(|FiniteAlgebraicExtensionField|))
   (name :initform "FiniteFieldNormalBasisExtension")
   (marker :initform 'domain)
   (abbreviation :initform 'FFNBX)
   (comment :initform (list
     "FiniteFieldNormalBasisExtensionByPolynomial(GF,n)  implements a"
     "finite extension field of degree n over the ground field GF."
     "The elements are represented by coordinate vectors with respect"
     "to a normal basis,"
     "a basis consisting of the conjugates (q-powers) of an element,"
     "in this case called normal element. This is chosen as a root of the extension"
     "polynomial, created by createNormalPoly from"
     "FiniteFieldPolynomialPackage"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldNormalBasisExtension|
  (progn
    (push '|FiniteFieldNormalBasisExtension| *Domains*)
    (make-instance '|FiniteFieldNormalBasisExtensionType|)))

\end{chunk}

\subsection{FiniteFieldNormalBasisExtensionByPolynomial}
\index[dom]{FiniteFieldNormalBasisExtensionByPolynomial!Domain}
\index[dom]{Domain!FiniteFieldNormalBasisExtensionByPolynomial}
\index[dom]{FFNBP}
\begin{chunk}{defclass FiniteFieldNormalBasisExtensionByPolynomialType}
(defclass |FiniteFieldNormalBasisExtensionByPolynomialType| (|FiniteAlgebraicExtensionFieldType|)
  ((parents :initform '(|FiniteAlgebraicExtensionField|))
   (name :initform "FiniteFieldNormalBasisExtensionByPolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'FFNBP)
   (comment :initform (list
     "FiniteFieldNormalBasisExtensionByPolynomial(GF,uni) implements a"
     "finite extension of the ground field GF. The elements are"
     "represented by coordinate vectors with respect to a normal basis, a basis"
     "consisting of the conjugates (q-powers) of an element, in this case"
     "called normal element, where q is the size of GF."
     "The normal element is chosen as a root of the extension"
     "polynomial, which MUST be normal over GF  (user responsibility)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldNormalBasisExtensionByPolynomial|
  (progn
    (push '|FiniteFieldNormalBasisExtensionByPolynomial| *Domains*)
    (make-instance '|FiniteFieldNormalBasisExtensionByPolynomialType|)))

\end{chunk}

\subsection{FlexibleArray}
\index[dom]{FlexibleArray!Domain}
\index[dom]{Domain!FlexibleArray}
\index[dom]{FARRAY}
\begin{chunk}{defclass FlexibleArrayType}
(defclass |FlexibleArrayType| (|ExtensibleLinearAggregateType|
                               |OneDimensionalArrayAggregateType|)
  ((parents :initform '(|ExtensibleLinearAggregate| |OneDimensionalArrayAggregate|))
   (name :initform "FlexibleArray")
   (marker :initform 'domain)
   (abbreviation :initform 'FARRAY)
   (comment :initform (list
     "A FlexibleArray is the notion of an array intended to allow for growth"
     "at the end only.  Hence the following efficient operations"
     "append(x,a) meaning append item x at the end of the array a"
     "delete(a,n) meaning delete the last item from the array a"
     "Flexible arrays support the other operations inherited from"
     "ExtensibleLinearAggregate. However, these are not efficient."
     "Flexible arrays combine the O(1) access time property of arrays"
     "with growing and shrinking at the end in O(1) (average) time."
     "This is done by using an ordinary array which may have zero or more"
     "empty slots at the end.  When the array becomes full it is copied"
     "into a new larger (50% larger) array.  Conversely, when the array"
     "becomes less than 1/2 full, it is copied into a smaller array."
     "Flexible arrays provide for an efficient implementation of many"
     "data structures in particular heaps, stacks and sets."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FlexibleArray|
  (progn
    (push '|FlexibleArray| *Domains*)
    (make-instance '|FlexibleArrayType|)))

\end{chunk}

\subsection{Float}
\index[dom]{Float!Domain}
\index[dom]{Domain!Float}
\index[dom]{FLOAT}
\begin{chunk}{defclass FloatType}
(defclass |FloatType| (|TranscendentalFunctionCategoryType|
                       |OpenMathType|
                       |FloatingPointSystemType|
                       |DifferentialRingType|)
  ((parents :initform '(|TranscendentalFunctionCategory|
                        |OpenMath|
                        |FloatingPointSystem|
                        |DifferentialRing|))
   (name :initform "Float")
   (marker :initform 'domain)
   (abbreviation :initform 'FLOAT)
   (comment :initform (list
     "Float implements arbitrary precision floating point arithmetic."
     "The number of significant digits of each operation can be set"
     "to an arbitrary value (the default is 20 decimal digits)."
     "The operation float(mantissa,exponent,base) for integer"
     "mantissa, exponent specifies the number"
     "mantissa * base ** exponent"
     "The underlying representation for floats is binary"
     "not decimal. The implications of this are described below."
     " "
     "The model adopted is that arithmetic operations are rounded to"
     "to nearest unit in the last place, that is, accurate to within"
     "2**(-bits). Also, the elementary functions and constants are"
     "accurate to one unit in the last place."
     "A float is represented as a record of two integers, the mantissa"
     "and the exponent.  The base of the representation is binary, hence"
     "a Record(m:mantissa,e:exponent) represents the number"
     "m * 2 ** e."
     "Though it is not assumed that the underlying integers are represented"
     "with a binary base, the code will be most efficient when this is the"
     "the case (this is true in most implementations of Lisp)."
     "The decision to choose the base to be binary has some unfortunate"
     "consequences.  First, decimal numbers like 0.3 cannot be represented"
     "exactly.  Second, there is a further loss of accuracy during"
     "conversion to decimal for output.  To compensate for this, if d digits"
     "of precision are specified, 1 + ceiling(log2(10^d)) bits are used."
     "Two numbers that are displayed identically may therefore be"
     "not equal.  On the other hand, a significant efficiency loss would"
     "be incurred if we chose to use a decimal base when the underlying"
     "integer base is binary."
     " "
     "Algorithms used:"
     "For the elementary functions, the general approach is to apply"
     "identities so that the taylor series can be used, and, so"
     "that it will converge within O( sqrt n ) steps.  For example,"
     "using the identity exp(x) = exp(x/2)**2, we can compute"
     "exp(1/3) to n digits of precision as follows.  We have"
     "exp(1/3) = exp(2 ** (-sqrt s) / 3) ** (2 ** sqrt s)."
     "The taylor series will converge in less than sqrt n steps and the"
     "exponentiation requires sqrt n multiplications for a total of"
     "2 sqrt n multiplications.  Assuming integer multiplication costs"
     "O( n**2 ) the overall running time is O( sqrt(n) n**2 )."
     "This approach is the best known approach for precisions up to"
     "about 10,000 digits at which point the methods of Brent"
     "which are O( log(n) n**2 ) become competitive.  Note also that"
     "summing the terms of the taylor series for the elementary"
     "functions is done using integer operations.  This avoids the"
     "overhead of floating point operations and results in efficient"
     "code at low precisions.  This implementation makes no attempt"
     "to reuse storage, relying on the underlying system to do"
     "garbage collection. I estimate that the efficiency of this"
     "package at low precisions could be improved by a factor of 2"
     "if in-place operations were available."
     " "
     "Running times: in the following, n is the number of bits of precision"
     "*, /, sqrt, pi, exp1, log2, log10:  O( n**2 )"
     "exp, log, sin, atan: O(sqrt(n) n**2)"
     "The other elementary functions are coded in terms of the ones above."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Float|
  (progn
    (push '|Float| *Domains*)
    (make-instance '|FloatType|)))

\end{chunk}

\subsection{FortranCode}
\index[dom]{FortranCode!Domain}
\index[dom]{Domain!FortranCode}
\index[dom]{FC}
\begin{chunk}{defclass FortranCodeType}
(defclass |FortranCodeType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "FortranCode")
   (marker :initform 'domain)
   (abbreviation :initform 'FC)
   (comment :initform (list
     "This domain builds representations of program code segments for use with"
     "the FortranProgram domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranCode|
  (progn
    (push '|FortranCode| *Domains*)
    (make-instance '|FortranCodeType|)))

\end{chunk}

\subsection{FortranExpression}
\index[dom]{FortranExpression!Domain}
\index[dom]{Domain!FortranExpression}
\index[dom]{FEXPR}
\begin{chunk}{defclass FortranExpressionType}
(defclass |FortranExpressionType| (|AlgebraType|
                                   |ExpressionSpaceType|
                                   |PartialDifferentialRingType|)
  ((parents :initform '(|Algebra|
                        |ExpressionSpace|
                        |PartialDifferentialRing|))
   (name :initform "FortranExpression")
   (marker :initform 'domain)
   (abbreviation :initform 'FEXPR)
   (comment :initform (list
     "A domain of expressions involving functions which can be"
     "translated into standard Fortran-77, with some extra extensions from"
     "the NAG Fortran Library."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranExpression|
  (progn
    (push '|FortranExpression| *Domains*)
    (make-instance '|FortranExpressionType|)))

\end{chunk}

\subsection{FortranProgram}
\index[dom]{FortranProgram!Domain}
\index[dom]{Domain!FortranProgram}
\index[dom]{FORTRAN}
\begin{chunk}{defclass FortranProgramType}
(defclass |FortranProgramType| (|FortranProgramCategoryType|)
  ((parents :initform '(|FortranProgramCategory|))
   (name :initform "FortranProgram")
   (marker :initform 'domain)
   (abbreviation :initform 'FORTRAN)
   (comment :initform (list
     "FortranProgram allows the user to build and manipulate simple"
     "models of FORTRAN subprograms.  These can then be transformed into"
     "actual FORTRAN notation."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranProgram|
  (progn
    (push '|FortranProgram| *Domains*)
    (make-instance '|FortranProgramType|)))

\end{chunk}

\subsection{FortranScalarType}
\index[dom]{FortranScalarType!Domain}
\index[dom]{Domain!FortranScalarType}
\index[dom]{FST}
\begin{chunk}{defclass FortranScalarTypeType}
(defclass |FortranScalarTypeType| (|CoercibleToType|)
  ((parents :initform '(|CoercibleTo|))
   (name :initform "FortranScalarType")
   (marker :initform 'domain)
   (abbreviation :initform 'FST)
   (comment :initform (list
     "Creates and manipulates objects which correspond to the"
     "basic FORTRAN data types: REAL, INTEGER, COMPLEX, LOGICAL and CHARACTER"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranScalarType|
  (progn
    (push '|FortranScalarType| *Domains*)
    (make-instance '|FortranScalarTypeType|)))

\end{chunk}

\subsection{FortranTemplate}
\index[dom]{FortranTemplate!Domain}
\index[dom]{Domain!FortranTemplate}
\index[dom]{FTEM}
\begin{chunk}{defclass FortranTemplateType}
(defclass |FortranTemplateType| (|FileCategoryType|)
  ((parents :initform '(|FileCategory|))
   (name :initform "FortranTemplate")
   (marker :initform 'domain)
   (abbreviation :initform 'FTEM)
   (comment :initform (list
     "Code to manipulate Fortran templates"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranTemplate|
  (progn
    (push '|FortranTemplate| *Domains*)
    (make-instance '|FortranTemplateType|)))

\end{chunk}

\subsection{FortranType}
\index[dom]{FortranType!Domain}
\index[dom]{Domain!FortranType}
\index[dom]{FT}
\begin{chunk}{defclass FortranTypeType}
(defclass |FortranTypeType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "FortranType")
   (marker :initform 'domain)
   (abbreviation :initform 'FT)
   (comment :initform (list
     "Creates and manipulates objects which correspond to FORTRAN"
     "data types, including array dimensions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranType|
  (progn
    (push '|FortranType| *Domains*)
    (make-instance '|FortranTypeType|)))

\end{chunk}

\subsection{FourierComponent}
\index[dom]{FourierComponent!Domain}
\index[dom]{Domain!FourierComponent}
\index[dom]{FCOMP}
\begin{chunk}{defclass FourierComponentType}
(defclass |FourierComponentType| (|OrderedSetType|)
  ((parents :initform '(|OrderedSet|))
   (name :initform "FourierComponent")
   (marker :initform 'domain)
   (abbreviation :initform 'FCOMP)
   (comment :initform (list
     "This domain creates kernels for use in Fourier series"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FourierComponent|
  (progn
    (push '|FourierComponent| *Domains*)
    (make-instance '|FourierComponentType|)))

\end{chunk}

\subsection{FourierSeries}
\index[dom]{FourierSeries!Domain}
\index[dom]{Domain!FourierSeries}
\index[dom]{FSERIES}
\begin{chunk}{defclass FourierSeriesType}
(defclass |FourierSeriesType| (|AlgebraType|)
  ((parents :initform '(|Algebra|))
   (name :initform "FourierSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'FSERIES)
   (comment :initform (list
     "This domain converts terms into Fourier series"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FourierSeries|
  (progn
    (push '|FourierSeries| *Domains*)
    (make-instance '|FourierSeriesType|)))

\end{chunk}

\subsection{Fraction}
\index[dom]{Fraction!Domain}
\index[dom]{Domain!Fraction}
\index[dom]{FRAC}
\begin{chunk}{defclass FractionType}
(defclass |FractionType| (|QuotientFieldCategoryType| |OpenMathType|)
  ((parents :initform '(|QuotientFieldCategory| |OpenMath|))
   (name :initform "Fraction")
   (marker :initform 'domain)
   (abbreviation :initform 'FRAC)
   (comment :initform (list
     "Fraction takes an IntegralDomain S and produces"
     "the domain of Fractions with numerators and denominators from S."
     "If S is also a GcdDomain, then gcd's between numerator and"
     "denominator will be cancelled during all operations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Fraction|
  (progn
    (push '|Fraction| *Domains*)
    (make-instance '|FractionType|)))

\end{chunk}

\subsection{FractionalIdeal}
\index[dom]{FractionalIdeal!Domain}
\index[dom]{Domain!FractionalIdeal}
\index[dom]{FRIDEAL}
\begin{chunk}{defclass FractionalIdealType}
(defclass |FractionalIdealType| (|GroupType|)
  ((parents :initform '(|Group|))
   (name :initform "FractionalIdeal")
   (marker :initform 'domain)
   (abbreviation :initform 'FRIDEAL)
   (comment :initform (list
     "Fractional ideals in a framed algebra."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FractionalIdeal|
  (progn
    (push '|FractionalIdeal| *Domains*)
    (make-instance '|FractionalIdealType|)))

\end{chunk}

\subsection{FramedModule}
\index[dom]{FramedModule!Domain}
\index[dom]{Domain!FramedModule}
\index[dom]{FRMOD}
\begin{chunk}{defclass FramedModuleType}
(defclass |FramedModuleType| (|MonoidType|)
  ((parents :initform '(|Monoid|))
   (name :initform "FramedModule")
   (marker :initform 'domain)
   (abbreviation :initform 'FRMOD)
   (comment :initform (list
     "Module representation of fractional ideals."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FramedModule|
  (progn
    (push '|FramedModule| *Domains*)
    (make-instance '|FramedModuleType|)))

\end{chunk}

\subsection{FreeAbelianGroup}
\index[dom]{FreeAbelianGroup!Domain}
\index[dom]{Domain!FreeAbelianGroup}
\index[dom]{FAGROUP}
\begin{chunk}{defclass FreeAbelianGroupType}
(defclass |FreeAbelianGroupType| (|OrderedSetType|
                                  |ModuleType|
                                  |FreeAbelianMonoidCategoryType|)
  ((parents :initform '(|OrderedSet| |Module| |FreeAbelianMonoidCategory|))
   (name :initform "FreeAbelianGroup")
   (marker :initform 'domain)
   (abbreviation :initform 'FAGROUP)
   (comment :initform (list
     "Free abelian group on any set of generators"
     "The free abelian group on a set S is the monoid of finite sums of"
     "the form reduce(+,[ni * si]) where the si's are in S, and the ni's"
     "are integers. The operation is commutative."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FreeAbelianGroup|
  (progn
    (push '|FreeAbelianGroup| *Domains*)
    (make-instance '|FreeAbelianGroupType|)))

\end{chunk}

\subsection{FreeAbelianMonoid}
\index[dom]{FreeAbelianMonoid!Domain}
\index[dom]{Domain!FreeAbelianMonoid}
\index[dom]{FAMONOID}
\begin{chunk}{defclass FreeAbelianMonoidType}
(defclass |FreeAbelianMonoidType| (|FreeAbelianMonoidCategoryType|)
  ((parents :initform '(|FreeAbelianMonoidCategory|))
   (name :initform "FreeAbelianMonoid")
   (marker :initform 'domain)
   (abbreviation :initform 'FAMONOID)
   (comment :initform (list
     "Free abelian monoid on any set of generators"
     "The free abelian monoid on a set S is the monoid of finite sums of"
     "the form reduce(+,[ni * si]) where the si's are in S, and the ni's"
     "are non-negative integers. The operation is commutative."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FreeAbelianMonoid|
  (progn
    (push '|FreeAbelianMonoid| *Domains*)
    (make-instance '|FreeAbelianMonoidType|)))

\end{chunk}

\subsection{FreeGroup}
\index[dom]{FreeGroup!Domain}
\index[dom]{Domain!FreeGroup}
\index[dom]{FGROUP}
\begin{chunk}{defclass FreeGroupType}
(defclass |FreeGroupType| (|GroupType| |RetractableToType|)
  ((parents :initform '(|Group| |RetractableTo|))
   (name :initform "FreeGroup")
   (marker :initform 'domain)
   (abbreviation :initform 'FGROUP)
   (comment :initform (list
     "Free group on any set of generators"
     "The free group on a set S is the group of finite products of"
     "the form reduce(*,[si ** ni]) where the si's are in S, and the ni's"
     "are integers. The multiplication is not commutative."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FreeGroup|
  (progn
    (push '|FreeGroup| *Domains*)
    (make-instance '|FreeGroupType|)))

\end{chunk}

\subsection{FreeModule}
\index[dom]{FreeModule!Domain}
\index[dom]{Domain!FreeModule}
\index[dom]{FM}
\begin{chunk}{defclass FreeModuleType}
(defclass |FreeModuleType| (|IndexedDirectProductCategoryType|
                            |ModuleType|)
  ((parents :initform '(|IndexedDirectProductCategory| |Module|))
   (name :initform "FreeModule")
   (marker :initform 'domain)
   (abbreviation :initform 'FM)
   (comment :initform (list
     "A bi-module is a free module"
     "over a ring with generators indexed by an ordered set."
     "Each element can be expressed as a finite linear combination of"
     "generators. Only non-zero terms are stored."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FreeModule|
  (progn
    (push '|FreeModule| *Domains*)
    (make-instance '|FreeModuleType|)))

\end{chunk}

\subsection{FreeModule1}
\index[dom]{FreeModule1!Domain}
\index[dom]{Domain!FreeModule1}
\index[dom]{FM1}
\begin{chunk}{defclass FreeModule1Type}
(defclass |FreeModule1Type| (|FreeModuleCatType|)
  ((parents :initform '(|FreeModuleCat|))
   (name :initform "FreeModule1")
   (marker :initform 'domain)
   (abbreviation :initform 'FM1)
   (comment :initform (list
     "This domain implements linear combinations"
     "of elements from the domain S with coefficients"
     "in the domain R where S is an ordered set"
     "and R is a ring (which may be non-commutative)."
     "This domain is used by domains of non-commutative algebra such as:"
     "XDistributedPolynomial, XRecursivePolynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FreeModule1|
  (progn
    (push '|FreeModule1| *Domains*)
    (make-instance '|FreeModule1Type|)))

\end{chunk}

\subsection{FreeMonoid}
\index[dom]{FreeMonoid!Domain}
\index[dom]{Domain!FreeMonoid}
\index[dom]{FMONOID}
\begin{chunk}{defclass FreeMonoidType}
(defclass |FreeMonoidType| (|MonoidType| |OrderedSetType| |RetractableToType|)
  ((parents :initform '(|Monoid| |OrderedSet| |RetractableTo|))
   (name :initform "FreeMonoid")
   (marker :initform 'domain)
   (abbreviation :initform 'FMONOID)
   (comment :initform (list
     "Free monoid on any set of generators"
     "The free monoid on a set S is the monoid of finite products of"
     "the form reduce(*,[si ** ni]) where the si's are in S, and the ni's"
     "are nonnegative integers. The multiplication is not commutative."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FreeMonoid|
  (progn
    (push '|FreeMonoid| *Domains*)
    (make-instance '|FreeMonoidType|)))

\end{chunk}

\subsection{FreeNilpotentLie}
\index[dom]{FreeNilpotentLie!Domain}
\index[dom]{Domain!FreeNilpotentLie}
\index[dom]{FNLA}
\begin{chunk}{defclass FreeNilpotentLieType}
(defclass |FreeNilpotentLieType| (|NonAssociativeAlgebraType|)
  ((parents :initform '(|NonAssociativeAlgebra|))
   (name :initform "FreeNilpotentLie")
   (marker :initform 'domain)
   (abbreviation :initform 'FNLA)
   (comment :initform (list
     "Generate the Free Lie Algebra over a ring R with identity;"
     "A P. Hall basis is generated by a package call to HallBasis."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FreeNilpotentLie|
  (progn
    (push '|FreeNilpotentLie| *Domains*)
    (make-instance '|FreeNilpotentLieType|)))

\end{chunk}

\subsection{FullPartialFractionExpansion}
\index[dom]{FullPartialFractionExpansion!Domain}
\index[dom]{Domain!FullPartialFractionExpansion}
\index[dom]{FPARFRAC}
\begin{chunk}{defclass FullPartialFractionExpansionType}
(defclass |FullPartialFractionExpansionType| (|SetCategoryType| |ConvertibleToType|)
  ((parents :initform '(|SetCategory| |ConvertibleTo|))
   (name :initform "FullPartialFractionExpansion")
   (marker :initform 'domain)
   (abbreviation :initform 'FPARFRAC)
   (comment :initform (list
     "Full partial fraction expansion of rational functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FullPartialFractionExpansion|
  (progn
    (push '|FullPartialFractionExpansion| *Domains*)
    (make-instance '|FullPartialFractionExpansionType|)))

\end{chunk}

\subsection{FunctionCalled}
\index[dom]{FunctionCalled!Domain}
\index[dom]{Domain!FunctionCalled}
\index[dom]{FUNCTION}
\begin{chunk}{defclass FunctionCalledType}
(defclass |FunctionCalledType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "FunctionCalled")
   (marker :initform 'domain)
   (abbreviation :initform 'FUNCTION)
   (comment :initform (list
     "This domain implements named functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionCalled|
  (progn
    (push '|FunctionCalled| *Domains*)
    (make-instance '|FunctionCalledType|)))

\end{chunk}

\section{G}

\subsection{GeneralDistributedMultivariatePolynomial}
\index[dom]{GeneralDistributedMultivariatePolynomial!Domain}
\index[dom]{Domain!GeneralDistributedMultivariatePolynomial}
\index[dom]{GDMP}
\begin{chunk}{defclass GeneralDistributedMultivariatePolynomialType}
(defclass |GeneralDistributedMultivariatePolynomialType| (|PolynomialCategoryType|)
  ((parents :initform '(|PolynomialCategory|))
   (name :initform "GeneralDistributedMultivariatePolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'GDMP)
   (comment :initform (list
     "This type supports distributed multivariate polynomials"
     "whose variables are from a user specified list of symbols."
     "The coefficient ring may be non commutative,"
     "but the variables are assumed to commute."
     "The term ordering is specified by its third parameter."
     "Suggested types which define term orderings include:"
     "DirectProduct, HomogeneousDirectProduct,"
     "SplitHomogeneousDirectProduct and finally"
     "OrderedDirectProduct which accepts an arbitrary user"
     "function to define a term ordering."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GeneralDistributedMultivariatePolynomial|
  (progn
    (push '|GeneralDistributedMultivariatePolynomial| *Domains*)
    (make-instance '|GeneralDistributedMultivariatePolynomialType|)))

\end{chunk}

\subsection{GeneralModulePolynomial}
\index[dom]{GeneralModulePolynomial!Domain}
\index[dom]{Domain!GeneralModulePolynomial}
\index[dom]{GMODPOL}
\begin{chunk}{defclass GeneralModulePolynomialType}
(defclass |GeneralModulePolynomialType| (|ModuleType|)
  ((parents :initform '(|Module|))
   (name :initform "GeneralModulePolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'GMODPOL)
   (comment :initform (list
     "This package is undocumented"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GeneralModulePolynomial|
  (progn
    (push '|GeneralModulePolynomial| *Domains*)
    (make-instance '|GeneralModulePolynomialType|)))

\end{chunk}

\subsection{GenericNonAssociativeAlgebra}
\index[dom]{GenericNonAssociativeAlgebra!Domain}
\index[dom]{Domain!GenericNonAssociativeAlgebra}
\index[dom]{GCNAALG}
\begin{chunk}{defclass GenericNonAssociativeAlgebraType}
(defclass |GenericNonAssociativeAlgebraType| (|FramedNonAssociativeAlgebraType|)
  ((parents :initform '(|FramedNonAssociativeAlgebra|))
   (name :initform "GenericNonAssociativeAlgebra")
   (marker :initform 'domain)
   (abbreviation :initform 'GCNAALG)
   (comment :initform (list
     "AlgebraGenericElementPackage allows you to create generic elements"
     "of an algebra, the scalars are extended to include symbolic"
     "coefficients"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GenericNonAssociativeAlgebra|
  (progn
    (push '|GenericNonAssociativeAlgebra| *Domains*)
    (make-instance '|GenericNonAssociativeAlgebraType|)))

\end{chunk}

\subsection{GeneralPolynomialSet}
\index[dom]{GeneralPolynomialSet!Domain}
\index[dom]{Domain!GeneralPolynomialSet}
\index[dom]{GPOLSET}
\begin{chunk}{defclass GeneralPolynomialSetType}
(defclass |GeneralPolynomialSetType| (|PolynomialSetCategoryType|)
  ((parents :initform '(|PolynomialSetCategory|))
   (name :initform "GeneralPolynomialSet")
   (marker :initform 'domain)
   (abbreviation :initform 'GPOLSET)
   (comment :initform (list
     "A domain for polynomial sets."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GeneralPolynomialSet|
  (progn
    (push '|GeneralPolynomialSet| *Domains*)
    (make-instance '|GeneralPolynomialSetType|)))

\end{chunk}

\subsection{GeneralSparseTable}
\index[dom]{GeneralSparseTable!Domain}
\index[dom]{Domain!GeneralSparseTable}
\index[dom]{GSTBL}
\begin{chunk}{defclass GeneralSparseTableType}
(defclass |GeneralSparseTableType| (|TableAggregateType|)
  ((parents :initform '(|TableAggregate|))
   (name :initform "GeneralSparseTable")
   (marker :initform 'domain)
   (abbreviation :initform 'GSTBL)
   (comment :initform (list
     "A sparse table has a default entry, which is returned if no other"
     "value has been explicitly stored for a key."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GeneralSparseTable|
  (progn
    (push '|GeneralSparseTable| *Domains*)
    (make-instance '|GeneralSparseTableType|)))

\end{chunk}

\subsection{GeneralTriangularSet}
\index[dom]{GeneralTriangularSet!Domain}
\index[dom]{Domain!GeneralTriangularSet}
\index[dom]{GTSET}
\begin{chunk}{defclass GeneralTriangularSetType}
(defclass |GeneralTriangularSetType| (|TriangularSetCategoryType|)
  ((parents :initform '(|TriangularSetCategory|))
   (name :initform "GeneralTriangularSet")
   (marker :initform 'domain)
   (abbreviation :initform 'GTSET)
   (comment :initform (list
     "A domain constructor of the category TriangularSetCategory."
     "The only requirement for a list of polynomials to be a member of such"
     "a domain is the following: no polynomial is constant and two distinct"
     "polynomials have distinct main variables. Such a triangular set may"
     "not be auto-reduced or consistent. Triangular sets are stored"
     "as sorted lists w.r.t. the main variables of their members but they"
     "are displayed in reverse order."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GeneralTriangularSet|
  (progn
    (push '|GeneralTriangularSet| *Domains*)
    (make-instance '|GeneralTriangularSetType|)))

\end{chunk}

\subsection{GeneralUnivariatePowerSeries}
\index[dom]{GeneralUnivariatePowerSeries!Domain}
\index[dom]{Domain!GeneralUnivariatePowerSeries}
\index[dom]{GSERIES}
\begin{chunk}{defclass GeneralUnivariatePowerSeriesType}
(defclass |GeneralUnivariatePowerSeriesType| (|UnivariatePuiseuxSeriesCategoryType|)
  ((parents :initform '(|UnivariatePuiseuxSeriesCategory|))
   (name :initform "GeneralUnivariatePowerSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'GSERIES)
   (comment :initform (list
     "This is a category of univariate Puiseux series constructed"
     "from univariate Laurent series.  A Puiseux series is represented"
     "by a pair [r,f(x)], where r is a positive rational number and"
     "f(x) is a Laurent series.  This pair represents the Puiseux"
     "series f(x\^r)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GeneralUnivariatePowerSeries|
  (progn
    (push '|GeneralUnivariatePowerSeries| *Domains*)
    (make-instance '|GeneralUnivariatePowerSeriesType|)))

\end{chunk}

\subsection{GraphImage}
\index[dom]{GraphImage!Domain}
\index[dom]{Domain!GraphImage}
\index[dom]{GRIMAGE}
\begin{chunk}{defclass GraphImageType}
(defclass |GraphImageType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "GraphImage")
   (marker :initform 'domain)
   (abbreviation :initform 'GRIMAGE)
   (comment :initform (list
     "TwoDimensionalGraph creates virtual two dimensional graphs"
     "(to be displayed on TwoDimensionalViewports)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GraphImage|
  (progn
    (push '|GraphImage| *Domains*)
    (make-instance '|GraphImageType|)))

\end{chunk}

\subsection{GuessOption}
\index[dom]{GuessOption!Domain}
\index[dom]{Domain!GuessOption}
\index[dom]{GOPT}
\begin{chunk}{defclass GuessOptionType}
(defclass |GuessOptionType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "GuessOption")
   (marker :initform 'domain)
   (abbreviation :initform 'GOPT)
   (comment :initform (list
     "GuessOption is a domain whose elements are various options used"
     "by Guess."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GuessOption|
  (progn
    (push '|GuessOption| *Domains*)
    (make-instance '|GuessOptionType|)))

\end{chunk}

\subsection{GuessOptionFunctions0}
\index[dom]{GuessOptionFunctions0!Domain}
\index[dom]{Domain!GuessOptionFunctions0}
\index[dom]{GOPT0}
\begin{chunk}{defclass GuessOptionFunctions0Type}
(defclass |GuessOptionFunctions0Type| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "GuessOptionFunctions0")
   (marker :initform 'domain)
   (abbreviation :initform 'GOPT0)
   (comment :initform (list
     "GuessOptionFunctions0 provides operations that extract the"
     "values of options for Guess."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GuessOptionFunctions0|
  (progn
    (push '|GuessOptionFunctions0| *Domains*)
    (make-instance '|GuessOptionFunctions0Type|)))

\end{chunk}

\section{H}

\subsection{HashTable}
\index[dom]{HashTable!Domain}
\index[dom]{Domain!HashTable}
\index[dom]{HASHTBL}
\begin{chunk}{defclass HashTableType}
(defclass |HashTableType| (|TableAggregateType|)
  ((parents :initform '(|TableAggregate|))
   (name :initform "HashTable")
   (marker :initform 'domain)
   (abbreviation :initform 'HASHTBL)
   (comment :initform (list
     "This domain provides access to the underlying Lisp hash tables."
     "By varying the hashfn parameter, tables suited for different"
     "purposes can be obtained."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |HashTable|
   (progn
     (push '|HashTable| *Domains*)
     (make-instance '|HashTableType|)))

\end{chunk}

\subsection{Heap}
\index[dom]{Heap!Domain}
\index[dom]{Domain!Heap}
\index[dom]{HEAP}
\begin{chunk}{defclass HeapType}
(defclass |HeapType| (|PriorityQueueAggregateType|)
  ((parents :initform '(|PriorityQueueAggregate|))
   (name :initform "Heap")
   (marker :initform 'domain)
   (abbreviation :initform 'HEAP)
   (comment :initform (list
     "Heap implemented in a flexible array to allow for insertions"
     "Complexity: O(log n) insertion, extraction and O(n) construction"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Heap|
  (progn
    (push '|Heap| *Domains*)
    (make-instance '|HeapType|)))

\end{chunk}

\subsection{HexadecimalExpansion}
\index[dom]{HexadecimalExpansion!Domain}
\index[dom]{Domain!HexadecimalExpansion}
\index[dom]{HEXADEC}
\begin{chunk}{defclass HexadecimalExpansionType}
(defclass |HexadecimalExpansionType| (|QuotientFieldCategoryType|)
  ((parents :initform '(|QuotientFieldCategory|))
   (name :initform "HexadecimalExpansion")
   (marker :initform 'domain)
   (abbreviation :initform 'HEXADEC)
   (comment :initform (list
     "This domain allows rational numbers to be presented as repeating"
     "hexadecimal expansions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |HexadecimalExpansion|
  (progn
    (push '|HexadecimalExpansion| *Domains*)
    (make-instance '|HexadecimalExpansionType|)))

\end{chunk}

\subsection{HTMLFormat}
\index[dom]{HTMLFormat!Domain}
\index[dom]{Domain!HTMLFormat}
\index[dom]{HTMLFORM}
\begin{chunk}{defclass HTMLFormatType}
(defclass |HTMLFormatType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "HTMLFormat")
   (marker :initform 'domain)
   (abbreviation :initform 'HTMLFORM)
   (comment :initform (list
     "HtmlFormat provides a coercion from OutputForm to html."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |HTMLFormat|
  (progn
    (push '|HTMLFormat| *Domains*)
    (make-instance '|HTMLFormatType|)))

\end{chunk}

\subsection{HomogeneousDirectProduct}
\index[dom]{HomogeneousDirectProduct!Domain}
\index[dom]{Domain!HomogeneousDirectProduct}
\index[dom]{HDP}
\begin{chunk}{defclass HomogeneousDirectProductType}
(defclass |HomogeneousDirectProductType| (|DirectProductCategoryType|)
  ((parents :initform '(|DirectProductCategory|))
   (name :initform "HomogeneousDirectProduct")
   (marker :initform 'domain)
   (abbreviation :initform 'HDP)
   (comment :initform (list
     "This type represents the finite direct or cartesian product of an"
     "underlying ordered component type. The vectors are ordered first"
     "by the sum of their components, and then refined using a reverse"
     "lexicographic ordering. This type is a suitable third argument for"
     "GeneralDistributedMultivariatePolynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |HomogeneousDirectProduct|
  (progn
    (push '|HomogeneousDirectProduct| *Domains*)
    (make-instance '|HomogeneousDirectProductType|)))

\end{chunk}

\subsection{HomogeneousDistributedMultivariatePolynomial}
\index[dom]{HomogeneousDistributedMultivariatePolynomial!Domain}
\index[dom]{Domain!HomogeneousDistributedMultivariatePolynomial}
\index[dom]{HDMP}
\begin{chunk}{defclass HomogeneousDistributedMultivariatePolynomialType}
(defclass |HomogeneousDistributedMultivariatePolynomialType| (|PolynomialCategoryType|)
  ((parents :initform '(|PolynomialCategory|))
   (name :initform "HomogeneousDistributedMultivariatePolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'HDMP)
   (comment :initform (list
     "This type supports distributed multivariate polynomials"
     "whose variables are from a user specified list of symbols."
     "The coefficient ring may be non commutative,"
     "but the variables are assumed to commute."
     "The term ordering is total degree ordering refined by reverse"
     "lexicographic ordering with respect to the position that the variables"
     "appear in the list of variables parameter."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |HomogeneousDistributedMultivariatePolynomial|
  (progn
    (push '|HomogeneousDistributedMultivariatePolynomial| *Domains*)
    (make-instance '|HomogeneousDistributedMultivariatePolynomialType|)))

\end{chunk}

\subsection{HyperellipticFiniteDivisor}
\index[dom]{HyperellipticFiniteDivisor!Domain}
\index[dom]{Domain!HyperellipticFiniteDivisor}
\index[dom]{HELLFDIV}
\begin{chunk}{defclass HyperellipticFiniteDivisorType}
(defclass |HyperellipticFiniteDivisorType| (|FiniteDivisorCategoryType|)
  ((parents :initform '(|FiniteDivisorCategory|))
   (name :initform "HyperellipticFiniteDivisor")
   (marker :initform 'domain)
   (abbreviation :initform 'HELLFDIV)
   (comment :initform (list
     "This domains implements finite rational divisors on an hyperelliptic curve,"
     "that is finite formal sums SUM(n * P) where the n's are integers and the"
     "P's are finite rational points on the curve."
     "The equation of the curve must be  y^2 = f(x) and f must have odd degree."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |HyperellipticFiniteDivisor|
  (progn
    (push '|HyperellipticFiniteDivisor| *Domains*)
    (make-instance '|HyperellipticFiniteDivisorType|)))

\end{chunk}

\section{I}

\subsection{InfClsPt}
\index[dom]{InfClsPt!Domain}
\index[dom]{Domain!InfClsPt}
\index[dom]{ICP}
\begin{chunk}{defclass InfClsPtType}
(defclass |InfClsPtType| (|InfinitlyClosePointCategoryType|)
  ((parents :initform '(|InfinitlyClosePointCategory|))
   (name :initform "InfClsPt")
   (marker :initform 'domain)
   (abbreviation :initform 'ICP)
   (comment :initform (list
     "This domain is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InfClsPt|
  (progn
    (push '|InfClsPt| *Domains*)
    (make-instance '|InfClsPtType|)))

\end{chunk}

\subsection{IndexCard}
\index[dom]{IndexCard!Domain}
\index[dom]{Domain!IndexCard}
\index[dom]{ICARD}
\begin{chunk}{defclass IndexCardType}
(defclass |IndexCardType| (|OrderedSetType|)
  ((parents :initform '(|OrderedSet|))
   (name :initform "IndexCard")
   (marker :initform 'domain)
   (abbreviation :initform 'ICARD)
   (comment :initform (list
     "This domain implements a container of information about the AXIOM library"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexCard|
  (progn
    (push '|IndexCard| *Domains*)
    (make-instance '|IndexCardType|)))

\end{chunk}

\subsection{IndexedBits}
\index[dom]{IndexedBits!Domain}
\index[dom]{Domain!IndexedBits}
\index[dom]{IBITS}
\begin{chunk}{defclass IndexedBitsType}
(defclass |IndexedBitsType| (|BitAggregateType|)
  ((parents :initform '(|BitAggregate|))
   (name :initform "IndexedBits")
   (marker :initform 'domain)
   (abbreviation :initform 'IBITS)
   (comment :initform (list
     "IndexedBits is a domain to compactly represent"
     "large quantities of Boolean data."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedBits|
  (progn
    (push '|IndexedBits| *Domains*)
    (make-instance '|IndexedBitsType|)))

\end{chunk}

\subsection{IndexedDirectProductAbelianGroup}
\index[dom]{IndexedDirectProductAbelianGroup!Domain}
\index[dom]{Domain!IndexedDirectProductAbelianGroup}
\index[dom]{IDPAG}
\begin{chunk}{defclass IndexedDirectProductAbelianGroupType}
(defclass |IndexedDirectProductAbelianGroupType| (|AbelianGroupType|
                                                  |IndexedDirectProductCategoryType|)
  ((parents :initform '(|AbelianGroup|
                        |IndexedDirectProductCategory|))
   (name :initform "IndexedDirectProductAbelianGroup")
   (marker :initform 'domain)
   (abbreviation :initform 'IDPAG)
   (comment :initform (list
     "Indexed direct products of abelian groups over an abelian group A of"
     "generators indexed by the ordered set S."
     "All items have finite support: only non-zero terms are stored."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedDirectProductAbelianGroup|
  (progn
    (push '|IndexedDirectProductAbelianGroup| *Domains*)
    (make-instance '|IndexedDirectProductAbelianGroupType|)))

\end{chunk}

\subsection{IndexedDirectProductAbelianMonoid}
\index[dom]{IndexedDirectProductAbelianMonoid!Domain}
\index[dom]{Domain!IndexedDirectProductAbelianMonoid}
\index[dom]{IDPAM}
\begin{chunk}{defclass IndexedDirectProductAbelianMonoidType}
(defclass |IndexedDirectProductAbelianMonoidType| (|AbelianMonoidType|
                                                   |IndexedDirectProductCategoryType|)
  ((parents :initform '(|AbelianMonoid|
                        |IndexedDirectProductCategory|))
   (name :initform "IndexedDirectProductAbelianMonoid")
   (marker :initform 'domain)
   (abbreviation :initform 'IDPAM)
   (comment :initform (list
     "Indexed direct products of abelian monoids over an abelian monoid"
     "A of generators indexed by the ordered set S. All items have"
     "finite support. Only non-zero terms are stored."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedDirectProductAbelianMonoid|
  (progn
    (push '|IndexedDirectProductAbelianMonoid| *Domains*)
    (make-instance '|IndexedDirectProductAbelianMonoidType|)))

\end{chunk}

\subsection{IndexedDirectProductObject}
\index[dom]{IndexedDirectProductObject!Domain}
\index[dom]{Domain!IndexedDirectProductObject}
\index[dom]{IDPO}
\begin{chunk}{defclass IndexedDirectProductObjectType}
(defclass |IndexedDirectProductObjectType| (|IndexedDirectProductCategoryType|)
  ((parents :initform '(|IndexedDirectProductCategory|))
   (name :initform "IndexedDirectProductObject")
   (marker :initform 'domain)
   (abbreviation :initform 'IDPO)
   (comment :initform (list
     "Indexed direct products of objects over a set A"
     "of generators indexed by an ordered set S. All items have finite support."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedDirectProductObject|
  (progn
    (push '|IndexedDirectProductObject| *Domains*)
    (make-instance '|IndexedDirectProductObjectType|)))

\end{chunk}

\subsection{IndexedDirectProductOrderedAbelianMonoid}
\index[dom]{IndexedDirectProductOrderedAbelianMonoid!Domain}
\index[dom]{Domain!IndexedDirectProductOrderedAbelianMonoid}
\index[dom]{IDPOAM}
\begin{chunk}{defclass IndexedDirectProductOrderedAbelianMonoidType}
(defclass |IndexedDirectProductOrderedAbelianMonoidType| (|OrderedAbelianMonoidType|
                                                          |IndexedDirectProductCategoryType|)
  ((parents :initform '(|OrderedAbelianMonoid|
                        |IndexedDirectProductCategory|))
   (name :initform "IndexedDirectProductOrderedAbelianMonoid")
   (marker :initform 'domain)
   (abbreviation :initform 'IDPOAM)
   (comment :initform (list
     "Indexed direct products of ordered abelian monoids A of"
     "generators indexed by the ordered set S."
     "The inherited order is lexicographical."
     "All items have finite support: only non-zero terms are stored."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedDirectProductOrderedAbelianMonoid|
  (progn
    (push '|IndexedDirectProductOrderedAbelianMonoid| *Domains*)
    (make-instance '|IndexedDirectProductOrderedAbelianMonoidType|)))

\end{chunk}

\subsection{IndexedDirectProductOrderedAbelianMonoidSup}
\index[dom]{IndexedDirectProductOrderedAbelianMonoidSup!Domain}
\index[dom]{Domain!IndexedDirectProductOrderedAbelianMonoidSup}
\index[dom]{IDPOAMS}
\begin{chunk}{defclass IndexedDirectProductOrderedAbelianMonoidSupType}
(defclass |IndexedDirectProductOrderedAbelianMonoidSupType| (|IndexedDirectProductCategoryType|
                                                             |OrderedAbelianMonoidSupType|)
  ((parents :initform '(|IndexedDirectProductCategory| |OrderedAbelianMonoidSup|))
   (name :initform "IndexedDirectProductOrderedAbelianMonoidSup")
   (marker :initform 'domain)
   (abbreviation :initform 'IDPOAMS)
   (comment :initform (list
     "Indexed direct products of ordered abelian monoid sups A,"
     "generators indexed by the ordered set S."
     "All items have finite support: only non-zero terms are stored."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedDirectProductOrderedAbelianMonoidSup|
  (progn
    (push '|IndexedDirectProductOrderedAbelianMonoidSup| *Domains*)
    (make-instance '|IndexedDirectProductOrderedAbelianMonoidSupType|)))

\end{chunk}

\subsection{IndexedExponents}
\index[dom]{IndexedExponents!Domain}
\index[dom]{Domain!IndexedExponents}
\index[dom]{INDE}
\begin{chunk}{defclass IndexedExponentsType}
(defclass |IndexedExponentsType| (|IndexedDirectProductCategoryType|
                                  |OrderedAbelianMonoidSupType|)
  ((parents :initform '(|IndexedDirectProductCategory| |OrderedAbelianMonoidSup|))
   (name :initform "IndexedExponents")
   (marker :initform 'domain)
   (abbreviation :initform 'INDE)
   (comment :initform (list
     "IndexedExponents of an ordered set of variables gives a representation"
     "for the degree of polynomials in commuting variables. It gives an ordered"
     "pairing of non negative integer exponents with variables"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedExponents|
  (progn
    (push '|IndexedExponents| *Domains*)
    (make-instance '|IndexedExponentsType|)))

\end{chunk}

\subsection{IndexedFlexibleArray}
\index[dom]{IndexedFlexibleArray!Domain}
\index[dom]{Domain!IndexedFlexibleArray}
\index[dom]{IFARRAY}
\begin{chunk}{defclass IndexedFlexibleArrayType}
(defclass |IndexedFlexibleArrayType| (|ExtensibleLinearAggregateType|
                                      |OneDimensionalArrayAggregateType|)
  ((parents :initform '(|ExtensibleLinearAggregate| |OneDimensionalArrayAggregate|))
   (name :initform "IndexedFlexibleArray")
   (marker :initform 'domain)
   (abbreviation :initform 'IFARRAY)
   (comment :initform (list
     "A FlexibleArray is the notion of an array intended to allow for growth"
     "at the end only.  Hence the following efficient operations"
     "append(x,a) meaning append item x at the end of the array a"
     "delete(a,n) meaning delete the last item from the array a"
     "Flexible arrays support the other operations inherited from"
     "ExtensibleLinearAggregate. However, these are not efficient."
     "Flexible arrays combine the O(1) access time property of arrays"
     "with growing and shrinking at the end in O(1) (average) time."
     "This is done by using an ordinary array which may have zero or more"
     "empty slots at the end.  When the array becomes full it is copied"
     "into a new larger (50% larger) array.  Conversely, when the array"
     "becomes less than 1/2 full, it is copied into a smaller array."
     "Flexible arrays provide for an efficient implementation of many"
     "data structures in particular heaps, stacks and sets."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedFlexibleArray|
  (progn
    (push '|IndexedFlexibleArray| *Domains*)
    (make-instance '|IndexedFlexibleArrayType|)))

\end{chunk}

\subsection{IndexedList}
\index[dom]{IndexedList!Domain}
\index[dom]{Domain!IndexedList}
\index[dom]{ILIST}
\begin{chunk}{defclass IndexedListType}
(defclass |IndexedListType| (|ListAggregateType|)
  ((parents :initform '(|ListAggregate|))
   (name :initform "IndexedList")
   (marker :initform 'domain)
   (abbreviation :initform 'ILIST)
   (comment :initform (list
     "IndexedList is a basic implementation of the functions"
     "in ListAggregate, often using functions in the underlying"
     "LISP system. The second parameter to the constructor (mn)"
     "is the beginning index of the list. That is, if l is a"
     "list, then elt(l,mn) is the first value. This constructor"
     "is probably best viewed as the implementation of singly-linked"
     "lists that are addressable by index rather than as a mere wrapper"
     "for LISP lists."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedList|
  (progn
    (push '|IndexedList| *Domains*)
    (make-instance '|IndexedListType|)))

\end{chunk}

\subsection{IndexedMatrix}
\index[dom]{IndexedMatrix!Domain}
\index[dom]{Domain!IndexedMatrix}
\index[dom]{IMATRIX}
\begin{chunk}{defclass IndexedMatrixType}
(defclass |IndexedMatrixType| (|MatrixCategoryType|)
  ((parents :initform '(|MatrixCategory|))
   (name :initform "IndexedMatrix")
   (marker :initform 'domain)
   (abbreviation :initform 'IMATRIX)
   (comment :initform (list
     "An IndexedMatrix is a matrix where the minimal row and column"
     "indices are parameters of the type.  The domains Row and Col"
     "are both IndexedVectors."
     "The index of the 'first' row may be obtained by calling the"
     "function minRowIndex.  The index of the 'first' column may"
     "be obtained by calling the function minColIndex.  The index of"
     "the first element of a 'Row' is the same as the index of the"
     "first column in a matrix and vice versa."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedMatrix|
  (progn
    (push '|IndexedMatrix| *Domains*)
    (make-instance '|IndexedMatrixType|)))

\end{chunk}

\subsection{IndexedOneDimensionalArray}
\index[dom]{IndexedOneDimensionalArray!Domain}
\index[dom]{Domain!IndexedOneDimensionalArray}
\index[dom]{IARRAY1}
\begin{chunk}{defclass IndexedOneDimensionalArrayType}
(defclass |IndexedOneDimensionalArrayType| (|OneDimensionalArrayAggregateType|)
  ((parents :initform '(|OneDimensionalArrayAggregate|))
   (name :initform "IndexedOneDimensionalArray")
   (marker :initform 'domain)
   (abbreviation :initform 'IARRAY1)
   (comment :initform (list
     "This is the basic one dimensional array data type."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedOneDimensionalArray|
  (progn
    (push '|IndexedOneDimensionalArray| *Domains*)
    (make-instance '|IndexedOneDimensionalArrayType|)))

\end{chunk}

\subsection{IndexedString}
\index[dom]{IndexedString!Domain}
\index[dom]{Domain!IndexedString}
\index[dom]{ISTRING}
\begin{chunk}{defclass IndexedStringType}
(defclass |IndexedStringType| (|StringAggregateType|)
  ((parents :initform '(|StringAggregate|))
   (name :initform "IndexedString")
   (marker :initform 'domain)
   (abbreviation :initform 'ISTRING)
   (comment :initform (list
     "This domain implements low-level strings"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedString|
  (progn
    (push '|IndexedString| *Domains*)
    (make-instance '|IndexedStringType|)))

\end{chunk}

\subsection{IndexedTwoDimensionalArray}
\index[dom]{IndexedTwoDimensionalArray!Domain}
\index[dom]{Domain!IndexedTwoDimensionalArray}
\index[dom]{IARRAY2}
\begin{chunk}{defclass IndexedTwoDimensionalArrayType}
(defclass |IndexedTwoDimensionalArrayType| (|TwoDimensionalArrayCategoryType|)
  ((parents :initform '(|TwoDimensionalArrayCategory|))
   (name :initform "IndexedTwoDimensionalArray")
   (marker :initform 'domain)
   (abbreviation :initform 'IARRAY2)
   (comment :initform (list
     "This domain implements two dimensional arrays"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedTwoDimensionalArray|
  (progn
    (push '|IndexedTwoDimensionalArray| *Domains*)
    (make-instance '|IndexedTwoDimensionalArrayType|)))

\end{chunk}

\subsection{IndexedVector}
\index[dom]{IndexedVector!Domain}
\index[dom]{Domain!IndexedVector}
\index[dom]{IVECTOR}
\begin{chunk}{defclass IndexedVectorType}
(defclass |IndexedVectorType| (|VectorCategoryType|)
  ((parents :initform '(|VectorCategory|))
   (name :initform "IndexedVector")
   (marker :initform 'domain)
   (abbreviation :initform 'IVECTOR)
   (comment :initform (list
     "This type represents vector like objects with varying lengths"
     "and a user-specified initial index."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IndexedVector|
  (progn
    (push '|IndexedVector| *Domains*)
    (make-instance '|IndexedVectorType|)))

\end{chunk}

\subsection{InfiniteTuple}
\index[dom]{InfiniteTuple!Domain}
\index[dom]{Domain!InfiniteTuple}
\index[dom]{ITUPLE}
\begin{chunk}{defclass InfiniteTupleType}
(defclass |InfiniteTupleType| (|CoercibleToType|)
  ((parents :initform '(|CoercibleTo|))
   (name :initform "InfiniteTuple")
   (marker :initform 'domain)
   (abbreviation :initform 'ITUPLE)
   (comment :initform (list
     "This package implements 'infinite tuples' for the interpreter."
     "The representation is a stream."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InfiniteTuple|
  (progn
    (push '|InfiniteTuple| *Domains*)
    (make-instance '|InfiniteTupleType|)))

\end{chunk}

\subsection{InfinitlyClosePoint}
\index[dom]{InfinitlyClosePoint!Domain}
\index[dom]{Domain!InfinitlyClosePoint}
\index[dom]{INFCLSPT}
\begin{chunk}{defclass InfinitlyClosePointType}
(defclass |InfinitlyClosePointType| (|InfinitlyClosePointCategoryType|)
  ((parents :initform '(|InfinitlyClosePointCategory|))
   (name :initform "InfinitlyClosePoint")
   (marker :initform 'domain)
   (abbreviation :initform 'INFCLSPT)
   (comment :initform (list
     "This domain is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InfinitlyClosePoint|
  (progn
    (push '|InfinitlyClosePoint| *Domains*)
    (make-instance '|InfinitlyClosePointType|)))

\end{chunk}

\subsection{InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteField}
\index[dom]{InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteField!Domain}
\index[dom]{Domain!InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteField}
\index[dom]{INFCLSPS}
\begin{chunk}{defclass InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteFieldType}
(defclass |InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteFieldType| (|InfinitlyClosePointCategoryType|)
  ((parents :initform '(|InfinitlyClosePointCategory|))
   (name :initform "InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteField")
   (marker :initform 'domain)
   (abbreviation :initform 'INFCLSPS)
   (comment :initform (list
     "This domain is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteField|
  (progn
    (push '|InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteField| *Domains*)
    (make-instance '|InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteFieldType|)))

\end{chunk}

\subsection{InnerAlgebraicNumber}
\index[dom]{InnerAlgebraicNumber!Domain}
\index[dom]{Domain!InnerAlgebraicNumber}
\index[dom]{IAN}
\begin{chunk}{defclass InnerAlgebraicNumberType}
(defclass |InnerAlgebraicNumberType| (|AlgebraicallyClosedFieldType|
                                      |CharacteristicZeroType|
                                      |DifferentialRingType|
                                      |ExpressionSpaceType|
                                      |LinearlyExplicitRingOverType|
                                      |RealConstantType|)
  ((parents :initform '(|AlgebraicallyClosedField|
                        |CharacteristicZero|
                        |DifferentialRing|
                        |ExpressionSpace|
                        |LinearlyExplicitRingOver|
                        |RealConstant|))
   (name :initform "InnerAlgebraicNumber")
   (marker :initform 'domain)
   (abbreviation :initform 'IAN)
   (comment :initform (list
     "Algebraic closure of the rational numbers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerAlgebraicNumber|
  (progn
    (push '|InnerAlgebraicNumber| *Domains*)
    (make-instance '|InnerAlgebraicNumberType|)))

\end{chunk}

\subsection{InnerFiniteField}
\index[dom]{InnerFiniteField!Domain}
\index[dom]{Domain!InnerFiniteField}
\index[dom]{IFF}
\begin{chunk}{defclass InnerFiniteFieldType}
(defclass |InnerFiniteFieldType| (|FiniteAlgebraicExtensionFieldType|)
  ((parents :initform '(|FiniteAlgebraicExtensionField|))
   (name :initform "InnerFiniteField")
   (marker :initform 'domain)
   (abbreviation :initform 'IFF)
   (comment :initform (list
     "InnerFiniteField(p,n) implements finite fields with p**n elements"
     "where p is assumed prime but does not check."
     "For a version which checks that p is prime, see FiniteField."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerFiniteField|
  (progn
    (push '|InnerFiniteField| *Domains*)
    (make-instance '|InnerFiniteFieldType|)))

\end{chunk}

\subsection{InnerFreeAbelianMonoid}
\index[dom]{InnerFreeAbelianMonoid!Domain}
\index[dom]{Domain!InnerFreeAbelianMonoid}
\index[dom]{IFAMON}
\begin{chunk}{defclass InnerFreeAbelianMonoidType}
(defclass |InnerFreeAbelianMonoidType| (|FreeAbelianMonoidCategoryType|)
  ((parents :initform '(|FreeAbelianMonoidCategory|))
   (name :initform "InnerFreeAbelianMonoid")
   (marker :initform 'domain)
   (abbreviation :initform 'IFAMON)
   (comment :initform (list
     "Internal implementation of a free abelian monoid on any set of generators"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerFreeAbelianMonoid|
  (progn
    (push '|InnerFreeAbelianMonoid| *Domains*)
    (make-instance '|InnerFreeAbelianMonoidType|)))

\end{chunk}

\subsection{InnerIndexedTwoDimensionalArray}
\index[dom]{InnerIndexedTwoDimensionalArray!Domain}
\index[dom]{Domain!InnerIndexedTwoDimensionalArray}
\index[dom]{IIARRAY2}
\begin{chunk}{defclass InnerIndexedTwoDimensionalArrayType}
(defclass |InnerIndexedTwoDimensionalArrayType| (|TwoDimensionalArrayCategoryType|)
  ((parents :initform '(|TwoDimensionalArrayCategory|))
   (name :initform "InnerIndexedTwoDimensionalArray")
   (marker :initform 'domain)
   (abbreviation :initform 'IIARRAY2)
   (comment :initform (list
     "There is no description for this domain"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerIndexedTwoDimensionalArray|
  (progn
    (push '|InnerIndexedTwoDimensionalArray| *Domains*)
    (make-instance '|InnerIndexedTwoDimensionalArrayType|)))

\end{chunk}

\subsection{InnerPAdicInteger}
\index[dom]{InnerPAdicInteger!Domain}
\index[dom]{Domain!InnerPAdicInteger}
\index[dom]{IPADIC}
\begin{chunk}{defclass InnerPAdicIntegerType}
(defclass |InnerPAdicIntegerType| (|PAdicIntegerCategoryType|)
  ((parents :initform '(|PAdicIntegerCategory|))
   (name :initform "InnerPAdicInteger")
   (marker :initform 'domain)
   (abbreviation :initform 'IPADIC)
   (comment :initform (list
     "This domain implements Zp, the p-adic completion of the integers."
     "This is an internal domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerPAdicInteger|
  (progn
    (push '|InnerPAdicInteger| *Domains*)
    (make-instance '|InnerPAdicIntegerType|)))

\end{chunk}

\subsection{InnerPrimeField}
\index[dom]{InnerPrimeField!Domain}
\index[dom]{Domain!InnerPrimeField}
\index[dom]{IPF}
\begin{chunk}{defclass InnerPrimeFieldType}
(defclass |InnerPrimeFieldType| (|ConvertibleToType|
                                 |FiniteAlgebraicExtensionFieldType|)
  ((parents :initform '(|ConvertibleTo| |FiniteAlgebraicExtensionField|))
   (name :initform "InnerPrimeField")
   (marker :initform 'domain)
   (abbreviation :initform 'IPF)
   (comment :initform (list
     "InnerPrimeField(p) implements the field with p elements."
     "Note: argument p MUST be a prime (this domain does not check)."
     "See PrimeField for a domain that does check."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerPrimeField|
  (progn
    (push '|InnerPrimeField| *Domains*)
    (make-instance '|InnerPrimeFieldType|)))

\end{chunk}

\subsection{InnerSparseUnivariatePowerSeries}
\index[dom]{InnerSparseUnivariatePowerSeries!Domain}
\index[dom]{Domain!InnerSparseUnivariatePowerSeries}
\index[dom]{ISUPS}
\begin{chunk}{defclass InnerSparseUnivariatePowerSeriesType}
(defclass |InnerSparseUnivariatePowerSeriesType| (|UnivariatePowerSeriesCategoryType|)
  ((parents :initform '(|UnivariatePowerSeriesCategory|))
   (name :initform "InnerSparseUnivariatePowerSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'ISUPS)
   (comment :initform (list
     "InnerSparseUnivariatePowerSeries is an internal domain"
     "used for creating sparse Taylor and Laurent series."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerSparseUnivariatePowerSeries|
  (progn
    (push '|InnerSparseUnivariatePowerSeries| *Domains*)
    (make-instance '|InnerSparseUnivariatePowerSeriesType|)))

\end{chunk}

\subsection{InnerTable}
\index[dom]{InnerTable!Domain}
\index[dom]{Domain!InnerTable}
\index[dom]{INTABL}
\begin{chunk}{defclass InnerTableType}
(defclass |InnerTableType| (|TableAggregateType|)
  ((parents :initform '(|TableAggregate|))
   (name :initform "InnerTable")
   (marker :initform 'domain)
   (abbreviation :initform 'INTABL)
   (comment :initform (list
     "This domain is used to provide a conditional 'add' domain"
     "for the implementation of Table."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerTable|
  (progn
    (push '|InnerTable| *Domains*)
    (make-instance '|InnerTableType|)))

\end{chunk}

\subsection{InnerTaylorSeries}
\index[dom]{InnerTaylorSeries!Domain}
\index[dom]{Domain!InnerTaylorSeries}
\index[dom]{ITAYLOR}
\begin{chunk}{defclass InnerTaylorSeriesType}
(defclass |InnerTaylorSeriesType| (|IntegralDomainType|)
  ((parents :initform '(|IntegralDomain|))
   (name :initform "InnerTaylorSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'ITAYLOR)
   (comment :initform (list
     "This is an internal Taylor series type in which Taylor series"
     "are represented by a Stream of Ring elements."
     "For univariate series, the Stream elements are the Taylor"
     "coefficients. For multivariate series, the nth Stream element"
     "is a form of degree n in the power series variables."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerTaylorSeries|
  (progn
    (push '|InnerTaylorSeries| *Domains*)
    (make-instance '|InnerTaylorSeriesType|)))

\end{chunk}

\subsection{InputForm}
\index[dom]{InputForm!Domain}
\index[dom]{Domain!InputForm}
\index[dom]{INFORM}
\begin{chunk}{defclass InputFormType}
(defclass |InputFormType| (|ConvertibleToType| |SExpressionCategoryType|)
  ((parents :initform '(|ConvertibleTo| |SExpressionCategory|))
   (name :initform "InputForm")
   (marker :initform 'domain)
   (abbreviation :initform 'INFORM)
   (comment :initform (list
     "Domain of parsed forms which can be passed to the interpreter."
     "This is also the interface between algebra code and facilities"
     "in the interpreter."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InputForm|
  (progn
    (push '|InputForm| *Domains*)
    (make-instance '|InputFormType|)))

\end{chunk}

\subsection{Integer}
\index[dom]{Integer!Domain}
\index[dom]{Domain!Integer}
\index[dom]{INT}
\begin{chunk}{defclass IntegerType}
(defclass |IntegerType| (|IntegerNumberSystemType| |OpenMathType|)
  ((parents :initform '(|IntegerNumberSystem| |OpenMath|))
   (name :initform "Integer")
   (marker :initform 'domain)
   (abbreviation :initform 'INT)
   (comment :initform (list
     "Integer provides the domain of arbitrary precision integers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Integer|
  (progn
    (push '|Integer| *Domains*)
    (make-instance '|IntegerType|)))

\end{chunk}

\subsection{IntegerMod}
\index[dom]{IntegerMod!Domain}
\index[dom]{Domain!IntegerMod}
\index[dom]{ZMOD}
\begin{chunk}{defclass IntegerModType}
(defclass |IntegerModType| (|StepThroughType|
                            |FiniteType|
                            |ConvertibleToType|
                            |CommutativeRingType|)
  ((parents :initform '(|StepThrough|
                        |Finite|
                        |ConvertibleTo|
                        |CommutativeRing|))
   (name :initform "IntegerMod")
   (marker :initform 'domain)
   (abbreviation :initform 'ZMOD)
   (comment :initform (list
     "IntegerMod(n) creates the ring of integers reduced modulo the integer n."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegerMod|
  (progn
    (push '|IntegerMod| *Domains*)
    (make-instance '|IntegerModType|)))

\end{chunk}

\subsection{IntegrationFunctionsTable}
\index[dom]{IntegrationFunctionsTable!Domain}
\index[dom]{Domain!IntegrationFunctionsTable}
\index[dom]{INTFTBL}
\begin{chunk}{defclass IntegrationFunctionsTableType}
(defclass |IntegrationFunctionsTableType| (|AxiomClass|)
  ((parents :initform '())
   (name :initform "IntegrationFunctionsTable")
   (marker :initform 'domain)
   (abbreviation :initform 'INTFTBL)
   (comment :initform (list
     "There is no description for this domain"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegrationFunctionsTable|
  (progn
    (push '|IntegrationFunctionsTable| *Domains*)
    (make-instance '|IntegrationFunctionsTableType|)))

\end{chunk}

\subsection{IntegrationResult}
\index[dom]{IntegrationResult!Domain}
\index[dom]{Domain!IntegrationResult}
\index[dom]{IR}
\begin{chunk}{defclass IntegrationResultType}
(defclass |IntegrationResultType| (|RetractableToType| |ModuleType|)
  ((parents :initform '(|RetractableTo| |Module|))
   (name :initform "IntegrationResult")
   (marker :initform 'domain)
   (abbreviation :initform 'IR)
   (comment :initform (list
     "The result of a transcendental integration."
     "If a function f has an elementary integral g, then g can be written"
     "in the form g = h + c1 log(u1) + c2 log(u2) + ... + cn log(un)"
     "where h, which is in the same field than f, is called the rational"
     "part of the integral, and c1 log(u1) + ... cn log(un) is called the"
     "logarithmic part of the integral. This domain manipulates integrals"
     "represented in that form, by keeping both parts separately. The logs"
     "are not explicitly computed."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegrationResult|
  (progn
    (push '|IntegrationResult| *Domains*)
    (make-instance '|IntegrationResultType|)))

\end{chunk}

\subsection{Interval}
\index[dom]{Interval!Domain}
\index[dom]{Domain!Interval}
\index[dom]{INTRVL}
\begin{chunk}{defclass IntervalType}
(defclass |IntervalType| (|IntervalCategoryType|)
  ((parents :initform '(|IntervalCategory|))
   (name :initform "Interval")
   (marker :initform 'domain)
   (abbreviation :initform 'INTRVL)
   (comment :initform (list
     "This domain is an implementation of interval arithmetic and transcendental"
     "functions over intervals."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Interval|
  (progn
    (push '|Interval| *Domains*)
    (make-instance '|IntervalType|)))

\end{chunk}

\section{K}

\subsection{Kernel}
\index[dom]{Kernel!Domain}
\index[dom]{Domain!Kernel}
\index[dom]{KERNEL}
\begin{chunk}{defclass KernelType}
(defclass |KernelType| (|CachableSetType| |PatternableType|)
  ((parents :initform '(|CachableSet| |Patternable|))
   (name :initform "Kernel")
   (marker :initform 'domain)
   (abbreviation :initform 'KERNEL)
   (comment :initform (list
     "A kernel over a set S is an operator applied to a given list"
     "of arguments from S."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Kernel|
  (progn
    (push '|Kernel| *Domains*)
    (make-instance '|KernelType|)))

\end{chunk}

\subsection{KeyedAccessFile}
\index[dom]{KeyedAccessFile!Domain}
\index[dom]{Domain!KeyedAccessFile}
\index[dom]{KAFILE}
\begin{chunk}{defclass KeyedAccessFileType}
(defclass |KeyedAccessFileType| (|TableAggregateType| |FileCategoryType|)
  ((parents :initform '(|TableAggregate| |FileCategory|))
   (name :initform "KeyedAccessFile")
   (marker :initform 'domain)
   (abbreviation :initform 'KAFILE)
   (comment :initform (list
     "This domain allows a random access file to be viewed both as a table"
     "and as a file object. The KeyedAccessFile format is a directory"
     "containing a single file called ``index.kaf''. This file is a random"
     "access file. The first thing in the file is an integer which is the"
     "byte offset of an association list (the dictionary) at the end of"
     "the file. The association list is of the form"
     "((key . byteoffset) (key . byteoffset)...)"
     "where the byte offset is the number of bytes from the beginning of"
     "the file. This offset contains an s-expression for the value of the key."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |KeyedAccessFile|
  (progn
    (push '|KeyedAccessFile| *Domains*)
    (make-instance '|KeyedAccessFileType|)))

\end{chunk}

\section{L}

\subsection{LaurentPolynomial}
\index[dom]{LaurentPolynomial!Domain}
\index[dom]{Domain!LaurentPolynomial}
\index[dom]{LAUPOL}
\begin{chunk}{defclass LaurentPolynomialType}
(defclass |LaurentPolynomialType| (|FullyRetractableToType|
                                   |EuclideanDomainType|
                                   |DifferentialExtensionType|
                                   |ConvertibleToType|
                                   |CharacteristicZeroType|
                                   |CharacteristicNonZeroType|)
  ((parents :initform '(|FullyRetractableTo|
                        |EuclideanDomain|
                        |DifferentialExtension|
                        |ConvertibleTo|
                        |CharacteristicZero|
                        |CharacteristicNonZero|))
   (name :initform "LaurentPolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'LAUPOL)
   (comment :initform (list
     "Univariate polynomials with negative and positive exponents."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LaurentPolynomial|
  (progn
    (push '|LaurentPolynomial| *Domains*)
    (make-instance '|LaurentPolynomialType|)))

\end{chunk}

\subsection{Library}
\index[dom]{Library!Domain}
\index[dom]{Domain!Library}
\index[dom]{LIB}
\begin{chunk}{defclass LibraryType}
(defclass |LibraryType| (|TableAggregateType|)
  ((parents :initform '(|TableAggregate|))
   (name :initform "Library")
   (marker :initform 'domain)
   (abbreviation :initform 'LIB)
   (comment :initform (list
     "This domain provides a simple way to save values in files."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Library|
  (progn
    (push '|Library| *Domains*)
    (make-instance '|LibraryType|)))

\end{chunk}

\subsection{LieExponentials}
\index[dom]{LieExponentials!Domain}
\index[dom]{Domain!LieExponentials}
\index[dom]{LEXP}
\begin{chunk}{defclass LieExponentialsType}
(defclass |LieExponentialsType| (|GroupType|)
  ((parents :initform '(|Group|))
   (name :initform "LieExponentials")
   (marker :initform 'domain)
   (abbreviation :initform 'LEXP)
   (comment :initform (list
     "Management of the Lie Group associated with a"
     "free nilpotent Lie algebra. Every Lie bracket with"
     "length greater than Order are assumed to be null."
     "The implementation inherits from the XPBWPolynomial"
     "domain constructor: Lyndon coordinates are exponential coordinates"
     "of the second kind. "))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LieExponentials|
  (progn
    (push '|LieExponentials| *Domains*)
    (make-instance '|LieExponentialsType|)))

\end{chunk}

\subsection{LiePolynomial}
\index[dom]{LiePolynomial!Domain}
\index[dom]{Domain!LiePolynomial}
\index[dom]{LPOLY}
\begin{chunk}{defclass LiePolynomialType}
(defclass |LiePolynomialType| (|FreeLieAlgebraType| |FreeModuleCatType|)
  ((parents :initform '(|FreeLieAlgebra| |FreeModuleCat|))
   (name :initform "LiePolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'LPOLY)
   (comment :initform (list
     "This type supports Lie polynomials in Lyndon basis"
     "see Free Lie Algebras by C. Reutenauer"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LiePolynomial|
  (progn
    (push '|LiePolynomial| *Domains*)
    (make-instance '|LiePolynomialType|)))

\end{chunk}

\subsection{LieSquareMatrix}
\index[dom]{LieSquareMatrix!Domain}
\index[dom]{Domain!LieSquareMatrix}
\index[dom]{LSQM}
\begin{chunk}{defclass LieSquareMatrixType}
(defclass |LieSquareMatrixType| (|FramedNonAssociativeAlgebraType|
                                 |SquareMatrixCategoryType|)
  ((parents :initform '(|FramedNonAssociativeAlgebra| |SquareMatrixCategory|))
   (name :initform "LieSquareMatrix")
   (marker :initform 'domain)
   (abbreviation :initform 'LSQM)
   (comment :initform (list
     "LieSquareMatrix(n,R) implements the Lie algebra of the n by n"
     "matrices over the commutative ring R."
     "The Lie bracket (commutator) of the algebra is given by"
     "a*b := (a *$SQMATRIX(n,R) b - b *$SQMATRIX(n,R) a),"
     "where *$SQMATRIX(n,R) is the usual matrix multiplication."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LieSquareMatrix|
  (progn
    (push '|LieSquareMatrix| *Domains*)
    (make-instance '|LieSquareMatrixType|)))

\end{chunk}

\subsection{LinearOrdinaryDifferentialOperator}
\index[dom]{LinearOrdinaryDifferentialOperator!Domain}
\index[dom]{Domain!LinearOrdinaryDifferentialOperator}
\index[dom]{LODO}
\begin{chunk}{defclass LinearOrdinaryDifferentialOperatorType}
(defclass |LinearOrdinaryDifferentialOperatorType| (|LinearOrdinaryDifferentialOperatorCategoryType|)
  ((parents :initform '(|LinearOrdinaryDifferentialOperatorCategory|))
   (name :initform "LinearOrdinaryDifferentialOperator")
   (marker :initform 'domain)
   (abbreviation :initform 'LODO)
   (comment :initform (list
     "LinearOrdinaryDifferentialOperator defines a ring of"
     "differential operators with coefficients in a ring A with a given"
     "derivation."
     "Multiplication of operators corresponds to functional composition:"
     "(L1 * L2).(f) = L1 L2 f"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinearOrdinaryDifferentialOperator|
  (progn
    (push '|LinearOrdinaryDifferentialOperator| *Domains*)
    (make-instance '|LinearOrdinaryDifferentialOperatorType|)))

\end{chunk}

\subsection{LinearOrdinaryDifferentialOperator1}
\index[dom]{LinearOrdinaryDifferentialOperator1!Domain}
\index[dom]{Domain!LinearOrdinaryDifferentialOperator1}
\index[dom]{LODO1}
\begin{chunk}{defclass LinearOrdinaryDifferentialOperator1Type}
(defclass |LinearOrdinaryDifferentialOperator1Type| (|LinearOrdinaryDifferentialOperatorCategoryType|)
  ((parents :initform '(|LinearOrdinaryDifferentialOperatorCategory|))
   (name :initform "LinearOrdinaryDifferentialOperator1")
   (marker :initform 'domain)
   (abbreviation :initform 'LODO1)
   (comment :initform (list
     "LinearOrdinaryDifferentialOperator1 defines a ring of"
     "differential operators with coefficients in a differential ring A"
     "Multiplication of operators corresponds to functional composition:"
     "(L1 * L2).(f) = L1 L2 f"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinearOrdinaryDifferentialOperator1|
  (progn
    (push '|LinearOrdinaryDifferentialOperator1| *Domains*)
    (make-instance '|LinearOrdinaryDifferentialOperator1Type|)))

\end{chunk}

\subsection{LinearOrdinaryDifferentialOperator2}
\index[dom]{LinearOrdinaryDifferentialOperator2!Domain}
\index[dom]{Domain!LinearOrdinaryDifferentialOperator2}
\index[dom]{LODO2}
\begin{chunk}{defclass LinearOrdinaryDifferentialOperator2Type}
(defclass |LinearOrdinaryDifferentialOperator2Type| (|LinearOrdinaryDifferentialOperatorCategoryType|)
  ((parents :initform '(|LinearOrdinaryDifferentialOperatorCategory|))
   (name :initform "LinearOrdinaryDifferentialOperator2")
   (marker :initform 'domain)
   (abbreviation :initform 'LODO2)
   (comment :initform (list
     "LinearOrdinaryDifferentialOperator2 defines a ring of"
     "differential operators with coefficients in a differential ring A"
     "and acting on an A-module M."
     "Multiplication of operators corresponds to functional composition:"
     "(L1 * L2).(f) = L1 L2 f"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinearOrdinaryDifferentialOperator2|
  (progn
    (push '|LinearOrdinaryDifferentialOperator2| *Domains*)
    (make-instance '|LinearOrdinaryDifferentialOperator2Type|)))

\end{chunk}

\subsection{List}
\index[dom]{List!Domain}
\index[dom]{Domain!List}
\index[dom]{LIST}
\begin{chunk}{defclass ListType}
(defclass |ListType| (|OpenMathType| |ListAggregateType|)
  ((parents :initform '(|OpenMath| |ListAggregate|))
   (name :initform "List")
   (marker :initform 'domain)
   (abbreviation :initform 'LIST)
   (comment :initform (list
     "List implements singly-linked lists that are"
     "addressable by indices; the index of the first element"
     "is 1. In addition to the operations provided by"
     "IndexedList, this constructor provides some"
     "LISP-like functions such as null and cons."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |List|
  (progn
    (push '|List| *Domains*)
    (make-instance '|ListType|)))

\end{chunk}

\subsection{ListMonoidOps}
\index[dom]{ListMonoidOps!Domain}
\index[dom]{Domain!ListMonoidOps}
\index[dom]{LMOPS}
\begin{chunk}{defclass ListMonoidOpsType}
(defclass |ListMonoidOpsType| (|SetCategoryType| |RetractableToType|)
  ((parents :initform '(|SetCategory| |RetractableTo|))
   (name :initform "ListMonoidOps")
   (marker :initform 'domain)
   (abbreviation :initform 'LMOPS)
   (comment :initform (list
     "This internal package represents monoid (abelian or not, with or"
     "without inverses) as lists and provides some common operations"
     "to the various flavors of monoids."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ListMonoidOps|
  (progn
    (push '|ListMonoidOps| *Domains*)
    (make-instance '|ListMonoidOpsType|)))

\end{chunk}

\subsection{ListMultiDictionary}
\index[dom]{ListMultiDictionary!Domain}
\index[dom]{Domain!ListMultiDictionary}
\index[dom]{LMDICT}
\begin{chunk}{defclass ListMultiDictionaryType}
(defclass |ListMultiDictionaryType| (|MultiDictionaryType|)
  ((parents :initform '(|MultiDictionary|))
   (name :initform "ListMultiDictionary")
   (marker :initform 'domain)
   (abbreviation :initform 'LMDICT)
   (comment :initform (list
     "The ListMultiDictionary domain implements a"
     "dictionary with duplicates"
     "allowed.  The representation is a list with duplicates represented"
     "explicitly.  Hence most operations will be relatively inefficient"
     "when the number of entries in the dictionary becomes large."
     "If the objects in the dictionary belong to an ordered set,"
     "the entries are maintained in ascending order."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ListMultiDictionary|
  (progn
    (push '|ListMultiDictionary| *Domains*)
    (make-instance '|ListMultiDictionaryType|)))

\end{chunk}

\subsection{LocalAlgebra}
\index[dom]{LocalAlgebra!Domain}
\index[dom]{Domain!LocalAlgebra}
\index[dom]{LA}
\begin{chunk}{defclass LocalAlgebraType}
(defclass |LocalAlgebraType| (|AlgebraType| |OrderedRingType|)
  ((parents :initform '(|Algebra| |OrderedRing|))
   (name :initform "LocalAlgebra")
   (marker :initform 'domain)
   (abbreviation :initform 'LA)
   (comment :initform (list
     "LocalAlgebra produces the localization of an algebra,"
     "fractions whose numerators come from some R algebra."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LocalAlgebra|
  (progn
    (push '|LocalAlgebra| *Domains*)
    (make-instance '|LocalAlgebraType|)))

\end{chunk}

\subsection{Localize}
\index[dom]{Localize!Domain}
\index[dom]{Domain!Localize}
\index[dom]{LO}
\begin{chunk}{defclass LocalizeType}
(defclass |LocalizeType| (|ModuleType| |OrderedAbelianGroupType|)
  ((parents :initform '(|Module| |OrderedAbelianGroup|))
   (name :initform "Localize")
   (marker :initform 'domain)
   (abbreviation :initform 'LO)
   (comment :initform (list
     "Localize(M,R,S) produces fractions with numerators"
     "from an R module M and denominators from some multiplicative subset D of R."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Localize|
  (progn
    (push '|Localize| *Domains*)
    (make-instance '|LocalizeType|)))

\end{chunk}

\subsection{LyndonWord}
\index[dom]{LyndonWord!Domain}
\index[dom]{Domain!LyndonWord}
\index[dom]{LWORD}
\begin{chunk}{defclass LyndonWordType}
(defclass |LyndonWordType| (|OrderedSetType| |RetractableToType|)
  ((parents :initform '(|OrderedSet| |RetractableTo|))
   (name :initform "LyndonWord")
   (marker :initform 'domain)
   (abbreviation :initform 'LWORD)
   (comment :initform (list
     "Lyndon words over arbitrary (ordered) symbols:"
     "see Free Lie Algebras by C. Reutenauer (Oxford science publications)."
     "A Lyndon word is a word which is smaller than any of its right factors"
     "w.r.t. the pure lexicographical ordering."
     "If a and b are two Lyndon words such that a < b"
     "holds w.r.t lexicographical ordering then a*b is a Lyndon word."
     "Parenthesized Lyndon words can be generated from symbols by using the"
     "following rule:"
     "[[a,b],c] is a Lyndon word iff a*b < c <= b holds."
     "Lyndon words are internally represented by binary trees using the"
     "Magma domain constructor."
     "Two ordering are provided: lexicographic and"
     "length-lexicographic. "))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LyndonWord|
  (progn
    (push '|LyndonWord| *Domains*)
    (make-instance '|LyndonWordType|)))

\end{chunk}

\section{M}

%TPDHERE class precedence error
\subsection{MachineComplex}
\index[dom]{MachineComplex!Domain}
\index[dom]{Domain!MachineComplex}
\index[dom]{MCMPLX}
\begin{chunk}{insane}
(defclass |MachineComplexType| (|ComplexCategoryType| |FortranMachineTypeCategoryType|)
  ((parents :initform '(|ComplexCategory| |FortranMachineTypeCategory|))
   (name :initform "MachineComplex")
   (marker :initform 'domain)
   (abbreviation :initform 'MCMPLX)
   (comment :initform (list
     "A domain which models the complex number representation"
     "used by machines in the AXIOM-NAG link."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MachineComplex|
  (progn
    (push '|MachineComplex| *Domains*)
    (make-instance '|MachineComplexType|)))

\end{chunk}

%TPDHERE class precedence error
\subsection{MachineFloat}
\index[dom]{MachineFloat!Domain}
\index[dom]{Domain!MachineFloat}
\index[dom]{MFLOAT}
\begin{chunk}{insane}
(defclass |MachineFloatType| (|FloatingPointSystemType| |FortranMachineTypeCategoryType|)
  ((parents :initform '(|FloatingPointSystem| |FortranMachineTypeCategory|))
   (name :initform "MachineFloat")
   (marker :initform 'domain)
   (abbreviation :initform 'MFLOAT)
   (comment :initform (list
     "A domain which models the floating point representation"
     " used by machines in the AXIOM-NAG link."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MachineFloat|
  (progn
    (push '|MachineFloat| *Domains*)
    (make-instance '|MachineFloatType|)))

\end{chunk}

%TPDHERE class precedence failure
\subsection{MachineInteger}
\index[dom]{MachineInteger!Domain}
\index[dom]{Domain!MachineInteger}
\index[dom]{MINT}
\begin{chunk}{defclass MachineIntegerType}
(defclass |MachineIntegerType| (|IntegerNumberSystemType|); |FortranMachineTypeCategoryType|)
  ((parents :initform '(|IntegerNumberSystem| |FortranMachineTypeCategory|))
   (name :initform "MachineInteger")
   (marker :initform 'domain)
   (abbreviation :initform 'MINT)
   (comment :initform (list
     "A domain which models the integer representation"
     " used by machines in the AXIOM-NAG link."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MachineInteger|
  (progn
    (push '|MachineInteger| *Domains*)
    (make-instance '|MachineIntegerType|)))

\end{chunk}

\subsection{Magma}
\index[dom]{Magma!Domain}
\index[dom]{Domain!Magma}
\index[dom]{MAGMA}
\begin{chunk}{defclass MagmaType}
(defclass |MagmaType| (|OrderedSetType| |RetractableToType|)
  ((parents :initform '(|OrderedSet| |RetractableTo|))
   (name :initform "Magma")
   (marker :initform 'domain)
   (abbreviation :initform 'MAGMA)
   (comment :initform (list
     "This type is the basic representation of"
     "parenthesized words (binary trees over arbitrary symbols)"
     "useful in LiePolynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Magma|
  (progn
    (push '|Magma| *Domains*)
    (make-instance '|MagmaType|)))

\end{chunk}

\subsection{MakeCachableSet}
\index[dom]{MakeCachableSet!Domain}
\index[dom]{Domain!MakeCachableSet}
\index[dom]{MKCHSET}
\begin{chunk}{defclass MakeCachableSetType}
(defclass |MakeCachableSetType| (|CachableSetType|)
  ((parents :initform '(|CachableSet|))
   (name :initform "MakeCachableSet")
   (marker :initform 'domain)
   (abbreviation :initform 'MKCHSET)
   (comment :initform (list
     "MakeCachableSet(S) returns a cachable set which is equal to S as a set."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MakeCachableSet|
  (progn
    (push '|MakeCachableSet| *Domains*)
    (make-instance '|MakeCachableSetType|)))

\end{chunk}

\subsection{MathMLFormat}
\index[dom]{MathMLFormat!Domain}
\index[dom]{Domain!MathMLFormat}
\index[dom]{MMLFORM}
\begin{chunk}{defclass MathMLFormatType}
(defclass |MathMLFormatType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "MathMLFormat")
   (marker :initform 'domain)
   (abbreviation :initform 'MMLFORM)
   (comment :initform (list
     "This package is based on the TeXFormat domain by Robert S. Sutor"
     "MathMLFormat provides a coercion from OutputForm"
     "to MathML format."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MathMLFormat|
  (progn
    (push '|MathMLFormat| *Domains*)
    (make-instance '|MathMLFormatType|)))

\end{chunk}

\subsection{Matrix}
\index[dom]{Matrix!Domain}
\index[dom]{Domain!Matrix}
\index[dom]{MATRIX}
\begin{chunk}{defclass MatrixType}
(defclass |MatrixType| (|ConvertibleToType| |MatrixCategoryType|)
  ((parents :initform '(|ConvertibleTo| |MatrixCategory|))
   (name :initform "Matrix")
   (marker :initform 'domain)
   (abbreviation :initform 'MATRIX)
   (comment :initform (list
     "Matrix is a matrix domain where 1-based indexing is used"
     "for both rows and columns."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Matrix|
  (progn
    (push '|Matrix| *Domains*)
    (make-instance '|MatrixType|)))

\end{chunk}

\subsection{ModMonic}
\index[dom]{ModMonic!Domain}
\index[dom]{Domain!ModMonic}
\index[dom]{MODMON}
\begin{chunk}{defclass ModMonicType}
(defclass |ModMonicType| (|UnivariatePolynomialCategoryType| |FiniteType|)
  ((parents :initform '(|UnivariatePolynomialCategory| |Finite|))
   (name :initform "ModMonic")
   (marker :initform 'domain)
   (abbreviation :initform 'MODMON)
   (comment :initform (list
     "This package has not been documented"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ModMonic|
  (progn
    (push '|ModMonic| *Domains*)
    (make-instance '|ModMonicType|)))

\end{chunk}

\subsection{ModularField}
\index[dom]{ModularField!Domain}
\index[dom]{Domain!ModularField}
\index[dom]{MODFIELD}
\begin{chunk}{defclass ModularFieldType}
(defclass |ModularFieldType| (|FieldType|)
  ((parents :initform '(|Field|))
   (name :initform "ModularField")
   (marker :initform 'domain)
   (abbreviation :initform 'MODFIELD)
   (comment :initform (list
     "These domains are used for the factorization and gcds"
     "of univariate polynomials over the integers in order to work modulo"
     "different  primes."
     "See ModularRing, EuclideanModularRing"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ModularField|
  (progn
    (push '|ModularField| *Domains*)
    (make-instance '|ModularFieldType|)))

\end{chunk}

\subsection{ModularRing}
\index[dom]{ModularRing!Domain}
\index[dom]{Domain!ModularRing}
\index[dom]{MODRING}
\begin{chunk}{defclass ModularRingType}
(defclass |ModularRingType| (|RingType|)
  ((parents :initform '(|Ring|))
   (name :initform "ModularRing")
   (marker :initform 'domain)
   (abbreviation :initform 'MODRING)
   (comment :initform (list
     "These domains are used for the factorization and gcds"
     "of univariate polynomials over the integers in order to work modulo"
     "different  primes."
     "See EuclideanModularRing ,ModularField"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ModularRing|
  (progn
    (push '|ModularRing| *Domains*)
    (make-instance '|ModularRingType|)))

\end{chunk}

\subsection{ModuleMonomial}
\index[dom]{ModuleMonomial!Domain}
\index[dom]{Domain!ModuleMonomial}
\index[dom]{MODMONOM}
\begin{chunk}{defclass ModuleMonomialType}
(defclass |ModuleMonomialType| (|OrderedSetType|)
  ((parents :initform '(|OrderedSet|))
   (name :initform "ModuleMonomial")
   (marker :initform 'domain)
   (abbreviation :initform 'MODMONOM)
   (comment :initform (list
     "This package has no documentation"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ModuleMonomial|
  (progn
    (push '|ModuleMonomial| *Domains*)
    (make-instance '|ModuleMonomialType|)))

\end{chunk}

\subsection{ModuleOperator}
\index[dom]{ModuleOperator!Domain}
\index[dom]{Domain!ModuleOperator}
\index[dom]{MODOP}
\begin{chunk}{defclass ModuleOperatorType}
(defclass |ModuleOperatorType| (|AlgebraType|
                                |CharacteristicNonZeroType|
                                |CharacteristicZeroType|
                                |EltableType|
                                |RetractableToType|)
  ((parents :initform '(|Algebra|
                        |CharacteristicNonZero|
                        |CharacteristicZero|
                        |Eltable|
                        |RetractableTo|))
   (name :initform "ModuleOperator")
   (marker :initform 'domain)
   (abbreviation :initform 'MODOP)
   (comment :initform (list
     "Algebra of ADDITIVE operators on a module."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ModuleOperator|
  (progn
    (push '|ModuleOperator| *Domains*)
    (make-instance '|ModuleOperatorType|)))

\end{chunk}

\subsection{MoebiusTransform}
\index[dom]{MoebiusTransform!Domain}
\index[dom]{Domain!MoebiusTransform}
\index[dom]{MOEBIUS}
\begin{chunk}{defclass MoebiusTransformType}
(defclass |MoebiusTransformType| (|GroupType|)
  ((parents :initform '(|Group|))
   (name :initform "MoebiusTransform")
   (marker :initform 'domain)
   (abbreviation :initform 'MOEBIUS)
   (comment :initform (list
     "MoebiusTransform(F) is the domain of fractional linear (Moebius)"
     "transformations over F. This a domain of 2-by-2 matrices acting on P1(F)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MoebiusTransform|
  (progn
    (push '|MoebiusTransform| *Domains*)
    (make-instance '|MoebiusTransformType|)))

\end{chunk}

\subsection{MonoidRing}
\index[dom]{MonoidRing!Domain}
\index[dom]{Domain!MonoidRing}
\index[dom]{MRING}
\begin{chunk}{defclass MonoidRingType}
(defclass |MonoidRingType| (|RetractableToType|
                            |FiniteType|
                            |CharacteristicZeroType|
                            |CharacteristicNonZeroType|
                            |AlgebraType|)
  ((parents :initform '(|RetractableTo|
                        |Finite|
                        |CharacteristicZero|
                        |CharacteristicNonZero|
                        |Algebra|))
   (name :initform "MonoidRing")
   (marker :initform 'domain)
   (abbreviation :initform 'MRING)
   (comment :initform (list
     "MonoidRing(R,M), implements the algebra"
     "of all maps from the monoid M to the commutative ring R with"
     "finite support."
     "Multiplication of two maps f and g is defined"
     "to map an element c of M to the (convolution) sum over f(a)g(b)"
     "such that ab = c. Thus M can be identified with a canonical"
     "basis and the maps can also be considered as formal linear combinations"
     "of the elements in M. Scalar multiples of a basis element are called"
     "monomials. A prominent example is the class of polynomials"
     "where the monoid is a direct product of the natural numbers"
     "with pointwise addition. When M is"
     "FreeMonoid Symbol, one gets polynomials"
     "in infinitely many non-commuting variables. Another application"
     "area is representation theory of finite groups G, where modules"
     "over MonoidRing(R,G) are studied."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MonoidRing|
  (progn
    (push '|MonoidRing| *Domains*)
    (make-instance '|MonoidRingType|)))

\end{chunk}

\subsection{Multiset}
\index[dom]{Multiset!Domain}
\index[dom]{Domain!Multiset}
\index[dom]{MSET}
\begin{chunk}{defclass MultisetType}
(defclass |MultisetType| (|MultisetAggregateType|)
  ((parents :initform '(|MultisetAggregate|))
   (name :initform "Multiset")
   (marker :initform 'domain)
   (abbreviation :initform 'MSET)
   (comment :initform (list
     "A multiset is a set with multiplicities."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Multiset|
  (progn
    (push '|Multiset| *Domains*)
    (make-instance '|MultisetType|)))

\end{chunk}

\subsection{MultivariatePolynomial}
\index[dom]{MultivariatePolynomial!Domain}
\index[dom]{Domain!MultivariatePolynomial}
\index[dom]{MPOLY}
\begin{chunk}{defclass MultivariatePolynomialType}
(defclass |MultivariatePolynomialType| (|PolynomialCategoryType|)
  ((parents :initform '(|PolynomialCategory|))
   (name :initform "MultivariatePolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'MPOLY)
   (comment :initform (list
     "This type is the basic representation of sparse recursive multivariate"
     "polynomials whose variables are from a user specified list of symbols."
     "The ordering is specified by the position of the variable in the list."
     "The coefficient ring may be non commutative,"
     "but the variables are assumed to commute."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MultivariatePolynomial|
  (progn
    (push '|MultivariatePolynomial| *Domains*)
    (make-instance '|MultivariatePolynomialType|)))

\end{chunk}

\subsection{MyExpression}
\index[dom]{MyExpression!Domain}
\index[dom]{Domain!MyExpression}
\index[dom]{MYEXPR}
\begin{chunk}{defclass MyExpressionType}
(defclass |MyExpressionType| (|FunctionSpaceType| |CombinatorialOpsCategoryType|)
  ((parents :initform '(|FunctionSpace| |CombinatorialOpsCategory|))
   (name :initform "MyExpression")
   (marker :initform 'domain)
   (abbreviation :initform 'MYEXPR)
   (comment :initform (list
     "This domain has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MyExpression|
  (progn
    (push '|MyExpression| *Domains*)
    (make-instance '|MyExpressionType|)))

\end{chunk}

\subsection{MyUnivariatePolynomial}
\index[dom]{MyUnivariatePolynomial!Domain}
\index[dom]{Domain!MyUnivariatePolynomial}
\index[dom]{MYUP}
\begin{chunk}{defclass MyUnivariatePolynomialType}
(defclass |MyUnivariatePolynomialType| (|UnivariatePolynomialCategoryType|)
  ((parents :initform '(|UnivariatePolynomialCategory|))
   (name :initform "MyUnivariatePolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'MYUP)
   (comment :initform (list
     "This domain has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MyUnivariatePolynomial|
  (progn
    (push '|MyUnivariatePolynomial| *Domains*)
    (make-instance '|MyUnivariatePolynomialType|)))

\end{chunk}

\section{N}

\subsection{NeitherSparseOrDensePowerSeries}
\index[dom]{NeitherSparseOrDensePowerSeries!Domain}
\index[dom]{Domain!NeitherSparseOrDensePowerSeries}
\index[dom]{NSDPS}
\begin{chunk}{defclass NeitherSparseOrDensePowerSeriesType}
(defclass |NeitherSparseOrDensePowerSeriesType| (|LocalPowerSeriesCategoryType|
                                                 |LazyStreamAggregateType|)
  ((parents :initform '(|LocalPowerSeriesCategory| |LazyStreamAggregate|))
   (name :initform "NeitherSparseOrDensePowerSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'NSDPS)
   (comment :initform (list
     "This domain is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NeitherSparseOrDensePowerSeries|
  (progn
    (push '|NeitherSparseOrDensePowerSeries| *Domains*)
    (make-instance '|NeitherSparseOrDensePowerSeriesType|)))

\end{chunk}

\subsection{NewSparseMultivariatePolynomial}
\index[dom]{NewSparseMultivariatePolynomial!Domain}
\index[dom]{Domain!NewSparseMultivariatePolynomial}
\index[dom]{NSMP}
\begin{chunk}{defclass NewSparseMultivariatePolynomialType}
(defclass |NewSparseMultivariatePolynomialType| (|RecursivePolynomialCategoryType|)
  ((parents :initform '(|RecursivePolynomialCategory|))
   (name :initform "NewSparseMultivariatePolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'NSMP)
   (comment :initform (list
     "A post-facto extension for SMP in order"
     "to speed up operations related to pseudo-division and gcd."
     "This domain is based on the NSUP constructor which is"
     "itself a post-facto extension of the SUP constructor."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NewSparseMultivariatePolynomial|
  (progn
    (push '|NewSparseMultivariatePolynomial| *Domains*)
    (make-instance '|NewSparseMultivariatePolynomialType|)))

\end{chunk}

\subsection{NewSparseUnivariatePolynomial}
\index[dom]{NewSparseUnivariatePolynomial!Domain}
\index[dom]{Domain!NewSparseUnivariatePolynomial}
\index[dom]{NSUP}
\begin{chunk}{defclass NewSparseUnivariatePolynomialType}
(defclass |NewSparseUnivariatePolynomialType| (|UnivariatePolynomialCategoryType|)
  ((parents :initform '(|UnivariatePolynomialCategory|))
   (name :initform "NewSparseUnivariatePolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'NSUP)
   (comment :initform (list
     "A post-facto extension for SUP in order"
     "to speed up operations related to pseudo-division and gcd for"
     "both SUP and, consequently, NSMP."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NewSparseUnivariatePolynomial|
  (progn
    (push '|NewSparseUnivariatePolynomial| *Domains*)
    (make-instance '|NewSparseUnivariatePolynomialType|)))

\end{chunk}

\subsection{None}
\index[dom]{None!Domain}
\index[dom]{Domain!None}
\index[dom]{NONE}
\begin{chunk}{defclass NoneType}
(defclass |NoneType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "None")
   (marker :initform 'domain)
   (abbreviation :initform 'NONE)
   (comment :initform (list
     "None implements a type with no objects. It is mainly"
     "used in technical situations where such a thing is needed (for example,"
     "the interpreter and some of the internal Expression code)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |None|
  (progn
    (push '|None| *Domains*)
    (make-instance '|NoneType|)))

\end{chunk}

\subsection{NonNegativeInteger}
\index[dom]{NonNegativeInteger!Domain}
\index[dom]{Domain!NonNegativeInteger}
\index[dom]{NNI}
\begin{chunk}{defclass NonNegativeIntegerType}
(defclass |NonNegativeIntegerType| (|OrderedAbelianMonoidSupType| |MonoidType|)
  ((parents :initform '(|OrderedAbelianMonoidSup| |Monoid|))
   (name :initform "NonNegativeInteger")
   (marker :initform 'domain)
   (abbreviation :initform 'NNI)
   (comment :initform (list
     "NonNegativeInteger provides functions for non negative integers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NonNegativeInteger|
  (progn
    (push '|NonNegativeInteger| *Domains*)
    (make-instance '|NonNegativeIntegerType|)))

\end{chunk}

\subsection{NottinghamGroup}
\index[dom]{NottinghamGroup!Domain}
\index[dom]{Domain!NottinghamGroup}
\index[dom]{NOTTING}
\begin{chunk}{defclass NottinghamGroupType}
(defclass |NottinghamGroupType| (|GroupType|)
  ((parents :initform '(|Group|))
   (name :initform "NottinghamGroup")
   (marker :initform 'domain)
   (abbreviation :initform 'NOTTING)
   (comment :initform (list
     "This is an implmenentation of the Nottingham Group"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NottinghamGroup|
  (progn
    (push '|NottinghamGroup| *Domains*)
    (make-instance '|NottinghamGroupType|)))

\end{chunk}

\subsection{NumericalIntegrationProblem}
\index[dom]{NumericalIntegrationProblem!Domain}
\index[dom]{Domain!NumericalIntegrationProblem}
\index[dom]{NIPROB}
\begin{chunk}{defclass NumericalIntegrationProblemType}
(defclass |NumericalIntegrationProblemType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "NumericalIntegrationProblem")
   (marker :initform 'domain)
   (abbreviation :initform 'NIPROB)
   (comment :initform (list
     "NumericalIntegrationProblem is a domain"
     "for the representation of Numerical Integration problems for use"
     "by ANNA."
     " "
     "The representation is a Union of two record types - one for integration of"
     "a function of one variable:"
     " "
     "Record(var:Symbol,"
     "fn:Expression DoubleFloat,"
     "range:Segment OrderedCompletion DoubleFloat,"
     "abserr:DoubleFloat,"
     "relerr:DoubleFloat,)"
     " "
     "and one for multivariate integration:"
     " "
     "Record(fn:Expression DoubleFloat,"
     "range:List Segment OrderedCompletion DoubleFloat,"
     "abserr:DoubleFloat,"
     "relerr:DoubleFloat,)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NumericalIntegrationProblem|
  (progn
    (push '|NumericalIntegrationProblem| *Domains*)
    (make-instance '|NumericalIntegrationProblemType|)))

\end{chunk}

\subsection{NumericalODEProblem}
\index[dom]{NumericalODEProblem!Domain}
\index[dom]{Domain!NumericalODEProblem}
\index[dom]{ODEPROB}
\begin{chunk}{defclass NumericalODEProblemType}
(defclass |NumericalODEProblemType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "NumericalODEProblem")
   (marker :initform 'domain)
   (abbreviation :initform 'ODEPROB)
   (comment :initform (list
     "NumericalODEProblem is a domain"
     "for the representation of Numerical ODE problems for use"
     "by ANNA."
     " "
     "The representation is of type:"
     " "
     "Record(xinit:DoubleFloat,"
     "xend:DoubleFloat,"
     "fn:Vector Expression DoubleFloat,"
     "yinit:List DoubleFloat,intvals:List DoubleFloat,"
     "g:Expression DoubleFloat,abserr:DoubleFloat,"
     "relerr:DoubleFloat)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NumericalODEProblem|
  (progn
    (push '|NumericalODEProblem| *Domains*)
    (make-instance '|NumericalODEProblemType|)))

\end{chunk}

\subsection{NumericalOptimizationProblem}
\index[dom]{NumericalOptimizationProblem!Domain}
\index[dom]{Domain!NumericalOptimizationProblem}
\index[dom]{OPTPROB}
\begin{chunk}{defclass NumericalOptimizationProblemType}
(defclass |NumericalOptimizationProblemType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "NumericalOptimizationProblem")
   (marker :initform 'domain)
   (abbreviation :initform 'OPTPROB)
   (comment :initform (list
     "NumericalOptimizationProblem is a domain"
     "for the representation of Numerical Optimization problems for use"
     "by ANNA."
     " "
     "The representation is a Union of two record types - one for optimization of"
     "a single function of one or more variables:"
     " "
     "Record("
     "fn:Expression DoubleFloat,"
     "init:List DoubleFloat,"
     "lb:List OrderedCompletion DoubleFloat,"
     "cf:List Expression DoubleFloat,"
     "ub:List OrderedCompletion DoubleFloat)"
     " "
     "and one for least-squares problems that is, optimization of a set of"
     "observations of a data set:"
     " "
     "Record(lfn:List Expression DoubleFloat,"
     "init:List DoubleFloat)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NumericalOptimizationProblem|
  (progn
    (push '|NumericalOptimizationProblem| *Domains*)
    (make-instance '|NumericalOptimizationProblemType|)))

\end{chunk}

\subsection{NumericalPDEProblem}
\index[dom]{NumericalPDEProblem!Domain}
\index[dom]{Domain!NumericalPDEProblem}
\index[dom]{PDEPROB}
\begin{chunk}{defclass NumericalPDEProblemType}
(defclass |NumericalPDEProblemType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "NumericalPDEProblem")
   (marker :initform 'domain)
   (abbreviation :initform 'PDEPROB)
   (comment :initform (list
     "NumericalPDEProblem is a domain"
     "for the representation of Numerical PDE problems for use"
     "by ANNA."
     " "
     "The representation is of type:"
     " "
     "Record(pde:List Expression DoubleFloat,"
     "constraints:List PDEC,"
     "f:List List Expression DoubleFloat,"
     "st:String,"
     "tol:DoubleFloat)"
     " "
     "where PDEC is of type:"
     " "
     "Record(start:DoubleFloat,"
     "finish:DoubleFloat,"
     "grid:NonNegativeInteger,"
     "boundaryType:Integer,"
     "dStart:Matrix DoubleFloat,"
     "dFinish:Matrix DoubleFloat)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NumericalPDEProblem|
  (progn
    (push '|NumericalPDEProblem| *Domains*)
    (make-instance '|NumericalPDEProblemType|)))

\end{chunk}

\section{O}

\subsection{Octonion}
\index[dom]{Octonion!Domain}
\index[dom]{Domain!Octonion}
\index[dom]{OCT}
\begin{chunk}{defclass OctonionType}
(defclass |OctonionType| (|OctonionCategoryType|)
  ((parents :initform '(|OctonionCategory|))
   (name :initform "Octonion")
   (marker :initform 'domain)
   (abbreviation :initform 'OCT)
   (comment :initform (list
     "Octonion implements octonions (Cayley-Dixon algebra) over a"
     "commutative ring, an eight-dimensional non-associative"
     "algebra, doubling the quaternions in the same way as doubling"
     "the complex numbers to get the quaternions"
     "the main constructor function is octon which takes 8"
     "arguments: the real part, the i imaginary part, the j"
     "imaginary part, the k imaginary part, (as with quaternions)"
     "and in addition the imaginary parts E, I, J, K."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Octonion|
  (progn
    (push '|Octonion| *Domains*)
    (make-instance '|OctonionType|)))

\end{chunk}

\subsection{ODEIntensityFunctionsTable}
\index[dom]{ODEIntensityFunctionsTable!Domain}
\index[dom]{Domain!ODEIntensityFunctionsTable}
\index[dom]{ODEIFTBL}
\begin{chunk}{defclass ODEIntensityFunctionsTableType}
(defclass |ODEIntensityFunctionsTableType| (|AxiomClass|)
  ((parents :initform '())
   (name :initform "ODEIntensityFunctionsTable")
   (marker :initform 'domain)
   (abbreviation :initform 'ODEIFTBL)
   (comment :initform (list
     "ODEIntensityFunctionsTable() provides a dynamic table and a set of"
     "functions to store details found out about sets of ODE's."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ODEIntensityFunctionsTable|
  (progn
    (push '|ODEIntensityFunctionsTable| *Domains*)
    (make-instance '|ODEIntensityFunctionsTableType|)))

\end{chunk}

\subsection{OneDimensionalArray}
\index[dom]{OneDimensionalArray!Domain}
\index[dom]{Domain!OneDimensionalArray}
\index[dom]{ARRAY1}
\begin{chunk}{defclass OneDimensionalArrayType}
(defclass |OneDimensionalArrayType| (|OneDimensionalArrayAggregateType|)
  ((parents :initform '(|OneDimensionalArrayAggregate|))
   (name :initform "OneDimensionalArray")
   (marker :initform 'domain)
   (abbreviation :initform 'ARRAY1)
   (comment :initform (list
     "This is the domain of 1-based one dimensional arrays"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OneDimensionalArray|
  (progn
    (push '|OneDimensionalArray| *Domains*)
    (make-instance '|OneDimensionalArrayType|)))

\end{chunk}

\subsection{OnePointCompletion}
\index[dom]{OnePointCompletion!Domain}
\index[dom]{Domain!OnePointCompletion}
\index[dom]{ONECOMP}
\begin{chunk}{defclass OnePointCompletionType}
(defclass |OnePointCompletionType| (|OrderedRingType| |FullyRetractableToType|)
  ((parents :initform '(|OrderedRing| |FullyRetractableTo|))
   (name :initform "OnePointCompletion")
   (marker :initform 'domain)
   (abbreviation :initform 'ONECOMP)
   (comment :initform (list
     "Completion with infinity."
     "Adjunction of a complex infinity to a set."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OnePointCompletion|
  (progn
    (push '|OnePointCompletion| *Domains*)
    (make-instance '|OnePointCompletionType|)))

\end{chunk}

\subsection{OpenMathConnection}
\index[dom]{OpenMathConnection!Domain}
\index[dom]{Domain!OpenMathConnection}
\index[dom]{OMCONN}
\begin{chunk}{defclass OpenMathConnectionType}
(defclass |OpenMathConnectionType| (|AxiomClass|)
  ((parents :initform '())
   (name :initform "OpenMathConnection")
   (marker :initform 'domain)
   (abbreviation :initform 'OMCONN)
   (comment :initform (list
     "OpenMathConnection provides low-level functions"
     "for handling connections to and from OpenMathDevices."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OpenMathConnection|
  (progn
    (push '|OpenMathConnection| *Domains*)
    (make-instance '|OpenMathConnectionType|)))

\end{chunk}

\subsection{OpenMathDevice}
\index[dom]{OpenMathDevice!Domain}
\index[dom]{Domain!OpenMathDevice}
\index[dom]{OMDEV}
\begin{chunk}{defclass OpenMathDeviceType}
(defclass |OpenMathDeviceType| (|AxiomClass|)
  ((parents :initform '())
   (name :initform "OpenMathDevice")
   (marker :initform 'domain)
   (abbreviation :initform 'OMDEV)
   (comment :initform (list
     "OpenMathDevice provides support for reading"
     "and writing openMath objects to files, strings etc.  It also provides"
     "access to low-level operations from within the interpreter."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OpenMathDevice|
  (progn
    (push '|OpenMathDevice| *Domains*)
    (make-instance '|OpenMathDeviceType|)))

\end{chunk}

\subsection{OpenMathEncoding}
\index[dom]{OpenMathEncoding!Domain}
\index[dom]{Domain!OpenMathEncoding}
\index[dom]{OMENC}
\begin{chunk}{defclass OpenMathEncodingType}
(defclass |OpenMathEncodingType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "OpenMathEncoding")
   (marker :initform 'domain)
   (abbreviation :initform 'OMENC)
   (comment :initform (list
     "OpenMathEncoding is the set of valid OpenMath encodings."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OpenMathEncoding|
  (progn
    (push '|OpenMathEncoding| *Domains*)
    (make-instance '|OpenMathEncodingType|)))

\end{chunk}

\subsection{OpenMathError}
\index[dom]{OpenMathError!Domain}
\index[dom]{Domain!OpenMathError}
\index[dom]{OMERR}
\begin{chunk}{defclass OpenMathErrorType}
(defclass |OpenMathErrorType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "OpenMathError")
   (marker :initform 'domain)
   (abbreviation :initform 'OMERR)
   (comment :initform (list
     "OpenMathError is the domain of OpenMath errors."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OpenMathError|
  (progn
    (push '|OpenMathError| *Domains*)
    (make-instance '|OpenMathErrorType|)))

\end{chunk}

\subsection{OpenMathErrorKind}
\index[dom]{OpenMathErrorKind!Domain}
\index[dom]{Domain!OpenMathErrorKind}
\index[dom]{OMERRK}
\begin{chunk}{defclass OpenMathErrorKindType}
(defclass |OpenMathErrorKindType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "OpenMathErrorKind")
   (marker :initform 'domain)
   (abbreviation :initform 'OMERRK)
   (comment :initform (list
     "OpenMathErrorKind represents different kinds"
     "of OpenMath errors: specifically parse errors, unknown CD or symbol"
     "errors, and read errors."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OpenMathErrorKind|
  (progn
    (push '|OpenMathErrorKind| *Domains*)
    (make-instance '|OpenMathErrorKindType|)))

\end{chunk}

\subsection{Operator}
\index[dom]{Operator!Domain}
\index[dom]{Domain!Operator}
\index[dom]{OP}
\begin{chunk}{defclass OperatorType}
(defclass |OperatorType| (|AlgebraType|
                          |CharacteristicNonZeroType|
                          |CharacteristicZeroType|
                          |EltableType|
                          |RetractableToType|)
  ((parents :initform '(|Algebra|
                        |CharacteristicNonZero|
                        |CharacteristicZero|
                        |Eltable|
                        |RetractableTo|))
   (name :initform "Operator")
   (marker :initform 'domain)
   (abbreviation :initform 'OP)
   (comment :initform (list
     "Algebra of ADDITIVE operators over a ring."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Operator|
  (progn
    (push '|Operator| *Domains*)
    (make-instance '|OperatorType|)))

\end{chunk}

\subsection{OppositeMonogenicLinearOperator}
\index[dom]{OppositeMonogenicLinearOperator!Domain}
\index[dom]{Domain!OppositeMonogenicLinearOperator}
\index[dom]{OMLO}
\begin{chunk}{defclass OppositeMonogenicLinearOperatorType}
(defclass |OppositeMonogenicLinearOperatorType| (|DifferentialRingType|
                                                 |MonogenicLinearOperatorType|)
  ((parents :initform '(|DifferentialRing| |MonogenicLinearOperator|))
   (name :initform "OppositeMonogenicLinearOperator")
   (marker :initform 'domain)
   (abbreviation :initform 'OMLO)
   (comment :initform (list
     "This constructor creates the MonogenicLinearOperator domain"
     "which is 'opposite' in the ring sense to P."
     "That is, as sets P = $ but a * b in $ is equal to"
     "b * a in P."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OppositeMonogenicLinearOperator|
  (progn
    (push '|OppositeMonogenicLinearOperator| *Domains*)
    (make-instance '|OppositeMonogenicLinearOperatorType|)))

\end{chunk}

\subsection{OrderedCompletion}
\index[dom]{OrderedCompletion!Domain}
\index[dom]{Domain!OrderedCompletion}
\index[dom]{ORDCOMP}
\begin{chunk}{defclass OrderedCompletionType}
(defclass |OrderedCompletionType| (|OrderedRingType| |FullyRetractableToType|)
  ((parents :initform '(|OrderedRing| |FullyRetractableTo|))
   (name :initform "OrderedCompletion")
   (marker :initform 'domain)
   (abbreviation :initform 'ORDCOMP)
   (comment :initform (list
     "Completion with + and - infinity."
     "Adjunction of two real infinites quantities to a set."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedCompletion|
  (progn
    (push '|OrderedCompletion| *Domains*)
    (make-instance '|OrderedCompletionType|)))

\end{chunk}

\subsection{OrderedDirectProduct}
\index[dom]{OrderedDirectProduct!Domain}
\index[dom]{Domain!OrderedDirectProduct}
\index[dom]{ODP}
\begin{chunk}{defclass OrderedDirectProductType}
(defclass |OrderedDirectProductType| (|DirectProductCategoryType|)
  ((parents :initform '(|DirectProductCategory|))
   (name :initform "OrderedDirectProduct")
   (marker :initform 'domain)
   (abbreviation :initform 'ODP)
   (comment :initform nil)
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedDirectProduct|
  (progn
    (push '|OrderedDirectProduct| *Domains*)
    (make-instance '|OrderedDirectProductType|)))

\end{chunk}

\subsection{OrderedFreeMonoid}
\index[dom]{OrderedFreeMonoid!Domain}
\index[dom]{Domain!OrderedFreeMonoid}
\index[dom]{OFMONOID}
\begin{chunk}{defclass OrderedFreeMonoidType}
(defclass |OrderedFreeMonoidType| (|RetractableToType| |OrderedMonoidType|)
  ((parents :initform '(|RetractableTo| |OrderedMonoid|))
   (name :initform "OrderedFreeMonoid")
   (marker :initform 'domain)
   (abbreviation :initform 'OFMONOID)
   (comment :initform (list
     "The free monoid on a set S is the monoid of finite products of"
     "the form reduce(*,[si ** ni]) where the si's are in S, and the ni's"
     "are non-negative integers. The multiplication is not commutative."
     "For two elements x and y the relation x < y"
     "holds if either length(x) < length(y) holds or if these lengths"
     "are equal and if x is smaller than y w.r.t. the"
     "lexicographical ordering induced by S."
     "This domain inherits implementation from FreeMonoid."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedFreeMonoid|
  (progn
    (push '|OrderedFreeMonoid| *Domains*)
    (make-instance '|OrderedFreeMonoidType|)))

\end{chunk}

\subsection{OrderedVariableList}
\index[dom]{OrderedVariableList!Domain}
\index[dom]{Domain!OrderedVariableList}
\index[dom]{OVAR}
\begin{chunk}{defclass OrderedVariableListType}
(defclass |OrderedVariableListType| (|ConvertibleToType| |OrderedFiniteType|)
  ((parents :initform '(|ConvertibleTo| |OrderedFinite|))
   (name :initform "OrderedVariableList")
   (marker :initform 'domain)
   (abbreviation :initform 'OVAR)
   (comment :initform (list
     "This domain implements ordered variables"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedVariableList|
  (progn
    (push '|OrderedVariableList| *Domains*)
    (make-instance '|OrderedVariableListType|)))

\end{chunk}

\subsection{OrderlyDifferentialPolynomial}
\index[dom]{OrderlyDifferentialPolynomial!Domain}
\index[dom]{Domain!OrderlyDifferentialPolynomial}
\index[dom]{ODPOL}
\begin{chunk}{defclass OrderlyDifferentialPolynomialType}
(defclass |OrderlyDifferentialPolynomialType| (|DifferentialPolynomialCategoryType|)
  ((parents :initform '(|DifferentialPolynomialCategory|))
   (name :initform "OrderlyDifferentialPolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'ODPOL)
   (comment :initform (list
     "OrderlyDifferentialPolynomial implements"
     "an ordinary differential polynomial ring in arbitrary number"
     "of differential indeterminates, with coefficients in a"
     "ring.  The ranking on the differential indeterminate is orderly."
     "This is analogous to the domain Polynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderlyDifferentialPolynomial|
  (progn
    (push '|OrderlyDifferentialPolynomial| *Domains*)
    (make-instance '|OrderlyDifferentialPolynomialType|)))

\end{chunk}

\subsection{OrderlyDifferentialVariable}
\index[dom]{OrderlyDifferentialVariable!Domain}
\index[dom]{Domain!OrderlyDifferentialVariable}
\index[dom]{ODVAR}
\begin{chunk}{defclass OrderlyDifferentialVariableType}
(defclass |OrderlyDifferentialVariableType| (|DifferentialVariableCategoryType|)
  ((parents :initform '(|DifferentialVariableCategory|))
   (name :initform "OrderlyDifferentialVariable")
   (marker :initform 'domain)
   (abbreviation :initform 'ODVAR)
   (comment :initform (list
     "OrderlyDifferentialVariable adds a commonly used orderly"
     "ranking to the set of derivatives of an ordered list of differential"
     "indeterminates.  An orderly ranking is a ranking < of the"
     "derivatives with the property that for two derivatives u and v,"
     "u < v if the order of u is less than that of v."
     "This domain belongs to DifferentialVariableCategory.  It"
     "defines weight to be just order, and it"
     "defines an orderly ranking < on derivatives u via the"
     "lexicographic order on the pair"
     "(order(u), variable}(u)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderlyDifferentialVariable|
  (progn
    (push '|OrderlyDifferentialVariable| *Domains*)
    (make-instance '|OrderlyDifferentialVariableType|)))

\end{chunk}

\subsection{OrdinaryDifferentialRing}
\index[dom]{OrdinaryDifferentialRing!Domain}
\index[dom]{Domain!OrdinaryDifferentialRing}
\index[dom]{ODR}
\begin{chunk}{defclass OrdinaryDifferentialRingType}
(defclass |OrdinaryDifferentialRingType| (|FieldType| |DifferentialRingType|)
  ((parents :initform '(|Field| |DifferentialRing|))
   (name :initform "OrdinaryDifferentialRing")
   (marker :initform 'domain)
   (abbreviation :initform 'ODR)
   (comment :initform (list
     "This constructor produces an ordinary differential ring from"
     "a partial differential ring by specifying a variable."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrdinaryDifferentialRing|
  (progn
    (push '|OrdinaryDifferentialRing| *Domains*)
    (make-instance '|OrdinaryDifferentialRingType|)))

\end{chunk}

\subsection{OrdinaryWeightedPolynomials}
\index[dom]{OrdinaryWeightedPolynomials!Domain}
\index[dom]{Domain!OrdinaryWeightedPolynomials}
\index[dom]{OWP}
\begin{chunk}{defclass OrdinaryWeightedPolynomialsType}
(defclass |OrdinaryWeightedPolynomialsType| (|AlgebraType|)
  ((parents :initform '(|Algebra|))
   (name :initform "OrdinaryWeightedPolynomials")
   (marker :initform 'domain)
   (abbreviation :initform 'OWP)
   (comment :initform (list
     "This domain represents truncated weighted polynomials over the"
     "'Polynomial' type. The variables must be"
     "specified, as must the weights."
     "The representation is sparse"
     "in the sense that only non-zero terms are represented."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrdinaryWeightedPolynomials|
  (progn
    (push '|OrdinaryWeightedPolynomials| *Domains*)
    (make-instance '|OrdinaryWeightedPolynomialsType|)))

\end{chunk}

\subsection{OrdSetInts}
\index[dom]{OrdSetInts!Domain}
\index[dom]{Domain!OrdSetInts}
\index[dom]{OSI}
\begin{chunk}{defclass OrdSetIntsType}
(defclass |OrdSetIntsType| (|OrderedSetType|)
  ((parents :initform '(|OrderedSet|))
   (name :initform "OrdSetInts")
   (marker :initform 'domain)
   (abbreviation :initform 'OSI)
   (comment :initform (list
     "A domain used in order to take the free R-module on the"
     "Integers I.  This is actually the forgetful functor from OrderedRings"
     "to OrderedSets applied to I"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrdSetInts|
  (progn
    (push '|OrdSetInts| *Domains*)
    (make-instance '|OrdSetIntsType|)))

\end{chunk}

\subsection{OutputForm}
\index[dom]{OutputForm!Domain}
\index[dom]{Domain!OutputForm}
\index[dom]{OUTFORM}
\begin{chunk}{defclass OutputFormType}
(defclass |OutputFormType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "OutputForm")
   (marker :initform 'domain)
   (abbreviation :initform 'OUTFORM)
   (comment :initform (list
     "This domain is used to create and manipulate mathematical expressions"
     "for output.  It is intended to provide an insulating layer between"
     "the expression rendering software (for example, FORTRAN or TeX) and"
     "the output coercions in the various domains."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OutputForm|
  (progn
    (push '|OutputForm| *Domains*)
    (make-instance '|OutputFormType|)))

\end{chunk}

\section{P}

\subsection{PAdicInteger}
\index[dom]{PAdicInteger!Domain}
\index[dom]{Domain!PAdicInteger}
\index[dom]{PADIC}
\begin{chunk}{defclass PAdicIntegerType}
(defclass |PAdicIntegerType| (|PAdicIntegerCategoryType|)
  ((parents :initform '(|PAdicIntegerCategory|))
   (name :initform "PAdicInteger")
   (marker :initform 'domain)
   (abbreviation :initform 'PADIC)
   (comment :initform (list
     "Stream-based implementation of Zp: p-adic numbers are represented as"
     "sum(i = 0.., a[i] * p^i), where the a[i] lie in 0,1,...,(p - 1)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PAdicInteger|
  (progn
    (push '|PAdicInteger| *Domains*)
    (make-instance '|PAdicIntegerType|)))

\end{chunk}

\subsection{PAdicRational}
\index[dom]{PAdicRational!Domain}
\index[dom]{Domain!PAdicRational}
\index[dom]{PADICRAT}
\begin{chunk}{defclass PAdicRationalType}
(defclass |PAdicRationalType| (|QuotientFieldCategoryType|)
  ((parents :initform '(|QuotientFieldCategory|))
   (name :initform "PAdicRational")
   (marker :initform 'domain)
   (abbreviation :initform 'PADICRAT)
   (comment :initform (list
     "Stream-based implementation of Qp: numbers are represented as"
     " sum(i = k.., a[i] * p^i) where the a[i] lie in 0,1,...,(p - 1)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PAdicRational|
  (progn
    (push '|PAdicRational| *Domains*)
    (make-instance '|PAdicRationalType|)))

\end{chunk}

\subsection{PAdicRationalConstructor}
\index[dom]{PAdicRationalConstructor!Domain}
\index[dom]{Domain!PAdicRationalConstructor}
\index[dom]{PADICRC}
\begin{chunk}{defclass PAdicRationalConstructorType}
(defclass |PAdicRationalConstructorType| (|QuotientFieldCategoryType|)
  ((parents :initform '(|QuotientFieldCategory|))
   (name :initform "PAdicRationalConstructor")
   (marker :initform 'domain)
   (abbreviation :initform 'PADICRC)
   (comment :initform (list
     "This is the category of stream-based representations of Qp."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PAdicRationalConstructor|
  (progn
    (push '|PAdicRationalConstructor| *Domains*)
    (make-instance '|PAdicRationalConstructorType|)))

\end{chunk}

\subsection{Palette}
\index[dom]{Palette!Domain}
\index[dom]{Domain!Palette}
\index[dom]{PALETTE}
\begin{chunk}{defclass PaletteType}
(defclass |PaletteType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "Palette")
   (marker :initform 'domain)
   (abbreviation :initform 'PALETTE)
   (comment :initform (list
     "This domain describes four groups of color shades (palettes)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Palette|
  (progn
    (push '|Palette| *Domains*)
    (make-instance '|PaletteType|)))

\end{chunk}

\subsection{ParametricPlaneCurve}
\index[dom]{ParametricPlaneCurve!Domain}
\index[dom]{Domain!ParametricPlaneCurve}
\index[dom]{PARPCURV}
\begin{chunk}{defclass ParametricPlaneCurveType}
(defclass |ParametricPlaneCurveType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ParametricPlaneCurve")
   (marker :initform 'domain)
   (abbreviation :initform 'PARPCURV)
   (comment :initform (list
     "ParametricPlaneCurve is used for plotting parametric plane"
     "curves in the affine plane."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ParametricPlaneCurve|
  (progn
    (push '|ParametricPlaneCurve| *Domains*)
    (make-instance '|ParametricPlaneCurveType|)))

\end{chunk}

\subsection{ParametricSpaceCurve}
\index[dom]{ParametricSpaceCurve!Domain}
\index[dom]{Domain!ParametricSpaceCurve}
\index[dom]{PARSCURV}
\begin{chunk}{defclass ParametricSpaceCurveType}
(defclass |ParametricSpaceCurveType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ParametricSpaceCurve")
   (marker :initform 'domain)
   (abbreviation :initform 'PARSCURV)
   (comment :initform (list
     "ParametricSpaceCurve is used for plotting parametric space"
     "curves in affine 3-space."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ParametricSpaceCurve|
  (progn
    (push '|ParametricSpaceCurve| *Domains*)
    (make-instance '|ParametricSpaceCurveType|)))

\end{chunk}

\subsection{ParametricSurface}
\index[dom]{ParametricSurface!Domain}
\index[dom]{Domain!ParametricSurface}
\index[dom]{PARSURF}
\begin{chunk}{defclass ParametricSurfaceType}
(defclass |ParametricSurfaceType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ParametricSurface")
   (marker :initform 'domain)
   (abbreviation :initform 'PARSURF)
   (comment :initform (list
     "ParametricSurface is used for plotting parametric surfaces in"
     "affine 3-space."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ParametricSurface|
  (progn
    (push '|ParametricSurface| *Domains*)
    (make-instance '|ParametricSurfaceType|)))

\end{chunk}

\subsection{PartialFraction}
\index[dom]{PartialFraction!Domain}
\index[dom]{Domain!PartialFraction}
\index[dom]{PFR}
\begin{chunk}{defclass PartialFractionType}
(defclass |PartialFractionType| (|FieldType|)
  ((parents :initform '(|Field|))
   (name :initform "PartialFraction")
   (marker :initform 'domain)
   (abbreviation :initform 'PFR)
   (comment :initform (list
     "The domain PartialFraction implements partial fractions"
     "over a euclidean domain R. This requirement on the"
     "argument domain allows us to normalize the fractions.  Of"
     "particular interest are the 2 forms for these fractions.  The"
     "``compact'' form has only one fractional term per prime in the"
     "denominator, while the ``p-adic'' form expands each numerator"
     "p-adically via the prime p in the denominator.  For computational"
     "efficiency, the compact form is used, though the p-adic form may"
     "be gotten by calling the function padicFraction}.  For a"
     "general euclidean domain, it is not known how to factor the"
     "denominator.  Thus the function partialFraction takes as its"
     "second argument an element of Factored(R)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PartialFraction|
  (progn
    (push '|PartialFraction| *Domains*)
    (make-instance '|PartialFractionType|)))

\end{chunk}

\subsection{Partition}
\index[dom]{Partition!Domain}
\index[dom]{Domain!Partition}
\index[dom]{PRTITION}
\begin{chunk}{defclass PartitionType}
(defclass |PartitionType| (|ConvertibleToType| |OrderedCancellationAbelianMonoidType|)
  ((parents :initform '(|ConvertibleTo| |OrderedCancellationAbelianMonoid|))
   (name :initform "Partition")
   (marker :initform 'domain)
   (abbreviation :initform 'PRTITION)
   (comment :initform (list
     "Partition is an OrderedCancellationAbelianMonoid which is used"
     "as the basis for symmetric polynomial representation of the"
     "sums of powers in SymmetricPolynomial.  Thus, (5 2 2 1) will"
     "represent s5 * s2**2 * s1."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Partition|
  (progn
    (push '|Partition| *Domains*)
    (make-instance '|PartitionType|)))

\end{chunk}

\subsection{Pattern}
\index[dom]{Pattern!Domain}
\index[dom]{Domain!Pattern}
\index[dom]{PATTERN}
\begin{chunk}{defclass PatternType}
(defclass |PatternType| (|SetCategoryType| |RetractableToType|)
  ((parents :initform '(|SetCategory| |RetractableTo|))
   (name :initform "Pattern")
   (marker :initform 'domain)
   (abbreviation :initform 'PATTERN)
   (comment :initform (list
     "Patterns for use by the pattern matcher."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Pattern|
  (progn
    (push '|Pattern| *Domains*)
    (make-instance '|PatternType|)))

\end{chunk}

\subsection{PatternMatchListResult}
\index[dom]{PatternMatchListResult!Domain}
\index[dom]{Domain!PatternMatchListResult}
\index[dom]{PATLRES}
\begin{chunk}{defclass PatternMatchListResultType}
(defclass |PatternMatchListResultType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "PatternMatchListResult")
   (marker :initform 'domain)
   (abbreviation :initform 'PATLRES)
   (comment :initform (list
     "A PatternMatchListResult is an object internally returned by the"
     "pattern matcher when matching on lists."
     "It is either a failed match, or a pair of PatternMatchResult,"
     "one for atoms (elements of the list), and one for lists."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatchListResult|
  (progn
    (push '|PatternMatchListResult| *Domains*)
    (make-instance '|PatternMatchListResultType|)))

\end{chunk}

\subsection{PatternMatchResult}
\index[dom]{PatternMatchResult!Domain}
\index[dom]{Domain!PatternMatchResult}
\index[dom]{PATRES}
\begin{chunk}{defclass PatternMatchResultType}
(defclass |PatternMatchResultType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "PatternMatchResult")
   (marker :initform 'domain)
   (abbreviation :initform 'PATRES)
   (comment :initform (list
     "A PatternMatchResult is an object internally returned by the"
     "pattern matcher; It is either a failed match, or a list of"
     "matches of the form (var, expr) meaning that the variable var"
     "matches the expression expr."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatchResult|
  (progn
    (push '|PatternMatchResult| *Domains*)
    (make-instance '|PatternMatchResultType|)))

\end{chunk}

\subsection{PendantTree}
\index[dom]{PendantTree!Domain}
\index[dom]{Domain!PendantTree}
\index[dom]{PENDTREE}
\begin{chunk}{defclass PendantTreeType}
(defclass |PendantTreeType| (|BinaryRecursiveAggregateType|)
  ((parents :initform '(|BinaryRecursiveAggregate|))
   (name :initform "PendantTree")
   (marker :initform 'domain)
   (abbreviation :initform 'PENDTREE)
   (comment :initform (list
     "A PendantTree(S) is either a leaf? and is an S or has"
     "a left and a right both PendantTree(S)'s"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PendantTree|
  (progn
    (push '|PendantTree| *Domains*)
    (make-instance '|PendantTreeType|)))

\end{chunk}

\subsection{Permutation}
\index[dom]{Permutation!Domain}
\index[dom]{Domain!Permutation}
\index[dom]{PERM}
\begin{chunk}{defclass PermutationType}
(defclass |PermutationType| (|PermutationCategoryType|)
  ((parents :initform '(|PermutationCategory|))
   (name :initform "Permutation")
   (marker :initform 'domain)
   (abbreviation :initform 'PERM)
   (comment :initform (list
     "Permutation(S) implements the group of all bijections"
     "on a set S, which move only a finite number of points."
     "A permutation is considered as a map from S into S. In particular"
     "multiplication is defined as composition of maps:"
     "pi1 * pi2 = pi1 o pi2."
     "The internal representation of permuatations are two lists"
     "of equal length representing preimages and images."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Permutation|
  (progn
    (push '|Permutation| *Domains*)
    (make-instance '|PermutationType|)))

\end{chunk}

\subsection{PermutationGroup}
\index[dom]{PermutationGroup!Domain}
\index[dom]{Domain!PermutationGroup}
\index[dom]{PERMGRP}
\begin{chunk}{defclass PermutationGroupType}
(defclass |PermutationGroupType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "PermutationGroup")
   (marker :initform 'domain)
   (abbreviation :initform 'PERMGRP)
   (comment :initform (list
     "PermutationGroup implements permutation groups acting"
     "on a set S, all subgroups of the symmetric group of S,"
     "represented as a list of permutations (generators). Note that"
     "therefore the objects are not members of the Axiom category"
     "Group."
     "Using the idea of base and strong generators by Sims,"
     "basic routines and algorithms"
     "are implemented so that the word problem for"
     "permutation groups can be solved."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PermutationGroup|
  (progn
    (push '|PermutationGroup| *Domains*)
    (make-instance '|PermutationGroupType|)))

\end{chunk}

\subsection{Pi}
\index[dom]{Pi!Domain}
\index[dom]{Domain!Pi}
\index[dom]{HACKPI}
\begin{chunk}{defclass PiType}
(defclass |PiType| (|CharacteristicZeroType|
                    |FieldType|
                    |RealConstantType|
                    |RetractableToType|)
  ((parents :initform '(|CharacteristicZero|
                        |Field|
                        |RealConstant|
                        |RetractableTo|))
   (name :initform "Pi")
   (marker :initform 'domain)
   (abbreviation :initform 'HACKPI)
   (comment :initform (list
     "Symbolic fractions in %pi with integer coefficients;"
     "The point for using Pi as the default domain for those fractions"
     "is that Pi is coercible to the float types, and not Expression."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Pi|
  (progn
    (push '|Pi| *Domains*)
    (make-instance '|PiType|)))

\end{chunk}

\subsection{PlaneAlgebraicCurvePlot}
\index[dom]{PlaneAlgebraicCurvePlot!Domain}
\index[dom]{Domain!PlaneAlgebraicCurvePlot}
\index[dom]{ACPLOT}
\begin{chunk}{defclass PlaneAlgebraicCurvePlotType}
(defclass |PlaneAlgebraicCurvePlotType| (|PlottablePlaneCurveCategoryType|)
  ((parents :initform '(|PlottablePlaneCurveCategory|))
   (name :initform "PlaneAlgebraicCurvePlot")
   (marker :initform 'domain)
   (abbreviation :initform 'ACPLOT)
   (comment :initform (list
     "Plot a NON-SINGULAR plane algebraic curve p(x,y) = 0."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PlaneAlgebraicCurvePlot|
  (progn
    (push '|PlaneAlgebraicCurvePlot| *Domains*)
    (make-instance '|PlaneAlgebraicCurvePlotType|)))

\end{chunk}

\subsection{Places}
\index[dom]{Places!Domain}
\index[dom]{Domain!Places}
\index[dom]{PLACES}
\begin{chunk}{defclass PlacesType}
(defclass |PlacesType| (|PlacesCategoryType|)
  ((parents :initform '(|PlacesCategory|))
   (name :initform "Places")
   (marker :initform 'domain)
   (abbreviation :initform 'PLACES)
   (comment :initform (list
     "The following is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Places|
  (progn
    (push '|Places| *Domains*)
    (make-instance '|PlacesType|)))

\end{chunk}

\subsection{PlacesOverPseudoAlgebraicClosureOfFiniteField}
\index[dom]{PlacesOverPseudoAlgebraicClosureOfFiniteField!Domain}
\index[dom]{Domain!PlacesOverPseudoAlgebraicClosureOfFiniteField}
\index[dom]{PLACESPS}
\begin{chunk}{defclass PlacesOverPseudoAlgebraicClosureOfFiniteFieldType}
(defclass |PlacesOverPseudoAlgebraicClosureOfFiniteFieldType| (|PlacesCategoryType|)
  ((parents :initform '(|PlacesCategory|))
   (name :initform "PlacesOverPseudoAlgebraicClosureOfFiniteField")
   (marker :initform 'domain)
   (abbreviation :initform 'PLACESPS)
   (comment :initform (list
     "The following is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PlacesOverPseudoAlgebraicClosureOfFiniteField|
  (progn
    (push '|PlacesOverPseudoAlgebraicClosureOfFiniteField| *Domains*)
    (make-instance '|PlacesOverPseudoAlgebraicClosureOfFiniteFieldType|)))

\end{chunk}

\subsection{Plcs}
\index[dom]{Plcs!Domain}
\index[dom]{Domain!Plcs}
\index[dom]{PLCS}
\begin{chunk}{defclass PlcsType}
(defclass |PlcsType| (|PlacesCategoryType|)
  ((parents :initform '(|PlacesCategory|))
   (name :initform "Plcs")
   (marker :initform 'domain)
   (abbreviation :initform 'PLCS)
   (comment :initform (list
     "The following is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Plcs|
  (progn
    (push '|Plcs| *Domains*)
    (make-instance '|PlcsType|)))

\end{chunk}

\subsection{Plot}
\index[dom]{Plot!Domain}
\index[dom]{Domain!Plot}
\index[dom]{PLOT}
\begin{chunk}{defclass PlotType}
(defclass |PlotType| (|PlottablePlaneCurveCategoryType|)
  ((parents :initform '(|PlottablePlaneCurveCategory|))
   (name :initform "Plot")
   (marker :initform 'domain)
   (abbreviation :initform 'PLOT)
   (comment :initform (list
     "The Plot domain supports plotting of functions defined over a"
     "real number system.  A real number system is a model for the real"
     "numbers and as such may be an approximation.  For example"
     "floating point numbers and infinite continued fractions."
     "The facilities at this point are limited to 2-dimensional plots"
     "or either a single function or a parametric function."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Plot|
  (progn
    (push '|Plot| *Domains*)
    (make-instance '|PlotType|)))

\end{chunk}

\subsection{Plot3D}
\index[dom]{Plot3D!Domain}
\index[dom]{Domain!Plot3D}
\index[dom]{PLOT3D}
\begin{chunk}{defclass Plot3DType}
(defclass |Plot3DType| (|PlottableSpaceCurveCategoryType|)
  ((parents :initform '(|PlottableSpaceCurveCategory|))
   (name :initform "Plot3D")
   (marker :initform 'domain)
   (abbreviation :initform 'PLOT3D)
   (comment :initform (list
     "Plot3D supports parametric plots defined over a real"
     "number system.  A real number system is a model for the real"
     "numbers and as such may be an approximation.  For example,"
     "floating point numbers and infinite continued fractions are"
     "real number systems. The facilities at this point are limited"
     "to 3-dimensional parametric plots."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Plot3D|
  (progn
    (push '|Plot3D| *Domains*)
    (make-instance '|Plot3DType|)))

\end{chunk}

\subsection{PoincareBirkhoffWittLyndonBasis}
\index[dom]{PoincareBirkhoffWittLyndonBasis!Domain}
\index[dom]{Domain!PoincareBirkhoffWittLyndonBasis}
\index[dom]{PBWLB}
\begin{chunk}{defclass PoincareBirkhoffWittLyndonBasisType}
(defclass |PoincareBirkhoffWittLyndonBasisType| (|OrderedSetType| |RetractableToType|)
  ((parents :initform '(|OrderedSet| |RetractableTo|))
   (name :initform "PoincareBirkhoffWittLyndonBasis")
   (marker :initform 'domain)
   (abbreviation :initform 'PBWLB)
   (comment :initform (list
     "This domain provides the internal representation"
     "of polynomials in non-commutative variables written"
     "over the Poincare-Birkhoff-Witt basis."
     "See the XPBWPolynomial domain constructor."
     "See Free Lie Algebras by C. Reutenauer "))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PoincareBirkhoffWittLyndonBasis|
  (progn
    (push '|PoincareBirkhoffWittLyndonBasis| *Domains*)
    (make-instance '|PoincareBirkhoffWittLyndonBasisType|)))

\end{chunk}

\subsection{Point}
\index[dom]{Point!Domain}
\index[dom]{Domain!Point}
\index[dom]{POINT}
\begin{chunk}{defclass PointType}
(defclass |PointType| (|PointCategoryType|)
  ((parents :initform '(|PointCategory|))
   (name :initform "Point")
   (marker :initform 'domain)
   (abbreviation :initform 'POINT)
   (comment :initform (list
     "This domain implements points in coordinate space"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Point|
  (progn
    (push '|Point| *Domains*)
    (make-instance '|PointType|)))

\end{chunk}

\subsection{Polynomial}
\index[dom]{Polynomial!Domain}
\index[dom]{Domain!Polynomial}
\index[dom]{POLY}
\begin{chunk}{defclass PolynomialType}
(defclass |PolynomialType| (|PolynomialCategoryType|)
  ((parents :initform '(|PolynomialCategory|))
   (name :initform "Polynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'POLY)
   (comment :initform (list
     "This type is the basic representation of sparse recursive multivariate"
     "polynomials whose variables are arbitrary symbols. The ordering"
     "is alphabetic determined by the Symbol type."
     "The coefficient ring may be non commutative,"
     "but the variables are assumed to commute."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Polynomial|
  (progn
    (push '|Polynomial| *Domains*)
    (make-instance '|PolynomialType|)))

\end{chunk}

\subsection{PolynomialIdeals}
\index[dom]{PolynomialIdeals!Domain}
\index[dom]{Domain!PolynomialIdeals}
\index[dom]{IDEAL}
\begin{chunk}{defclass PolynomialIdealsType}
(defclass |PolynomialIdealsType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "PolynomialIdeals")
   (marker :initform 'domain)
   (abbreviation :initform 'IDEAL)
   (comment :initform (list
     "This domain represents polynomial ideals with coefficients in any"
     "field and supports the basic ideal operations, including intersection"
     "sum and quotient."
     "An ideal is represented by a list of polynomials (the generators of"
     "the ideal) and a boolean that is true if the generators are a Groebner"
     "basis."
     "The algorithms used are based on Groebner basis computations. The"
     "ordering is determined by the datatype of the input polynomials."
     "Users may use refinements of total degree orderings."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialIdeals|
  (progn
    (push '|PolynomialIdeals| *Domains*)
    (make-instance '|PolynomialIdealsType|)))

\end{chunk}

\subsection{PolynomialRing}
\index[dom]{PolynomialRing!Domain}
\index[dom]{Domain!PolynomialRing}
\index[dom]{PR}
\begin{chunk}{defclass PolynomialRingType}
(defclass |PolynomialRingType| (|FiniteAbelianMonoidRingType|)
  ((parents :initform '(|FiniteAbelianMonoidRing|))
   (name :initform "PolynomialRing")
   (marker :initform 'domain)
   (abbreviation :initform 'PR)
   (comment :initform (list
     "This domain represents generalized polynomials with coefficients"
     "(from a not necessarily commutative ring), and terms"
     "indexed by their exponents (from an arbitrary ordered abelian monoid)."
     "This type is used, for example,"
     "by the DistributedMultivariatePolynomial domain where"
     "the exponent domain is a direct product of non negative integers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialRing|
  (progn
    (push '|PolynomialRing| *Domains*)
    (make-instance '|PolynomialRingType|)))

\end{chunk}

\subsection{PositiveInteger}
\index[dom]{PositiveInteger!Domain}
\index[dom]{Domain!PositiveInteger}
\index[dom]{PI}
\begin{chunk}{defclass PositiveIntegerType}
(defclass |PositiveIntegerType| (|OrderedSetType| |MonoidType| |AbelianSemiGroupType|)
  ((parents :initform '(|OrderedSet| |Monoid| |AbelianSemiGroup|))
   (name :initform "PositiveInteger")
   (marker :initform 'domain)
   (abbreviation :initform 'PI)
   (comment :initform (list
     "PositiveInteger provides functions for positive integers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PositiveInteger|
  (progn
    (push '|PositiveInteger| *Domains*)
    (make-instance '|PositiveIntegerType|)))

\end{chunk}

\subsection{PrimeField}
\index[dom]{PrimeField!Domain}
\index[dom]{Domain!PrimeField}
\index[dom]{PF}
\begin{chunk}{defclass PrimeFieldType}
(defclass |PrimeFieldType| (|ConvertibleToType|
                            |FiniteAlgebraicExtensionFieldType|)
  ((parents :initform '(|ConvertibleTo| 
                        |FiniteAlgebraicExtensionField|))
   (name :initform "PrimeField")
   (marker :initform 'domain)
   (abbreviation :initform 'PF)
   (comment :initform (list
     "PrimeField(p) implements the field with p elements if p is a prime number."
     "Error: if p is not prime."
     "Note: this domain does not check that argument is a prime."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PrimeField|
  (progn
    (push '|PrimeField| *Domains*)
    (make-instance '|PrimeFieldType|)))

\end{chunk}

\subsection{PrimitiveArray}
\index[dom]{PrimitiveArray!Domain}
\index[dom]{Domain!PrimitiveArray}
\index[dom]{PRIMARR}
\begin{chunk}{defclass PrimitiveArrayType}
(defclass |PrimitiveArrayType| (|OneDimensionalArrayAggregateType|)
  ((parents :initform '(|OneDimensionalArrayAggregate|))
   (name :initform "PrimitiveArray")
   (marker :initform 'domain)
   (abbreviation :initform 'PRIMARR)
   (comment :initform (list
     "This provides a fast array type with no bound checking on elt's."
     "Minimum index is 0 in this type, cannot be changed"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PrimitiveArray|
  (progn
    (push '|PrimitiveArray| *Domains*)
    (make-instance '|PrimitiveArrayType|)))

\end{chunk}

\subsection{Product}
\index[dom]{Product!Domain}
\index[dom]{Domain!Product}
\index[dom]{PRODUCT}
\begin{chunk}{defclass ProductType}
(defclass |ProductType| (|AbelianGroupType|
                         |FiniteType|
                         |GroupType|
                         |OrderedAbelianMonoidSupType|)
  ((parents :initform '(|AbelianGroup| |Finite| |Group| |OrderedAbelianMonoidSup|))
   (name :initform "Product")
   (marker :initform 'domain)
   (abbreviation :initform 'PRODUCT)
   (comment :initform (list
     "This domain implements cartesian product"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Product|
  (progn
    (push '|Product| *Domains*)
    (make-instance '|ProductType|)))

\end{chunk}

\subsection{ProjectivePlane}
\index[dom]{ProjectivePlane!Domain}
\index[dom]{Domain!ProjectivePlane}
\index[dom]{PROJPL}
\begin{chunk}{defclass ProjectivePlaneType}
(defclass |ProjectivePlaneType| (|ProjectiveSpaceCategoryType|)
  ((parents :initform '(|ProjectiveSpaceCategory|))
   (name :initform "ProjectivePlane")
   (marker :initform 'domain)
   (abbreviation :initform 'PROJPL)
   (comment :initform (list
     "This is part of the PAFF package, related to projective space."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ProjectivePlane|
  (progn
    (push '|ProjectivePlane| *Domains*)
    (make-instance '|ProjectivePlaneType|)))

\end{chunk}

\subsection{ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteField}
\index[dom]{ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteField!Domain}
\index[dom]{Domain!ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteField}
\index[dom]{PROJPLPS}
\begin{chunk}{defclass ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteFieldType}
(defclass |ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteFieldType| (|ProjectiveSpaceCategoryType|)
  ((parents :initform '(|ProjectiveSpaceCategory|))
   (name :initform "ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteField")
   (marker :initform 'domain)
   (abbreviation :initform 'PROJPLPS)
   (comment :initform (list
     "This is part of the PAFF package, related to projective space."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteField|
  (progn
    (push '|ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteField| *Domains*)
    (make-instance '|ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteFieldType|)))

\end{chunk}

\subsection{ProjectiveSpace}
\index[dom]{ProjectiveSpace!Domain}
\index[dom]{Domain!ProjectiveSpace}
\index[dom]{PROJSP}
\begin{chunk}{defclass ProjectiveSpaceType}
(defclass |ProjectiveSpaceType| (|ProjectiveSpaceCategoryType|)
  ((parents :initform '(|ProjectiveSpaceCategory|))
   (name :initform "ProjectiveSpace")
   (marker :initform 'domain)
   (abbreviation :initform 'PROJSP)
   (comment :initform (list
     "This is part of the PAFF package, related to projective space."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ProjectiveSpace|
  (progn
    (push '|ProjectiveSpace| *Domains*)
    (make-instance '|ProjectiveSpaceType|)))

\end{chunk}

\subsection{PseudoAlgebraicClosureOfAlgExtOfRationalNumber}
\index[dom]{PseudoAlgebraicClosureOfAlgExtOfRationalNumber!Domain}
\index[dom]{Domain!PseudoAlgebraicClosureOfAlgExtOfRationalNumber}
\index[dom]{PACEXT}
\begin{chunk}{defclass PseudoAlgebraicClosureOfAlgExtOfRationalNumberType}
(defclass |PseudoAlgebraicClosureOfAlgExtOfRationalNumberType| (
                    |PseudoAlgebraicClosureOfAlgExtOfRationalNumberCategoryType|)
  ((parents :initform '(|PseudoAlgebraicClosureOfAlgExtOfRationalNumberCategory|))
   (name :initform "PseudoAlgebraicClosureOfAlgExtOfRationalNumber")
   (marker :initform 'domain)
   (abbreviation :initform 'PACEXT)
   (comment :initform (list
     "This domain implement dynamic extension over the"
     "PseudoAlgebraicClosureOfRationalNumber."
     "A tower extension T  of the ground field K is any sequence of field"
     "extension (T : K_0, K_1, ..., K_i...,K_n) where K_0 = K"
     "and for i =1,2,...,n, K_i is an extension of K_{i-1} of degree > 1"
     "and defined by an irreducible polynomial p(Z) in K_{i-1}."
     "Two towers (T_1: K_01, K_11,...,K_i1,...,K_n1) and "
     "(T_2: K_02, K_12,...,K_i2,...,K_n2)"
     "are said to be related if T_1 <= T_2 (or T_1 >= T_2),"
     "that is if K_i1 = K_i2 for i=1,2,...,n1"
     "(or i=1,2,...,n2). Any algebraic operations defined for several elements"
     "are only defined if all of the concerned elements are comming from"
     "a set of related tour extensions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PseudoAlgebraicClosureOfAlgExtOfRationalNumber|
  (progn
    (push '|PseudoAlgebraicClosureOfAlgExtOfRationalNumber| *Domains*)
    (make-instance '|PseudoAlgebraicClosureOfAlgExtOfRationalNumberType|)))

\end{chunk}

\subsection{PseudoAlgebraicClosureOfFiniteField}
\index[dom]{PseudoAlgebraicClosureOfFiniteField!Domain}
\index[dom]{Domain!PseudoAlgebraicClosureOfFiniteField}
\index[dom]{PACOFF}
\begin{chunk}{defclass PseudoAlgebraicClosureOfFiniteFieldType}
(defclass |PseudoAlgebraicClosureOfFiniteFieldType| (|PseudoAlgebraicClosureOfFiniteFieldCategoryType| 
                                                     |ExtensionFieldType|)
  ((parents :initform '(|PseudoAlgebraicClosureOfFiniteFieldCategory| |ExtensionField|))
   (name :initform "PseudoAlgebraicClosureOfFiniteField")
   (marker :initform 'domain)
   (abbreviation :initform 'PACOFF)
   (comment :initform (list
     "This domain implement  dynamic extension using the simple notion of"
     "tower extensions. A tower extension T  of the ground  field K is any"
     "sequence of field extension (T : K_0, K_1, ..., K_i...,K_n) where K_0 = K"
     "and for i =1,2,...,n, K_i is an extension of K_{i-1} of degree > 1 and"
     "defined by an irreducible polynomial p(Z) in K_{i-1}."
     "Two towers (T_1: K_01, K_11,...,K_i1,...,K_n1)"
     "and (T_2: K_02, K_12,...,K_i2,...,K_n2) are said to be related"
     "if T_1 <= T_2 (or T_1 >= T_2), that is if K_i1 = K_i2 for i=1,2,...,n1"
     "(or i=1,2,...,n2). Any algebraic operations defined for several elements"
     "are only defined if all of the concerned elements are comming from"
     "a set of related tour extensions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PseudoAlgebraicClosureOfFiniteField|
  (progn
    (push '|PseudoAlgebraicClosureOfFiniteField| *Domains*)
    (make-instance '|PseudoAlgebraicClosureOfFiniteFieldType|)))

\end{chunk}

\subsection{PseudoAlgebraicClosureOfRationalNumber}
\index[dom]{PseudoAlgebraicClosureOfRationalNumber!Domain}
\index[dom]{Domain!PseudoAlgebraicClosureOfRationalNumber}
\index[dom]{PACRAT}
\begin{chunk}{defclass PseudoAlgebraicClosureOfRationalNumberType}
(defclass |PseudoAlgebraicClosureOfRationalNumberType| (
                        |PseudoAlgebraicClosureOfRationalNumberCategoryType|)
  ((parents :initform '(|PseudoAlgebraicClosureOfRationalNumberCategory|))
   (name :initform "PseudoAlgebraicClosureOfRationalNumber")
   (marker :initform 'domain)
   (abbreviation :initform 'PACRAT)
   (comment :initform (list
     "++ This domain implements dynamic extension using the simple notion of"
     "tower extensions. A tower extension T of the ground field K is any"
     "sequence of field extension (T : K_0, K_1, ..., K_i...,K_n) where K_0 = K"
     "and for i =1,2,...,n, K_i is an extension of K_{i-1} of degree > 1 and"
     "defined by an irreducible polynomial p(Z) in K_{i-1}."
     "Two towers (T_1: K_01, K_11,...,K_i1,...,K_n1) and"
     "(T_2: K_02, K_12,...,K_i2,...,K_n2) are said to be related if T_1 <= T_2"
     "(or T_1 >= T_2), that is if K_i1 = K_i2 for i=1,2,...,n1"
     "(or i=1,2,...,n2). Any algebraic operations defined for several elements"
     "are only defined if all of the concerned elements are comming from"
     "a set of related tour extensions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PseudoAlgebraicClosureOfRationalNumber|
  (progn
    (push '|PseudoAlgebraicClosureOfRationalNumber| *Domains*)
    (make-instance '|PseudoAlgebraicClosureOfRationalNumberType|)))

\end{chunk}

\section{Q}

\subsection{QuadraticForm}
\index[dom]{QuadraticForm!Domain}
\index[dom]{Domain!QuadraticForm}
\index[dom]{QFORM}
\begin{chunk}{defclass QuadraticFormType}
(defclass |QuadraticFormType| (|AbelianGroupType|)
  ((parents :initform '(|AbelianGroup|))
   (name :initform "QuadraticForm")
   (marker :initform 'domain)
   (abbreviation :initform 'QFORM)
   (comment :initform (list
     "This domain provides modest support for quadratic forms."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |QuadraticForm|
  (progn
    (push '|QuadraticForm| *Domains*)
    (make-instance '|QuadraticFormType|)))

\end{chunk}

\subsection{QuasiAlgebraicSet}
\index[dom]{QuasiAlgebraicSet!Domain}
\index[dom]{Domain!QuasiAlgebraicSet}
\index[dom]{QALGSET}
\begin{chunk}{defclass QuasiAlgebraicSetType}
(defclass |QuasiAlgebraicSetType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "QuasiAlgebraicSet")
   (marker :initform 'domain)
   (abbreviation :initform 'QALGSET)
   (comment :initform (list
     "QuasiAlgebraicSet constructs a domain representing"
     "quasi-algebraic sets, which is the intersection of a Zariski"
     "closed set, defined as the common zeros of a given list of"
     "polynomials (the defining polynomials for equations), and a principal"
     "Zariski open set, defined as the complement of the common"
     "zeros of a polynomial f (the defining polynomial for the inequation)."
     "This domain provides simplification of a user-given representation"
     "using groebner basis computations."
     "There are two simplification routines: the first function"
     "idealSimplify  uses groebner"
     "basis of ideals alone, while the second, simplify uses both"
     "groebner basis and factorization.  The resulting defining equations L"
     "always form a groebner basis, and the resulting defining"
     "inequation f is always reduced.  The function simplify may"
     "be applied several times if desired.   A third simplification"
     "routine radicalSimplify is provided in"
     "QuasiAlgebraicSet2  for comparison study only,"
     "as it is inefficient compared to the other two, as well as is"
     "restricted to only certain coefficient domains.  For detail analysis"
     "and a comparison of the three methods, please consult the reference"
     "cited."
     " "
     "A polynomial function q defined on the quasi-algebraic set"
     "is equivalent to its reduced form with respect to L.  While"
     "this may be obtained using the usual normal form"
     "algorithm, there is no canonical form for q."
     " "
     "The ordering in groebner basis computation is determined by"
     "the data type of the input polynomials.  If it is possible"
     "we suggest to use refinements of total degree orderings."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |QuasiAlgebraicSet|
  (progn
    (push '|QuasiAlgebraicSet| *Domains*)
    (make-instance '|QuasiAlgebraicSetType|)))

\end{chunk}

\subsection{Quaternion}
\index[dom]{Quaternion!Domain}
\index[dom]{Domain!Quaternion}
\index[dom]{QUAT}
\begin{chunk}{defclass QuaternionType}
(defclass |QuaternionType| (|QuaternionCategoryType|)
  ((parents :initform '(|QuaternionCategory|))
   (name :initform "Quaternion")
   (marker :initform 'domain)
   (abbreviation :initform 'QUAT)
   (comment :initform (list
     "Quaternion implements quaternions over a"
     "commutative ring. The main constructor function is quatern"
     "which takes 4 arguments: the real part, the i imaginary part, the j"
     "imaginary part and the k imaginary part."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Quaternion|
  (progn
    (push '|Quaternion| *Domains*)
    (make-instance '|QuaternionType|)))

\end{chunk}

\subsection{QueryEquation}
\index[dom]{QueryEquation!Domain}
\index[dom]{Domain!QueryEquation}
\index[dom]{QEQUAT}
\begin{chunk}{defclass QueryEquationType}
(defclass |QueryEquationType| (|CoercibleToType|)
  ((parents :initform '(|CoercibleTo|))
   (name :initform "QueryEquation")
   (marker :initform 'domain)
   (abbreviation :initform 'QEQUAT)
   (comment :initform (list
     "This domain implements simple database queries"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |QueryEquation|
  (progn
    (push '|QueryEquation| *Domains*)
    (make-instance '|QueryEquationType|)))

\end{chunk}

\subsection{Queue}
\index[dom]{Queue!Domain}
\index[dom]{Domain!Queue}
\index[dom]{QUEUE}
\begin{chunk}{defclass QueueType}
(defclass |QueueType| (|QueueAggregateType|)
  ((parents :initform '(|QueueAggregate|))
   (name :initform "Queue")
   (marker :initform 'domain)
   (abbreviation :initform 'QUEUE)
   (comment :initform (list
     "Linked List implementation of a Queue"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Queue|
  (progn
    (push '|Queue| *Domains*)
    (make-instance '|QueueType|)))

\end{chunk}

\section{R}

\subsection{RadicalFunctionField}
\index[dom]{RadicalFunctionField!Domain}
\index[dom]{Domain!RadicalFunctionField}
\index[dom]{RADFF}
\begin{chunk}{defclass RadicalFunctionFieldType}
(defclass |RadicalFunctionFieldType| (|FunctionFieldCategoryType|)
  ((parents :initform '(|FunctionFieldCategory|))
   (name :initform "RadicalFunctionField")
   (marker :initform 'domain)
   (abbreviation :initform 'RADFF)
   (comment :initform (list
     "Function field defined by y**n = f(x)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RadicalFunctionField|
  (progn
    (push '|RadicalFunctionField| *Domains*)
    (make-instance '|RadicalFunctionFieldType|)))

\end{chunk}

\subsection{RadixExpansion}
\index[dom]{RadixExpansion!Domain}
\index[dom]{Domain!RadixExpansion}
\index[dom]{RADIX}
\begin{chunk}{defclass RadixExpansionType}
(defclass |RadixExpansionType| (|QuotientFieldCategoryType|)
  ((parents :initform '(|QuotientFieldCategory|))
   (name :initform "RadixExpansion")
   (marker :initform 'domain)
   (abbreviation :initform 'RADIX)
   (comment :initform (list
     "This domain allows rational numbers to be presented as repeating"
     "decimal expansions or more generally as repeating expansions in any base."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RadixExpansion|
  (progn
    (push '|RadixExpansion| *Domains*)
    (make-instance '|RadixExpansionType|)))

\end{chunk}

\subsection{RealClosure}
\index[dom]{RealClosure!Domain}
\index[dom]{Domain!RealClosure}
\index[dom]{RECLOS}
\begin{chunk}{defclass RealClosureType}
(defclass |RealClosureType| (|RealClosedFieldType|)
  ((parents :initform '(|RealClosedField|))
   (name :initform "RealClosure")
   (marker :initform 'domain)
   (abbreviation :initform 'RECLOS)
   (comment :initform (list
     "This domain implements the real closure of an ordered field."
     "Note:"
     "The code here is generic it does not depend of the way the operations"
     "are done. The two macros PME and SEG should be passed as functorial"
     "arguments to the domain. It does not help much to write a category"
     "since non trivial methods cannot be placed there either."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RealClosure|
  (progn
    (push '|RealClosure| *Domains*)
    (make-instance '|RealClosureType|)))

\end{chunk}

\subsection{RectangularMatrix}
\index[dom]{RectangularMatrix!Domain}
\index[dom]{Domain!RectangularMatrix}
\index[dom]{RMATRIX}
\begin{chunk}{defclass RectangularMatrixType}
(defclass |RectangularMatrixType| (|ConvertibleToType|
                                   |RectangularMatrixCategoryType|
                                   |VectorSpaceType|)
  ((parents :initform '(|ConvertibleTo|
                        |RectangularMatrixCategory|
                        |VectorSpace|))
   (name :initform "RectangularMatrix")
   (marker :initform 'domain)
   (abbreviation :initform 'RMATRIX)
   (comment :initform (list
     "RectangularMatrix is a matrix domain where the number of rows"
     "and the number of columns are parameters of the domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RectangularMatrix|
  (progn
    (push '|RectangularMatrix| *Domains*)
    (make-instance '|RectangularMatrixType|)))

\end{chunk}

\subsection{Reference}
\index[dom]{Reference!Domain}
\index[dom]{Domain!Reference}
\index[dom]{REF}
\begin{chunk}{defclass ReferenceType}
(defclass |ReferenceType| (|TypeType| |SetCategoryType|)
  ((parents :initform '(|Type| |SetCategory|))
   (name :initform "Reference")
   (marker :initform 'domain)
   (abbreviation :initform 'REF)
   (comment :initform (list
     "Reference is for making a changeable instance of something."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Reference|
  (progn
    (push '|Reference| *Domains*)
    (make-instance '|ReferenceType|)))

\end{chunk}

\subsection{RegularChain}
\index[dom]{RegularChain!Domain}
\index[dom]{Domain!RegularChain}
\index[dom]{RGCHAIN}
\begin{chunk}{defclass RegularChainType}
(defclass |RegularChainType| (|RegularTriangularSetCategoryType|)
  ((parents :initform '(|RegularTriangularSetCategory|))
   (name :initform "RegularChain")
   (marker :initform 'domain)
   (abbreviation :initform 'RGCHAIN)
   (comment :initform (list
     "A domain for regular chains (regular triangular sets) over"
     "a Gcd-Domain and with a fix list of variables."
     "This is just a front-end for the RegularTriangularSet"
     "domain constructor."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RegularChain|
  (progn
    (push '|RegularChain| *Domains*)
    (make-instance '|RegularChainType|)))

\end{chunk}

\subsection{RegularTriangularSet}
\index[dom]{RegularTriangularSet!Domain}
\index[dom]{Domain!RegularTriangularSet}
\index[dom]{REGSET}
\begin{chunk}{defclass RegularTriangularSetType}
(defclass |RegularTriangularSetType| (|RegularTriangularSetCategoryType|)
  ((parents :initform '(|RegularTriangularSetCategory|))
   (name :initform "RegularTriangularSet")
   (marker :initform 'domain)
   (abbreviation :initform 'REGSET)
   (comment :initform (list
     "This domain provides an implementation of regular chains."
     "Moreover, the operation zeroSetSplit is an implementation of a new"
     "algorithm for solving polynomial systems by means of regular chains."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RegularTriangularSet|
  (progn
    (push '|RegularTriangularSet| *Domains*)
    (make-instance '|RegularTriangularSetType|)))

\end{chunk}

\subsection{ResidueRing}
\index[dom]{ResidueRing!Domain}
\index[dom]{Domain!ResidueRing}
\index[dom]{RESRING}
\begin{chunk}{defclass ResidueRingType}
(defclass |ResidueRingType| (|CommutativeRingType| |AlgebraType|)
  ((parents :initform '(|CommutativeRing| |Algebra|))
   (name :initform "ResidueRing")
   (marker :initform 'domain)
   (abbreviation :initform 'RESRING)
   (comment :initform (list
     "ResidueRing is the quotient of a polynomial ring by  an ideal."
     "The ideal is given as a list of generators. The elements of the domain"
     "are equivalence classes expressed in terms of reduced elements"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ResidueRing|
  (progn
    (push '|ResidueRing| *Domains*)
    (make-instance '|ResidueRingType|)))

\end{chunk}

\subsection{Result}
\index[dom]{Result!Domain}
\index[dom]{Domain!Result}
\index[dom]{RESULT}
\begin{chunk}{defclass ResultType}
(defclass |ResultType| (|TableAggregateType|)
  ((parents :initform '(|TableAggregate|))
   (name :initform "Result")
   (marker :initform 'domain)
   (abbreviation :initform 'RESULT)
   (comment :initform (list
     "A domain used to return the results from a call to the NAG"
     "Library.  It prints as a list of names and types, though the user may"
     "choose to display values automatically if he or she wishes."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Result|
  (progn
    (push '|Result| *Domains*)
    (make-instance '|ResultType|)))

\end{chunk}

\subsection{RewriteRule}
\index[dom]{RewriteRule!Domain}
\index[dom]{Domain!RewriteRule}
\index[dom]{RULE}
\begin{chunk}{defclass RewriteRuleType}
(defclass |RewriteRuleType| (|SetCategoryType| |RetractableToType| |EltableType|)
  ((parents :initform '(|SetCategory| |RetractableTo| |Eltable|))
   (name :initform "RewriteRule")
   (marker :initform 'domain)
   (abbreviation :initform 'RULE)
   (comment :initform (list
     "Rules for the pattern matcher"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RewriteRule|
  (progn
    (push '|RewriteRule| *Domains*)
    (make-instance '|RewriteRuleType|)))

\end{chunk}

\subsection{RightOpenIntervalRootCharacterization}
\index[dom]{RightOpenIntervalRootCharacterization!Domain}
\index[dom]{Domain!RightOpenIntervalRootCharacterization}
\index[dom]{ROIRC}
\begin{chunk}{defclass RightOpenIntervalRootCharacterizationType}
(defclass |RightOpenIntervalRootCharacterizationType| (|RealRootCharacterizationCategoryType|)
  ((parents :initform '(|RealRootCharacterizationCategory|))
   (name :initform "RightOpenIntervalRootCharacterization")
   (marker :initform 'domain)
   (abbreviation :initform 'ROIRC)
   (comment :initform (list
     "RightOpenIntervalRootCharacterization provides work with"
     "interval root coding."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RightOpenIntervalRootCharacterization|
  (progn
    (push '|RightOpenIntervalRootCharacterization| *Domains*)
    (make-instance '|RightOpenIntervalRootCharacterizationType|)))

\end{chunk}

\subsection{RomanNumeral}
\index[dom]{RomanNumeral!Domain}
\index[dom]{Domain!RomanNumeral}
\index[dom]{ROMAN}
\begin{chunk}{defclass RomanNumeralType}
(defclass |RomanNumeralType| (|IntegerNumberSystemType|)
  ((parents :initform '(|IntegerNumberSystem|))
   (name :initform "RomanNumeral")
   (marker :initform 'domain)
   (abbreviation :initform 'ROMAN)
   (comment :initform (list
     "RomanNumeral provides functions for converting"
     "integers to roman numerals."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RomanNumeral|
  (progn
    (push '|RomanNumeral| *Domains*)
    (make-instance '|RomanNumeralType|)))

\end{chunk}

\subsection{RoutinesTable}
\index[dom]{RoutinesTable!Domain}
\index[dom]{Domain!RoutinesTable}
\index[dom]{ROUTINE}
\begin{chunk}{defclass RoutinesTableType}
(defclass |RoutinesTableType| (|TableAggregateType|)
  ((parents :initform '(|TableAggregate|))
   (name :initform "RoutinesTable")
   (marker :initform 'domain)
   (abbreviation :initform 'ROUTINE)
   (comment :initform (list
     "RoutinesTable implements a database and associated tuning"
     "mechanisms for a set of known NAG routines"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RoutinesTable|
  (progn
    (push '|RoutinesTable| *Domains*)
    (make-instance '|RoutinesTableType|)))

\end{chunk}

\subsection{RuleCalled}
\index[dom]{RuleCalled!Domain}
\index[dom]{Domain!RuleCalled}
\index[dom]{RULECOLD}
\begin{chunk}{defclass RuleCalledType}
(defclass |RuleCalledType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "RuleCalled")
   (marker :initform 'domain)
   (abbreviation :initform 'RULECOLD)
   (comment :initform (list
     "This domain implements named rules "))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RuleCalled|
  (progn
    (push '|RuleCalled| *Domains*)
    (make-instance '|RuleCalledType|)))

\end{chunk}

\subsection{Ruleset}
\index[dom]{Ruleset!Domain}
\index[dom]{Domain!Ruleset}
\index[dom]{RULESET}
\begin{chunk}{defclass RulesetType}
(defclass |RulesetType| (|SetCategoryType| |EltableType|)
  ((parents :initform '(|SetCategory| |Eltable|))
   (name :initform "Ruleset")
   (marker :initform 'domain)
   (abbreviation :initform 'RULESET)
   (comment :initform (list
     "Sets of rules for the pattern matcher."
     "A ruleset is a set of pattern matching rules grouped together."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Ruleset|
  (progn
    (push '|Ruleset| *Domains*)
    (make-instance '|RulesetType|)))

\end{chunk}

\section{S}

\subsection{ScriptFormulaFormat}
\index[dom]{ScriptFormulaFormat!Domain}
\index[dom]{Domain!ScriptFormulaFormat}
\index[dom]{FORMULA}
\begin{chunk}{defclass ScriptFormulaFormatType}
(defclass |ScriptFormulaFormatType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "ScriptFormulaFormat")
   (marker :initform 'domain)
   (abbreviation :initform 'FORMULA)
   (comment :initform (list
     "ScriptFormulaFormat provides a coercion from"
     "OutputForm to IBM SCRIPT/VS Mathematical Formula Format."
     "The basic SCRIPT formula format object consists of three parts:"
     "a prologue, a formula part and an epilogue.  The functions"
     "prologue, formula and epilogue"
     "extract these parts, respectively.  The central parts of the expression"
     "go into the formula part.  The other parts can be set"
     "(setPrologue!, setEpilogue!) so that contain the"
     "appropriate tags for printing.  For example, the prologue and"
     "epilogue might simply contain ':df.'  and ':edf.'  so that the"
     "formula section will be printed in display math mode."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ScriptFormulaFormat|
  (progn
    (push '|ScriptFormulaFormat| *Domains*)
    (make-instance '|ScriptFormulaFormatType|)))

\end{chunk}

\subsection{Segment}
\index[dom]{Segment!Domain}
\index[dom]{Domain!Segment}
\index[dom]{SEG}
\begin{chunk}{defclass SegmentType}
(defclass |SegmentType| (|SetCategoryType| |SegmentExpansionCategoryType|)
  ((parents :initform '(|SetCategory| |SegmentExpansionCategory|))
   (name :initform "Segment")
   (marker :initform 'domain)
   (abbreviation :initform 'SEG)
   (comment :initform (list
     "This type is used to specify a range of values from type S."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Segment|
  (progn
    (push '|Segment| *Domains*)
    (make-instance '|SegmentType|)))

\end{chunk}

\subsection{SegmentBinding}
\index[dom]{SegmentBinding!Domain}
\index[dom]{Domain!SegmentBinding}
\index[dom]{SEGBIND}
\begin{chunk}{defclass SegmentBindingType}
(defclass |SegmentBindingType| (|TypeType| |SetCategoryType|)
  ((parents :initform '(|Type| |SetCategory|))
   (name :initform "SegmentBinding")
   (marker :initform 'domain)
   (abbreviation :initform 'SEGBIND)
   (comment :initform (list
     "This domain is used to provide the function argument syntax v=a..b."
     "This is used, for example, by the top-level draw functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SegmentBinding|
  (progn
    (push '|SegmentBinding| *Domains*)
    (make-instance '|SegmentBindingType|)))

\end{chunk}

\subsection{Set}
\index[dom]{Set!Domain}
\index[dom]{Domain!Set}
\index[dom]{SET}
\begin{chunk}{defclass SetType}
(defclass |SetType| (|FiniteSetAggregateType|)
  ((parents :initform '(|FiniteSetAggregate|))
   (name :initform "Set")
   (marker :initform 'domain)
   (abbreviation :initform 'SET)
   (comment :initform (list
     "A set over a domain D models the usual mathematical notion of a finite set"
     "of elements from D."
     "Sets are unordered collections of distinct elements"
     "(that is, order and duplication does not matter)."
     "The notation set [a,b,c] can be used to create"
     "a set and the usual operations such as union and intersection are available"
     "to form new sets."
     "In our implementation, Axiom maintains the entries in"
     "sorted order.  Specifically, the parts function returns the entries"
     "as a list in ascending order and"
     "the extract operation returns the maximum entry."
     "Given two sets s and t where #s = m and #t = n,"
     "the complexity of"
     "     s = t is O(min(n,m)"
     "     s < t is O(max(n,m)"
     "     union(s,t), intersect(s,t), minus(s,t)"
     "        symmetricDifference(s,t) is O(max(n,m)"
     "     member(x,t) is O(n log n)"
     "     insert(x,t) and remove(x,t) is O(n)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Set|
  (progn
    (push '|Set| *Domains*)
    (make-instance '|SetType|)))

\end{chunk}

\subsection{SetOfMIntegersInOneToN}
\index[dom]{SetOfMIntegersInOneToN!Domain}
\index[dom]{Domain!SetOfMIntegersInOneToN}
\index[dom]{SETMN}
\begin{chunk}{defclass SetOfMIntegersInOneToNType}
(defclass |SetOfMIntegersInOneToNType| (|FiniteType|)
  ((parents :initform '(|Finite|))
   (name :initform "SetOfMIntegersInOneToN")
   (marker :initform 'domain)
   (abbreviation :initform 'SETMN)
   (comment :initform (list
     "SetOfMIntegersInOneToN implements the subsets of M integers"
     "in the interval [1..n]"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SetOfMIntegersInOneToN|
  (progn
    (push '|SetOfMIntegersInOneToN| *Domains*)
    (make-instance '|SetOfMIntegersInOneToNType|)))

\end{chunk}

\subsection{SequentialDifferentialPolynomial}
\index[dom]{SequentialDifferentialPolynomial!Domain}
\index[dom]{Domain!SequentialDifferentialPolynomial}
\index[dom]{SDPOL}
\begin{chunk}{defclass SequentialDifferentialPolynomialType}
(defclass |SequentialDifferentialPolynomialType| (|DifferentialPolynomialCategoryType|)
  ((parents :initform '(|DifferentialPolynomialCategory|))
   (name :initform "SequentialDifferentialPolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'SDPOL)
   (comment :initform (list
     "SequentialDifferentialPolynomial implements"
     "an ordinary differential polynomial ring in arbitrary number"
     "of differential indeterminates, with coefficients in a"
     "ring.  The ranking on the differential indeterminate is sequential."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SequentialDifferentialPolynomial|
  (progn
    (push '|SequentialDifferentialPolynomial| *Domains*)
    (make-instance '|SequentialDifferentialPolynomialType|)))

\end{chunk}

\subsection{SequentialDifferentialVariable}
\index[dom]{SequentialDifferentialVariable!Domain}
\index[dom]{Domain!SequentialDifferentialVariable}
\index[dom]{SDVAR}
\begin{chunk}{defclass SequentialDifferentialVariableType}
(defclass |SequentialDifferentialVariableType| (|DifferentialVariableCategoryType|)
  ((parents :initform '(|DifferentialVariableCategory|))
   (name :initform "SequentialDifferentialVariable")
   (marker :initform 'domain)
   (abbreviation :initform 'SDVAR)
   (comment :initform (list
     "OrderlyDifferentialVariable adds a commonly used sequential"
     "ranking to the set of derivatives of an ordered list of differential"
     "indeterminates.  A sequential ranking is a ranking < of the"
     "derivatives with the property that for any derivative v,"
     "there are only a finite number of derivatives u with u < v."
     "This domain belongs to DifferentialVariableCategory. It"
     "defines weight to be just order, and it"
     "defines a sequential ranking < on derivatives u by the"
     "lexicographic order on the pair"
     "(variable(u), order(u))."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SequentialDifferentialVariable|
  (progn
    (push '|SequentialDifferentialVariable| *Domains*)
    (make-instance '|SequentialDifferentialVariableType|)))

\end{chunk}

\subsection{SExpression}
\index[dom]{SExpression!Domain}
\index[dom]{Domain!SExpression}
\index[dom]{SEX}
\begin{chunk}{defclass SExpressionType}
(defclass |SExpressionType| (|SExpressionCategoryType|)
  ((parents :initform '(|SExpressionCategory|))
   (name :initform "SExpression")
   (marker :initform 'domain)
   (abbreviation :initform 'SEX)
   (comment :initform (list
     "This domain allows the manipulation of the usual Lisp values"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SExpression|
  (progn
    (push '|SExpression| *Domains*)
    (make-instance '|SExpressionType|)))

\end{chunk}

\subsection{SExpressionOf}
\index[dom]{SExpressionOf!Domain}
\index[dom]{Domain!SExpressionOf}
\index[dom]{SEXOF}
\begin{chunk}{defclass SExpressionOfType}
(defclass |SExpressionOfType| (|SExpressionCategoryType|)
  ((parents :initform '(|SExpressionCategory|))
   (name :initform "SExpressionOf")
   (marker :initform 'domain)
   (abbreviation :initform 'SEXOF)
   (comment :initform (list
     "This domain allows the manipulation of Lisp values over"
     "arbitrary atomic types."
     "Allows the names of the atomic types to be chosen."
     "Warning: Although the parameters are declared only to be Sets,"
     "they must have the appropriate representations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SExpressionOf|
  (progn
    (push '|SExpressionOf| *Domains*)
    (make-instance '|SExpressionOfType|)))

\end{chunk}

\subsection{SimpleAlgebraicExtension}
\index[dom]{SimpleAlgebraicExtension!Domain}
\index[dom]{Domain!SimpleAlgebraicExtension}
\index[dom]{SAE}
\begin{chunk}{defclass SimpleAlgebraicExtensionType}
(defclass |SimpleAlgebraicExtensionType| (|MonogenicAlgebraType|)
  ((parents :initform '(|MonogenicAlgebra|))
   (name :initform "SimpleAlgebraicExtension")
   (marker :initform 'domain)
   (abbreviation :initform 'SAE)
   (comment :initform (list
     "Algebraic extension of a ring by a single polynomial."
     "Domain which represents simple algebraic extensions of arbitrary"
     "rings. The first argument to the domain, R, is the underlying ring,"
     "the second argument is a domain of univariate polynomials over K,"
     "while the last argument specifies the defining minimal polynomial."
     "The elements of the domain are canonically represented as polynomials"
     "of degree less than that of the minimal polynomial with coefficients"
     "in R. The second argument is both the type of the third argument and"
     "the underlying representation used by SAE itself."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SimpleAlgebraicExtension|
  (progn
    (push '|SimpleAlgebraicExtension| *Domains*)
    (make-instance '|SimpleAlgebraicExtensionType|)))

\end{chunk}

\subsection{SimpleCell}
\index[dom]{SimpleCell!Domain}
\index[dom]{Domain!SimpleCell}
\index[dom]{SCELL}
\begin{chunk}{defclass SimpleCellType}
(defclass |SimpleCellType| (|CoercibleToType|)
  ((parents :initform '(|CoercibleTo|))
   (name :initform "SimpleCell")
   (marker :initform 'domain)
   (abbreviation :initform 'SCELL)
   (comment :initform nil)
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SimpleCell|
  (progn
    (push '|SimpleCell| *Domains*)
    (make-instance '|SimpleCellType|)))

\end{chunk}

\subsection{SimpleFortranProgram}
\index[dom]{SimpleFortranProgram!Domain}
\index[dom]{Domain!SimpleFortranProgram}
\index[dom]{SFORT}
\begin{chunk}{defclass SimpleFortranProgramType}
(defclass |SimpleFortranProgramType| (|FortranProgramCategoryType|)
  ((parents :initform '(|FortranProgramCategory|))
   (name :initform "SimpleFortranProgram")
   (marker :initform 'domain)
   (abbreviation :initform 'SFORT)
   (comment :initform (list
     "SimpleFortranProgram(f,type) provides a simple model of some"
     "FORTRAN subprograms, making it possible to coerce objects of various"
     "domains into a FORTRAN subprogram called f."
     "These can then be translated into legal FORTRAN code."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SimpleFortranProgram|
  (progn
    (push '|SimpleFortranProgram| *Domains*)
    (make-instance '|SimpleFortranProgramType|)))

\end{chunk}

\subsection{SingleInteger}
\index[dom]{SingleInteger!Domain}
\index[dom]{Domain!SingleInteger}
\index[dom]{SINT}
\begin{chunk}{defclass SingleIntegerType}
(defclass |SingleIntegerType| (|OpenMathType| |LogicType| |IntegerNumberSystemType|)
  ((parents :initform '(|OpenMath| |Logic| |IntegerNumberSystem|))
   (name :initform "SingleInteger")
   (marker :initform 'domain)
   (abbreviation :initform 'SINT)
   (comment :initform (list
     "SingleInteger is intended to support machine integer arithmetic."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SingleInteger|
  (progn
    (push '|SingleInteger| *Domains*)
    (make-instance '|SingleIntegerType|)))

\end{chunk}

\subsection{SingletonAsOrderedSet}
\index[dom]{SingletonAsOrderedSet!Domain}
\index[dom]{Domain!SingletonAsOrderedSet}
\index[dom]{SAOS}
\begin{chunk}{defclass SingletonAsOrderedSetType}
(defclass |SingletonAsOrderedSetType| (|OrderedSetType|)
  ((parents :initform '(|OrderedSet|))
   (name :initform "SingletonAsOrderedSet")
   (marker :initform 'domain)
   (abbreviation :initform 'SAOS)
   (comment :initform (list
     "This trivial domain lets us build Univariate Polynomials"
     "in an anonymous variable"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SingletonAsOrderedSet|
  (progn
    (push '|SingletonAsOrderedSet| *Domains*)
    (make-instance '|SingletonAsOrderedSetType|)))

\end{chunk}

\subsection{SparseEchelonMatrix}
\index[dom]{SparseEchelonMatrix!Domain}
\index[dom]{Domain!SparseEchelonMatrix}
\index[dom]{SEM}
\begin{chunk}{defclass SparseEchelonMatrixType}
(defclass |SparseEchelonMatrixType| (|CoercibleToType|)
  ((parents :initform '(|CoercibleTo|))
   (name :initform "SparseEchelonMatrix")
   (marker :initform 'domain)
   (abbreviation :initform 'SEM)
   (comment :initform (list
     "SparseEchelonMatrix(C, D) implements sparse matrices whose columns"
     "are enumerated by the OrderedSet C and whose entries"
     "belong to the GcdDomain D. The basic operation of"
     "this domain is the computation of an row echelon form. The used algorithm"
     "tries to maintain the sparsity and is especially adapted to matrices who"
     "are already close to a row echelon form."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SparseEchelonMatrix|
  (progn
    (push '|SparseEchelonMatrix| *Domains*)
    (make-instance '|SparseEchelonMatrixType|)))

\end{chunk}

\subsection{SparseMultivariatePolynomial}
\index[dom]{SparseMultivariatePolynomial!Domain}
\index[dom]{Domain!SparseMultivariatePolynomial}
\index[dom]{SMP}
\begin{chunk}{defclass SparseMultivariatePolynomialType}
(defclass |SparseMultivariatePolynomialType| (|PolynomialCategoryType|)
  ((parents :initform '(|PolynomialCategory|))
   (name :initform "SparseMultivariatePolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'SMP)
   (comment :initform (list
     "This type is the basic representation of sparse recursive multivariate"
     "polynomials. It is parameterized by the coefficient ring and the"
     "variable set which may be infinite. The variable ordering is determined"
     "by the variable set parameter. The coefficient ring may be non-commutative,"
     "but the variables are assumed to commute."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SparseMultivariatePolynomial|
  (progn
    (push '|SparseMultivariatePolynomial| *Domains*)
    (make-instance '|SparseMultivariatePolynomialType|)))

\end{chunk}

\subsection{SparseMultivariateTaylorSeries}
\index[dom]{SparseMultivariateTaylorSeries!Domain}
\index[dom]{Domain!SparseMultivariateTaylorSeries}
\index[dom]{SMTS}
\begin{chunk}{defclass SparseMultivariateTaylorSeriesType}
(defclass |SparseMultivariateTaylorSeriesType| (|MultivariateTaylorSeriesCategoryType|)
  ((parents :initform '(|MultivariateTaylorSeriesCategory|))
   (name :initform "SparseMultivariateTaylorSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'SMTS)
   (comment :initform (list
     "This domain provides multivariate Taylor series with variables"
     "from an arbitrary ordered set.  A Taylor series is represented"
     "by a stream of polynomials from the polynomial domain SMP."
     "The nth element of the stream is a form of degree n.  SMTS is an"
     "internal domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SparseMultivariateTaylorSeries|
  (progn
    (push '|SparseMultivariateTaylorSeries| *Domains*)
    (make-instance '|SparseMultivariateTaylorSeriesType|)))

\end{chunk}

\subsection{SparseTable}
\index[dom]{SparseTable!Domain}
\index[dom]{Domain!SparseTable}
\index[dom]{STBL}
\begin{chunk}{defclass SparseTableType}
(defclass |SparseTableType| (|TableAggregateType|)
  ((parents :initform '(|TableAggregate|))
   (name :initform "SparseTable")
   (marker :initform 'domain)
   (abbreviation :initform 'STBL)
   (comment :initform (list
     "A sparse table has a default entry, which is returned if no other"
     "value has been explicitly stored for a key."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SparseTable|
  (progn
    (push '|SparseTable| *Domains*)
    (make-instance '|SparseTableType|)))

\end{chunk}

\subsection{SparseUnivariateLaurentSeries}
\index[dom]{SparseUnivariateLaurentSeries!Domain}
\index[dom]{Domain!SparseUnivariateLaurentSeries}
\index[dom]{SULS}
\begin{chunk}{defclass SparseUnivariateLaurentSeriesType}
(defclass |SparseUnivariateLaurentSeriesType| (|UnivariateLaurentSeriesConstructorCategoryType|)
  ((parents :initform '(|UnivariateLaurentSeriesConstructorCategory|))
   (name :initform "SparseUnivariateLaurentSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'SULS)
   (comment :initform (list
     "SparseUnivariateLaurentSeries is a domain representing Laurent"
     "series in one variable with coefficients in an arbitrary ring.  The"
     "parameters of the type specify the coefficient ring, the power series"
     "variable, and the center of the power series expansion.  For example,"
     "SparseUnivariateLaurentSeries(Integer,x,3) represents Laurent"
     "series in (x - 3) with integer coefficients."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SparseUnivariateLaurentSeries|
  (progn
    (push '|SparseUnivariateLaurentSeries| *Domains*)
    (make-instance '|SparseUnivariateLaurentSeriesType|)))

\end{chunk}

\subsection{SparseUnivariatePolynomial}
\index[dom]{SparseUnivariatePolynomial!Domain}
\index[dom]{Domain!SparseUnivariatePolynomial}
\index[dom]{SUP}
\begin{chunk}{defclass SparseUnivariatePolynomialType}
(defclass |SparseUnivariatePolynomialType| (|UnivariatePolynomialCategoryType|)
  ((parents :initform '(|UnivariatePolynomialCategory|))
   (name :initform "SparseUnivariatePolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'SUP)
   (comment :initform (list
     "This domain represents univariate polynomials over arbitrary"
     "(not necessarily commutative) coefficient rings. The variable is"
     "unspecified  so that the variable displays as ? on output."
     "If it is necessary to specify the variable name,"
     "use type UnivariatePolynomial. The representation is sparse"
     "in the sense that only non-zero terms are represented."
     "Note that if the coefficient ring is a field,"
     "this domain forms a euclidean domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SparseUnivariatePolynomial|
  (progn
    (push '|SparseUnivariatePolynomial| *Domains*)
    (make-instance '|SparseUnivariatePolynomialType|)))

\end{chunk}

\subsection{SparseUnivariatePolynomialExpressions}
\index[dom]{SparseUnivariatePolynomialExpressions!Domain}
\index[dom]{Domain!SparseUnivariatePolynomialExpressions}
\index[dom]{SUPEXPR}
\begin{chunk}{defclass SparseUnivariatePolynomialExpressionsType}
(defclass |SparseUnivariatePolynomialExpressionsType| (|UnivariatePolynomialCategoryType|
                                                       |TranscendentalFunctionCategoryType|)
  ((parents :initform '(|UnivariatePolynomialCategory| |TranscendentalFunctionCategory|))
   (name :initform "SparseUnivariatePolynomialExpressions")
   (marker :initform 'domain)
   (abbreviation :initform 'SUPEXPR)
   (comment :initform (list
     "This domain has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SparseUnivariatePolynomialExpressions|
  (progn
    (push '|SparseUnivariatePolynomialExpressions| *Domains*)
    (make-instance '|SparseUnivariatePolynomialExpressionsType|)))

\end{chunk}

\subsection{SparseUnivariatePuiseuxSeries}
\index[dom]{SparseUnivariatePuiseuxSeries!Domain}
\index[dom]{Domain!SparseUnivariatePuiseuxSeries}
\index[dom]{SUPXS}
\begin{chunk}{defclass SparseUnivariatePuiseuxSeriesType}
(defclass |SparseUnivariatePuiseuxSeriesType| (|UnivariatePuiseuxSeriesConstructorCategoryType|)
  ((parents :initform '(|UnivariatePuiseuxSeriesConstructorCategory|))
   (name :initform "SparseUnivariatePuiseuxSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'SUPXS)
   (comment :initform (list
     "Sparse Puiseux series in one variable"
     "SparseUnivariatePuiseuxSeries is a domain representing Puiseux"
     "series in one variable with coefficients in an arbitrary ring.  The"
     "parameters of the type specify the coefficient ring, the power series"
     "variable, and the center of the power series expansion.  For example,"
     "SparseUnivariatePuiseuxSeries(Integer,x,3) represents Puiseux"
     "series in (x - 3) with Integer coefficients."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SparseUnivariatePuiseuxSeries|
  (progn
    (push '|SparseUnivariatePuiseuxSeries| *Domains*)
    (make-instance '|SparseUnivariatePuiseuxSeriesType|)))

\end{chunk}

\subsection{SparseUnivariateSkewPolynomial}
\index[dom]{SparseUnivariateSkewPolynomial!Domain}
\index[dom]{Domain!SparseUnivariateSkewPolynomial}
\index[dom]{ORESUP}
\begin{chunk}{defclass SparseUnivariateSkewPolynomialType}
(defclass |SparseUnivariateSkewPolynomialType| (|UnivariateSkewPolynomialCategoryType|)
  ((parents :initform '(|UnivariateSkewPolynomialCategory|))
   (name :initform "SparseUnivariateSkewPolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'ORESUP)
   (comment :initform (list
     "This is the domain of sparse univariate skew polynomials over an Ore"
     "coefficient field."
     "The multiplication is given by x a = sigma(a) x + delta a."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SparseUnivariateSkewPolynomial|
  (progn
    (push '|SparseUnivariateSkewPolynomial| *Domains*)
    (make-instance '|SparseUnivariateSkewPolynomialType|)))

\end{chunk}

\subsection{SparseUnivariateTaylorSeries}
\index[dom]{SparseUnivariateTaylorSeries!Domain}
\index[dom]{Domain!SparseUnivariateTaylorSeries}
\index[dom]{SUTS}
\begin{chunk}{defclass SparseUnivariateTaylorSeriesType}
(defclass |SparseUnivariateTaylorSeriesType| (|UnivariateTaylorSeriesCategoryType|)
  ((parents :initform '(|UnivariateTaylorSeriesCategory|))
   (name :initform "SparseUnivariateTaylorSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'SUTS)
   (comment :initform (list
     "SparseUnivariateTaylorSeries is a domain representing Taylor"
     "series in one variable with coefficients in an arbitrary ring.  The"
     "parameters of the type specify the coefficient ring, the power series"
     "variable, and the center of the power series expansion.  For example,"
     "SparseUnivariateTaylorSeries(Integer,x,3) represents Taylor"
     "series in (x - 3) with Integer coefficients."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SparseUnivariateTaylorSeries|
  (progn
    (push '|SparseUnivariateTaylorSeries| *Domains*)
    (make-instance '|SparseUnivariateTaylorSeriesType|)))

\end{chunk}

\subsection{SplitHomogeneousDirectProduct}
\index[dom]{SplitHomogeneousDirectProduct!Domain}
\index[dom]{Domain!SplitHomogeneousDirectProduct}
\index[dom]{SHDP}
\begin{chunk}{defclass SplitHomogeneousDirectProductType}
(defclass |SplitHomogeneousDirectProductType| (|DirectProductCategoryType|)
  ((parents :initform '(|DirectProductCategory|))
   (name :initform "SplitHomogeneousDirectProduct")
   (marker :initform 'domain)
   (abbreviation :initform 'SHDP)
   (comment :initform (list
     "This type represents the finite direct or cartesian product of an"
     "underlying ordered component type. The vectors are ordered as if"
     "they were split into two blocks. The dim1 parameter specifies the"
     "length of the first block. The ordering is lexicographic between"
     "the blocks but acts like HomogeneousDirectProduct"
     "within each block. This type is a suitable third argument for"
     "GeneralDistributedMultivariatePolynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SplitHomogeneousDirectProduct|
  (progn
    (push '|SplitHomogeneousDirectProduct| *Domains*)
    (make-instance '|SplitHomogeneousDirectProductType|)))

\end{chunk}

\subsection{SplittingNode}
\index[dom]{SplittingNode!Domain}
\index[dom]{Domain!SplittingNode}
\index[dom]{SPLNODE}
\begin{chunk}{defclass SplittingNodeType}
(defclass |SplittingNodeType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "SplittingNode")
   (marker :initform 'domain)
   (abbreviation :initform 'SPLNODE)
   (comment :initform (list
     "This domain exports a modest implementation for the"
     "vertices of splitting trees. These vertices are called"
     "here splitting nodes. Every of these nodes store 3 informations."
     "The first one is its value, that is the current expression"
     "to evaluate. The second one is its condition, that is the"
     "hypothesis under which the value has to be evaluated."
     "The last one is its status, that is a boolean flag"
     "which is true iff the value is the result of its"
     "evaluation under its condition. Two splitting vertices"
     "are equal iff they have the sane values and the same"
     "conditions (so their status do not matter)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SplittingNode|
  (progn
    (push '|SplittingNode| *Domains*)
    (make-instance '|SplittingNodeType|)))

\end{chunk}

\subsection{SplittingTree}
\index[dom]{SplittingTree!Domain}
\index[dom]{Domain!SplittingTree}
\index[dom]{SPLTREE}
\begin{chunk}{defclass SplittingTreeType}
(defclass |SplittingTreeType| (|RecursiveAggregateType|)
  ((parents :initform '(|RecursiveAggregate|))
   (name :initform "SplittingTree")
   (marker :initform 'domain)
   (abbreviation :initform 'SPLTREE)
   (comment :initform (list
     "This domain exports a modest implementation of splitting"
     "trees. Spliiting trees are needed when the"
     "evaluation of some quantity under some hypothesis"
     "requires to split the hypothesis into sub-cases."
     "For instance by adding some new hypothesis on one"
     "hand and its negation on another hand. The computations"
     "are terminated is a splitting tree a when"
     "status(value(a)) is true. Thus,"
     "if for the splitting tree a the flag"
     "status(value(a)) is true, then"
     "status(value(d)) is true for any"
     "subtree d of a. This property"
     "of splitting trees is called the termination"
     "condition. If no vertex in a splitting tree a"
     "is equal to another, a is said to satisfy"
     "the no-duplicates condition. The splitting "
     "tree a will satisfy this condition"
     "if nodes are added to \axiom{a} by mean of"
     "splitNodeOf! and if construct"
     "is only used to create the root of a"
     "with no children."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SplittingTree|
  (progn
    (push '|SplittingTree| *Domains*)
    (make-instance '|SplittingTreeType|)))

\end{chunk}

\subsection{SquareFreeRegularTriangularSet}
\index[dom]{SquareFreeRegularTriangularSet!Domain}
\index[dom]{Domain!SquareFreeRegularTriangularSet}
\index[dom]{SREGSET}
\begin{chunk}{defclass SquareFreeRegularTriangularSetType}
(defclass |SquareFreeRegularTriangularSetType| (|SquareFreeRegularTriangularSetCategoryType|)
  ((parents :initform '(|SquareFreeRegularTriangularSetCategory|))
   (name :initform "SquareFreeRegularTriangularSet")
   (marker :initform 'domain)
   (abbreviation :initform 'SREGSET)
   (comment :initform (list
     "This domain provides an implementation of square-free regular chains."
     "Moreover, the operation zeroSetSplit"
     "is an implementation of a new algorithm for solving polynomial systems by"
     "means of regular chains."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SquareFreeRegularTriangularSet|
  (progn
    (push '|SquareFreeRegularTriangularSet| *Domains*)
    (make-instance '|SquareFreeRegularTriangularSetType|)))

\end{chunk}

\subsection{SquareMatrix}
\index[dom]{SquareMatrix!Domain}
\index[dom]{Domain!SquareMatrix}
\index[dom]{SQMATRIX}
\begin{chunk}{defclass SquareMatrixType}
(defclass |SquareMatrixType| (|SquareMatrixCategoryType| |ConvertibleToType|)
  ((parents :initform '(|SquareMatrixCategory| |ConvertibleTo|))
   (name :initform "SquareMatrix")
   (marker :initform 'domain)
   (abbreviation :initform 'SQMATRIX)
   (comment :initform (list
     "SquareMatrix is a matrix domain of square matrices, where the"
     "number of rows (= number of columns) is a parameter of the type."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SquareMatrix|
  (progn
    (push '|SquareMatrix| *Domains*)
    (make-instance '|SquareMatrixType|)))

\end{chunk}

\subsection{Stack}
\index[dom]{Stack!Domain}
\index[dom]{Domain!Stack}
\index[dom]{STACK}
\begin{chunk}{defclass StackType}
(defclass |StackType| (|StackAggregateType|)
  ((parents :initform '(|StackAggregate|))
   (name :initform "Stack")
   (marker :initform 'domain)
   (abbreviation :initform 'STACK)
   (comment :initform (list
     "Linked List implementation of a Stack"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Stack|
  (progn
    (push '|Stack| *Domains*)
    (make-instance '|StackType|)))

\end{chunk}

\subsection{StochasticDifferential}
\index[dom]{StochasticDifferential!Domain}
\index[dom]{Domain!StochasticDifferential}
\index[dom]{SD}
\begin{chunk}{defclass StochasticDifferentialType}
(defclass |StochasticDifferentialType| (|RngType| |RetractableToType| |ModuleType|)
  ((parents :initform '(|Rng| |RetractableTo| |Module|))
   (name :initform "StochasticDifferential")
   (marker :initform 'domain)
   (abbreviation :initform 'SD)
   (comment :initform (list
     "A basic implementation of StochasticDifferential(R) using the"
     "associated domain BasicStochasticDifferential in the underlying"
     "representation as sparse multivariate polynomials. The domain is"
     "a module over Expression(R), and is a ring without identity"
     "(AXIOM term is 'Rng'). Note that separate instances, for example"
     "using R=Integer and R=Float, have different hidden structure"
     "(multiplication and drift tables)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StochasticDifferential|
  (progn
    (push '|StochasticDifferential| *Domains*)
    (make-instance '|StochasticDifferentialType|)))

\end{chunk}

\subsection{Stream}
\index[dom]{Stream!Domain}
\index[dom]{Domain!Stream}
\index[dom]{STREAM}
\begin{chunk}{defclass StreamType}
(defclass |StreamType| (|LazyStreamAggregateType|)
  ((parents :initform '(|LazyStreamAggregate|))
   (name :initform "Stream")
   (marker :initform 'domain)
   (abbreviation :initform 'STREAM)
   (comment :initform (list
     "A stream is an implementation of an infinite sequence using"
     "a list of terms that have been computed and a function closure"
     "to compute additional terms when needed."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Stream|
  (progn
    (push '|Stream| *Domains*)
    (make-instance '|StreamType|)))

\end{chunk}

\subsection{String}
\index[dom]{String!Domain}
\index[dom]{Domain!String}
\index[dom]{STRING}
\begin{chunk}{defclass StringType}
(defclass |StringType| (|StringCategoryType|)
  ((parents :initform '(|StringCategory|))
   (name :initform "String")
   (marker :initform 'domain)
   (abbreviation :initform 'STRING)
   (comment :initform (list
     "This is the domain of character strings. Strings are 1 based."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |String|
  (progn
    (push '|String| *Domains*)
    (make-instance '|StringType|)))

\end{chunk}

\subsection{StringTable}
\index[dom]{StringTable!Domain}
\index[dom]{Domain!StringTable}
\index[dom]{STRTBL}
\begin{chunk}{defclass StringTableType}
(defclass |StringTableType| (|TableAggregateType|)
  ((parents :initform '(|TableAggregate|))
   (name :initform "StringTable")
   (marker :initform 'domain)
   (abbreviation :initform 'STRTBL)
   (comment :initform (list
     "This domain provides tables where the keys are strings."
     "A specialized hash function for strings is used."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StringTable|
  (progn
    (push '|StringTable| *Domains*)
    (make-instance '|StringTableType|)))

\end{chunk}

\subsection{SubSpace}
\index[dom]{SubSpace!Domain}
\index[dom]{Domain!SubSpace}
\index[dom]{SUBSPACE}
\begin{chunk}{defclass SubSpaceType}
(defclass |SubSpaceType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "SubSpace")
   (marker :initform 'domain)
   (abbreviation :initform 'SUBSPACE)
   (comment :initform (list
     "This domain is not documented"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SubSpace|
  (progn
    (push '|SubSpace| *Domains*)
    (make-instance '|SubSpaceType|)))

\end{chunk}

\subsection{SubSpaceComponentProperty}
\index[dom]{SubSpaceComponentProperty!Domain}
\index[dom]{Domain!SubSpaceComponentProperty}
\index[dom]{COMPPROP}
\begin{chunk}{defclass SubSpaceComponentPropertyType}
(defclass |SubSpaceComponentPropertyType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "SubSpaceComponentProperty")
   (marker :initform 'domain)
   (abbreviation :initform 'COMPPROP)
   (comment :initform (list
     "This domain implements some global properties of subspaces."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SubSpaceComponentProperty|
  (progn
    (push '|SubSpaceComponentProperty| *Domains*)
    (make-instance '|SubSpaceComponentPropertyType|)))

\end{chunk}

\subsection{SuchThat}
\index[dom]{SuchThat!Domain}
\index[dom]{Domain!SuchThat}
\index[dom]{SUCH}
\begin{chunk}{defclass SuchThatType}
(defclass |SuchThatType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "SuchThat")
   (marker :initform 'domain)
   (abbreviation :initform 'SUCH)
   (comment :initform (list
     "This domain implements 'such that' forms"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SuchThat|
  (progn
    (push '|SuchThat| *Domains*)
    (make-instance '|SuchThatType|)))

\end{chunk}

\subsection{Switch}
\index[dom]{Switch!Domain}
\index[dom]{Domain!Switch}
\index[dom]{SWITCH}
\begin{chunk}{defclass SwitchType}
(defclass |SwitchType| (|CoercibleToType|)
  ((parents :initform '(|CoercibleTo|))
   (name :initform "Switch")
   (marker :initform 'domain)
   (abbreviation :initform 'SWITCH)
   (comment :initform (list
     "This domain builds representations of boolean expressions for use with"
     "the FortranCode domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Switch|
  (progn
    (push '|Switch| *Domains*)
    (make-instance '|SwitchType|)))

\end{chunk}

\subsection{Symbol}
\index[dom]{Symbol!Domain}
\index[dom]{Domain!Symbol}
\index[dom]{SYMBOL}
\begin{chunk}{defclass SymbolType}
(defclass |SymbolType| (|PatternMatchableType|
                        |OrderedSetType|
                        |OpenMathType|
                        |ConvertibleToType|)
  ((parents :initform '(|PatternMatchable|
                        |OrderedSet|
                        |OpenMath|
                        |ConvertibleTo|))
   (name :initform "Symbol")
   (marker :initform 'domain)
   (abbreviation :initform 'SYMBOL)
   (comment :initform (list
     "Basic and scripted symbols."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Symbol|
  (progn
    (push '|Symbol| *Domains*)
    (make-instance '|SymbolType|)))

\end{chunk}

\subsection{SymbolTable}
\index[dom]{SymbolTable!Domain}
\index[dom]{Domain!SymbolTable}
\index[dom]{SYMTAB}
\begin{chunk}{defclass SymbolTableType}
(defclass |SymbolTableType| (|CoercibleToType|)
  ((parents :initform '(|CoercibleTo|))
   (name :initform "SymbolTable")
   (marker :initform 'domain)
   (abbreviation :initform 'SYMTAB)
   (comment :initform (list
     "Create and manipulate a symbol table for generated FORTRAN code"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SymbolTable|
  (progn
    (push '|SymbolTable| *Domains*)
    (make-instance '|SymbolTableType|)))

\end{chunk}

\subsection{SymmetricPolynomial}
\index[dom]{SymmetricPolynomial!Domain}
\index[dom]{Domain!SymmetricPolynomial}
\index[dom]{SYMPOLY}
\begin{chunk}{defclass SymmetricPolynomialType}
(defclass |SymmetricPolynomialType| (|FiniteAbelianMonoidRingType|)
  ((parents :initform '(|FiniteAbelianMonoidRing|))
   (name :initform "SymmetricPolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'SYMPOLY)
   (comment :initform (list
     "This domain implements symmetric polynomial"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SymmetricPolynomial|
  (progn
    (push '|SymmetricPolynomial| *Domains*)
    (make-instance '|SymmetricPolynomialType|)))

\end{chunk}

\section{T}

\subsection{Table}
\index[dom]{Table!Domain}
\index[dom]{Domain!Table}
\index[dom]{TABLE}
\begin{chunk}{defclass TableType}
(defclass |TableType| (|TableAggregateType|)
  ((parents :initform '(|TableAggregate|))
   (name :initform "Table")
   (marker :initform 'domain)
   (abbreviation :initform 'TABLE)
   (comment :initform (list
     "This is the general purpose table type."
     "The keys are hashed to look up the entries."
     "This creates a HashTable if equal for the Key"
     "domain is consistent with Lisp EQUAL otherwise an"
     "AssociationList"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Table|
  (progn
    (push '|Table| *Domains*)
    (make-instance '|TableType|)))

\end{chunk}

\subsection{Tableau}
\index[dom]{Tableau!Domain}
\index[dom]{Domain!Tableau}
\index[dom]{TABLEAU}
\begin{chunk}{defclass TableauType}
(defclass |TableauType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "Tableau")
   (marker :initform 'domain)
   (abbreviation :initform 'TABLEAU)
   (comment :initform (list
     "The tableau domain is for printing Young tableaux, and"
     "coercions to and from List List S where S is a set."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Tableau|
  (progn
    (push '|Tableau| *Domains*)
    (make-instance '|TableauType|)))

\end{chunk}

\subsection{TaylorSerieso}
\index[dom]{TaylorSerieso!Domain}
\index[dom]{Domain!TaylorSerieso}
\index[dom]{TS}
\begin{chunk}{defclass TaylorSeriesoType}
(defclass |TaylorSeriesoType| (|MultivariateTaylorSeriesCategoryType|)
  ((parents :initform '(|MultivariateTaylorSeriesCategory|))
   (name :initform "TaylorSerieso")
   (marker :initform 'domain)
   (abbreviation :initform 'TS)
   (comment :initform (list
     "TaylorSeries is a general multivariate Taylor series domain"
     "over the ring Coef and with variables of type Symbol."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TaylorSerieso|
  (progn
    (push '|TaylorSerieso| *Domains*)
    (make-instance '|TaylorSeriesoType|)))

\end{chunk}

\subsection{TexFormat}
\index[dom]{TexFormat!Domain}
\index[dom]{Domain!TexFormat}
\index[dom]{TEX}
\begin{chunk}{defclass TexFormatType}
(defclass |TexFormatType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "TexFormat")
   (marker :initform 'domain)
   (abbreviation :initform 'TEX)
   (comment :initform (list
     "TexFormat provides a coercion from OutputForm to"
     "TeX format.  The particular dialect of TeX used is LaTeX."
     "The basic object consists of three parts: a prologue, a"
     "tex part and an epilogue. The functions prologue,"
     "tex and epilogue extract these parts,"
     "respectively.  The main guts of the expression go into the tex part."
     "The other parts can be set (setPrologue!,"
     "setEpilogue!) so that contain the appropriate tags for"
     "printing. For example, the prologue and epilogue might simply"
     "contain '\\verb+\\[+' and '\\verb+\\]+', respectively, so that"
     "the TeX section will be printed in LaTeX display math mode."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TexFormat|
  (progn
    (push '|TexFormat| *Domains*)
    (make-instance '|TexFormatType|)))

\end{chunk}

\subsection{TextFile}
\index[dom]{TextFile!Domain}
\index[dom]{Domain!TextFile}
\index[dom]{TEXTFILE}
\begin{chunk}{defclass TextFileType}
(defclass |TextFileType| (|FileCategoryType|)
  ((parents :initform '(|FileCategory|))
   (name :initform "TextFile")
   (marker :initform 'domain)
   (abbreviation :initform 'TEXTFILE)
   (comment :initform (list
     "This domain provides an implementation of text files.  Text is stored"
     "in these files using the native character set of the computer."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TextFile|
  (progn
    (push '|TextFile| *Domains*)
    (make-instance '|TextFileType|)))

\end{chunk}

\subsection{TheSymbolTable}
\index[dom]{TheSymbolTable!Domain}
\index[dom]{Domain!TheSymbolTable}
\index[dom]{SYMS}
\begin{chunk}{defclass TheSymbolTableType}
(defclass |TheSymbolTableType| (|CoercibleToType|)
  ((parents :initform '(|CoercibleTo|))
   (name :initform "TheSymbolTable")
   (marker :initform 'domain)
   (abbreviation :initform 'SYMS)
   (comment :initform (list
     "Creates and manipulates one global symbol table for FORTRAN"
     "code generation, containing details of types, dimensions, and argument"
     "lists."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TheSymbolTable|
  (progn
    (push '|TheSymbolTable| *Domains*)
    (make-instance '|TheSymbolTableType|)))

\end{chunk}

\subsection{ThreeDimensionalMatrix}
\index[dom]{ThreeDimensionalMatrix!Domain}
\index[dom]{Domain!ThreeDimensionalMatrix}
\index[dom]{M3D}
\begin{chunk}{defclass ThreeDimensionalMatrixType}
(defclass |ThreeDimensionalMatrixType| (|HomogeneousAggregateType|)
  ((parents :initform '(|HomogeneousAggregate|))
   (name :initform "ThreeDimensionalMatrix")
   (marker :initform 'domain)
   (abbreviation :initform 'M3D)
   (comment :initform (list
     "This domain represents three dimensional matrices over a general object type"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ThreeDimensionalMatrix|
  (progn
    (push '|ThreeDimensionalMatrix| *Domains*)
    (make-instance '|ThreeDimensionalMatrixType|)))

\end{chunk}

\subsection{ThreeDimensionalViewport}
\index[dom]{ThreeDimensionalViewport!Domain}
\index[dom]{Domain!ThreeDimensionalViewport}
\index[dom]{VIEW3D}
\begin{chunk}{defclass ThreeDimensionalViewportType}
(defclass |ThreeDimensionalViewportType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "ThreeDimensionalViewport")
   (marker :initform 'domain)
   (abbreviation :initform 'VIEW3D)
   (comment :initform (list
     "ThreeDimensionalViewport creates viewports to display graphs"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ThreeDimensionalViewport|
  (progn
    (push '|ThreeDimensionalViewport| *Domains*)
    (make-instance '|ThreeDimensionalViewportType|)))

\end{chunk}

\subsection{ThreeSpace}
\index[dom]{ThreeSpace!Domain}
\index[dom]{Domain!ThreeSpace}
\index[dom]{SPACE3}
\begin{chunk}{defclass ThreeSpaceType}
(defclass |ThreeSpaceType| (|ThreeSpaceCategoryType|)
  ((parents :initform '(|ThreeSpaceCategory|))
   (name :initform "ThreeSpace")
   (marker :initform 'domain)
   (abbreviation :initform 'SPACE3)
   (comment :initform (list
     "The domain ThreeSpace is used for creating three dimensional"
     "objects using functions for defining points, curves, polygons, constructs"
     "and the subspaces containing them."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ThreeSpace|
  (progn
    (push '|ThreeSpace| *Domains*)
    (make-instance '|ThreeSpaceType|)))

\end{chunk}

\subsection{Tree}
\index[dom]{Tree!Domain}
\index[dom]{Domain!Tree}
\index[dom]{TREE}
\begin{chunk}{defclass TreeType}
(defclass |TreeType| (|RecursiveAggregateType|)
  ((parents :initform '(|RecursiveAggregate|))
   (name :initform "Tree")
   (marker :initform 'domain)
   (abbreviation :initform 'TREE)
   (comment :initform (list
     "Tree(S) is a basic domains of tree structures."
     "Each tree is either empty or else is a node consisting of a value and"
     "a list of (sub)trees."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Tree|
  (progn
    (push '|Tree| *Domains*)
    (make-instance '|TreeType|)))

\end{chunk}

\subsection{TubePlot}
\index[dom]{TubePlot!Domain}
\index[dom]{Domain!TubePlot}
\index[dom]{TUBE}
\begin{chunk}{defclass TubePlotType}
(defclass |TubePlotType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TubePlot")
   (marker :initform 'domain)
   (abbreviation :initform 'TUBE)
   (comment :initform (list
     "Package for constructing tubes around 3-dimensional parametric curves."
     "Domain of tubes around 3-dimensional parametric curves."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TubePlot|
  (progn
    (push '|TubePlot| *Domains*)
    (make-instance '|TubePlotType|)))

\end{chunk}

\subsection{Tuple}
\index[dom]{Tuple!Domain}
\index[dom]{Domain!Tuple}
\index[dom]{TUPLE}
\begin{chunk}{defclass TupleType}
(defclass |TupleType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "Tuple")
   (marker :initform 'domain)
   (abbreviation :initform 'TUPLE)
   (comment :initform (list
     "This domain is used to interface with the interpreter's notion"
     "of comma-delimited sequences of values."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Tuple|
  (progn
    (push '|Tuple| *Domains*)
    (make-instance '|TupleType|)))

\end{chunk}

\subsection{TwoDimensionalArray}
\index[dom]{TwoDimensionalArray!Domain}
\index[dom]{Domain!TwoDimensionalArray}
\index[dom]{ARRAY2}
\begin{chunk}{defclass TwoDimensionalArrayType}
(defclass |TwoDimensionalArrayType| (|TwoDimensionalArrayCategoryType|)
  ((parents :initform '(|TwoDimensionalArrayCategory|))
   (name :initform "TwoDimensionalArray")
   (marker :initform 'domain)
   (abbreviation :initform 'ARRAY2)
   (comment :initform (list
     "A TwoDimensionalArray is a two dimensional array with"
     "1-based indexing for both rows and columns."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TwoDimensionalArray|
  (progn
    (push '|TwoDimensionalArray| *Domains*)
    (make-instance '|TwoDimensionalArrayType|)))

\end{chunk}

\subsection{TwoDimensionalViewport}
\index[dom]{TwoDimensionalViewport!Domain}
\index[dom]{Domain!TwoDimensionalViewport}
\index[dom]{VIEW2D}
\begin{chunk}{defclass TwoDimensionalViewportType}
(defclass |TwoDimensionalViewportType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "TwoDimensionalViewport")
   (marker :initform 'domain)
   (abbreviation :initform 'VIEW2D)
   (comment :initform (list
     "TwoDimensionalViewport creates viewports to display graphs."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TwoDimensionalViewport|
  (progn
    (push '|TwoDimensionalViewport| *Domains*)
    (make-instance '|TwoDimensionalViewportType|)))

\end{chunk}

\section{U}

\subsection{UnivariateFormalPowerSeries}
\index[dom]{UnivariateFormalPowerSeries!Domain}
\index[dom]{Domain!UnivariateFormalPowerSeries}
\index[dom]{UFPS}
\begin{chunk}{defclass UnivariateFormalPowerSeriesType}
(defclass |UnivariateFormalPowerSeriesType| (|UnivariateTaylorSeriesCategoryType|)
  ((parents :initform '(|UnivariateTaylorSeriesCategory|))
   (name :initform "UnivariateFormalPowerSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'UFPS)
   (comment :initform (list
     "This domain has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateFormalPowerSeries|
  (progn
    (push '|UnivariateFormalPowerSeries| *Domains*)
    (make-instance '|UnivariateFormalPowerSeriesType|)))

\end{chunk}

\subsection{UnivariateLaurentSeries}
\index[dom]{UnivariateLaurentSeries!Domain}
\index[dom]{Domain!UnivariateLaurentSeries}
\index[dom]{ULS}
\begin{chunk}{defclass UnivariateLaurentSeriesType}
(defclass |UnivariateLaurentSeriesType| (|UnivariateLaurentSeriesConstructorCategoryType|)
  ((parents :initform '(|UnivariateLaurentSeriesConstructorCategory|))
   (name :initform "UnivariateLaurentSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'ULS)
   (comment :initform (list
     "UnivariateLaurentSeries is a domain representing Laurent"
     "series in one variable with coefficients in an arbitrary ring.  The"
     "parameters of the type specify the coefficient ring, the power series"
     "variable, and the center of the power series expansion.  For example,"
     "UnivariateLaurentSeries(Integer,x,3) represents Laurent series in"
     "(x - 3) with integer coefficients."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateLaurentSeries|
  (progn
    (push '|UnivariateLaurentSeries| *Domains*)
    (make-instance '|UnivariateLaurentSeriesType|)))

\end{chunk}

\subsection{UnivariateLaurentSeriesConstructor}
\index[dom]{UnivariateLaurentSeriesConstructor!Domain}
\index[dom]{Domain!UnivariateLaurentSeriesConstructor}
\index[dom]{ULSCONS}
\begin{chunk}{defclass UnivariateLaurentSeriesConstructorType}
(defclass |UnivariateLaurentSeriesConstructorType| (|UnivariateLaurentSeriesConstructorCategoryType|)
  ((parents :initform '(|UnivariateLaurentSeriesConstructorCategory|))
   (name :initform "UnivariateLaurentSeriesConstructor")
   (marker :initform 'domain)
   (abbreviation :initform 'ULSCONS)
   (comment :initform (list
     "This package enables one to construct a univariate Laurent series"
     "domain from a univariate Taylor series domain. Univariate"
     "Laurent series are represented by a pair [n,f(x)], where n is"
     "an arbitrary integer and f(x)} is a Taylor series.  This pair"
     "represents the Laurent series x**n * f(x)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateLaurentSeriesConstructor|
  (progn
    (push '|UnivariateLaurentSeriesConstructor| *Domains*)
    (make-instance '|UnivariateLaurentSeriesConstructorType|)))

\end{chunk}

\subsection{UnivariatePolynomial}
\index[dom]{UnivariatePolynomial!Domain}
\index[dom]{Domain!UnivariatePolynomial}
\index[dom]{UP}
\begin{chunk}{defclass UnivariatePolynomialType}
(defclass |UnivariatePolynomialType| (|UnivariatePolynomialCategoryType|)
  ((parents :initform '(|UnivariatePolynomialCategory|))
   (name :initform "UnivariatePolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'UP)
   (comment :initform (list
     "This domain represents univariate polynomials in some symbol"
     "over arbitrary (not necessarily commutative) coefficient rings."
     "The representation is sparse"
     "in the sense that only non-zero terms are represented."
     "Note that if the coefficient ring is a field, then this domain"
     "forms a euclidean domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePolynomial|
  (progn
    (push '|UnivariatePolynomial| *Domains*)
    (make-instance '|UnivariatePolynomialType|)))

\end{chunk}

\subsection{UnivariatePuiseuxSeries}
\index[dom]{UnivariatePuiseuxSeries!Domain}
\index[dom]{Domain!UnivariatePuiseuxSeries}
\index[dom]{UPXS}
\begin{chunk}{defclass UnivariatePuiseuxSeriesType}
(defclass |UnivariatePuiseuxSeriesType| (|UnivariatePuiseuxSeriesConstructorCategoryType|)
  ((parents :initform '(|UnivariatePuiseuxSeriesConstructorCategory|))
   (name :initform "UnivariatePuiseuxSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'UPXS)
   (comment :initform (list
     "Dense Puiseux series in one variable"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePuiseuxSeries|
  (progn
    (push '|UnivariatePuiseuxSeries| *Domains*)
    (make-instance '|UnivariatePuiseuxSeriesType|)))

\end{chunk}

\subsection{UnivariatePuiseuxSeriesConstructor}
\index[dom]{UnivariatePuiseuxSeriesConstructor!Domain}
\index[dom]{Domain!UnivariatePuiseuxSeriesConstructor}
\index[dom]{UPXSCONS}
\begin{chunk}{defclass UnivariatePuiseuxSeriesConstructorType}
(defclass |UnivariatePuiseuxSeriesConstructorType| (|UnivariatePuiseuxSeriesConstructorCategoryType|)
  ((parents :initform '(|UnivariatePuiseuxSeriesConstructorCategory|))
   (name :initform "UnivariatePuiseuxSeriesConstructor")
   (marker :initform 'domain)
   (abbreviation :initform 'UPXSCONS)
   (comment :initform (list
     "This package enables one to construct a univariate Puiseux series"
     "domain from a univariate Laurent series domain. Univariate"
     "Puiseux series are represented by a pair [r,f(x)], where r is"
     "a positive rational number and f(x) is a Laurent series."
     "This pair represents the Puiseux series f(x^r)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePuiseuxSeriesConstructor|
  (progn
    (push '|UnivariatePuiseuxSeriesConstructor| *Domains*)
    (make-instance '|UnivariatePuiseuxSeriesConstructorType|)))

\end{chunk}

\subsection{UnivariatePuiseuxSeriesWithExponentialSingularity}
\index[dom]{UnivariatePuiseuxSeriesWithExponentialSingularity!Domain}
\index[dom]{Domain!UnivariatePuiseuxSeriesWithExponentialSingularity}
\index[dom]{UPXSSING}
\begin{chunk}{defclass UnivariatePuiseuxSeriesWithExponentialSingularityType}
(defclass |UnivariatePuiseuxSeriesWithExponentialSingularityType| (|FiniteAbelianMonoidRingType|)
  ((parents :initform '(|FiniteAbelianMonoidRing|))
   (name :initform "UnivariatePuiseuxSeriesWithExponentialSingularity")
   (marker :initform 'domain)
   (abbreviation :initform 'UPXSSING)
   (comment :initform (list
     "UnivariatePuiseuxSeriesWithExponentialSingularity is a domain used to"
     "represent functions with essential singularities.  Objects in this"
     "domain are sums, where each term in the sum is a univariate Puiseux"
     "series times the exponential of a univariate Puiseux series.  Thus,"
     "the elements of this domain are sums of expressions of the form"
     "g(x) * exp(f(x)), where g(x) is a univariate Puiseux series"
     "and f(x) is a univariate Puiseux series with no terms of non-negative"
     "degree."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePuiseuxSeriesWithExponentialSingularity|
  (progn
    (push '|UnivariatePuiseuxSeriesWithExponentialSingularity| *Domains*)
    (make-instance '|UnivariatePuiseuxSeriesWithExponentialSingularityType|)))

\end{chunk}

\subsection{UnivariateSkewPolynomial}
\index[dom]{UnivariateSkewPolynomial!Domain}
\index[dom]{Domain!UnivariateSkewPolynomial}
\index[dom]{OREUP}
\begin{chunk}{defclass UnivariateSkewPolynomialType}
(defclass |UnivariateSkewPolynomialType| (|UnivariateSkewPolynomialCategoryType|)
  ((parents :initform '(|UnivariateSkewPolynomialCategory|))
   (name :initform "UnivariateSkewPolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'OREUP)
   (comment :initform (list
     "This is the domain of univariate skew polynomials over an Ore"
     "coefficient field in a named variable."
     "The multiplication is given by x a = sigma(a) x + delta a."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateSkewPolynomial|
  (progn
    (push '|UnivariateSkewPolynomial| *Domains*)
    (make-instance '|UnivariateSkewPolynomialType|)))

\end{chunk}

\subsection{UnivariateTaylorSeries}
\index[dom]{UnivariateTaylorSeries!Domain}
\index[dom]{Domain!UnivariateTaylorSeries}
\index[dom]{UTS}
\begin{chunk}{defclass UnivariateTaylorSeriesType}
(defclass |UnivariateTaylorSeriesType| (|UnivariateTaylorSeriesCategoryType|)
  ((parents :initform '(|UnivariateTaylorSeriesCategory|))
   (name :initform "UnivariateTaylorSeries")
   (marker :initform 'domain)
   (abbreviation :initform 'UTS)
   (comment :initform (list
     "Dense Taylor series in one variable"
     "UnivariateTaylorSeries is a domain representing Taylor"
     "series in"
     "one variable with coefficients in an arbitrary ring.  The parameters"
     "of the type specify the coefficient ring, the power series variable,"
     "and the center of the power series expansion.  For example,"
     "UnivariateTaylorSeries(Integer,x,3) represents"
     "Taylor series in"
     "(x - 3) with Integer coefficients."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateTaylorSeries|
  (progn
    (push '|UnivariateTaylorSeries| *Domains*)
    (make-instance '|UnivariateTaylorSeriesType|)))

\end{chunk}

\subsection{UnivariateTaylorSeriesCZero}
\index[dom]{UnivariateTaylorSeriesCZero!Domain}
\index[dom]{Domain!UnivariateTaylorSeriesCZero}
\index[dom]{UTSZ}
\begin{chunk}{defclass UnivariateTaylorSeriesCZeroType}
(defclass |UnivariateTaylorSeriesCZeroType| (|UnivariateTaylorSeriesCategoryType|)
  ((parents :initform '(|UnivariateTaylorSeriesCategory|))
   (name :initform "UnivariateTaylorSeriesCZero")
   (marker :initform 'domain)
   (abbreviation :initform 'UTSZ)
   (comment :initform (list
     "Part of the Package for Algebraic Function Fields in one variable PAFF"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateTaylorSeriesCZero|
  (progn
    (push '|UnivariateTaylorSeriesCZero| *Domains*)
    (make-instance '|UnivariateTaylorSeriesCZeroType|)))

\end{chunk}

\subsection{UniversalSegment}
\index[dom]{UniversalSegment!Domain}
\index[dom]{Domain!UniversalSegment}
\index[dom]{UNISEG}
\begin{chunk}{defclass UniversalSegmentType}
(defclass |UniversalSegmentType| (|SetCategoryType| |SegmentExpansionCategoryType|)
  ((parents :initform '(|SetCategory| |SegmentExpansionCategory|))
   (name :initform "UniversalSegment")
   (marker :initform 'domain)
   (abbreviation :initform 'UNISEG)
   (comment :initform (list
     "Part of the Package for Algebraic Function Fields in one variable PAFF"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UniversalSegment|
  (progn
    (push '|UniversalSegment| *Domains*)
    (make-instance '|UniversalSegmentType|)))

\end{chunk}

\subsection{U8Matrix}
\index[dom]{U8Matrix!Domain}
\index[dom]{Domain!U8Matrix}
\index[dom]{U8MAT}
\begin{chunk}{defclass U8MatrixType}
(defclass |U8MatrixType| (|MatrixCategoryType|)
  ((parents :initform '(|MatrixCategory|))
   (name :initform "U8Matrix")
   (marker :initform 'domain)
   (abbreviation :initform 'U8MAT)
   (comment :initform (list
     "This is a low-level domain which implements matrices"
     "(two dimensional arrays) of 8-bit integers."
     "Indexing is 0 based, there is no bound checking (unless"
     "provided by lower level)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |U8Matrix|
  (progn
    (push '|U8Matrix| *Domains*)
    (make-instance '|U8MatrixType|)))

\end{chunk}

\subsection{U16Matrix}
\index[dom]{U16Matrix!Domain}
\index[dom]{Domain!U16Matrix}
\index[dom]{U16MAT}
\begin{chunk}{defclass U16MatrixType}
(defclass |U16MatrixType| (|MatrixCategoryType|)
  ((parents :initform '(|MatrixCategory|))
   (name :initform "U16Matrix")
   (marker :initform 'domain)
   (abbreviation :initform 'U16MAT)
   (comment :initform (list
     "This is a low-level domain which implements matrices"
     "(two dimensional arrays) of 16-bit integers."
     "Indexing is 0 based, there is no bound checking (unless"
     "provided by lower level)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |U16Matrix|
  (progn
    (push '|U16Matrix| *Domains*)
    (make-instance '|U16MatrixType|)))

\end{chunk}

\subsection{U32Matrix}
\index[dom]{U32Matrix!Domain}
\index[dom]{Domain!U32Matrix}
\index[dom]{U32MAT}
\begin{chunk}{defclass U32MatrixType}
(defclass |U32MatrixType| (|MatrixCategoryType|)
  ((parents :initform '(|MatrixCategory|))
   (name :initform "U32Matrix")
   (marker :initform 'domain)
   (abbreviation :initform 'U32MAT)
   (comment :initform (list
     "This is a low-level domain which implements matrices"
     "(two dimensional arrays) of 32-bit integers."
     "Indexing is 0 based, there is no bound checking (unless"
     "provided by lower level)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |U32Matrix|
  (progn
    (push '|U32Matrix| *Domains*)
    (make-instance '|U32MatrixType|)))

\end{chunk}

\subsection{U8Vector}
\index[dom]{U8Vector!Domain}
\index[dom]{Domain!U8Vector}
\index[dom]{U8VEC}
\begin{chunk}{defclass U8VectorType}
(defclass |U8VectorType| (|OneDimensionalArrayAggregateType|)
  ((parents :initform '(|OneDimensionalArrayAggregate|))
   (name :initform "U8Vector")
   (marker :initform 'domain)
   (abbreviation :initform 'U8VEC)
   (comment :initform (list
     "This is a low-level domain which implements vectors"
     "(one dimensional arrays) of unsigned 8-bit numbers.  Indexing"
     "is 0 based, there is no bound checking (unless provided by"
     "lower level)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |U8Vector|
  (progn
    (push '|U8Vector| *Domains*)
    (make-instance '|U8VectorType|)))

\end{chunk}

\subsection{U16Vector}
\index[dom]{U16Vector!Domain}
\index[dom]{Domain!U16Vector}
\index[dom]{U16VEC}
\begin{chunk}{defclass U16VectorType}
(defclass |U16VectorType| (|OneDimensionalArrayAggregateType|)
  ((parents :initform '(|OneDimensionalArrayAggregate|))
   (name :initform "U16Vector")
   (marker :initform 'domain)
   (abbreviation :initform 'U16VEC)
   (comment :initform (list
     "This is a low-level domain which implements vectors"
     "(one dimensional arrays) of unsigned 16-bit numbers.  Indexing"
     "is 0 based, there is no bound checking (unless provided by"
     "lower level)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |U16Vector|
  (progn
    (push '|U16Vector| *Domains*)
    (make-instance '|U16VectorType|)))

\end{chunk}

\subsection{U32Vector}
\index[dom]{U32Vector!Domain}
\index[dom]{Domain!U32Vector}
\index[dom]{U32VEC}
\begin{chunk}{defclass U32VectorType}
(defclass |U32VectorType| (|OneDimensionalArrayAggregateType|)
  ((parents :initform '(|OneDimensionalArrayAggregate|))
   (name :initform "U32Vector")
   (marker :initform 'domain)
   (abbreviation :initform 'U32VEC)
   (comment :initform (list
     "This is a low-level domain which implements vectors"
     "(one dimensional arrays) of unsigned 32-bit numbers.  Indexing"
     "is 0 based, there is no bound checking (unless provided by"
     "lower level)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |U32Vector|
  (progn
    (push '|U32Vector| *Domains*)
    (make-instance '|U32VectorType|)))

\end{chunk}

\section{V}

\subsection{Variable}
\index[dom]{Variable!Domain}
\index[dom]{Domain!Variable}
\index[dom]{VARIABLE}
\begin{chunk}{defclass VariableType}
(defclass |VariableType| (|SetCategoryType|)
  ((parents :initform '(|SetCategory|))
   (name :initform "Variable")
   (marker :initform 'domain)
   (abbreviation :initform 'VARIABLE)
   (comment :initform (list
     "This domain implements variables"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Variable|
  (progn
    (push '|Variable| *Domains*)
    (make-instance '|VariableType|)))

\end{chunk}

\subsection{Vector}
\index[dom]{Vector!Domain}
\index[dom]{Domain!Vector}
\index[dom]{VECTOR}
\begin{chunk}{defclass VectorType}
(defclass |VectorType| (|VectorCategoryType|)
  ((parents :initform '(|VectorCategory|))
   (name :initform "Vector")
   (marker :initform 'domain)
   (abbreviation :initform 'VECTOR)
   (comment :initform (list
     "This type represents vector like objects with varying lengths"
     "and indexed by a finite segment of integers starting at 1."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Vector|
  (progn
    (push '|Vector| *Domains*)
    (make-instance '|VectorType|)))

\end{chunk}

\subsection{Void}
\index[dom]{Void!Domain}
\index[dom]{Domain!Void}
\index[dom]{VOID}
\begin{chunk}{defclass VoidType}
(defclass |VoidType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "Void")
   (marker :initform 'domain)
   (abbreviation :initform 'VOID)
   (comment :initform (list
     "This type is used when no value is needed, for example, in the then"
     "part of a one armed if."
     "All values can be coerced to type Void.  Once a value has been coerced"
     "to Void, it cannot be recovered."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Void|
  (progn
    (push '|Void| *Domains*)
    (make-instance '|VoidType|)))

\end{chunk}

\section{W}

\subsection{WeightedPolynomials}
\index[dom]{WeightedPolynomials!Domain}
\index[dom]{Domain!WeightedPolynomials}
\index[dom]{WP}
\begin{chunk}{defclass WeightedPolynomialsType}
(defclass |WeightedPolynomialsType| (|AlgebraType|)
  ((parents :initform '(|Algebra|))
   (name :initform "WeightedPolynomials")
   (marker :initform 'domain)
   (abbreviation :initform 'WP)
   (comment :initform (list
     "This domain represents truncated weighted polynomials over a general"
     "(not necessarily commutative) polynomial type. The variables must be"
     "specified, as must the weights."
     "The representation is sparse"
     "in the sense that only non-zero terms are represented."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |WeightedPolynomials|
  (progn
    (push '|WeightedPolynomials| *Domains*)
    (make-instance '|WeightedPolynomialsType|)))

\end{chunk}

\subsection{WuWenTsunTriangularSet}
\index[dom]{WuWenTsunTriangularSet!Domain}
\index[dom]{Domain!WuWenTsunTriangularSet}
\index[dom]{WUTSET}
\begin{chunk}{defclass WuWenTsunTriangularSetType}
(defclass |WuWenTsunTriangularSetType| (|TriangularSetCategoryType|)
  ((parents :initform '(|TriangularSetCategory|))
   (name :initform "WuWenTsunTriangularSet")
   (marker :initform 'domain)
   (abbreviation :initform 'WUTSET)
   (comment :initform (list
     "A domain constructor of the category GeneralTriangularSet."
     "The only requirement for a list of polynomials to be a member of such"
     "a domain is the following: no polynomial is constant and two distinct"
     "polynomials have distinct main variables. Such a triangular set may"
     "not be auto-reduced or consistent. The construct operation"
     "does not check the previous requirement. Triangular sets are stored"
     "as sorted lists w.r.t. the main variables of their members."
     "Furthermore, this domain exports operations dealing with the"
     "characteristic set method of Wu Wen Tsun and some optimizations"
     "mainly proposed by Dong Ming Wang."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |WuWenTsunTriangularSet|
  (progn
    (push '|WuWenTsunTriangularSet| *Domains*)
    (make-instance '|WuWenTsunTriangularSetType|)))

\end{chunk}

\section{X}

\subsection{XDistributedPolynomial}
\index[dom]{XDistributedPolynomial!Domain}
\index[dom]{Domain!XDistributedPolynomial}
\index[dom]{XDPOLY}
\begin{chunk}{defclass XDistributedPolynomialType}
(defclass |XDistributedPolynomialType| (|FreeModuleCatType| |XPolynomialsCatType|)
  ((parents :initform '(|FreeModuleCat| |XPolynomialsCat|))
   (name :initform "XDistributedPolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'XDPOLY)
   (comment :initform (list
     "This type supports distributed multivariate polynomials"
     "whose variables do not commute."
     "The coefficient ring may be non-commutative too."
     "However, coefficients and variables commute."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |XDistributedPolynomial|
  (progn
    (push '|XDistributedPolynomial| *Domains*)
    (make-instance '|XDistributedPolynomialType|)))

\end{chunk}

\subsection{XPBWPolynomial}
\index[dom]{XPBWPolynomial!Domain}
\index[dom]{Domain!XPBWPolynomial}
\index[dom]{XPBWPOLY}
\begin{chunk}{defclass XPBWPolynomialType}
(defclass |XPBWPolynomialType| (|FreeModuleCatType| |XPolynomialsCatType|)
  ((parents :initform '(|FreeModuleCat| |XPolynomialsCat|))
   (name :initform "XPBWPolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'XPBWPOLY)
   (comment :initform (list
     "This domain constructor implements polynomials in non-commutative"
     "variables written in the Poincare-Birkhoff-Witt basis from the"
     "Lyndon basis."
     "These polynomials can be used to compute Baker-Campbell-Hausdorff"
     "relations. "))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |XPBWPolynomial|
  (progn
    (push '|XPBWPolynomial| *Domains*)
    (make-instance '|XPBWPolynomialType|)))

\end{chunk}

\subsection{XPolynomial}
\index[dom]{XPolynomial!Domain}
\index[dom]{Domain!XPolynomial}
\index[dom]{XPOLY}
\begin{chunk}{defclass XPolynomialType}
(defclass |XPolynomialType| (|XPolynomialsCatType|)
  ((parents :initform '(|XPolynomialsCat|))
   (name :initform "XPolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'XPOLY)
   (comment :initform (list
     "This type supports multivariate polynomials whose set of variables"
     "is Symbol. The representation is recursive."
     "The coefficient ring may be non-commutative and the variables"
     "do not commute. However, coefficients and variables commute."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |XPolynomial|
  (progn
    (push '|XPolynomial| *Domains*)
    (make-instance '|XPolynomialType|)))

\end{chunk}

\subsection{XPolynomialRing}
\index[dom]{XPolynomialRing!Domain}
\index[dom]{Domain!XPolynomialRing}
\index[dom]{XPR}
\begin{chunk}{defclass XPolynomialRingType}
(defclass |XPolynomialRingType| (|FreeModuleCatType| |XAlgebraType|)
  ((parents :initform '(|FreeModuleCat| |XAlgebra|))
   (name :initform "XPolynomialRing")
   (marker :initform 'domain)
   (abbreviation :initform 'XPR)
   (comment :initform (list
     "This domain represents generalized polynomials with coefficients"
     "(from a not necessarily commutative ring), and words"
     "belonging to an arbitrary OrderedMonoid."
     "This type is used, for instance, by the XDistributedPolynomial" 
     "domain constructor where the Monoid is free."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |XPolynomialRing|
  (progn
    (push '|XPolynomialRing| *Domains*)
    (make-instance '|XPolynomialRingType|)))

\end{chunk}

\subsection{XRecursivePolynomial}
\index[dom]{XRecursivePolynomial!Domain}
\index[dom]{Domain!XRecursivePolynomial}
\index[dom]{XRPOLY}
\begin{chunk}{defclass XRecursivePolynomialType}
(defclass |XRecursivePolynomialType| (|XPolynomialsCatType|)
  ((parents :initform '(|XPolynomialsCat|))
   (name :initform "XRecursivePolynomial")
   (marker :initform 'domain)
   (abbreviation :initform 'XRPOLY)
   (comment :initform (list
     "This type supports multivariate polynomials whose variables do not commute."
     "The representation is recursive. The coefficient ring may be"
     "non-commutative. Coefficients and variables commute."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |XRecursivePolynomial|
  (progn
    (push '|XRecursivePolynomial| *Domains*)
    (make-instance '|XRecursivePolynomialType|)))

\end{chunk}

\chapter{The Packages}

\section{A}

\subsection{AffineAlgebraicSetComputeWithGroebnerBasis}
\index[pkg]{AffineAlgebraicSetComputeWithGroebnerBasis!Domain}
\index[pkg]{Domain!AffineAlgebraicSetComputeWithGroebnerBasis}
\index[pkg]{AFALGGRO}
\begin{chunk}{defclass AffineAlgebraicSetComputeWithGroebnerBasisType}
(defclass |AffineAlgebraicSetComputeWithGroebnerBasisType| (|AxiomClass|)
  ((parents :initform '())
   (name :initform "AffineAlgebraicSetComputeWithGroebnerBasis")
   (marker :initform 'package)
   (abbreviation :initform 'AFALGGRO)
   (comment :initform (list
     "The following is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AffineAlgebraicSetComputeWithGroebnerBasis|
  (progn
    (push '|AffineAlgebraicSetComputeWithGroebnerBasis| *Packages*)
    (make-instance '|AffineAlgebraicSetComputeWithGroebnerBasisType|)))

\end{chunk}

\subsection{AffineAlgebraicSetComputeWithResultant}
\index[pkg]{AffineAlgebraicSetComputeWithResultant!Domain}
\index[pkg]{Domain!AffineAlgebraicSetComputeWithResultant}
\index[pkg]{AFALGRES}
\begin{chunk}{defclass AffineAlgebraicSetComputeWithResultantType}
(defclass |AffineAlgebraicSetComputeWithResultantType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AffineAlgebraicSetComputeWithResultant")
   (marker :initform 'package)
   (abbreviation :initform 'AFALGRES)
   (comment :initform (list
     "The following is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
    (withlist :initform nil)
   (haslist :initform nil)
    (addlist :initform nil)))

 (defvar |AffineAlgebraicSetComputeWithResultant|
   (progn
     (push '|AffineAlgebraicSetComputeWithResultant| *Packages*)
     (make-instance '|AffineAlgebraicSetComputeWithResultantType|)))

\end{chunk}

\subsection{AlgebraicFunction}
\index[pkg]{AlgebraicFunction!Domain}
\index[pkg]{Domain!AlgebraicFunction}
\index[pkg]{AF}
\begin{chunk}{(defclass AlgebraicFunctionType}
 (defclass |AlgebraicFunctionType| (|AxiomClass|)
   ((parents :initform ())
    (name :initform "AlgebraicFunction")
    (marker :initform 'package)
    (abbreviation :initform 'AF)
   (comment :initform (list
     "This package provides algebraic functions over an integral domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AlgebraicFunction|
  (progn
    (push '|AlgebraicFunction| *Packages*)
    (make-instance '|AlgebraicFunctionType|)))

\end{chunk}

\subsection{AlgebraicHermiteIntegration}
\index[pkg]{AlgebraicHermiteIntegration!Domain}
\index[pkg]{Domain!AlgebraicHermiteIntegration}
\index[pkg]{INTHERAL}
\begin{chunk}{defclass AlgebraicHermiteIntegrationType}
(defclass |AlgebraicHermiteIntegrationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AlgebraicHermiteIntegration")
   (marker :initform 'package)
   (abbreviation :initform 'INTHERAL)
   (comment :initform (list
     "Algebraic Hermite reduction."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AlgebraicHermiteIntegration|
  (progn
    (push '|AlgebraicHermiteIntegration| *Packages*)
    (make-instance '|AlgebraicHermiteIntegrationType|)))

\end{chunk}

\subsection{AlgebraicIntegrate}
\index[pkg]{AlgebraicIntegrate!Domain}
\index[pkg]{Domain!AlgebraicIntegrate}
\index[pkg]{INTALG}
\begin{chunk}{defclass AlgebraicIntegrateType}
(defclass |AlgebraicIntegrateType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AlgebraicIntegrate")
   (marker :initform 'package)
   (abbreviation :initform 'INTALG)
   (comment :initform (list
     "This package provides functions for integrating a function"
     "on an algebraic curve."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AlgebraicIntegrate|
  (progn
    (push '|AlgebraicIntegrate| *Packages*)
    (make-instance '|AlgebraicIntegrateType|)))

\end{chunk}

\subsection{AlgebraicIntegration}
\index[pkg]{AlgebraicIntegration!Domain}
\index[pkg]{Domain!AlgebraicIntegration}
\index[pkg]{INTAF}
\begin{chunk}{defclass AlgebraicIntegrationType}
(defclass |AlgebraicIntegrationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AlgebraicIntegration")
   (marker :initform 'package)
   (abbreviation :initform 'INTAF)
   (comment :initform (list
     "This package provides functions for the integration of"
     "algebraic integrands over transcendental functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AlgebraicIntegration|
  (progn
    (push '|AlgebraicIntegration| *Packages*)
    (make-instance '|AlgebraicIntegrationType|)))

\end{chunk}

\subsection{AlgebraicManipulations}
\index[pkg]{AlgebraicManipulations!Domain}
\index[pkg]{Domain!AlgebraicManipulations}
\index[pkg]{ALGMANIP}
\begin{chunk}{defclass AlgebraicManipulationsType}
(defclass |AlgebraicManipulationsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AlgebraicManipulations")
   (marker :initform 'package)
   (abbreviation :initform 'ALGMANIP)
   (comment :initform (list
     "AlgebraicManipulations provides functions to simplify and expand"
     "expressions involving algebraic operators."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AlgebraicManipulations|
  (progn
    (push '|AlgebraicManipulations| *Packages*)
    (make-instance '|AlgebraicManipulationsType|)))

\end{chunk}

\subsection{AlgebraicMultFact}
\index[pkg]{AlgebraicMultFact!Domain}
\index[pkg]{Domain!AlgebraicMultFact}
\index[pkg]{ALGMFACT}
\begin{chunk}{defclass AlgebraicMultFactType}
(defclass |AlgebraicMultFactType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AlgebraicMultFact")
   (marker :initform 'package)
   (abbreviation :initform 'ALGMFACT)
   (comment :initform (list
     "This package factors multivariate polynomials over the"
     "domain of AlgebraicNumber by allowing the user"
     "to specify a list of algebraic numbers generating the particular"
     "extension to factor over."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AlgebraicMultFact|
  (progn
    (push '|AlgebraicMultFact| *Packages*)
    (make-instance '|AlgebraicMultFactType|)))

\end{chunk}

\subsection{AlgebraPackage}
\index[pkg]{AlgebraPackage!Domain}
\index[pkg]{Domain!AlgebraPackage}
\index[pkg]{ALGPKG}
\begin{chunk}{defclass AlgebraPackageType}
(defclass |AlgebraPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AlgebraPackage")
   (marker :initform 'package)
   (abbreviation :initform 'ALGPKG)
   (comment :initform (list
     "AlgebraPackage assembles a variety of useful functions for"
     "general algebras."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AlgebraPackage|
  (progn
    (push '|AlgebraPackage| *Packages*)
    (make-instance '|AlgebraPackageType|)))

\end{chunk}

\subsection{AlgFactor}
\index[pkg]{AlgFactor!Domain}
\index[pkg]{Domain!AlgFactor}
\index[pkg]{ALGFACT}
\begin{chunk}{defclass AlgFactorType}
(defclass |AlgFactorType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AlgFactor")
   (marker :initform 'package)
   (abbreviation :initform 'ALGFACT)
   (comment :initform (list
     "Factorization of univariate polynomials with coefficients in"
     "AlgebraicNumber."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AlgFactor|
  (progn
    (push '|AlgFactor| *Packages*)
    (make-instance '|AlgFactorType|)))

\end{chunk}

\subsection{AnnaNumericalIntegrationPackage}
\index[pkg]{AnnaNumericalIntegrationPackage!Domain}
\index[pkg]{Domain!AnnaNumericalIntegrationPackage}
\index[pkg]{INTPACK}
\begin{chunk}{defclass AnnaNumericalIntegrationPackageType}
(defclass |AnnaNumericalIntegrationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AnnaNumericalIntegrationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'INTPACK)
   (comment :initform (list
     "AnnaNumericalIntegrationPackage is a package"
     "of functions for the category" 
     "NumericalIntegrationCategory"
     "with measure, and integrate."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AnnaNumericalIntegrationPackage|
  (progn
    (push '|AnnaNumericalIntegrationPackage| *Packages*)
    (make-instance '|AnnaNumericalIntegrationPackageType|)))

\end{chunk}

\subsection{AnnaNumericalOptimizationPackage}
\index[pkg]{AnnaNumericalOptimizationPackage!Domain}
\index[pkg]{Domain!AnnaNumericalOptimizationPackage}
\index[pkg]{OPTPACK}
\begin{chunk}{defclass AnnaNumericalOptimizationPackageType}
(defclass |AnnaNumericalOptimizationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AnnaNumericalOptimizationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'OPTPACK)
   (comment :initform (list
     "AnnaNumericalOptimizationPackage is a package of"
     "functions for the NumericalOptimizationCategory"
     "with measure and optimize."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AnnaNumericalOptimizationPackage|
  (progn
    (push '|AnnaNumericalOptimizationPackage| *Packages*)
    (make-instance '|AnnaNumericalOptimizationPackageType|)))

\end{chunk}

\subsection{AnnaOrdinaryDifferentialEquationPackage}
\index[pkg]{AnnaOrdinaryDifferentialEquationPackage!Domain}
\index[pkg]{Domain!AnnaOrdinaryDifferentialEquationPackage}
\index[pkg]{ODEPACK}
\begin{chunk}{defclass AnnaOrdinaryDifferentialEquationPackageType}
(defclass |AnnaOrdinaryDifferentialEquationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AnnaOrdinaryDifferentialEquationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'ODEPACK)
   (comment :initform (list
     "AnnaOrdinaryDifferentialEquationPackage is a package"
     "of functions for the category"
     "OrdinaryDifferentialEquationsSolverCategory"
     "with measure, and solve."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AnnaOrdinaryDifferentialEquationPackage|
  (progn
    (push '|AnnaOrdinaryDifferentialEquationPackage| *Packages*)
    (make-instance '|AnnaOrdinaryDifferentialEquationPackageType|)))

\end{chunk}

\subsection{AnnaPartialDifferentialEquationPackage}
\index[pkg]{AnnaPartialDifferentialEquationPackage!Domain}
\index[pkg]{Domain!AnnaPartialDifferentialEquationPackage}
\index[pkg]{PDEPACK}
\begin{chunk}{defclass AnnaPartialDifferentialEquationPackageType}
(defclass |AnnaPartialDifferentialEquationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AnnaPartialDifferentialEquationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'PDEPACK)
   (comment :initform (list
     "AnnaPartialDifferentialEquationPackage is an uncompleted"
     "package for the interface to NAG PDE routines.  It has been realised that"
     "a new approach to solving PDEs will need to be created."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AnnaPartialDifferentialEquationPackage|
  (progn
    (push '|AnnaPartialDifferentialEquationPackage| *Packages*)
    (make-instance '|AnnaPartialDifferentialEquationPackageType|)))

\end{chunk}

\subsection{AnyFunctions1}
\index[pkg]{AnyFunctions1!Domain}
\index[pkg]{Domain!AnyFunctions1}
\index[pkg]{ANY1}
\begin{chunk}{defclass AnyFunctions1Type}
(defclass |AnyFunctions1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AnyFunctions1")
   (marker :initform 'package)
   (abbreviation :initform 'ANY1)
   (comment :initform (list
     "AnyFunctions1 implements several utility functions for"
     "working with Any. These functions are used to go back"
     "and forth between objects of Any and objects of other"
     "types."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AnyFunctions1|
  (progn
    (push '|AnyFunctions1| *Packages*)
    (make-instance '|AnyFunctions1Type|)))

\end{chunk}

\subsection{ApplicationProgramInterface}
\index[pkg]{ApplicationProgramInterface!Domain}
\index[pkg]{Domain!ApplicationProgramInterface}
\index[pkg]{API}
\begin{chunk}{defclass ApplicationProgramInterfaceType}
(defclass |ApplicationProgramInterfaceType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ApplicationProgramInterface")
   (marker :initform 'package)
   (abbreviation :initform 'API)
   (comment :initform (list
     "This package contains useful functions that expose Axiom system internals"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ApplicationProgramInterface|
  (progn
    (push '|ApplicationProgramInterface| *Packages*)
    (make-instance '|ApplicationProgramInterfaceType|)))

\end{chunk}

\subsection{ApplyRules}
\index[pkg]{ApplyRules!Domain}
\index[pkg]{Domain!ApplyRules}
\index[pkg]{APPRULE}
\begin{chunk}{defclass ApplyRulesType}
(defclass |ApplyRulesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ApplyRules")
   (marker :initform 'package)
   (abbreviation :initform 'APPRULE)
   (comment :initform (list
     "This package apply rewrite rules to expressions, calling"
     "the pattern matcher."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ApplyRules|
  (progn
    (push '|ApplyRules| *Packages*)
    (make-instance '|ApplyRulesType|)))

\end{chunk}

\subsection{ApplyUnivariateSkewPolynomial}
\index[pkg]{ApplyUnivariateSkewPolynomial!Domain}
\index[pkg]{Domain!ApplyUnivariateSkewPolynomial}
\index[pkg]{APPLYORE}
\begin{chunk}{defclass ApplyUnivariateSkewPolynomialType}
(defclass |ApplyUnivariateSkewPolynomialType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ApplyUnivariateSkewPolynomial")
   (marker :initform 'package)
   (abbreviation :initform 'APPLYORE)
   (comment :initform (list
     "ApplyUnivariateSkewPolynomial (internal) allows univariate"
     "skew polynomials to be applied to appropriate modules."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ApplyUnivariateSkewPolynomial|
  (progn
    (push '|ApplyUnivariateSkewPolynomial| *Packages*)
    (make-instance '|ApplyUnivariateSkewPolynomialType|)))

\end{chunk}

\subsection{AssociatedEquations}
\index[pkg]{AssociatedEquations!Domain}
\index[pkg]{Domain!AssociatedEquations}
\index[pkg]{ASSOCEQ}
\begin{chunk}{defclass AssociatedEquationsType}
(defclass |AssociatedEquationsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AssociatedEquations")
   (marker :initform 'package)
   (abbreviation :initform 'ASSOCEQ)
   (comment :initform (list
     "AssociatedEquations provides functions to compute the"
     "associated equations needed for factoring operators"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AssociatedEquations|
  (progn
    (push '|AssociatedEquations| *Packages*)
    (make-instance '|AssociatedEquationsType|)))

\end{chunk}

\subsection{AttachPredicates}
\index[pkg]{AttachPredicates!Domain}
\index[pkg]{Domain!AttachPredicates}
\index[pkg]{PMPRED}
\begin{chunk}{defclass AttachPredicatesType}
(defclass |AttachPredicatesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AttachPredicates")
   (marker :initform 'package)
   (abbreviation :initform 'PMPRED)
   (comment :initform (list
     "Attaching predicates to symbols for pattern matching."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AttachPredicates|
  (progn
    (push '|AttachPredicates| *Packages*)
    (make-instance '|AttachPredicatesType|)))

\end{chunk}

\subsection{AxiomServer}
\index[pkg]{AxiomServer!Domain}
\index[pkg]{Domain!AxiomServer}
\index[pkg]{AXSERV}
\begin{chunk}{defclass AxiomServerType}
(defclass |AxiomServerType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "AxiomServer")
   (marker :initform 'package)
   (abbreviation :initform 'AXSERV)
   (comment :initform (list
     "This package provides a functions to support a web server for the"
     "new Axiom Browser functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |AxiomServer|
  (progn
    (push '|AxiomServer| *Packages*)
    (make-instance '|AxiomServerType|)))

\end{chunk}

\section{B}

\subsection{BalancedFactorisation}
\index[pkg]{BalancedFactorisation!Domain}
\index[pkg]{Domain!BalancedFactorisation}
\index[pkg]{BALFACT}
\begin{chunk}{defclass BalancedFactorisationType}
(defclass |BalancedFactorisationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "BalancedFactorisation")
   (marker :initform 'package)
   (abbreviation :initform 'BALFACT)
   (comment :initform (list
     "This package provides balanced factorisations of polynomials."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BalancedFactorisation|
  (progn
    (push '|BalancedFactorisation| *Packages*)
    (make-instance '|BalancedFactorisationType|)))

\end{chunk}

\subsection{BasicOperatorFunctions1}
\index[pkg]{BasicOperatorFunctions1!Domain}
\index[pkg]{Domain!BasicOperatorFunctions1}
\index[pkg]{BOP1}
\begin{chunk}{defclass BasicOperatorFunctions1Type}
(defclass |BasicOperatorFunctions1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "BasicOperatorFunctions1")
   (marker :initform 'package)
   (abbreviation :initform 'BOP1)
   (comment :initform (list
     "This package exports functions to set some commonly used properties"
     "of operators, including properties which contain functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BasicOperatorFunctions1|
  (progn
    (push '|BasicOperatorFunctions1| *Packages*)
    (make-instance '|BasicOperatorFunctions1Type|)))

\end{chunk}

\subsection{Bezier}
\index[pkg]{Bezier!Domain}
\index[pkg]{Domain!Bezier}
\index[pkg]{BEZIER}
\begin{chunk}{defclass BezierType}
(defclass |BezierType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "Bezier")
   (marker :initform 'package)
   (abbreviation :initform 'BEZIER)
   (comment :initform (list
     "Provide linear, quadratic, and cubic spline bezier curves"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Bezier|
  (progn
    (push '|Bezier| *Packages*)
    (make-instance '|BezierType|)))

\end{chunk}

\subsection{BezoutMatrix}
\index[pkg]{BezoutMatrix!Domain}
\index[pkg]{Domain!BezoutMatrix}
\index[pkg]{BEZOUT}
\begin{chunk}{defclass BezoutMatrixType}
(defclass |BezoutMatrixType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "BezoutMatrix")
   (marker :initform 'package)
   (abbreviation :initform 'BEZOUT)
   (comment :initform (list
     "BezoutMatrix contains functions for computing resultants and"
     "discriminants using Bezout matrices."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BezoutMatrix|
  (progn
    (push '|BezoutMatrix| *Packages*)
    (make-instance '|BezoutMatrixType|)))

\end{chunk}

\subsection{BlowUpPackage}
\index[pkg]{BlowUpPackage!Domain}
\index[pkg]{Domain!BlowUpPackage}
\index[pkg]{BLUPPACK}
\begin{chunk}{defclass BlowUpPackageType}
(defclass |BlowUpPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "BlowUpPackage")
   (marker :initform 'package)
   (abbreviation :initform 'BLUPPACK)
   (comment :initform (list
     "The following is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BlowUpPackage|
  (progn
    (push '|BlowUpPackage| *Packages*)
    (make-instance '|BlowUpPackageType|)))

\end{chunk}

\subsection{BoundIntegerRoots}
\index[pkg]{BoundIntegerRoots!Domain}
\index[pkg]{Domain!BoundIntegerRoots}
\index[pkg]{BOUNDZRO}
\begin{chunk}{defclass BoundIntegerRootsType}
(defclass |BoundIntegerRootsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "BoundIntegerRoots")
   (marker :initform 'package)
   (abbreviation :initform 'BOUNDZRO)
   (comment :initform (list
     "BoundIntegerRoots provides functions to"
     "find lower bounds on the integer roots of a polynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BoundIntegerRoots|
  (progn
    (push '|BoundIntegerRoots| *Packages*)
    (make-instance '|BoundIntegerRootsType|)))

\end{chunk}

\subsection{BrillhartTests}
\index[pkg]{BrillhartTests!Domain}
\index[pkg]{Domain!BrillhartTests}
\index[pkg]{BRILL}
\begin{chunk}{defclass BrillhartTestsType}
(defclass |BrillhartTestsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "BrillhartTests")
   (marker :initform 'package)
   (abbreviation :initform 'BRILL)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |BrillhartTests|
  (progn
    (push '|BrillhartTests| *Packages*)
    (make-instance '|BrillhartTestsType|)))

\end{chunk}

\section{C}

\subsection{CartesianTensorFunctions2}
\index[pkg]{CartesianTensorFunctions2!Domain}
\index[pkg]{Domain!CartesianTensorFunctions2}
\index[pkg]{CARTEN2}
\begin{chunk}{defclass CartesianTensorFunctions2Type}
(defclass |CartesianTensorFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CartesianTensorFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'CARTEN2)
   (comment :initform (list
     "This package provides functions to enable conversion of tensors"
     "given conversion of the components."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CartesianTensorFunctions2|
  (progn
    (push '|CartesianTensorFunctions2| *Packages*)
    (make-instance '|CartesianTensorFunctions2Type|)))

\end{chunk}

\subsection{ChangeOfVariable}
\index[pkg]{ChangeOfVariable!Domain}
\index[pkg]{Domain!ChangeOfVariable}
\index[pkg]{CHVAR}
\begin{chunk}{defclass ChangeOfVariableType}
(defclass |ChangeOfVariableType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ChangeOfVariable")
   (marker :initform 'package)
   (abbreviation :initform 'CHVAR)
   (comment :initform (list
     "Tools to send a point to infinity on an algebraic curve."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ChangeOfVariable|
  (progn
    (push '|ChangeOfVariable| *Packages*)
    (make-instance '|ChangeOfVariableType|)))

\end{chunk}

\subsection{CharacteristicPolynomialInMonogenicalAlgebra}
\index[pkg]{CharacteristicPolynomialInMonogenicalAlgebra!Domain}
\index[pkg]{Domain!CharacteristicPolynomialInMonogenicalAlgebra}
\index[pkg]{CPIMA}
\begin{chunk}{defclass CharacteristicPolynomialInMonogenicalAlgebraType}
(defclass |CharacteristicPolynomialInMonogenicalAlgebraType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CharacteristicPolynomialInMonogenicalAlgebra")
   (marker :initform 'package)
   (abbreviation :initform 'CPIMA)
   (comment :initform (list
     "This package implements characteristicPolynomials for monogenic algebras"
     "using resultants"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CharacteristicPolynomialInMonogenicalAlgebra|
  (progn
    (push '|CharacteristicPolynomialInMonogenicalAlgebra| *Packages*)
    (make-instance '|CharacteristicPolynomialInMonogenicalAlgebraType|)))

\end{chunk}

\subsection{CharacteristicPolynomialPackage}
\index[pkg]{CharacteristicPolynomialPackage!Domain}
\index[pkg]{Domain!CharacteristicPolynomialPackage}
\index[pkg]{CHARPOL}
\begin{chunk}{defclass CharacteristicPolynomialPackageType}
(defclass |CharacteristicPolynomialPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CharacteristicPolynomialPackage")
   (marker :initform 'package)
   (abbreviation :initform 'CHARPOL)
   (comment :initform (list
     "This package provides a characteristicPolynomial function"
     "for any matrix over a commutative ring."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CharacteristicPolynomialPackage|
  (progn
    (push '|CharacteristicPolynomialPackage| *Packages*)
    (make-instance '|CharacteristicPolynomialPackageType|)))

\end{chunk}

\subsection{ChineseRemainderToolsForIntegralBases}
\index[pkg]{ChineseRemainderToolsForIntegralBases!Domain}
\index[pkg]{Domain!ChineseRemainderToolsForIntegralBases}
\index[pkg]{IBACHIN}
\begin{chunk}{defclass ChineseRemainderToolsForIntegralBasesType}
(defclass |ChineseRemainderToolsForIntegralBasesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ChineseRemainderToolsForIntegralBases")
   (marker :initform 'package)
   (abbreviation :initform 'IBACHIN)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ChineseRemainderToolsForIntegralBases|
  (progn
    (push '|ChineseRemainderToolsForIntegralBases| *Packages*)
    (make-instance '|ChineseRemainderToolsForIntegralBasesType|)))

\end{chunk}

\subsection{CoerceVectorMatrixPackage}
\index[pkg]{CoerceVectorMatrixPackage!Domain}
\index[pkg]{Domain!CoerceVectorMatrixPackage}
\index[pkg]{CVMP}
\begin{chunk}{defclass CoerceVectorMatrixPackageType}
(defclass |CoerceVectorMatrixPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CoerceVectorMatrixPackage")
   (marker :initform 'package)
   (abbreviation :initform 'CVMP)
   (comment :initform (list
     "CoerceVectorMatrixPackage is an unexposed, technical package"
     "for data conversions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CoerceVectorMatrixPackage|
  (progn
    (push '|CoerceVectorMatrixPackage| *Packages*)
    (make-instance '|CoerceVectorMatrixPackageType|)))

\end{chunk}

\subsection{CombinatorialFunction}
\index[pkg]{CombinatorialFunction!Domain}
\index[pkg]{Domain!CombinatorialFunction}
\index[pkg]{COMBF}
\begin{chunk}{defclass CombinatorialFunctionType}
(defclass |CombinatorialFunctionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CombinatorialFunction")
   (marker :initform 'package)
   (abbreviation :initform 'COMBF)
   (comment :initform (list
     "Provides combinatorial functions over an integral domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CombinatorialFunction|
  (progn
    (push '|CombinatorialFunction| *Packages*)
    (make-instance '|CombinatorialFunctionType|)))

\end{chunk}

\subsection{CommonDenominator}
\index[pkg]{CommonDenominator!Domain}
\index[pkg]{Domain!CommonDenominator}
\index[pkg]{CDEN}
\begin{chunk}{defclass CommonDenominatorType}
(defclass |CommonDenominatorType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CommonDenominator")
   (marker :initform 'package)
   (abbreviation :initform 'CDEN)
   (comment :initform (list
     "CommonDenominator provides functions to compute the"
     "common denominator of a finite linear aggregate of elements of"
     "the quotient field of an integral domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CommonDenominator|
  (progn
    (push '|CommonDenominator| *Packages*)
    (make-instance '|CommonDenominatorType|)))

\end{chunk}

\subsection{CommonOperators}
\index[pkg]{CommonOperators!Domain}
\index[pkg]{Domain!CommonOperators}
\index[pkg]{COMMONOP}
\begin{chunk}{defclass CommonOperatorsType}
(defclass |CommonOperatorsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CommonOperators")
   (marker :initform 'package)
   (abbreviation :initform 'COMMONOP)
   (comment :initform (list
     "This package exports the elementary operators, with some semantics"
     "already attached to them. The semantics that is attached here is not"
     "dependent on the set in which the operators will be applied."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CommonOperators|
  (progn
    (push '|CommonOperators| *Packages*)
    (make-instance '|CommonOperatorsType|)))

\end{chunk}

\subsection{CommuteUnivariatePolynomialCategory}
\index[pkg]{CommuteUnivariatePolynomialCategory!Domain}
\index[pkg]{Domain!CommuteUnivariatePolynomialCategory}
\index[pkg]{COMMUPC}
\begin{chunk}{defclass CommuteUnivariatePolynomialCategoryType}
(defclass |CommuteUnivariatePolynomialCategoryType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CommuteUnivariatePolynomialCategory")
   (marker :initform 'package)
   (abbreviation :initform 'COMMUPC)
   (comment :initform (list
     "A package for swapping the order of two variables in a tower of two"
     "UnivariatePolynomialCategory extensions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CommuteUnivariatePolynomialCategory|
  (progn
    (push '|CommuteUnivariatePolynomialCategory| *Packages*)
    (make-instance '|CommuteUnivariatePolynomialCategoryType|)))

\end{chunk}

\subsection{ComplexFactorization}
\index[pkg]{ComplexFactorization!Domain}
\index[pkg]{Domain!ComplexFactorization}
\index[pkg]{COMPFACT}
\begin{chunk}{defclass ComplexFactorizationType}
(defclass |ComplexFactorizationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ComplexFactorization")
   (marker :initform 'package)
   (abbreviation :initform 'COMPFACT)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ComplexFactorization|
  (progn
    (push '|ComplexFactorization| *Packages*)
    (make-instance '|ComplexFactorizationType|)))

\end{chunk}

\subsection{ComplexFunctions2}
\index[pkg]{ComplexFunctions2!Domain}
\index[pkg]{Domain!ComplexFunctions2}
\index[pkg]{COMPLEX2}
\begin{chunk}{defclass ComplexFunctions2Type}
(defclass |ComplexFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ComplexFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'COMPLEX2)
   (comment :initform (list
     "This package extends maps from underlying rings to maps between"
     "complex over those rings."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ComplexFunctions2|
  (progn
    (push '|ComplexFunctions2| *Packages*)
    (make-instance '|ComplexFunctions2Type|)))

\end{chunk}

\subsection{ComplexIntegerSolveLinearPolynomialEquation}
\index[pkg]{ComplexIntegerSolveLinearPolynomialEquation!Domain}
\index[pkg]{Domain!ComplexIntegerSolveLinearPolynomialEquation}
\index[pkg]{CINTSLPE}
\begin{chunk}{defclass ComplexIntegerSolveLinearPolynomialEquationType}
(defclass |ComplexIntegerSolveLinearPolynomialEquationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ComplexIntegerSolveLinearPolynomialEquation")
   (marker :initform 'package)
   (abbreviation :initform 'CINTSLPE)
   (comment :initform (list
     "This package provides the generalized euclidean algorithm which is"
     "needed as the basic step for factoring polynomials."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ComplexIntegerSolveLinearPolynomialEquation|
  (progn
    (push '|ComplexIntegerSolveLinearPolynomialEquation| *Packages*)
    (make-instance '|ComplexIntegerSolveLinearPolynomialEquationType|)))

\end{chunk}

\subsection{ComplexPattern}
\index[pkg]{ComplexPattern!Domain}
\index[pkg]{Domain!ComplexPattern}
\index[pkg]{COMPLPAT}
\begin{chunk}{defclass ComplexPatternType}
(defclass |ComplexPatternType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ComplexPattern")
   (marker :initform 'package)
   (abbreviation :initform 'COMPLPAT)
   (comment :initform (list
     "This package supports converting complex expressions to patterns"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ComplexPattern|
  (progn
    (push '|ComplexPattern| *Packages*)
    (make-instance '|ComplexPatternType|)))

\end{chunk}

\subsection{ComplexPatternMatch}
\index[pkg]{ComplexPatternMatch!Domain}
\index[pkg]{Domain!ComplexPatternMatch}
\index[pkg]{CPMATCH}
\begin{chunk}{defclass ComplexPatternMatchType}
(defclass |ComplexPatternMatchType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ComplexPatternMatch")
   (marker :initform 'package)
   (abbreviation :initform 'CPMATCH)
   (comment :initform (list
     "This package supports matching patterns involving complex expressions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ComplexPatternMatch|
  (progn
    (push '|ComplexPatternMatch| *Packages*)
    (make-instance '|ComplexPatternMatchType|)))

\end{chunk}

\subsection{ComplexRootFindingPackage}
\index[pkg]{ComplexRootFindingPackage!Domain}
\index[pkg]{Domain!ComplexRootFindingPackage}
\index[pkg]{CRFP}
\begin{chunk}{defclass ComplexRootFindingPackageType}
(defclass |ComplexRootFindingPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ComplexRootFindingPackage")
   (marker :initform 'package)
   (abbreviation :initform 'CRFP)
   (comment :initform (list
     "ComplexRootFindingPackage provides functions to"
     "find all roots of a polynomial p over the complex number by"
     "using Plesken's idea to calculate in the polynomial ring"
     "modulo f and employing the Chinese Remainder Theorem."
     "In this first version, the precision (see digits)"
     "is not increased when this is necessary to"
     "avoid rounding errors. Hence it is the user's responsibility to"
     "increase the precision if necessary."
     "Note also, if this package is called with, for example, Fraction Integer,"
     "the precise calculations could require a lot of time."
     "Also note that evaluating the zeros is not necessarily a good check"
     "whether the result is correct: already evaluation can cause"
     "rounding errors."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ComplexRootFindingPackage|
  (progn
    (push '|ComplexRootFindingPackage| *Packages*)
    (make-instance '|ComplexRootFindingPackageType|)))

\end{chunk}

\subsection{ComplexRootPackage}
\index[pkg]{ComplexRootPackage!Domain}
\index[pkg]{Domain!ComplexRootPackage}
\index[pkg]{CMPLXRT}
\begin{chunk}{defclass ComplexRootPackageType}
(defclass |ComplexRootPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ComplexRootPackage")
   (marker :initform 'package)
   (abbreviation :initform 'CMPLXRT)
   (comment :initform (list
     "This package provides functions complexZeros"
     "for finding the complex zeros"
     "of univariate polynomials with complex rational number coefficients."
     "The results are to any user specified precision and are returned"
     "as either complex rational number or complex floating point numbers"
     "depending on the type of the second argument which specifies the"
     "precision."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ComplexRootPackage|
  (progn
    (push '|ComplexRootPackage| *Packages*)
    (make-instance '|ComplexRootPackageType|)))

\end{chunk}

\subsection{ComplexTrigonometricManipulations}
\index[pkg]{ComplexTrigonometricManipulations!Domain}
\index[pkg]{Domain!ComplexTrigonometricManipulations}
\index[pkg]{CTRIGMNP}
\begin{chunk}{defclass ComplexTrigonometricManipulationsType}
(defclass |ComplexTrigonometricManipulationsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ComplexTrigonometricManipulations")
   (marker :initform 'package)
   (abbreviation :initform 'CTRIGMNP)
   (comment :initform (list
     "ComplexTrigonometricManipulations provides function that"
     "compute the real and imaginary parts of complex functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ComplexTrigonometricManipulations|
  (progn
    (push '|ComplexTrigonometricManipulations| *Packages*)
    (make-instance '|ComplexTrigonometricManipulationsType|)))

\end{chunk}

\subsection{ConstantLODE}
\index[pkg]{ConstantLODE!Domain}
\index[pkg]{Domain!ConstantLODE}
\index[pkg]{ODECONST}
\begin{chunk}{defclass ConstantLODEType}
(defclass |ConstantLODEType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ConstantLODE")
   (marker :initform 'package)
   (abbreviation :initform 'ODECONST)
   (comment :initform (list
     "Solution of linear ordinary differential equations,"
     "constant coefficient case."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ConstantLODE|
  (progn
    (push '|ConstantLODE| *Packages*)
    (make-instance '|ConstantLODEType|)))

\end{chunk}

\subsection{CoordinateSystems}
\index[pkg]{CoordinateSystems!Domain}
\index[pkg]{Domain!CoordinateSystems}
\index[pkg]{COORDSYS}
\begin{chunk}{defclass CoordinateSystemsType}
(defclass |CoordinateSystemsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CoordinateSystems")
   (marker :initform 'package)
   (abbreviation :initform 'COORDSYS)
   (comment :initform (list
     "CoordinateSystems provides coordinate transformation functions"
     "for plotting.  Functions in this package return conversion functions"
     "which take points expressed in other coordinate systems and return points"
     "with the corresponding Cartesian coordinates."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CoordinateSystems|
  (progn
    (push '|CoordinateSystems| *Packages*)
    (make-instance '|CoordinateSystemsType|)))

\end{chunk}

\subsection{CRApackage}
\index[pkg]{CRApackage!Domain}
\index[pkg]{Domain!CRApackage}
\index[pkg]{CRAPACK}
\begin{chunk}{defclass CRApackageType}
(defclass |CRApackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CRApackage")
   (marker :initform 'package)
   (abbreviation :initform 'CRAPACK)
   (comment :initform (list
     "This package has no documentation"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CRApackage|
  (progn
    (push '|CRApackage| *Packages*)
    (make-instance '|CRApackageType|)))

\end{chunk}

\subsection{CycleIndicators}
\index[pkg]{CycleIndicators!Domain}
\index[pkg]{Domain!CycleIndicators}
\index[pkg]{CYCLES}
\begin{chunk}{defclass CycleIndicatorsType}
(defclass |CycleIndicatorsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CycleIndicators")
   (marker :initform 'package)
   (abbreviation :initform 'CYCLES)
   (comment :initform (list
     "Polya-Redfield enumeration by cycle indices."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CycleIndicators|
  (progn
    (push '|CycleIndicators| *Packages*)
    (make-instance '|CycleIndicatorsType|)))

\end{chunk}

\subsection{CyclicStreamTools}
\index[pkg]{CyclicStreamTools!Domain}
\index[pkg]{Domain!CyclicStreamTools}
\index[pkg]{CSTTOOLS}
\begin{chunk}{defclass CyclicStreamToolsType}
(defclass |CyclicStreamToolsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CyclicStreamTools")
   (marker :initform 'package)
   (abbreviation :initform 'CSTTOOLS)
   (comment :initform (list
     "This package provides tools for working with cyclic streams."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CyclicStreamTools|
  (progn
    (push '|CyclicStreamTools| *Packages*)
    (make-instance '|CyclicStreamToolsType|)))

\end{chunk}

\subsection{CyclotomicPolynomialPackage}
\index[pkg]{CyclotomicPolynomialPackage!Domain}
\index[pkg]{Domain!CyclotomicPolynomialPackage}
\index[pkg]{CYCLOTOM}
\begin{chunk}{defclass CyclotomicPolynomialPackageType}
(defclass |CyclotomicPolynomialPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CyclotomicPolynomialPackage")
   (marker :initform 'package)
   (abbreviation :initform 'CYCLOTOM)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CyclotomicPolynomialPackage|
  (progn
    (push '|CyclotomicPolynomialPackage| *Packages*)
    (make-instance '|CyclotomicPolynomialPackageType|)))

\end{chunk}

\subsection{CylindricalAlgebraicDecompositionPackage}
\index[pkg]{CylindricalAlgebraicDecompositionPackage!Domain}
\index[pkg]{Domain!CylindricalAlgebraicDecompositionPackage}
\index[pkg]{CAD}
\begin{chunk}{defclass CylindricalAlgebraicDecompositionPackageType}
(defclass |CylindricalAlgebraicDecompositionPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CylindricalAlgebraicDecompositionPackage")
   (marker :initform 'package)
   (abbreviation :initform 'CAD)
   (comment :initform nil)
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CylindricalAlgebraicDecompositionPackage|
  (progn
    (push '|CylindricalAlgebraicDecompositionPackage| *Packages*)
    (make-instance '|CylindricalAlgebraicDecompositionPackageType|)))

\end{chunk}

\subsection{CylindricalAlgebraicDecompositionUtilities}
\index[pkg]{CylindricalAlgebraicDecompositionUtilities!Domain}
\index[pkg]{Domain!CylindricalAlgebraicDecompositionUtilities}
\index[pkg]{CADU}
\begin{chunk}{defclass CylindricalAlgebraicDecompositionUtilitiesType}
(defclass |CylindricalAlgebraicDecompositionUtilitiesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "CylindricalAlgebraicDecompositionUtilities")
   (marker :initform 'package)
   (abbreviation :initform 'CADU)
   (comment :initform nil)
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |CylindricalAlgebraicDecompositionUtilities|
  (progn
    (push '|CylindricalAlgebraicDecompositionUtilities| *Packages*)
    (make-instance '|CylindricalAlgebraicDecompositionUtilitiesType|)))

\end{chunk}

\section{D}

\subsection{DefiniteIntegrationTools}
\index[pkg]{DefiniteIntegrationTools!Domain}
\index[pkg]{Domain!DefiniteIntegrationTools}
\index[pkg]{DFINTTLS}
\begin{chunk}{defclass DefiniteIntegrationToolsType}
(defclass |DefiniteIntegrationToolsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "DefiniteIntegrationTools")
   (marker :initform 'package)
   (abbreviation :initform 'DFINTTLS)
   (comment :initform (list
     "DefiniteIntegrationTools provides common tools used"
     "by the definite integration of both rational and elementary functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DefiniteIntegrationTools|
  (progn
    (push '|DefiniteIntegrationTools| *Packages*)
    (make-instance '|DefiniteIntegrationToolsType|)))

\end{chunk}

\subsection{DegreeReductionPackage}
\index[pkg]{DegreeReductionPackage!Domain}
\index[pkg]{Domain!DegreeReductionPackage}
\index[pkg]{DEGRED}
\begin{chunk}{defclass DegreeReductionPackageType}
(defclass |DegreeReductionPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "DegreeReductionPackage")
   (marker :initform 'package)
   (abbreviation :initform 'DEGRED)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DegreeReductionPackage|
  (progn
    (push '|DegreeReductionPackage| *Packages*)
    (make-instance '|DegreeReductionPackageType|)))

\end{chunk}

\subsection{DesingTreePackage}
\index[pkg]{DesingTreePackage!Domain}
\index[pkg]{Domain!DesingTreePackage}
\index[pkg]{DTP}
\begin{chunk}{defclass DesingTreePackageType}
(defclass |DesingTreePackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "DesingTreePackage")
   (marker :initform 'package)
   (abbreviation :initform 'DTP)
   (comment :initform (list
     "The following is all the categories, domains and package"
     "used for the desingularisation be means of"
     "monoidal transformation (Blowing-up)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DesingTreePackage|
  (progn
    (push '|DesingTreePackage| *Packages*)
    (make-instance '|DesingTreePackageType|)))

\end{chunk}

\subsection{DiophantineSolutionPackage}
\index[pkg]{DiophantineSolutionPackage!Domain}
\index[pkg]{Domain!DiophantineSolutionPackage}
\index[pkg]{DIOSP}
\begin{chunk}{defclass DiophantineSolutionPackageType}
(defclass |DiophantineSolutionPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "DiophantineSolutionPackage")
   (marker :initform 'package)
   (abbreviation :initform 'DIOSP)
   (comment :initform (list
     "Any solution of a homogeneous linear Diophantine equation"
     "can be represented as a sum of minimal solutions, which"
     "form a 'basis' (a minimal solution cannot be represented"
     "as a nontrivial sum of solutions)"
     "in the case of an inhomogeneous linear Diophantine equation,"
     "each solution is the sum of a inhomogeneous solution and"
     "any number of homogeneous solutions"
     "therefore, it suffices to compute two sets:"
     "1. all minimal inhomogeneous solutions"
     "2. all minimal homogeneous solutions"
     "the algorithm implemented is a completion procedure, which"
     "enumerates all solutions in a recursive depth-first-search"
     "it can be seen as finding monotone paths in a graph"
     "for more details see Reference"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DiophantineSolutionPackage|
  (progn
    (push '|DiophantineSolutionPackage| *Packages*)
    (make-instance '|DiophantineSolutionPackageType|)))

\end{chunk}

\subsection{DirectProductFunctions2}
\index[pkg]{DirectProductFunctions2!Domain}
\index[pkg]{Domain!DirectProductFunctions2}
\index[pkg]{DIRPROD2}
\begin{chunk}{defclass DirectProductFunctions2Type}
(defclass |DirectProductFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "DirectProductFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'DIRPROD2)
   (comment :initform (list
     "This package provides operations which all take as arguments direct"
     "products of elements of some type A and functions from A"
     "to another type B. The operations all iterate over their vector argument"
     "and either return a value of type B or a direct product over B."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DirectProductFunctions2|
  (progn
    (push '|DirectProductFunctions2| *Packages*)
    (make-instance '|DirectProductFunctions2Type|)))

\end{chunk}

\subsection{DiscreteLogarithmPackage}
\index[pkg]{DiscreteLogarithmPackage!Domain}
\index[pkg]{Domain!DiscreteLogarithmPackage}
\index[pkg]{DLP}
\begin{chunk}{defclass DiscreteLogarithmPackageType}
(defclass |DiscreteLogarithmPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "DiscreteLogarithmPackage")
   (marker :initform 'package)
   (abbreviation :initform 'DLP)
   (comment :initform (list
     "DiscreteLogarithmPackage implements help functions for discrete logarithms"
     "in monoids using small cyclic groups."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DiscreteLogarithmPackage|
  (progn
    (push '|DiscreteLogarithmPackage| *Packages*)
    (make-instance '|DiscreteLogarithmPackageType|)))

\end{chunk}

\subsection{DisplayPackage}
\index[pkg]{DisplayPackage!Domain}
\index[pkg]{Domain!DisplayPackage}
\index[pkg]{DISPLAY}
\begin{chunk}{defclass DisplayPackageType}
(defclass |DisplayPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "DisplayPackage")
   (marker :initform 'package)
   (abbreviation :initform 'DISPLAY)
   (comment :initform (list
     "DisplayPackage allows one to print strings in a nice manner,"
     "including highlighting substrings."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DisplayPackage|
  (progn
    (push '|DisplayPackage| *Packages*)
    (make-instance '|DisplayPackageType|)))

\end{chunk}

\subsection{DistinctDegreeFactorize}
\index[pkg]{DistinctDegreeFactorize!Domain}
\index[pkg]{Domain!DistinctDegreeFactorize}
\index[pkg]{DDFACT}
\begin{chunk}{defclass DistinctDegreeFactorizeType}
(defclass |DistinctDegreeFactorizeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "DistinctDegreeFactorize")
   (marker :initform 'package)
   (abbreviation :initform 'DDFACT)
   (comment :initform (list
     "Package for the factorization of a univariate polynomial with"
     "coefficients in a finite field. The algorithm used is the"
     "'distinct degree' algorithm of Cantor-Zassenhaus, modified"
     "to use trace instead of the norm and a table for computing"
     "Frobenius as suggested by Naudin and Quitte."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DistinctDegreeFactorize|
  (progn
    (push '|DistinctDegreeFactorize| *Packages*)
    (make-instance '|DistinctDegreeFactorizeType|)))

\end{chunk}

\subsection{DoubleFloatSpecialFunctions}
\index[pkg]{DoubleFloatSpecialFunctions!Domain}
\index[pkg]{Domain!DoubleFloatSpecialFunctions}
\index[pkg]{DFSFUN}
\label{package DFSFUN DoubleFloatSpecialFunctions}
\begin{chunk}{defclass DoubleFloatSpecialFunctionsType}
(defclass |DoubleFloatSpecialFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "DoubleFloatSpecialFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'DFSFUN)
   (comment :initform (list
     "This package provides special functions for double precision"
     "real and complex floating point."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DoubleFloatSpecialFunctions|
  (progn
    (push '|DoubleFloatSpecialFunctions| *Packages*)
    (make-instance '|DoubleFloatSpecialFunctionsType|)))

\end{chunk}

\subsection{DoubleResultantPackage}
\index[pkg]{DoubleResultantPackage!Domain}
\index[pkg]{Domain!DoubleResultantPackage}
\index[pkg]{DBLRESP}
\begin{chunk}{defclass DoubleResultantPackageType}
(defclass |DoubleResultantPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "DoubleResultantPackage")
   (marker :initform 'package)
   (abbreviation :initform 'DBLRESP)
   (comment :initform (list
     "This package provides functions for computing the residues"
     "of a function on an algebraic curve."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DoubleResultantPackage|
  (progn
    (push '|DoubleResultantPackage| *Packages*)
    (make-instance '|DoubleResultantPackageType|)))

\end{chunk}

\subsection{DrawComplex}
\index[pkg]{DrawComplex!Domain}
\index[pkg]{Domain!DrawComplex}
\index[pkg]{DRAWCX}
\begin{chunk}{defclass DrawComplexType}
(defclass |DrawComplexType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "DrawComplex")
   (marker :initform 'package)
   (abbreviation :initform 'DRAWCX)
   (comment :initform (list
     "DrawComplex provides some facilities"
     "for drawing complex functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DrawComplex|
  (progn
    (push '|DrawComplex| *Packages*)
    (make-instance '|DrawComplexType|)))

\end{chunk}

\subsection{DrawNumericHack}
\index[pkg]{DrawNumericHack!Domain}
\index[pkg]{Domain!DrawNumericHack}
\index[pkg]{DRAWHACK}
\begin{chunk}{defclass DrawNumericHackType}
(defclass |DrawNumericHackType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "DrawNumericHack")
   (marker :initform 'package)
   (abbreviation :initform 'DRAWHACK)
   (comment :initform (list
     "Hack for the draw interface. DrawNumericHack provides"
     "a 'coercion' from something of the form x = a..b where a" 
     "and b are"
     "formal expressions to a binding of the form x = c..d where c and d"
     "are the numerical values of a and b. This 'coercion' fails if"
     "a and b contains symbolic variables, but is meant for expressions"
     "involving %pi."
     "Note that this package is meant for internal use only."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DrawNumericHack|
  (progn
    (push '|DrawNumericHack| *Packages*)
    (make-instance '|DrawNumericHackType|)))

\end{chunk}

\subsection{DrawOptionFunctions0}
\index[pkg]{DrawOptionFunctions0!Domain}
\index[pkg]{Domain!DrawOptionFunctions0}
\index[pkg]{DROPT0}
\begin{chunk}{defclass DrawOptionFunctions0Type}
(defclass |DrawOptionFunctions0Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "DrawOptionFunctions0")
   (marker :initform 'package)
   (abbreviation :initform 'DROPT0)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DrawOptionFunctions0|
  (progn
    (push '|DrawOptionFunctions0| *Packages*)
    (make-instance '|DrawOptionFunctions0Type|)))

\end{chunk}

\subsection{DrawOptionFunctions1}
\index[pkg]{DrawOptionFunctions1!Domain}
\index[pkg]{Domain!DrawOptionFunctions1}
\index[pkg]{DROPT1}
\begin{chunk}{defclass DrawOptionFunctions1Type}
(defclass |DrawOptionFunctions1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "DrawOptionFunctions1")
   (marker :initform 'package)
   (abbreviation :initform 'DROPT1)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |DrawOptionFunctions1|
  (progn
    (push '|DrawOptionFunctions1| *Packages*)
    (make-instance '|DrawOptionFunctions1Type|)))

\end{chunk}

\subsection{d01AgentsPackage}
\index[pkg]{d01AgentsPackage!Domain}
\index[pkg]{Domain!d01AgentsPackage}
\index[pkg]{D01AGNT}
\begin{chunk}{defclass d01AgentsPackageType}
(defclass |d01AgentsPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "d01AgentsPackage")
   (marker :initform 'package)
   (abbreviation :initform 'D01AGNT)
   (comment :initform (list
     "d01AgentsPackage is a package of numerical agents to be used"
     "to investigate attributes of an input function so as to decide the"
     "measure of an appropriate numerical integration routine."
     "It contains functions rangeIsFinite to test the input range and"
     "functionIsContinuousAtEndPoints to check for continuity at"
     "the end points of the range."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d01AgentsPackage|
  (progn
    (push '|d01AgentsPackage| *Packages*)
    (make-instance '|d01AgentsPackageType|)))

\end{chunk}

\subsection{d01WeightsPackage}
\index[pkg]{d01WeightsPackage!Domain}
\index[pkg]{Domain!d01WeightsPackage}
\index[pkg]{D01WGTS}
\begin{chunk}{defclass d01WeightsPackageType}
(defclass |d01WeightsPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "d01WeightsPackage")
   (marker :initform 'package)
   (abbreviation :initform 'D01WGTS)
   (comment :initform (list
     "d01WeightsPackage is a package for functions used to investigate"
     "whether a function can be divided into a simpler function and a weight"
     "function.  The types of weights investigated are those giving rise to"
     "end-point singularities of the algebraico-logarithmic type, and"
     "trigonometric weights."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d01WeightsPackage|
  (progn
    (push '|d01WeightsPackage| *Packages*)
    (make-instance '|d01WeightsPackageType|)))

\end{chunk}

\subsection{d02AgentsPackage}
\index[pkg]{d02AgentsPackage!Domain}
\index[pkg]{Domain!d02AgentsPackage}
\index[pkg]{D02AGNT}
\begin{chunk}{defclass d02AgentsPackageType}
(defclass |d02AgentsPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "d02AgentsPackage")
   (marker :initform 'package)
   (abbreviation :initform 'D02AGNT)
   (comment :initform nil)
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d02AgentsPackage|
  (progn
    (push '|d02AgentsPackage| *Packages*)
    (make-instance '|d02AgentsPackageType|)))

\end{chunk}

\subsection{d03AgentsPackage}
\index[pkg]{d03AgentsPackage!Domain}
\index[pkg]{Domain!d03AgentsPackage}
\index[pkg]{D03AGNT}
\begin{chunk}{defclass d03AgentsPackageType}
(defclass |d03AgentsPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "d03AgentsPackage")
   (marker :initform 'package)
   (abbreviation :initform 'D03AGNT)
   (comment :initform (list
     "d03AgentsPackage contains a set of computational agents"
     "for use with Partial Differential Equation solvers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |d03AgentsPackage|
  (progn
    (push '|d03AgentsPackage| *Packages*)
    (make-instance '|d03AgentsPackageType|)))

\end{chunk}

\section{E}

\subsection{EigenPackage}
\index[pkg]{EigenPackage!Domain}
\index[pkg]{Domain!EigenPackage}
\index[pkg]{EP}
\begin{chunk}{defclass EigenPackageType}
(defclass |EigenPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "EigenPackage")
   (marker :initform 'package)
   (abbreviation :initform 'EP)
   (comment :initform (list
     "This is a package for the exact computation of eigenvalues and eigenvectors."
     "This package can be made to work for matrices with coefficients which are"
     "rational functions over a ring where we can factor polynomials."
     "Rational eigenvalues are always explicitly computed while the"
     "non-rational ones are expressed in terms of their minimal polynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |EigenPackage|
  (progn
    (push '|EigenPackage| *Packages*)
    (make-instance '|EigenPackageType|)))

\end{chunk}

\subsection{ElementaryFunction}
\index[pkg]{ElementaryFunction!Domain}
\index[pkg]{Domain!ElementaryFunction}
\index[pkg]{EF}
\begin{chunk}{defclass ElementaryFunctionType}
(defclass |ElementaryFunctionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ElementaryFunction")
   (marker :initform 'package)
   (abbreviation :initform 'EF)
   (comment :initform (list
     "Provides elementary functions over an integral domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ElementaryFunction|
  (progn
    (push '|ElementaryFunction| *Packages*)
    (make-instance '|ElementaryFunctionType|)))

\end{chunk}

\subsection{ElementaryFunctionDefiniteIntegration}
\index[pkg]{ElementaryFunctionDefiniteIntegration!Domain}
\index[pkg]{Domain!ElementaryFunctionDefiniteIntegration}
\index[pkg]{DEFINTEF}
\begin{chunk}{defclass ElementaryFunctionDefiniteIntegrationType}
(defclass |ElementaryFunctionDefiniteIntegrationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ElementaryFunctionDefiniteIntegration")
   (marker :initform 'package)
   (abbreviation :initform 'DEFINTEF)
   (comment :initform (list
     "RationalFunctionDefiniteIntegration provides functions to"
     "compute definite integrals of rational functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ElementaryFunctionDefiniteIntegration|
  (progn
    (push '|ElementaryFunctionDefiniteIntegration| *Packages*)
    (make-instance '|ElementaryFunctionDefiniteIntegrationType|)))

\end{chunk}

\subsection{ElementaryFunctionLODESolver}
\index[pkg]{ElementaryFunctionLODESolver!Domain}
\index[pkg]{Domain!ElementaryFunctionLODESolver}
\index[pkg]{LODEEF}
\begin{chunk}{defclass ElementaryFunctionLODESolverType}
(defclass |ElementaryFunctionLODESolverType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ElementaryFunctionLODESolver")
   (marker :initform 'package)
   (abbreviation :initform 'LODEEF)
   (comment :initform (list
     "ElementaryFunctionLODESolver provides the top-level"
     "functions for finding closed form solutions of linear ordinary"
     "differential equations and initial value problems."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ElementaryFunctionLODESolver|
  (progn
    (push '|ElementaryFunctionLODESolver| *Packages*)
    (make-instance '|ElementaryFunctionLODESolverType|)))

\end{chunk}

\subsection{ElementaryFunctionODESolver}
\index[pkg]{ElementaryFunctionODESolver!Domain}
\index[pkg]{Domain!ElementaryFunctionODESolver}
\index[pkg]{ODEEF}
\begin{chunk}{defclass ElementaryFunctionODESolverType}
(defclass |ElementaryFunctionODESolverType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ElementaryFunctionODESolver")
   (marker :initform 'package)
   (abbreviation :initform 'ODEEF)
   (comment :initform (list
     "ElementaryFunctionODESolver provides the top-level"
     "functions for finding closed form solutions of ordinary"
     "differential equations and initial value problems."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ElementaryFunctionODESolver|
  (progn
    (push '|ElementaryFunctionODESolver| *Packages*)
    (make-instance '|ElementaryFunctionODESolverType|)))

\end{chunk}

\subsection{ElementaryFunctionSign}
\index[pkg]{ElementaryFunctionSign!Domain}
\index[pkg]{Domain!ElementaryFunctionSign}
\index[pkg]{SIGNEF}
\begin{chunk}{defclass ElementaryFunctionSignType}
(defclass |ElementaryFunctionSignType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ElementaryFunctionSign")
   (marker :initform 'package)
   (abbreviation :initform 'SIGNEF)
   (comment :initform (list
     "This package provides functions to determine the sign of an"
     "elementary function around a point or infinity."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ElementaryFunctionSign|
  (progn
    (push '|ElementaryFunctionSign| *Packages*)
    (make-instance '|ElementaryFunctionSignType|)))

\end{chunk}

\subsection{ElementaryFunctionStructurePackage}
\index[pkg]{ElementaryFunctionStructurePackage!Domain}
\index[pkg]{Domain!ElementaryFunctionStructurePackage}
\index[pkg]{EFSTRUC}
\begin{chunk}{defclass ElementaryFunctionStructurePackageType}
(defclass |ElementaryFunctionStructurePackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ElementaryFunctionStructurePackage")
   (marker :initform 'package)
   (abbreviation :initform 'EFSTRUC)
   (comment :initform (list
     "ElementaryFunctionStructurePackage provides functions to test the"
     "algebraic independence of various elementary functions, using the"
     "Risch structure theorem (real and complex versions)."
     "It also provides transformations on elementary functions"
     "which are not considered simplifications."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ElementaryFunctionStructurePackage|
  (progn
    (push '|ElementaryFunctionStructurePackage| *Packages*)
    (make-instance '|ElementaryFunctionStructurePackageType|)))

\end{chunk}

\subsection{ElementaryIntegration}
\index[pkg]{ElementaryIntegration!Domain}
\index[pkg]{Domain!ElementaryIntegration}
\index[pkg]{INTEF}
\begin{chunk}{defclass ElementaryIntegrationType}
(defclass |ElementaryIntegrationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ElementaryIntegration")
   (marker :initform 'package)
   (abbreviation :initform 'INTEF)
   (comment :initform (list
     "This package provides functions for integration, limited integration,"
     "extended integration and the risch differential equation for"
     "elementary functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ElementaryIntegration|
  (progn
    (push '|ElementaryIntegration| *Packages*)
    (make-instance '|ElementaryIntegrationType|)))

\end{chunk}

\subsection{ElementaryRischDE}
\index[pkg]{ElementaryRischDE!Domain}
\index[pkg]{Domain!ElementaryRischDE}
\index[pkg]{RDEEF}
\begin{chunk}{defclass ElementaryRischDEType}
(defclass |ElementaryRischDEType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ElementaryRischDE")
   (marker :initform 'package)
   (abbreviation :initform 'RDEEF)
   (comment :initform (list
     "Risch differential equation, elementary case."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ElementaryRischDE|
  (progn
    (push '|ElementaryRischDE| *Packages*)
    (make-instance '|ElementaryRischDEType|)))

\end{chunk}

\subsection{ElementaryRischDESystem}
\index[pkg]{ElementaryRischDESystem!Domain}
\index[pkg]{Domain!ElementaryRischDESystem}
\index[pkg]{RDEEFS}
\begin{chunk}{defclass ElementaryRischDESystemType}
(defclass |ElementaryRischDESystemType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ElementaryRischDESystem")
   (marker :initform 'package)
   (abbreviation :initform 'RDEEFS)
   (comment :initform (list
     "Risch differential equation, elementary case."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ElementaryRischDESystem|
  (progn
    (push '|ElementaryRischDESystem| *Packages*)
    (make-instance '|ElementaryRischDESystemType|)))

\end{chunk}

\subsection{EllipticFunctionsUnivariateTaylorSeries}
\index[pkg]{EllipticFunctionsUnivariateTaylorSeries!Domain}
\index[pkg]{Domain!EllipticFunctionsUnivariateTaylorSeries}
\index[pkg]{ELFUTS}
\begin{chunk}{defclass EllipticFunctionsUnivariateTaylorSeriesType}
(defclass |EllipticFunctionsUnivariateTaylorSeriesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "EllipticFunctionsUnivariateTaylorSeries")
   (marker :initform 'package)
   (abbreviation :initform 'ELFUTS)
   (comment :initform (list
     "The elliptic functions sn, sc and dn are expanded as Taylor series."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |EllipticFunctionsUnivariateTaylorSeries|
  (progn
    (push '|EllipticFunctionsUnivariateTaylorSeries| *Packages*)
    (make-instance '|EllipticFunctionsUnivariateTaylorSeriesType|)))

\end{chunk}

\subsection{EquationFunctions2}
\index[pkg]{EquationFunctions2!Domain}
\index[pkg]{Domain!EquationFunctions2}
\index[pkg]{EQ2}
\begin{chunk}{defclass EquationFunctions2Type}
(defclass |EquationFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "EquationFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'EQ2)
   (comment :initform (list
     "This package provides operations for mapping the sides of equations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |EquationFunctions2|
  (progn
    (push '|EquationFunctions2| *Packages*)
    (make-instance '|EquationFunctions2Type|)))

\end{chunk}

\subsection{ErrorFunctions}
\index[pkg]{ErrorFunctions!Domain}
\index[pkg]{Domain!ErrorFunctions}
\index[pkg]{ERROR}
\begin{chunk}{defclass ErrorFunctionsType}
(defclass |ErrorFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ErrorFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'ERROR)
   (comment :initform (list
     "ErrorFunctions implements error functions callable from the system"
     "interpreter.  Typically, these functions would be called in user"
     "functions.  The simple forms of the functions take one argument"
     "which is either a string (an error message) or a list of strings"
     "which all together make up a message.  The list can contain"
     "formatting codes (see below).  The more sophisticated versions takes"
     "two arguments where the first argument is the name of the function"
     "from which the error was invoked and the second argument is either a"
     "string or a list of strings, as above.  When you use the one"
     "argument version in an interpreter function, the system will"
     "automatically insert the name of the function as the new first"
     "argument.  Thus in the user interpreter function"
     "     f x == if x < 0 then error 'negative argument' else x"
     "the call to error will actually be of the form"
     "     error('f','negative argument')"
     "because the interpreter will have created a new first argument."
     " "
     "Formatting codes:  error messages may contain the following"
     "formatting codes (they should either start or end a string or"
     "else have blanks around them):"
     "%l      start a new line"
     "%ceon   start centering message lines"
     "%ceoff  stop  centering message lines"
     "%rjon   start displaying lines 'ragged left'"
     "%rjoff  stop  displaying lines 'ragged left'"
     "%i      indent   following lines 3 additional spaces"
     "%u      unindent following lines 3 additional spaces"
     "%xN    insert N blanks (eg, %x10 inserts 10 blanks)"
     " "
     "Examples:"
     "1.error 'Whoops, you made a %l %ceon big %ceoff %l mistake!'"
     "2.error ['Whoops, you made a','%l %ceon ','big',"
     "         '%d %ceoff %l','mistake!']"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ErrorFunctions|
  (progn
    (push '|ErrorFunctions| *Packages*)
    (make-instance '|ErrorFunctionsType|)))

\end{chunk}

\subsection{EuclideanGroebnerBasisPackage}
\index[pkg]{EuclideanGroebnerBasisPackage!Domain}
\index[pkg]{Domain!EuclideanGroebnerBasisPackage}
\index[pkg]{GBEUCLID}
\begin{chunk}{defclass EuclideanGroebnerBasisPackageType}
(defclass |EuclideanGroebnerBasisPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "EuclideanGroebnerBasisPackage")
   (marker :initform 'package)
   (abbreviation :initform 'GBEUCLID)
   (comment :initform (list
     "EuclideanGroebnerBasisPackage computes groebner"
     "bases for polynomial ideals over euclidean domains."
     "The basic computation provides"
     "a distinguished set of generators for these ideals."
     "This basis allows an easy test for membership: the operation"
     "euclideanNormalForm returns zero on ideal members. The string"
     "'info' and 'redcrit' can be given as additional args to provide"
     "incremental information during the computation. If 'info' is given,"
     "a computational summary is given for each s-polynomial. If 'redcrit'"
     "is given, the reduced critical pairs are printed. The term ordering"
     "is determined by the polynomial type used. Suggested types include"
     "DistributedMultivariatePolynomial,"
     "HomogeneousDistributedMultivariatePolynomial,"
     "GeneralDistributedMultivariatePolynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |EuclideanGroebnerBasisPackage|
  (progn
    (push '|EuclideanGroebnerBasisPackage| *Packages*)
    (make-instance '|EuclideanGroebnerBasisPackageType|)))

\end{chunk}

\subsection{EvaluateCycleIndicators}
\index[pkg]{EvaluateCycleIndicators!Domain}
\index[pkg]{Domain!EvaluateCycleIndicators}
\index[pkg]{EVALCYC}
\begin{chunk}{defclass EvaluateCycleIndicatorsType}
(defclass |EvaluateCycleIndicatorsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "EvaluateCycleIndicators")
   (marker :initform 'package)
   (abbreviation :initform 'EVALCYC)
   (comment :initform (list
     "This package is to be used in conjuction with the CycleIndicators package."
     "It provides an evaluation function for SymmetricPolynomials."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |EvaluateCycleIndicators|
  (progn
    (push '|EvaluateCycleIndicators| *Packages*)
    (make-instance '|EvaluateCycleIndicatorsType|)))

\end{chunk}

\subsection{ExpertSystemContinuityPackage}
\index[pkg]{ExpertSystemContinuityPackage!Domain}
\index[pkg]{Domain!ExpertSystemContinuityPackage}
\index[pkg]{ESCONT}
\begin{chunk}{defclass ExpertSystemContinuityPackageType}
(defclass |ExpertSystemContinuityPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ExpertSystemContinuityPackage")
   (marker :initform 'package)
   (abbreviation :initform 'ESCONT)
   (comment :initform (list
     "ExpertSystemContinuityPackage is a package of functions for the use of"
     "domains belonging to the category NumericalIntegration."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExpertSystemContinuityPackage|
  (progn
    (push '|ExpertSystemContinuityPackage| *Packages*)
    (make-instance '|ExpertSystemContinuityPackageType|)))

\end{chunk}

\subsection{ExpertSystemContinuityPackage1}
\index[pkg]{ExpertSystemContinuityPackage1!Domain}
\index[pkg]{Domain!ExpertSystemContinuityPackage1}
\index[pkg]{ESCONT1}
\begin{chunk}{defclass ExpertSystemContinuityPackage1Type}
(defclass |ExpertSystemContinuityPackage1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ExpertSystemContinuityPackage1")
   (marker :initform 'package)
   (abbreviation :initform 'ESCONT1)
   (comment :initform (list
     "ExpertSystemContinuityPackage1 exports a function to check range inclusion"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExpertSystemContinuityPackage1|
  (progn
    (push '|ExpertSystemContinuityPackage1| *Packages*)
    (make-instance '|ExpertSystemContinuityPackage1Type|)))

\end{chunk}

\subsection{ExpertSystemToolsPackage}
\index[pkg]{ExpertSystemToolsPackage!Domain}
\index[pkg]{Domain!ExpertSystemToolsPackage}
\index[pkg]{ESTOOLS}
\begin{chunk}{defclass ExpertSystemToolsPackageType}
(defclass |ExpertSystemToolsPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ExpertSystemToolsPackage")
   (marker :initform 'package)
   (abbreviation :initform 'ESTOOLS)
   (comment :initform (list
     "ExpertSystemToolsPackage contains some useful functions for use"
     "by the computational agents of numerical solvers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExpertSystemToolsPackage|
  (progn
    (push '|ExpertSystemToolsPackage| *Packages*)
    (make-instance '|ExpertSystemToolsPackageType|)))

\end{chunk}

\subsection{ExpertSystemToolsPackage1}
\index[pkg]{ExpertSystemToolsPackage1!Domain}
\index[pkg]{Domain!ExpertSystemToolsPackage1}
\index[pkg]{ESTOOLS1}
\begin{chunk}{defclass ExpertSystemToolsPackage1Type}
(defclass |ExpertSystemToolsPackage1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ExpertSystemToolsPackage1")
   (marker :initform 'package)
   (abbreviation :initform 'ESTOOLS1)
   (comment :initform (list
     "ExpertSystemToolsPackage1 contains some useful functions for use"
     "by the computational agents of Ordinary Differential Equation solvers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExpertSystemToolsPackage1|
  (progn
    (push '|ExpertSystemToolsPackage1| *Packages*)
    (make-instance '|ExpertSystemToolsPackage1Type|)))

\end{chunk}

\subsection{ExpertSystemToolsPackage2}
\index[pkg]{ExpertSystemToolsPackage2!Domain}
\index[pkg]{Domain!ExpertSystemToolsPackage2}
\index[pkg]{ESTOOLS2}
\begin{chunk}{defclass ExpertSystemToolsPackage2Type}
(defclass |ExpertSystemToolsPackage2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ExpertSystemToolsPackage2")
   (marker :initform 'package)
   (abbreviation :initform 'ESTOOLS2)
   (comment :initform (list
     "ExpertSystemToolsPackage2 contains some useful functions for use"
     "by the computational agents of Ordinary Differential Equation solvers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExpertSystemToolsPackage2|
  (progn
    (push '|ExpertSystemToolsPackage2| *Packages*)
    (make-instance '|ExpertSystemToolsPackage2Type|)))

\end{chunk}

\subsection{ExpressionFunctions2}
\index[pkg]{ExpressionFunctions2!Domain}
\index[pkg]{Domain!ExpressionFunctions2}
\index[pkg]{EXPR2}
\begin{chunk}{defclass ExpressionFunctions2Type}
(defclass |ExpressionFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ExpressionFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'EXPR2)
   (comment :initform (list
     "Lifting of maps to Expressions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExpressionFunctions2|
  (progn
    (push '|ExpressionFunctions2| *Packages*)
    (make-instance '|ExpressionFunctions2Type|)))

\end{chunk}

\subsection{ExpressionSolve}
\index[pkg]{ExpressionSolve!Domain}
\index[pkg]{Domain!ExpressionSolve}
\index[pkg]{EXPRSOL}
\begin{chunk}{defclass ExpressionSolveType}
(defclass |ExpressionSolveType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ExpressionSolve")
   (marker :initform 'package)
   (abbreviation :initform 'EXPRSOL)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExpressionSolve|
  (progn
    (push '|ExpressionSolve| *Packages*)
    (make-instance '|ExpressionSolveType|)))

\end{chunk}

\subsection{ExpressionSpaceFunctions1}
\index[pkg]{ExpressionSpaceFunctions1!Domain}
\index[pkg]{Domain!ExpressionSpaceFunctions1}
\index[pkg]{ES1}
\begin{chunk}{defclass ExpressionSpaceFunctions1Type}
(defclass |ExpressionSpaceFunctions1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ExpressionSpaceFunctions1")
   (marker :initform 'package)
   (abbreviation :initform 'ES1)
   (comment :initform (list
     "This package allows a map from any expression space into any object"
     "to be lifted to a kernel over the expression set, using a given"
     "property of the operator of the kernel."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExpressionSpaceFunctions1|
  (progn
    (push '|ExpressionSpaceFunctions1| *Packages*)
    (make-instance '|ExpressionSpaceFunctions1Type|)))

\end{chunk}

\subsection{ExpressionSpaceFunctions2}
\index[pkg]{ExpressionSpaceFunctions2!Domain}
\index[pkg]{Domain!ExpressionSpaceFunctions2}
\index[pkg]{ES2}
\begin{chunk}{defclass ExpressionSpaceFunctions2Type}
(defclass |ExpressionSpaceFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ExpressionSpaceFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'ES2)
   (comment :initform (list
     "This package allows a mapping E -> F to be lifted to a kernel over E"
     "This lifting can fail if the operator of the kernel cannot be applied"
     "in F; Do not use this package with E = F, since this may"
     "drop some properties of the operators."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExpressionSpaceFunctions2|
  (progn
    (push '|ExpressionSpaceFunctions2| *Packages*)
    (make-instance '|ExpressionSpaceFunctions2Type|)))

\end{chunk}

\subsection{ExpressionSpaceODESolver}
\index[pkg]{ExpressionSpaceODESolver!Domain}
\index[pkg]{Domain!ExpressionSpaceODESolver}
\index[pkg]{EXPRODE}
\begin{chunk}{defclass ExpressionSpaceODESolverType}
(defclass |ExpressionSpaceODESolverType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ExpressionSpaceODESolver")
   (marker :initform 'package)
   (abbreviation :initform 'EXPRODE)
   (comment :initform (list
     "Taylor series solutions of explicit ODE's"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExpressionSpaceODESolver|
  (progn
    (push '|ExpressionSpaceODESolver| *Packages*)
    (make-instance '|ExpressionSpaceODESolverType|)))

\end{chunk}

\subsection{ExpressionToOpenMath}
\index[pkg]{ExpressionToOpenMath!Domain}
\index[pkg]{Domain!ExpressionToOpenMath}
\index[pkg]{OMEXPR}
\begin{chunk}{defclass ExpressionToOpenMathType}
(defclass |ExpressionToOpenMathType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ExpressionToOpenMath")
   (marker :initform 'package)
   (abbreviation :initform 'OMEXPR)
   (comment :initform (list
     "ExpressionToOpenMath provides support for"
     "converting objects of type Expression into OpenMath."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExpressionToOpenMath|
  (progn
    (push '|ExpressionToOpenMath| *Packages*)
    (make-instance '|ExpressionToOpenMathType|)))

\end{chunk}

\subsection{ExpressionToUnivariatePowerSeries}
\index[pkg]{ExpressionToUnivariatePowerSeries!Domain}
\index[pkg]{Domain!ExpressionToUnivariatePowerSeries}
\index[pkg]{EXPR2UPS}
\begin{chunk}{defclass ExpressionToUnivariatePowerSeriesType}
(defclass |ExpressionToUnivariatePowerSeriesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ExpressionToUnivariatePowerSeries")
   (marker :initform 'package)
   (abbreviation :initform 'EXPR2UPS)
   (comment :initform (list
     "This package provides functions to convert functional expressions"
     "to power series."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExpressionToUnivariatePowerSeries|
  (progn
    (push '|ExpressionToUnivariatePowerSeries| *Packages*)
    (make-instance '|ExpressionToUnivariatePowerSeriesType|)))

\end{chunk}

\subsection{ExpressionTubePlot}
\index[pkg]{ExpressionTubePlot!Domain}
\index[pkg]{Domain!ExpressionTubePlot}
\index[pkg]{EXPRTUBE}
\begin{chunk}{defclass ExpressionTubePlotType}
(defclass |ExpressionTubePlotType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ExpressionTubePlot")
   (marker :initform 'package)
   (abbreviation :initform 'EXPRTUBE)
   (comment :initform (list
     "Package for constructing tubes around 3-dimensional parametric curves."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ExpressionTubePlot|
  (progn
    (push '|ExpressionTubePlot| *Packages*)
    (make-instance '|ExpressionTubePlotType|)))

\end{chunk}

\subsection{Export3D}
\index[pkg]{Export3D!Domain}
\index[pkg]{Domain!Export3D}
\index[pkg]{EXP3D}
\begin{chunk}{defclass Export3DType}
(defclass |Export3DType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "Export3D")
   (marker :initform 'package)
   (abbreviation :initform 'EXP3D)
   (comment :initform (list
     "This package provides support for exporting SubSpace and"
     "ThreeSpace structures to files."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Export3D|
  (progn
    (push '|Export3D| *Packages*)
    (make-instance '|Export3DType|)))

\end{chunk}

\subsection{e04AgentsPackage}
\index[pkg]{e04AgentsPackage!Domain}
\index[pkg]{Domain!e04AgentsPackage}
\index[pkg]{E04AGNT}
\begin{chunk}{defclass e04AgentsPackageType}
(defclass |e04AgentsPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "e04AgentsPackage")
   (marker :initform 'package)
   (abbreviation :initform 'E04AGNT)
   (comment :initform (list
     "e04AgentsPackage is a package of numerical agents to be used"
     "to investigate attributes of an input function so as to decide the"
     "measure of an appropriate numerical optimization routine."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |e04AgentsPackage|
  (progn
    (push '|e04AgentsPackage| *Packages*)
    (make-instance '|e04AgentsPackageType|)))

\end{chunk}

\section{F}

\subsection{FactoredFunctions}
\index[pkg]{FactoredFunctions!Domain}
\index[pkg]{Domain!FactoredFunctions}
\index[pkg]{FACTFUNC}
\begin{chunk}{defclass FactoredFunctionsType}
(defclass |FactoredFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FactoredFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'FACTFUNC)
   (comment :initform (list
     "Computes various functions on factored arguments."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FactoredFunctions|
  (progn
    (push '|FactoredFunctions| *Packages*)
    (make-instance '|FactoredFunctionsType|)))

\end{chunk}

\subsection{FactoredFunctions2}
\index[pkg]{FactoredFunctions2!Domain}
\index[pkg]{Domain!FactoredFunctions2}
\index[pkg]{FR2}
\begin{chunk}{defclass FactoredFunctions2Type}
(defclass |FactoredFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FactoredFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'FR2)
   (comment :initform (list
     "FactoredFunctions2 contains functions that involve"
     "factored objects whose underlying domains may not be the same."
     "For example, map might be used to coerce an object of"
     "type Factored(Integer) to Factored(Complex(Integer))."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FactoredFunctions2|
  (progn
    (push '|FactoredFunctions2| *Packages*)
    (make-instance '|FactoredFunctions2Type|)))

\end{chunk}

\subsection{FactoredFunctionUtilities}
\index[pkg]{FactoredFunctionUtilities!Domain}
\index[pkg]{Domain!FactoredFunctionUtilities}
\index[pkg]{FRUTIL}
\begin{chunk}{defclass FactoredFunctionUtilitiesType}
(defclass |FactoredFunctionUtilitiesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FactoredFunctionUtilities")
   (marker :initform 'package)
   (abbreviation :initform 'FRUTIL)
   (comment :initform (list
     "FactoredFunctionUtilities implements some utility"
     "functions for manipulating factored objects."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FactoredFunctionUtilities|
  (progn
    (push '|FactoredFunctionUtilities| *Packages*)
    (make-instance '|FactoredFunctionUtilitiesType|)))

\end{chunk}

\subsection{FactoringUtilities}
\index[pkg]{FactoringUtilities!Domain}
\index[pkg]{Domain!FactoringUtilities}
\index[pkg]{FACUTIL}
\begin{chunk}{defclass FactoringUtilitiesType}
(defclass |FactoringUtilitiesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FactoringUtilities")
   (marker :initform 'package)
   (abbreviation :initform 'FACUTIL)
   (comment :initform (list
     "This package provides utilities used by the factorizers"
     "which operate on polynomials represented as univariate polynomials"
     "with multivariate coefficients."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FactoringUtilities|
  (progn
    (push '|FactoringUtilities| *Packages*)
    (make-instance '|FactoringUtilitiesType|)))

\end{chunk}

\subsection{FactorisationOverPseudoAlgebraicClosureOfAlgExtOfRationalNumber}
\index[pkg]{FactorisationOverPseudoAlgebraicClosureOfAlgExtOfRationalNumber!Domain}
\index[pkg]{Domain!FactorisationOverPseudoAlgebraicClosureOfAlgExtOfRationalNumber}
\index[pkg]{FACTEXT}
\begin{chunk}{defclass FactorisationOverPseudoAlgebraicClosureOfAlgExtOfRationalNumberType}
(defclass |FactorisationOverPseudoAlgebraicClosureOfAlgExtOfRationalNumberType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FactorisationOverPseudoAlgebraicClosureOfAlgExtOfRationalNumber")
   (marker :initform 'package)
   (abbreviation :initform 'FACTEXT)
   (comment :initform (list
     "Part of the Package for Algebraic Function Fields in one variable PAFF"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FactorisationOverPseudoAlgebraicClosureOfAlgExtOfRationalNumber|
  (progn
    (push '|FactorisationOverPseudoAlgebraicClosureOfAlgExtOfRationalNumber| *Packages*)
    (make-instance '|FactorisationOverPseudoAlgebraicClosureOfAlgExtOfRationalNumberType|)))

\end{chunk}

\subsection{FactorisationOverPseudoAlgebraicClosureOfRationalNumber}
\index[pkg]{FactorisationOverPseudoAlgebraicClosureOfRationalNumber!Domain}
\index[pkg]{Domain!FactorisationOverPseudoAlgebraicClosureOfRationalNumber}
\index[pkg]{FACTRN}
\begin{chunk}{defclass FactorisationOverPseudoAlgebraicClosureOfRationalNumberType}
(defclass |FactorisationOverPseudoAlgebraicClosureOfRationalNumberType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FactorisationOverPseudoAlgebraicClosureOfRationalNumber")
   (marker :initform 'package)
   (abbreviation :initform 'FACTRN)
   (comment :initform (list
     "Part of the Package for Algebraic Function Fields in one variable PAFF"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FactorisationOverPseudoAlgebraicClosureOfRationalNumber|
  (progn
    (push '|FactorisationOverPseudoAlgebraicClosureOfRationalNumber| *Packages*)
    (make-instance '|FactorisationOverPseudoAlgebraicClosureOfRationalNumberType|)))

\end{chunk}

\subsection{FGLMIfCanPackage}
\index[pkg]{FGLMIfCanPackage!Domain}
\index[pkg]{Domain!FGLMIfCanPackage}
\index[pkg]{FGLMICPK}
\begin{chunk}{defclass FGLMIfCanPackageType}
(defclass |FGLMIfCanPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FGLMIfCanPackage")
   (marker :initform 'package)
   (abbreviation :initform 'FGLMICPK)
   (comment :initform (list
     "This is just an interface between several packages and domains."
     "The goal is to compute lexicographical Groebner bases"
     "of sets of polynomial with type Polynomial R"
     "by the FGLM algorithm if this is possible"
     "(if the input system generates a zero-dimensional ideal)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FGLMIfCanPackage|
  (progn
    (push '|FGLMIfCanPackage| *Packages*)
    (make-instance '|FGLMIfCanPackageType|)))

\end{chunk}

\subsection{FindOrderFinite}
\index[pkg]{FindOrderFinite!Domain}
\index[pkg]{Domain!FindOrderFinite}
\index[pkg]{FORDER}
\begin{chunk}{defclass FindOrderFiniteType}
(defclass |FindOrderFiniteType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FindOrderFinite")
   (marker :initform 'package)
   (abbreviation :initform 'FORDER)
   (comment :initform (list
     "Finds the order of a divisor over a finite field"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FindOrderFinite|
  (progn
    (push '|FindOrderFinite| *Packages*)
    (make-instance '|FindOrderFiniteType|)))

\end{chunk}

\subsection{FiniteAbelianMonoidRingFunctions2}
\index[pkg]{FiniteAbelianMonoidRingFunctions2!Domain}
\index[pkg]{Domain!FiniteAbelianMonoidRingFunctions2}
\index[pkg]{FAMR2}
\begin{chunk}{defclass FiniteAbelianMonoidRingFunctions2Type}
(defclass |FiniteAbelianMonoidRingFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FiniteAbelianMonoidRingFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'FAMR2)
   (comment :initform (list
     "This package provides a mapping function for FiniteAbelianMonoidRing"
     "The packages defined in this file provide fast fraction free rational"
     "interpolation algorithms. (see FAMR2, FFFG, FFFGF, NEWTON)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteAbelianMonoidRingFunctions2|
  (progn
    (push '|FiniteAbelianMonoidRingFunctions2| *Packages*)
    (make-instance '|FiniteAbelianMonoidRingFunctions2Type|)))

\end{chunk}

\subsection{FiniteDivisorFunctions2}
\index[pkg]{FiniteDivisorFunctions2!Domain}
\index[pkg]{Domain!FiniteDivisorFunctions2}
\index[pkg]{FDIV2}
\begin{chunk}{defclass FiniteDivisorFunctions2Type}
(defclass |FiniteDivisorFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FiniteDivisorFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'FDIV2)
   (comment :initform (list
     "Lift a map to finite divisors."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteDivisorFunctions2|
  (progn
    (push '|FiniteDivisorFunctions2| *Packages*)
    (make-instance '|FiniteDivisorFunctions2Type|)))

\end{chunk}

\subsection{FiniteFieldFactorization}
\index[pkg]{FiniteFieldFactorization!Domain}
\index[pkg]{Domain!FiniteFieldFactorization}
\index[pkg]{FFFACTOR}
\begin{chunk}{defclass FiniteFieldFactorizationType}
(defclass |FiniteFieldFactorizationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FiniteFieldFactorization")
   (marker :initform 'package)
   (abbreviation :initform 'FFFACTOR)
   (comment :initform (list
     "Part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldFactorization|
  (progn
    (push '|FiniteFieldFactorization| *Packages*)
    (make-instance '|FiniteFieldFactorizationType|)))

\end{chunk}

\subsection{FiniteFieldFactorizationWithSizeParseBySideEffect}
\index[pkg]{FiniteFieldFactorizationWithSizeParseBySideEffect!Domain}
\index[pkg]{Domain!FiniteFieldFactorizationWithSizeParseBySideEffect}
\index[pkg]{FFFACTSE}
\begin{chunk}{defclass FiniteFieldFactorizationWithSizeParseBySideEffectType}
(defclass |FiniteFieldFactorizationWithSizeParseBySideEffectType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FiniteFieldFactorizationWithSizeParseBySideEffect")
   (marker :initform 'package)
   (abbreviation :initform 'FFFACTSE)
   (comment :initform (list
     "Part of the package for Algebraic Function Fields in one variable (PAFF)"
     "It has been modified (very slitely) so that each time the 'factor'"
     "function is used, the variable related to the size of the field"
     "over which the polynomial is factorized is reset. This is done in"
     "order to be used with a 'dynamic extension field' which size is not"
     "fixed but set before calling the 'factor' function and which is"
     "parse by side effect to this package via the function 'size'. See"
     "the local function initialize' of this package."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldFactorizationWithSizeParseBySideEffect|
  (progn
    (push '|FiniteFieldFactorizationWithSizeParseBySideEffect| *Packages*)
    (make-instance '|FiniteFieldFactorizationWithSizeParseBySideEffectType|)))

\end{chunk}

\subsection{FiniteFieldFunctions}
\index[pkg]{FiniteFieldFunctions!Domain}
\index[pkg]{Domain!FiniteFieldFunctions}
\index[pkg]{FFF}
\begin{chunk}{defclass FiniteFieldFunctionsType}
(defclass |FiniteFieldFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FiniteFieldFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'FFF)
   (comment :initform (list
     "FiniteFieldFunctions(GF) is a package with functions"
     "concerning finite extension fields of the finite ground field GF,"
     "for example, Zech logarithms."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldFunctions|
  (progn
    (push '|FiniteFieldFunctions| *Packages*)
    (make-instance '|FiniteFieldFunctionsType|)))

\end{chunk}

\subsection{FiniteFieldHomomorphisms}
\index[pkg]{FiniteFieldHomomorphisms!Domain}
\index[pkg]{Domain!FiniteFieldHomomorphisms}
\index[pkg]{FFHOM}
\begin{chunk}{defclass FiniteFieldHomomorphismsType}
(defclass |FiniteFieldHomomorphismsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FiniteFieldHomomorphisms")
   (marker :initform 'package)
   (abbreviation :initform 'FFHOM)
   (comment :initform (list
     "FiniteFieldHomomorphisms(F1,GF,F2) exports coercion functions of"
     "elements between the fields F1 and F2, which both must be"
     "finite simple algebraic extensions of the finite ground field GF."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldHomomorphisms|
  (progn
    (push '|FiniteFieldHomomorphisms| *Packages*)
    (make-instance '|FiniteFieldHomomorphismsType|)))

\end{chunk}

\subsection{FiniteFieldPolynomialPackage}
\index[pkg]{FiniteFieldPolynomialPackage!Domain}
\index[pkg]{Domain!FiniteFieldPolynomialPackage}
\index[pkg]{FFPOLY}
\begin{chunk}{defclass FiniteFieldPolynomialPackageType}
(defclass |FiniteFieldPolynomialPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FiniteFieldPolynomialPackage")
   (marker :initform 'package)
   (abbreviation :initform 'FFPOLY)
   (comment :initform (list
     "This package provides a number of functions for generating, counting"
     "and testing irreducible, normal, primitive, random polynomials"
     "over finite fields."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldPolynomialPackage|
  (progn
    (push '|FiniteFieldPolynomialPackage| *Packages*)
    (make-instance '|FiniteFieldPolynomialPackageType|)))

\end{chunk}

\subsection{FiniteFieldPolynomialPackage2}
\index[pkg]{FiniteFieldPolynomialPackage2!Domain}
\index[pkg]{Domain!FiniteFieldPolynomialPackage2}
\index[pkg]{FFPOLY2}
\begin{chunk}{defclass FiniteFieldPolynomialPackage2Type}
(defclass |FiniteFieldPolynomialPackage2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FiniteFieldPolynomialPackage2")
   (marker :initform 'package)
   (abbreviation :initform 'FFPOLY2)
   (comment :initform (list
     "FiniteFieldPolynomialPackage2(F,GF) exports some functions concerning"
     "finite fields, which depend on a finite field GF and an"
     "algebraic extension F of GF, for example, a zero of a polynomial"
     "over GF in F."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldPolynomialPackage2|
  (progn
    (push '|FiniteFieldPolynomialPackage2| *Packages*)
    (make-instance '|FiniteFieldPolynomialPackage2Type|)))

\end{chunk}

\subsection{FiniteFieldSolveLinearPolynomialEquation}
\index[pkg]{FiniteFieldSolveLinearPolynomialEquation!Domain}
\index[pkg]{Domain!FiniteFieldSolveLinearPolynomialEquation}
\index[pkg]{FFSLPE}
\begin{chunk}{defclass FiniteFieldSolveLinearPolynomialEquationType}
(defclass |FiniteFieldSolveLinearPolynomialEquationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FiniteFieldSolveLinearPolynomialEquation")
   (marker :initform 'package)
   (abbreviation :initform 'FFSLPE)
   (comment :initform (list
     "This package solves linear diophantine equations for Bivariate polynomials"
     "over finite fields"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldSolveLinearPolynomialEquation|
  (progn
    (push '|FiniteFieldSolveLinearPolynomialEquation| *Packages*)
    (make-instance '|FiniteFieldSolveLinearPolynomialEquationType|)))

\end{chunk}

\subsection{FiniteFieldSquareFreeDecomposition}
\index[pkg]{FiniteFieldSquareFreeDecomposition!Domain}
\index[pkg]{Domain!FiniteFieldSquareFreeDecomposition}
\index[pkg]{FFSQFR}
\begin{chunk}{defclass FiniteFieldSquareFreeDecompositionType}
(defclass |FiniteFieldSquareFreeDecompositionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FiniteFieldSquareFreeDecomposition")
   (marker :initform 'package)
   (abbreviation :initform 'FFSQFR)
   (comment :initform (list
     "Part of the package for Algebraic Function Fields in one variable (PAFF)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteFieldSquareFreeDecomposition|
  (progn
    (push '|FiniteFieldSquareFreeDecomposition| *Packages*)
    (make-instance '|FiniteFieldSquareFreeDecompositionType|)))

\end{chunk}

\subsection{FiniteLinearAggregateFunctions2}
\index[pkg]{FiniteLinearAggregateFunctions2!Domain}
\index[pkg]{Domain!FiniteLinearAggregateFunctions2}
\index[pkg]{FLAGG2}
\begin{chunk}{defclass FiniteLinearAggregateFunctions2Type}
(defclass |FiniteLinearAggregateFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FiniteLinearAggregateFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'FLAGG2)
   (comment :initform (list
     "FiniteLinearAggregateFunctions2 provides functions involving two"
     "FiniteLinearAggregates where the underlying domains might be"
     "different. An example of this might be creating a list of rational"
     "numbers by mapping a function across a list of integers where the"
     "function divides each integer by 1000."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteLinearAggregateFunctions2|
  (progn
    (push '|FiniteLinearAggregateFunctions2| *Packages*)
    (make-instance '|FiniteLinearAggregateFunctions2Type|)))

\end{chunk}

\subsection{FiniteLinearAggregateSort}
\index[pkg]{FiniteLinearAggregateSort!Domain}
\index[pkg]{Domain!FiniteLinearAggregateSort}
\index[pkg]{FLASORT}
\begin{chunk}{defclass FiniteLinearAggregateSortType}
(defclass |FiniteLinearAggregateSortType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FiniteLinearAggregateSort")
   (marker :initform 'package)
   (abbreviation :initform 'FLASORT)
   (comment :initform (list
     "This package exports 3 sorting algorithms which work over"
     "FiniteLinearAggregates."
     "Sort package (in-place) for shallowlyMutable Finite Linear Aggregates"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteLinearAggregateSort|
  (progn
    (push '|FiniteLinearAggregateSort| *Packages*)
    (make-instance '|FiniteLinearAggregateSortType|)))

\end{chunk}

\subsection{FiniteSetAggregateFunctions2}
\index[pkg]{FiniteSetAggregateFunctions2!Domain}
\index[pkg]{Domain!FiniteSetAggregateFunctions2}
\index[pkg]{FSAGG2}
\begin{chunk}{defclass FiniteSetAggregateFunctions2Type}
(defclass |FiniteSetAggregateFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FiniteSetAggregateFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'FSAGG2)
   (comment :initform (list
     "FiniteSetAggregateFunctions2 provides functions involving two"
     "finite set aggregates where the underlying domains might be"
     "different. An example of this is to create a set of rational"
     "numbers by mapping a function across a set of integers, where the"
     "function divides each integer by 1000."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FiniteSetAggregateFunctions2|
  (progn
    (push '|FiniteSetAggregateFunctions2| *Packages*)
    (make-instance '|FiniteSetAggregateFunctions2Type|)))

\end{chunk}

\subsection{FloatingComplexPackage}
\index[pkg]{FloatingComplexPackage!Domain}
\index[pkg]{Domain!FloatingComplexPackage}
\index[pkg]{FLOATCP}
\begin{chunk}{defclass FloatingComplexPackageType}
(defclass |FloatingComplexPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FloatingComplexPackage")
   (marker :initform 'package)
   (abbreviation :initform 'FLOATCP)
   (comment :initform (list
     "This is a package for the approximation of complex solutions for"
     "systems of equations of rational functions with complex rational"
     "coefficients. The results are expressed as either complex rational"
     "numbers or complex floats depending on the type of the precision"
     "parameter which can be either a rational number or a floating point number."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FloatingComplexPackage|
  (progn
    (push '|FloatingComplexPackage| *Packages*)
    (make-instance '|FloatingComplexPackageType|)))

\end{chunk}

\subsection{FloatingRealPackage}
\index[pkg]{FloatingRealPackage!Domain}
\index[pkg]{Domain!FloatingRealPackage}
\index[pkg]{FLOATRP}
\begin{chunk}{defclass FloatingRealPackageType}
(defclass |FloatingRealPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FloatingRealPackage")
   (marker :initform 'package)
   (abbreviation :initform 'FLOATRP)
   (comment :initform (list
     "This is a package for the approximation of real solutions for"
     "systems of polynomial equations over the rational numbers."
     "The results are expressed as either rational numbers or floats"
     "depending on the type of the precision parameter which can be"
     "either a rational number or a floating point number."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FloatingRealPackage|
  (progn
    (push '|FloatingRealPackage| *Packages*)
    (make-instance '|FloatingRealPackageType|)))

\end{chunk}

\subsection{FloatSpecialFunctions}
\index[pkg]{FloatSpecialFunctions!Domain}
\index[pkg]{Domain!FloatSpecialFunctions}
\index[pkg]{FSFUN}
\begin{chunk}{defclass FloatSpecialFunctionsType}
(defclass |FloatSpecialFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FloatSpecialFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'FSFUN)
   (comment :initform nil)
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FloatSpecialFunctions|
  (progn
    (push '|FloatSpecialFunctions| *Packages*)
    (make-instance '|FloatSpecialFunctionsType|)))

\end{chunk}

\subsection{FortranCodePackage1}
\index[pkg]{FortranCodePackage1!Domain}
\index[pkg]{Domain!FortranCodePackage1}
\index[pkg]{FCPAK1}
\begin{chunk}{defclass FortranCodePackage1Type}
(defclass |FortranCodePackage1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FortranCodePackage1")
   (marker :initform 'package)
   (abbreviation :initform 'FCPAK1)
   (comment :initform (list
     "FortranCodePackage1 provides some utilities for"
     "producing useful objects in FortranCode domain."
     "The Package may be used with the FortranCode domain and its"
     "printCode or possibly via an outputAsFortran."
     "(The package provides items of use in connection with ASPs"
     "in the AXIOM-NAG link and, where appropriate, naming accords"
     "with that in IRENA.)"
     "The easy-to-use functions use Fortran loop variables I1, I2,"
     "and it is users' responsibility to check that this is sensible."
     "The advanced functions use SegmentBinding to allow users control"
     "over Fortran loop variable names."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranCodePackage1|
  (progn
    (push '|FortranCodePackage1| *Packages*)
    (make-instance '|FortranCodePackage1Type|)))

\end{chunk}

\subsection{FortranOutputStackPackage}
\index[pkg]{FortranOutputStackPackage!Domain}
\index[pkg]{Domain!FortranOutputStackPackage}
\index[pkg]{FOP}
\begin{chunk}{defclass FortranOutputStackPackageType}
(defclass |FortranOutputStackPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FortranOutputStackPackage")
   (marker :initform 'package)
   (abbreviation :initform 'FOP)
   (comment :initform (list
     "Code to manipulate Fortran Output Stack"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranOutputStackPackage|
  (progn
    (push '|FortranOutputStackPackage| *Packages*)
    (make-instance '|FortranOutputStackPackageType|)))

\end{chunk}

\subsection{FortranPackage}
\index[pkg]{FortranPackage!Domain}
\index[pkg]{Domain!FortranPackage}
\index[pkg]{FORT}
\begin{chunk}{defclass FortranPackageType}
(defclass |FortranPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FortranPackage")
   (marker :initform 'package)
   (abbreviation :initform 'FORT)
   (comment :initform (list
     "Provides an interface to the boot code for calling Fortran"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FortranPackage|
  (progn
    (push '|FortranPackage| *Packages*)
    (make-instance '|FortranPackageType|)))

\end{chunk}

\subsection{FractionalIdealFunctions2}
\index[pkg]{FractionalIdealFunctions2!Domain}
\index[pkg]{Domain!FractionalIdealFunctions2}
\index[pkg]{FRIDEAL2}
\begin{chunk}{defclass FractionalIdealFunctions2Type}
(defclass |FractionalIdealFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FractionalIdealFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'FRIDEAL2)
   (comment :initform (list
     "Lifting of morphisms to fractional ideals."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FractionalIdealFunctions2|
  (progn
    (push '|FractionalIdealFunctions2| *Packages*)
    (make-instance '|FractionalIdealFunctions2Type|)))

\end{chunk}

\subsection{FractionFreeFastGaussian}
\index[pkg]{FractionFreeFastGaussian!Domain}
\index[pkg]{Domain!FractionFreeFastGaussian}
\index[pkg]{FFFG}
\begin{chunk}{defclass FractionFreeFastGaussianType}
(defclass |FractionFreeFastGaussianType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FractionFreeFastGaussian")
   (marker :initform 'package)
   (abbreviation :initform 'FFFG)
   (comment :initform (list
     "This package implements the interpolation algorithm proposed in Beckermann,"
     "Bernhard and Labahn, George, Fraction-free computation of matrix rational"
     "interpolants and matrix GCDs, SIAM Journal on Matrix Analysis and"
     "Applications 22."
     "The packages defined in this file provide fast fraction free rational"
     "interpolation algorithms. (see FAMR2, FFFG, FFFGF, NEWTON)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FractionFreeFastGaussian|
  (progn
    (push '|FractionFreeFastGaussian| *Packages*)
    (make-instance '|FractionFreeFastGaussianType|)))

\end{chunk}

\subsection{FractionFreeFastGaussianFractions}
\index[pkg]{FractionFreeFastGaussianFractions!Domain}
\index[pkg]{Domain!FractionFreeFastGaussianFractions}
\index[pkg]{FFFGF}
\begin{chunk}{defclass FractionFreeFastGaussianFractionsType}
(defclass |FractionFreeFastGaussianFractionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FractionFreeFastGaussianFractions")
   (marker :initform 'package)
   (abbreviation :initform 'FFFGF)
   (comment :initform (list
     "This package lifts the interpolation functions from"
     "FractionFreeFastGaussian to fractions."
     "The packages defined in this file provide fast fraction free rational"
     "interpolation algorithms. (see FAMR2, FFFG, FFFGF, NEWTON)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FractionFreeFastGaussianFractions|
  (progn
    (push '|FractionFreeFastGaussianFractions| *Packages*)
    (make-instance '|FractionFreeFastGaussianFractionsType|)))

\end{chunk}

\subsection{FractionFunctions2}
\index[pkg]{FractionFunctions2!Domain}
\index[pkg]{Domain!FractionFunctions2}
\index[pkg]{FRAC2}
\begin{chunk}{defclass FractionFunctions2Type}
(defclass |FractionFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FractionFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'FRAC2)
   (comment :initform (list
     "This package extends a map between integral domains to"
     "a map between Fractions over those domains by applying the map to the"
     "numerators and denominators."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FractionFunctions2|
  (progn
    (push '|FractionFunctions2| *Packages*)
    (make-instance '|FractionFunctions2Type|)))

\end{chunk}

\subsection{FramedNonAssociativeAlgebraFunctions2}
\index[pkg]{FramedNonAssociativeAlgebraFunctions2!Domain}
\index[pkg]{Domain!FramedNonAssociativeAlgebraFunctions2}
\index[pkg]{FRNAAF2}
\begin{chunk}{defclass FramedNonAssociativeAlgebraFunctions2Type}
(defclass |FramedNonAssociativeAlgebraFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FramedNonAssociativeAlgebraFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'FRNAAF2)
   (comment :initform (list
     "FramedNonAssociativeAlgebraFunctions2 implements functions between"
     "two framed non associative algebra domains defined over different rings."
     "The function map is used to coerce between algebras over different"
     "domains having the same structural constants."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FramedNonAssociativeAlgebraFunctions2|
  (progn
    (push '|FramedNonAssociativeAlgebraFunctions2| *Packages*)
    (make-instance '|FramedNonAssociativeAlgebraFunctions2Type|)))

\end{chunk}

\subsection{FunctionalSpecialFunction}
\index[pkg]{FunctionalSpecialFunction!Domain}
\index[pkg]{Domain!FunctionalSpecialFunction}
\index[pkg]{FSPECF}
\begin{chunk}{defclass FunctionalSpecialFunctionType}
(defclass |FunctionalSpecialFunctionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FunctionalSpecialFunction")
   (marker :initform 'package)
   (abbreviation :initform 'FSPECF)
   (comment :initform (list
     "Provides some special functions over an integral domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionalSpecialFunction|
  (progn
    (push '|FunctionalSpecialFunction| *Packages*)
    (make-instance '|FunctionalSpecialFunctionType|)))

\end{chunk}

\subsection{FunctionFieldCategoryFunctions2}
\index[pkg]{FunctionFieldCategoryFunctions2!Domain}
\index[pkg]{Domain!FunctionFieldCategoryFunctions2}
\index[pkg]{FFCAT2}
\begin{chunk}{defclass FunctionFieldCategoryFunctions2Type}
(defclass |FunctionFieldCategoryFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FunctionFieldCategoryFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'FFCAT2)
   (comment :initform (list
     "Lifts a map from rings to function fields over them."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionFieldCategoryFunctions2|
  (progn
    (push '|FunctionFieldCategoryFunctions2| *Packages*)
    (make-instance '|FunctionFieldCategoryFunctions2Type|)))

\end{chunk}

\subsection{FunctionFieldIntegralBasis}
\index[pkg]{FunctionFieldIntegralBasis!Domain}
\index[pkg]{Domain!FunctionFieldIntegralBasis}
\index[pkg]{FFINTBAS}
\begin{chunk}{defclass FunctionFieldIntegralBasisType}
(defclass |FunctionFieldIntegralBasisType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FunctionFieldIntegralBasis")
   (marker :initform 'package)
   (abbreviation :initform 'FFINTBAS)
   (comment :initform (list
     "Integral bases for function fields of dimension one"
     "In this package R is a Euclidean domain and F is a framed algebra"
     "over R.  The package provides functions to compute the integral"
     "closure of R in the quotient field of F.  It is assumed that"
     "char(R/P) = char(R) for any prime P of R.  A typical instance of"
     "this is when R = K[x] and F is a function field over R."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionFieldIntegralBasis|
  (progn
    (push '|FunctionFieldIntegralBasis| *Packages*)
    (make-instance '|FunctionFieldIntegralBasisType|)))

\end{chunk}

\subsection{FunctionSpaceAssertions}
\index[pkg]{FunctionSpaceAssertions!Domain}
\index[pkg]{Domain!FunctionSpaceAssertions}
\index[pkg]{PMASSFS}
\begin{chunk}{defclass FunctionSpaceAssertionsType}
(defclass |FunctionSpaceAssertionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FunctionSpaceAssertions")
   (marker :initform 'package)
   (abbreviation :initform 'PMASSFS)
   (comment :initform (list
     "Attaching assertions to symbols for pattern matching"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionSpaceAssertions|
  (progn
    (push '|FunctionSpaceAssertions| *Packages*)
    (make-instance '|FunctionSpaceAssertionsType|)))

\end{chunk}

\subsection{FunctionSpaceAttachPredicates}
\index[pkg]{FunctionSpaceAttachPredicates!Domain}
\index[pkg]{Domain!FunctionSpaceAttachPredicates}
\index[pkg]{PMPREDFS}
\begin{chunk}{defclass FunctionSpaceAttachPredicatesType}
(defclass |FunctionSpaceAttachPredicatesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FunctionSpaceAttachPredicates")
   (marker :initform 'package)
   (abbreviation :initform 'PMPREDFS)
   (comment :initform (list
     "Attaching predicates to symbols for pattern matching."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionSpaceAttachPredicates|
  (progn
    (push '|FunctionSpaceAttachPredicates| *Packages*)
    (make-instance '|FunctionSpaceAttachPredicatesType|)))

\end{chunk}

\subsection{FunctionSpaceComplexIntegration}
\index[pkg]{FunctionSpaceComplexIntegration!Domain}
\index[pkg]{Domain!FunctionSpaceComplexIntegration}
\index[pkg]{FSCINT}
\begin{chunk}{defclass FunctionSpaceComplexIntegrationType}
(defclass |FunctionSpaceComplexIntegrationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FunctionSpaceComplexIntegration")
   (marker :initform 'package)
   (abbreviation :initform 'FSCINT)
   (comment :initform (list
     "FunctionSpaceComplexIntegration provides functions for the"
     "indefinite integration of complex-valued functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionSpaceComplexIntegration|
  (progn
    (push '|FunctionSpaceComplexIntegration| *Packages*)
    (make-instance '|FunctionSpaceComplexIntegrationType|)))

\end{chunk}

\subsection{FunctionSpaceFunctions2}
\index[pkg]{FunctionSpaceFunctions2!Domain}
\index[pkg]{Domain!FunctionSpaceFunctions2}
\index[pkg]{FS2}
\begin{chunk}{defclass FunctionSpaceFunctions2Type}
(defclass |FunctionSpaceFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FunctionSpaceFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'FS2)
   (comment :initform (list
     "This package allows a mapping R -> S to be lifted to a mapping"
     "from a function space over R to a function space over S"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionSpaceFunctions2|
  (progn
    (push '|FunctionSpaceFunctions2| *Packages*)
    (make-instance '|FunctionSpaceFunctions2Type|)))

\end{chunk}

\subsection{FunctionSpaceIntegration}
\index[pkg]{FunctionSpaceIntegration!Domain}
\index[pkg]{Domain!FunctionSpaceIntegration}
\index[pkg]{FSINT}
\begin{chunk}{defclass FunctionSpaceIntegrationType}
(defclass |FunctionSpaceIntegrationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FunctionSpaceIntegration")
   (marker :initform 'package)
   (abbreviation :initform 'FSINT)
   (comment :initform (list
     "Top-level real function integration"
     "FunctionSpaceIntegration provides functions for the"
     "indefinite integration of real-valued functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionSpaceIntegration|
  (progn
    (push '|FunctionSpaceIntegration| *Packages*)
    (make-instance '|FunctionSpaceIntegrationType|)))

\end{chunk}

\subsection{FunctionSpacePrimitiveElement}
\index[pkg]{FunctionSpacePrimitiveElement!Domain}
\index[pkg]{Domain!FunctionSpacePrimitiveElement}
\index[pkg]{FSPRMELT}
\begin{chunk}{defclass FunctionSpacePrimitiveElementType}
(defclass |FunctionSpacePrimitiveElementType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FunctionSpacePrimitiveElement")
   (marker :initform 'package)
   (abbreviation :initform 'FSPRMELT)
   (comment :initform (list
     "FunctionsSpacePrimitiveElement provides functions to compute"
     "primitive elements in functions spaces"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionSpacePrimitiveElement|
  (progn
    (push '|FunctionSpacePrimitiveElement| *Packages*)
    (make-instance '|FunctionSpacePrimitiveElementType|)))

\end{chunk}

\subsection{FunctionSpaceReduce}
\index[pkg]{FunctionSpaceReduce!Domain}
\index[pkg]{Domain!FunctionSpaceReduce}
\index[pkg]{FSRED}
\begin{chunk}{defclass FunctionSpaceReduceType}
(defclass |FunctionSpaceReduceType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FunctionSpaceReduce")
   (marker :initform 'package)
   (abbreviation :initform 'FSRED)
   (comment :initform (list
     "Reduction from a function space to the rational numbers"
     "This package provides function which replaces transcendental kernels"
     "in a function space by random integers. The correspondence between"
     "the kernels and the integers is fixed between calls to new()."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionSpaceReduce|
  (progn
    (push '|FunctionSpaceReduce| *Packages*)
    (make-instance '|FunctionSpaceReduceType|)))

\end{chunk}

\subsection{FunctionSpaceSum}
\index[pkg]{FunctionSpaceSum!Domain}
\index[pkg]{Domain!FunctionSpaceSum}
\index[pkg]{SUMFS}
\begin{chunk}{defclass FunctionSpaceSumType}
(defclass |FunctionSpaceSumType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FunctionSpaceSum")
   (marker :initform 'package)
   (abbreviation :initform 'SUMFS)
   (comment :initform (list
     "Computes sums of top-level expressions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionSpaceSum|
  (progn
    (push '|FunctionSpaceSum| *Packages*)
    (make-instance '|FunctionSpaceSumType|)))

\end{chunk}

\subsection{FunctionSpaceToExponentialExpansion}
\index[pkg]{FunctionSpaceToExponentialExpansion!Domain}
\index[pkg]{Domain!FunctionSpaceToExponentialExpansion}
\index[pkg]{FS2EXPXP}
\begin{chunk}{defclass FunctionSpaceToExponentialExpansionType}
(defclass |FunctionSpaceToExponentialExpansionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FunctionSpaceToExponentialExpansion")
   (marker :initform 'package)
   (abbreviation :initform 'FS2EXPXP)
   (comment :initform (list
     "This package converts expressions in some function space to exponential"
     "expansions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionSpaceToExponentialExpansion|
  (progn
    (push '|FunctionSpaceToExponentialExpansion| *Packages*)
    (make-instance '|FunctionSpaceToExponentialExpansionType|)))

\end{chunk}

\subsection{FunctionSpaceToUnivariatePowerSeries}
\index[pkg]{FunctionSpaceToUnivariatePowerSeries!Domain}
\index[pkg]{Domain!FunctionSpaceToUnivariatePowerSeries}
\index[pkg]{FS2UPS}
\begin{chunk}{defclass FunctionSpaceToUnivariatePowerSeriesType}
(defclass |FunctionSpaceToUnivariatePowerSeriesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FunctionSpaceToUnivariatePowerSeries")
   (marker :initform 'package)
   (abbreviation :initform 'FS2UPS)
   (comment :initform (list
     "This package converts expressions in some function space to power"
     "series in a variable x with coefficients in that function space."
     "The function exprToUPS converts expressions to power series"
     "whose coefficients do not contain the variable x. The function"
     "exprToGenUPS converts functional expressions to power series"
     "whose coefficients may involve functions of log(x)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionSpaceToUnivariatePowerSeries|
  (progn
    (push '|FunctionSpaceToUnivariatePowerSeries| *Packages*)
    (make-instance '|FunctionSpaceToUnivariatePowerSeriesType|)))

\end{chunk}

\subsection{FunctionSpaceUnivariatePolynomialFactor}
\index[pkg]{FunctionSpaceUnivariatePolynomialFactor!Domain}
\index[pkg]{Domain!FunctionSpaceUnivariatePolynomialFactor}
\index[pkg]{FSUPFACT}
\begin{chunk}{defclass FunctionSpaceUnivariatePolynomialFactorType}
(defclass |FunctionSpaceUnivariatePolynomialFactorType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "FunctionSpaceUnivariatePolynomialFactor")
   (marker :initform 'package)
   (abbreviation :initform 'FSUPFACT)
   (comment :initform (list
     "This package is used internally by IR2F"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |FunctionSpaceUnivariatePolynomialFactor|
  (progn
    (push '|FunctionSpaceUnivariatePolynomialFactor| *Packages*)
    (make-instance '|FunctionSpaceUnivariatePolynomialFactorType|)))

\end{chunk}

\section{G}

\subsection{GaloisGroupFactorizationUtilities}
\index[pkg]{GaloisGroupFactorizationUtilities!Domain}
\index[pkg]{Domain!GaloisGroupFactorizationUtilities}
\index[pkg]{GALFACTU}
\begin{chunk}{defclass GaloisGroupFactorizationUtilitiesType}
(defclass |GaloisGroupFactorizationUtilitiesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GaloisGroupFactorizationUtilities")
   (marker :initform 'package)
   (abbreviation :initform 'GALFACTU)
   (comment :initform (list
     "GaloisGroupFactorizationUtilities provides functions"
     "that will be used by the factorizer."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GaloisGroupFactorizationUtilities|
  (progn
    (push '|GaloisGroupFactorizationUtilities| *Packages*)
    (make-instance '|GaloisGroupFactorizationUtilitiesType|)))

\end{chunk}

\subsection{GaloisGroupFactorizer}
\index[pkg]{GaloisGroupFactorizer!Domain}
\index[pkg]{Domain!GaloisGroupFactorizer}
\index[pkg]{GALFACT}
\begin{chunk}{defclass GaloisGroupFactorizerType}
(defclass |GaloisGroupFactorizerType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GaloisGroupFactorizer")
   (marker :initform 'package)
   (abbreviation :initform 'GALFACT)
   (comment :initform (list
     "GaloisGroupFactorizationUtilities provides functions"
     "that will be used by the factorizer."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GaloisGroupFactorizer|
  (progn
    (push '|GaloisGroupFactorizer| *Packages*)
    (make-instance '|GaloisGroupFactorizerType|)))

\end{chunk}

\subsection{GaloisGroupPolynomialUtilities}
\index[pkg]{GaloisGroupPolynomialUtilities!Domain}
\index[pkg]{Domain!GaloisGroupPolynomialUtilities}
\index[pkg]{GALPOLYU}
\begin{chunk}{defclass GaloisGroupPolynomialUtilitiesType}
(defclass |GaloisGroupPolynomialUtilitiesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GaloisGroupPolynomialUtilities")
   (marker :initform 'package)
   (abbreviation :initform 'GALPOLYU)
   (comment :initform (list
     "GaloisGroupPolynomialUtilities provides useful"
     "functions for univariate polynomials which should be added to"
     "UnivariatePolynomialCategory or to Factored"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GaloisGroupPolynomialUtilities|
  (progn
    (push '|GaloisGroupPolynomialUtilities| *Packages*)
    (make-instance '|GaloisGroupPolynomialUtilitiesType|)))

\end{chunk}

\subsection{GaloisGroupUtilities}
\index[pkg]{GaloisGroupUtilities!Domain}
\index[pkg]{Domain!GaloisGroupUtilities}
\index[pkg]{GALUTIL}
\begin{chunk}{defclass GaloisGroupUtilitiesType}
(defclass |GaloisGroupUtilitiesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GaloisGroupUtilities")
   (marker :initform 'package)
   (abbreviation :initform 'GALUTIL)
   (comment :initform (list
     "GaloisGroupUtilities provides several useful functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GaloisGroupUtilities|
  (progn
    (push '|GaloisGroupUtilities| *Packages*)
    (make-instance '|GaloisGroupUtilitiesType|)))

\end{chunk}

\subsection{GaussianFactorizationPackage}
\index[pkg]{GaussianFactorizationPackage!Domain}
\index[pkg]{Domain!GaussianFactorizationPackage}
\index[pkg]{GAUSSFAC}
\begin{chunk}{defclass GaussianFactorizationPackageType}
(defclass |GaussianFactorizationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GaussianFactorizationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'GAUSSFAC)
   (comment :initform (list
     "Package for the factorization of complex or gaussian integers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GaussianFactorizationPackage|
  (progn
    (push '|GaussianFactorizationPackage| *Packages*)
    (make-instance '|GaussianFactorizationPackageType|)))

\end{chunk}

\subsection{GeneralHenselPackage}
\index[pkg]{GeneralHenselPackage!Domain}
\index[pkg]{Domain!GeneralHenselPackage}
\index[pkg]{GHENSEL}
\begin{chunk}{defclass GeneralHenselPackageType}
(defclass |GeneralHenselPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GeneralHenselPackage")
   (marker :initform 'package)
   (abbreviation :initform 'GHENSEL)
   (comment :initform (list
     "Used for Factorization of bivariate polynomials over a finite field."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GeneralHenselPackage|
  (progn
    (push '|GeneralHenselPackage| *Packages*)
    (make-instance '|GeneralHenselPackageType|)))

\end{chunk}

\subsection{GeneralizedMultivariateFactorize}
\index[pkg]{GeneralizedMultivariateFactorize!Domain}
\index[pkg]{Domain!GeneralizedMultivariateFactorize}
\index[pkg]{GENMFACT}
\begin{chunk}{defclass GeneralizedMultivariateFactorizeType}
(defclass |GeneralizedMultivariateFactorizeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GeneralizedMultivariateFactorize")
   (marker :initform 'package)
   (abbreviation :initform 'GENMFACT)
   (comment :initform (list
     "This is the top level package for doing multivariate factorization"
     "over basic domains like Integer or Fraction Integer."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GeneralizedMultivariateFactorize|
  (progn
    (push '|GeneralizedMultivariateFactorize| *Packages*)
    (make-instance '|GeneralizedMultivariateFactorizeType|)))

\end{chunk}

\subsection{GeneralPackageForAlgebraicFunctionField}
\index[pkg]{GeneralPackageForAlgebraicFunctionField!Domain}
\index[pkg]{Domain!GeneralPackageForAlgebraicFunctionField}
\index[pkg]{GPAFF}
\begin{chunk}{defclass GeneralPackageForAlgebraicFunctionFieldType}
(defclass |GeneralPackageForAlgebraicFunctionFieldType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GeneralPackageForAlgebraicFunctionField")
   (marker :initform 'package)
   (abbreviation :initform 'GPAFF)
   (comment :initform (list
     "A package that implements the Brill-Noether algorithm. Part of the"
     "PAFF package."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GeneralPackageForAlgebraicFunctionField|
  (progn
    (push '|GeneralPackageForAlgebraicFunctionField| *Packages*)
    (make-instance '|GeneralPackageForAlgebraicFunctionFieldType|)))

\end{chunk}

\subsection{GeneralPolynomialGcdPackage}
\index[pkg]{GeneralPolynomialGcdPackage!Domain}
\index[pkg]{Domain!GeneralPolynomialGcdPackage}
\index[pkg]{GENPGCD}
\begin{chunk}{defclass GeneralPolynomialGcdPackageType}
(defclass |GeneralPolynomialGcdPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GeneralPolynomialGcdPackage")
   (marker :initform 'package)
   (abbreviation :initform 'GENPGCD)
   (comment :initform nil)
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GeneralPolynomialGcdPackage|
  (progn
    (push '|GeneralPolynomialGcdPackage| *Packages*)
    (make-instance '|GeneralPolynomialGcdPackageType|)))

\end{chunk}

\subsection{GenerateUnivariatePowerSeries}
\index[pkg]{GenerateUnivariatePowerSeries!Domain}
\index[pkg]{Domain!GenerateUnivariatePowerSeries}
\index[pkg]{GENUPS}
\begin{chunk}{defclass GenerateUnivariatePowerSeriesType}
(defclass |GenerateUnivariatePowerSeriesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GenerateUnivariatePowerSeries")
   (marker :initform 'package)
   (abbreviation :initform 'GENUPS)
   (comment :initform (list
     "GenerateUnivariatePowerSeries provides functions that create"
     "power series from explicit formulas for their nth coefficient."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GenerateUnivariatePowerSeries|
  (progn
    (push '|GenerateUnivariatePowerSeries| *Packages*)
    (make-instance '|GenerateUnivariatePowerSeriesType|)))

\end{chunk}

\subsection{GenExEuclid}
\index[pkg]{GenExEuclid!Domain}
\index[pkg]{Domain!GenExEuclid}
\index[pkg]{GENEEZ}
\begin{chunk}{defclass GenExEuclidType}
(defclass |GenExEuclidType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GenExEuclid")
   (marker :initform 'package)
   (abbreviation :initform 'GENEEZ)
   (comment :initform nil)
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GenExEuclid|
  (progn
    (push '|GenExEuclid| *Packages*)
    (make-instance '|GenExEuclidType|)))

\end{chunk}

\subsection{GenUFactorize}
\index[pkg]{GenUFactorize!Domain}
\index[pkg]{Domain!GenUFactorize}
\index[pkg]{GENUFACT}
\begin{chunk}{defclass GenUFactorizeType}
(defclass |GenUFactorizeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GenUFactorize")
   (marker :initform 'package)
   (abbreviation :initform 'GENUFACT)
   (comment :initform (list
     "This package provides operations for the factorization"
     "of univariate polynomials with integer"
     "coefficients. The factorization is done by 'lifting' the"
     "finite 'berlekamp's factorization"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GenUFactorize|
  (progn
    (push '|GenUFactorize| *Packages*)
    (make-instance '|GenUFactorizeType|)))

\end{chunk}

\subsection{GenusZeroIntegration}
\index[pkg]{GenusZeroIntegration!Domain}
\index[pkg]{Domain!GenusZeroIntegration}
\index[pkg]{INTG0}
\begin{chunk}{defclass GenusZeroIntegrationType}
(defclass |GenusZeroIntegrationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GenusZeroIntegration")
   (marker :initform 'package)
   (abbreviation :initform 'INTG0)
   (comment :initform (list
     "Rationalization of several types of genus 0 integrands"
     "This internal package rationalises integrands on curves of the form"
     "     y\^2 = a x\^2 + b x + c"
     "     y\^2 = (a x + b) / (c x + d)"
     "     f(x, y) = 0 where f has degree 1 in x"
     "The rationalization is done for integration, limited integration,"
     "extended integration and the risch differential equation"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GenusZeroIntegration|
  (progn
    (push '|GenusZeroIntegration| *Packages*)
    (make-instance '|GenusZeroIntegrationType|)))

\end{chunk}

\subsection{GnuDraw}
\index[pkg]{GnuDraw!Domain}
\index[pkg]{Domain!GnuDraw}
\index[pkg]{GDRAW}
\begin{chunk}{defclass GnuDrawType}
(defclass |GnuDrawType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GnuDraw")
   (marker :initform 'package)
   (abbreviation :initform 'GDRAW)
   (comment :initform (list
     "This package provides support for gnuplot. These routines"
     "generate output files contain gnuplot scripts that may be"
     "processed directly by gnuplot. This is especially convenient"
     "in the axiom-wiki environment where gnuplot is called from"
     "LaTeX via gnuplottex."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GnuDraw|
  (progn
    (push '|GnuDraw| *Packages*)
    (make-instance '|GnuDrawType|)))

\end{chunk}

\subsection{GosperSummationMethod}
\index[pkg]{GosperSummationMethod!Domain}
\index[pkg]{Domain!GosperSummationMethod}
\index[pkg]{GOSPER}
\begin{chunk}{defclass GosperSummationMethodType}
(defclass |GosperSummationMethodType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GosperSummationMethod")
   (marker :initform 'package)
   (abbreviation :initform 'GOSPER)
   (comment :initform (list
     "Gosper's summation algorithm."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GosperSummationMethod|
  (progn
    (push '|GosperSummationMethod| *Packages*)
    (make-instance '|GosperSummationMethodType|)))

\end{chunk}

\subsection{GraphicsDefaults}
\index[pkg]{GraphicsDefaults!Domain}
\index[pkg]{Domain!GraphicsDefaults}
\index[pkg]{GRDEF}
\begin{chunk}{defclass GraphicsDefaultsType}
(defclass |GraphicsDefaultsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GraphicsDefaults")
   (marker :initform 'package)
   (abbreviation :initform 'GRDEF)
   (comment :initform (list
     "TwoDimensionalPlotSettings sets global flags and constants"
     "for 2-dimensional plotting."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GraphicsDefaults|
  (progn
    (push '|GraphicsDefaults| *Packages*)
    (make-instance '|GraphicsDefaultsType|)))

\end{chunk}

\subsection{Graphviz}
\index[pkg]{Graphviz!Domain}
\index[pkg]{Domain!Graphviz}
\index[pkg]{GRAPHVIZ}
\begin{chunk}{defclass GraphvizType}
(defclass |GraphvizType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "Graphviz")
   (marker :initform 'package)
   (abbreviation :initform 'GRAPHVIZ)
   (comment :initform (list
     "Low level tools for creating and viewing graphs using graphviz"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Graphviz|
  (progn
    (push '|Graphviz| *Packages*)
    (make-instance '|GraphvizType|)))

\end{chunk}

\subsection{GrayCode}
\index[pkg]{GrayCode!Domain}
\index[pkg]{Domain!GrayCode}
\index[pkg]{GRAY}
\begin{chunk}{defclass GrayCodeType}
(defclass |GrayCodeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GrayCode")
   (marker :initform 'package)
   (abbreviation :initform 'GRAY)
   (comment :initform (list
     "GrayCode provides a function for efficiently running"
     "through all subsets of a finite set, only changing one element"
     "by another one."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GrayCode|
  (progn
    (push '|GrayCode| *Packages*)
    (make-instance '|GrayCodeType|)))

\end{chunk}

\subsection{GroebnerFactorizationPackage}
\index[pkg]{GroebnerFactorizationPackage!Domain}
\index[pkg]{Domain!GroebnerFactorizationPackage}
\index[pkg]{GBF}
\begin{chunk}{defclass GroebnerFactorizationPackageType}
(defclass |GroebnerFactorizationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GroebnerFactorizationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'GBF)
   (comment :initform (list
     "GroebnerFactorizationPackage provides the function"
     "groebnerFactor which uses the factorization routines of Axiom to"
     "factor each polynomial under consideration while doing the groebner basis"
     "algorithm. Then it writes the ideal as an intersection of ideals"
     "determined by the irreducible factors. Note that the whole ring may"
     "occur as well as other redundancies. We also use the fact, that from the"
     "second factor on we can assume that the preceding factors are"
     "not equal to 0 and we divide all polynomials under considerations"
     "by the elements of this list of 'nonZeroRestrictions'."
     "The result is a list of groebner bases, whose union of solutions"
     "of the corresponding systems of equations is the solution of"
     "the system of equation corresponding to the input list."
     "The term ordering is determined by the polynomial type used."
     "Suggested types include"
     "DistributedMultivariatePolynomial,"
     "HomogeneousDistributedMultivariatePolynomial,"
     "GeneralDistributedMultivariatePolynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GroebnerFactorizationPackage|
  (progn
    (push '|GroebnerFactorizationPackage| *Packages*)
    (make-instance '|GroebnerFactorizationPackageType|)))

\end{chunk}

\subsection{GroebnerInternalPackage}
\index[pkg]{GroebnerInternalPackage!Domain}
\index[pkg]{Domain!GroebnerInternalPackage}
\index[pkg]{GBINTERN}
\begin{chunk}{defclass GroebnerInternalPackageType}
(defclass |GroebnerInternalPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GroebnerInternalPackage")
   (marker :initform 'package)
   (abbreviation :initform 'GBINTERN)
   (comment :initform (list
     "This package provides low level tools for Groebner basis computations"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GroebnerInternalPackage|
  (progn
    (push '|GroebnerInternalPackage| *Packages*)
    (make-instance '|GroebnerInternalPackageType|)))

\end{chunk}

\subsection{GroebnerPackage}
\index[pkg]{GroebnerPackage!Domain}
\index[pkg]{Domain!GroebnerPackage}
\index[pkg]{GB}
\begin{chunk}{defclass GroebnerPackageType}
(defclass |GroebnerPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GroebnerPackage")
   (marker :initform 'package)
   (abbreviation :initform 'GB)
   (comment :initform (list
     "GroebnerPackage computes groebner"
     "bases for polynomial ideals. The basic computation provides a distinguished"
     "set of generators for polynomial ideals over fields. This basis allows an"
     "easy test for membership: the operation normalForm"
     "returns zero on ideal members. When the provided coefficient domain, Dom,"
     "is not a field, the result is equivalent to considering the extended"
     "ideal with Fraction(Dom) as coefficients, but considerably more"
     "efficient since all calculations are performed in Dom. Additional"
     "argument 'info' and 'redcrit' can be given to provide incremental"
     "information during computation. Argument 'info' produces a computational"
     "summary for each s-polynomial."
     "Argument 'redcrit' prints out the reduced critical pairs. The term ordering"
     "is determined by the polynomial type used. Suggested types include"
     "DistributedMultivariatePolynomial,"
     "HomogeneousDistributedMultivariatePolynomial,"
     "GeneralDistributedMultivariatePolynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GroebnerPackage|
  (progn
    (push '|GroebnerPackage| *Packages*)
    (make-instance '|GroebnerPackageType|)))

\end{chunk}

\subsection{GroebnerSolve}
\index[pkg]{GroebnerSolve!Domain}
\index[pkg]{Domain!GroebnerSolve}
\index[pkg]{GROEBSOL}
\begin{chunk}{defclass GroebnerSolveType}
(defclass |GroebnerSolveType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GroebnerSolve")
   (marker :initform 'package)
   (abbreviation :initform 'GROEBSOL)
   (comment :initform (list
     "Solve systems of polynomial equations using Groebner bases"
     "Total order Groebner bases are computed and then converted to lex ones"
     "This package is mostly intended for internal use."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GroebnerSolve|
  (progn
    (push '|GroebnerSolve| *Packages*)
    (make-instance '|GroebnerSolveType|)))

\end{chunk}

\subsection{Guess}
\index[pkg]{Guess!Domain}
\index[pkg]{Domain!Guess}
\index[pkg]{GUESS}
\begin{chunk}{defclass GuessType}
(defclass |GuessType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "Guess")
   (marker :initform 'package)
   (abbreviation :initform 'GUESS)
   (comment :initform (list
     "This package implements guessing of sequences. Packages for the"
     "most common cases are provided as GuessInteger,"
     "GuessPolynomial, etc."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Guess|
  (progn
    (push '|Guess| *Packages*)
    (make-instance '|GuessType|)))

\end{chunk}

\subsection{GuessAlgebraicNumber}
\index[pkg]{GuessAlgebraicNumber!Domain}
\index[pkg]{Domain!GuessAlgebraicNumber}
\index[pkg]{GUESSAN}
\begin{chunk}{defclass GuessAlgebraicNumberType}
(defclass |GuessAlgebraicNumberType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GuessAlgebraicNumber")
   (marker :initform 'package)
   (abbreviation :initform 'GUESSAN)
   (comment :initform (list
     "This package exports guessing of sequences of rational functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GuessAlgebraicNumber|
  (progn
    (push '|GuessAlgebraicNumber| *Packages*)
    (make-instance '|GuessAlgebraicNumberType|)))

\end{chunk}

\subsection{GuessFinite}
\index[pkg]{GuessFinite!Domain}
\index[pkg]{Domain!GuessFinite}
\index[pkg]{GUESSF}
\begin{chunk}{defclass GuessFiniteType}
(defclass |GuessFiniteType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GuessFinite")
   (marker :initform 'package)
   (abbreviation :initform 'GUESSF)
   (comment :initform (list
     "This package exports guessing of sequences of numbers in a finite field"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GuessFinite|
  (progn
    (push '|GuessFinite| *Packages*)
    (make-instance '|GuessFiniteType|)))

\end{chunk}

\subsection{GuessFiniteFunctions}
\index[pkg]{GuessFiniteFunctions!Domain}
\index[pkg]{Domain!GuessFiniteFunctions}
\index[pkg]{GUESSF1}
\begin{chunk}{defclass GuessFiniteFunctionsType}
(defclass |GuessFiniteFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GuessFiniteFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'GUESSF1)
   (comment :initform (list
     "This package exports guessing of sequences of numbers in a finite field"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GuessFiniteFunctions|
  (progn
    (push '|GuessFiniteFunctions| *Packages*)
    (make-instance '|GuessFiniteFunctionsType|)))

\end{chunk}

\subsection{GuessInteger}
\index[pkg]{GuessInteger!Domain}
\index[pkg]{Domain!GuessInteger}
\index[pkg]{GUESSINT}
\begin{chunk}{defclass GuessIntegerType}
(defclass |GuessIntegerType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GuessInteger")
   (marker :initform 'package)
   (abbreviation :initform 'GUESSINT)
   (comment :initform (list
     "This package exports guessing of sequences of rational numbers"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GuessInteger|
  (progn
    (push '|GuessInteger| *Packages*)
    (make-instance '|GuessIntegerType|)))

\end{chunk}

\subsection{GuessPolynomial}
\index[pkg]{GuessPolynomial!Domain}
\index[pkg]{Domain!GuessPolynomial}
\index[pkg]{GUESSP}
\begin{chunk}{defclass GuessPolynomialType}
(defclass |GuessPolynomialType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GuessPolynomial")
   (marker :initform 'package)
   (abbreviation :initform 'GUESSP)
   (comment :initform (list
     "This package exports guessing of sequences of rational functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GuessPolynomial|
  (progn
    (push '|GuessPolynomial| *Packages*)
    (make-instance '|GuessPolynomialType|)))

\end{chunk}

\subsection{GuessUnivariatePolynomial}
\index[pkg]{GuessUnivariatePolynomial!Domain}
\index[pkg]{Domain!GuessUnivariatePolynomial}
\index[pkg]{GUESSUP}
\begin{chunk}{defclass GuessUnivariatePolynomialType}
(defclass |GuessUnivariatePolynomialType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "GuessUnivariatePolynomial")
   (marker :initform 'package)
   (abbreviation :initform 'GUESSUP)
   (comment :initform (list
     "This package exports guessing of sequences of univariate rational functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |GuessUnivariatePolynomial|
  (progn
    (push '|GuessUnivariatePolynomial| *Packages*)
    (make-instance '|GuessUnivariatePolynomialType|)))

\end{chunk}

\section{H}

\subsection{HallBasis}
\index[pkg]{HallBasis!Domain}
\index[pkg]{Domain!HallBasis}
\index[pkg]{HB}
\begin{chunk}{defclass HallBasisType}
(defclass |HallBasisType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "HallBasis")
   (marker :initform 'package)
   (abbreviation :initform 'HB)
   (comment :initform (list
     "Generate a basis for the free Lie algebra on n"
     "generators over a ring R with identity up to basic commutators"
     "of length c using the algorithm of P. Hall as given in Serre's"
     "book Lie Groups -- Lie Algebras"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |HallBasis|
  (progn
    (push '|HallBasis| *Packages*)
    (make-instance '|HallBasisType|)))

\end{chunk}

\subsection{HeuGcd}
\index[pkg]{HeuGcd!Domain}
\index[pkg]{Domain!HeuGcd}
\index[pkg]{HEUGCD}
\begin{chunk}{defclass HeuGcdType}
(defclass |HeuGcdType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "HeuGcd")
   (marker :initform 'package)
   (abbreviation :initform 'HEUGCD)
   (comment :initform (list
     "This package provides the functions for the heuristic integer gcd."
     "Geddes's algorithm,for univariate polynomials with integer coefficients"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |HeuGcd|
  (progn
    (push '|HeuGcd| *Packages*)
    (make-instance '|HeuGcdType|)))

\end{chunk}

\section{I}

\subsection{IdealDecompositionPackage}
\index[pkg]{IdealDecompositionPackage!Domain}
\index[pkg]{Domain!IdealDecompositionPackage}
\index[pkg]{IDECOMP}
\begin{chunk}{defclass IdealDecompositionPackageType}
(defclass |IdealDecompositionPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IdealDecompositionPackage")
   (marker :initform 'package)
   (abbreviation :initform 'IDECOMP)
   (comment :initform (list
     "This package provides functions for the primary decomposition of"
     "polynomial ideals over the rational numbers. The ideals are members"
     "of the PolynomialIdeals domain, and the polynomial generators are"
     "required to be from the DistributedMultivariatePolynomial domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IdealDecompositionPackage|
  (progn
    (push '|IdealDecompositionPackage| *Packages*)
    (make-instance '|IdealDecompositionPackageType|)))

\end{chunk}

\subsection{IncrementingMaps}
\index[pkg]{IncrementingMaps!Domain}
\index[pkg]{Domain!IncrementingMaps}
\index[pkg]{INCRMAPS}
\begin{chunk}{defclass IncrementingMapsType}
(defclass |IncrementingMapsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IncrementingMaps")
   (marker :initform 'package)
   (abbreviation :initform 'INCRMAPS)
   (comment :initform (list
     "This package provides operations to create incrementing functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IncrementingMaps|
  (progn
    (push '|IncrementingMaps| *Packages*)
    (make-instance '|IncrementingMapsType|)))

\end{chunk}

\subsection{InfiniteProductCharacteristicZero}
\index[pkg]{InfiniteProductCharacteristicZero!Domain}
\index[pkg]{Domain!InfiniteProductCharacteristicZero}
\index[pkg]{INFPROD0}
\begin{chunk}{defclass InfiniteProductCharacteristicZeroType}
(defclass |InfiniteProductCharacteristicZeroType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InfiniteProductCharacteristicZero")
   (marker :initform 'package)
   (abbreviation :initform 'INFPROD0)
   (comment :initform (list
     "This package computes infinite products of univariate Taylor series"
     "over an integral domain of characteristic 0."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InfiniteProductCharacteristicZero|
  (progn
    (push '|InfiniteProductCharacteristicZero| *Packages*)
    (make-instance '|InfiniteProductCharacteristicZeroType|)))

\end{chunk}

\subsection{InfiniteProductFiniteField}
\index[pkg]{InfiniteProductFiniteField!Domain}
\index[pkg]{Domain!InfiniteProductFiniteField}
\index[pkg]{INPRODFF}
\begin{chunk}{defclass InfiniteProductFiniteFieldType}
(defclass |InfiniteProductFiniteFieldType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InfiniteProductFiniteField")
   (marker :initform 'package)
   (abbreviation :initform 'INPRODFF)
   (comment :initform (list
     "This package computes infinite products of univariate Taylor series"
     "over an arbitrary finite field."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InfiniteProductFiniteField|
  (progn
    (push '|InfiniteProductFiniteField| *Packages*)
    (make-instance '|InfiniteProductFiniteFieldType|)))

\end{chunk}

\subsection{InfiniteProductPrimeField}
\index[pkg]{InfiniteProductPrimeField!Domain}
\index[pkg]{Domain!InfiniteProductPrimeField}
\index[pkg]{INPRODPF}
\begin{chunk}{defclass InfiniteProductPrimeFieldType}
(defclass |InfiniteProductPrimeFieldType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InfiniteProductPrimeField")
   (marker :initform 'package)
   (abbreviation :initform 'INPRODPF)
   (comment :initform (list
     "This package computes infinite products of univariate Taylor series"
     "over a field of prime order."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InfiniteProductPrimeField|
  (progn
    (push '|InfiniteProductPrimeField| *Packages*)
    (make-instance '|InfiniteProductPrimeFieldType|)))

\end{chunk}

\subsection{InfiniteTupleFunctions2}
\index[pkg]{InfiniteTupleFunctions2!Domain}
\index[pkg]{Domain!InfiniteTupleFunctions2}
\index[pkg]{ITFUN2}
\begin{chunk}{defclass InfiniteTupleFunctions2Type}
(defclass |InfiniteTupleFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InfiniteTupleFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'ITFUN2)
   (comment :initform (list
     "Functions defined on streams with entries in two sets."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InfiniteTupleFunctions2|
  (progn
    (push '|InfiniteTupleFunctions2| *Packages*)
    (make-instance '|InfiniteTupleFunctions2Type|)))

\end{chunk}

\subsection{InfiniteTupleFunctions3}
\index[pkg]{InfiniteTupleFunctions3!Domain}
\index[pkg]{Domain!InfiniteTupleFunctions3}
\index[pkg]{ITFUN3}
\begin{chunk}{defclass InfiniteTupleFunctions3Type}
(defclass |InfiniteTupleFunctions3Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InfiniteTupleFunctions3")
   (marker :initform 'package)
   (abbreviation :initform 'ITFUN3)
   (comment :initform (list
     "Functions defined on streams with entries in two sets."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InfiniteTupleFunctions3|
  (progn
    (push '|InfiniteTupleFunctions3| *Packages*)
    (make-instance '|InfiniteTupleFunctions3Type|)))

\end{chunk}

\subsection{Infinity}
\index[pkg]{Infinity!Domain}
\index[pkg]{Domain!Infinity}
\index[pkg]{INFINITY}
\begin{chunk}{defclass InfinityType}
(defclass |InfinityType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "Infinity")
   (marker :initform 'package)
   (abbreviation :initform 'INFINITY)
   (comment :initform (list
     "Default infinity signatures for the interpreter"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Infinity|
  (progn
    (push '|Infinity| *Packages*)
    (make-instance '|InfinityType|)))

\end{chunk}

\subsection{InnerAlgFactor}
\index[pkg]{InnerAlgFactor!Domain}
\index[pkg]{Domain!InnerAlgFactor}
\index[pkg]{IALGFACT}
\begin{chunk}{defclass InnerAlgFactorType}
(defclass |InnerAlgFactorType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InnerAlgFactor")
   (marker :initform 'package)
   (abbreviation :initform 'IALGFACT)
   (comment :initform (list
     "Factorisation in a simple algebraic extension"
     "Factorization of univariate polynomials with coefficients in an"
     "algebraic extension of a field over which we can factor UP's"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerAlgFactor|
  (progn
    (push '|InnerAlgFactor| *Packages*)
    (make-instance '|InnerAlgFactorType|)))

\end{chunk}

\subsection{InnerCommonDenominator}
\index[pkg]{InnerCommonDenominator!Domain}
\index[pkg]{Domain!InnerCommonDenominator}
\index[pkg]{ICDEN}
\begin{chunk}{defclass InnerCommonDenominatorType}
(defclass |InnerCommonDenominatorType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InnerCommonDenominator")
   (marker :initform 'package)
   (abbreviation :initform 'ICDEN)
   (comment :initform (list
     "InnerCommonDenominator provides functions to compute"
     "the common denominator of a finite linear aggregate of elements"
     "of the quotient field of an integral domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerCommonDenominator|
  (progn
    (push '|InnerCommonDenominator| *Packages*)
    (make-instance '|InnerCommonDenominatorType|)))

\end{chunk}

\subsection{InnerMatrixLinearAlgebraFunctions}
\index[pkg]{InnerMatrixLinearAlgebraFunctions!Domain}
\index[pkg]{Domain!InnerMatrixLinearAlgebraFunctions}
\index[pkg]{IMATLIN}
\begin{chunk}{defclass InnerMatrixLinearAlgebraFunctionsType}
(defclass |InnerMatrixLinearAlgebraFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InnerMatrixLinearAlgebraFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'IMATLIN)
   (comment :initform (list
     "InnerMatrixLinearAlgebraFunctions is an internal package"
     "which provides standard linear algebra functions on domains in"
     "MatrixCategory"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerMatrixLinearAlgebraFunctions|
  (progn
    (push '|InnerMatrixLinearAlgebraFunctions| *Packages*)
    (make-instance '|InnerMatrixLinearAlgebraFunctionsType|)))

\end{chunk}

\subsection{InnerMatrixQuotientFieldFunctions}
\index[pkg]{InnerMatrixQuotientFieldFunctions!Domain}
\index[pkg]{Domain!InnerMatrixQuotientFieldFunctions}
\index[pkg]{IMATQF}
\begin{chunk}{defclass InnerMatrixQuotientFieldFunctionsType}
(defclass |InnerMatrixQuotientFieldFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InnerMatrixQuotientFieldFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'IMATQF)
   (comment :initform (list
     "InnerMatrixQuotientFieldFunctions provides functions on matrices"
     "over an integral domain which involve the quotient field of that integral"
     "domain.  The functions rowEchelon and inverse return matrices with"
     "entries in the quotient field."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerMatrixQuotientFieldFunctions|
  (progn
    (push '|InnerMatrixQuotientFieldFunctions| *Packages*)
    (make-instance '|InnerMatrixQuotientFieldFunctionsType|)))

\end{chunk}

\subsection{InnerModularGcd}
\index[pkg]{InnerModularGcd!Domain}
\index[pkg]{Domain!InnerModularGcd}
\index[pkg]{INMODGCD}
\begin{chunk}{defclass InnerModularGcdType}
(defclass |InnerModularGcdType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InnerModularGcd")
   (marker :initform 'package)
   (abbreviation :initform 'INMODGCD)
   (comment :initform (list
     "This file contains the functions for modular gcd algorithm"
     "for univariate polynomials with coefficients in a"
     "non-trivial euclidean domain (not a field)."
     "The package parametrised by the coefficient domain,"
     "the polynomial domain, a prime, and a function for choosing the next prime"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerModularGcd|
  (progn
    (push '|InnerModularGcd| *Packages*)
    (make-instance '|InnerModularGcdType|)))

\end{chunk}

\subsection{InnerMultFact}
\index[pkg]{InnerMultFact!Domain}
\index[pkg]{Domain!InnerMultFact}
\index[pkg]{INNMFACT}
\begin{chunk}{defclass InnerMultFactType}
(defclass |InnerMultFactType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InnerMultFact")
   (marker :initform 'package)
   (abbreviation :initform 'INNMFACT)
   (comment :initform (list
     "This is an inner package for factoring multivariate polynomials"
     "over various coefficient domains in characteristic 0."
     "The univariate factor operation is passed as a parameter."
     "Multivariate hensel lifting is used to lift the univariate"
     "factorization"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerMultFact|
  (progn
    (push '|InnerMultFact| *Packages*)
    (make-instance '|InnerMultFactType|)))

\end{chunk}

\subsection{InnerNormalBasisFieldFunctions}
\index[pkg]{InnerNormalBasisFieldFunctions!Domain}
\index[pkg]{Domain!InnerNormalBasisFieldFunctions}
\index[pkg]{INBFF}
\begin{chunk}{defclass InnerNormalBasisFieldFunctionsType}
(defclass |InnerNormalBasisFieldFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InnerNormalBasisFieldFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'INBFF)
   (comment :initform (list
     "InnerNormalBasisFieldFunctions(GF) (unexposed)"
     "This package has functions used by"
     "every normal basis finite field extension domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerNormalBasisFieldFunctions|
  (progn
    (push '|InnerNormalBasisFieldFunctions| *Packages*)
    (make-instance '|InnerNormalBasisFieldFunctionsType|)))

\end{chunk}

\subsection{InnerNumericEigenPackage}
\index[pkg]{InnerNumericEigenPackage!Domain}
\index[pkg]{Domain!InnerNumericEigenPackage}
\index[pkg]{INEP}
\begin{chunk}{defclass InnerNumericEigenPackageType}
(defclass |InnerNumericEigenPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InnerNumericEigenPackage")
   (marker :initform 'package)
   (abbreviation :initform 'INEP)
   (comment :initform (list
     "This package is the inner package to be used by NumericRealEigenPackage"
     "and NumericComplexEigenPackage for the computation of numeric"
     "eigenvalues and eigenvectors."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerNumericEigenPackage|
  (progn
    (push '|InnerNumericEigenPackage| *Packages*)
    (make-instance '|InnerNumericEigenPackageType|)))

\end{chunk}

\subsection{InnerNumericFloatSolvePackage}
\index[pkg]{InnerNumericFloatSolvePackage!Domain}
\index[pkg]{Domain!InnerNumericFloatSolvePackage}
\index[pkg]{INFSP}
\begin{chunk}{defclass InnerNumericFloatSolvePackageType}
(defclass |InnerNumericFloatSolvePackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InnerNumericFloatSolvePackage")
   (marker :initform 'package)
   (abbreviation :initform 'INFSP)
   (comment :initform (list
     "This is an internal package"
     "for computing approximate solutions to systems of polynomial equations."
     "The parameter K specifies the coefficient field of the input polynomials"
     "and must be either \spad{Fraction(Integer)} or"
     "Complex(Fraction Integer)."
     "The parameter F specifies where the solutions must lie and can"
     "be one of the following: Float, Fraction(Integer), Complex(Float),"
     "Complex(Fraction Integer). The last parameter specifies the type"
     "of the precision operand and must be either Fraction(Integer) or"
     "Float."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerNumericFloatSolvePackage|
  (progn
    (push '|InnerNumericFloatSolvePackage| *Packages*)
    (make-instance '|InnerNumericFloatSolvePackageType|)))

\end{chunk}

\subsection{InnerPolySign}
\index[pkg]{InnerPolySign!Domain}
\index[pkg]{Domain!InnerPolySign}
\index[pkg]{INPSIGN}
\begin{chunk}{defclass InnerPolySignType}
(defclass |InnerPolySignType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InnerPolySign")
   (marker :initform 'package)
   (abbreviation :initform 'INPSIGN)
   (comment :initform (list
     "Find the sign of a polynomial around a point or infinity."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerPolySign|
  (progn
    (push '|InnerPolySign| *Packages*)
    (make-instance '|InnerPolySignType|)))

\end{chunk}

\subsection{InnerPolySum}
\index[pkg]{InnerPolySum!Domain}
\index[pkg]{Domain!InnerPolySum}
\index[pkg]{ISUMP}
\begin{chunk}{defclass InnerPolySumType}
(defclass |InnerPolySumType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InnerPolySum")
   (marker :initform 'package)
   (abbreviation :initform 'ISUMP)
   (comment :initform (list
     "Tools for the summation packages of polynomials"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerPolySum|
  (progn
    (push '|InnerPolySum| *Packages*)
    (make-instance '|InnerPolySumType|)))

\end{chunk}

\subsection{InnerTrigonometricManipulations}
\index[pkg]{InnerTrigonometricManipulations!Domain}
\index[pkg]{Domain!InnerTrigonometricManipulations}
\index[pkg]{ITRIGMNP}
\begin{chunk}{defclass InnerTrigonometricManipulationsType}
(defclass |InnerTrigonometricManipulationsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InnerTrigonometricManipulations")
   (marker :initform 'package)
   (abbreviation :initform 'ITRIGMNP)
   (comment :initform (list
     "This package provides transformations from trigonometric functions"
     "to exponentials and logarithms, and back."
     "F and FG should be the same type of function space."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InnerTrigonometricManipulations|
  (progn
    (push '|InnerTrigonometricManipulations| *Packages*)
    (make-instance '|InnerTrigonometricManipulationsType|)))

\end{chunk}

\subsection{InputFormFunctions1}
\index[pkg]{InputFormFunctions1!Domain}
\index[pkg]{Domain!InputFormFunctions1}
\index[pkg]{INFORM1}
\begin{chunk}{defclass InputFormFunctions1Type}
(defclass |InputFormFunctions1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InputFormFunctions1")
   (marker :initform 'package)
   (abbreviation :initform 'INFORM1)
   (comment :initform (list
     "Tools for manipulating input forms."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InputFormFunctions1|
  (progn
    (push '|InputFormFunctions1| *Packages*)
    (make-instance '|InputFormFunctions1Type|)))

\end{chunk}

\subsection{InterfaceGroebnerPackage}
\index[pkg]{InterfaceGroebnerPackage!Domain}
\index[pkg]{Domain!InterfaceGroebnerPackage}
\index[pkg]{INTERGB}
\begin{chunk}{defclass InterfaceGroebnerPackageType}
(defclass |InterfaceGroebnerPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InterfaceGroebnerPackage")
   (marker :initform 'package)
   (abbreviation :initform 'INTERGB)
   (comment :initform (list
     "Part of the Package for Algebraic Function Fields in one variable PAFF"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InterfaceGroebnerPackage|
  (progn
    (push '|InterfaceGroebnerPackage| *Packages*)
    (make-instance '|InterfaceGroebnerPackageType|)))

\end{chunk}

\subsection{IntegerBits}
\index[pkg]{IntegerBits!Domain}
\index[pkg]{Domain!IntegerBits}
\index[pkg]{INTBIT}
\begin{chunk}{defclass IntegerBitsType}
(defclass |IntegerBitsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntegerBits")
   (marker :initform 'package)
   (abbreviation :initform 'INTBIT)
   (comment :initform (list
     "This  package provides functions to lookup bits in integers "))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegerBits|
  (progn
    (push '|IntegerBits| *Packages*)
    (make-instance '|IntegerBitsType|)))

\end{chunk}

\subsection{IntegerCombinatoricFunctions}
\index[pkg]{IntegerCombinatoricFunctions!Domain}
\index[pkg]{Domain!IntegerCombinatoricFunctions}
\index[pkg]{COMBINAT}
\begin{chunk}{defclass IntegerCombinatoricFunctionsType}
(defclass |IntegerCombinatoricFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntegerCombinatoricFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'COMBINAT)
   (comment :initform (list
     "The IntegerCombinatoricFunctions package provides some"
     "standard functions in combinatorics."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegerCombinatoricFunctions|
  (progn
    (push '|IntegerCombinatoricFunctions| *Packages*)
    (make-instance '|IntegerCombinatoricFunctionsType|)))

\end{chunk}

\subsection{IntegerFactorizationPackage}
\index[pkg]{IntegerFactorizationPackage!Domain}
\index[pkg]{Domain!IntegerFactorizationPackage}
\index[pkg]{INTFACT}
\begin{chunk}{defclass IntegerFactorizationPackageType}
(defclass |IntegerFactorizationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntegerFactorizationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'INTFACT)
   (comment :initform (list
     "This Package contains basic methods for integer factorization."
     "The factor operation employs trial division up to 10,000.  It"
     "then tests to see if n is a perfect power before using Pollards"
     "rho method.  Because Pollards method may fail, the result"
     "of factor may contain composite factors.  We should also employ"
     "Lenstra's eliptic curve method."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegerFactorizationPackage|
  (progn
    (push '|IntegerFactorizationPackage| *Packages*)
    (make-instance '|IntegerFactorizationPackageType|)))

\end{chunk}

\subsection{IntegerLinearDependence}
\index[pkg]{IntegerLinearDependence!Domain}
\index[pkg]{Domain!IntegerLinearDependence}
\index[pkg]{ZLINDEP}
\begin{chunk}{defclass IntegerLinearDependenceType}
(defclass |IntegerLinearDependenceType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntegerLinearDependence")
   (marker :initform 'package)
   (abbreviation :initform 'ZLINDEP)
   (comment :initform (list
     "Test for linear dependence over the integers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegerLinearDependence|
  (progn
    (push '|IntegerLinearDependence| *Packages*)
    (make-instance '|IntegerLinearDependenceType|)))

\end{chunk}

\subsection{IntegerNumberTheoryFunctions}
\index[pkg]{IntegerNumberTheoryFunctions!Domain}
\index[pkg]{Domain!IntegerNumberTheoryFunctions}
\index[pkg]{INTHEORY}
\begin{chunk}{defclass IntegerNumberTheoryFunctionsType}
(defclass |IntegerNumberTheoryFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntegerNumberTheoryFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'INTHEORY)
   (comment :initform (list
     "This package provides various number theoretic functions on the integers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegerNumberTheoryFunctions|
  (progn
    (push '|IntegerNumberTheoryFunctions| *Packages*)
    (make-instance '|IntegerNumberTheoryFunctionsType|)))

\end{chunk}

\subsection{IntegerPrimesPackage}
\index[pkg]{IntegerPrimesPackage!Domain}
\index[pkg]{Domain!IntegerPrimesPackage}
\index[pkg]{PRIMES}
\begin{chunk}{defclass IntegerPrimesPackageType}
(defclass |IntegerPrimesPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntegerPrimesPackage")
   (marker :initform 'package)
   (abbreviation :initform 'PRIMES)
   (comment :initform (list
     "The IntegerPrimesPackage implements a modification of"
     "Rabin's probabilistic"
     "primality test and the utility functions nextPrime,"
     "prevPrime and primes."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegerPrimesPackage|
  (progn
    (push '|IntegerPrimesPackage| *Packages*)
    (make-instance '|IntegerPrimesPackageType|)))

\end{chunk}

\subsection{IntegerRetractions}
\index[pkg]{IntegerRetractions!Domain}
\index[pkg]{Domain!IntegerRetractions}
\index[pkg]{INTRET}
\begin{chunk}{defclass IntegerRetractionsType}
(defclass |IntegerRetractionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntegerRetractions")
   (marker :initform 'package)
   (abbreviation :initform 'INTRET)
   (comment :initform (list
     "Provides integer testing and retraction functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegerRetractions|
  (progn
    (push '|IntegerRetractions| *Packages*)
    (make-instance '|IntegerRetractionsType|)))

\end{chunk}

\subsection{IntegerRoots}
\index[pkg]{IntegerRoots!Domain}
\index[pkg]{Domain!IntegerRoots}
\index[pkg]{IROOT}
\begin{chunk}{defclass IntegerRootsType}
(defclass |IntegerRootsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntegerRoots")
   (marker :initform 'package)
   (abbreviation :initform 'IROOT)
   (comment :initform (list
     "The IntegerRoots package computes square roots and"
     "nth roots of integers efficiently."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegerRoots|
  (progn
    (push '|IntegerRoots| *Packages*)
    (make-instance '|IntegerRootsType|)))

\end{chunk}

\subsection{IntegerSolveLinearPolynomialEquation}
\index[pkg]{IntegerSolveLinearPolynomialEquation!Domain}
\index[pkg]{Domain!IntegerSolveLinearPolynomialEquation}
\index[pkg]{INTSLPE}
\begin{chunk}{defclass IntegerSolveLinearPolynomialEquationType}
(defclass |IntegerSolveLinearPolynomialEquationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntegerSolveLinearPolynomialEquation")
   (marker :initform 'package)
   (abbreviation :initform 'INTSLPE)
   (comment :initform (list
     "This package provides the implementation for the"
     "solveLinearPolynomialEquation"
     "operation over the integers. It uses a lifting technique"
     "from the package GenExEuclid"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegerSolveLinearPolynomialEquation|
  (progn
    (push '|IntegerSolveLinearPolynomialEquation| *Packages*)
    (make-instance '|IntegerSolveLinearPolynomialEquationType|)))

\end{chunk}

\subsection{IntegralBasisTools}
\index[pkg]{IntegralBasisTools!Domain}
\index[pkg]{Domain!IntegralBasisTools}
\index[pkg]{IBATOOL}
\begin{chunk}{defclass IntegralBasisToolsType}
(defclass |IntegralBasisToolsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntegralBasisTools")
   (marker :initform 'package)
   (abbreviation :initform 'IBATOOL)
   (comment :initform (list
     "This package contains functions used in the packages"
     "FunctionFieldIntegralBasis and NumberFieldIntegralBasis."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegralBasisTools|
  (progn
    (push '|IntegralBasisTools| *Packages*)
    (make-instance '|IntegralBasisToolsType|)))

\end{chunk}

\subsection{IntegralBasisPolynomialTools}
\index[pkg]{IntegralBasisPolynomialTools!Domain}
\index[pkg]{Domain!IntegralBasisPolynomialTools}
\index[pkg]{IBPTOOLS}
\begin{chunk}{defclass IntegralBasisPolynomialToolsType}
(defclass |IntegralBasisPolynomialToolsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntegralBasisPolynomialTools")
   (marker :initform 'package)
   (abbreviation :initform 'IBPTOOLS)
   (comment :initform (list
     "IntegralBasisPolynomialTools provides functions for mapping functions"
     "on the coefficients of univariate and bivariate polynomials."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegralBasisPolynomialTools|
  (progn
    (push '|IntegralBasisPolynomialTools| *Packages*)
    (make-instance '|IntegralBasisPolynomialToolsType|)))

\end{chunk}

\subsection{IntegrationResultFunctions2}
\index[pkg]{IntegrationResultFunctions2!Domain}
\index[pkg]{Domain!IntegrationResultFunctions2}
\index[pkg]{IR2}
\begin{chunk}{defclass IntegrationResultFunctions2Type}
(defclass |IntegrationResultFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntegrationResultFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'IR2)
   (comment :initform (list
     "Internally used by the integration packages"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegrationResultFunctions2|
  (progn
    (push '|IntegrationResultFunctions2| *Packages*)
    (make-instance '|IntegrationResultFunctions2Type|)))

\end{chunk}

\subsection{IntegrationResultRFToFunction}
\index[pkg]{IntegrationResultRFToFunction!Domain}
\index[pkg]{Domain!IntegrationResultRFToFunction}
\index[pkg]{IRRF2F}
\begin{chunk}{defclass IntegrationResultRFToFunctionType}
(defclass |IntegrationResultRFToFunctionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntegrationResultRFToFunction")
   (marker :initform 'package)
   (abbreviation :initform 'IRRF2F)
   (comment :initform (list
     "Conversion of integration results to top-level expressions."
     "This package allows a sum of logs over the roots of a polynomial"
     "to be expressed as explicit logarithms and arc tangents, provided"
     "that the indexing polynomial can be factored into quadratics."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegrationResultRFToFunction|
  (progn
    (push '|IntegrationResultRFToFunction| *Packages*)
    (make-instance '|IntegrationResultRFToFunctionType|)))

\end{chunk}

\subsection{IntegrationResultToFunction}
\index[pkg]{IntegrationResultToFunction!Domain}
\index[pkg]{Domain!IntegrationResultToFunction}
\index[pkg]{IR2F}
\begin{chunk}{defclass IntegrationResultToFunctionType}
(defclass |IntegrationResultToFunctionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntegrationResultToFunction")
   (marker :initform 'package)
   (abbreviation :initform 'IR2F)
   (comment :initform (list
     "Conversion of integration results to top-level expressions"
     "This package allows a sum of logs over the roots of a polynomial"
     "to be expressed as explicit logarithms and arc tangents, provided"
     "that the indexing polynomial can be factored into quadratics."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegrationResultToFunction|
  (progn
    (push '|IntegrationResultToFunction| *Packages*)
    (make-instance '|IntegrationResultToFunctionType|)))

\end{chunk}

\subsection{IntegrationTools}
\index[pkg]{IntegrationTools!Domain}
\index[pkg]{Domain!IntegrationTools}
\index[pkg]{INTTOOLS}
\begin{chunk}{defclass IntegrationToolsType}
(defclass |IntegrationToolsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntegrationTools")
   (marker :initform 'package)
   (abbreviation :initform 'INTTOOLS)
   (comment :initform (list
     "Tools for the integrator"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntegrationTools|
  (progn
    (push '|IntegrationTools| *Packages*)
    (make-instance '|IntegrationToolsType|)))

\end{chunk}

\subsection{InternalPrintPackage}
\index[pkg]{InternalPrintPackage!Domain}
\index[pkg]{Domain!InternalPrintPackage}
\index[pkg]{IPRNTPK}
\begin{chunk}{defclass InternalPrintPackageType}
(defclass |InternalPrintPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InternalPrintPackage")
   (marker :initform 'package)
   (abbreviation :initform 'IPRNTPK)
   (comment :initform (list
     "A package to print strings without line-feed nor carriage-return."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InternalPrintPackage|
  (progn
    (push '|InternalPrintPackage| *Packages*)
    (make-instance '|InternalPrintPackageType|)))

\end{chunk}

\subsection{InternalRationalUnivariateRepresentationPackage}
\index[pkg]{InternalRationalUnivariateRepresentationPackage!Domain}
\index[pkg]{Domain!InternalRationalUnivariateRepresentationPackage}
\index[pkg]{IRURPK}
\begin{chunk}{defclass InternalRationalUnivariateRepresentationPackageType}
(defclass |InternalRationalUnivariateRepresentationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InternalRationalUnivariateRepresentationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'IRURPK)
   (comment :initform nil)
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InternalRationalUnivariateRepresentationPackage|
  (progn
    (push '|InternalRationalUnivariateRepresentationPackage| *Packages*)
    (make-instance '|InternalRationalUnivariateRepresentationPackageType|)))

\end{chunk}

\subsection{InterpolateFormsPackage}
\index[pkg]{InterpolateFormsPackage!Domain}
\index[pkg]{Domain!InterpolateFormsPackage}
\index[pkg]{INTFRSP}
\begin{chunk}{defclass InterpolateFormsPackageType}
(defclass |InterpolateFormsPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InterpolateFormsPackage")
   (marker :initform 'package)
   (abbreviation :initform 'INTFRSP)
   (comment :initform (list
     "The following is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InterpolateFormsPackage|
  (progn
    (push '|InterpolateFormsPackage| *Packages*)
    (make-instance '|InterpolateFormsPackageType|)))

\end{chunk}

\subsection{IntersectionDivisorPackage}
\index[pkg]{IntersectionDivisorPackage!Domain}
\index[pkg]{Domain!IntersectionDivisorPackage}
\index[pkg]{INTDIVP}
\begin{chunk}{defclass IntersectionDivisorPackageType}
(defclass |IntersectionDivisorPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IntersectionDivisorPackage")
   (marker :initform 'package)
   (abbreviation :initform 'INTDIVP)
   (comment :initform (list
     "The following is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IntersectionDivisorPackage|
  (progn
    (push '|IntersectionDivisorPackage| *Packages*)
    (make-instance '|IntersectionDivisorPackageType|)))

\end{chunk}

\subsection{IrredPolyOverFiniteField}
\index[pkg]{IrredPolyOverFiniteField!Domain}
\index[pkg]{Domain!IrredPolyOverFiniteField}
\index[pkg]{IRREDFFX}
\begin{chunk}{defclass IrredPolyOverFiniteFieldType}
(defclass |IrredPolyOverFiniteFieldType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IrredPolyOverFiniteField")
   (marker :initform 'package)
   (abbreviation :initform 'IRREDFFX)
   (comment :initform (list
     "This package exports the function generateIrredPoly that computes"
     "a monic irreducible polynomial of degree n over a finite field."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IrredPolyOverFiniteField|
  (progn
    (push '|IrredPolyOverFiniteField| *Packages*)
    (make-instance '|IrredPolyOverFiniteFieldType|)))

\end{chunk}

\subsection{IrrRepSymNatPackage}
\index[pkg]{IrrRepSymNatPackage!Domain}
\index[pkg]{Domain!IrrRepSymNatPackage}
\index[pkg]{IRSN}
\begin{chunk}{defclass IrrRepSymNatPackageType}
(defclass |IrrRepSymNatPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "IrrRepSymNatPackage")
   (marker :initform 'package)
   (abbreviation :initform 'IRSN)
   (comment :initform (list
     "IrrRepSymNatPackage contains functions for computing"
     "the ordinary irreducible representations of symmetric groups on"
     "n letters {1,2,...,n} in Young's natural form and their dimensions."
     "These representations can be labelled by number partitions of n,"
     "a weakly decreasing sequence of integers summing up to n, for"
     "example, [3,3,3,1] labels an irreducible representation for n equals 10."
     "Note that whenever a List Integer appears in a signature,"
     "a partition required."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |IrrRepSymNatPackage|
  (progn
    (push '|IrrRepSymNatPackage| *Packages*)
    (make-instance '|IrrRepSymNatPackageType|)))

\end{chunk}

\subsection{InverseLaplaceTransform}
\index[pkg]{InverseLaplaceTransform!Domain}
\index[pkg]{Domain!InverseLaplaceTransform}
\index[pkg]{INVLAPLA}
\begin{chunk}{defclass InverseLaplaceTransformType}
(defclass |InverseLaplaceTransformType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "InverseLaplaceTransform")
   (marker :initform 'package)
   (abbreviation :initform 'INVLAPLA)
   (comment :initform (list
     "This package computes the inverse Laplace Transform."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |InverseLaplaceTransform|
  (progn
    (push '|InverseLaplaceTransform| *Packages*)
    (make-instance '|InverseLaplaceTransformType|)))

\end{chunk}

\section{K}

\subsection{KernelFunctions2}
\index[pkg]{KernelFunctions2!Domain}
\index[pkg]{Domain!KernelFunctions2}
\index[pkg]{KERNEL2}
\begin{chunk}{defclass KernelFunctions2Type}
(defclass |KernelFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "KernelFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'KERNEL2)
   (comment :initform (list
     "This package exports some auxiliary functions on kernels"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |KernelFunctions2|
  (progn
    (push '|KernelFunctions2| *Packages*)
    (make-instance '|KernelFunctions2Type|)))

\end{chunk}

\subsection{Kovacic}
\index[pkg]{Kovacic!Domain}
\index[pkg]{Domain!Kovacic}
\index[pkg]{KOVACIC}
\begin{chunk}{defclass KovacicType}
(defclass |KovacicType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "Kovacic")
   (marker :initform 'package)
   (abbreviation :initform 'KOVACIC)
   (comment :initform (list
     "Kovacic provides a modified Kovacic's algorithm for"
     "solving explicitely irreducible 2nd order linear ordinary"
     "differential equations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Kovacic|
  (progn
    (push '|Kovacic| *Packages*)
    (make-instance '|KovacicType|)))

\end{chunk}

\section{L}

\subsection{LaplaceTransform}
\index[pkg]{LaplaceTransform!Domain}
\index[pkg]{Domain!LaplaceTransform}
\index[pkg]{LAPLACE}
\begin{chunk}{defclass LaplaceTransformType}
(defclass |LaplaceTransformType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LaplaceTransform")
   (marker :initform 'package)
   (abbreviation :initform 'LAPLACE)
   (comment :initform (list
     "This package computes the forward Laplace Transform."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LaplaceTransform|
  (progn
    (push '|LaplaceTransform| *Packages*)
    (make-instance '|LaplaceTransformType|)))

\end{chunk}

\subsection{LazardSetSolvingPackage}
\index[pkg]{LazardSetSolvingPackage!Domain}
\index[pkg]{Domain!LazardSetSolvingPackage}
\index[pkg]{LAZM3PK}
\begin{chunk}{defclass LazardSetSolvingPackageType}
(defclass |LazardSetSolvingPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LazardSetSolvingPackage")
   (marker :initform 'package)
   (abbreviation :initform 'LAZM3PK)
   (comment :initform (list
     "A package for solving polynomial systems by means of Lazard triangular"
     "sets. This package provides two operations. One for solving in the sense"
     "of the regular zeros, and the other for solving in the sense of"
     "the Zariski closure. Both produce square-free regular sets."
     "Moreover, the decompositions do not contain any redundant component."
     "However, only zero-dimensional regular sets are normalized, since"
     "normalization may be time consumming in positive dimension."
     "The decomposition process is that of [2]."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LazardSetSolvingPackage|
  (progn
    (push '|LazardSetSolvingPackage| *Packages*)
    (make-instance '|LazardSetSolvingPackageType|)))

\end{chunk}

\subsection{LeadingCoefDetermination}
\index[pkg]{LeadingCoefDetermination!Domain}
\index[pkg]{Domain!LeadingCoefDetermination}
\index[pkg]{LEADCDET}
\begin{chunk}{defclass LeadingCoefDeterminationType}
(defclass |LeadingCoefDeterminationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LeadingCoefDetermination")
   (marker :initform 'package)
   (abbreviation :initform 'LEADCDET)
   (comment :initform (list
     "Package for leading coefficient determination in the lifting step."
     "Package working for every R euclidean with property 'F'."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LeadingCoefDetermination|
  (progn
    (push '|LeadingCoefDetermination| *Packages*)
    (make-instance '|LeadingCoefDeterminationType|)))

\end{chunk}

\subsection{LexTriangularPackage}
\index[pkg]{LexTriangularPackage!Domain}
\index[pkg]{Domain!LexTriangularPackage}
\index[pkg]{LEXTRIPK}
\begin{chunk}{defclass LexTriangularPackageType}
(defclass |LexTriangularPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LexTriangularPackage")
   (marker :initform 'package)
   (abbreviation :initform 'LEXTRIPK)
   (comment :initform (list
     "A package for solving polynomial systems with finitely many solutions."
     "The decompositions are given by means of regular triangular sets."
     "The computations use lexicographical Groebner bases."
     "The main operations are lexTriangular"
     "and squareFreeLexTriangular. The second one provide decompositions by"
     "means of square-free regular triangular sets."
     "Both are based on the lexTriangular method described in [1]."
     "They differ from the algorithm described in [2] by the fact that"
     "multiplicities of the roots are not kept."
     "With the squareFreeLexTriangular operation all multiciplities are removed."
     "With the other operation some multiciplities may remain. Both operations"
     "admit an optional argument to produce normalized triangular sets."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LexTriangularPackage|
  (progn
    (push '|LexTriangularPackage| *Packages*)
    (make-instance '|LexTriangularPackageType|)))

\end{chunk}

\subsection{LinearDependence}
\index[pkg]{LinearDependence!Domain}
\index[pkg]{Domain!LinearDependence}
\index[pkg]{LINDEP}
\begin{chunk}{defclass LinearDependenceType}
(defclass |LinearDependenceType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LinearDependence")
   (marker :initform 'package)
   (abbreviation :initform 'LINDEP)
   (comment :initform (list
     "Test for linear dependence."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinearDependence|
  (progn
    (push '|LinearDependence| *Packages*)
    (make-instance '|LinearDependenceType|)))

\end{chunk}

\subsection{LinearOrdinaryDifferentialOperatorFactorizer}
\index[pkg]{LinearOrdinaryDifferentialOperatorFactorizer!Domain}
\index[pkg]{Domain!LinearOrdinaryDifferentialOperatorFactorizer}
\index[pkg]{LODOF}
\begin{chunk}{defclass LinearOrdinaryDifferentialOperatorFactorizerType}
(defclass |LinearOrdinaryDifferentialOperatorFactorizerType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LinearOrdinaryDifferentialOperatorFactorizer")
   (marker :initform 'package)
   (abbreviation :initform 'LODOF)
   (comment :initform (list
     "LinearOrdinaryDifferentialOperatorFactorizer provides a"
     "factorizer for linear ordinary differential operators whose coefficients"
     "are rational functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinearOrdinaryDifferentialOperatorFactorizer|
  (progn
    (push '|LinearOrdinaryDifferentialOperatorFactorizer| *Packages*)
    (make-instance '|LinearOrdinaryDifferentialOperatorFactorizerType|)))

\end{chunk}

\subsection{LinearOrdinaryDifferentialOperatorsOps}
\index[pkg]{LinearOrdinaryDifferentialOperatorsOps!Domain}
\index[pkg]{Domain!LinearOrdinaryDifferentialOperatorsOps}
\index[pkg]{LODOOPS}
\begin{chunk}{defclass LinearOrdinaryDifferentialOperatorsOpsType}
(defclass |LinearOrdinaryDifferentialOperatorsOpsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LinearOrdinaryDifferentialOperatorsOps")
   (marker :initform 'package)
   (abbreviation :initform 'LODOOPS)
   (comment :initform (list
     "LinearOrdinaryDifferentialOperatorsOps provides symmetric"
     "products and sums for linear ordinary differential operators."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinearOrdinaryDifferentialOperatorsOps|
  (progn
    (push '|LinearOrdinaryDifferentialOperatorsOps| *Packages*)
    (make-instance '|LinearOrdinaryDifferentialOperatorsOpsType|)))

\end{chunk}

\subsection{LinearPolynomialEquationByFractions}
\index[pkg]{LinearPolynomialEquationByFractions!Domain}
\index[pkg]{Domain!LinearPolynomialEquationByFractions}
\index[pkg]{LPEFRAC}
\begin{chunk}{defclass LinearPolynomialEquationByFractionsType}
(defclass |LinearPolynomialEquationByFractionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LinearPolynomialEquationByFractions")
   (marker :initform 'package)
   (abbreviation :initform 'LPEFRAC)
   (comment :initform (list
     "Given a PolynomialFactorizationExplicit ring, this package"
     "provides a defaulting rule for the solveLinearPolynomialEquation"
     "operation, by moving into the field of fractions, and solving it there"
     "via the multiEuclidean operation."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinearPolynomialEquationByFractions|
  (progn
    (push '|LinearPolynomialEquationByFractions| *Packages*)
    (make-instance '|LinearPolynomialEquationByFractionsType|)))

\end{chunk}

\subsection{LinearSystemFromPowerSeriesPackage}
\index[pkg]{LinearSystemFromPowerSeriesPackage!Domain}
\index[pkg]{Domain!LinearSystemFromPowerSeriesPackage}
\index[pkg]{LISYSER}
\begin{chunk}{defclass LinearSystemFromPowerSeriesPackageType}
(defclass |LinearSystemFromPowerSeriesPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LinearSystemFromPowerSeriesPackage")
   (marker :initform 'package)
   (abbreviation :initform 'LISYSER)
   (comment :initform (list
     "Part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinearSystemFromPowerSeriesPackage|
  (progn
    (push '|LinearSystemFromPowerSeriesPackage| *Packages*)
    (make-instance '|LinearSystemFromPowerSeriesPackageType|)))

\end{chunk}

\subsection{LinearSystemMatrixPackage}
\index[pkg]{LinearSystemMatrixPackage!Domain}
\index[pkg]{Domain!LinearSystemMatrixPackage}
\index[pkg]{LSMP}
\begin{chunk}{defclass LinearSystemMatrixPackageType}
(defclass |LinearSystemMatrixPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LinearSystemMatrixPackage")
   (marker :initform 'package)
   (abbreviation :initform 'LSMP)
   (comment :initform (list
     "This package solves linear system in the matrix form AX = B."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinearSystemMatrixPackage|
  (progn
    (push '|LinearSystemMatrixPackage| *Packages*)
    (make-instance '|LinearSystemMatrixPackageType|)))

\end{chunk}

\subsection{LinearSystemMatrixPackage1}
\index[pkg]{LinearSystemMatrixPackage1!Domain}
\index[pkg]{Domain!LinearSystemMatrixPackage1}
\index[pkg]{LSMP1}
\begin{chunk}{defclass LinearSystemMatrixPackage1Type}
(defclass |LinearSystemMatrixPackage1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LinearSystemMatrixPackage1")
   (marker :initform 'package)
   (abbreviation :initform 'LSMP1)
   (comment :initform (list
     "This package solves linear system in the matrix form AX = B."
     "It is essentially a particular instantiation of the package"
     "LinearSystemMatrixPackage for Matrix and Vector. This"
     "package's existence makes it easier to use solve in the"
     "AXIOM interpreter."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinearSystemMatrixPackage1|
  (progn
    (push '|LinearSystemMatrixPackage1| *Packages*)
    (make-instance '|LinearSystemMatrixPackage1Type|)))

\end{chunk}

\subsection{LinearSystemPolynomialPackage}
\index[pkg]{LinearSystemPolynomialPackage!Domain}
\index[pkg]{Domain!LinearSystemPolynomialPackage}
\index[pkg]{LSPP}
\begin{chunk}{defclass LinearSystemPolynomialPackageType}
(defclass |LinearSystemPolynomialPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LinearSystemPolynomialPackage")
   (marker :initform 'package)
   (abbreviation :initform 'LSPP)
   (comment :initform (list
     "This package finds the solutions of linear systems presented as a"
     "list of polynomials."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinearSystemPolynomialPackage|
  (progn
    (push '|LinearSystemPolynomialPackage| *Packages*)
    (make-instance '|LinearSystemPolynomialPackageType|)))

\end{chunk}

\subsection{LinGroebnerPackage}
\index[pkg]{LinGroebnerPackage!Domain}
\index[pkg]{Domain!LinGroebnerPackage}
\index[pkg]{LGROBP}
\begin{chunk}{defclass LinGroebnerPackageType}
(defclass |LinGroebnerPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LinGroebnerPackage")
   (marker :initform 'package)
   (abbreviation :initform 'LGROBP)
   (comment :initform (list
     "Given a Groebner basis B with respect to the total degree ordering for"
     "a zero-dimensional ideal I, compute"
     "a Groebner basis with respect to the lexicographical ordering by using"
     "linear algebra."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinGroebnerPackage|
  (progn
    (push '|LinGroebnerPackage| *Packages*)
    (make-instance '|LinGroebnerPackageType|)))

\end{chunk}

\subsection{LinesOpPack}
\index[pkg]{LinesOpPack!Domain}
\index[pkg]{Domain!LinesOpPack}
\index[pkg]{LOP}
\begin{chunk}{defclass LinesOpPackType}
(defclass |LinesOpPackType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LinesOpPack")
   (marker :initform 'package)
   (abbreviation :initform 'LOP)
   (comment :initform (list
     "A package that exports several linear algebra operations over lines"
     "of matrices. Part of the PAFF package."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LinesOpPack|
  (progn
    (push '|LinesOpPack| *Packages*)
    (make-instance '|LinesOpPackType|)))

\end{chunk}

\subsection{LiouvillianFunction}
\index[pkg]{LiouvillianFunction!Domain}
\index[pkg]{Domain!LiouvillianFunction}
\index[pkg]{LF}
\begin{chunk}{defclass LiouvillianFunctionType}
(defclass |LiouvillianFunctionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LiouvillianFunction")
   (marker :initform 'package)
   (abbreviation :initform 'LF)
   (comment :initform (list
     "This package provides liouvillian functions over an integral domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LiouvillianFunction|
  (progn
    (push '|LiouvillianFunction| *Packages*)
    (make-instance '|LiouvillianFunctionType|)))

\end{chunk}

\subsection{ListFunctions2}
\index[pkg]{ListFunctions2!Domain}
\index[pkg]{Domain!ListFunctions2}
\index[pkg]{LIST2}
\begin{chunk}{defclass ListFunctions2Type}
(defclass |ListFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ListFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'LIST2)
   (comment :initform (list
     "ListFunctions2 implements utility functions that"
     "operate on two kinds of lists, each with a possibly different"
     "type of element."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ListFunctions2|
  (progn
    (push '|ListFunctions2| *Packages*)
    (make-instance '|ListFunctions2Type|)))

\end{chunk}

\subsection{ListFunctions3}
\index[pkg]{ListFunctions3!Domain}
\index[pkg]{Domain!ListFunctions3}
\index[pkg]{LIST3}
\begin{chunk}{defclass ListFunctions3Type}
(defclass |ListFunctions3Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ListFunctions3")
   (marker :initform 'package)
   (abbreviation :initform 'LIST3)
   (comment :initform (list
     "ListFunctions3 implements utility functions that"
     "operate on three kinds of lists, each with a possibly different"
     "type of element."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ListFunctions3|
  (progn
    (push '|ListFunctions3| *Packages*)
    (make-instance '|ListFunctions3Type|)))

\end{chunk}

\subsection{ListToMap}
\index[pkg]{ListToMap!Domain}
\index[pkg]{Domain!ListToMap}
\index[pkg]{LIST2MAP}
\begin{chunk}{defclass ListToMapType}
(defclass |ListToMapType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ListToMap")
   (marker :initform 'package)
   (abbreviation :initform 'LIST2MAP)
   (comment :initform (list
     "ListToMap allows mappings to be described by a pair of"
     "lists of equal lengths.  The image of an element x,"
     "which appears in position n in the first list, is then"
     "the nth element of the second list.  A default value or"
     "default function can be specified to be used when x"
     "does not appear in the first list.  In the absence of defaults,"
     "an error will occur in that case."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ListToMap|
  (progn
    (push '|ListToMap| *Packages*)
    (make-instance '|ListToMapType|)))

\end{chunk}

\subsection{LocalParametrizationOfSimplePointPackage}
\index[pkg]{LocalParametrizationOfSimplePointPackage!Domain}
\index[pkg]{Domain!LocalParametrizationOfSimplePointPackage}
\index[pkg]{LPARSPT}
\begin{chunk}{defclass LocalParametrizationOfSimplePointPackageType}
(defclass |LocalParametrizationOfSimplePointPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "LocalParametrizationOfSimplePointPackage")
   (marker :initform 'package)
   (abbreviation :initform 'LPARSPT)
   (comment :initform (list
     "This package is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |LocalParametrizationOfSimplePointPackage|
  (progn
    (push '|LocalParametrizationOfSimplePointPackage| *Packages*)
    (make-instance '|LocalParametrizationOfSimplePointPackageType|)))

\end{chunk}

\section{M}

\subsection{MakeBinaryCompiledFunction}
\index[pkg]{MakeBinaryCompiledFunction!Domain}
\index[pkg]{Domain!MakeBinaryCompiledFunction}
\index[pkg]{MKBCFUNC}
\begin{chunk}{defclass MakeBinaryCompiledFunctionType}
(defclass |MakeBinaryCompiledFunctionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MakeBinaryCompiledFunction")
   (marker :initform 'package)
   (abbreviation :initform 'MKBCFUNC)
   (comment :initform (list
     "Tools and transforms for making compiled functions from"
     "top-level expressions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MakeBinaryCompiledFunction|
  (progn
    (push '|MakeBinaryCompiledFunction| *Packages*)
    (make-instance '|MakeBinaryCompiledFunctionType|)))

\end{chunk}

\subsection{MakeFloatCompiledFunction}
\index[pkg]{MakeFloatCompiledFunction!Domain}
\index[pkg]{Domain!MakeFloatCompiledFunction}
\index[pkg]{MKFLCFN}
\begin{chunk}{defclass MakeFloatCompiledFunctionType}
(defclass |MakeFloatCompiledFunctionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MakeFloatCompiledFunction")
   (marker :initform 'package)
   (abbreviation :initform 'MKFLCFN)
   (comment :initform (list
     "Tools for making compiled functions from top-level expressions"
     "MakeFloatCompiledFunction transforms top-level objects into"
     "compiled Lisp functions whose arguments are Lisp floats."
     "This by-passes the Axiom compiler and interpreter,"
     "thereby gaining several orders of magnitude."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MakeFloatCompiledFunction|
  (progn
    (push '|MakeFloatCompiledFunction| *Packages*)
    (make-instance '|MakeFloatCompiledFunctionType|)))

\end{chunk}

\subsection{MakeFunction}
\index[pkg]{MakeFunction!Domain}
\index[pkg]{Domain!MakeFunction}
\index[pkg]{MKFUNC}
\begin{chunk}{defclass MakeFunctionType}
(defclass |MakeFunctionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MakeFunction")
   (marker :initform 'package)
   (abbreviation :initform 'MKFUNC)
   (comment :initform (list
     "Tools for making interpreter functions from top-level expressions"
     "Transforms top-level objects into interpreter functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MakeFunction|
  (progn
    (push '|MakeFunction| *Packages*)
    (make-instance '|MakeFunctionType|)))

\end{chunk}

\subsection{MakeRecord}
\index[pkg]{MakeRecord!Domain}
\index[pkg]{Domain!MakeRecord}
\index[pkg]{MKRECORD}
\begin{chunk}{defclass MakeRecordType}
(defclass |MakeRecordType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MakeRecord")
   (marker :initform 'package)
   (abbreviation :initform 'MKRECORD)
   (comment :initform (list
     "MakeRecord is used internally by the interpreter to create record"
     "types which are used for doing parallel iterations on streams."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MakeRecord|
  (progn
    (push '|MakeRecord| *Packages*)
    (make-instance '|MakeRecordType|)))

\end{chunk}

\subsection{MakeUnaryCompiledFunction}
\index[pkg]{MakeUnaryCompiledFunction!Domain}
\index[pkg]{Domain!MakeUnaryCompiledFunction}
\index[pkg]{MKUCFUNC}
\begin{chunk}{defclass MakeUnaryCompiledFunctionType}
(defclass |MakeUnaryCompiledFunctionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MakeUnaryCompiledFunction")
   (marker :initform 'package)
   (abbreviation :initform 'MKUCFUNC)
   (comment :initform (list
     "Tools for making compiled functions from top-level expressions"
     "Transforms top-level objects into compiled functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MakeUnaryCompiledFunction|
  (progn
    (push '|MakeUnaryCompiledFunction| *Packages*)
    (make-instance '|MakeUnaryCompiledFunctionType|)))

\end{chunk}

\subsection{MappingPackageInternalHacks1}
\index[pkg]{MappingPackageInternalHacks1!Domain}
\index[pkg]{Domain!MappingPackageInternalHacks1}
\index[pkg]{MAPHACK1}
\begin{chunk}{defclass MappingPackageInternalHacks1Type}
(defclass |MappingPackageInternalHacks1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MappingPackageInternalHacks1")
   (marker :initform 'package)
   (abbreviation :initform 'MAPHACK1)
   (comment :initform (list
     "Various Currying operations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MappingPackageInternalHacks1|
  (progn
    (push '|MappingPackageInternalHacks1| *Packages*)
    (make-instance '|MappingPackageInternalHacks1Type|)))

\end{chunk}

\subsection{MappingPackageInternalHacks2}
\index[pkg]{MappingPackageInternalHacks2!Domain}
\index[pkg]{Domain!MappingPackageInternalHacks2}
\index[pkg]{MAPHACK2}
\begin{chunk}{defclass MappingPackageInternalHacks2Type}
(defclass |MappingPackageInternalHacks2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MappingPackageInternalHacks2")
   (marker :initform 'package)
   (abbreviation :initform 'MAPHACK2)
   (comment :initform (list
     "Various Currying operations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MappingPackageInternalHacks2|
  (progn
    (push '|MappingPackageInternalHacks2| *Packages*)
    (make-instance '|MappingPackageInternalHacks2Type|)))

\end{chunk}

\subsection{MappingPackageInternalHacks3}
\index[pkg]{MappingPackageInternalHacks3!Domain}
\index[pkg]{Domain!MappingPackageInternalHacks3}
\index[pkg]{MAPHACK3}
\begin{chunk}{defclass MappingPackageInternalHacks3Type}
(defclass |MappingPackageInternalHacks3Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MappingPackageInternalHacks3")
   (marker :initform 'package)
   (abbreviation :initform 'MAPHACK3)
   (comment :initform (list
     "Various Currying operations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MappingPackageInternalHacks3|
  (progn
    (push '|MappingPackageInternalHacks3| *Packages*)
    (make-instance '|MappingPackageInternalHacks3Type|)))

\end{chunk}

\subsection{MappingPackage1}
\index[pkg]{MappingPackage1!Domain}
\index[pkg]{Domain!MappingPackage1}
\index[pkg]{MAPPKG1}
\begin{chunk}{defclass MappingPackage1Type}
(defclass |MappingPackage1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MappingPackage1")
   (marker :initform 'package)
   (abbreviation :initform 'MAPPKG1)
   (comment :initform (list
     "Various Currying operations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MappingPackage1|
  (progn
    (push '|MappingPackage1| *Packages*)
    (make-instance '|MappingPackage1Type|)))

\end{chunk}

\subsection{MappingPackage2}
\index[pkg]{MappingPackage2!Domain}
\index[pkg]{Domain!MappingPackage2}
\index[pkg]{MAPPKG2}
\begin{chunk}{defclass MappingPackage2Type}
(defclass |MappingPackage2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MappingPackage2")
   (marker :initform 'package)
   (abbreviation :initform 'MAPPKG2)
   (comment :initform (list
     "Various Currying operations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MappingPackage2|
  (progn
    (push '|MappingPackage2| *Packages*)
    (make-instance '|MappingPackage2Type|)))

\end{chunk}

\subsection{MappingPackage3}
\index[pkg]{MappingPackage3!Domain}
\index[pkg]{Domain!MappingPackage3}
\index[pkg]{MAPPKG3}
\begin{chunk}{defclass MappingPackage3Type}
(defclass |MappingPackage3Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MappingPackage3")
   (marker :initform 'package)
   (abbreviation :initform 'MAPPKG3)
   (comment :initform (list
     "Various Currying operations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MappingPackage3|
  (progn
    (push '|MappingPackage3| *Packages*)
    (make-instance '|MappingPackage3Type|)))

\end{chunk}

\subsection{MappingPackage4}
\index[pkg]{MappingPackage4!Domain}
\index[pkg]{Domain!MappingPackage4}
\index[pkg]{MAPPKG4}
\begin{chunk}{defclass MappingPackage4Type}
(defclass |MappingPackage4Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MappingPackage4")
   (marker :initform 'package)
   (abbreviation :initform 'MAPPKG4)
   (comment :initform (list
     "Functional Composition."
     "Given functions f and g, returns the applicable closure"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MappingPackage4|
  (progn
    (push '|MappingPackage4| *Packages*)
    (make-instance '|MappingPackage4Type|)))

\end{chunk}

\subsection{MatrixCategoryFunctions2}
\index[pkg]{MatrixCategoryFunctions2!Domain}
\index[pkg]{Domain!MatrixCategoryFunctions2}
\index[pkg]{MATCAT2}
\begin{chunk}{defclass MatrixCategoryFunctions2Type}
(defclass |MatrixCategoryFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MatrixCategoryFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'MATCAT2)
   (comment :initform (list
     "MatrixCategoryFunctions2 provides functions between two matrix"
     "domains.  The functions provided are map and reduce."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MatrixCategoryFunctions2|
  (progn
    (push '|MatrixCategoryFunctions2| *Packages*)
    (make-instance '|MatrixCategoryFunctions2Type|)))

\end{chunk}

\subsection{MatrixCommonDenominator}
\index[pkg]{MatrixCommonDenominator!Domain}
\index[pkg]{Domain!MatrixCommonDenominator}
\index[pkg]{MCDEN}
\begin{chunk}{defclass MatrixCommonDenominatorType}
(defclass |MatrixCommonDenominatorType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MatrixCommonDenominator")
   (marker :initform 'package)
   (abbreviation :initform 'MCDEN)
   (comment :initform (list
     "MatrixCommonDenominator provides functions to"
     "compute the common denominator of a matrix of elements of the"
     "quotient field of an integral domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MatrixCommonDenominator|
  (progn
    (push '|MatrixCommonDenominator| *Packages*)
    (make-instance '|MatrixCommonDenominatorType|)))

\end{chunk}

\subsection{MatrixLinearAlgebraFunctions}
\index[pkg]{MatrixLinearAlgebraFunctions!Domain}
\index[pkg]{Domain!MatrixLinearAlgebraFunctions}
\index[pkg]{MATLIN}
\begin{chunk}{defclass MatrixLinearAlgebraFunctionsType}
(defclass |MatrixLinearAlgebraFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MatrixLinearAlgebraFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'MATLIN)
   (comment :initform (list
     "MatrixLinearAlgebraFunctions provides functions to compute"
     "inverses and canonical forms."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MatrixLinearAlgebraFunctions|
  (progn
    (push '|MatrixLinearAlgebraFunctions| *Packages*)
    (make-instance '|MatrixLinearAlgebraFunctionsType|)))

\end{chunk}

\subsection{MatrixManipulation}
\index[pkg]{MatrixManipulation!Domain}
\index[pkg]{Domain!MatrixManipulation}
\index[pkg]{MAMA}
\begin{chunk}{defclass MatrixManipulationType}
(defclass |MatrixManipulationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MatrixManipulation")
   (marker :initform 'package)
   (abbreviation :initform 'MAMA)
   (comment :initform (list
     "Some functions for manipulating (dense) matrices."
     "Supported are various kinds of slicing, splitting and stacking of"
     "matrices. The functions resemble operations often used in numerical"
     "linear algebra algorithms."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MatrixManipulation|
  (progn
    (push '|MatrixManipulation| *Packages*)
    (make-instance '|MatrixManipulationType|)))

\end{chunk}

\subsection{MergeThing}
\index[pkg]{MergeThing!Domain}
\index[pkg]{Domain!MergeThing}
\index[pkg]{MTHING}
\begin{chunk}{defclass MergeThingType}
(defclass |MergeThingType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MergeThing")
   (marker :initform 'package)
   (abbreviation :initform 'MTHING)
   (comment :initform (list
     "This package exports tools for merging lists"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MergeThing|
  (progn
    (push '|MergeThing| *Packages*)
    (make-instance '|MergeThingType|)))

\end{chunk}

\subsection{MeshCreationRoutinesForThreeDimensions}
\index[pkg]{MeshCreationRoutinesForThreeDimensions!Domain}
\index[pkg]{Domain!MeshCreationRoutinesForThreeDimensions}
\index[pkg]{MESH}
\begin{chunk}{defclass MeshCreationRoutinesForThreeDimensionsType}
(defclass |MeshCreationRoutinesForThreeDimensionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MeshCreationRoutinesForThreeDimensions")
   (marker :initform 'package)
   (abbreviation :initform 'MESH)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MeshCreationRoutinesForThreeDimensions|
  (progn
    (push '|MeshCreationRoutinesForThreeDimensions| *Packages*)
    (make-instance '|MeshCreationRoutinesForThreeDimensionsType|)))

\end{chunk}

\subsection{ModularDistinctDegreeFactorizer}
\index[pkg]{ModularDistinctDegreeFactorizer!Domain}
\index[pkg]{Domain!ModularDistinctDegreeFactorizer}
\index[pkg]{MDDFACT}
\begin{chunk}{defclass ModularDistinctDegreeFactorizerType}
(defclass |ModularDistinctDegreeFactorizerType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ModularDistinctDegreeFactorizer")
   (marker :initform 'package)
   (abbreviation :initform 'MDDFACT)
   (comment :initform (list
     "This package supports factorization and gcds"
     "of univariate polynomials over the integers modulo different"
     "primes. The inputs are given as polynomials over the integers"
     "with the prime passed explicitly as an extra argument."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ModularDistinctDegreeFactorizer|
  (progn
    (push '|ModularDistinctDegreeFactorizer| *Packages*)
    (make-instance '|ModularDistinctDegreeFactorizerType|)))

\end{chunk}

\subsection{ModularHermitianRowReduction}
\index[pkg]{ModularHermitianRowReduction!Domain}
\index[pkg]{Domain!ModularHermitianRowReduction}
\index[pkg]{MHROWRED}
\begin{chunk}{defclass ModularHermitianRowReductionType}
(defclass |ModularHermitianRowReductionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ModularHermitianRowReduction")
   (marker :initform 'package)
   (abbreviation :initform 'MHROWRED)
   (comment :initform (list
     "Modular hermitian row reduction."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ModularHermitianRowReduction|
  (progn
    (push '|ModularHermitianRowReduction| *Packages*)
    (make-instance '|ModularHermitianRowReductionType|)))

\end{chunk}

\subsection{MonoidRingFunctions2}
\index[pkg]{MonoidRingFunctions2!Domain}
\index[pkg]{Domain!MonoidRingFunctions2}
\index[pkg]{MRF2}
\begin{chunk}{defclass MonoidRingFunctions2Type}
(defclass |MonoidRingFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MonoidRingFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'MRF2)
   (comment :initform (list
     "MonoidRingFunctions2 implements functions between"
     "two monoid rings defined with the same monoid over different rings."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MonoidRingFunctions2|
  (progn
    (push '|MonoidRingFunctions2| *Packages*)
    (make-instance '|MonoidRingFunctions2Type|)))

\end{chunk}

\subsection{MonomialExtensionTools}
\index[pkg]{MonomialExtensionTools!Domain}
\index[pkg]{Domain!MonomialExtensionTools}
\index[pkg]{MONOTOOL}
\begin{chunk}{defclass MonomialExtensionToolsType}
(defclass |MonomialExtensionToolsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MonomialExtensionTools")
   (marker :initform 'package)
   (abbreviation :initform 'MONOTOOL)
   (comment :initform (list
     "Tools for handling monomial extensions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MonomialExtensionTools|
  (progn
    (push '|MonomialExtensionTools| *Packages*)
    (make-instance '|MonomialExtensionToolsType|)))

\end{chunk}

\subsection{MoreSystemCommands}
\index[pkg]{MoreSystemCommands!Domain}
\index[pkg]{Domain!MoreSystemCommands}
\index[pkg]{MSYSCMD}
\begin{chunk}{defclass MoreSystemCommandsType}
(defclass |MoreSystemCommandsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MoreSystemCommands")
   (marker :initform 'package)
   (abbreviation :initform 'MSYSCMD)
   (comment :initform (list
     "MoreSystemCommands implements an interface with the"
     "system command facility. These are the commands that are issued"
     "from source files or the system interpreter and they start with"
     "a close parenthesis, for example, the 'what' commands."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MoreSystemCommands|
  (progn
    (push '|MoreSystemCommands| *Packages*)
    (make-instance '|MoreSystemCommandsType|)))

\end{chunk}

\subsection{MPolyCatPolyFactorizer}
\index[pkg]{MPolyCatPolyFactorizer!Domain}
\index[pkg]{Domain!MPolyCatPolyFactorizer}
\index[pkg]{MPCPF}
\begin{chunk}{defclass MPolyCatPolyFactorizerType}
(defclass |MPolyCatPolyFactorizerType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MPolyCatPolyFactorizer")
   (marker :initform 'package)
   (abbreviation :initform 'MPCPF)
   (comment :initform (list
     "This package exports a factor operation for multivariate polynomials"
     "with coefficients which are polynomials over"
     "some ring R over which we can factor. It is used internally by packages"
     "such as the solve package which need to work with polynomials in a specific"
     "set of variables with coefficients which are polynomials in all the other"
     "variables."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MPolyCatPolyFactorizer|
  (progn
    (push '|MPolyCatPolyFactorizer| *Packages*)
    (make-instance '|MPolyCatPolyFactorizerType|)))

\end{chunk}

\subsection{MPolyCatRationalFunctionFactorizer}
\index[pkg]{MPolyCatRationalFunctionFactorizer!Domain}
\index[pkg]{Domain!MPolyCatRationalFunctionFactorizer}
\index[pkg]{MPRFF}
\begin{chunk}{defclass MPolyCatRationalFunctionFactorizerType}
(defclass |MPolyCatRationalFunctionFactorizerType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MPolyCatRationalFunctionFactorizer")
   (marker :initform 'package)
   (abbreviation :initform 'MPRFF)
   (comment :initform (list
     "This package exports a factor operation for multivariate polynomials"
     "with coefficients which are rational functions over"
     "some ring R over which we can factor. It is used internally by packages"
     "such as primary decomposition which need to work with polynomials"
     "with rational function coefficients, themselves fractions of"
     "polynomials."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MPolyCatRationalFunctionFactorizer|
  (progn
    (push '|MPolyCatRationalFunctionFactorizer| *Packages*)
    (make-instance '|MPolyCatRationalFunctionFactorizerType|)))

\end{chunk}

\subsection{MPolyCatFunctions2}
\index[pkg]{MPolyCatFunctions2!Domain}
\index[pkg]{Domain!MPolyCatFunctions2}
\index[pkg]{MPC2}
\begin{chunk}{defclass MPolyCatFunctions2Type}
(defclass |MPolyCatFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MPolyCatFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'MPC2)
   (comment :initform (list
     "Utilities for MPolyCat"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MPolyCatFunctions2|
  (progn
    (push '|MPolyCatFunctions2| *Packages*)
    (make-instance '|MPolyCatFunctions2Type|)))

\end{chunk}

\subsection{MPolyCatFunctions3}
\index[pkg]{MPolyCatFunctions3!Domain}
\index[pkg]{Domain!MPolyCatFunctions3}
\index[pkg]{MPC3}
\begin{chunk}{defclass MPolyCatFunctions3Type}
(defclass |MPolyCatFunctions3Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MPolyCatFunctions3")
   (marker :initform 'package)
   (abbreviation :initform 'MPC3)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MPolyCatFunctions3|
  (progn
    (push '|MPolyCatFunctions3| *Packages*)
    (make-instance '|MPolyCatFunctions3Type|)))

\end{chunk}

\subsection{MRationalFactorize}
\index[pkg]{MRationalFactorize!Domain}
\index[pkg]{Domain!MRationalFactorize}
\index[pkg]{MRATFAC}
\begin{chunk}{defclass MRationalFactorizeType}
(defclass |MRationalFactorizeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MRationalFactorize")
   (marker :initform 'package)
   (abbreviation :initform 'MRATFAC)
   (comment :initform (list
     "MRationalFactorize contains the factor function for multivariate"
     "polynomials over the quotient field of a ring R such that the package"
     "MultivariateFactorize can factor multivariate polynomials over R."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MRationalFactorize|
  (progn
    (push '|MRationalFactorize| *Packages*)
    (make-instance '|MRationalFactorizeType|)))

\end{chunk}

\subsection{MultFiniteFactorize}
\index[pkg]{MultFiniteFactorize!Domain}
\index[pkg]{Domain!MultFiniteFactorize}
\index[pkg]{MFINFACT}
\begin{chunk}{defclass MultFiniteFactorizeType}
(defclass |MultFiniteFactorizeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MultFiniteFactorize")
   (marker :initform 'package)
   (abbreviation :initform 'MFINFACT)
   (comment :initform (list
     "Package for factorization of multivariate polynomials over finite fields."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MultFiniteFactorize|
  (progn
    (push '|MultFiniteFactorize| *Packages*)
    (make-instance '|MultFiniteFactorizeType|)))

\end{chunk}

\subsection{MultipleMap}
\index[pkg]{MultipleMap!Domain}
\index[pkg]{Domain!MultipleMap}
\index[pkg]{MMAP}
\begin{chunk}{defclass MultipleMapType}
(defclass |MultipleMapType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MultipleMap")
   (marker :initform 'package)
   (abbreviation :initform 'MMAP)
   (comment :initform (list
     "Lifting of a map through 2 levels of polynomials"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MultipleMap|
  (progn
    (push '|MultipleMap| *Packages*)
    (make-instance '|MultipleMapType|)))

\end{chunk}

\subsection{MultiVariableCalculusFunctions}
\index[pkg]{MultiVariableCalculusFunctions!Domain}
\index[pkg]{Domain!MultiVariableCalculusFunctions}
\index[pkg]{MCALCFN}
\begin{chunk}{defclass MultiVariableCalculusFunctionsType}
(defclass |MultiVariableCalculusFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MultiVariableCalculusFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'MCALCFN)
   (comment :initform (list
     "MultiVariableCalculusFunctions Package provides several"
     "functions for multivariable calculus."
     "These include gradient, hessian and jacobian, divergence and laplacian."
     "Various forms for banded and sparse storage of matrices are included."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MultiVariableCalculusFunctions|
  (progn
    (push '|MultiVariableCalculusFunctions| *Packages*)
    (make-instance '|MultiVariableCalculusFunctionsType|)))

\end{chunk}

\subsection{MultivariateFactorize}
\index[pkg]{MultivariateFactorize!Domain}
\index[pkg]{Domain!MultivariateFactorize}
\index[pkg]{MULTFACT}
\begin{chunk}{defclass MultivariateFactorizeType}
(defclass |MultivariateFactorizeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MultivariateFactorize")
   (marker :initform 'package)
   (abbreviation :initform 'MULTFACT)
   (comment :initform (list
     "This is the top level package for doing multivariate factorization"
     "over basic domains like Integer or Fraction Integer."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MultivariateFactorize|
  (progn
    (push '|MultivariateFactorize| *Packages*)
    (make-instance '|MultivariateFactorizeType|)))

\end{chunk}

\subsection{MultivariateLifting}
\index[pkg]{MultivariateLifting!Domain}
\index[pkg]{Domain!MultivariateLifting}
\index[pkg]{MLIFT}
\begin{chunk}{defclass MultivariateLiftingType}
(defclass |MultivariateLiftingType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MultivariateLifting")
   (marker :initform 'package)
   (abbreviation :initform 'MLIFT)
   (comment :initform (list
     "This package provides the functions for the multivariate 'lifting', using"
     "an algorithm of Paul Wang."
     "This package will work for every euclidean domain R which has property"
     "F, there exists a factor operation in R[x]."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MultivariateLifting|
  (progn
    (push '|MultivariateLifting| *Packages*)
    (make-instance '|MultivariateLiftingType|)))

\end{chunk}

\subsection{MultivariateSquareFree}
\index[pkg]{MultivariateSquareFree!Domain}
\index[pkg]{Domain!MultivariateSquareFree}
\index[pkg]{MULTSQFR}
\begin{chunk}{defclass MultivariateSquareFreeType}
(defclass |MultivariateSquareFreeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "MultivariateSquareFree")
   (marker :initform 'package)
   (abbreviation :initform 'MULTSQFR)
   (comment :initform (list
     "This package provides the functions for the computation of the square"
     "free decomposition of a multivariate polynomial."
     "It uses the package GenExEuclid for the resolution of"
     "the equation Af + Bg = h and its generalization to n polynomials"
     "over an integral domain and the package MultivariateLifting"
     "for the 'multivariate' lifting."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |MultivariateSquareFree|
  (progn
    (push '|MultivariateSquareFree| *Packages*)
    (make-instance '|MultivariateSquareFreeType|)))

\end{chunk}

\section{N}

\subsection{NagEigenPackage}
\index[pkg]{NagEigenPackage!Domain}
\index[pkg]{Domain!NagEigenPackage}
\index[pkg]{NAGF02}
\begin{chunk}{defclass NagEigenPackageType}
(defclass |NagEigenPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NagEigenPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NAGF02)
   (comment :initform (list
     "This package uses the NAG Library to compute"
     "     eigenvalues and eigenvectors of a matrix"
     "     eigenvalues and eigenvectors of generalized matrix"
     "eigenvalue problems"
     "     singular values and singular vectors of a matrix."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NagEigenPackage|
  (progn
    (push '|NagEigenPackage| *Packages*)
    (make-instance '|NagEigenPackageType|)))

\end{chunk}

\subsection{NagFittingPackage}
\index[pkg]{NagFittingPackage!Domain}
\index[pkg]{Domain!NagFittingPackage}
\index[pkg]{NAGE02}
\begin{chunk}{defclass NagFittingPackageType}
(defclass |NagFittingPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NagFittingPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NAGE02)
   (comment :initform (list
     "This package uses the NAG Library to find a"
     "function which approximates a set of data points. Typically the"
     "data contain random errors, as of experimental measurement, which"
     "need to be smoothed out. To seek an approximation to the data, it"
     "is first necessary to specify for the approximating function a"
     "mathematical form (a polynomial, for example) which contains a"
     "number of unspecified coefficients: the appropriate fitting"
     "routine then derives for the coefficients the values which"
     "provide the best fit of that particular form. The package deals"
     "mainly with curve and surface fitting (fitting with"
     "functions of one and of two variables) when a polynomial or a"
     "cubic spline is used as the fitting function, since these cover"
     "the most common needs. However, fitting with other functions"
     "and/or more variables can be undertaken by means of general"
     "linear or nonlinear routines (some of which are contained in"
     "other packages) depending on whether the coefficients in the"
     "function occur linearly or nonlinearly. Cases where a graph"
     "rather than a set of data points is given can be treated simply"
     "by first reading a suitable set of points from the graph."
     "The package also contains routines for evaluating,"
     "differentiating and integrating polynomial and spline curves and"
     "surfaces, once the numerical values of their coefficients have"
     "been determined."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NagFittingPackage|
  (progn
    (push '|NagFittingPackage| *Packages*)
    (make-instance '|NagFittingPackageType|)))

\end{chunk}

\subsection{NagLinearEquationSolvingPackage}
\index[pkg]{NagLinearEquationSolvingPackage!Domain}
\index[pkg]{Domain!NagLinearEquationSolvingPackage}
\index[pkg]{NAGF04}
\begin{chunk}{defclass NagLinearEquationSolvingPackageType}
(defclass |NagLinearEquationSolvingPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NagLinearEquationSolvingPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NAGF04)
   (comment :initform (list
     "This package uses the NAG Library to solve the matrix equation"
     "     AX=B, where B"
     "may be a single vector or a matrix of multiple right-hand sides."
     "The matrix A may be real, complex, symmetric, Hermitian positive-"
     "definite, or sparse. It may also be rectangular, in which case a"
     "least-squares solution is obtained."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NagLinearEquationSolvingPackage|
  (progn
    (push '|NagLinearEquationSolvingPackage| *Packages*)
    (make-instance '|NagLinearEquationSolvingPackageType|)))

\end{chunk}

\subsection{NAGLinkSupportPackage}
\index[pkg]{NAGLinkSupportPackage!Domain}
\index[pkg]{Domain!NAGLinkSupportPackage}
\index[pkg]{NAGSP}
\begin{chunk}{defclass NAGLinkSupportPackageType}
(defclass |NAGLinkSupportPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NAGLinkSupportPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NAGSP)
   (comment :initform (list
     "Support functions for the NAG Library Link functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NAGLinkSupportPackage|
  (progn
    (push '|NAGLinkSupportPackage| *Packages*)
    (make-instance '|NAGLinkSupportPackageType|)))

\end{chunk}

\subsection{NagIntegrationPackage}
\index[pkg]{NagIntegrationPackage!Domain}
\index[pkg]{Domain!NagIntegrationPackage}
\index[pkg]{NAGD01}
\begin{chunk}{defclass NagIntegrationPackageType}
(defclass |NagIntegrationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NagIntegrationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NAGD01)
   (comment :initform (list
     "This package uses the NAG Library to calculate the numerical value of"
     "definite integrals in one or more dimensions and to evaluate"
     "weights and abscissae of integration rules."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NagIntegrationPackage|
  (progn
    (push '|NagIntegrationPackage| *Packages*)
    (make-instance '|NagIntegrationPackageType|)))

\end{chunk}

\subsection{NagInterpolationPackage}
\index[pkg]{NagInterpolationPackage!Domain}
\index[pkg]{Domain!NagInterpolationPackage}
\index[pkg]{NAGE01}
\begin{chunk}{defclass NagInterpolationPackageType}
(defclass |NagInterpolationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NagInterpolationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NAGE01)
   (comment :initform (list
     "This package uses the NAG Library to calculate the interpolation of a"
     "function of one or two variables. When provided with the value of the"
     "function (and possibly one or more of its lowest-order"
     "derivatives) at each of a number of values of the variable(s),"
     "the routines provide either an interpolating function or an"
     "interpolated value. For some of the interpolating functions,"
     "there are supporting routines to evaluate, differentiate or"
     "integrate them."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NagInterpolationPackage|
  (progn
    (push '|NagInterpolationPackage| *Packages*)
    (make-instance '|NagInterpolationPackageType|)))

\end{chunk}

\subsection{NagLapack}
\index[pkg]{NagLapack!Domain}
\index[pkg]{Domain!NagLapack}
\index[pkg]{NAGF07}
\begin{chunk}{defclass NagLapackType}
(defclass |NagLapackType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NagLapack")
   (marker :initform 'package)
   (abbreviation :initform 'NAGF07)
   (comment :initform (list
     "This package uses the NAG Library to compute matrix"
     "factorizations, and to solve systems of linear equations"
     "following the matrix factorizations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NagLapack|
  (progn
    (push '|NagLapack| *Packages*)
    (make-instance '|NagLapackType|)))

\end{chunk}

\subsection{NagMatrixOperationsPackage}
\index[pkg]{NagMatrixOperationsPackage!Domain}
\index[pkg]{Domain!NagMatrixOperationsPackage}
\index[pkg]{NAGF01}
\begin{chunk}{defclass NagMatrixOperationsPackageType}
(defclass |NagMatrixOperationsPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NagMatrixOperationsPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NAGF01)
   (comment :initform (list
     "This package uses the NAG Library to provide facilities for matrix"
     "factorizations and associated transformations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NagMatrixOperationsPackage|
  (progn
    (push '|NagMatrixOperationsPackage| *Packages*)
    (make-instance '|NagMatrixOperationsPackageType|)))

\end{chunk}

\subsection{NagOptimisationPackage}
\index[pkg]{NagOptimisationPackage!Domain}
\index[pkg]{Domain!NagOptimisationPackage}
\index[pkg]{NAGE04}
\begin{chunk}{defclass NagOptimisationPackageType}
(defclass |NagOptimisationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NagOptimisationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NAGE04)
   (comment :initform (list
     "This package uses the NAG Library to perform optimization."
     "An optimization problem involves minimizing a function (called"
     "the objective function) of several variables, possibly subject to"
     "restrictions on the values of the variables defined by a set of"
     "constraint functions. The routines in the NAG Foundation Library"
     "are concerned with function minimization only, since the problem"
     "of maximizing a given function can be transformed into a"
     "minimization problem simply by multiplying the function by -1."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NagOptimisationPackage|
  (progn
    (push '|NagOptimisationPackage| *Packages*)
    (make-instance '|NagOptimisationPackageType|)))

\end{chunk}

\subsection{NagOrdinaryDifferentialEquationsPackage}
\index[pkg]{NagOrdinaryDifferentialEquationsPackage!Domain}
\index[pkg]{Domain!NagOrdinaryDifferentialEquationsPackage}
\index[pkg]{NAGD02}
\begin{chunk}{defclass NagOrdinaryDifferentialEquationsPackageType}
(defclass |NagOrdinaryDifferentialEquationsPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NagOrdinaryDifferentialEquationsPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NAGD02)
   (comment :initform (list
     "This package uses the NAG Library to calculate the numerical solution of"
     "ordinary differential equations. There are two main types of problem,"
     "those in which all boundary conditions are specified at one point"
     "(initial-value problems), and those in which the boundary"
     "conditions are distributed between two or more points (boundary-"
     "value problems and eigenvalue problems). Routines are available"
     "for initial-value problems, two-point boundary-value problems and"
     "Sturm-Liouville eigenvalue problems."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NagOrdinaryDifferentialEquationsPackage|
  (progn
    (push '|NagOrdinaryDifferentialEquationsPackage| *Packages*)
    (make-instance '|NagOrdinaryDifferentialEquationsPackageType|)))

\end{chunk}

\subsection{NagPartialDifferentialEquationsPackage}
\index[pkg]{NagPartialDifferentialEquationsPackage!Domain}
\index[pkg]{Domain!NagPartialDifferentialEquationsPackage}
\index[pkg]{NAGD03}
\begin{chunk}{defclass NagPartialDifferentialEquationsPackageType}
(defclass |NagPartialDifferentialEquationsPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NagPartialDifferentialEquationsPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NAGD03)
   (comment :initform (list
     "This package uses the NAG Library to solve partial"
     "differential equations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NagPartialDifferentialEquationsPackage|
  (progn
    (push '|NagPartialDifferentialEquationsPackage| *Packages*)
    (make-instance '|NagPartialDifferentialEquationsPackageType|)))

\end{chunk}

\subsection{NagPolynomialRootsPackage}
\index[pkg]{NagPolynomialRootsPackage!Domain}
\index[pkg]{Domain!NagPolynomialRootsPackage}
\index[pkg]{NAGC02}
\begin{chunk}{defclass NagPolynomialRootsPackageType}
(defclass |NagPolynomialRootsPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NagPolynomialRootsPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NAGC02)
   (comment :initform (list
     "This package uses the NAG Library to compute the zeros of a"
     "polynomial with real or complex coefficients."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NagPolynomialRootsPackage|
  (progn
    (push '|NagPolynomialRootsPackage| *Packages*)
    (make-instance '|NagPolynomialRootsPackageType|)))

\end{chunk}

\subsection{NagRootFindingPackage}
\index[pkg]{NagRootFindingPackage!Domain}
\index[pkg]{Domain!NagRootFindingPackage}
\index[pkg]{NAGC05}
\begin{chunk}{defclass NagRootFindingPackageType}
(defclass |NagRootFindingPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NagRootFindingPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NAGC05)
   (comment :initform (list
     "This package uses the NAG Library to calculate real zeros of"
     "continuous real functions of one or more variables. (Complex"
     "equations must be expressed in terms of the equivalent larger"
     "system of real equations.)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NagRootFindingPackage|
  (progn
    (push '|NagRootFindingPackage| *Packages*)
    (make-instance '|NagRootFindingPackageType|)))

\end{chunk}

\subsection{NagSeriesSummationPackage}
\index[pkg]{NagSeriesSummationPackage!Domain}
\index[pkg]{Domain!NagSeriesSummationPackage}
\index[pkg]{NAGC06}
\begin{chunk}{defclass NagSeriesSummationPackageType}
(defclass |NagSeriesSummationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NagSeriesSummationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NAGC06)
   (comment :initform (list
     "This package uses the NAG Library to calculate the discrete Fourier"
     "transform of a sequence of real or complex data values, and"
     "applies it to calculate convolutions and correlations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NagSeriesSummationPackage|
  (progn
    (push '|NagSeriesSummationPackage| *Packages*)
    (make-instance '|NagSeriesSummationPackageType|)))

\end{chunk}

\subsection{NagSpecialFunctionsPackage}
\index[pkg]{NagSpecialFunctionsPackage!Domain}
\index[pkg]{Domain!NagSpecialFunctionsPackage}
\index[pkg]{NAGS}
\begin{chunk}{defclass NagSpecialFunctionsPackageType}
(defclass |NagSpecialFunctionsPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NagSpecialFunctionsPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NAGS)
   (comment :initform (list
     "This package uses the NAG Library to compute some commonly"
     "occurring physical and mathematical functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NagSpecialFunctionsPackage|
  (progn
    (push '|NagSpecialFunctionsPackage| *Packages*)
    (make-instance '|NagSpecialFunctionsPackageType|)))

\end{chunk}

\subsection{NewSparseUnivariatePolynomialFunctions2}
\index[pkg]{NewSparseUnivariatePolynomialFunctions2!Domain}
\index[pkg]{Domain!NewSparseUnivariatePolynomialFunctions2}
\index[pkg]{NSUP2}
\begin{chunk}{defclass NewSparseUnivariatePolynomialFunctions2Type}
(defclass |NewSparseUnivariatePolynomialFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NewSparseUnivariatePolynomialFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'NSUP2)
   (comment :initform (list
     "This package lifts a mapping from coefficient rings R to S to"
     "a mapping from sparse univariate polynomial over R to"
     "a sparse univariate polynomial over S."
     "Note that the mapping is assumed"
     "to send zero to zero, since it will only be applied to the non-zero"
     "coefficients of the polynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NewSparseUnivariatePolynomialFunctions2|
  (progn
    (push '|NewSparseUnivariatePolynomialFunctions2| *Packages*)
    (make-instance '|NewSparseUnivariatePolynomialFunctions2Type|)))

\end{chunk}

\subsection{NewtonInterpolation}
\index[pkg]{NewtonInterpolation!Domain}
\index[pkg]{Domain!NewtonInterpolation}
\index[pkg]{NEWTON}
\begin{chunk}{defclass NewtonInterpolationType}
(defclass |NewtonInterpolationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NewtonInterpolation")
   (marker :initform 'package)
   (abbreviation :initform 'NEWTON)
   (comment :initform (list
     "This package exports Newton interpolation for the special case where the"
     "result is known to be in the original integral domain"
     "The packages defined in this file provide fast fraction free rational"
     "interpolation algorithms. (see FAMR2, FFFG, FFFGF, NEWTON)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NewtonInterpolation|
  (progn
    (push '|NewtonInterpolation| *Packages*)
    (make-instance '|NewtonInterpolationType|)))

\end{chunk}

\subsection{NewtonPolygon}
\index[pkg]{NewtonPolygon!Domain}
\index[pkg]{Domain!NewtonPolygon}
\index[pkg]{NPOLYGON}
\begin{chunk}{defclass NewtonPolygonType}
(defclass |NewtonPolygonType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NewtonPolygon")
   (marker :initform 'package)
   (abbreviation :initform 'NPOLYGON)
   (comment :initform (list
     "The following is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NewtonPolygon|
  (progn
    (push '|NewtonPolygon| *Packages*)
    (make-instance '|NewtonPolygonType|)))

\end{chunk}

\subsection{NonCommutativeOperatorDivision}
\index[pkg]{NonCommutativeOperatorDivision!Domain}
\index[pkg]{Domain!NonCommutativeOperatorDivision}
\index[pkg]{NCODIV}
\begin{chunk}{defclass NonCommutativeOperatorDivisionType}
(defclass |NonCommutativeOperatorDivisionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NonCommutativeOperatorDivision")
   (marker :initform 'package)
   (abbreviation :initform 'NCODIV)
   (comment :initform (list
     "This package provides a division and related operations for"
     "MonogenicLinearOperators over a Field."
     "Since the multiplication is in general non-commutative,"
     "these operations all have left- and right-hand versions."
     "This package provides the operations based on left-division."
     "  [q,r] = leftDivide(a,b) means a=b*q+r"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NonCommutativeOperatorDivision|
  (progn
    (push '|NonCommutativeOperatorDivision| *Packages*)
    (make-instance '|NonCommutativeOperatorDivisionType|)))

\end{chunk}

\subsection{NoneFunctions1}
\index[pkg]{NoneFunctions1!Domain}
\index[pkg]{Domain!NoneFunctions1}
\index[pkg]{NONE1}
\begin{chunk}{defclass NoneFunctions1Type}
(defclass |NoneFunctions1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NoneFunctions1")
   (marker :initform 'package)
   (abbreviation :initform 'NONE1)
   (comment :initform (list
     "NoneFunctions1 implements functions on None."
     "It particular it includes a particulary dangerous coercion from"
     "any other type to None."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NoneFunctions1|
  (progn
    (push '|NoneFunctions1| *Packages*)
    (make-instance '|NoneFunctions1Type|)))

\end{chunk}

\subsection{NonLinearFirstOrderODESolver}
\index[pkg]{NonLinearFirstOrderODESolver!Domain}
\index[pkg]{Domain!NonLinearFirstOrderODESolver}
\index[pkg]{NODE1}
\begin{chunk}{defclass NonLinearFirstOrderODESolverType}
(defclass |NonLinearFirstOrderODESolverType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NonLinearFirstOrderODESolver")
   (marker :initform 'package)
   (abbreviation :initform 'NODE1)
   (comment :initform (list
     "NonLinearFirstOrderODESolver provides a function"
     "for finding closed form first integrals of nonlinear ordinary"
     "differential equations of order 1."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NonLinearFirstOrderODESolver|
  (progn
    (push '|NonLinearFirstOrderODESolver| *Packages*)
    (make-instance '|NonLinearFirstOrderODESolverType|)))

\end{chunk}

\subsection{NonLinearSolvePackage}
\index[pkg]{NonLinearSolvePackage!Domain}
\index[pkg]{Domain!NonLinearSolvePackage}
\index[pkg]{NLINSOL}
\begin{chunk}{defclass NonLinearSolvePackageType}
(defclass |NonLinearSolvePackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NonLinearSolvePackage")
   (marker :initform 'package)
   (abbreviation :initform 'NLINSOL)
   (comment :initform (list
     "NonLinearSolvePackage is an interface to SystemSolvePackage"
     "that attempts to retract the coefficients of the equations before"
     "solving. The solutions are given in the algebraic closure of R whenever"
     "possible."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NonLinearSolvePackage|
  (progn
    (push '|NonLinearSolvePackage| *Packages*)
    (make-instance '|NonLinearSolvePackageType|)))

\end{chunk}

\subsection{NormalizationPackage}
\index[pkg]{NormalizationPackage!Domain}
\index[pkg]{Domain!NormalizationPackage}
\index[pkg]{NORMPK}
\begin{chunk}{defclass NormalizationPackageType}
(defclass |NormalizationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NormalizationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NORMPK)
   (comment :initform (list
     "A package for computing normalized assocites of univariate polynomials"
     "with coefficients in a tower of simple extensions of a field."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NormalizationPackage|
  (progn
    (push '|NormalizationPackage| *Packages*)
    (make-instance '|NormalizationPackageType|)))

\end{chunk}

\subsection{NormInMonogenicAlgebra}
\index[pkg]{NormInMonogenicAlgebra!Domain}
\index[pkg]{Domain!NormInMonogenicAlgebra}
\index[pkg]{NORMMA}
\begin{chunk}{defclass NormInMonogenicAlgebraType}
(defclass |NormInMonogenicAlgebraType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NormInMonogenicAlgebra")
   (marker :initform 'package)
   (abbreviation :initform 'NORMMA)
   (comment :initform (list
     "This package implements the norm of a polynomial with coefficients"
     "in a monogenic algebra (using resultants)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NormInMonogenicAlgebra|
  (progn
    (push '|NormInMonogenicAlgebra| *Packages*)
    (make-instance '|NormInMonogenicAlgebraType|)))

\end{chunk}

\subsection{NormRetractPackage}
\index[pkg]{NormRetractPackage!Domain}
\index[pkg]{Domain!NormRetractPackage}
\index[pkg]{NORMRETR}
\begin{chunk}{defclass NormRetractPackageType}
(defclass |NormRetractPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NormRetractPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NORMRETR)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NormRetractPackage|
  (progn
    (push '|NormRetractPackage| *Packages*)
    (make-instance '|NormRetractPackageType|)))

\end{chunk}

\subsection{NPCoef}
\index[pkg]{NPCoef!Domain}
\index[pkg]{Domain!NPCoef}
\index[pkg]{NPCOEF}
\begin{chunk}{defclass NPCoefType}
(defclass |NPCoefType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NPCoef")
   (marker :initform 'package)
   (abbreviation :initform 'NPCOEF)
   (comment :initform (list
     "Package for the determination of the coefficients in the lifting"
     "process. Used by MultivariateLifting."
     "This package will work for every euclidean domain R which has property"
     "F, there exists a factor operation in R[x]."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NPCoef|
  (progn
    (push '|NPCoef| *Packages*)
    (make-instance '|NPCoefType|)))

\end{chunk}

\subsection{NumberFieldIntegralBasis}
\index[pkg]{NumberFieldIntegralBasis!Domain}
\index[pkg]{Domain!NumberFieldIntegralBasis}
\index[pkg]{NFINTBAS}
\begin{chunk}{defclass NumberFieldIntegralBasisType}
(defclass |NumberFieldIntegralBasisType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NumberFieldIntegralBasis")
   (marker :initform 'package)
   (abbreviation :initform 'NFINTBAS)
   (comment :initform (list
     "In this package F is a framed algebra over the integers (typically"
     "F = Z[a] for some algebraic integer a).  The package provides"
     "functions to compute the integral closure of Z in the quotient"
     "quotient field of F."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NumberFieldIntegralBasis|
  (progn
    (push '|NumberFieldIntegralBasis| *Packages*)
    (make-instance '|NumberFieldIntegralBasisType|)))

\end{chunk}

\subsection{NumberFormats}
\index[pkg]{NumberFormats!Domain}
\index[pkg]{Domain!NumberFormats}
\index[pkg]{NUMFMT}
\begin{chunk}{defclass NumberFormatsType}
(defclass |NumberFormatsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NumberFormats")
   (marker :initform 'package)
   (abbreviation :initform 'NUMFMT)
   (comment :initform (list
     "NumberFormats provides function to format and read arabic and"
     "roman numbers, to convert numbers to strings and to read"
     "floating-point numbers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NumberFormats|
  (progn
    (push '|NumberFormats| *Packages*)
    (make-instance '|NumberFormatsType|)))

\end{chunk}

\subsection{NumberTheoreticPolynomialFunctions}
\index[pkg]{NumberTheoreticPolynomialFunctions!Domain}
\index[pkg]{Domain!NumberTheoreticPolynomialFunctions}
\index[pkg]{NTPOLFN}
\begin{chunk}{defclass NumberTheoreticPolynomialFunctionsType}
(defclass |NumberTheoreticPolynomialFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NumberTheoreticPolynomialFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'NTPOLFN)
   (comment :initform (list
     "This package provides polynomials as functions on a ring."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NumberTheoreticPolynomialFunctions|
  (progn
    (push '|NumberTheoreticPolynomialFunctions| *Packages*)
    (make-instance '|NumberTheoreticPolynomialFunctionsType|)))

\end{chunk}

\subsection{Numeric}
\index[pkg]{Numeric!Domain}
\index[pkg]{Domain!Numeric}
\index[pkg]{NUMERIC}
\begin{chunk}{defclass NumericType}
(defclass |NumericType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "Numeric")
   (marker :initform 'package)
   (abbreviation :initform 'NUMERIC)
   (comment :initform (list
     "Numeric provides real and complex numerical evaluation"
     "functions for various symbolic types."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Numeric|
  (progn
    (push '|Numeric| *Packages*)
    (make-instance '|NumericType|)))

\end{chunk}

\subsection{NumericalOrdinaryDifferentialEquations}
\index[pkg]{NumericalOrdinaryDifferentialEquations!Domain}
\index[pkg]{Domain!NumericalOrdinaryDifferentialEquations}
\index[pkg]{NUMODE}
\begin{chunk}{defclass NumericalOrdinaryDifferentialEquationsType}
(defclass |NumericalOrdinaryDifferentialEquationsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NumericalOrdinaryDifferentialEquations")
   (marker :initform 'package)
   (abbreviation :initform 'NUMODE)
   (comment :initform (list
     "This package is a suite of functions for the numerical integration of an"
     "ordinary differential equation of n variables:"
     "     dy/dx = f(y,x)\tab{5}y is an n-vector"
     "All the routines are based on a 4-th order Runge-Kutta kernel."
     "These routines generally have as arguments:"
     "n, the number of dependent variables"
     "x1, the initial point"
     "h, the step size"
     "y, a vector of initial conditions of length n"
     "which upon exit contains the solution at x1 + h"
     " "
     "derivs, a function which computes the right hand side of the"
     "ordinary differential equation: derivs(dydx,y,x) computes"
     "dydx, a vector which contains the derivative information."
     " "
     "In order of increasing complexity"
     "     rk4(y,n,x1,h,derivs) advances the solution vector to"
     "     {x1 + h} and return the values in y."
     " "
     "     {rk4(y,n,x1,h,derivs,t1,t2,t3,t4)} is the same as"
     "     {rk4(y,n,x1,h,derivs)} except that you must provide 4 scratch"
     "     arrays t1-t4 of size n."
     " "
     "     Starting with y at x1, rk4f(y,n,x1,x2,ns,derivs)"
     "     uses ns fixed steps of a 4-th order Runge-Kutta"
     "     integrator to advance the solution vector to x2 and return"
     "     the values in y.  Argument x2, is the final point, and"
     "     ns, the number of steps to take."
     " "
     "rk4qc(y,n,x1,step,eps,yscal,derivs) takes a 5-th order"
     "Runge-Kutta step with monitoring of local truncation to ensure"
     "accuracy and adjust stepsize."
     "The function takes two half steps and one full step and scales"
     "the difference in solutions at the final point. If the error is"
     "within eps, the step is taken and the result is returned."
     "If the error is not within eps, the stepsize if decreased"
     "and the procedure is tried again until the desired accuracy is"
     "reached. Upon input, an trial step size must be given and upon"
     "return, an estimate of the next step size to use is returned as"
     "well as the step size which produced the desired accuracy."
     "The scaled error is computed as"
     "     error = MAX(ABS((y2steps(i) - y1step(i))/yscal(i)))"
     "and this is compared against eps. If this is greater"
     "than eps, the step size is reduced accordingly to"
     "     hnew = 0.9 * hdid * (error/eps)**(-1/4)"
     "If the error criterion is satisfied, then we check if the"
     "step size was too fine and return a more efficient one. If"
     "error > \spad{eps} * (6.0E-04) then the next step size should be"
     "     hnext = 0.9 * hdid * (error/\spad{eps})**(-1/5)"
     "Otherwise hnext = 4.0 * hdid is returned."
     "A more detailed discussion of this and related topics can be"
     "found in the book 'Numerical Recipies' by W.Press, B.P. Flannery,"
     "S.A. Teukolsky, W.T. Vetterling published by Cambridge University Press."
     " "
     "Argument step is a record of 3 floating point"
     "numbers (try , did , next),"
     "eps is the required accuracy,"
     "yscal is the scaling vector for the difference in solutions."
     "On input, step.try should be the guess at a step"
     "size to achieve the accuracy."
     "On output, step.did contains the step size which achieved the"
     "accuracy and step.next is the next step size to use."
     " "
     "rk4qc(y,n,x1,step,eps,yscal,derivs,t1,t2,t3,t4,t5,t6,t7) is the"
     "same as rk4qc(y,n,x1,step,eps,yscal,derivs) except that the user"
     "must provide the 7 scratch arrays t1-t7 of size n."
     " "
     "rk4a(y,n,x1,x2,eps,h,ns,derivs)"
     "is a driver program which uses rk4qc to integrate n ordinary"
     "differential equations starting at x1 to x2, keeping the local"
     "truncation error to within eps by changing the local step size."
     "The scaling vector is defined as"
     "     yscal(i) = abs(y(i)) + abs(h*dydx(i)) + tiny"
     "where y(i) is the solution at location x, dydx is the"
     "ordinary differential equation's right hand side, h is the current"
     "step size and tiny is 10 times the"
     "smallest positive number representable."
     " "
     "The user must supply an estimate for a trial step size and"
     "the maximum number of calls to rk4qc to use."
     "Argument x2 is the final point,"
     "eps is local truncation,"
     "ns is the maximum number of call to rk4qc to use."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NumericalOrdinaryDifferentialEquations|
  (progn
    (push '|NumericalOrdinaryDifferentialEquations| *Packages*)
    (make-instance '|NumericalOrdinaryDifferentialEquationsType|)))

\end{chunk}

\subsection{NumericalQuadrature}
\index[pkg]{NumericalQuadrature!Domain}
\index[pkg]{Domain!NumericalQuadrature}
\index[pkg]{NUMQUAD}
\begin{chunk}{defclass NumericalQuadratureType}
(defclass |NumericalQuadratureType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NumericalQuadrature")
   (marker :initform 'package)
   (abbreviation :initform 'NUMQUAD)
   (comment :initform (list
     "This suite of routines performs numerical quadrature using"
     "algorithms derived from the basic trapezoidal rule. Because"
     "the error term of this rule contains only even powers of the"
     "step size (for open and closed versions), fast convergence"
     "can be obtained if the integrand is sufficiently smooth."
     " "
     "Each routine returns a Record of type TrapAns, which contains"
     "value Float: estimate of the integral"
     "error Float: estimate of the error in the computation"
     "totalpts Integer: total number of function evaluations"
     "success Boolean: if the integral was computed within the user"
     "specified error criterion"
     "To produce this estimate, each routine generates an internal"
     "sequence of sub-estimates, denoted by S(i), depending on the"
     "routine, to which the various convergence criteria are applied."
     "The user must supply a relative accuracy, eps_r, and an absolute"
     "accuracy, \spad{eps_a}. Convergence is obtained when either"
     "     ABS(S(i) - S(i-1)) < eps_r * ABS(S(i-1))"
     "     or ABS(S(i) - S(i-1)) < eps_a"
     "are true statements."
     " "
     "The routines come in three families and three flavors:"
     "closed: romberg, simpson, trapezoidal"
     "open: rombergo, simpsono, trapezoidalo"
     "adaptive closed: aromberg, asimpson, atrapezoidal"
     " "
     "The S(i) for the trapezoidal family is the value of the"
     "integral using an equally spaced absicca trapezoidal rule for"
     "that level of refinement."
     " "
     "The S(i) for the simpson family is the value of the integral"
     "using an equally spaced absicca simpson rule for that level of"
     "refinement."
     " "
     "The S(i) for the romberg family is the estimate of the integral"
     "using an equally spaced absicca romberg method. For"
     "the i-th level, this is an appropriate combination of all the"
     "previous trapezodial estimates so that the error term starts"
     "with the 2*(i+1) power only."
     " "
     "The three families come in a closed version, where the formulas"
     "include the endpoints, an open version where the formulas do not"
     "include the endpoints and an adaptive version, where the user"
     "is required to input the number of subintervals over which the"
     "appropriate closed family integrator will apply with the usual"
     "convergence parmeters for each subinterval. This is useful"
     "where a large number of points are needed only in a small fraction"
     "of the entire domain."
     " "
     "Each routine takes as arguments:"
     "f integrand"
     "a starting point"
     "b ending point"
     "eps_r relative error"
     "eps_a absolute error"
     "nmin refinement level when to start checking for convergence (> 1)"
     "nmax maximum level of refinement"
     " "
     "The adaptive routines take as an additional parameter,"
     "nint, the number of independent intervals to apply a closed"
     "family integrator of the same name."
     " "
     "Notes:"
     "Closed family level i uses 1 + 2**i points."
     "Open family level i uses 1 + 3**i points."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NumericalQuadrature|
  (progn
    (push '|NumericalQuadrature| *Packages*)
    (make-instance '|NumericalQuadratureType|)))

\end{chunk}

\subsection{NumericComplexEigenPackage}
\index[pkg]{NumericComplexEigenPackage!Domain}
\index[pkg]{Domain!NumericComplexEigenPackage}
\index[pkg]{NCEP}
\begin{chunk}{defclass NumericComplexEigenPackageType}
(defclass |NumericComplexEigenPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NumericComplexEigenPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NCEP)
   (comment :initform (list
     "This package computes explicitly eigenvalues and eigenvectors of"
     "matrices with entries over the complex rational numbers."
     "The results are expressed either as complex floating numbers or as"
     "complex rational numbers depending on the type of the precision parameter."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NumericComplexEigenPackage|
  (progn
    (push '|NumericComplexEigenPackage| *Packages*)
    (make-instance '|NumericComplexEigenPackageType|)))

\end{chunk}

\subsection{NumericContinuedFraction}
\index[pkg]{NumericContinuedFraction!Domain}
\index[pkg]{Domain!NumericContinuedFraction}
\index[pkg]{NCNTFRAC}
\begin{chunk}{defclass NumericContinuedFractionType}
(defclass |NumericContinuedFractionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NumericContinuedFraction")
   (marker :initform 'package)
   (abbreviation :initform 'NCNTFRAC)
   (comment :initform (list
     "NumericContinuedFraction provides functions"
     "for converting floating point numbers to continued fractions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NumericContinuedFraction|
  (progn
    (push '|NumericContinuedFraction| *Packages*)
    (make-instance '|NumericContinuedFractionType|)))

\end{chunk}

\subsection{NumericRealEigenPackage}
\index[pkg]{NumericRealEigenPackage!Domain}
\index[pkg]{Domain!NumericRealEigenPackage}
\index[pkg]{NREP}
\begin{chunk}{defclass NumericRealEigenPackageType}
(defclass |NumericRealEigenPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NumericRealEigenPackage")
   (marker :initform 'package)
   (abbreviation :initform 'NREP)
   (comment :initform (list
     "This package computes explicitly eigenvalues and eigenvectors of"
     "matrices with entries over the Rational Numbers."
     "The results are expressed as floating numbers or as rational numbers"
     "depending on the type of the parameter Par."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NumericRealEigenPackage|
  (progn
    (push '|NumericRealEigenPackage| *Packages*)
    (make-instance '|NumericRealEigenPackageType|)))

\end{chunk}

\subsection{NumericTubePlot}
\index[pkg]{NumericTubePlot!Domain}
\index[pkg]{Domain!NumericTubePlot}
\index[pkg]{NUMTUBE}
\begin{chunk}{defclass NumericTubePlotType}
(defclass |NumericTubePlotType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "NumericTubePlot")
   (marker :initform 'package)
   (abbreviation :initform 'NUMTUBE)
   (comment :initform (list
     "Package for constructing tubes around 3-dimensional parametric curves."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |NumericTubePlot|
  (progn
    (push '|NumericTubePlot| *Packages*)
    (make-instance '|NumericTubePlotType|)))

\end{chunk}

\section{O}

\subsection{OctonionCategoryFunctions2}
\index[pkg]{OctonionCategoryFunctions2!Domain}
\index[pkg]{Domain!OctonionCategoryFunctions2}
\index[pkg]{OCTCT2}
\begin{chunk}{defclass OctonionCategoryFunctions2Type}
(defclass |OctonionCategoryFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "OctonionCategoryFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'OCTCT2)
   (comment :initform (list
     "OctonionCategoryFunctions2 implements functions between"
     "two octonion domains defined over different rings."
     "The function map is used to coerce between octonion types."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OctonionCategoryFunctions2|
  (progn
    (push '|OctonionCategoryFunctions2| *Packages*)
    (make-instance '|OctonionCategoryFunctions2Type|)))

\end{chunk}

\subsection{ODEIntegration}
\index[pkg]{ODEIntegration!Domain}
\index[pkg]{Domain!ODEIntegration}
\index[pkg]{ODEINT}
\begin{chunk}{defclass ODEIntegrationType}
(defclass |ODEIntegrationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ODEIntegration")
   (marker :initform 'package)
   (abbreviation :initform 'ODEINT)
   (comment :initform (list
     "ODEIntegration provides an interface to the integrator."
     "This package is intended for use"
     "by the differential equations solver but not at top-level."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ODEIntegration|
  (progn
    (push '|ODEIntegration| *Packages*)
    (make-instance '|ODEIntegrationType|)))

\end{chunk}

\subsection{ODETools}
\index[pkg]{ODETools!Domain}
\index[pkg]{Domain!ODETools}
\index[pkg]{ODETOOLS}
\begin{chunk}{defclass ODEToolsType}
(defclass |ODEToolsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ODETools")
   (marker :initform 'package)
   (abbreviation :initform 'ODETOOLS)
   (comment :initform (list
     "ODETools provides tools for the linear ODE solver."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ODETools|
  (progn
    (push '|ODETools| *Packages*)
    (make-instance '|ODEToolsType|)))

\end{chunk}

\subsection{OneDimensionalArrayFunctions2}
\index[pkg]{OneDimensionalArrayFunctions2!Domain}
\index[pkg]{Domain!OneDimensionalArrayFunctions2}
\index[pkg]{ARRAY12}
\begin{chunk}{defclass OneDimensionalArrayFunctions2Type}
(defclass |OneDimensionalArrayFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "OneDimensionalArrayFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'ARRAY12)
   (comment :initform (list
     "This package provides tools for operating on one-dimensional arrays"
     "with unary and binary functions involving different underlying types"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OneDimensionalArrayFunctions2|
  (progn
    (push '|OneDimensionalArrayFunctions2| *Packages*)
    (make-instance '|OneDimensionalArrayFunctions2Type|)))

\end{chunk}

\subsection{OnePointCompletionFunctions2}
\index[pkg]{OnePointCompletionFunctions2!Domain}
\index[pkg]{Domain!OnePointCompletionFunctions2}
\index[pkg]{ONECOMP2}
\begin{chunk}{defclass OnePointCompletionFunctions2Type}
(defclass |OnePointCompletionFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "OnePointCompletionFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'ONECOMP2)
   (comment :initform (list
     "Lifting of maps to one-point completions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OnePointCompletionFunctions2|
  (progn
    (push '|OnePointCompletionFunctions2| *Packages*)
    (make-instance '|OnePointCompletionFunctions2Type|)))

\end{chunk}

\subsection{OpenMathPackage}
\index[pkg]{OpenMathPackage!Domain}
\index[pkg]{Domain!OpenMathPackage}
\index[pkg]{OMPKG}
\begin{chunk}{defclass OpenMathPackageType}
(defclass |OpenMathPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "OpenMathPackage")
   (marker :initform 'package)
   (abbreviation :initform 'OMPKG)
   (comment :initform (list
     "OpenMathPackage provides some simple utilities"
     "to make reading OpenMath objects easier."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OpenMathPackage|
  (progn
    (push '|OpenMathPackage| *Packages*)
    (make-instance '|OpenMathPackageType|)))

\end{chunk}

\subsection{OpenMathServerPackage}
\index[pkg]{OpenMathServerPackage!Domain}
\index[pkg]{Domain!OpenMathServerPackage}
\index[pkg]{OMSERVER}
\begin{chunk}{defclass OpenMathServerPackageType}
(defclass |OpenMathServerPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "OpenMathServerPackage")
   (marker :initform 'package)
   (abbreviation :initform 'OMSERVER)
   (comment :initform (list
     "OpenMathServerPackage provides the necessary"
     "operations to run AXIOM as an OpenMath server, reading/writing objects"
     "to/from a port.  Please note the facilities available here are very basic."
     "The idea is that a user calls, for example, Omserve(4000,60) and then"
     "another process sends OpenMath objects to port 4000 and reads the result."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OpenMathServerPackage|
  (progn
    (push '|OpenMathServerPackage| *Packages*)
    (make-instance '|OpenMathServerPackageType|)))

\end{chunk}

\subsection{OperationsQuery}
\index[pkg]{OperationsQuery!Domain}
\index[pkg]{Domain!OperationsQuery}
\index[pkg]{OPQUERY}
\begin{chunk}{defclass OperationsQueryType}
(defclass |OperationsQueryType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "OperationsQuery")
   (marker :initform 'package)
   (abbreviation :initform 'OPQUERY)
   (comment :initform (list
     "This package exports tools to create AXIOM Library information databases."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OperationsQuery|
  (progn
    (push '|OperationsQuery| *Packages*)
    (make-instance '|OperationsQueryType|)))

\end{chunk}

\subsection{OrderedCompletionFunctions2}
\index[pkg]{OrderedCompletionFunctions2!Domain}
\index[pkg]{Domain!OrderedCompletionFunctions2}
\index[pkg]{ORDCOMP2}
\begin{chunk}{defclass OrderedCompletionFunctions2Type}
(defclass |OrderedCompletionFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "OrderedCompletionFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'ORDCOMP2)
   (comment :initform (list
     "Lifting of maps to ordered completions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderedCompletionFunctions2|
  (progn
    (push '|OrderedCompletionFunctions2| *Packages*)
    (make-instance '|OrderedCompletionFunctions2Type|)))

\end{chunk}

\subsection{OrderingFunctions}
\index[pkg]{OrderingFunctions!Domain}
\index[pkg]{Domain!OrderingFunctions}
\index[pkg]{ORDFUNS}
\begin{chunk}{defclass OrderingFunctionsType}
(defclass |OrderingFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "OrderingFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'ORDFUNS)
   (comment :initform (list
     "This package provides ordering functions on vectors which"
     "are suitable parameters for OrderedDirectProduct."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrderingFunctions|
  (progn
    (push '|OrderingFunctions| *Packages*)
    (make-instance '|OrderingFunctionsType|)))

\end{chunk}

\subsection{OrthogonalPolynomialFunctions}
\index[pkg]{OrthogonalPolynomialFunctions!Domain}
\index[pkg]{Domain!OrthogonalPolynomialFunctions}
\index[pkg]{ORTHPOL}
\begin{chunk}{defclass OrthogonalPolynomialFunctionsType}
(defclass |OrthogonalPolynomialFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "OrthogonalPolynomialFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'ORTHPOL)
   (comment :initform (list
     "This package provides orthogonal polynomials as functions on a ring."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OrthogonalPolynomialFunctions|
  (progn
    (push '|OrthogonalPolynomialFunctions| *Packages*)
    (make-instance '|OrthogonalPolynomialFunctionsType|)))

\end{chunk}

\subsection{OutputPackage}
\index[pkg]{OutputPackage!Domain}
\index[pkg]{Domain!OutputPackage}
\index[pkg]{OUT}
\begin{chunk}{defclass OutputPackageType}
(defclass |OutputPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "OutputPackage")
   (marker :initform 'package)
   (abbreviation :initform 'OUT)
   (comment :initform (list
     "OutPackage allows pretty-printing from programs."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |OutputPackage|
  (progn
    (push '|OutputPackage| *Packages*)
    (make-instance '|OutputPackageType|)))

\end{chunk}

\section{P}

\subsection{PackageForAlgebraicFunctionField}
\index[pkg]{PackageForAlgebraicFunctionField!Domain}
\index[pkg]{Domain!PackageForAlgebraicFunctionField}
\index[pkg]{PAFF}
\begin{chunk}{defclass PackageForAlgebraicFunctionFieldType}
(defclass |PackageForAlgebraicFunctionFieldType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PackageForAlgebraicFunctionField")
   (marker :initform 'package)
   (abbreviation :initform 'PAFF)
   (comment :initform (list
     "A package that implements the Brill-Noether algorithm."
     "Part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PackageForAlgebraicFunctionField|
  (progn
    (push '|PackageForAlgebraicFunctionField| *Packages*)
    (make-instance '|PackageForAlgebraicFunctionFieldType|)))

\end{chunk}

\subsection{PackageForAlgebraicFunctionFieldOverFiniteField}
\index[pkg]{PackageForAlgebraicFunctionFieldOverFiniteField!Domain}
\index[pkg]{Domain!PackageForAlgebraicFunctionFieldOverFiniteField}
\index[pkg]{PAFFFF}
\begin{chunk}{defclass PackageForAlgebraicFunctionFieldOverFiniteFieldType}
(defclass |PackageForAlgebraicFunctionFieldOverFiniteFieldType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PackageForAlgebraicFunctionFieldOverFiniteField")
   (marker :initform 'package)
   (abbreviation :initform 'PAFFFF)
   (comment :initform (list
     "A package that implements the Brill-Noether algorithm."
     "Part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PackageForAlgebraicFunctionFieldOverFiniteField|
  (progn
    (push '|PackageForAlgebraicFunctionFieldOverFiniteField| *Packages*)
    (make-instance '|PackageForAlgebraicFunctionFieldOverFiniteFieldType|)))

\end{chunk}

\subsection{PackageForPoly}
\index[pkg]{PackageForPoly!Domain}
\index[pkg]{Domain!PackageForPoly}
\index[pkg]{PFORP}
\begin{chunk}{defclass PackageForPolyType}
(defclass |PackageForPolyType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PackageForPoly")
   (marker :initform 'package)
   (abbreviation :initform 'PFORP)
   (comment :initform (list
     "The following is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PackageForPoly|
  (progn
    (push '|PackageForPoly| *Packages*)
    (make-instance '|PackageForPolyType|)))

\end{chunk}

\subsection{PadeApproximantPackage}
\index[pkg]{PadeApproximantPackage!Domain}
\index[pkg]{Domain!PadeApproximantPackage}
\index[pkg]{PADEPAC}
\begin{chunk}{defclass PadeApproximantPackageType}
(defclass |PadeApproximantPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PadeApproximantPackage")
   (marker :initform 'package)
   (abbreviation :initform 'PADEPAC)
   (comment :initform (list
     "This package computes reliable Pad&ea. approximants using"
     "a generalized Viskovatov continued fraction algorithm."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PadeApproximantPackage|
  (progn
    (push '|PadeApproximantPackage| *Packages*)
    (make-instance '|PadeApproximantPackageType|)))

\end{chunk}

\subsection{PadeApproximants}
\index[pkg]{PadeApproximants!Domain}
\index[pkg]{Domain!PadeApproximants}
\index[pkg]{PADE}
\begin{chunk}{defclass PadeApproximantsType}
(defclass |PadeApproximantsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PadeApproximants")
   (marker :initform 'package)
   (abbreviation :initform 'PADE)
   (comment :initform (list
     "This package computes reliable Pad&ea. approximants using"
     "a generalized Viskovatov continued fraction algorithm."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PadeApproximants|
  (progn
    (push '|PadeApproximants| *Packages*)
    (make-instance '|PadeApproximantsType|)))

\end{chunk}

\subsection{PAdicWildFunctionFieldIntegralBasis}
\index[pkg]{PAdicWildFunctionFieldIntegralBasis!Domain}
\index[pkg]{Domain!PAdicWildFunctionFieldIntegralBasis}
\index[pkg]{PWFFINTB}
\begin{chunk}{defclass PAdicWildFunctionFieldIntegralBasisType}
(defclass |PAdicWildFunctionFieldIntegralBasisType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PAdicWildFunctionFieldIntegralBasis")
   (marker :initform 'package)
   (abbreviation :initform 'PWFFINTB)
   (comment :initform (list
     "In this package K is a finite field, R is a ring of univariate"
     "polynomials over K, and F is a monogenic algebra over R."
     "We require that F is monogenic, that F = K[x,y]/(f(x,y)),"
     "because the integral basis algorithm used will factor the polynomial"
     "f(x,y).  The package provides a function to compute the integral"
     "closure of R in the quotient field of F as well as a function to compute"
     "a 'local integral basis' at a specific prime."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PAdicWildFunctionFieldIntegralBasis|
  (progn
    (push '|PAdicWildFunctionFieldIntegralBasis| *Packages*)
    (make-instance '|PAdicWildFunctionFieldIntegralBasisType|)))

\end{chunk}

\subsection{ParadoxicalCombinatorsForStreams}
\index[pkg]{ParadoxicalCombinatorsForStreams!Domain}
\index[pkg]{Domain!ParadoxicalCombinatorsForStreams}
\index[pkg]{YSTREAM}
\begin{chunk}{defclass ParadoxicalCombinatorsForStreamsType}
(defclass |ParadoxicalCombinatorsForStreamsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ParadoxicalCombinatorsForStreams")
   (marker :initform 'package)
   (abbreviation :initform 'YSTREAM)
   (comment :initform (list
     "Computation of fixed points of mappings on streams"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ParadoxicalCombinatorsForStreams|
  (progn
    (push '|ParadoxicalCombinatorsForStreams| *Packages*)
    (make-instance '|ParadoxicalCombinatorsForStreamsType|)))

\end{chunk}

\subsection{ParametricLinearEquations}
\index[pkg]{ParametricLinearEquations!Domain}
\index[pkg]{Domain!ParametricLinearEquations}
\index[pkg]{PLEQN}
\begin{chunk}{defclass ParametricLinearEquationsType}
(defclass |ParametricLinearEquationsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ParametricLinearEquations")
   (marker :initform 'package)
   (abbreviation :initform 'PLEQN)
   (comment :initform (list
     "This package completely solves a parametric linear system of equations"
     "by decomposing the set of all parametric values for which the linear"
     "system is consistent into a union of quasi-algebraic  sets (which need"
     "not be irredundant, but most of the time is). Each quasi-algebraic"
     "set is described by a list of polynomials that vanish on the set, and"
     "a list of polynomials that vanish at no point of the set."
     "For each quasi-algebraic set, the solution of the linear system"
     "is given, as a particular solution and  a basis of the homogeneous"
     "system."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ParametricLinearEquations|
  (progn
    (push '|ParametricLinearEquations| *Packages*)
    (make-instance '|ParametricLinearEquationsType|)))

\end{chunk}

\subsection{ParametricPlaneCurveFunctions2}
\index[pkg]{ParametricPlaneCurveFunctions2!Domain}
\index[pkg]{Domain!ParametricPlaneCurveFunctions2}
\index[pkg]{PARPC2}
\begin{chunk}{defclass ParametricPlaneCurveFunctions2Type}
(defclass |ParametricPlaneCurveFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ParametricPlaneCurveFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'PARPC2)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ParametricPlaneCurveFunctions2|
  (progn
    (push '|ParametricPlaneCurveFunctions2| *Packages*)
    (make-instance '|ParametricPlaneCurveFunctions2Type|)))

\end{chunk}

\subsection{ParametricSpaceCurveFunctions2}
\index[pkg]{ParametricSpaceCurveFunctions2!Domain}
\index[pkg]{Domain!ParametricSpaceCurveFunctions2}
\index[pkg]{PARSC2}
\begin{chunk}{defclass ParametricSpaceCurveFunctions2Type}
(defclass |ParametricSpaceCurveFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ParametricSpaceCurveFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'PARSC2)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ParametricSpaceCurveFunctions2|
  (progn
    (push '|ParametricSpaceCurveFunctions2| *Packages*)
    (make-instance '|ParametricSpaceCurveFunctions2Type|)))

\end{chunk}

\subsection{ParametricSurfaceFunctions2}
\index[pkg]{ParametricSurfaceFunctions2!Domain}
\index[pkg]{Domain!ParametricSurfaceFunctions2}
\index[pkg]{PARSU2}
\begin{chunk}{defclass ParametricSurfaceFunctions2Type}
(defclass |ParametricSurfaceFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ParametricSurfaceFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'PARSU2)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ParametricSurfaceFunctions2|
  (progn
    (push '|ParametricSurfaceFunctions2| *Packages*)
    (make-instance '|ParametricSurfaceFunctions2Type|)))

\end{chunk}

\subsection{ParametrizationPackage}
\index[pkg]{ParametrizationPackage!Domain}
\index[pkg]{Domain!ParametrizationPackage}
\index[pkg]{PARAMP}
\begin{chunk}{defclass ParametrizationPackageType}
(defclass |ParametrizationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ParametrizationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'PARAMP)
   (comment :initform (list
     "The following is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ParametrizationPackage|
  (progn
    (push '|ParametrizationPackage| *Packages*)
    (make-instance '|ParametrizationPackageType|)))

\end{chunk}

\subsection{PartialFractionPackage}
\index[pkg]{PartialFractionPackage!Domain}
\index[pkg]{Domain!PartialFractionPackage}
\index[pkg]{PFRPAC}
\begin{chunk}{defclass PartialFractionPackageType}
(defclass |PartialFractionPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PartialFractionPackage")
   (marker :initform 'package)
   (abbreviation :initform 'PFRPAC)
   (comment :initform (list
     "The package PartialFractionPackage gives an easier"
     "to use interfact the domain PartialFraction."
     "The user gives a fraction of polynomials, and a variable and"
     "the package converts it to the proper datatype for the"
     "PartialFraction domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PartialFractionPackage|
  (progn
    (push '|PartialFractionPackage| *Packages*)
    (make-instance '|PartialFractionPackageType|)))

\end{chunk}

\subsection{PartitionsAndPermutations}
\index[pkg]{PartitionsAndPermutations!Domain}
\index[pkg]{Domain!PartitionsAndPermutations}
\index[pkg]{PARTPERM}
\begin{chunk}{defclass PartitionsAndPermutationsType}
(defclass |PartitionsAndPermutationsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PartitionsAndPermutations")
   (marker :initform 'package)
   (abbreviation :initform 'PARTPERM)
   (comment :initform (list
     "PartitionsAndPermutations contains functions for generating streams of"
     "integer partitions, and streams of sequences of integers"
     "composed from a multi-set."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PartitionsAndPermutations|
  (progn
    (push '|PartitionsAndPermutations| *Packages*)
    (make-instance '|PartitionsAndPermutationsType|)))

\end{chunk}

\subsection{PatternFunctions1}
\index[pkg]{PatternFunctions1!Domain}
\index[pkg]{Domain!PatternFunctions1}
\index[pkg]{PATTERN1}
\begin{chunk}{defclass PatternFunctions1Type}
(defclass |PatternFunctions1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PatternFunctions1")
   (marker :initform 'package)
   (abbreviation :initform 'PATTERN1)
   (comment :initform (list
     "Utilities for handling patterns"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternFunctions1|
  (progn
    (push '|PatternFunctions1| *Packages*)
    (make-instance '|PatternFunctions1Type|)))

\end{chunk}

\subsection{PatternFunctions2}
\index[pkg]{PatternFunctions2!Domain}
\index[pkg]{Domain!PatternFunctions2}
\index[pkg]{PATTERN2}
\begin{chunk}{defclass PatternFunctions2Type}
(defclass |PatternFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PatternFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'PATTERN2)
   (comment :initform (list
     "Lifts maps to patterns"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternFunctions2|
  (progn
    (push '|PatternFunctions2| *Packages*)
    (make-instance '|PatternFunctions2Type|)))

\end{chunk}

\subsection{PatternMatch}
\index[pkg]{PatternMatch!Domain}
\index[pkg]{Domain!PatternMatch}
\index[pkg]{PATMATCH}
\begin{chunk}{defclass PatternMatchType}
(defclass |PatternMatchType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PatternMatch")
   (marker :initform 'package)
   (abbreviation :initform 'PATMATCH)
   (comment :initform (list
     "This package provides the top-level pattern macthing functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatch|
  (progn
    (push '|PatternMatch| *Packages*)
    (make-instance '|PatternMatchType|)))

\end{chunk}

\subsection{PatternMatchAssertions}
\index[pkg]{PatternMatchAssertions!Domain}
\index[pkg]{Domain!PatternMatchAssertions}
\index[pkg]{PMASS}
\begin{chunk}{defclass PatternMatchAssertionsType}
(defclass |PatternMatchAssertionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PatternMatchAssertions")
   (marker :initform 'package)
   (abbreviation :initform 'PMASS)
   (comment :initform (list
     "Attaching assertions to symbols for pattern matching;"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatchAssertions|
  (progn
    (push '|PatternMatchAssertions| *Packages*)
    (make-instance '|PatternMatchAssertionsType|)))

\end{chunk}

\subsection{PatternMatchFunctionSpace}
\index[pkg]{PatternMatchFunctionSpace!Domain}
\index[pkg]{Domain!PatternMatchFunctionSpace}
\index[pkg]{PMFS}
\begin{chunk}{defclass PatternMatchFunctionSpaceType}
(defclass |PatternMatchFunctionSpaceType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PatternMatchFunctionSpace")
   (marker :initform 'package)
   (abbreviation :initform 'PMFS)
   (comment :initform (list
     "This package provides pattern matching functions on function spaces."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatchFunctionSpace|
  (progn
    (push '|PatternMatchFunctionSpace| *Packages*)
    (make-instance '|PatternMatchFunctionSpaceType|)))

\end{chunk}

\subsection{PatternMatchIntegerNumberSystem}
\index[pkg]{PatternMatchIntegerNumberSystem!Domain}
\index[pkg]{Domain!PatternMatchIntegerNumberSystem}
\index[pkg]{PMINS}
\begin{chunk}{defclass PatternMatchIntegerNumberSystemType}
(defclass |PatternMatchIntegerNumberSystemType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PatternMatchIntegerNumberSystem")
   (marker :initform 'package)
   (abbreviation :initform 'PMINS)
   (comment :initform (list
     "This package provides pattern matching functions on integers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatchIntegerNumberSystem|
  (progn
    (push '|PatternMatchIntegerNumberSystem| *Packages*)
    (make-instance '|PatternMatchIntegerNumberSystemType|)))

\end{chunk}

\subsection{PatternMatchIntegration}
\index[pkg]{PatternMatchIntegration!Domain}
\index[pkg]{Domain!PatternMatchIntegration}
\index[pkg]{INTPM}
\begin{chunk}{defclass PatternMatchIntegrationType}
(defclass |PatternMatchIntegrationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PatternMatchIntegration")
   (marker :initform 'package)
   (abbreviation :initform 'INTPM)
   (comment :initform (list
     "PatternMatchIntegration provides functions that use"
     "the pattern matcher to find some indefinite and definite integrals"
     "involving special functions and found in the litterature."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatchIntegration|
  (progn
    (push '|PatternMatchIntegration| *Packages*)
    (make-instance '|PatternMatchIntegrationType|)))

\end{chunk}

\subsection{PatternMatchKernel}
\index[pkg]{PatternMatchKernel!Domain}
\index[pkg]{Domain!PatternMatchKernel}
\index[pkg]{PMKERNEL}
\begin{chunk}{defclass PatternMatchKernelType}
(defclass |PatternMatchKernelType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PatternMatchKernel")
   (marker :initform 'package)
   (abbreviation :initform 'PMKERNEL)
   (comment :initform (list
     "This package provides pattern matching functions on kernels."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatchKernel|
  (progn
    (push '|PatternMatchKernel| *Packages*)
    (make-instance '|PatternMatchKernelType|)))

\end{chunk}

\subsection{PatternMatchListAggregate}
\index[pkg]{PatternMatchListAggregate!Domain}
\index[pkg]{Domain!PatternMatchListAggregate}
\index[pkg]{PMLSAGG}
\begin{chunk}{defclass PatternMatchListAggregateType}
(defclass |PatternMatchListAggregateType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PatternMatchListAggregate")
   (marker :initform 'package)
   (abbreviation :initform 'PMLSAGG)
   (comment :initform (list
     "This package provides pattern matching functions on lists."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatchListAggregate|
  (progn
    (push '|PatternMatchListAggregate| *Packages*)
    (make-instance '|PatternMatchListAggregateType|)))

\end{chunk}

\subsection{PatternMatchPolynomialCategory}
\index[pkg]{PatternMatchPolynomialCategory!Domain}
\index[pkg]{Domain!PatternMatchPolynomialCategory}
\index[pkg]{PMPLCAT}
\begin{chunk}{defclass PatternMatchPolynomialCategoryType}
(defclass |PatternMatchPolynomialCategoryType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PatternMatchPolynomialCategory")
   (marker :initform 'package)
   (abbreviation :initform 'PMPLCAT)
   (comment :initform (list
     "This package provides pattern matching functions on polynomials."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatchPolynomialCategory|
  (progn
    (push '|PatternMatchPolynomialCategory| *Packages*)
    (make-instance '|PatternMatchPolynomialCategoryType|)))

\end{chunk}

\subsection{PatternMatchPushDown}
\index[pkg]{PatternMatchPushDown!Domain}
\index[pkg]{Domain!PatternMatchPushDown}
\index[pkg]{PMDOWN}
\begin{chunk}{defclass PatternMatchPushDownType}
(defclass |PatternMatchPushDownType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PatternMatchPushDown")
   (marker :initform 'package)
   (abbreviation :initform 'PMDOWN)
   (comment :initform (list
     "This packages provides tools for matching recursively in type towers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatchPushDown|
  (progn
    (push '|PatternMatchPushDown| *Packages*)
    (make-instance '|PatternMatchPushDownType|)))

\end{chunk}

\subsection{PatternMatchQuotientFieldCategory}
\index[pkg]{PatternMatchQuotientFieldCategory!Domain}
\index[pkg]{Domain!PatternMatchQuotientFieldCategory}
\index[pkg]{PMQFCAT}
\begin{chunk}{defclass PatternMatchQuotientFieldCategoryType}
(defclass |PatternMatchQuotientFieldCategoryType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PatternMatchQuotientFieldCategory")
   (marker :initform 'package)
   (abbreviation :initform 'PMQFCAT)
   (comment :initform (list
     "This package provides pattern matching functions on quotients."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatchQuotientFieldCategory|
  (progn
    (push '|PatternMatchQuotientFieldCategory| *Packages*)
    (make-instance '|PatternMatchQuotientFieldCategoryType|)))

\end{chunk}

\subsection{PatternMatchResultFunctions2}
\index[pkg]{PatternMatchResultFunctions2!Domain}
\index[pkg]{Domain!PatternMatchResultFunctions2}
\index[pkg]{PATRES2}
\begin{chunk}{defclass PatternMatchResultFunctions2Type}
(defclass |PatternMatchResultFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PatternMatchResultFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'PATRES2)
   (comment :initform (list
     "Lifts maps to pattern matching results."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatchResultFunctions2|
  (progn
    (push '|PatternMatchResultFunctions2| *Packages*)
    (make-instance '|PatternMatchResultFunctions2Type|)))

\end{chunk}

\subsection{PatternMatchSymbol}
\index[pkg]{PatternMatchSymbol!Domain}
\index[pkg]{Domain!PatternMatchSymbol}
\index[pkg]{PMSYM}
\begin{chunk}{defclass PatternMatchSymbolType}
(defclass |PatternMatchSymbolType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PatternMatchSymbol")
   (marker :initform 'package)
   (abbreviation :initform 'PMSYM)
   (comment :initform (list
     "This package provides pattern matching functions on symbols."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatchSymbol|
  (progn
    (push '|PatternMatchSymbol| *Packages*)
    (make-instance '|PatternMatchSymbolType|)))

\end{chunk}

\subsection{PatternMatchTools}
\index[pkg]{PatternMatchTools!Domain}
\index[pkg]{Domain!PatternMatchTools}
\index[pkg]{PMTOOLS}
\begin{chunk}{defclass PatternMatchToolsType}
(defclass |PatternMatchToolsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PatternMatchTools")
   (marker :initform 'package)
   (abbreviation :initform 'PMTOOLS)
   (comment :initform (list
     "This package provides tools for the pattern matcher."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PatternMatchTools|
  (progn
    (push '|PatternMatchTools| *Packages*)
    (make-instance '|PatternMatchToolsType|)))

\end{chunk}

\subsection{Permanent}
\index[pkg]{Permanent!Domain}
\index[pkg]{Domain!Permanent}
\index[pkg]{PERMAN}
\begin{chunk}{defclass PermanentType}
(defclass |PermanentType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "Permanent")
   (marker :initform 'package)
   (abbreviation :initform 'PERMAN)
   (comment :initform (list
     "Permanent implements the functions permanent, the"
     "permanent for square matrices."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |Permanent|
  (progn
    (push '|Permanent| *Packages*)
    (make-instance '|PermanentType|)))

\end{chunk}

\subsection{PermutationGroupExamples}
\index[pkg]{PermutationGroupExamples!Domain}
\index[pkg]{Domain!PermutationGroupExamples}
\index[pkg]{PGE}
\begin{chunk}{defclass PermutationGroupExamplesType}
(defclass |PermutationGroupExamplesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PermutationGroupExamples")
   (marker :initform 'package)
   (abbreviation :initform 'PGE)
   (comment :initform (list
     "PermutationGroupExamples provides permutation groups for"
     "some classes of groups: symmetric, alternating, dihedral, cyclic,"
     "direct products of cyclic, which are in fact the finite abelian groups"
     "of symmetric groups called Young subgroups."
     "Furthermore, Rubik's group as permutation group of 48 integers and a list"
     "of sporadic simple groups derived from the atlas of finite groups."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PermutationGroupExamples|
  (progn
    (push '|PermutationGroupExamples| *Packages*)
    (make-instance '|PermutationGroupExamplesType|)))

\end{chunk}

\subsection{PiCoercions}
\index[pkg]{PiCoercions!Domain}
\index[pkg]{Domain!PiCoercions}
\index[pkg]{PICOERCE}
\begin{chunk}{defclass PiCoercionsType}
(defclass |PiCoercionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PiCoercions")
   (marker :initform 'package)
   (abbreviation :initform 'PICOERCE)
   (comment :initform (list
     "Provides a coercion from the symbolic fractions in %pi with"
     "integer coefficients to any Expression type."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PiCoercions|
  (progn
    (push '|PiCoercions| *Packages*)
    (make-instance '|PiCoercionsType|)))

\end{chunk}

\subsection{PlotFunctions1}
\index[pkg]{PlotFunctions1!Domain}
\index[pkg]{Domain!PlotFunctions1}
\index[pkg]{PLOT1}
\begin{chunk}{defclass PlotFunctions1Type}
(defclass |PlotFunctions1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PlotFunctions1")
   (marker :initform 'package)
   (abbreviation :initform 'PLOT1)
   (comment :initform (list
     "PlotFunctions1 provides facilities for plotting curves"
     "where functions SF -> SF are specified by giving an expression"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PlotFunctions1|
  (progn
    (push '|PlotFunctions1| *Packages*)
    (make-instance '|PlotFunctions1Type|)))

\end{chunk}

\subsection{PlotTools}
\index[pkg]{PlotTools!Domain}
\index[pkg]{Domain!PlotTools}
\index[pkg]{PLOTTOOL}
\begin{chunk}{defclass PlotToolsType}
(defclass |PlotToolsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PlotTools")
   (marker :initform 'package)
   (abbreviation :initform 'PLOTTOOL)
   (comment :initform (list
     "This package exports plotting tools"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PlotTools|
  (progn
    (push '|PlotTools| *Packages*)
    (make-instance '|PlotToolsType|)))

\end{chunk}

\subsection{ProjectiveAlgebraicSetPackage}
\index[pkg]{ProjectiveAlgebraicSetPackage!Domain}
\index[pkg]{Domain!ProjectiveAlgebraicSetPackage}
\index[pkg]{PRJALGPK}
\begin{chunk}{defclass ProjectiveAlgebraicSetPackageType}
(defclass |ProjectiveAlgebraicSetPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ProjectiveAlgebraicSetPackage")
   (marker :initform 'package)
   (abbreviation :initform 'PRJALGPK)
   (comment :initform (list
     "The following is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ProjectiveAlgebraicSetPackage|
  (progn
    (push '|ProjectiveAlgebraicSetPackage| *Packages*)
    (make-instance '|ProjectiveAlgebraicSetPackageType|)))

\end{chunk}

\subsection{PointFunctions2}
\index[pkg]{PointFunctions2!Domain}
\index[pkg]{Domain!PointFunctions2}
\index[pkg]{PTFUNC2}
\begin{chunk}{defclass PointFunctions2Type}
(defclass |PointFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PointFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'PTFUNC2)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PointFunctions2|
  (progn
    (push '|PointFunctions2| *Packages*)
    (make-instance '|PointFunctions2Type|)))

\end{chunk}

\subsection{PointPackage}
\index[pkg]{PointPackage!Domain}
\index[pkg]{Domain!PointPackage}
\index[pkg]{PTPACK}
\begin{chunk}{defclass PointPackageType}
(defclass |PointPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PointPackage")
   (marker :initform 'package)
   (abbreviation :initform 'PTPACK)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PointPackage|
  (progn
    (push '|PointPackage| *Packages*)
    (make-instance '|PointPackageType|)))

\end{chunk}

\subsection{PointsOfFiniteOrder}
\index[pkg]{PointsOfFiniteOrder!Domain}
\index[pkg]{Domain!PointsOfFiniteOrder}
\index[pkg]{PFO}
\begin{chunk}{defclass PointsOfFiniteOrderType}
(defclass |PointsOfFiniteOrderType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PointsOfFiniteOrder")
   (marker :initform 'package)
   (abbreviation :initform 'PFO)
   (comment :initform (list
     "This package provides function for testing whether a divisor on a"
     "curve is a torsion divisor."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PointsOfFiniteOrder|
  (progn
    (push '|PointsOfFiniteOrder| *Packages*)
    (make-instance '|PointsOfFiniteOrderType|)))

\end{chunk}

\subsection{PointsOfFiniteOrderRational}
\index[pkg]{PointsOfFiniteOrderRational!Domain}
\index[pkg]{Domain!PointsOfFiniteOrderRational}
\index[pkg]{PFOQ}
\begin{chunk}{defclass PointsOfFiniteOrderRationalType}
(defclass |PointsOfFiniteOrderRationalType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PointsOfFiniteOrderRational")
   (marker :initform 'package)
   (abbreviation :initform 'PFOQ)
   (comment :initform (list
     "This package provides function for testing whether a divisor on a"
     "curve is a torsion divisor."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PointsOfFiniteOrderRational|
  (progn
    (push '|PointsOfFiniteOrderRational| *Packages*)
    (make-instance '|PointsOfFiniteOrderRationalType|)))

\end{chunk}

\subsection{PointsOfFiniteOrderTools}
\index[pkg]{PointsOfFiniteOrderTools!Domain}
\index[pkg]{Domain!PointsOfFiniteOrderTools}
\index[pkg]{PFOTOOLS}
\begin{chunk}{defclass PointsOfFiniteOrderToolsType}
(defclass |PointsOfFiniteOrderToolsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PointsOfFiniteOrderTools")
   (marker :initform 'package)
   (abbreviation :initform 'PFOTOOLS)
   (comment :initform (list
     "Utilities for PFOQ and PFO"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PointsOfFiniteOrderTools|
  (progn
    (push '|PointsOfFiniteOrderTools| *Packages*)
    (make-instance '|PointsOfFiniteOrderToolsType|)))

\end{chunk}

\subsection{PolynomialPackageForCurve}
\index[pkg]{PolynomialPackageForCurve!Domain}
\index[pkg]{Domain!PolynomialPackageForCurve}
\index[pkg]{PLPKCRV}
\begin{chunk}{defclass PolynomialPackageForCurveType}
(defclass |PolynomialPackageForCurveType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialPackageForCurve")
   (marker :initform 'package)
   (abbreviation :initform 'PLPKCRV)
   (comment :initform (list
     "The following is part of the PAFF package"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialPackageForCurve|
  (progn
    (push '|PolynomialPackageForCurve| *Packages*)
    (make-instance '|PolynomialPackageForCurveType|)))

\end{chunk}

\subsection{PolToPol}
\index[pkg]{PolToPol!Domain}
\index[pkg]{Domain!PolToPol}
\index[pkg]{POLTOPOL}
\begin{chunk}{defclass PolToPolType}
(defclass |PolToPolType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolToPol")
   (marker :initform 'package)
   (abbreviation :initform 'POLTOPOL)
   (comment :initform (list
     "Package with the conversion functions among different kind of polynomials"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolToPol|
  (progn
    (push '|PolToPol| *Packages*)
    (make-instance '|PolToPolType|)))

\end{chunk}

\subsection{PolyGroebner}
\index[pkg]{PolyGroebner!Domain}
\index[pkg]{Domain!PolyGroebner}
\index[pkg]{PGROEB}
\begin{chunk}{defclass PolyGroebnerType}
(defclass |PolyGroebnerType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolyGroebner")
   (marker :initform 'package)
   (abbreviation :initform 'PGROEB)
   (comment :initform (list
     "Groebner functions for P F"
     "This package is an interface package to the groebner basis"
     "package which allows you to compute groebner bases for polynomials"
     "in either lexicographic ordering or total degree ordering refined"
     "by reverse lex. The input is the ordinary polynomial type which"
     "is internally converted to a type with the required ordering."
     "The resulting grobner basis is converted back to ordinary polynomials."
     "The ordering among the variables is controlled by an explicit list"
     "of variables which is passed as a second argument. The coefficient"
     "domain is allowed to be any gcd domain, but the groebner basis is"
     "computed as if the polynomials were over a field."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolyGroebner|
  (progn
    (push '|PolyGroebner| *Packages*)
    (make-instance '|PolyGroebnerType|)))

\end{chunk}

\subsection{PolynomialAN2Expression}
\index[pkg]{PolynomialAN2Expression!Domain}
\index[pkg]{Domain!PolynomialAN2Expression}
\index[pkg]{PAN2EXPR}
\begin{chunk}{defclass PolynomialAN2ExpressionType}
(defclass |PolynomialAN2ExpressionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialAN2Expression")
   (marker :initform 'package)
   (abbreviation :initform 'PAN2EXPR)
   (comment :initform (list
     "This package provides a coerce from polynomials over"
     "algebraic numbers to Expression AlgebraicNumber."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialAN2Expression|
  (progn
    (push '|PolynomialAN2Expression| *Packages*)
    (make-instance '|PolynomialAN2ExpressionType|)))

\end{chunk}

\subsection{PolynomialCategoryLifting}
\index[pkg]{PolynomialCategoryLifting!Domain}
\index[pkg]{Domain!PolynomialCategoryLifting}
\index[pkg]{POLYLIFT}
\begin{chunk}{defclass PolynomialCategoryLiftingType}
(defclass |PolynomialCategoryLiftingType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialCategoryLifting")
   (marker :initform 'package)
   (abbreviation :initform 'POLYLIFT)
   (comment :initform (list
     "This package provides a very general map function, which"
     "given a set S and polynomials over R with maps from the"
     "variables into S and the coefficients into S, maps polynomials"
     "into S. S is assumed to support +, * and **."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialCategoryLifting|
  (progn
    (push '|PolynomialCategoryLifting| *Packages*)
    (make-instance '|PolynomialCategoryLiftingType|)))

\end{chunk}

\subsection{PolynomialCategoryQuotientFunctions}
\index[pkg]{PolynomialCategoryQuotientFunctions!Domain}
\index[pkg]{Domain!PolynomialCategoryQuotientFunctions}
\index[pkg]{POLYCATQ}
\begin{chunk}{defclass PolynomialCategoryQuotientFunctionsType}
(defclass |PolynomialCategoryQuotientFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialCategoryQuotientFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'POLYCATQ)
   (comment :initform (list
     "Manipulations on polynomial quotients"
     "This package transforms multivariate polynomials or fractions into"
     "univariate polynomials or fractions, and back."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialCategoryQuotientFunctions|
  (progn
    (push '|PolynomialCategoryQuotientFunctions| *Packages*)
    (make-instance '|PolynomialCategoryQuotientFunctionsType|)))

\end{chunk}

\subsection{PolynomialComposition}
\index[pkg]{PolynomialComposition!Domain}
\index[pkg]{Domain!PolynomialComposition}
\index[pkg]{PCOMP}
\begin{chunk}{defclass PolynomialCompositionType}
(defclass |PolynomialCompositionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialComposition")
   (marker :initform 'package)
   (abbreviation :initform 'PCOMP)
   (comment :initform (list
     "Polynomial composition and decomposition functions"
     "If f = g o h then g=leftFactor(f,h) and h=rightFactor(f,g)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialComposition|
  (progn
    (push '|PolynomialComposition| *Packages*)
    (make-instance '|PolynomialCompositionType|)))

\end{chunk}

\subsection{PolynomialDecomposition}
\index[pkg]{PolynomialDecomposition!Domain}
\index[pkg]{Domain!PolynomialDecomposition}
\index[pkg]{PDECOMP}
\begin{chunk}{defclass PolynomialDecompositionType}
(defclass |PolynomialDecompositionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialDecomposition")
   (marker :initform 'package)
   (abbreviation :initform 'PDECOMP)
   (comment :initform (list
     "Polynomial composition and decomposition functions"
     "If f = g o h then g=leftFactor(f,h) and h=rightFactor(f,g)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialDecomposition|
  (progn
    (push '|PolynomialDecomposition| *Packages*)
    (make-instance '|PolynomialDecompositionType|)))

\end{chunk}

\subsection{PolynomialFactorizationByRecursion}
\index[pkg]{PolynomialFactorizationByRecursion!Domain}
\index[pkg]{Domain!PolynomialFactorizationByRecursion}
\index[pkg]{PFBR}
\begin{chunk}{defclass PolynomialFactorizationByRecursionType}
(defclass |PolynomialFactorizationByRecursionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialFactorizationByRecursion")
   (marker :initform 'package)
   (abbreviation :initform 'PFBR)
   (comment :initform (list
     "PolynomialFactorizationByRecursion(R,E,VarSet,S)"
     "is used for factorization of sparse univariate polynomials over"
     "a domain S of multivariate polynomials over R."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialFactorizationByRecursion|
  (progn
    (push '|PolynomialFactorizationByRecursion| *Packages*)
    (make-instance '|PolynomialFactorizationByRecursionType|)))

\end{chunk}

\subsection{PolynomialFactorizationByRecursionUnivariate}
\index[pkg]{PolynomialFactorizationByRecursionUnivariate!Domain}
\index[pkg]{Domain!PolynomialFactorizationByRecursionUnivariate}
\index[pkg]{PFBRU}
\begin{chunk}{defclass PolynomialFactorizationByRecursionUnivariateType}
(defclass |PolynomialFactorizationByRecursionUnivariateType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialFactorizationByRecursionUnivariate")
   (marker :initform 'package)
   (abbreviation :initform 'PFBRU)
   (comment :initform (list
     "PolynomialFactorizationByRecursionUnivariate"
     "R is a PolynomialFactorizationExplicit domain,"
     "S is univariate polynomials over R"
     "We are interested in handling SparseUnivariatePolynomials over"
     "S, is a variable we shall call z"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialFactorizationByRecursionUnivariate|
  (progn
    (push '|PolynomialFactorizationByRecursionUnivariate| *Packages*)
    (make-instance '|PolynomialFactorizationByRecursionUnivariateType|)))

\end{chunk}

\subsection{PolynomialFunctions2}
\index[pkg]{PolynomialFunctions2!Domain}
\index[pkg]{Domain!PolynomialFunctions2}
\index[pkg]{POLY2}
\begin{chunk}{defclass PolynomialFunctions2Type}
(defclass |PolynomialFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'POLY2)
   (comment :initform (list
     "This package takes a mapping between coefficient rings, and lifts"
     "it to a mapping between polynomials over those rings."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialFunctions2|
  (progn
    (push '|PolynomialFunctions2| *Packages*)
    (make-instance '|PolynomialFunctions2Type|)))

\end{chunk}

\subsection{PolynomialGcdPackage}
\index[pkg]{PolynomialGcdPackage!Domain}
\index[pkg]{Domain!PolynomialGcdPackage}
\index[pkg]{PGCD}
\begin{chunk}{defclass PolynomialGcdPackageType}
(defclass |PolynomialGcdPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialGcdPackage")
   (marker :initform 'package)
   (abbreviation :initform 'PGCD)
   (comment :initform (list
     "This package computes multivariate polynomial gcd's using"
     "a hensel lifting strategy. The constraint on the coefficient"
     "domain is imposed by the lifting strategy. It is assumed that"
     "the coefficient domain has the property that almost all specializations"
     "preserve the degree of the gcd."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialGcdPackage|
  (progn
    (push '|PolynomialGcdPackage| *Packages*)
    (make-instance '|PolynomialGcdPackageType|)))

\end{chunk}

\subsection{PolynomialInterpolation}
\index[pkg]{PolynomialInterpolation!Domain}
\index[pkg]{Domain!PolynomialInterpolation}
\index[pkg]{PINTERP}
\begin{chunk}{defclass PolynomialInterpolationType}
(defclass |PolynomialInterpolationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialInterpolation")
   (marker :initform 'package)
   (abbreviation :initform 'PINTERP)
   (comment :initform (list
     "This package exports interpolation algorithms"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialInterpolation|
  (progn
    (push '|PolynomialInterpolation| *Packages*)
    (make-instance '|PolynomialInterpolationType|)))

\end{chunk}

\subsection{PolynomialInterpolationAlgorithms}
\index[pkg]{PolynomialInterpolationAlgorithms!Domain}
\index[pkg]{Domain!PolynomialInterpolationAlgorithms}
\index[pkg]{PINTERPA}
\begin{chunk}{defclass PolynomialInterpolationAlgorithmsType}
(defclass |PolynomialInterpolationAlgorithmsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialInterpolationAlgorithms")
   (marker :initform 'package)
   (abbreviation :initform 'PINTERPA)
   (comment :initform (list
     "This package exports interpolation algorithms"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialInterpolationAlgorithms|
  (progn
    (push '|PolynomialInterpolationAlgorithms| *Packages*)
    (make-instance '|PolynomialInterpolationAlgorithmsType|)))

\end{chunk}

\subsection{PolynomialNumberTheoryFunctions}
\index[pkg]{PolynomialNumberTheoryFunctions!Domain}
\index[pkg]{Domain!PolynomialNumberTheoryFunctions}
\index[pkg]{PNTHEORY}
\begin{chunk}{defclass PolynomialNumberTheoryFunctionsType}
(defclass |PolynomialNumberTheoryFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialNumberTheoryFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'PNTHEORY)
   (comment :initform (list
     "This package provides various polynomial number theoretic functions"
     "over the integers."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialNumberTheoryFunctions|
  (progn
    (push '|PolynomialNumberTheoryFunctions| *Packages*)
    (make-instance '|PolynomialNumberTheoryFunctionsType|)))

\end{chunk}

\subsection{PolynomialRoots}
\index[pkg]{PolynomialRoots!Domain}
\index[pkg]{Domain!PolynomialRoots}
\index[pkg]{POLYROOT}
\begin{chunk}{defclass PolynomialRootsType}
(defclass |PolynomialRootsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialRoots")
   (marker :initform 'package)
   (abbreviation :initform 'POLYROOT)
   (comment :initform (list
     "Computes n-th roots of quotients of multivariate polynomials"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialRoots|
  (progn
    (push '|PolynomialRoots| *Packages*)
    (make-instance '|PolynomialRootsType|)))

\end{chunk}

\subsection{PolynomialSetUtilitiesPackage}
\index[pkg]{PolynomialSetUtilitiesPackage!Domain}
\index[pkg]{Domain!PolynomialSetUtilitiesPackage}
\index[pkg]{PSETPK}
\begin{chunk}{defclass PolynomialSetUtilitiesPackageType}
(defclass |PolynomialSetUtilitiesPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialSetUtilitiesPackage")
   (marker :initform 'package)
   (abbreviation :initform 'PSETPK)
   (comment :initform (list
     "This package provides modest routines for polynomial system solving."
     "The aim of many of the operations of this package is to remove certain"
     "factors in some polynomials in order to avoid unnecessary computations"
     "in algorithms involving splitting techniques by partial factorization."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialSetUtilitiesPackage|
  (progn
    (push '|PolynomialSetUtilitiesPackage| *Packages*)
    (make-instance '|PolynomialSetUtilitiesPackageType|)))

\end{chunk}

\subsection{PolynomialSolveByFormulas}
\index[pkg]{PolynomialSolveByFormulas!Domain}
\index[pkg]{Domain!PolynomialSolveByFormulas}
\index[pkg]{SOLVEFOR}
\begin{chunk}{defclass PolynomialSolveByFormulasType}
(defclass |PolynomialSolveByFormulasType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialSolveByFormulas")
   (marker :initform 'package)
   (abbreviation :initform 'SOLVEFOR)
   (comment :initform (list
     "This package factors the formulas out of the general solve code,"
     "allowing their recursive use over different domains."
     "Care is taken to introduce few radicals so that radical extension"
     "domains can more easily simplify the results."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialSolveByFormulas|
  (progn
    (push '|PolynomialSolveByFormulas| *Packages*)
    (make-instance '|PolynomialSolveByFormulasType|)))

\end{chunk}

\subsection{PolynomialSquareFree}
\index[pkg]{PolynomialSquareFree!Domain}
\index[pkg]{Domain!PolynomialSquareFree}
\index[pkg]{PSQFR}
\begin{chunk}{defclass PolynomialSquareFreeType}
(defclass |PolynomialSquareFreeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialSquareFree")
   (marker :initform 'package)
   (abbreviation :initform 'PSQFR)
   (comment :initform (list
     "This package computes square-free decomposition of multivariate"
     "polynomials over a coefficient ring which is an arbitrary gcd domain."
     "The requirement on the coefficient domain guarantees that the"
     "content can be"
     "removed so that factors will be primitive as well as square-free."
     "Over an infinite ring of finite characteristic,it may not be possible to"
     "guarantee that the factors are square-free."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialSquareFree|
  (progn
    (push '|PolynomialSquareFree| *Packages*)
    (make-instance '|PolynomialSquareFreeType|)))

\end{chunk}

\subsection{PolynomialToUnivariatePolynomial}
\index[pkg]{PolynomialToUnivariatePolynomial!Domain}
\index[pkg]{Domain!PolynomialToUnivariatePolynomial}
\index[pkg]{POLY2UP}
\begin{chunk}{defclass PolynomialToUnivariatePolynomialType}
(defclass |PolynomialToUnivariatePolynomialType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PolynomialToUnivariatePolynomial")
   (marker :initform 'package)
   (abbreviation :initform 'POLY2UP)
   (comment :initform (list
     "This package is primarily to help the interpreter do coercions."
     "It allows you to view a polynomial as a"
     "univariate polynomial in one of its variables with"
     "coefficients which are again a polynomial in all the"
     "other variables."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PolynomialToUnivariatePolynomial|
  (progn
    (push '|PolynomialToUnivariatePolynomial| *Packages*)
    (make-instance '|PolynomialToUnivariatePolynomialType|)))

\end{chunk}

\subsection{PowerSeriesLimitPackage}
\index[pkg]{PowerSeriesLimitPackage!Domain}
\index[pkg]{Domain!PowerSeriesLimitPackage}
\index[pkg]{LIMITPS}
\begin{chunk}{defclass PowerSeriesLimitPackageType}
(defclass |PowerSeriesLimitPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PowerSeriesLimitPackage")
   (marker :initform 'package)
   (abbreviation :initform 'LIMITPS)
   (comment :initform (list
     "PowerSeriesLimitPackage implements limits of expressions"
     "in one or more variables as one of the variables approaches a"
     "limiting value.  Included are two-sided limits, left- and right-"
     "hand limits, and limits at plus or minus infinity."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PowerSeriesLimitPackage|
  (progn
    (push '|PowerSeriesLimitPackage| *Packages*)
    (make-instance '|PowerSeriesLimitPackageType|)))

\end{chunk}

\subsection{PrecomputedAssociatedEquations}
\index[pkg]{PrecomputedAssociatedEquations!Domain}
\index[pkg]{Domain!PrecomputedAssociatedEquations}
\index[pkg]{PREASSOC}
\begin{chunk}{defclass PrecomputedAssociatedEquationsType}
(defclass |PrecomputedAssociatedEquationsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PrecomputedAssociatedEquations")
   (marker :initform 'package)
   (abbreviation :initform 'PREASSOC)
   (comment :initform (list
     "PrecomputedAssociatedEquations stores some generic"
     "precomputations which speed up the computations of the"
     "associated equations needed for factoring operators."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PrecomputedAssociatedEquations|
  (progn
    (push '|PrecomputedAssociatedEquations| *Packages*)
    (make-instance '|PrecomputedAssociatedEquationsType|)))

\end{chunk}

\subsection{PrimitiveArrayFunctions2}
\index[pkg]{PrimitiveArrayFunctions2!Domain}
\index[pkg]{Domain!PrimitiveArrayFunctions2}
\index[pkg]{PRIMARR2}
\begin{chunk}{defclass PrimitiveArrayFunctions2Type}
(defclass |PrimitiveArrayFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PrimitiveArrayFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'PRIMARR2)
   (comment :initform (list
     "This package provides tools for operating on primitive arrays"
     "with unary and binary functions involving different underlying types"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PrimitiveArrayFunctions2|
  (progn
    (push '|PrimitiveArrayFunctions2| *Packages*)
    (make-instance '|PrimitiveArrayFunctions2Type|)))

\end{chunk}

\subsection{PrimitiveElement}
\index[pkg]{PrimitiveElement!Domain}
\index[pkg]{Domain!PrimitiveElement}
\index[pkg]{PRIMELT}
\begin{chunk}{defclass PrimitiveElementType}
(defclass |PrimitiveElementType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PrimitiveElement")
   (marker :initform 'package)
   (abbreviation :initform 'PRIMELT)
   (comment :initform (list
     "PrimitiveElement provides functions to compute primitive elements"
     "in algebraic extensions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PrimitiveElement|
  (progn
    (push '|PrimitiveElement| *Packages*)
    (make-instance '|PrimitiveElementType|)))

\end{chunk}

\subsection{PrimitiveRatDE}
\index[pkg]{PrimitiveRatDE!Domain}
\index[pkg]{Domain!PrimitiveRatDE}
\index[pkg]{ODEPRIM}
\begin{chunk}{defclass PrimitiveRatDEType}
(defclass |PrimitiveRatDEType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PrimitiveRatDE")
   (marker :initform 'package)
   (abbreviation :initform 'ODEPRIM)
   (comment :initform (list
     "PrimitiveRatDE provides functions for in-field solutions of linear"
     "ordinary differential equations, in the transcendental case."
     "The derivation to use is given by the parameter L."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PrimitiveRatDE|
  (progn
    (push '|PrimitiveRatDE| *Packages*)
    (make-instance '|PrimitiveRatDEType|)))

\end{chunk}

\subsection{PrimitiveRatRicDE}
\index[pkg]{PrimitiveRatRicDE!Domain}
\index[pkg]{Domain!PrimitiveRatRicDE}
\index[pkg]{ODEPRRIC}
\begin{chunk}{defclass PrimitiveRatRicDEType}
(defclass |PrimitiveRatRicDEType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PrimitiveRatRicDE")
   (marker :initform 'package)
   (abbreviation :initform 'ODEPRRIC)
   (comment :initform (list
     "In-field solution of Riccati equations, primitive case."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PrimitiveRatRicDE|
  (progn
    (push '|PrimitiveRatRicDE| *Packages*)
    (make-instance '|PrimitiveRatRicDEType|)))

\end{chunk}

\subsection{PrintPackage}
\index[pkg]{PrintPackage!Domain}
\index[pkg]{Domain!PrintPackage}
\index[pkg]{PRINT}
\begin{chunk}{defclass PrintPackageType}
(defclass |PrintPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PrintPackage")
   (marker :initform 'package)
   (abbreviation :initform 'PRINT)
   (comment :initform (list
     "PrintPackage provides a print function for output forms."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PrintPackage|
  (progn
    (push '|PrintPackage| *Packages*)
    (make-instance '|PrintPackageType|)))

\end{chunk}

\subsection{PseudoLinearNormalForm}
\index[pkg]{PseudoLinearNormalForm!Domain}
\index[pkg]{Domain!PseudoLinearNormalForm}
\index[pkg]{PSEUDLIN}
\begin{chunk}{defclass PseudoLinearNormalFormType}
(defclass |PseudoLinearNormalFormType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PseudoLinearNormalForm")
   (marker :initform 'package)
   (abbreviation :initform 'PSEUDLIN)
   (comment :initform (list
     "PseudoLinearNormalForm provides a function for computing a block-companion"
     "form for pseudo-linear operators."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PseudoLinearNormalForm|
  (progn
    (push '|PseudoLinearNormalForm| *Packages*)
    (make-instance '|PseudoLinearNormalFormType|)))

\end{chunk}

\subsection{PseudoRemainderSequence}
\index[pkg]{PseudoRemainderSequence!Domain}
\index[pkg]{Domain!PseudoRemainderSequence}
\index[pkg]{PRS}
\begin{chunk}{defclass PseudoRemainderSequenceType}
(defclass |PseudoRemainderSequenceType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PseudoRemainderSequence")
   (marker :initform 'package)
   (abbreviation :initform 'PRS)
   (comment :initform (list
     "This package contains some functions: discriminant, resultant,"
     "subResultantGcd, chainSubResultants, degreeSubResultant, lastSubResultant,"
     "resultantEuclidean, subResultantGcdEuclidean, semiSubResultantGcdEuclidean1,"
     "semiSubResultantGcdEuclidean2"
     "These procedures come from improvements of the subresultants algorithm."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PseudoRemainderSequence|
  (progn
    (push '|PseudoRemainderSequence| *Packages*)
    (make-instance '|PseudoRemainderSequenceType|)))

\end{chunk}

\subsection{PureAlgebraicIntegration}
\index[pkg]{PureAlgebraicIntegration!Domain}
\index[pkg]{Domain!PureAlgebraicIntegration}
\index[pkg]{INTPAF}
\begin{chunk}{defclass PureAlgebraicIntegrationType}
(defclass |PureAlgebraicIntegrationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PureAlgebraicIntegration")
   (marker :initform 'package)
   (abbreviation :initform 'INTPAF)
   (comment :initform (list
     "Integration of pure algebraic functions."
     "This package provides functions for integration, limited integration,"
     "extended integration and the risch differential equation for"
     "pure algebraic integrands."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PureAlgebraicIntegration|
  (progn
    (push '|PureAlgebraicIntegration| *Packages*)
    (make-instance '|PureAlgebraicIntegrationType|)))

\end{chunk}

\subsection{PureAlgebraicLODE}
\index[pkg]{PureAlgebraicLODE!Domain}
\index[pkg]{Domain!PureAlgebraicLODE}
\index[pkg]{ODEPAL}
\begin{chunk}{defclass PureAlgebraicLODEType}
(defclass |PureAlgebraicLODEType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PureAlgebraicLODE")
   (marker :initform 'package)
   (abbreviation :initform 'ODEPAL)
   (comment :initform (list
     "In-field solution of an linear ordinary differential equation,"
     "pure algebraic case."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PureAlgebraicLODE|
  (progn
    (push '|PureAlgebraicLODE| *Packages*)
    (make-instance '|PureAlgebraicLODEType|)))

\end{chunk}

\subsection{PushVariables}
\index[pkg]{PushVariables!Domain}
\index[pkg]{Domain!PushVariables}
\index[pkg]{PUSHVAR}
\begin{chunk}{defclass PushVariablesType}
(defclass |PushVariablesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "PushVariables")
   (marker :initform 'package)
   (abbreviation :initform 'PUSHVAR)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |PushVariables|
  (progn
    (push '|PushVariables| *Packages*)
    (make-instance '|PushVariablesType|)))

\end{chunk}

\section{Q}

\subsection{QuasiAlgebraicSet2}
\index[pkg]{QuasiAlgebraicSet2!Domain}
\index[pkg]{Domain!QuasiAlgebraicSet2}
\index[pkg]{QALGSET2}
\begin{chunk}{defclass QuasiAlgebraicSet2Type}
(defclass |QuasiAlgebraicSet2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "QuasiAlgebraicSet2")
   (marker :initform 'package)
   (abbreviation :initform 'QALGSET2)
   (comment :initform (list
     "QuasiAlgebraicSet2 adds a function radicalSimplify"
     "which uses IdealDecompositionPackage to simplify"
     "the representation of a quasi-algebraic set.  A quasi-algebraic set"
     "is the intersection of a Zariski"
     "closed set, defined as the common zeros of a given list of"
     "polynomials (the defining polynomials for equations), and a principal"
     "Zariski open set, defined as the complement of the common"
     "zeros of a polynomial f (the defining polynomial for the inequation)."
     "Quasi-algebraic sets are implemented in the domain"
     "QuasiAlgebraicSet, where two simplification routines are"
     "provided:"
     "idealSimplify and simplify."
     "The function"
     "radicalSimplify is added"
     "for comparison study only.  Because the domain"
     "IdealDecompositionPackage provides facilities for"
     "computing with radical ideals, it is necessary to restrict"
     "the ground ring to the domain Fraction Integer,"
     "and the polynomial ring to be of type"
     "DistributedMultivariatePolynomial."
     "The routine radicalSimplify uses these to compute groebner"
     "basis of radical ideals and"
     "is inefficient and restricted when compared to the"
     "two in QuasiAlgebraicSet."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |QuasiAlgebraicSet2|
  (progn
    (push '|QuasiAlgebraicSet2| *Packages*)
    (make-instance '|QuasiAlgebraicSet2Type|)))

\end{chunk}

\subsection{QuasiComponentPackage}
\index[pkg]{QuasiComponentPackage!Domain}
\index[pkg]{Domain!QuasiComponentPackage}
\index[pkg]{QCMPACK}
\begin{chunk}{defclass QuasiComponentPackageType}
(defclass |QuasiComponentPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "QuasiComponentPackage")
   (marker :initform 'package)
   (abbreviation :initform 'QCMPACK)
   (comment :initform (list
     "A package for removing redundant quasi-components and redundant"
     "branches when decomposing a variety by means of quasi-components"
     "of regular triangular sets."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |QuasiComponentPackage|
  (progn
    (push '|QuasiComponentPackage| *Packages*)
    (make-instance '|QuasiComponentPackageType|)))

\end{chunk}

\subsection{QuotientFieldCategoryFunctions2}
\index[pkg]{QuotientFieldCategoryFunctions2!Domain}
\index[pkg]{Domain!QuotientFieldCategoryFunctions2}
\index[pkg]{QFCAT2}
\begin{chunk}{defclass QuotientFieldCategoryFunctions2Type}
(defclass |QuotientFieldCategoryFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "QuotientFieldCategoryFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'QFCAT2)
   (comment :initform (list
     "This package extends a function between integral domains"
     "to a mapping between their quotient fields."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |QuotientFieldCategoryFunctions2|
  (progn
    (push '|QuotientFieldCategoryFunctions2| *Packages*)
    (make-instance '|QuotientFieldCategoryFunctions2Type|)))

\end{chunk}

\subsection{QuaternionCategoryFunctions2}
\index[pkg]{QuaternionCategoryFunctions2!Domain}
\index[pkg]{Domain!QuaternionCategoryFunctions2}
\index[pkg]{QUATCT2}
\begin{chunk}{defclass QuaternionCategoryFunctions2Type}
(defclass |QuaternionCategoryFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "QuaternionCategoryFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'QUATCT2)
   (comment :initform (list
     "QuaternionCategoryFunctions2 implements functions between"
     "two quaternion domains.  The function map is used by"
     "the system interpreter to coerce between quaternion types."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |QuaternionCategoryFunctions2|
  (progn
    (push '|QuaternionCategoryFunctions2| *Packages*)
    (make-instance '|QuaternionCategoryFunctions2Type|)))

\end{chunk}

\section{R}

\subsection{RadicalEigenPackage}
\index[pkg]{RadicalEigenPackage!Domain}
\index[pkg]{Domain!RadicalEigenPackage}
\index[pkg]{REP}
\begin{chunk}{defclass RadicalEigenPackageType}
(defclass |RadicalEigenPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RadicalEigenPackage")
   (marker :initform 'package)
   (abbreviation :initform 'REP)
   (comment :initform (list
     "Package for the computation of eigenvalues and eigenvectors."
     "This package works for matrices with coefficients which are"
     "rational functions over the integers."
     "(see Fraction Polynomial Integer)."
     "The eigenvalues and eigenvectors are expressed in terms of radicals."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RadicalEigenPackage|
  (progn
    (push '|RadicalEigenPackage| *Packages*)
    (make-instance '|RadicalEigenPackageType|)))

\end{chunk}

\subsection{RadicalSolvePackage}
\index[pkg]{RadicalSolvePackage!Domain}
\index[pkg]{Domain!RadicalSolvePackage}
\index[pkg]{SOLVERAD}
\begin{chunk}{defclass RadicalSolvePackageType}
(defclass |RadicalSolvePackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RadicalSolvePackage")
   (marker :initform 'package)
   (abbreviation :initform 'SOLVERAD)
   (comment :initform (list
     "This package tries to find solutions"
     "expressed in terms of radicals for systems of equations"
     "of rational functions with coefficients in an integral domain R."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RadicalSolvePackage|
  (progn
    (push '|RadicalSolvePackage| *Packages*)
    (make-instance '|RadicalSolvePackageType|)))

\end{chunk}

\subsection{RadixUtilities}
\index[pkg]{RadixUtilities!Domain}
\index[pkg]{Domain!RadixUtilities}
\index[pkg]{RADUTIL}
\begin{chunk}{defclass RadixUtilitiesType}
(defclass |RadixUtilitiesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RadixUtilities")
   (marker :initform 'package)
   (abbreviation :initform 'RADUTIL)
   (comment :initform (list
     "This package provides tools for creating radix expansions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RadixUtilities|
  (progn
    (push '|RadixUtilities| *Packages*)
    (make-instance '|RadixUtilitiesType|)))

\end{chunk}

\subsection{RandomDistributions}
\index[pkg]{RandomDistributions!Domain}
\index[pkg]{Domain!RandomDistributions}
\index[pkg]{RDIST}
\begin{chunk}{defclass RandomDistributionsType}
(defclass |RandomDistributionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RandomDistributions")
   (marker :initform 'package)
   (abbreviation :initform 'RDIST)
   (comment :initform (list
     "This package exports random distributions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RandomDistributions|
  (progn
    (push '|RandomDistributions| *Packages*)
    (make-instance '|RandomDistributionsType|)))

\end{chunk}

\subsection{RandomFloatDistributions}
\index[pkg]{RandomFloatDistributions!Domain}
\index[pkg]{Domain!RandomFloatDistributions}
\index[pkg]{RFDIST}
\begin{chunk}{defclass RandomFloatDistributionsType}
(defclass |RandomFloatDistributionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RandomFloatDistributions")
   (marker :initform 'package)
   (abbreviation :initform 'RFDIST)
   (comment :initform (list
     "This package exports random floating-point distributions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RandomFloatDistributions|
  (progn
    (push '|RandomFloatDistributions| *Packages*)
    (make-instance '|RandomFloatDistributionsType|)))

\end{chunk}

\subsection{RandomIntegerDistributions}
\index[pkg]{RandomIntegerDistributions!Domain}
\index[pkg]{Domain!RandomIntegerDistributions}
\index[pkg]{RIDIST}
\begin{chunk}{defclass RandomIntegerDistributionsType}
(defclass |RandomIntegerDistributionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RandomIntegerDistributions")
   (marker :initform 'package)
   (abbreviation :initform 'RIDIST)
   (comment :initform (list
     "This package exports integer distributions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RandomIntegerDistributions|
  (progn
    (push '|RandomIntegerDistributions| *Packages*)
    (make-instance '|RandomIntegerDistributionsType|)))

\end{chunk}

\subsection{RandomNumberSource}
\index[pkg]{RandomNumberSource!Domain}
\index[pkg]{Domain!RandomNumberSource}
\index[pkg]{RANDSRC}
\begin{chunk}{defclass RandomNumberSourceType}
(defclass |RandomNumberSourceType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RandomNumberSource")
   (marker :initform 'package)
   (abbreviation :initform 'RANDSRC)
   (comment :initform (list
     "Random number generators."
     "All random numbers used in the system should originate from"
     "the same generator.  This package is intended to be the source."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RandomNumberSource|
  (progn
    (push '|RandomNumberSource| *Packages*)
    (make-instance '|RandomNumberSourceType|)))

\end{chunk}

\subsection{RationalFactorize}
\index[pkg]{RationalFactorize!Domain}
\index[pkg]{Domain!RationalFactorize}
\index[pkg]{RATFACT}
\begin{chunk}{defclass RationalFactorizeType}
(defclass |RationalFactorizeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RationalFactorize")
   (marker :initform 'package)
   (abbreviation :initform 'RATFACT)
   (comment :initform (list
     "Factorization of extended polynomials with rational coefficients."
     "This package implements factorization of extended polynomials"
     "whose coefficients are rational numbers. It does this by taking the"
     "lcm of the coefficients of the polynomial and creating a polynomial"
     "with integer coefficients. The algorithm in"
     "GaloisGroupFactorizer is then"
     "used to factor the integer polynomial. The result is normalized"
     "with respect to the original lcm of the denominators."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RationalFactorize|
  (progn
    (push '|RationalFactorize| *Packages*)
    (make-instance '|RationalFactorizeType|)))

\end{chunk}

\subsection{RationalFunction}
\index[pkg]{RationalFunction!Domain}
\index[pkg]{Domain!RationalFunction}
\index[pkg]{RF}
\begin{chunk}{defclass RationalFunctionType}
(defclass |RationalFunctionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RationalFunction")
   (marker :initform 'package)
   (abbreviation :initform 'RF)
   (comment :initform (list
     "Utilities that provide the same top-level manipulations on"
     "fractions than on polynomials."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RationalFunction|
  (progn
    (push '|RationalFunction| *Packages*)
    (make-instance '|RationalFunctionType|)))

\end{chunk}

\subsection{RationalFunctionDefiniteIntegration}
\index[pkg]{RationalFunctionDefiniteIntegration!Domain}
\index[pkg]{Domain!RationalFunctionDefiniteIntegration}
\index[pkg]{DEFINTRF}
\begin{chunk}{defclass RationalFunctionDefiniteIntegrationType}
(defclass |RationalFunctionDefiniteIntegrationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RationalFunctionDefiniteIntegration")
   (marker :initform 'package)
   (abbreviation :initform 'DEFINTRF)
   (comment :initform (list
     "Definite integration of rational functions."
     "RationalFunctionDefiniteIntegration provides functions to"
     "compute definite integrals of rational functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RationalFunctionDefiniteIntegration|
  (progn
    (push '|RationalFunctionDefiniteIntegration| *Packages*)
    (make-instance '|RationalFunctionDefiniteIntegrationType|)))

\end{chunk}

\subsection{RationalFunctionFactor}
\index[pkg]{RationalFunctionFactor!Domain}
\index[pkg]{Domain!RationalFunctionFactor}
\index[pkg]{RFFACT}
\begin{chunk}{defclass RationalFunctionFactorType}
(defclass |RationalFunctionFactorType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RationalFunctionFactor")
   (marker :initform 'package)
   (abbreviation :initform 'RFFACT)
   (comment :initform (list
     "Factorization of univariate polynomials with coefficients which"
     "are rational functions with integer coefficients."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RationalFunctionFactor|
  (progn
    (push '|RationalFunctionFactor| *Packages*)
    (make-instance '|RationalFunctionFactorType|)))

\end{chunk}

\subsection{RationalFunctionFactorizer}
\index[pkg]{RationalFunctionFactorizer!Domain}
\index[pkg]{Domain!RationalFunctionFactorizer}
\index[pkg]{RFFACTOR}
\begin{chunk}{defclass RationalFunctionFactorizerType}
(defclass |RationalFunctionFactorizerType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RationalFunctionFactorizer")
   (marker :initform 'package)
   (abbreviation :initform 'RFFACTOR)
   (comment :initform (list
     "\spadtype{RationalFunctionFactorizer} contains the factor function"
     "(called factorFraction) which factors fractions of polynomials by factoring"
     "the numerator and denominator. Since any non zero fraction is a unit"
     "the usual factor operation will just return the original fraction."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RationalFunctionFactorizer|
  (progn
    (push '|RationalFunctionFactorizer| *Packages*)
    (make-instance '|RationalFunctionFactorizerType|)))

\end{chunk}

\subsection{RationalFunctionIntegration}
\index[pkg]{RationalFunctionIntegration!Domain}
\index[pkg]{Domain!RationalFunctionIntegration}
\index[pkg]{INTRF}
\begin{chunk}{defclass RationalFunctionIntegrationType}
(defclass |RationalFunctionIntegrationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RationalFunctionIntegration")
   (marker :initform 'package)
   (abbreviation :initform 'INTRF)
   (comment :initform (list
     "This package provides functions for the integration of rational functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RationalFunctionIntegration|
  (progn
    (push '|RationalFunctionIntegration| *Packages*)
    (make-instance '|RationalFunctionIntegrationType|)))

\end{chunk}

\subsection{RationalFunctionLimitPackage}
\index[pkg]{RationalFunctionLimitPackage!Domain}
\index[pkg]{Domain!RationalFunctionLimitPackage}
\index[pkg]{LIMITRF}
\begin{chunk}{defclass RationalFunctionLimitPackageType}
(defclass |RationalFunctionLimitPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RationalFunctionLimitPackage")
   (marker :initform 'package)
   (abbreviation :initform 'LIMITRF)
   (comment :initform (list
     "Computation of limits for rational functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RationalFunctionLimitPackage|
  (progn
    (push '|RationalFunctionLimitPackage| *Packages*)
    (make-instance '|RationalFunctionLimitPackageType|)))

\end{chunk}

\subsection{RationalFunctionSign}
\index[pkg]{RationalFunctionSign!Domain}
\index[pkg]{Domain!RationalFunctionSign}
\index[pkg]{SIGNRF}
\begin{chunk}{defclass RationalFunctionSignType}
(defclass |RationalFunctionSignType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RationalFunctionSign")
   (marker :initform 'package)
   (abbreviation :initform 'SIGNRF)
   (comment :initform (list
     "Find the sign of a rational function around a point or infinity."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RationalFunctionSign|
  (progn
    (push '|RationalFunctionSign| *Packages*)
    (make-instance '|RationalFunctionSignType|)))

\end{chunk}

\subsection{RationalFunctionSum}
\index[pkg]{RationalFunctionSum!Domain}
\index[pkg]{Domain!RationalFunctionSum}
\index[pkg]{SUMRF}
\begin{chunk}{defclass RationalFunctionSumType}
(defclass |RationalFunctionSumType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RationalFunctionSum")
   (marker :initform 'package)
   (abbreviation :initform 'SUMRF)
   (comment :initform (list
     "Computes sums of rational functions"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RationalFunctionSum|
  (progn
    (push '|RationalFunctionSum| *Packages*)
    (make-instance '|RationalFunctionSumType|)))

\end{chunk}

\subsection{RationalIntegration}
\index[pkg]{RationalIntegration!Domain}
\index[pkg]{Domain!RationalIntegration}
\index[pkg]{INTRAT}
\begin{chunk}{defclass RationalIntegrationType}
(defclass |RationalIntegrationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RationalIntegration")
   (marker :initform 'package)
   (abbreviation :initform 'INTRAT)
   (comment :initform (list
     "This package provides functions for the base case of the Risch algorithm."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RationalIntegration|
  (progn
    (push '|RationalIntegration| *Packages*)
    (make-instance '|RationalIntegrationType|)))

\end{chunk}

\subsection{RationalInterpolation}
\index[pkg]{RationalInterpolation!Domain}
\index[pkg]{Domain!RationalInterpolation}
\index[pkg]{RINTERP}
\begin{chunk}{defclass RationalInterpolationType}
(defclass |RationalInterpolationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RationalInterpolation")
   (marker :initform 'package)
   (abbreviation :initform 'RINTERP)
   (comment :initform (list
     "This package exports rational interpolation algorithms"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RationalInterpolation|
  (progn
    (push '|RationalInterpolation| *Packages*)
    (make-instance '|RationalInterpolationType|)))

\end{chunk}

\subsection{RationalLODE}
\index[pkg]{RationalLODE!Domain}
\index[pkg]{Domain!RationalLODE}
\index[pkg]{ODERAT}
\begin{chunk}{defclass RationalLODEType}
(defclass |RationalLODEType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RationalLODE")
   (marker :initform 'package)
   (abbreviation :initform 'ODERAT)
   (comment :initform (list
     "RationalLODE provides functions for in-field solutions of linear"
     "ordinary differential equations, in the rational case."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RationalLODE|
  (progn
    (push '|RationalLODE| *Packages*)
    (make-instance '|RationalLODEType|)))

\end{chunk}

\subsection{RationalRetractions}
\index[pkg]{RationalRetractions!Domain}
\index[pkg]{Domain!RationalRetractions}
\index[pkg]{RATRET}
\begin{chunk}{defclass RationalRetractionsType}
(defclass |RationalRetractionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RationalRetractions")
   (marker :initform 'package)
   (abbreviation :initform 'RATRET)
   (comment :initform (list
     "Rational number testing and retraction functions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RationalRetractions|
  (progn
    (push '|RationalRetractions| *Packages*)
    (make-instance '|RationalRetractionsType|)))

\end{chunk}

\subsection{RationalRicDE}
\index[pkg]{RationalRicDE!Domain}
\index[pkg]{Domain!RationalRicDE}
\index[pkg]{ODERTRIC}
\begin{chunk}{defclass RationalRicDEType}
(defclass |RationalRicDEType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RationalRicDE")
   (marker :initform 'package)
   (abbreviation :initform 'ODERTRIC)
   (comment :initform (list
     "In-field solution of Riccati equations, rational case."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RationalRicDE|
  (progn
    (push '|RationalRicDE| *Packages*)
    (make-instance '|RationalRicDEType|)))

\end{chunk}

\subsection{RationalUnivariateRepresentationPackage}
\index[pkg]{RationalUnivariateRepresentationPackage!Domain}
\index[pkg]{Domain!RationalUnivariateRepresentationPackage}
\index[pkg]{RURPK}
\begin{chunk}{defclass RationalUnivariateRepresentationPackageType}
(defclass |RationalUnivariateRepresentationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RationalUnivariateRepresentationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'RURPK)
   (comment :initform (list
     "A package for computing the rational univariate representation"
     "of a zero-dimensional algebraic variety given by a regular"
     "triangular set. This package is essentially an interface for the"
     "InternalRationalUnivariateRepresentationPackage constructor."
     "It is used in the ZeroDimensionalSolvePackage"
     "for solving polynomial systems with finitely many solutions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RationalUnivariateRepresentationPackage|
  (progn
    (push '|RationalUnivariateRepresentationPackage| *Packages*)
    (make-instance '|RationalUnivariateRepresentationPackageType|)))

\end{chunk}

\subsection{RealPolynomialUtilitiesPackage}
\index[pkg]{RealPolynomialUtilitiesPackage!Domain}
\index[pkg]{Domain!RealPolynomialUtilitiesPackage}
\index[pkg]{POLUTIL}
\begin{chunk}{defclass RealPolynomialUtilitiesPackageType}
(defclass |RealPolynomialUtilitiesPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RealPolynomialUtilitiesPackage")
   (marker :initform 'package)
   (abbreviation :initform 'POLUTIL)
   (comment :initform (list
     "RealPolynomialUtilitiesPackage provides common functions used"
     "by interval coding."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RealPolynomialUtilitiesPackage|
  (progn
    (push '|RealPolynomialUtilitiesPackage| *Packages*)
    (make-instance '|RealPolynomialUtilitiesPackageType|)))

\end{chunk}

\subsection{RealSolvePackage}
\index[pkg]{RealSolvePackage!Domain}
\index[pkg]{Domain!RealSolvePackage}
\index[pkg]{REALSOLV}
\begin{chunk}{defclass RealSolvePackageType}
(defclass |RealSolvePackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RealSolvePackage")
   (marker :initform 'package)
   (abbreviation :initform 'REALSOLV)
   (comment :initform (list
     "This package provides numerical solutions of systems of"
     "polynomial equations for use in ACPLOT"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RealSolvePackage|
  (progn
    (push '|RealSolvePackage| *Packages*)
    (make-instance '|RealSolvePackageType|)))

\end{chunk}

\subsection{RealZeroPackage}
\index[pkg]{RealZeroPackage!Domain}
\index[pkg]{Domain!RealZeroPackage}
\index[pkg]{REAL0}
\begin{chunk}{defclass RealZeroPackageType}
(defclass |RealZeroPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RealZeroPackage")
   (marker :initform 'package)
   (abbreviation :initform 'REAL0)
   (comment :initform (list
     "This package provides functions for finding the real zeros"
     "of univariate polynomials over the integers to arbitrary user-specified"
     "precision. The results are returned as a list of"
     "isolating intervals which are expressed as records with"
     "'left' and 'right' rational number components."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RealZeroPackage|
  (progn
    (push '|RealZeroPackage| *Packages*)
    (make-instance '|RealZeroPackageType|)))

\end{chunk}

\subsection{RealZeroPackageQ}
\index[pkg]{RealZeroPackageQ!Domain}
\index[pkg]{Domain!RealZeroPackageQ}
\index[pkg]{REAL0Q}
\begin{chunk}{defclass RealZeroPackageQType}
(defclass |RealZeroPackageQType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RealZeroPackageQ")
   (marker :initform 'package)
   (abbreviation :initform 'REAL0Q)
   (comment :initform (list
     "This package provides functions for finding the real zeros of univariate"
     "polynomials over the rational numbers to arbitrary user-specified"
     "precision. The results are returned as a list of isolating intervals,"
     "expressed as records with 'left' and 'right' rational number components."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RealZeroPackageQ|
  (progn
    (push '|RealZeroPackageQ| *Packages*)
    (make-instance '|RealZeroPackageQType|)))

\end{chunk}

\subsection{RectangularMatrixCategoryFunctions2}
\index[pkg]{RectangularMatrixCategoryFunctions2!Domain}
\index[pkg]{Domain!RectangularMatrixCategoryFunctions2}
\index[pkg]{RMCAT2}
\begin{chunk}{defclass RectangularMatrixCategoryFunctions2Type}
(defclass |RectangularMatrixCategoryFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RectangularMatrixCategoryFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'RMCAT2)
   (comment :initform (list
     "RectangularMatrixCategoryFunctions2 provides functions between"
     "two matrix domains.  The functions provided are map and"
     "reduce."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RectangularMatrixCategoryFunctions2|
  (progn
    (push '|RectangularMatrixCategoryFunctions2| *Packages*)
    (make-instance '|RectangularMatrixCategoryFunctions2Type|)))

\end{chunk}

\subsection{RecurrenceOperator}
\index[pkg]{RecurrenceOperator!Domain}
\index[pkg]{Domain!RecurrenceOperator}
\index[pkg]{RECOP}
\begin{chunk}{defclass RecurrenceOperatorType}
(defclass |RecurrenceOperatorType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RecurrenceOperator")
   (marker :initform 'package)
   (abbreviation :initform 'RECOP)
   (comment :initform (list
     "This package provides an operator for the n-th term of a recurrence and an"
     "operator for the coefficient of x^n in a function specified by a functional"
     "equation."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RecurrenceOperator|
  (progn
    (push '|RecurrenceOperator| *Packages*)
    (make-instance '|RecurrenceOperatorType|)))

\end{chunk}

\subsection{ReducedDivisor}
\index[pkg]{ReducedDivisor!Domain}
\index[pkg]{Domain!ReducedDivisor}
\index[pkg]{RDIV}
\begin{chunk}{defclass ReducedDivisorType}
(defclass |ReducedDivisorType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ReducedDivisor")
   (marker :initform 'package)
   (abbreviation :initform 'RDIV)
   (comment :initform (list
     "Finds the order of a divisor over a finite field"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ReducedDivisor|
  (progn
    (push '|ReducedDivisor| *Packages*)
    (make-instance '|ReducedDivisorType|)))

\end{chunk}

\subsection{ReduceLODE}
\index[pkg]{ReduceLODE!Domain}
\index[pkg]{Domain!ReduceLODE}
\index[pkg]{ODERED}
\begin{chunk}{defclass ReduceLODEType}
(defclass |ReduceLODEType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ReduceLODE")
   (marker :initform 'package)
   (abbreviation :initform 'ODERED)
   (comment :initform (list
     "Elimination of an algebraic from the coefficentss"
     "of a linear ordinary differential equation."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ReduceLODE|
  (progn
    (push '|ReduceLODE| *Packages*)
    (make-instance '|ReduceLODEType|)))

\end{chunk}

\subsection{ReductionOfOrder}
\index[pkg]{ReductionOfOrder!Domain}
\index[pkg]{Domain!ReductionOfOrder}
\index[pkg]{REDORDER}
\begin{chunk}{defclass ReductionOfOrderType}
(defclass |ReductionOfOrderType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ReductionOfOrder")
   (marker :initform 'package)
   (abbreviation :initform 'REDORDER)
   (comment :initform (list
     "ReductionOfOrder provides"
     "functions for reducing the order of linear ordinary differential equations"
     "once some solutions are known."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ReductionOfOrder|
  (progn
    (push '|ReductionOfOrder| *Packages*)
    (make-instance '|ReductionOfOrderType|)))

\end{chunk}

\subsection{RegularSetDecompositionPackage}
\index[pkg]{RegularSetDecompositionPackage!Domain}
\index[pkg]{Domain!RegularSetDecompositionPackage}
\index[pkg]{RSDCMPK}
\begin{chunk}{defclass RegularSetDecompositionPackageType}
(defclass |RegularSetDecompositionPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RegularSetDecompositionPackage")
   (marker :initform 'package)
   (abbreviation :initform 'RSDCMPK)
   (comment :initform (list
     "A package providing a new algorithm for solving polynomial systems"
     "by means of regular chains. Two ways of solving are proposed:"
     "in the sense of Zariski closure (like in Kalkbrener's algorithm)"
     "or in the sense of the regular zeros (like in Wu, Wang or Lazard"
     "methods). This algorithm is valid for any type"
     "of regular set. It does not care about the way a polynomial is"
     "added in an regular set, or how two quasi-components are compared"
     "(by an inclusion-test), or how the invertibility test is made in"
     "the tower of simple extensions associated with a regular set."
     "These operations are realized respectively by the domain TS"
     "and the packages"
     "QCMPACK(R,E,V,P,TS) and RSETGCD(R,E,V,P,TS)."
     "The same way it does not care about the way univariate polynomial"
     "gcd (with coefficients in the tower of simple extensions associated"
     "with a regular set) are computed. The only requirement is that these"
     "gcd need to have invertible initials (normalized or not)."
     "WARNING. There is no need for a user to call directly any operation"
     "of this package since they can be accessed by the domain TS."
     "Thus, the operations of this package are not documented."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RegularSetDecompositionPackage|
  (progn
    (push '|RegularSetDecompositionPackage| *Packages*)
    (make-instance '|RegularSetDecompositionPackageType|)))

\end{chunk}

\subsection{RegularTriangularSetGcdPackage}
\index[pkg]{RegularTriangularSetGcdPackage!Domain}
\index[pkg]{Domain!RegularTriangularSetGcdPackage}
\index[pkg]{RSETGCD}
\begin{chunk}{defclass RegularTriangularSetGcdPackageType}
(defclass |RegularTriangularSetGcdPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RegularTriangularSetGcdPackage")
   (marker :initform 'package)
   (abbreviation :initform 'RSETGCD)
   (comment :initform (list
     "An internal package for computing gcds and resultants of univariate"
     "polynomials with coefficients in a tower of simple extensions of a field."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RegularTriangularSetGcdPackage|
  (progn
    (push '|RegularTriangularSetGcdPackage| *Packages*)
    (make-instance '|RegularTriangularSetGcdPackageType|)))

\end{chunk}

\subsection{RepeatedDoubling}
\index[pkg]{RepeatedDoubling!Domain}
\index[pkg]{Domain!RepeatedDoubling}
\index[pkg]{REPDB}
\begin{chunk}{defclass RepeatedDoublingType}
(defclass |RepeatedDoublingType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RepeatedDoubling")
   (marker :initform 'package)
   (abbreviation :initform 'REPDB)
   (comment :initform (list
     "Implements multiplication by repeated addition"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RepeatedDoubling|
  (progn
    (push '|RepeatedDoubling| *Packages*)
    (make-instance '|RepeatedDoublingType|)))

\end{chunk}

\subsection{RepeatedSquaring}
\index[pkg]{RepeatedSquaring!Domain}
\index[pkg]{Domain!RepeatedSquaring}
\index[pkg]{REPSQ}
\begin{chunk}{defclass RepeatedSquaringType}
(defclass |RepeatedSquaringType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RepeatedSquaring")
   (marker :initform 'package)
   (abbreviation :initform 'REPSQ)
   (comment :initform (list
     "Implements exponentiation by repeated squaring"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RepeatedSquaring|
  (progn
    (push '|RepeatedSquaring| *Packages*)
    (make-instance '|RepeatedSquaringType|)))

\end{chunk}

\subsection{RepresentationPackage1}
\index[pkg]{RepresentationPackage1!Domain}
\index[pkg]{Domain!RepresentationPackage1}
\index[pkg]{REP1}
\begin{chunk}{defclass RepresentationPackage1Type}
(defclass |RepresentationPackage1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RepresentationPackage1")
   (marker :initform 'package)
   (abbreviation :initform 'REP1)
   (comment :initform (list
     "RepresentationPackage1 provides functions for representation theory"
     "for finite groups and algebras."
     "The package creates permutation representations and uses tensor products"
     "and its symmetric and antisymmetric components to create new"
     "representations of larger degree from given ones."
     "Note that instead of having parameters from Permutation"
     "this package allows list notation of permutations as well:"
     "for example [1,4,3,2] denotes permutes 2 and 4 and fixes 1 and 3."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RepresentationPackage1|
  (progn
    (push '|RepresentationPackage1| *Packages*)
    (make-instance '|RepresentationPackage1Type|)))

\end{chunk}

\subsection{RepresentationPackage2}
\index[pkg]{RepresentationPackage2!Domain}
\index[pkg]{Domain!RepresentationPackage2}
\index[pkg]{REP2}
\begin{chunk}{defclass RepresentationPackage2Type}
(defclass |RepresentationPackage2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RepresentationPackage2")
   (marker :initform 'package)
   (abbreviation :initform 'REP2)
   (comment :initform (list
     "RepresentationPackage2 provides functions for working with"
     "modular representations of finite groups and algebra."
     "The routines in this package are created, using ideas of R. Parker,"
     "(the meat-Axe) to get smaller representations from bigger ones,"
     "finding sub- and factormodules, or to show, that such the"
     "representations are irreducible."
     "Note that most functions are randomized functions of Las Vegas type"
     "every answer is correct, but with small probability"
     "the algorithm fails to get an answer."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RepresentationPackage2|
  (progn
    (push '|RepresentationPackage2| *Packages*)
    (make-instance '|RepresentationPackage2Type|)))

\end{chunk}

\subsection{ResolveLatticeCompletion}
\index[pkg]{ResolveLatticeCompletion!Domain}
\index[pkg]{Domain!ResolveLatticeCompletion}
\index[pkg]{RESLATC}
\begin{chunk}{defclass ResolveLatticeCompletionType}
(defclass |ResolveLatticeCompletionType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ResolveLatticeCompletion")
   (marker :initform 'package)
   (abbreviation :initform 'RESLATC)
   (comment :initform (list
     "This package provides coercions for the special types Exit"
     "and Void."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ResolveLatticeCompletion|
  (progn
    (push '|ResolveLatticeCompletion| *Packages*)
    (make-instance '|ResolveLatticeCompletionType|)))

\end{chunk}

\subsection{RetractSolvePackage}
\index[pkg]{RetractSolvePackage!Domain}
\index[pkg]{Domain!RetractSolvePackage}
\index[pkg]{RETSOL}
\begin{chunk}{defclass RetractSolvePackageType}
(defclass |RetractSolvePackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RetractSolvePackage")
   (marker :initform 'package)
   (abbreviation :initform 'RETSOL)
   (comment :initform (list
     "RetractSolvePackage is an interface to SystemSolvePackage"
     "that attempts to retract the coefficients of the equations before"
     "solving."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RetractSolvePackage|
  (progn
    (push '|RetractSolvePackage| *Packages*)
    (make-instance '|RetractSolvePackageType|)))

\end{chunk}

\subsection{RootsFindingPackage}
\index[pkg]{RootsFindingPackage!Domain}
\index[pkg]{Domain!RootsFindingPackage}
\index[pkg]{RFP}
\begin{chunk}{defclass RootsFindingPackageType}
(defclass |RootsFindingPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "RootsFindingPackage")
   (marker :initform 'package)
   (abbreviation :initform 'RFP)
   (comment :initform (list
     "This pacackage finds all the roots of a polynomial. If the constant field is"
     "not large enough then it returns the list of found zeros and the degree"
     "of the extension need to find the other roots missing. If the return"
     "degree is 1 then all the roots have been found. If 0 is return"
     "for the extension degree then there are an infinite number of zeros,"
     "that is you ask for the zeroes of 0. In the case of infinite field"
     "a list of all found zeros is kept and for each other call of a function"
     "that finds zeroes, a check is made on that list; this is to keep"
     "a kind of 'canonical' representation of the elements."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |RootsFindingPackage|
  (progn
    (push '|RootsFindingPackage| *Packages*)
    (make-instance '|RootsFindingPackageType|)))

\end{chunk}

\section{S}

\subsection{SAERationalFunctionAlgFactor}
\index[pkg]{SAERationalFunctionAlgFactor!Domain}
\index[pkg]{Domain!SAERationalFunctionAlgFactor}
\index[pkg]{SAERFFC}
\begin{chunk}{defclass SAERationalFunctionAlgFactorType}
(defclass |SAERationalFunctionAlgFactorType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SAERationalFunctionAlgFactor")
   (marker :initform 'package)
   (abbreviation :initform 'SAERFFC)
   (comment :initform (list
     "Factorization of univariate polynomials with coefficients in an"
     "algebraic extension of \spadtype{Fraction Polynomial Integer}."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SAERationalFunctionAlgFactor|
  (progn
    (push '|SAERationalFunctionAlgFactor| *Packages*)
    (make-instance '|SAERationalFunctionAlgFactorType|)))

\end{chunk}

\subsection{ScriptFormulaFormat1}
\index[pkg]{ScriptFormulaFormat1!Domain}
\index[pkg]{Domain!ScriptFormulaFormat1}
\index[pkg]{FORMULA1}
\begin{chunk}{defclass ScriptFormulaFormat1Type}
(defclass |ScriptFormulaFormat1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ScriptFormulaFormat1")
   (marker :initform 'package)
   (abbreviation :initform 'FORMULA1)
   (comment :initform (list
     "ScriptFormulaFormat1 provides a utility coercion for"
     "changing to SCRIPT formula format anything that has a coercion to"
     "the standard output format."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ScriptFormulaFormat1|
  (progn
    (push '|ScriptFormulaFormat1| *Packages*)
    (make-instance '|ScriptFormulaFormat1Type|)))

\end{chunk}

\subsection{SegmentBindingFunctions2}
\index[pkg]{SegmentBindingFunctions2!Domain}
\index[pkg]{Domain!SegmentBindingFunctions2}
\index[pkg]{SEGBIND2}
\begin{chunk}{defclass SegmentBindingFunctions2Type}
(defclass |SegmentBindingFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SegmentBindingFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'SEGBIND2)
   (comment :initform (list
     "This package provides operations for mapping functions onto"
     "SegmentBindings."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SegmentBindingFunctions2|
  (progn
    (push '|SegmentBindingFunctions2| *Packages*)
    (make-instance '|SegmentBindingFunctions2Type|)))

\end{chunk}

\subsection{SegmentFunctions2}
\index[pkg]{SegmentFunctions2!Domain}
\index[pkg]{Domain!SegmentFunctions2}
\index[pkg]{SEG2}
\begin{chunk}{defclass SegmentFunctions2Type}
(defclass |SegmentFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SegmentFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'SEG2)
   (comment :initform (list
     "This package provides operations for mapping functions onto segments."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SegmentFunctions2|
  (progn
    (push '|SegmentFunctions2| *Packages*)
    (make-instance '|SegmentFunctions2Type|)))

\end{chunk}

\subsection{SimpleAlgebraicExtensionAlgFactor}
\index[pkg]{SimpleAlgebraicExtensionAlgFactor!Domain}
\index[pkg]{Domain!SimpleAlgebraicExtensionAlgFactor}
\index[pkg]{SAEFACT}
\begin{chunk}{defclass SimpleAlgebraicExtensionAlgFactorType}
(defclass |SimpleAlgebraicExtensionAlgFactorType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SimpleAlgebraicExtensionAlgFactor")
   (marker :initform 'package)
   (abbreviation :initform 'SAEFACT)
   (comment :initform (list
     "Factorization of univariate polynomials with coefficients in an"
     "algebraic extension of the rational numbers (Fraction Integer)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SimpleAlgebraicExtensionAlgFactor|
  (progn
    (push '|SimpleAlgebraicExtensionAlgFactor| *Packages*)
    (make-instance '|SimpleAlgebraicExtensionAlgFactorType|)))

\end{chunk}

\subsection{SimplifyAlgebraicNumberConvertPackage}
\index[pkg]{SimplifyAlgebraicNumberConvertPackage!Domain}
\index[pkg]{Domain!SimplifyAlgebraicNumberConvertPackage}
\index[pkg]{SIMPAN}
\begin{chunk}{defclass SimplifyAlgebraicNumberConvertPackageType}
(defclass |SimplifyAlgebraicNumberConvertPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SimplifyAlgebraicNumberConvertPackage")
   (marker :initform 'package)
   (abbreviation :initform 'SIMPAN)
   (comment :initform (list
     "Package to allow simplify to be called on AlgebraicNumbers"
     "by converting to EXPR(INT)"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SimplifyAlgebraicNumberConvertPackage|
  (progn
    (push '|SimplifyAlgebraicNumberConvertPackage| *Packages*)
    (make-instance '|SimplifyAlgebraicNumberConvertPackageType|)))

\end{chunk}

\subsection{SmithNormalForm}
\index[pkg]{SmithNormalForm!Domain}
\index[pkg]{Domain!SmithNormalForm}
\index[pkg]{SMITH}
\begin{chunk}{defclass SmithNormalFormType}
(defclass |SmithNormalFormType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SmithNormalForm")
   (marker :initform 'package)
   (abbreviation :initform 'SMITH)
   (comment :initform (list
     "SmithNormalForm is a package"
     "which provides some standard canonical forms for matrices."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SmithNormalForm|
  (progn
    (push '|SmithNormalForm| *Packages*)
    (make-instance '|SmithNormalFormType|)))

\end{chunk}

\subsection{SortedCache}
\index[pkg]{SortedCache!Domain}
\index[pkg]{Domain!SortedCache}
\index[pkg]{SCACHE}
\begin{chunk}{defclass SortedCacheType}
(defclass |SortedCacheType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SortedCache")
   (marker :initform 'package)
   (abbreviation :initform 'SCACHE)
   (comment :initform (list
     "A sorted cache of a cachable set S is a dynamic structure that"
     "keeps the elements of S sorted and assigns an integer to each"
     "element of S once it is in the cache. This way, equality and ordering"
     "on S are tested directly on the integers associated with the elements"
     "of S, once they have been entered in the cache."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SortedCache|
  (progn
    (push '|SortedCache| *Packages*)
    (make-instance '|SortedCacheType|)))

\end{chunk}

\subsection{SortPackage}
\index[pkg]{SortPackage!Domain}
\index[pkg]{Domain!SortPackage}
\index[pkg]{SORTPAK}
\begin{chunk}{defclass SortPackageType}
(defclass |SortPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SortPackage")
   (marker :initform 'package)
   (abbreviation :initform 'SORTPAK)
   (comment :initform (list
     "This package exports sorting algorithnms"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SortPackage|
  (progn
    (push '|SortPackage| *Packages*)
    (make-instance '|SortPackageType|)))

\end{chunk}

\subsection{SparseUnivariatePolynomialFunctions2}
\index[pkg]{SparseUnivariatePolynomialFunctions2!Domain}
\index[pkg]{Domain!SparseUnivariatePolynomialFunctions2}
\index[pkg]{SUP2}
\begin{chunk}{defclass SparseUnivariatePolynomialFunctions2Type}
(defclass |SparseUnivariatePolynomialFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SparseUnivariatePolynomialFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'SUP2)
   (comment :initform (list
     "This package lifts a mapping from coefficient rings R to S to"
     "a mapping from sparse univariate polynomial over R to"
     "a sparse univariate polynomial over S."
     "Note that the mapping is assumed"
     "to send zero to zero, since it will only be applied to the non-zero"
     "coefficients of the polynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SparseUnivariatePolynomialFunctions2|
  (progn
    (push '|SparseUnivariatePolynomialFunctions2| *Packages*)
    (make-instance '|SparseUnivariatePolynomialFunctions2Type|)))

\end{chunk}

\subsection{SpecialOutputPackage}
\index[pkg]{SpecialOutputPackage!Domain}
\index[pkg]{Domain!SpecialOutputPackage}
\index[pkg]{SPECOUT}
\begin{chunk}{defclass SpecialOutputPackageType}
(defclass |SpecialOutputPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SpecialOutputPackage")
   (marker :initform 'package)
   (abbreviation :initform 'SPECOUT)
   (comment :initform (list
     "SpecialOutputPackage allows FORTRAN, Tex and"
     "Script Formula Formatter output from programs."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SpecialOutputPackage|
  (progn
    (push '|SpecialOutputPackage| *Packages*)
    (make-instance '|SpecialOutputPackageType|)))

\end{chunk}

\subsection{SquareFreeQuasiComponentPackage}
\index[pkg]{SquareFreeQuasiComponentPackage!Domain}
\index[pkg]{Domain!SquareFreeQuasiComponentPackage}
\index[pkg]{SFQCMPK}
\begin{chunk}{defclass SquareFreeQuasiComponentPackageType}
(defclass |SquareFreeQuasiComponentPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SquareFreeQuasiComponentPackage")
   (marker :initform 'package)
   (abbreviation :initform 'SFQCMPK)
   (comment :initform (list
     "A internal package for removing redundant quasi-components and redundant"
     "branches when decomposing a variety by means of quasi-components"
     "of regular triangular sets."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SquareFreeQuasiComponentPackage|
  (progn
    (push '|SquareFreeQuasiComponentPackage| *Packages*)
    (make-instance '|SquareFreeQuasiComponentPackageType|)))

\end{chunk}

\subsection{SquareFreeRegularSetDecompositionPackage}
\index[pkg]{SquareFreeRegularSetDecompositionPackage!Domain}
\index[pkg]{Domain!SquareFreeRegularSetDecompositionPackage}
\index[pkg]{SRDCMPK}
\begin{chunk}{defclass SquareFreeRegularSetDecompositionPackageType}
(defclass |SquareFreeRegularSetDecompositionPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SquareFreeRegularSetDecompositionPackage")
   (marker :initform 'package)
   (abbreviation :initform 'SRDCMPK)
   (comment :initform (list
     "A package providing a new algorithm for solving polynomial systems"
     "by means of regular chains. Two ways of solving are provided:"
     "in the sense of Zariski closure (like in Kalkbrener's algorithm)"
     "or in the sense of the regular zeros (like in Wu, Wang or Lazard-"
     "Moreno methods). This algorithm is valid for any type"
     "of regular set. It does not care about the way a polynomial is"
     "added in an regular set, or how two quasi-components are compared"
     "(by an inclusion-test), or how the invertibility test is made in"
     "the tower of simple extensions associated with a regular set."
     "These operations are realized respectively by the domain TS"
     "and the packages QCMPPK(R,E,V,P,TS) and RSETGCD(R,E,V,P,TS)."
     "The same way it does not care about the way univariate polynomial"
     "gcds (with coefficients in the tower of simple extensions associated"
     "with a regular set) are computed. The only requirement is that these"
     "gcds need to have invertible initials (normalized or not)."
     "WARNING. There is no need for a user to call directly any operation"
     "of this package since they can be accessed by the domain TS."
     "Thus, the operations of this package are not documented."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SquareFreeRegularSetDecompositionPackage|
  (progn
    (push '|SquareFreeRegularSetDecompositionPackage| *Packages*)
    (make-instance '|SquareFreeRegularSetDecompositionPackageType|)))

\end{chunk}

\subsection{SquareFreeRegularTriangularSetGcdPackage}
\index[pkg]{SquareFreeRegularTriangularSetGcdPackage!Domain}
\index[pkg]{Domain!SquareFreeRegularTriangularSetGcdPackage}
\index[pkg]{SFRGCD}
\begin{chunk}{defclass SquareFreeRegularTriangularSetGcdPackageType}
(defclass |SquareFreeRegularTriangularSetGcdPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SquareFreeRegularTriangularSetGcdPackage")
   (marker :initform 'package)
   (abbreviation :initform 'SFRGCD)
   (comment :initform (list
     "A internal package for computing gcds and resultants of univariate"
     "polynomials with coefficients in a tower of simple extensions of a field."
     "There is no need to use directly this package since its main operations are"
     "available from TS."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SquareFreeRegularTriangularSetGcdPackage|
  (progn
    (push '|SquareFreeRegularTriangularSetGcdPackage| *Packages*)
    (make-instance '|SquareFreeRegularTriangularSetGcdPackageType|)))

\end{chunk}

\subsection{StorageEfficientMatrixOperations}
\index[pkg]{StorageEfficientMatrixOperations!Domain}
\index[pkg]{Domain!StorageEfficientMatrixOperations}
\index[pkg]{MATSTOR}
\begin{chunk}{defclass StorageEfficientMatrixOperationsType}
(defclass |StorageEfficientMatrixOperationsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "StorageEfficientMatrixOperations")
   (marker :initform 'package)
   (abbreviation :initform 'MATSTOR)
   (comment :initform (list
     "This package provides standard arithmetic operations on matrices."
     "The functions in this package store the results of computations"
     "in existing matrices, rather than creating new matrices.  This"
     "package works only for matrices of type Matrix and uses the"
     "internal representation of this type."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StorageEfficientMatrixOperations|
  (progn
    (push '|StorageEfficientMatrixOperations| *Packages*)
    (make-instance '|StorageEfficientMatrixOperationsType|)))

\end{chunk}

\subsection{StreamFunctions1}
\index[pkg]{StreamFunctions1!Domain}
\index[pkg]{Domain!StreamFunctions1}
\index[pkg]{STREAM1}
\begin{chunk}{defclass StreamFunctions1Type}
(defclass |StreamFunctions1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "StreamFunctions1")
   (marker :initform 'package)
   (abbreviation :initform 'STREAM1)
   (comment :initform (list
     "Functions defined on streams with entries in one set."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StreamFunctions1|
  (progn
    (push '|StreamFunctions1| *Packages*)
    (make-instance '|StreamFunctions1Type|)))

\end{chunk}

\subsection{StreamFunctions2}
\index[pkg]{StreamFunctions2!Domain}
\index[pkg]{Domain!StreamFunctions2}
\index[pkg]{STREAM2}
\begin{chunk}{defclass StreamFunctions2Type}
(defclass |StreamFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "StreamFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'STREAM2)
   (comment :initform (list
     "Functions defined on streams with entries in two sets."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StreamFunctions2|
  (progn
    (push '|StreamFunctions2| *Packages*)
    (make-instance '|StreamFunctions2Type|)))

\end{chunk}

\subsection{StreamFunctions3}
\index[pkg]{StreamFunctions3!Domain}
\index[pkg]{Domain!StreamFunctions3}
\index[pkg]{STREAM3}
\begin{chunk}{defclass StreamFunctions3Type}
(defclass |StreamFunctions3Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "StreamFunctions3")
   (marker :initform 'package)
   (abbreviation :initform 'STREAM3)
   (comment :initform (list
     "Functions defined on streams with entries in three sets."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StreamFunctions3|
  (progn
    (push '|StreamFunctions3| *Packages*)
    (make-instance '|StreamFunctions3Type|)))

\end{chunk}

\subsection{StreamInfiniteProduct}
\index[pkg]{StreamInfiniteProduct!Domain}
\index[pkg]{Domain!StreamInfiniteProduct}
\index[pkg]{STINPROD}
\begin{chunk}{defclass StreamInfiniteProductType}
(defclass |StreamInfiniteProductType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "StreamInfiniteProduct")
   (marker :initform 'package)
   (abbreviation :initform 'STINPROD)
   (comment :initform (list
     "This package computes infinite products of Taylor series over an"
     "integral domain of characteristic 0.  Here Taylor series are"
     "represented by streams of Taylor coefficients."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StreamInfiniteProduct|
  (progn
    (push '|StreamInfiniteProduct| *Packages*)
    (make-instance '|StreamInfiniteProductType|)))

\end{chunk}

\subsection{StreamTaylorSeriesOperations}
\index[pkg]{StreamTaylorSeriesOperations!Domain}
\index[pkg]{Domain!StreamTaylorSeriesOperations}
\index[pkg]{STTAYLOR}
\begin{chunk}{defclass StreamTaylorSeriesOperationsType}
(defclass |StreamTaylorSeriesOperationsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "StreamTaylorSeriesOperations")
   (marker :initform 'package)
   (abbreviation :initform 'STTAYLOR)
   (comment :initform (list
     "StreamTaylorSeriesOperations implements Taylor series arithmetic,"
     "where a Taylor series is represented by a stream of its coefficients."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StreamTaylorSeriesOperations|
  (progn
    (push '|StreamTaylorSeriesOperations| *Packages*)
    (make-instance '|StreamTaylorSeriesOperationsType|)))

\end{chunk}

\subsection{StreamTensor}
\index[pkg]{StreamTensor!Domain}
\index[pkg]{Domain!StreamTensor}
\index[pkg]{STNSR}
\begin{chunk}{defclass StreamTensorType}
(defclass |StreamTensorType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "StreamTensor")
   (marker :initform 'package)
   (abbreviation :initform 'STNSR)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StreamTensor|
  (progn
    (push '|StreamTensor| *Packages*)
    (make-instance '|StreamTensorType|)))

\end{chunk}

\subsection{StreamTranscendentalFunctions}
\index[pkg]{StreamTranscendentalFunctions!Domain}
\index[pkg]{Domain!StreamTranscendentalFunctions}
\index[pkg]{STTF}
\begin{chunk}{defclass StreamTranscendentalFunctionsType}
(defclass |StreamTranscendentalFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "StreamTranscendentalFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'STTF)
   (comment :initform (list
     "StreamTranscendentalFunctions implements transcendental functions on"
     "Taylor series, where a Taylor series is represented by a stream of"
     "its coefficients."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StreamTranscendentalFunctions|
  (progn
    (push '|StreamTranscendentalFunctions| *Packages*)
    (make-instance '|StreamTranscendentalFunctionsType|)))

\end{chunk}

\subsection{StreamTranscendentalFunctionsNonCommutative}
\index[pkg]{StreamTranscendentalFunctionsNonCommutative!Domain}
\index[pkg]{Domain!StreamTranscendentalFunctionsNonCommutative}
\index[pkg]{STTFNC}
\begin{chunk}{defclass StreamTranscendentalFunctionsNonCommutativeType}
(defclass |StreamTranscendentalFunctionsNonCommutativeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "StreamTranscendentalFunctionsNonCommutative")
   (marker :initform 'package)
   (abbreviation :initform 'STTFNC)
   (comment :initform (list
     "StreamTranscendentalFunctionsNonCommutative implements transcendental"
     "functions on Taylor series over a non-commutative ring, where a Taylor"
     "series is represented by a stream of its coefficients."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StreamTranscendentalFunctionsNonCommutative|
  (progn
    (push '|StreamTranscendentalFunctionsNonCommutative| *Packages*)
    (make-instance '|StreamTranscendentalFunctionsNonCommutativeType|)))

\end{chunk}

\subsection{StructuralConstantsPackage}
\index[pkg]{StructuralConstantsPackage!Domain}
\index[pkg]{Domain!StructuralConstantsPackage}
\index[pkg]{SCPKG}
\begin{chunk}{defclass StructuralConstantsPackageType}
(defclass |StructuralConstantsPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "StructuralConstantsPackage")
   (marker :initform 'package)
   (abbreviation :initform 'SCPKG)
   (comment :initform (list
     "StructuralConstantsPackage provides functions creating"
     "structural constants from a multiplication tables or a basis"
     "of a matrix algebra and other useful functions in this context."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |StructuralConstantsPackage|
  (progn
    (push '|StructuralConstantsPackage| *Packages*)
    (make-instance '|StructuralConstantsPackageType|)))

\end{chunk}

\subsection{SturmHabichtPackage}
\index[pkg]{SturmHabichtPackage!Domain}
\index[pkg]{Domain!SturmHabichtPackage}
\index[pkg]{SHP}
\begin{chunk}{defclass SturmHabichtPackageType}
(defclass |SturmHabichtPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SturmHabichtPackage")
   (marker :initform 'package)
   (abbreviation :initform 'SHP)
   (comment :initform (list
     "This package produces functions for counting etc. real roots of univariate"
     "polynomials in x over R, which must be an OrderedIntegralDomain"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SturmHabichtPackage|
  (progn
    (push '|SturmHabichtPackage| *Packages*)
    (make-instance '|SturmHabichtPackageType|)))

\end{chunk}

\subsection{SubResultantPackage}
\index[pkg]{SubResultantPackage!Domain}
\index[pkg]{Domain!SubResultantPackage}
\index[pkg]{SUBRESP}
\begin{chunk}{defclass SubResultantPackageType}
(defclass |SubResultantPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SubResultantPackage")
   (marker :initform 'package)
   (abbreviation :initform 'SUBRESP)
   (comment :initform (list
     "This package computes the subresultants of two polynomials which is needed"
     "for the `Lazard Rioboo' enhancement to Tragers integrations formula"
     "For efficiency reasons this has been rewritten to call Lionel Ducos"
     "package which is currently the best one."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SubResultantPackage|
  (progn
    (push '|SubResultantPackage| *Packages*)
    (make-instance '|SubResultantPackageType|)))

\end{chunk}

\subsection{SupFractionFactorizer}
\index[pkg]{SupFractionFactorizer!Domain}
\index[pkg]{Domain!SupFractionFactorizer}
\index[pkg]{SUPFRACF}
\begin{chunk}{defclass SupFractionFactorizerType}
(defclass |SupFractionFactorizerType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SupFractionFactorizer")
   (marker :initform 'package)
   (abbreviation :initform 'SUPFRACF)
   (comment :initform (list
     "SupFractionFactorize  contains the factor function for univariate"
     "polynomials over the quotient field of a ring S such that the package"
     "MultivariateFactorize works for S"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SupFractionFactorizer|
  (progn
    (push '|SupFractionFactorizer| *Packages*)
    (make-instance '|SupFractionFactorizerType|)))

\end{chunk}

\subsection{SystemODESolver}
\index[pkg]{SystemODESolver!Domain}
\index[pkg]{Domain!SystemODESolver}
\index[pkg]{ODESYS}
\begin{chunk}{defclass SystemODESolverType}
(defclass |SystemODESolverType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SystemODESolver")
   (marker :initform 'package)
   (abbreviation :initform 'ODESYS)
   (comment :initform (list
     "SystemODESolver provides tools for triangulating"
     "and solving some systems of linear ordinary differential equations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SystemODESolver|
  (progn
    (push '|SystemODESolver| *Packages*)
    (make-instance '|SystemODESolverType|)))

\end{chunk}

\subsection{SystemSolvePackage}
\index[pkg]{SystemSolvePackage!Domain}
\index[pkg]{Domain!SystemSolvePackage}
\index[pkg]{SYSSOLP}
\begin{chunk}{defclass SystemSolvePackageType}
(defclass |SystemSolvePackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SystemSolvePackage")
   (marker :initform 'package)
   (abbreviation :initform 'SYSSOLP)
   (comment :initform (list
     "Symbolic solver for systems of rational functions with coefficients"
     "in an integral domain R."
     "The systems are solved in the field of rational functions over R."
     "Solutions are exact of the form variable = value when the value is"
     "a member of the coefficient domain R. Otherwise the solutions"
     "are implicitly expressed as roots of univariate polynomial equations over R."
     "Care is taken to guarantee that the denominators of the input"
     "equations do not vanish on the solution sets."
     "The arguments to solve can either be given as equations or"
     "as rational functions interpreted as equal"
     "to zero. The user can specify an explicit list of symbols to"
     "be solved for, treating all other symbols appearing as parameters"
     "or omit the list of symbols in which case the system tries to"
     "solve with respect to all symbols appearing in the input."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SystemSolvePackage|
  (progn
    (push '|SystemSolvePackage| *Packages*)
    (make-instance '|SystemSolvePackageType|)))

\end{chunk}

\subsection{SymmetricGroupCombinatoricFunctions}
\index[pkg]{SymmetricGroupCombinatoricFunctions!Domain}
\index[pkg]{Domain!SymmetricGroupCombinatoricFunctions}
\index[pkg]{SGCF}
\begin{chunk}{defclass SymmetricGroupCombinatoricFunctionsType}
(defclass |SymmetricGroupCombinatoricFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SymmetricGroupCombinatoricFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'SGCF)
   (comment :initform (list
     "SymmetricGroupCombinatoricFunctions contains combinatoric"
     "functions concerning symmetric groups and representation"
     "theory: list young tableaus, improper partitions, subsets"
     "bijection of Coleman."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SymmetricGroupCombinatoricFunctions|
  (progn
    (push '|SymmetricGroupCombinatoricFunctions| *Packages*)
    (make-instance '|SymmetricGroupCombinatoricFunctionsType|)))

\end{chunk}

\subsection{SymmetricFunctions}
\index[pkg]{SymmetricFunctions!Domain}
\index[pkg]{Domain!SymmetricFunctions}
\index[pkg]{SYMFUNC}
\begin{chunk}{defclass SymmetricFunctionsType}
(defclass |SymmetricFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "SymmetricFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'SYMFUNC)
   (comment :initform (list
     "Computes all the symmetric functions in n variables."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |SymmetricFunctions|
  (progn
    (push '|SymmetricFunctions| *Packages*)
    (make-instance '|SymmetricFunctionsType|)))

\end{chunk}

\section{T}

\subsection{TableauxBumpers}
\index[pkg]{TableauxBumpers!Domain}
\index[pkg]{Domain!TableauxBumpers}
\index[pkg]{TABLBUMP}
\begin{chunk}{defclass TableauxBumpersType}
(defclass |TableauxBumpersType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TableauxBumpers")
   (marker :initform 'package)
   (abbreviation :initform 'TABLBUMP)
   (comment :initform (list
     "TableauBumpers implements the Schenstead-Knuth"
     "correspondence between sequences and pairs of Young tableaux."
     "The 2 Young tableaux are represented as a single tableau with"
     "pairs as components."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TableauxBumpers|
  (progn
    (push '|TableauxBumpers| *Packages*)
    (make-instance '|TableauxBumpersType|)))

\end{chunk}

\subsection{TabulatedComputationPackage}
\index[pkg]{TabulatedComputationPackage!Domain}
\index[pkg]{Domain!TabulatedComputationPackage}
\index[pkg]{TBCMPPK}
\begin{chunk}{defclass TabulatedComputationPackageType}
(defclass |TabulatedComputationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TabulatedComputationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'TBCMPPK)
   (comment :initform (list
     "TabulatedComputationPackage(Key ,Entry) provides some modest support"
     "for dealing with operations with type Key -> Entry. The result of"
     "such operations can be stored and retrieved with this package by using"
     "a hash-table. The user does not need to worry about the management of"
     "this hash-table. However, onnly one hash-table is built by calling"
     "TabulatedComputationPackage(Key ,Entry)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TabulatedComputationPackage|
  (progn
    (push '|TabulatedComputationPackage| *Packages*)
    (make-instance '|TabulatedComputationPackageType|)))

\end{chunk}

\subsection{TangentExpansions}
\index[pkg]{TangentExpansions!Domain}
\index[pkg]{Domain!TangentExpansions}
\index[pkg]{TANEXP}
\begin{chunk}{defclass TangentExpansionsType}
(defclass |TangentExpansionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TangentExpansions")
   (marker :initform 'package)
   (abbreviation :initform 'TANEXP)
   (comment :initform (list
     "Expands tangents of sums and scalar products."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TangentExpansions|
  (progn
    (push '|TangentExpansions| *Packages*)
    (make-instance '|TangentExpansionsType|)))

\end{chunk}

\subsection{TaylorSolve}
\index[pkg]{TaylorSolve!Domain}
\index[pkg]{Domain!TaylorSolve}
\index[pkg]{UTSSOL}
\begin{chunk}{defclass TaylorSolveType}
(defclass |TaylorSolveType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TaylorSolve")
   (marker :initform 'package)
   (abbreviation :initform 'UTSSOL)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TaylorSolve|
  (progn
    (push '|TaylorSolve| *Packages*)
    (make-instance '|TaylorSolveType|)))

\end{chunk}

\subsection{TemplateUtilities}
\index[pkg]{TemplateUtilities!Domain}
\index[pkg]{Domain!TemplateUtilities}
\index[pkg]{TEMUTL}
\begin{chunk}{defclass TemplateUtilitiesType}
(defclass |TemplateUtilitiesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TemplateUtilities")
   (marker :initform 'package)
   (abbreviation :initform 'TEMUTL)
   (comment :initform (list
     "This package provides functions for template manipulation"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TemplateUtilities|
  (progn
    (push '|TemplateUtilities| *Packages*)
    (make-instance '|TemplateUtilitiesType|)))

\end{chunk}

\subsection{TexFormat1}
\index[pkg]{TexFormat1!Domain}
\index[pkg]{Domain!TexFormat1}
\index[pkg]{TEX1}
\begin{chunk}{defclass TexFormat1Type}
(defclass |TexFormat1Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TexFormat1")
   (marker :initform 'package)
   (abbreviation :initform 'TEX1)
   (comment :initform (list
     "TexFormat1 provides a utility coercion for changing"
     "to TeX format anything that has a coercion to the standard output format."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TexFormat1|
  (progn
    (push '|TexFormat1| *Packages*)
    (make-instance '|TexFormat1Type|)))

\end{chunk}

\subsection{ToolsForSign}
\index[pkg]{ToolsForSign!Domain}
\index[pkg]{Domain!ToolsForSign}
\index[pkg]{TOOLSIGN}
\begin{chunk}{defclass ToolsForSignType}
(defclass |ToolsForSignType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ToolsForSign")
   (marker :initform 'package)
   (abbreviation :initform 'TOOLSIGN)
   (comment :initform (list
     "Tools for the sign finding utilities."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ToolsForSign|
  (progn
    (push '|ToolsForSign| *Packages*)
    (make-instance '|ToolsForSignType|)))

\end{chunk}

\subsection{TopLevelDrawFunctions}
\index[pkg]{TopLevelDrawFunctions!Domain}
\index[pkg]{Domain!TopLevelDrawFunctions}
\index[pkg]{DRAW}
\begin{chunk}{defclass TopLevelDrawFunctionsType}
(defclass |TopLevelDrawFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TopLevelDrawFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'DRAW)
   (comment :initform (list
     "TopLevelDrawFunctions provides top level functions for"
     "drawing graphics of expressions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TopLevelDrawFunctions|
  (progn
    (push '|TopLevelDrawFunctions| *Packages*)
    (make-instance '|TopLevelDrawFunctionsType|)))

\end{chunk}

\subsection{TopLevelDrawFunctionsForAlgebraicCurves}
\index[pkg]{TopLevelDrawFunctionsForAlgebraicCurves!Domain}
\index[pkg]{Domain!TopLevelDrawFunctionsForAlgebraicCurves}
\index[pkg]{DRAWCURV}
\begin{chunk}{defclass TopLevelDrawFunctionsForAlgebraicCurvesType}
(defclass |TopLevelDrawFunctionsForAlgebraicCurvesType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TopLevelDrawFunctionsForAlgebraicCurves")
   (marker :initform 'package)
   (abbreviation :initform 'DRAWCURV)
   (comment :initform (list
     "TopLevelDrawFunctionsForAlgebraicCurves provides top level"
     "functions for drawing non-singular algebraic curves."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TopLevelDrawFunctionsForAlgebraicCurves|
  (progn
    (push '|TopLevelDrawFunctionsForAlgebraicCurves| *Packages*)
    (make-instance '|TopLevelDrawFunctionsForAlgebraicCurvesType|)))

\end{chunk}

\subsection{TopLevelDrawFunctionsForCompiledFunctions}
\index[pkg]{TopLevelDrawFunctionsForCompiledFunctions!Domain}
\index[pkg]{Domain!TopLevelDrawFunctionsForCompiledFunctions}
\index[pkg]{DRAWCFUN}
\begin{chunk}{defclass TopLevelDrawFunctionsForCompiledFunctionsType}
(defclass |TopLevelDrawFunctionsForCompiledFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TopLevelDrawFunctionsForCompiledFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'DRAWCFUN)
   (comment :initform (list
     "TopLevelDrawFunctionsForCompiledFunctions provides top level"
     "functions for drawing graphics of expressions."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TopLevelDrawFunctionsForCompiledFunctions|
  (progn
    (push '|TopLevelDrawFunctionsForCompiledFunctions| *Packages*)
    (make-instance '|TopLevelDrawFunctionsForCompiledFunctionsType|)))

\end{chunk}

\subsection{TopLevelDrawFunctionsForPoints}
\index[pkg]{TopLevelDrawFunctionsForPoints!Domain}
\index[pkg]{Domain!TopLevelDrawFunctionsForPoints}
\index[pkg]{DRAWPT}
\begin{chunk}{defclass TopLevelDrawFunctionsForPointsType}
(defclass |TopLevelDrawFunctionsForPointsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TopLevelDrawFunctionsForPoints")
   (marker :initform 'package)
   (abbreviation :initform 'DRAWPT)
   (comment :initform (list
     "TopLevelDrawFunctionsForPoints provides top level functions"
     "for drawing curves and surfaces described by sets of points."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TopLevelDrawFunctionsForPoints|
  (progn
    (push '|TopLevelDrawFunctionsForPoints| *Packages*)
    (make-instance '|TopLevelDrawFunctionsForPointsType|)))

\end{chunk}

\subsection{TopLevelThreeSpace}
\index[pkg]{TopLevelThreeSpace!Domain}
\index[pkg]{Domain!TopLevelThreeSpace}
\index[pkg]{TOPSP}
\begin{chunk}{defclass TopLevelThreeSpaceType}
(defclass |TopLevelThreeSpaceType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TopLevelThreeSpace")
   (marker :initform 'package)
   (abbreviation :initform 'TOPSP)
   (comment :initform (list
     "This package exports a function for making a ThreeSpace"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TopLevelThreeSpace|
  (progn
    (push '|TopLevelThreeSpace| *Packages*)
    (make-instance '|TopLevelThreeSpaceType|)))

\end{chunk}

\subsection{TranscendentalHermiteIntegration}
\index[pkg]{TranscendentalHermiteIntegration!Domain}
\index[pkg]{Domain!TranscendentalHermiteIntegration}
\index[pkg]{INTHERTR}
\begin{chunk}{defclass TranscendentalHermiteIntegrationType}
(defclass |TranscendentalHermiteIntegrationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TranscendentalHermiteIntegration")
   (marker :initform 'package)
   (abbreviation :initform 'INTHERTR)
   (comment :initform (list
     "Hermite integration, transcendental case."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TranscendentalHermiteIntegration|
  (progn
    (push '|TranscendentalHermiteIntegration| *Packages*)
    (make-instance '|TranscendentalHermiteIntegrationType|)))

\end{chunk}

\subsection{TranscendentalIntegration}
\index[pkg]{TranscendentalIntegration!Domain}
\index[pkg]{Domain!TranscendentalIntegration}
\index[pkg]{INTTR}
\begin{chunk}{defclass TranscendentalIntegrationType}
(defclass |TranscendentalIntegrationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TranscendentalIntegration")
   (marker :initform 'package)
   (abbreviation :initform 'INTTR)
   (comment :initform (list
     "This package provides functions for the transcendental"
     "case of the Risch algorithm."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TranscendentalIntegration|
  (progn
    (push '|TranscendentalIntegration| *Packages*)
    (make-instance '|TranscendentalIntegrationType|)))

\end{chunk}

\subsection{TranscendentalManipulations}
\index[pkg]{TranscendentalManipulations!Domain}
\index[pkg]{Domain!TranscendentalManipulations}
\index[pkg]{TRMANIP}
\begin{chunk}{defclass TranscendentalManipulationsType}
(defclass |TranscendentalManipulationsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TranscendentalManipulations")
   (marker :initform 'package)
   (abbreviation :initform 'TRMANIP)
   (comment :initform (list
     "TranscendentalManipulations provides functions to simplify and"
     "expand expressions involving transcendental operators."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TranscendentalManipulations|
  (progn
    (push '|TranscendentalManipulations| *Packages*)
    (make-instance '|TranscendentalManipulationsType|)))

\end{chunk}

\subsection{TranscendentalRischDE}
\index[pkg]{TranscendentalRischDE!Domain}
\index[pkg]{Domain!TranscendentalRischDE}
\index[pkg]{RDETR}
\begin{chunk}{defclass TranscendentalRischDEType}
(defclass |TranscendentalRischDEType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TranscendentalRischDE")
   (marker :initform 'package)
   (abbreviation :initform 'RDETR)
   (comment :initform (list
     "Risch differential equation, transcendental case."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TranscendentalRischDE|
  (progn
    (push '|TranscendentalRischDE| *Packages*)
    (make-instance '|TranscendentalRischDEType|)))

\end{chunk}

\subsection{TranscendentalRischDESystem}
\index[pkg]{TranscendentalRischDESystem!Domain}
\index[pkg]{Domain!TranscendentalRischDESystem}
\index[pkg]{RDETRS}
\begin{chunk}{defclass TranscendentalRischDESystemType}
(defclass |TranscendentalRischDESystemType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TranscendentalRischDESystem")
   (marker :initform 'package)
   (abbreviation :initform 'RDETRS)
   (comment :initform (list
     "Risch differential equation system, transcendental case."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TranscendentalRischDESystem|
  (progn
    (push '|TranscendentalRischDESystem| *Packages*)
    (make-instance '|TranscendentalRischDESystemType|)))

\end{chunk}

\subsection{TransSolvePackage}
\index[pkg]{TransSolvePackage!Domain}
\index[pkg]{Domain!TransSolvePackage}
\index[pkg]{SOLVETRA}
\begin{chunk}{defclass TransSolvePackageType}
(defclass |TransSolvePackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TransSolvePackage")
   (marker :initform 'package)
   (abbreviation :initform 'SOLVETRA)
   (comment :initform (list
     "This package tries to find solutions of equations of type Expression(R)."
     "This means expressions involving transcendental, exponential, logarithmic"
     "and nthRoot functions."
     "After trying to transform different kernels to one kernel by applying"
     "several rules, it calls zerosOf for the SparseUnivariatePolynomial in"
     "the remaining kernel."
     "For example the expression sin(x)*cos(x)-2 will be transformed to"
     "-2 tan(x/2)**4 -2 tan(x/2)**3 -4 tan(x/2)**2 +2 tan(x/2) -2"
     "by using the function normalize and then to"
     "-2 tan(x)**2 + tan(x) -2"
     "with help of subsTan. This function tries to express the given function"
     "in terms of tan(x/2) to express in terms of tan(x)."
     "Other examples are the expressions sqrt(x+1)+sqrt(x+7)+1 or"
     "sqrt(sin(x))+1 ."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TransSolvePackage|
  (progn
    (push '|TransSolvePackage| *Packages*)
    (make-instance '|TransSolvePackageType|)))

\end{chunk}

\subsection{TransSolvePackageService}
\index[pkg]{TransSolvePackageService!Domain}
\index[pkg]{Domain!TransSolvePackageService}
\index[pkg]{SOLVESER}
\begin{chunk}{defclass TransSolvePackageServiceType}
(defclass |TransSolvePackageServiceType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TransSolvePackageService")
   (marker :initform 'package)
   (abbreviation :initform 'SOLVESER)
   (comment :initform (list
     "This package finds the function func3 where  func1 and func2"
     "are given and  func1 = func3(func2) .  If there is no solution then"
     "function func1 will be returned."
     "An example would be func1:= 8*X**3+32*X**2-14*X ::EXPR INT and"
     "func2:=2*X ::EXPR INT convert them via univariate"
     "to FRAC SUP EXPR INT and then the solution is func3:=X**3+X**2-X"
     "of type FRAC SUP EXPR INT"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TransSolvePackageService|
  (progn
    (push '|TransSolvePackageService| *Packages*)
    (make-instance '|TransSolvePackageServiceType|)))

\end{chunk}

\subsection{TriangularMatrixOperations}
\index[pkg]{TriangularMatrixOperations!Domain}
\index[pkg]{Domain!TriangularMatrixOperations}
\index[pkg]{TRIMAT}
\begin{chunk}{defclass TriangularMatrixOperationsType}
(defclass |TriangularMatrixOperationsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TriangularMatrixOperations")
   (marker :initform 'package)
   (abbreviation :initform 'TRIMAT)
   (comment :initform (list
     "This package provides functions that compute 'fraction-free'"
     "inverses of upper and lower triangular matrices over a integral"
     "domain.  By 'fraction-free inverses' we mean the following:"
     "given a matrix B with entries in R and an element d of R such that"
     "d * inv(B) also has entries in R, we return d * inv(B).  Thus,"
     "it is not necessary to pass to the quotient field in any of our"
     "computations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TriangularMatrixOperations|
  (progn
    (push '|TriangularMatrixOperations| *Packages*)
    (make-instance '|TriangularMatrixOperationsType|)))

\end{chunk}

\subsection{TrigonometricManipulations}
\index[pkg]{TrigonometricManipulations!Domain}
\index[pkg]{Domain!TrigonometricManipulations}
\index[pkg]{TRIGMNIP}
\begin{chunk}{defclass TrigonometricManipulationsType}
(defclass |TrigonometricManipulationsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TrigonometricManipulations")
   (marker :initform 'package)
   (abbreviation :initform 'TRIGMNIP)
   (comment :initform (list
     "TrigonometricManipulations provides transformations from"
     "trigonometric functions to complex exponentials and logarithms, and back."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TrigonometricManipulations|
  (progn
    (push '|TrigonometricManipulations| *Packages*)
    (make-instance '|TrigonometricManipulationsType|)))

\end{chunk}

\subsection{TubePlotTools}
\index[pkg]{TubePlotTools!Domain}
\index[pkg]{Domain!TubePlotTools}
\index[pkg]{TUBETOOL}
\begin{chunk}{defclass TubePlotToolsType}
(defclass |TubePlotToolsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TubePlotTools")
   (marker :initform 'package)
   (abbreviation :initform 'TUBETOOL)
   (comment :initform (list
     "Tools for constructing tubes around 3-dimensional parametric curves."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TubePlotTools|
  (progn
    (push '|TubePlotTools| *Packages*)
    (make-instance '|TubePlotToolsType|)))

\end{chunk}

\subsection{TwoDimensionalPlotClipping}
\index[pkg]{TwoDimensionalPlotClipping!Domain}
\index[pkg]{Domain!TwoDimensionalPlotClipping}
\index[pkg]{CLIP}
\begin{chunk}{defclass TwoDimensionalPlotClippingType}
(defclass |TwoDimensionalPlotClippingType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TwoDimensionalPlotClipping")
   (marker :initform 'package)
   (abbreviation :initform 'CLIP)
   (comment :initform (list
     "Automatic clipping for 2-dimensional plots"
     "The purpose of this package is to provide reasonable plots of"
     "functions with singularities."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TwoDimensionalPlotClipping|
  (progn
    (push '|TwoDimensionalPlotClipping| *Packages*)
    (make-instance '|TwoDimensionalPlotClippingType|)))

\end{chunk}

\subsection{TwoFactorize}
\index[pkg]{TwoFactorize!Domain}
\index[pkg]{Domain!TwoFactorize}
\index[pkg]{TWOFACT}
\begin{chunk}{defclass TwoFactorizeType}
(defclass |TwoFactorizeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "TwoFactorize")
   (marker :initform 'package)
   (abbreviation :initform 'TWOFACT)
   (comment :initform (list
     "A basic package for the factorization of bivariate polynomials"
     "over a finite field."
     "The functions here represent the base step for the multivariate factorizer."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |TwoFactorize|
  (progn
    (push '|TwoFactorize| *Packages*)
    (make-instance '|TwoFactorizeType|)))

\end{chunk}

\section{U}

\subsection{UnivariateFactorize}
\index[pkg]{UnivariateFactorize!Domain}
\index[pkg]{Domain!UnivariateFactorize}
\index[pkg]{UNIFACT}
\begin{chunk}{defclass UnivariateFactorizeType}
(defclass |UnivariateFactorizeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UnivariateFactorize")
   (marker :initform 'package)
   (abbreviation :initform 'UNIFACT)
   (comment :initform (list
     "Package for the factorization of univariate polynomials with integer"
     "coefficients. The factorization is done by 'lifting' (HENSEL) the"
     "factorization over a finite field."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateFactorize|
  (progn
    (push '|UnivariateFactorize| *Packages*)
    (make-instance '|UnivariateFactorizeType|)))

\end{chunk}

\subsection{UnivariateFormalPowerSeriesFunctions}
\index[pkg]{UnivariateFormalPowerSeriesFunctions!Domain}
\index[pkg]{Domain!UnivariateFormalPowerSeriesFunctions}
\index[pkg]{UFPS1}
\begin{chunk}{defclass UnivariateFormalPowerSeriesFunctionsType}
(defclass |UnivariateFormalPowerSeriesFunctionsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UnivariateFormalPowerSeriesFunctions")
   (marker :initform 'package)
   (abbreviation :initform 'UFPS1)
   (comment :initform (list
     "This package has no description"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateFormalPowerSeriesFunctions|
  (progn
    (push '|UnivariateFormalPowerSeriesFunctions| *Packages*)
    (make-instance '|UnivariateFormalPowerSeriesFunctionsType|)))

\end{chunk}

\subsection{UnivariateLaurentSeriesFunctions2}
\index[pkg]{UnivariateLaurentSeriesFunctions2!Domain}
\index[pkg]{Domain!UnivariateLaurentSeriesFunctions2}
\index[pkg]{ULS2}
\begin{chunk}{defclass UnivariateLaurentSeriesFunctions2Type}
(defclass |UnivariateLaurentSeriesFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UnivariateLaurentSeriesFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'ULS2)
   (comment :initform (list
     "Mapping package for univariate Laurent series"
     "This package allows one to apply a function to the coefficients of"
     "a univariate Laurent series."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateLaurentSeriesFunctions2|
  (progn
    (push '|UnivariateLaurentSeriesFunctions2| *Packages*)
    (make-instance '|UnivariateLaurentSeriesFunctions2Type|)))

\end{chunk}

\subsection{UnivariatePolynomialCategoryFunctions2}
\index[pkg]{UnivariatePolynomialCategoryFunctions2!Domain}
\index[pkg]{Domain!UnivariatePolynomialCategoryFunctions2}
\index[pkg]{UPOLYC2}
\begin{chunk}{defclass UnivariatePolynomialCategoryFunctions2Type}
(defclass |UnivariatePolynomialCategoryFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UnivariatePolynomialCategoryFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'UPOLYC2)
   (comment :initform (list
     "Mapping from polynomials over R to polynomials over S"
     "given a map from R to S assumed to send zero to zero."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePolynomialCategoryFunctions2|
  (progn
    (push '|UnivariatePolynomialCategoryFunctions2| *Packages*)
    (make-instance '|UnivariatePolynomialCategoryFunctions2Type|)))

\end{chunk}

\subsection{UnivariatePolynomialCommonDenominator}
\index[pkg]{UnivariatePolynomialCommonDenominator!Domain}
\index[pkg]{Domain!UnivariatePolynomialCommonDenominator}
\index[pkg]{UPCDEN}
\begin{chunk}{defclass UnivariatePolynomialCommonDenominatorType}
(defclass |UnivariatePolynomialCommonDenominatorType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UnivariatePolynomialCommonDenominator")
   (marker :initform 'package)
   (abbreviation :initform 'UPCDEN)
   (comment :initform (list
     "UnivariatePolynomialCommonDenominator provides"
     "functions to compute the common denominator of the coefficients of"
     "univariate polynomials over the quotient field of a gcd domain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePolynomialCommonDenominator|
  (progn
    (push '|UnivariatePolynomialCommonDenominator| *Packages*)
    (make-instance '|UnivariatePolynomialCommonDenominatorType|)))

\end{chunk}

\subsection{UnivariatePolynomialDecompositionPackage}
\index[pkg]{UnivariatePolynomialDecompositionPackage!Domain}
\index[pkg]{Domain!UnivariatePolynomialDecompositionPackage}
\index[pkg]{UPDECOMP}
\begin{chunk}{defclass UnivariatePolynomialDecompositionPackageType}
(defclass |UnivariatePolynomialDecompositionPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UnivariatePolynomialDecompositionPackage")
   (marker :initform 'package)
   (abbreviation :initform 'UPDECOMP)
   (comment :initform (list
     "UnivariatePolynomialDecompositionPackage implements"
     "functional decomposition of univariate polynomial with coefficients"
     "in an IntegralDomain of CharacteristicZero."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePolynomialDecompositionPackage|
  (progn
    (push '|UnivariatePolynomialDecompositionPackage| *Packages*)
    (make-instance '|UnivariatePolynomialDecompositionPackageType|)))

\end{chunk}

\subsection{UnivariatePolynomialDivisionPackage}
\index[pkg]{UnivariatePolynomialDivisionPackage!Domain}
\index[pkg]{Domain!UnivariatePolynomialDivisionPackage}
\index[pkg]{UPDIVP}
\begin{chunk}{defclass UnivariatePolynomialDivisionPackageType}
(defclass |UnivariatePolynomialDivisionPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UnivariatePolynomialDivisionPackage")
   (marker :initform 'package)
   (abbreviation :initform 'UPDIVP)
   (comment :initform (list
     "UnivariatePolynomialDivisionPackage provides a"
     "division for non monic univarite polynomials with coefficients in"
     "an IntegralDomain."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePolynomialDivisionPackage|
  (progn
    (push '|UnivariatePolynomialDivisionPackage| *Packages*)
    (make-instance '|UnivariatePolynomialDivisionPackageType|)))

\end{chunk}

\subsection{UnivariatePolynomialFunctions2}
\index[pkg]{UnivariatePolynomialFunctions2!Domain}
\index[pkg]{Domain!UnivariatePolynomialFunctions2}
\index[pkg]{UP2}
\begin{chunk}{defclass UnivariatePolynomialFunctions2Type}
(defclass |UnivariatePolynomialFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UnivariatePolynomialFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'UP2)
   (comment :initform (list
     "This package lifts a mapping from coefficient rings R to S to"
     "a mapping from UnivariatePolynomial(x,R) to"
     "UnivariatePolynomial(y,S). Note that the mapping is assumed"
     "to send zero to zero, since it will only be applied to the non-zero"
     "coefficients of the polynomial."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePolynomialFunctions2|
  (progn
    (push '|UnivariatePolynomialFunctions2| *Packages*)
    (make-instance '|UnivariatePolynomialFunctions2Type|)))

\end{chunk}

\subsection{UnivariatePolynomialMultiplicationPackage}
\index[pkg]{UnivariatePolynomialMultiplicationPackage!Domain}
\index[pkg]{Domain!UnivariatePolynomialMultiplicationPackage}
\index[pkg]{UPMP}
\begin{chunk}{defclass UnivariatePolynomialMultiplicationPackageType}
(defclass |UnivariatePolynomialMultiplicationPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UnivariatePolynomialMultiplicationPackage")
   (marker :initform 'package)
   (abbreviation :initform 'UPMP)
   (comment :initform (list
     "This package implements Karatsuba's trick for multiplying"
     "(large) univariate polynomials. It could be improved with"
     "a version doing the work on place and also with a special"
     "case for squares. We've done this in Basicmath, but we"
     "believe that this out of the scope of AXIOM."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePolynomialMultiplicationPackage|
  (progn
    (push '|UnivariatePolynomialMultiplicationPackage| *Packages*)
    (make-instance '|UnivariatePolynomialMultiplicationPackageType|)))

\end{chunk}

\subsection{UnivariatePolynomialSquareFree}
\index[pkg]{UnivariatePolynomialSquareFree!Domain}
\index[pkg]{Domain!UnivariatePolynomialSquareFree}
\index[pkg]{UPSQFREE}
\begin{chunk}{defclass UnivariatePolynomialSquareFreeType}
(defclass |UnivariatePolynomialSquareFreeType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UnivariatePolynomialSquareFree")
   (marker :initform 'package)
   (abbreviation :initform 'UPSQFREE)
   (comment :initform (list
     "This package provides for square-free decomposition of"
     "univariate polynomials over arbitrary rings,"
     "a partial factorization such that each factor is a product"
     "of irreducibles with multiplicity one and the factors are"
     "pairwise relatively prime. If the ring"
     "has characteristic zero, the result is guaranteed to satisfy"
     "this condition. If the ring is an infinite ring of"
     "finite characteristic, then it may not be possible to decide when"
     "polynomials contain factors which are pth powers. In this"
     "case, the flag associated with that polynomial is set to 'nil'"
     "(meaning that that polynomials are not guaranteed to be square-free)."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePolynomialSquareFree|
  (progn
    (push '|UnivariatePolynomialSquareFree| *Packages*)
    (make-instance '|UnivariatePolynomialSquareFreeType|)))

\end{chunk}

\subsection{UnivariatePuiseuxSeriesFunctions2}
\index[pkg]{UnivariatePuiseuxSeriesFunctions2!Domain}
\index[pkg]{Domain!UnivariatePuiseuxSeriesFunctions2}
\index[pkg]{UPXS2}
\begin{chunk}{defclass UnivariatePuiseuxSeriesFunctions2Type}
(defclass |UnivariatePuiseuxSeriesFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UnivariatePuiseuxSeriesFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'UPXS2)
   (comment :initform (list
     "Mapping package for univariate Puiseux series."
     "This package allows one to apply a function to the coefficients of"
     "a univariate Puiseux series."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariatePuiseuxSeriesFunctions2|
  (progn
    (push '|UnivariatePuiseuxSeriesFunctions2| *Packages*)
    (make-instance '|UnivariatePuiseuxSeriesFunctions2Type|)))

\end{chunk}

\subsection{UnivariateSkewPolynomialCategoryOps}
\index[pkg]{UnivariateSkewPolynomialCategoryOps!Domain}
\index[pkg]{Domain!UnivariateSkewPolynomialCategoryOps}
\index[pkg]{OREPCTO}
\begin{chunk}{defclass UnivariateSkewPolynomialCategoryOpsType}
(defclass |UnivariateSkewPolynomialCategoryOpsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UnivariateSkewPolynomialCategoryOps")
   (marker :initform 'package)
   (abbreviation :initform 'OREPCTO)
   (comment :initform (list
     "UnivariateSkewPolynomialCategoryOps provides products and"
     "divisions of univariate skew polynomials."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateSkewPolynomialCategoryOps|
  (progn
    (push '|UnivariateSkewPolynomialCategoryOps| *Packages*)
    (make-instance '|UnivariateSkewPolynomialCategoryOpsType|)))

\end{chunk}

\subsection{UnivariateTaylorSeriesFunctions2}
\index[pkg]{UnivariateTaylorSeriesFunctions2!Domain}
\index[pkg]{Domain!UnivariateTaylorSeriesFunctions2}
\index[pkg]{UTS2}
\begin{chunk}{defclass UnivariateTaylorSeriesFunctions2Type}
(defclass |UnivariateTaylorSeriesFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UnivariateTaylorSeriesFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'UTS2)
   (comment :initform (list
     "Mapping package for univariate Taylor series."
     "This package allows one to apply a function to the coefficients of"
     "a univariate Taylor series."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateTaylorSeriesFunctions2|
  (progn
    (push '|UnivariateTaylorSeriesFunctions2| *Packages*)
    (make-instance '|UnivariateTaylorSeriesFunctions2Type|)))

\end{chunk}

\subsection{UnivariateTaylorSeriesODESolver}
\index[pkg]{UnivariateTaylorSeriesODESolver!Domain}
\index[pkg]{Domain!UnivariateTaylorSeriesODESolver}
\index[pkg]{UTSODE}
\begin{chunk}{defclass UnivariateTaylorSeriesODESolverType}
(defclass |UnivariateTaylorSeriesODESolverType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UnivariateTaylorSeriesODESolver")
   (marker :initform 'package)
   (abbreviation :initform 'UTSODE)
   (comment :initform (list
     "Taylor series solutions of explicit ODE's."
     "This package provides Taylor series solutions to regular"
     "linear or non-linear ordinary differential equations of"
     "arbitrary order."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UnivariateTaylorSeriesODESolver|
  (progn
    (push '|UnivariateTaylorSeriesODESolver| *Packages*)
    (make-instance '|UnivariateTaylorSeriesODESolverType|)))

\end{chunk}

\subsection{UniversalSegmentFunctions2}
\index[pkg]{UniversalSegmentFunctions2!Domain}
\index[pkg]{Domain!UniversalSegmentFunctions2}
\index[pkg]{UNISEG2}
\begin{chunk}{defclass UniversalSegmentFunctions2Type}
(defclass |UniversalSegmentFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UniversalSegmentFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'UNISEG2)
   (comment :initform (list
     "This package provides operations for mapping functions onto segments."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UniversalSegmentFunctions2|
  (progn
    (push '|UniversalSegmentFunctions2| *Packages*)
    (make-instance '|UniversalSegmentFunctions2Type|)))

\end{chunk}

\subsection{UserDefinedPartialOrdering}
\index[pkg]{UserDefinedPartialOrdering!Domain}
\index[pkg]{Domain!UserDefinedPartialOrdering}
\index[pkg]{UDPO}
\begin{chunk}{defclass UserDefinedPartialOrderingType}
(defclass |UserDefinedPartialOrderingType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UserDefinedPartialOrdering")
   (marker :initform 'package)
   (abbreviation :initform 'UDPO)
   (comment :initform (list
     "Provides functions to force a partial ordering on any set."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UserDefinedPartialOrdering|
  (progn
    (push '|UserDefinedPartialOrdering| *Packages*)
    (make-instance '|UserDefinedPartialOrderingType|)))

\end{chunk}

\subsection{UserDefinedVariableOrdering}
\index[pkg]{UserDefinedVariableOrdering!Domain}
\index[pkg]{Domain!UserDefinedVariableOrdering}
\index[pkg]{UDVO}
\begin{chunk}{defclass UserDefinedVariableOrderingType}
(defclass |UserDefinedVariableOrderingType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UserDefinedVariableOrdering")
   (marker :initform 'package)
   (abbreviation :initform 'UDVO)
   (comment :initform (list
     "This packages provides functions to allow the user to select the ordering"
     "on the variables and operators for displaying polynomials,"
     "fractions and expressions. The ordering affects the display"
     "only and not the computations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UserDefinedVariableOrdering|
  (progn
    (push '|UserDefinedVariableOrdering| *Packages*)
    (make-instance '|UserDefinedVariableOrderingType|)))

\end{chunk}

\subsection{UTSodetools}
\index[pkg]{UTSodetools!Domain}
\index[pkg]{Domain!UTSodetools}
\index[pkg]{UTSODETL}
\begin{chunk}{defclass UTSodetoolsType}
(defclass |UTSodetoolsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "UTSodetools")
   (marker :initform 'package)
   (abbreviation :initform 'UTSODETL)
   (comment :initform (list
     "RUTSodetools provides tools to interface with the series"
     "ODE solver when presented with linear ODEs."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |UTSodetools|
  (progn
    (push '|UTSodetools| *Packages*)
    (make-instance '|UTSodetoolsType|)))

\end{chunk}

\subsection{U32VectorPolynomialOperations}
\index[pkg]{U32VectorPolynomialOperations!Domain}
\index[pkg]{Domain!U32VectorPolynomialOperations}
\index[pkg]{POLYVEC}
\begin{chunk}{defclass U32VectorPolynomialOperationsType}
(defclass |U32VectorPolynomialOperationsType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "U32VectorPolynomialOperations")
   (marker :initform 'package)
   (abbreviation :initform 'POLYVEC)
   (comment :initform (list
     "This is a low-level package which implements operations"
     "on vectors treated as univariate modular polynomials.  Most"
     "operations takes modulus as parameter.  Modulus is machine"
     "sized prime which should be small enough to avoid overflow"
     "in intermediate calculations."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |U32VectorPolynomialOperations|
  (progn
    (push '|U32VectorPolynomialOperations| *Packages*)
    (make-instance '|U32VectorPolynomialOperationsType|)))

\end{chunk}

\section{V}

\subsection{VectorFunctions2}
\index[pkg]{VectorFunctions2!Domain}
\index[pkg]{Domain!VectorFunctions2}
\index[pkg]{VECTOR2}
\begin{chunk}{defclass VectorFunctions2Type}
(defclass |VectorFunctions2Type| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "VectorFunctions2")
   (marker :initform 'package)
   (abbreviation :initform 'VECTOR2)
   (comment :initform (list
     "This package provides operations which all take as arguments"
     "vectors of elements of some type A and functions from A to"
     "another of type B. The operations all iterate over their vector argument"
     "and either return a value of type B or a vector over B."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |VectorFunctions2|
  (progn
    (push '|VectorFunctions2| *Packages*)
    (make-instance '|VectorFunctions2Type|)))

\end{chunk}

\subsection{ViewDefaultsPackage}
\index[pkg]{ViewDefaultsPackage!Domain}
\index[pkg]{Domain!ViewDefaultsPackage}
\index[pkg]{VIEWDEF}
\begin{chunk}{defclass ViewDefaultsPackageType}
(defclass |ViewDefaultsPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ViewDefaultsPackage")
   (marker :initform 'package)
   (abbreviation :initform 'VIEWDEF)
   (comment :initform (list
     "ViewportDefaultsPackage describes default and user definable"
     "values for graphics"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ViewDefaultsPackage|
  (progn
    (push '|ViewDefaultsPackage| *Packages*)
    (make-instance '|ViewDefaultsPackageType|)))

\end{chunk}

\subsection{ViewportPackage}
\index[pkg]{ViewportPackage!Domain}
\index[pkg]{Domain!ViewportPackage}
\index[pkg]{VIEW}
\begin{chunk}{defclass ViewportPackageType}
(defclass |ViewportPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ViewportPackage")
   (marker :initform 'package)
   (abbreviation :initform 'VIEW)
   (comment :initform (list
     "ViewportPackage provides functions for creating GraphImages"
     "and TwoDimensionalViewports from lists of lists of points."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ViewportPackage|
  (progn
    (push '|ViewportPackage| *Packages*)
    (make-instance '|ViewportPackageType|)))

\end{chunk}

\section{W}

\subsection{WeierstrassPreparation}
\index[pkg]{WeierstrassPreparation!Domain}
\index[pkg]{Domain!WeierstrassPreparation}
\index[pkg]{WEIER}
\begin{chunk}{defclass WeierstrassPreparationType}
(defclass |WeierstrassPreparationType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "WeierstrassPreparation")
   (marker :initform 'package)
   (abbreviation :initform 'WEIER)
   (comment :initform (list
     "This package implements the Weierstrass preparation"
     "theorem f or multivariate power series."
     "weierstrass(v,p) where v is a variable, and p is a"
     "TaylorSeries(R) in which the terms"
     "of lowest degree s must include c*v**s where c is a constant,s>0,"
     "is a list of TaylorSeries coefficients A[i] of the equivalent polynomial"
     "A = A[0] + A[1]*v + A[2]*v**2 + ... + A[s-1]*v**(s-1) + v**s"
     "such that p=A*B , B being a TaylorSeries of minimum degree 0"))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |WeierstrassPreparation|
  (progn
    (push '|WeierstrassPreparation| *Packages*)
    (make-instance '|WeierstrassPreparationType|)))

\end{chunk}

\subsection{WildFunctionFieldIntegralBasis}
\index[pkg]{WildFunctionFieldIntegralBasis!Domain}
\index[pkg]{Domain!WildFunctionFieldIntegralBasis}
\index[pkg]{WFFINTBS}
\begin{chunk}{defclass WildFunctionFieldIntegralBasisType}
(defclass |WildFunctionFieldIntegralBasisType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "WildFunctionFieldIntegralBasis")
   (marker :initform 'package)
   (abbreviation :initform 'WFFINTBS)
   (comment :initform (list
     "In this package K is a finite field, R is a ring of univariate"
     "polynomials over K, and F is a framed algebra over R.  The package"
     "provides a function to compute the integral closure of R in the quotient"
     "field of F as well as a function to compute a 'local integral basis'"
     "at a specific prime."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |WildFunctionFieldIntegralBasis|
  (progn
    (push '|WildFunctionFieldIntegralBasis| *Packages*)
    (make-instance '|WildFunctionFieldIntegralBasisType|)))

\end{chunk}

\section{X}

\subsection{XExponentialPackage}
\index[pkg]{XExponentialPackage!Domain}
\index[pkg]{Domain!XExponentialPackage}
\index[pkg]{XIXPPKG}
\begin{chunk}{defclass XExponentialPackageType}
(defclass |XExponentialPackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "XExponentialPackage")
   (marker :initform 'package)
   (abbreviation :initform 'XEXPPKG)
   (comment :initform (list
     "This package provides computations of logarithms and exponentials"
     "for polynomials in non-commutative variables."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform nil)
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |XExponentialPackage|
  (progn
    (push '|XExponentialPackage| *Packages*)
    (make-instance '|XExponentialPackageType|)))

\end{chunk}

\section{Z}

\subsection{ZeroDimensionalSolvePackage}
\index[pkg]{ZeroDimensionalSolvePackage!Domain}
\index[pkg]{Domain!ZeroDimensionalSolvePackage}
\index[pkg]{ZDSOLVE}
\begin{chunk}{defclass ZeroDimensionalSolvePackageType}
(defclass |ZeroDimensionalSolvePackageType| (|AxiomClass|)
  ((parents :initform ())
   (name :initform "ZeroDimensionalSolvePackage")
   (marker :initform 'package)
   (abbreviation :initform 'ZDSOLVE)
   (comment :initform (list
     "A package for computing symbolically the complex and real roots of"
     "zero-dimensional algebraic systems over the integer or rational"
     "numbers. Complex roots are given by means of univariate representations"
     "of irreducible regular chains. Real roots are given by means of tuples"
     "of coordinates lying in the RealClosure of the coefficient ring."
     "This constructor takes three arguments. The first one R is the"
     "coefficient ring. The second one ls is the list of variables"
     "involved in the systems to solve. The third one must be concat(ls,s)"
     "where s is an additional symbol used for the univariate"
     "representations."
     "WARNING. The third argument is not checked."
     "All operations are based on triangular decompositions."
     "The default is to compute these decompositions directly from the input"
     "system by using the RegularChain domain constructor."
     "The lexTriangular algorithm can also be used for computing these"
     "decompositions (see LexTriangularPackage package constructor)."
     "For that purpose, the operations univariateSolve, realSolve and"
     "positiveSolve admit an optional argument."))
   (argslist :initform nil)
   (macros :initform nil)
   (withlist :initform (list 
     (make-signature '|triangSolve| '(List |RegularChain| R ls) '(LP B B)
       (list
        "binomial(n,r) returns the \spad{(n,r)} binomial coefficient"
        "(often denoted in the literature by \spad{C(n,r)})."
        "Note that \spad{C(n,r) = n!/(r!(n-r)!)} where \spad{n >= r >= 0}.")
       (list
        "[binomial(5,i) for i in 0..5]"))
     (make-signature '|triangSolve| '(List |RegularChain| R ls) '(LP B)
       (list
         "factorial(n) computes the factorial of n"
         "(denoted in the literature by \spad{n!})"
         "Note that \spad{n! = n (n-1)! when n > 0}; also, \spad{0! = 1}."))
     (make-signature '|triangSolve| '(List |RegularChain| R ls) '(LP)
       (list
         "factorial(n) computes the factorial of n"
         "(denoted in the literature by \spad{n!})"
         "Note that \spad{n! = n (n-1)! when n > 0}; also, \spad{0! = 1}."))
     (make-signature '|permutation| '% '(% %)
       (list
         "permutation(n, m) returns the number of"
         "permutations of n objects taken m at a time."
         "Note that \spad{permutation(n,m) = n!/(n-m)!}."))))
   (haslist :initform nil)
   (addlist :initform nil)))

(defvar |ZeroDimensionalSolvePackage|
  (progn
    (push '|ZeroDimensionalSolvePackage| *Packages*)
    (make-instance '|ZeroDimensionalSolvePackageType|)))

\end{chunk}

\chapter{Common Lisp Types}
\begin{verbatim}
Class      Class Precedence List

array      array t
bit-vector bit-vector vector array sequence t
character  character t
complex    complex number t
cons       cons list sequence t
float      float number t
integer    integer rational number t
list       list sequence t
null       null symbol list sequence t
number     number t
ratio      ratio rational number t
rational   rational number t
sequence   sequence t
string     string vector array sequence t
symbol     symbol t
t          t
vector     vector array sequence t
\end{verbatim}

\chapter{EBNF}

\section{For show output}

\begin{verbatim}
PARAM ::= UPPERCASELETTER        

DOMAINSPEC ::= DOMAIN
             | DOMAIN(%)
             | DOMAIN(PARAM)
             | DOMAIN(DOMAIN[,DOMAIN]*)

HASSPEC ::= 'if' '$' 'has' CATEGORY
          | 'if' PARAM 'has' CATEGORY
          | 'if' DOMAINSPEC 'has' CATEGORY
          | 'if' PARAM 'has' DOMAINSPEC

ANDSPEC ::= HASSPEC 'and' HASSPEC

ORSPEC ::= HASSPEC
         | HASSPEC 'or' ANDSPEC
         | ANDSPEC 'or' HAPSPEC
         | ANDSPEC 'or' ANDSPEC
         | ORSPEC 'or' HASSPEC
         | ORSPEC 'or' ANDSPEC
         | ORSPEC 'or' ORSPEC

IFSPEC ::= HASSPEC
         | ANDSPEC
         | ORSPEC

FUNCSPEC ::= '(' PARAM '->' PARAM ')'

DPSPEC ::= '%'
         | PARAM
         | DOMAINSPEC
         | FUNCSPEC

TWOLIST ::= '(' DPSPEC ',' DPSPEC ')'

CONSTANT ::= '0'
           | '1'

PREFIX ::= '#?'
         | '-?'

INFIX ::= '?**?' 
        | '?*?'
        | '?-?'

UNIONSPEC ::= 'Union' '(' DPSPEC ',' '"failed"' ')'

KEYSPEC ::= Symbol ':' DOMAIN
          | Symbol ':' PARAM

RECORDSPEC ::= 'Record' '(' KEYSPEC [',' KEYSPEC]* ')'

CONSTANT ':' '()'    '->' '%'
CONSTANT ':' '()'    '->' '%' IFSPEC
PREFIX   ':' DPSPEC  '->' DPSPEC
PREFIX   ':' DPSPEC  '->' DPSPEC IFSPEC
INFIX    ':' TWOLIST '->' DPSPEC
INFIX    ':' TWOLIST '->' DPSPEC IFSPEC
INFIX    ':' TWOLIST '->' UNIONSPEC
'?..?' ':' '(' '%' ',' '%' ')' '->' '%'
'?..?' ':' '(' 'S' ',' 'S' ')' '->' '%'
'?.?'  ':' '(' '%' ',' DPSPEC ')' '->' DPSPEC
'?.count'  ':' '(' '%' ',' 'count' ')' '->' DPSPEC
'?.first  ':' '(' '%' ',' 'first' ')' '->' RECORDSPEC
'?.last  ':' '(' '%' ',' 'last' ')' '->' DPSPEC
'?.last  ':' '(' '%' ',' 'last' ')' '->' DP
'?.last  ':' '(' '%' ',' 'last' ')' '->' RECORDSPEC
'?.last  ':' '(' '%' ',' 'last' ')' '->' PARAM
'?.left  ':' '(' '%' ',' 'left' ')' '->' '%'
'?.rest  ':' '(' '%' ',' 'rest' ')' '->' '%'
'?.right  ':' '(' '%' ',' 'right' ')' '->' '%'
'?.sort  ':' '(' '%' ',' 'sort' ')' '->' '%'
'?.unique  ':' '(' '%' ',' 'unique' ')' '->' '%'
'?.value  ':' '(' '%' ',' 'value' ')' '->' RECORDSPEC
'?.value  ':' '(' '%' ',' 'value' ')' '->' PARAM
'?.value  ':' '(' '%' ',' 'value' ')' '->' DOMAINSPEC
\end{verbatim}

\chapter{The Compiler}

\begin{chunk}{sane}
(defmacro must (FSMname input)
  `(let (text)
     (if (setq text ,FSMname ,input)
       (progn (format t "ACCEPT ~a~%" text) t)
       (progn (format t "FAILED ~a~%" text) nil))))

\end{chunk}

\begin{chunk}{sane}
(defmacro expect (FSMname input)
  `(let (text)
     (if (setq text ,FSMname ,input)
       (format t "ACCEPT ~a~%" text)
       (format t "FAILED ~a~%" text))))

\end{chunk}

\chapter{Sane Interpreter}

This is the top loop of the Sane interpreter.

It defines a function {\bf bye} which only exists for the lifetime of
the interpreter. When called from the Sane command line, {\bf bye}
returns the gensym. If that gensym is seen the Sane interpreter makes
the {\bf bye} unbound and exits. Note that we save any existing
definition of {\bf bye} and restore it when the interpreter exits.

\begin{chunk}{insane}
(defun sane ()
  (let (input result)
    (labels (
      (printType (thing)
        (typecase thing
         (string "String")
         (array "Array")
         (bit-vector "Bit-vector")
         (character "Character")
         (complex "Complex")
         (null "Null")
         (list "List")
         (cons "Cons")
         (float "Float")
         (integer "Integer")
         (rational "Rational")
         (number "Number")
         (ratio "Ratio")
         (sequence "Sequence")
         (t "t")
         (symbol "Symbol")
         (vector "Vector")))
      (localHelp ()
        ; define a help command
        (setq result "beyond it"))
    )
    (loop do 
      (format t "S> ") 
      (force-output) 
      (setq input (read))
      (cond
        ((eq input 'bye) (return))
        ((eq input 'help) (localHelp))
        (t (setq result (eval input))))
      (format t "  ~s~%       Type: ~a~%" result (printType result))
      (terpri)))))

\end{chunk}

\index[code]{NonNegativeInteger!Domain}
\index[code]{Domain!NonNegativeInteger}
\index[code]{NNI}
\begin{chunk}{defmacro must}
(defmacro must (FSMname input)
  `(let (text)
     (if (setq text ,FSMname ,input)
       (progn (format t "ACCEPT ~a~%" text) t)
       (progn (format t "FAILED ~a~%" text) nil))))

\end{chunk}

\begin{chunk}{defmacro expect}
(defmacro expect (FSMname input)
  `(let (text)
     (if (setq text ,FSMname ,input)
       (format t "ACCEPT ~a~%" text)
       (format t "FAILED ~a~%" text))))

\end{chunk}


\begin{chunk}{all}

\getchunk{defvar categories}
\getchunk{defvar domains}
\getchunk{defvar packages}
\getchunk{defvar indent}
\getchunk{defvar place}
\getchunk{defvar theparse}
\getchunk{defvar forcelongs}

\getchunk{defclass hasclause}
\getchunk{defclass haslist}
\getchunk{defclass AxiomClass}
\getchunk{defclass typeParam}
\getchunk{defclass WithClass}
\getchunk{defclass AddClass}
\getchunk{defclass signature}
\getchunk{defclass amacro}
\getchunk{defclass operation}
\getchunk{defclass CDPSigClass}
\getchunk{defclass ParserClass}
\getchunk{defclass gather}
\getchunk{defclass sourcecode}
\getchunk{defclass abbreviation}

\getchunk{defgeneric showSig}

\getchunk{defmethod print-object}
\getchunk{defmethod showSig}

\getchunk{defmacro birth}
\getchunk{defmacro defunt}
\getchunk{defmacro depthof}
\getchunk{defmacro expect}
\getchunk{defmacro FSM-abbname}
\getchunk{defmacro FSM-AND}
\getchunk{defmacro FSM-cdpname}
\getchunk{defmacro FSM-dword}
\getchunk{defmacro FSM-gather}
\getchunk{defmacro FSM-match}
\getchunk{defmacro FSM-OR}
\getchunk{defmacro FSM-startsWith}
\getchunk{defmacro FSM-uword}
\getchunk{defmacro FSM-word}
\getchunk{defmacro ll}
\getchunk{defmacro must}
\getchunk{defmacro nameof}
\getchunk{defmacro trim}

\getchunk{defun indent}
\getchunk{defun pretty}
\getchunk{defun spawn}
\getchunk{defun splitchar}
\getchunk{defun pile2tree}

\getchunk{defun compileSpad}
\getchunk{defun explode}
\getchunk{defun FSM-abbrev}
\getchunk{defun FSM-gatherList}
\getchunk{defun FSM-gatherVars}
\getchunk{defun FSM-catBody}
\getchunk{defun FSM-cdpsig}
\getchunk{defun FSM-comment}
\getchunk{defun FSM-dpBody}
\getchunk{defun FSM-extract1Macro}
\getchunk{defun FSM-isCategory?}
\getchunk{defun FSM-macroNames}
\getchunk{defun FSM-macros}
\getchunk{defun FSMSIG}
\getchunk{defun getAncestors}
\getchunk{defun getDomains}
\getchunk{defun leaves}
\getchunk{defun make-hasclause}
\getchunk{defun make-haslist}
\getchunk{defun make-Sourcecode}
\getchunk{defun operationToSignature}
\getchunk{defun operations-show}
\getchunk{defun Parse}
\getchunk{defun parseSignature}
\getchunk{defun signatureToOperation}

\getchunk{defvar level1}
\getchunk{defclass AdditiveValuationAttributeType}
\getchunk{defclass ApproximateAttributeType}
\getchunk{defclass ArbitraryExponentAttributeType}
\getchunk{defclass ArbitraryPrecisionAttributeType}
\getchunk{defclass ArcHyperbolicFunctionCategoryType}
\getchunk{defclass ArcTrigonometricFunctionCategoryType}
\getchunk{defclass AttributeRegistryType}
\getchunk{defclass BasicTypeType}
\getchunk{defclass CanonicalAttributeType}
\getchunk{defclass CanonicalClosedAttributeType}
\getchunk{defclass CanonicalUnitNormalAttributeType}
\getchunk{defclass CentralAttributeType}
\getchunk{defclass CoercibleToType}
\getchunk{defclass CombinatorialFunctionCategoryType}
\getchunk{defclass CommutativeStarAttributeType}
\getchunk{defclass ConvertibleToType}
\getchunk{defclass ElementaryFunctionCategoryType}
\getchunk{defclass EltableType}
\getchunk{defclass FiniteAggregateAttributeType}
\getchunk{defclass HyperbolicFunctionCategoryType}
\getchunk{defclass InnerEvalableType}
\getchunk{defclass JacobiIdentityAttributeType}
\getchunk{defclass LazyRepresentationAttributeType}
\getchunk{defclass LeftUnitaryAttributeType}
\getchunk{defclass ModularAlgebraicGcdOperationsType}
\getchunk{defclass MultiplicativeValuationAttributeType}
\getchunk{defclass NoZeroDivisorsAttributeType}
\getchunk{defclass NotherianAttributeType}
\getchunk{defclass NullSquareAttributeType}
\getchunk{defclass OpenMathType}
\getchunk{defclass PartialTranscendentalFunctionsType}
\getchunk{defclass PartiallyOrderedSetAttributeType}
\getchunk{defclass PrimitiveFunctionCategoryType}
\getchunk{defclass RadicalCategoryType}
\getchunk{defclass RetractableToType}
\getchunk{defclass RightUnitaryAttributeType}
\getchunk{defclass ShallowlyMutableAttributeType}
\getchunk{defclass SpecialFunctionCategoryType}
\getchunk{defclass TrigonometricFunctionCategoryType}
\getchunk{defclass TypeType}
\getchunk{defclass UnitsKnownAttributeType}

\getchunk{defvar level2}
\getchunk{defclass AggregateType}
\getchunk{defclass CombinatorialOpsCategoryType}
\getchunk{defclass EltableAggregateType}
\getchunk{defclass EvalableType}
\getchunk{defclass FortranProgramCategoryType}
\getchunk{defclass FullyRetractableToType}
\getchunk{defclass LogicType}
\getchunk{defclass PatternableType}
\getchunk{defclass PlottablePlaneCurveCategoryType}
\getchunk{defclass PlottableSpaceCurveCategoryType}
\getchunk{defclass RealConstantType}
\getchunk{defclass SegmentCategoryType}
\getchunk{defclass SetCategoryType}
\getchunk{defclass TranscendentalFunctionCategoryType}

\getchunk{defvar level3}
\getchunk{defclass AbelianSemiGroupType}
\getchunk{defclass BlowUpMethodCategoryType}
\getchunk{defclass ComparableType}
\getchunk{defclass FileCategoryType}
\getchunk{defclass FileNameCategoryType}
\getchunk{defclass FiniteType}
\getchunk{defclass FortranFunctionCategoryType}
\getchunk{defclass FortranMatrixCategoryType}
\getchunk{defclass FortranMatrixFunctionCategoryType}
\getchunk{defclass FortranVectorCategoryType}
\getchunk{defclass FortranVectorFunctionCategoryType}
\getchunk{defclass FullyEvalableOverType}
\getchunk{defclass GradedModuleType}
\getchunk{defclass HomogeneousAggregateType}
\getchunk{defclass IndexedDirectProductCategoryType}
\getchunk{defclass LiouvillianFunctionCategoryType}
\getchunk{defclass MonadType}
\getchunk{defclass NumericalIntegrationCategoryType}
\getchunk{defclass NumericalOptimizationCategoryType}
\getchunk{defclass OrderedSetType}
\getchunk{defclass OrdinaryDifferentialEquationsSolverCategoryType}
\getchunk{defclass PartialDifferentialEquationsSolverCategoryType}
\getchunk{defclass PatternMatchableType}
\getchunk{defclass RealRootCharacterizationCategoryType}
\getchunk{defclass SExpressionCategoryType}
\getchunk{defclass SegmentExpansionCategoryType}
\getchunk{defclass SemiGroupType}
\getchunk{defclass SetCategoryWithDegreeType}
\getchunk{defclass StepThroughType}
\getchunk{defclass ThreeSpaceCategoryType}

\getchunk{defvar level4}
\getchunk{defclass AbelianMonoidType}
\getchunk{defclass AffineSpaceCategoryType}
\getchunk{defclass BagAggregateType}
\getchunk{defclass CachableSetType}
\getchunk{defclass CollectionType}
\getchunk{defclass DifferentialVariableCategoryType}
\getchunk{defclass ExpressionSpaceType}
\getchunk{defclass FullyPatternMatchableType}
\getchunk{defclass GradedAlgebraType}
\getchunk{defclass IndexedAggregateType}
\getchunk{defclass InfinitlyClosePointCategoryType}
\getchunk{defclass MonadWithUnitType}
\getchunk{defclass MonoidType}
\getchunk{defclass |OrderedAbelianSemiGroupType}
\getchunk{defclass OrderedFiniteType}
\getchunk{defclass PlacesCategoryType}
\getchunk{defclass ProjectiveSpaceCategoryType}
\getchunk{defclass RecursiveAggregateType}
\getchunk{defclass TwoDimensionalArrayCategoryType}

\getchunk{defvar level5}
\getchunk{defclass BinaryRecursiveAggregateType}
\getchunk{defclass CancellationAbelianMonoidType}
\getchunk{defclass DesingTreeCategoryType}
\getchunk{defclass DoublyLinkedAggregateType}
\getchunk{defclass GroupType}
\getchunk{defclass LinearAggregateType}
\getchunk{defclass MatrixCategoryType}
\getchunk{defclass OrderedAbelianMonoidType}
\getchunk{defclass OrderedMonoidType}
\getchunk{defclass PolynomialSetCategoryType}
\getchunk{defclass PriorityQueueAggregateType}
\getchunk{defclass QueueAggregateType}
\getchunk{defclass SetAggregateType}
\getchunk{defclass StackAggregateType}
\getchunk{defclass UnaryRecursiveAggregateType}

\getchunk{defvar level6}
\getchunk{defclass AbelianGroupType}
\getchunk{defclass BinaryTreeCategoryType}
\getchunk{defclass DequeueAggregateType}
\getchunk{defclass DictionaryOperationsType}
\getchunk{defclass ExtensibleLinearAggregateType}
\getchunk{defclass FiniteLinearAggregateType}
\getchunk{defclass FreeAbelianMonoidCategoryType}
\getchunk{defclass OrderedCancellationAbelianMonoidType}
\getchunk{defclass PermutationCategoryType}
\getchunk{defclass StreamAggregateType}
\getchunk{defclass TriangularSetCategoryType}

\getchunk{defvar level7}
\getchunk{defclass DictionaryType}
\getchunk{defclass FiniteDivisorCategoryType}
\getchunk{defclass LazyStreamAggregateType}
\getchunk{defclass LeftModuleType}
\getchunk{defclass ListAggregateType}
\getchunk{defclass MultiDictionaryType}
\getchunk{defclass MultisetAggregateType}
\getchunk{defclass NonAssociativeRngType}
\getchunk{defclass OneDimensionalArrayAggregateType}
\getchunk{defclass OrderedAbelianGroupType}
\getchunk{defclass OrderedAbelianMonoidSupType}
\getchunk{defclass RegularTriangularSetCategoryType}
\getchunk{defclass RightModuleType}
\getchunk{defclass RngType}

\getchunk{defvar level8}
\getchunk{defclass BiModuleType}
\getchunk{defclass |BitAggregateType}
\getchunk{defclass FiniteSetAggregateType}
\getchunk{defclass KeyedDictionaryType}
\getchunk{defclass NonAssociativeRingType}
\getchunk{defclass NormalizedTriangularSetCategoryType}
\getchunk{defclass OrderedMultisetAggregateType}
\getchunk{defclass RingType}
\getchunk{defclass SquareFreeRegularTriangularSetCategoryType}
\getchunk{defclass StringAggregateType}
\getchunk{defclass |VectorCategoryType}

\getchunk{defvar level9}
\getchunk{defclass CharacteristicNonZeroType}
\getchunk{defclass CharacteristicZeroType}
\getchunk{defclass CommutativeRingType}
\getchunk{defclass DifferentialRingType}
\getchunk{defclass EntireRingType}
\getchunk{defclass LeftAlgebraType}
\getchunk{defclass LinearlyExplicitRingOverType}
\getchunk{defclass ModuleType}
\getchunk{defclass OrderedRingType}
\getchunk{defclass PartialDifferentialRingType}
\getchunk{defclass PointCategoryType}
\getchunk{defclass SquareFreeNormalizedTriangularSetCategoryType}
\getchunk{defclass StringCategoryType}
\getchunk{defclass TableAggregateType}

\getchunk{defvar level10}
\getchunk{defclass AlgebraType}
\getchunk{defclass AssociationListAggregateType}
\getchunk{defclass DifferentialExtensionType}
\getchunk{defclass DivisorCategoryType}
\getchunk{defclass FreeModuleCatType}
\getchunk{defclass FullyLinearlyExplicitRingOverType}
\getchunk{defclass LeftOreRingType}
\getchunk{defclass LieAlgebraType}
\getchunk{defclass NonAssociativeAlgebraType}
\getchunk{defclass RectangularMatrixCategoryType}
\getchunk{defclass VectorSpaceType}

\getchunk{defvar level11}
\getchunk{defclass DirectProductCategoryType}
\getchunk{defclass DivisionRingType}
\getchunk{defclass FiniteRankAlgebraType}
\getchunk{defclass FiniteRankNonAssociativeAlgebraType}
\getchunk{defclass FreeLieAlgebraType}
\getchunk{defclass IntegralDomainType}
\getchunk{defclass MonogenicLinearOperatorType}
\getchunk{defclass OctonionCategoryType}
\getchunk{defclass SquareMatrixCategoryType}
\getchunk{defclass UnivariateSkewPolynomialCategoryType}
\getchunk{defclass XAlgebraType}

\getchunk{defvar level12}
\getchunk{defclass AbelianMonoidRingType}
\getchunk{defclass FortranMachineTypeCategoryType}
\getchunk{defclass FramedAlgebraType}
\getchunk{defclass FramedNonAssociativeAlgebraType}
\getchunk{defclass GcdDomainType}
\getchunk{defclass LinearOrdinaryDifferentialOperatorCategoryType}
\getchunk{defclass OrderedIntegralDomainType}
\getchunk{defclass QuaternionCategoryType}
\getchunk{defclass XFreeAlgebraType}

\getchunk{defvar level13}
\getchunk{defclass FiniteAbelianMonoidRingType}
\getchunk{defclass IntervalCategoryType}
\getchunk{defclass PowerSeriesCategoryType}
\getchunk{defclass PrincipalIdealDomainType}
\getchunk{defclass UniqueFactorizationDomainType}
\getchunk{defclass XPolynomialsCatType}

\getchunk{defvar level14}
\getchunk{defclass EuclideanDomainType}
\getchunk{defclass MultivariateTaylorSeriesCategoryType}
\getchunk{defclass PolynomialFactorizationExplicitType}
\getchunk{defclass UnivariatePowerSeriesCategoryType}

\getchunk{defvar level15}
\getchunk{defclass FieldType}
\getchunk{defclass IntegerNumberSystemType}
\getchunk{defclass PAdicIntegerCategoryType}
\getchunk{defclass PolynomialCategoryType}
\getchunk{defclass UnivariateTaylorSeriesCategoryType}

\getchunk{defvar level16}
\getchunk{defclass AlgebraicallyClosedFieldType}
\getchunk{defclass DifferentialPolynomialCategoryType}
\getchunk{defclass FieldOfPrimeCharacteristicType}
\getchunk{defclass FunctionSpaceType}
\getchunk{defclass LocalPowerSeriesCategoryType}
\getchunk{defclass PseudoAlgebraicClosureOfPerfectFieldCategoryType}
\getchunk{defclass QuotientFieldCategoryType}
\getchunk{defclass RealClosedFieldType}
\getchunk{defclass RealNumberSystemType}
\getchunk{defclass RecursivePolynomialCategoryType}
\getchunk{defclass UnivariateLaurentSeriesCategoryType}
\getchunk{defclass UnivariatePolynomialCategoryType}
\getchunk{defclass UnivariatePuiseuxSeriesCategoryType}

\getchunk{defvar level17}
\getchunk{defclass AlgebraicallyClosedFunctionSpaceType}
\getchunk{defclass ExtensionFieldType}
\getchunk{defclass FiniteFieldCategoryType}
\getchunk{defclass FloatingPointSystemType}
\getchunk{defclass UnivariateLaurentSeriesConstructorCategoryType}
\getchunk{defclass UnivariatePuiseuxSeriesConstructorCategoryType}

\getchunk{defvar level18}
\getchunk{defclass FiniteAlgebraicExtensionFieldType}
\getchunk{defclass MonogenicAlgebraType}
\getchunk{defclass PseudoAlgebraicClosureOfFiniteFieldCategoryType}
\getchunk{defclass PseudoAlgebraicClosureOfRationalNumberCategoryType}

\getchunk{defvar level19}
\getchunk{defclass ComplexCategoryType}
\getchunk{defclass FunctionFieldCategoryType}
\getchunk{defclass PseudoAlgebraicClosureOfAlgExtOfRationalNumberCategoryType}
\getchunk{defclass AffinePlaneType}
\getchunk{defclass AffinePlaneOverPseudoAlgebraicClosureOfFiniteFieldType}
\getchunk{defclass AffineSpaceType}
\getchunk{defclass AlgebraGivenByStructuralConstantsType}
\getchunk{defclass AlgebraicFunctionFieldType}
\getchunk{defclass AlgebraicNumberType}
\getchunk{defclass AnonymousFunctionType}
\getchunk{defclass AntiSymmType}
\getchunk{defclass AnyType}
\getchunk{defclass ArrayStackType}
\getchunk{defclass Asp1Type}
\getchunk{defclass Asp10Type}
\getchunk{defclass |Asp12Type}
\getchunk{defclass Asp19Type}
\getchunk{defclass Asp20Type}
\getchunk{defclass Asp24Type}
\getchunk{defclass Asp27Type}
\getchunk{defclass Asp28Type}
\getchunk{defclass Asp29Type}
\getchunk{defclass Asp30Type}
\getchunk{defclass Asp31Type}
\getchunk{defclass Asp33Type}
\getchunk{defclass Asp34Type}
\getchunk{defclass Asp35Type}
\getchunk{defclass Asp4Type}
\getchunk{defclass Asp41Type}
\getchunk{defclass Asp42Type}
\getchunk{defclass Asp49Type}
\getchunk{defclass Asp50Type}
\getchunk{defclass Asp55Type}
\getchunk{defclass Asp6Type}
\getchunk{defclass Asp7Type}
\getchunk{defclass Asp73Type}
\getchunk{defclass Asp74Type}
\getchunk{defclass Asp77Type}
\getchunk{defclass Asp78Type}
\getchunk{defclass Asp8Type}
\getchunk{defclass Asp80Type}
\getchunk{defclass Asp9Type}
\getchunk{defclass AssociatedJordanAlgebraType}
\getchunk{defclass AssociatedLieAlgebraType}
\getchunk{defclass AssociationListType}
\getchunk{defclass AttributeButtonsType}
\getchunk{defclass AutomorphismType}
\getchunk{defclass BalancedBinaryTreeType}
\getchunk{defclass BalancedPAdicIntegerType}
\getchunk{defclass BalancedPAdicRationalType}
\getchunk{defclass BasicFunctionsType}
\getchunk{defclass BasicOperatorType}
\getchunk{defclass BasicStochasticDifferentialType}
\getchunk{defclass BinaryExpansionType}
\getchunk{defclass BinaryFileType}
\getchunk{defclass BinarySearchTreeType}
\getchunk{defclass BinaryTournamentType}
\getchunk{defclass BinaryTreeType}
\getchunk{defclass BitsType}
\getchunk{defclass BlowUpWithHamburgerNoetherType}
\getchunk{defclass BlowUpWithQuadTransType}
\getchunk{defclass BooleanType}
\getchunk{defclass CardinalNumberType}
\getchunk{defclass CartesianTensorType}
\getchunk{defclass CellType}
\getchunk{defclass CharacterType}
\getchunk{defclass CharacterClassType}
\getchunk{defclass CliffordAlgebraType}
\getchunk{defclass ColorType}
\getchunk{defclass CommutatorType}
\getchunk{defclass ComplexType}
\getchunk{defclass ComplexDoubleFloatMatrixType}
\getchunk{defclass ComplexDoubleFloatVectorType}
\getchunk{defclass ContinuedFractionType}
\getchunk{defclass DatabaseType}
\getchunk{defclass DataListType}
\getchunk{defclass DecimalExpansionType}
\getchunk{defclass DenavitHartenbergMatrixType}
\getchunk{defclass DequeueType}
\getchunk{defclass DeRhamComplexType}
\getchunk{defclass DesingTreeType}
\getchunk{defclass DifferentialSparseMultivariatePolynomialType}
\getchunk{defclass DirectProductType}
\getchunk{defclass DirectProductMatrixModuleType}
\getchunk{defclass DirectProductModuleType}
\getchunk{defclass DirichletRingType}
\getchunk{defclass DistributedMultivariatePolynomialType}
\getchunk{defclass DivisorType}
\getchunk{defclass DoubleFloatType}
\getchunk{defclass DoubleFloatMatrixType}
\getchunk{defclass DoubleFloatVectorType}
\getchunk{defclass DrawOptionType}
\getchunk{defclass d01ajfAnnaTypeType}
\getchunk{defclass d01akfAnnaTypeType}
\getchunk{defclass d01alfAnnaTypeType}
\getchunk{defclass d01amfAnnaTypeType}
\getchunk{defclass d01anfAnnaTypeType}
\getchunk{defclass d01apfAnnaTypeType}
\getchunk{defclass d01aqfAnnaTypeType}
\getchunk{defclass d01asfAnnaTypeType}
\getchunk{defclass d01fcfAnnaTypeType}
\getchunk{defclass d01gbfAnnaTypeType}
\getchunk{defclass d01TransformFunctionTypeType}
\getchunk{defclass d02bbfAnnaTypeType}
\getchunk{defclass d02bhfAnnaTypeType}
\getchunk{defclass d02cjfAnnaTypeType}
\getchunk{defclass d02ejfAnnaTypeType}
\getchunk{defclass d03eefAnnaTypeType}
\getchunk{defclass d03fafAnnaTypeType}
\getchunk{defclass ElementaryFunctionsUnivariateLaurentSeriesType}
\getchunk{defclass ElementaryFunctionsUnivariatePuiseuxSeriesType}
\getchunk{defclass EquationType}
\getchunk{defclass EqTableType}
\getchunk{defclass EuclideanModularRingType}
\getchunk{defclass ExitType}
\getchunk{defclass ExponentialExpansionType}
\getchunk{defclass ExpressionType}
\getchunk{defclass ExponentialOfUnivariatePuiseuxSeriesType}
\getchunk{defclass ExtAlgBasisType}
\getchunk{defclass e04dgfAnnaTypeType}
\getchunk{defclass e04fdfAnnaTypeType}
\getchunk{defclass e04gcfAnnaTypeType}
\getchunk{defclass e04jafAnnaTypeType}
\getchunk{defclass e04mbfAnnaTypeType}
\getchunk{defclass e04nafAnnaTypeType}
\getchunk{defclass e04ucfAnnaTypeType}
\getchunk{defclass FactoredType}
\getchunk{defclass FileType}
\getchunk{defclass FileNameType}
\getchunk{defclass FiniteDivisorType}
\getchunk{defclass FiniteFieldType}
\getchunk{defclass FiniteFieldCyclicGroupType}
\getchunk{defclass FiniteFieldCyclicGroupExtensionType}
\getchunk{defclass FiniteFieldCyclicGroupExtensionByPolynomialType}
\getchunk{defclass FiniteFieldExtensionType}
\getchunk{defclass FiniteFieldExtensionByPolynomialType}
\getchunk{defclass FiniteFieldNormalBasisType}
\getchunk{defclass FiniteFieldNormalBasisExtensionType}
\getchunk{defclass FiniteFieldNormalBasisExtensionByPolynomialType}
\getchunk{defclass FlexibleArrayType}
\getchunk{defclass FloatType}
\getchunk{defclass FortranCodeType}
\getchunk{defclass FortranExpressionType}
\getchunk{defclass FortranProgramType}
\getchunk{defclass FortranScalarTypeType}
\getchunk{defclass FortranTemplateType}
\getchunk{defclass FortranTypeType}
\getchunk{defclass FourierComponentType}
\getchunk{defclass FourierSeriesType}
\getchunk{defclass FractionType}
\getchunk{defclass FractionalIdealType}
\getchunk{defclass FramedModuleType}
\getchunk{defclass FreeAbelianGroupType}
\getchunk{defclass FreeAbelianMonoidType}
\getchunk{defclass FreeGroupType}
\getchunk{defclass FreeModuleType}
\getchunk{defclass FreeModule1Type}
\getchunk{defclass FreeMonoidType}
\getchunk{defclass FreeNilpotentLieType}
\getchunk{defclass FullPartialFractionExpansionType}
\getchunk{defclass FunctionCalledType}
\getchunk{defclass GeneralDistributedMultivariatePolynomialType}
\getchunk{defclass GeneralModulePolynomialType}
\getchunk{defclass GenericNonAssociativeAlgebraType}
\getchunk{defclass GeneralPolynomialSetType}
\getchunk{defclass GeneralSparseTableType}
\getchunk{defclass GeneralTriangularSetType}
\getchunk{defclass GeneralUnivariatePowerSeriesType}
\getchunk{defclass GraphImageType}
\getchunk{defclass GuessOptionType}
\getchunk{defclass GuessOptionFunctions0Type}
\getchunk{defclass HashTableType}
\getchunk{defclass HeapType}
\getchunk{defclass HexadecimalExpansionType}
\getchunk{defclass HTMLFormatType}
\getchunk{defclass HomogeneousDirectProductType}
\getchunk{defclass HomogeneousDistributedMultivariatePolynomialType}
\getchunk{defclass HyperellipticFiniteDivisorType}
\getchunk{defclass InfClsPtType}
\getchunk{defclass IndexCardType}
\getchunk{defclass IndexedBitsType}
\getchunk{defclass IndexedDirectProductAbelianGroupType}
\getchunk{defclass IndexedDirectProductAbelianMonoidType}
\getchunk{defclass IndexedDirectProductObjectType}
\getchunk{defclass IndexedDirectProductOrderedAbelianMonoidType}
\getchunk{defclass IndexedDirectProductOrderedAbelianMonoidSupType}
\getchunk{defclass IndexedExponentsType}
\getchunk{defclass IndexedFlexibleArrayType}
\getchunk{defclass IndexedListType}
\getchunk{defclass IndexedMatrixType}
\getchunk{defclass IndexedOneDimensionalArrayType}
\getchunk{defclass IndexedStringType}
\getchunk{defclass IndexedTwoDimensionalArrayType}
\getchunk{defclass IndexedVectorType}
\getchunk{defclass InfiniteTupleType}
\getchunk{defclass InfinitlyClosePointType}
\getchunk{defclass InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteFieldType}
\getchunk{defclass InnerAlgebraicNumberType}
\getchunk{defclass InnerFiniteFieldType}
\getchunk{defclass InnerFreeAbelianMonoidType}
\getchunk{defclass InnerIndexedTwoDimensionalArrayType}
\getchunk{defclass InnerPAdicIntegerType}
\getchunk{defclass InnerPrimeFieldType}
\getchunk{defclass InnerSparseUnivariatePowerSeriesType}
\getchunk{defclass InnerTableType}
\getchunk{defclass InnerTaylorSeriesType}
\getchunk{defclass InputFormType}
\getchunk{defclass IntegerType}
\getchunk{defclass IntegerModType}
\getchunk{defclass IntegrationFunctionsTableType}
\getchunk{defclass IntegrationResultType}
\getchunk{defclass IntervalType}
\getchunk{defclass KernelType}
\getchunk{defclass KeyedAccessFileType}
\getchunk{defclass LaurentPolynomialType}
\getchunk{defclass LibraryType}
\getchunk{defclass LieExponentialsType}
\getchunk{defclass LiePolynomialType}
\getchunk{defclass LieSquareMatrixType}
\getchunk{defclass LinearOrdinaryDifferentialOperatorType}
\getchunk{defclass LinearOrdinaryDifferentialOperator1Type}
\getchunk{defclass LinearOrdinaryDifferentialOperator2Type}
\getchunk{defclass ListType}
\getchunk{defclass ListMonoidOpsType}
\getchunk{defclass ListMultiDictionaryType}
\getchunk{defclass LocalAlgebraType}
\getchunk{defclass LocalizeType}
\getchunk{defclass LyndonWordType}
\getchunk{defclass MachineIntegerType}
\getchunk{defclass MagmaType}
\getchunk{defclass MakeCachableSetType}
\getchunk{defclass MathMLFormatType}
\getchunk{defclass MatrixType}
\getchunk{defclass ModMonicType}
\getchunk{defclass ModularFieldType}
\getchunk{defclass ModularRingType}
\getchunk{defclass ModuleMonomialType}
\getchunk{defclass ModuleOperatorType}
\getchunk{defclass MoebiusTransformType}
\getchunk{defclass MonoidRingType}
\getchunk{defclass MultisetType}
\getchunk{defclass MultivariatePolynomialType}
\getchunk{defclass MyExpressionType}
\getchunk{defclass MyUnivariatePolynomialType}
\getchunk{defclass NeitherSparseOrDensePowerSeriesType}
\getchunk{defclass NewSparseMultivariatePolynomialType}
\getchunk{defclass NewSparseUnivariatePolynomialType}
\getchunk{defclass NoneType}
\getchunk{defclass NonNegativeIntegerType}
\getchunk{defclass NottinghamGroupType}
\getchunk{defclass NumericalIntegrationProblemType}
\getchunk{defclass NumericalODEProblemType}
\getchunk{defclass NumericalOptimizationProblemType}
\getchunk{defclass NumericalPDEProblemType}
\getchunk{defclass OctonionType}
\getchunk{defclass ODEIntensityFunctionsTableType}
\getchunk{defclass OneDimensionalArrayType}
\getchunk{defclass OnePointCompletionType}
\getchunk{defclass OpenMathConnectionType}
\getchunk{defclass OpenMathDeviceType}
\getchunk{defclass OpenMathEncodingType}
\getchunk{defclass OpenMathErrorType}
\getchunk{defclass OpenMathErrorKindType}
\getchunk{defclass OperatorType}
\getchunk{defclass OppositeMonogenicLinearOperatorType}
\getchunk{defclass OrderedCompletionType}
\getchunk{defclass OrderedDirectProductType}
\getchunk{defclass OrderedFreeMonoidType}
\getchunk{defclass OrderedVariableListType}
\getchunk{defclass OrderlyDifferentialPolynomialType}
\getchunk{defclass OrderlyDifferentialVariableType}
\getchunk{defclass OrdinaryDifferentialRingType}
\getchunk{defclass OrdinaryWeightedPolynomialsType}
\getchunk{defclass OrdSetIntsType}
\getchunk{defclass OutputFormType}
\getchunk{defclass PAdicIntegerType}
\getchunk{defclass PAdicRationalType}
\getchunk{defclass PAdicRationalConstructorType}
\getchunk{defclass PaletteType}
\getchunk{defclass ParametricPlaneCurveType}
\getchunk{defclass ParametricSpaceCurveType}
\getchunk{defclass ParametricSurfaceType}
\getchunk{defclass PartialFractionType}
\getchunk{defclass PartitionType}
\getchunk{defclass PatternType}
\getchunk{defclass PatternMatchListResultType}
\getchunk{defclass PatternMatchResultType}
\getchunk{defclass PendantTreeType}
\getchunk{defclass PermutationType}
\getchunk{defclass PermutationGroupType}
\getchunk{defclass PiType}
\getchunk{defclass PlaneAlgebraicCurvePlotType}
\getchunk{defclass PlacesType}
\getchunk{defclass PlacesOverPseudoAlgebraicClosureOfFiniteFieldType}
\getchunk{defclass PlcsType}
\getchunk{defclass PlotType}
\getchunk{defclass Plot3DType}
\getchunk{defclass PoincareBirkhoffWittLyndonBasisType}
\getchunk{defclass PointType}
\getchunk{defclass PolynomialType}
\getchunk{defclass PolynomialIdealsType}
\getchunk{defclass PolynomialRingType}
\getchunk{defclass PositiveIntegerType}
\getchunk{defclass PrimeFieldType}
\getchunk{defclass PrimitiveArrayType}
\getchunk{defclass ProductType}
\getchunk{defclass ProjectivePlaneType}
\getchunk{defclass ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteFieldType}
\getchunk{defclass ProjectiveSpaceType}
\getchunk{defclass PseudoAlgebraicClosureOfAlgExtOfRationalNumberType}
\getchunk{defclass PseudoAlgebraicClosureOfFiniteFieldType}
\getchunk{defclass PseudoAlgebraicClosureOfRationalNumberType}
\getchunk{defclass QuadraticFormType}
\getchunk{defclass QuasiAlgebraicSetType}
\getchunk{defclass QuaternionType}
\getchunk{defclass QueryEquationType}
\getchunk{defclass QueueType}
\getchunk{defclass RadicalFunctionFieldType}
\getchunk{defclass RadixExpansionType}
\getchunk{defclass RealClosureType}
\getchunk{defclass RectangularMatrixType}
\getchunk{defclass ReferenceType}
\getchunk{defclass RegularChainType}
\getchunk{defclass RegularTriangularSetType}
\getchunk{defclass ResidueRingType}
\getchunk{defclass ResultType}
\getchunk{defclass RewriteRuleType}
\getchunk{defclass RightOpenIntervalRootCharacterizationType}
\getchunk{defclass RomanNumeralType}
\getchunk{defclass RoutinesTableType}
\getchunk{defclass RuleCalledType}
\getchunk{defclass RulesetType}
\getchunk{defclass ScriptFormulaFormatType}
\getchunk{defclass SegmentType}
\getchunk{defclass SegmentBindingType}
\getchunk{defclass SetType}
\getchunk{defclass SetOfMIntegersInOneToNType}
\getchunk{defclass SequentialDifferentialPolynomialType}
\getchunk{defclass SequentialDifferentialVariableType}
\getchunk{defclass SExpressionType}
\getchunk{defclass SExpressionOfType}
\getchunk{defclass SimpleAlgebraicExtensionType}
\getchunk{defclass SimpleCellType}
\getchunk{defclass SimpleFortranProgramType}
\getchunk{defclass SingleIntegerType}
\getchunk{defclass SingletonAsOrderedSetType}
\getchunk{defclass SparseEchelonMatrixType}
\getchunk{defclass SparseMultivariatePolynomialType}
\getchunk{defclass SparseMultivariateTaylorSeriesType}
\getchunk{defclass SparseTableType}
\getchunk{defclass SparseUnivariateLaurentSeriesType}
\getchunk{defclass SparseUnivariatePolynomialType}
\getchunk{defclass SparseUnivariatePolynomialExpressionsType}
\getchunk{defclass SparseUnivariatePuiseuxSeriesType}
\getchunk{defclass SparseUnivariateSkewPolynomialType}
\getchunk{defclass SparseUnivariateTaylorSeriesType}
\getchunk{defclass SplitHomogeneousDirectProductType}
\getchunk{defclass SplittingNodeType}
\getchunk{defclass SplittingTreeType}
\getchunk{defclass SquareFreeRegularTriangularSetType}
\getchunk{defclass SquareMatrixType}
\getchunk{defclass StackType}
\getchunk{defclass StochasticDifferentialType}
\getchunk{defclass StreamType}
\getchunk{defclass StringType}
\getchunk{defclass StringTableType}
\getchunk{defclass SubSpaceType}
\getchunk{defclass SubSpaceComponentPropertyType}
\getchunk{defclass SuchThatType}
\getchunk{defclass SwitchType}
\getchunk{defclass SymbolType}
\getchunk{defclass SymbolTableType}
\getchunk{defclass SymmetricPolynomialType}
\getchunk{defclass TableType}
\getchunk{defclass TableauType}
\getchunk{defclass TaylorSeriesoType}
\getchunk{defclass TexFormatType}
\getchunk{defclass TextFileType}
\getchunk{defclass TheSymbolTableType}
\getchunk{defclass ThreeDimensionalMatrixType}
\getchunk{defclass ThreeDimensionalViewportType}
\getchunk{defclass ThreeSpaceType}
\getchunk{defclass TreeType}
\getchunk{defclass TubePlotType}
\getchunk{defclass TupleType}
\getchunk{defclass TwoDimensionalArrayType}
\getchunk{defclass TwoDimensionalViewportType}
\getchunk{defclass UnivariateFormalPowerSeriesType}
\getchunk{defclass UnivariateLaurentSeriesType}
\getchunk{defclass UnivariateLaurentSeriesConstructorType}
\getchunk{defclass UnivariatePolynomialType}
\getchunk{defclass UnivariatePuiseuxSeriesType}
\getchunk{defclass UnivariatePuiseuxSeriesConstructorType}
\getchunk{defclass UnivariatePuiseuxSeriesWithExponentialSingularityType}
\getchunk{defclass UnivariateSkewPolynomialType}
\getchunk{defclass UnivariateTaylorSeriesType}
\getchunk{defclass UnivariateTaylorSeriesCZeroType}
\getchunk{defclass UniversalSegmentType}
\getchunk{defclass U8MatrixType}
\getchunk{defclass U16MatrixType}
\getchunk{defclass U32MatrixType}
\getchunk{defclass U8VectorType}
\getchunk{defclass U16VectorType}
\getchunk{defclass U32VectorType}
\getchunk{defclass VariableType}
\getchunk{defclass VectorType}
\getchunk{defclass VoidType}
\getchunk{defclass WeightedPolynomialsType}
\getchunk{defclass WuWenTsunTriangularSetType}
\getchunk{defclass XDistributedPolynomialType}
\getchunk{defclass XPBWPolynomialType}
\getchunk{defclass XPolynomialType}
\getchunk{defclass XPolynomialRingType}
\getchunk{defclass XRecursivePolynomialType}
\getchunk{defclass AffineAlgebraicSetComputeWithGroebnerBasisType}
\getchunk{defclass AffineAlgebraicSetComputeWithResultantType}
\getchunk{defclass AlgebraicFunctionType}
\getchunk{defclass AlgebraicHermiteIntegrationType}
\getchunk{defclass AlgebraicIntegrateType}
\getchunk{defclass AlgebraicIntegrationType}
\getchunk{defclass AlgebraicManipulationsType}
\getchunk{defclass AlgebraicMultFactType}
\getchunk{defclass AlgebraPackageType}
\getchunk{defclass AlgFactorType}
\getchunk{defclass AnnaNumericalIntegrationPackageType}
\getchunk{defclass AnnaNumericalOptimizationPackageType}
\getchunk{defclass AnnaOrdinaryDifferentialEquationPackageType}
\getchunk{defclass AnnaPartialDifferentialEquationPackageType}
\getchunk{defclass AnyFunctions1Type}
\getchunk{defclass ApplicationProgramInterfaceType}
\getchunk{defclass ApplyRulesType}
\getchunk{defclass ApplyUnivariateSkewPolynomialType}
\getchunk{defclass AssociatedEquationsType}
\getchunk{defclass AttachPredicatesType}
\getchunk{defclass AxiomServerType}
\getchunk{defclass BalancedFactorisationType}
\getchunk{defclass BasicOperatorFunctions1Type}
\getchunk{defclass BezierType}
\getchunk{defclass BezoutMatrixType}
\getchunk{defclass BlowUpPackageType}
\getchunk{defclass BoundIntegerRootsType}
\getchunk{defclass BrillhartTestsType}
\getchunk{defclass CartesianTensorFunctions2Type}
\getchunk{defclass ChangeOfVariableType}
\getchunk{defclass CharacteristicPolynomialInMonogenicalAlgebraType}
\getchunk{defclass CharacteristicPolynomialPackageType}
\getchunk{defclass ChineseRemainderToolsForIntegralBasesType}
\getchunk{defclass CoerceVectorMatrixPackageType}
\getchunk{defclass CombinatorialFunctionType}
\getchunk{defclass CommonDenominatorType}
\getchunk{defclass CommonOperatorsType}
\getchunk{defclass CommuteUnivariatePolynomialCategoryType}
\getchunk{defclass ComplexFactorizationType}
\getchunk{defclass ComplexFunctions2Type}
\getchunk{defclass ComplexIntegerSolveLinearPolynomialEquationType}
\getchunk{defclass ComplexPatternType}
\getchunk{defclass ComplexPatternMatchType}
\getchunk{defclass ComplexRootFindingPackageType}
\getchunk{defclass ComplexRootPackageType}
\getchunk{defclass ComplexTrigonometricManipulationsType}
\getchunk{defclass ConstantLODEType}
\getchunk{defclass CoordinateSystemsType}
\getchunk{defclass CRApackageType}
\getchunk{defclass CycleIndicatorsType}
\getchunk{defclass CyclicStreamToolsType}
\getchunk{defclass CyclotomicPolynomialPackageType}
\getchunk{defclass CylindricalAlgebraicDecompositionPackageType}
\getchunk{defclass CylindricalAlgebraicDecompositionUtilitiesType}
\getchunk{defclass DefiniteIntegrationToolsType}
\getchunk{defclass DegreeReductionPackageType}
\getchunk{defclass DesingTreePackageType}
\getchunk{defclass DiophantineSolutionPackageType}
\getchunk{defclass DirectProductFunctions2Type}
\getchunk{defclass DiscreteLogarithmPackageType}
\getchunk{defclass DisplayPackageType}
\getchunk{defclass DistinctDegreeFactorizeType}
\getchunk{defclass DoubleFloatSpecialFunctionsType}
\getchunk{defclass DoubleResultantPackageType}
\getchunk{defclass DrawComplexType}
\getchunk{defclass DrawNumericHackType}
\getchunk{defclass DrawOptionFunctions0Type}
\getchunk{defclass DrawOptionFunctions1Type}
\getchunk{defclass d01AgentsPackageType}
\getchunk{defclass d01WeightsPackageType}
\getchunk{defclass d02AgentsPackageType}
\getchunk{defclass d03AgentsPackageType}
\getchunk{defclass EigenPackageType}
\getchunk{defclass ElementaryFunctionType}
\getchunk{defclass ElementaryFunctionDefiniteIntegrationType}
\getchunk{defclass ElementaryFunctionLODESolverType}
\getchunk{defclass ElementaryFunctionODESolverType}
\getchunk{defclass ElementaryFunctionSignType}
\getchunk{defclass ElementaryFunctionStructurePackageType}
\getchunk{defclass ElementaryIntegrationType}
\getchunk{defclass ElementaryRischDEType}
\getchunk{defclass ElementaryRischDESystemType}
\getchunk{defclass EllipticFunctionsUnivariateTaylorSeriesType}
\getchunk{defclass EquationFunctions2Type}
\getchunk{defclass ErrorFunctionsType}
\getchunk{defclass EuclideanGroebnerBasisPackageType}
\getchunk{defclass EvaluateCycleIndicatorsType}
\getchunk{defclass ExpertSystemContinuityPackageType}
\getchunk{defclass ExpertSystemContinuityPackage1Type}
\getchunk{defclass ExpertSystemToolsPackageType}
\getchunk{defclass ExpertSystemToolsPackage1Type}
\getchunk{defclass ExpertSystemToolsPackage2Type}
\getchunk{defclass ExpressionFunctions2Type}
\getchunk{defclass ExpressionSolveType}
\getchunk{defclass ExpressionSpaceFunctions1Type}
\getchunk{defclass ExpressionSpaceFunctions2Type}
\getchunk{defclass ExpressionSpaceODESolverType}
\getchunk{defclass ExpressionToOpenMathType}
\getchunk{defclass ExpressionToUnivariatePowerSeriesType}
\getchunk{defclass ExpressionTubePlotType}
\getchunk{defclass Export3DType}
\getchunk{defclass e04AgentsPackageType}
\getchunk{defclass FactoredFunctionsType}
\getchunk{defclass FactoredFunctions2Type}
\getchunk{defclass FactoredFunctionUtilitiesType}
\getchunk{defclass FactoringUtilitiesType}
\getchunk{defclass FactorisationOverPseudoAlgebraicClosureOfAlgExtOfRationalNumberType}
\getchunk{defclass FactorisationOverPseudoAlgebraicClosureOfRationalNumberType}
\getchunk{defclass FGLMIfCanPackageType}
\getchunk{defclass FindOrderFiniteType}
\getchunk{defclass FiniteAbelianMonoidRingFunctions2Type}
\getchunk{defclass FiniteDivisorFunctions2Type}
\getchunk{defclass FiniteFieldFactorizationType}
\getchunk{defclass FiniteFieldFactorizationWithSizeParseBySideEffectType}
\getchunk{defclass FiniteFieldFunctionsType}
\getchunk{defclass FiniteFieldHomomorphismsType}
\getchunk{defclass FiniteFieldPolynomialPackageType}
\getchunk{defclass FiniteFieldPolynomialPackage2Type}
\getchunk{defclass FiniteFieldSolveLinearPolynomialEquationType}
\getchunk{defclass FiniteFieldSquareFreeDecompositionType}
\getchunk{defclass FiniteLinearAggregateFunctions2Type}
\getchunk{defclass FiniteLinearAggregateSortType}
\getchunk{defclass FiniteSetAggregateFunctions2Type}
\getchunk{defclass FloatingComplexPackageType}
\getchunk{defclass FloatingRealPackageType}
\getchunk{defclass FloatSpecialFunctionsType}
\getchunk{defclass FortranCodePackage1Type}
\getchunk{defclass FortranOutputStackPackageType}
\getchunk{defclass FortranPackageType}
\getchunk{defclass FractionalIdealFunctions2Type}
\getchunk{defclass FractionFreeFastGaussianType}
\getchunk{defclass FractionFreeFastGaussianFractionsType}
\getchunk{defclass FractionFunctions2Type}
\getchunk{defclass FramedNonAssociativeAlgebraFunctions2Type}
\getchunk{defclass FunctionalSpecialFunctionType}
\getchunk{defclass FunctionFieldCategoryFunctions2Type}
\getchunk{defclass FunctionFieldIntegralBasisType}
\getchunk{defclass FunctionSpaceAssertionsType}
\getchunk{defclass FunctionSpaceAttachPredicatesType}
\getchunk{defclass FunctionSpaceComplexIntegrationType}
\getchunk{defclass FunctionSpaceFunctions2Type}
\getchunk{defclass FunctionSpaceIntegrationType}
\getchunk{defclass FunctionSpacePrimitiveElementType}
\getchunk{defclass FunctionSpaceReduceType}
\getchunk{defclass FunctionSpaceSumType}
\getchunk{defclass FunctionSpaceToExponentialExpansionType}
\getchunk{defclass FunctionSpaceToUnivariatePowerSeriesType}
\getchunk{defclass FunctionSpaceUnivariatePolynomialFactorType}
\getchunk{defclass GaloisGroupFactorizationUtilitiesType}
\getchunk{defclass GaloisGroupFactorizerType}
\getchunk{defclass GaloisGroupPolynomialUtilitiesType}
\getchunk{defclass GaloisGroupUtilitiesType}
\getchunk{defclass GaussianFactorizationPackageType}
\getchunk{defclass GeneralHenselPackageType}
\getchunk{defclass GeneralizedMultivariateFactorizeType}
\getchunk{defclass GeneralPackageForAlgebraicFunctionFieldType}
\getchunk{defclass GeneralPolynomialGcdPackageType}
\getchunk{defclass GenerateUnivariatePowerSeriesType}
\getchunk{defclass GenExEuclidType}
\getchunk{defclass GenUFactorizeType}
\getchunk{defclass GenusZeroIntegrationType}
\getchunk{defclass GnuDrawType}
\getchunk{defclass GosperSummationMethodType}
\getchunk{defclass GraphicsDefaultsType}
\getchunk{defclass GraphvizType}
\getchunk{defclass GrayCodeType}
\getchunk{defclass GroebnerFactorizationPackageType}
\getchunk{defclass GroebnerInternalPackageType}
\getchunk{defclass GroebnerPackageType}
\getchunk{defclass GroebnerSolveType}
\getchunk{defclass GuessType}
\getchunk{defclass GuessAlgebraicNumberType}
\getchunk{defclass GuessFiniteType}
\getchunk{defclass GuessFiniteFunctionsType}
\getchunk{defclass GuessIntegerType}
\getchunk{defclass GuessPolynomialType}
\getchunk{defclass GuessUnivariatePolynomialType}
\getchunk{defclass HallBasisType}
\getchunk{defclass HeuGcdType}
\getchunk{defclass IdealDecompositionPackageType}
\getchunk{defclass IncrementingMapsType}
\getchunk{defclass InfiniteProductCharacteristicZeroType}
\getchunk{defclass InfiniteProductFiniteFieldType}
\getchunk{defclass InfiniteProductPrimeFieldType}
\getchunk{defclass InfiniteTupleFunctions2Type}
\getchunk{defclass InfiniteTupleFunctions3Type}
\getchunk{defclass InfinityType}
\getchunk{defclass InnerAlgFactorType}
\getchunk{defclass InnerCommonDenominatorType}
\getchunk{defclass InnerMatrixLinearAlgebraFunctionsType}
\getchunk{defclass InnerMatrixQuotientFieldFunctionsType}
\getchunk{defclass InnerModularGcdType}
\getchunk{defclass InnerMultFactType}
\getchunk{defclass InnerNormalBasisFieldFunctionsType}
\getchunk{defclass InnerNumericEigenPackageType}
\getchunk{defclass InnerNumericFloatSolvePackageType}
\getchunk{defclass InnerPolySignType}
\getchunk{defclass InnerPolySumType}
\getchunk{defclass InnerTrigonometricManipulationsType}
\getchunk{defclass InputFormFunctions1Type}
\getchunk{defclass InterfaceGroebnerPackageType}
\getchunk{defclass IntegerBitsType}
\getchunk{defclass IntegerCombinatoricFunctionsType}
\getchunk{defclass IntegerFactorizationPackageType}
\getchunk{defclass IntegerLinearDependenceType}
\getchunk{defclass IntegerNumberTheoryFunctionsType}
\getchunk{defclass IntegerPrimesPackageType}
\getchunk{defclass IntegerRetractionsType}
\getchunk{defclass IntegerRootsType}
\getchunk{defclass IntegerSolveLinearPolynomialEquationType}
\getchunk{defclass IntegralBasisToolsType}
\getchunk{defclass IntegralBasisPolynomialToolsType}
\getchunk{defclass IntegrationResultFunctions2Type}
\getchunk{defclass IntegrationResultRFToFunctionType}
\getchunk{defclass IntegrationResultToFunctionType}
\getchunk{defclass IntegrationToolsType}
\getchunk{defclass InternalPrintPackageType}
\getchunk{defclass InternalRationalUnivariateRepresentationPackageType}
\getchunk{defclass InterpolateFormsPackageType}
\getchunk{defclass IntersectionDivisorPackageType}
\getchunk{defclass IrredPolyOverFiniteFieldType}
\getchunk{defclass IrrRepSymNatPackageType}
\getchunk{defclass InverseLaplaceTransformType}
\getchunk{defclass KernelFunctions2Type}
\getchunk{defclass KovacicType}
\getchunk{defclass LaplaceTransformType}
\getchunk{defclass LazardSetSolvingPackageType}
\getchunk{defclass LeadingCoefDeterminationType}
\getchunk{defclass LexTriangularPackageType}
\getchunk{defclass LinearDependenceType}
\getchunk{defclass LinearOrdinaryDifferentialOperatorFactorizerType}
\getchunk{defclass LinearOrdinaryDifferentialOperatorsOpsType}
\getchunk{defclass LinearPolynomialEquationByFractionsType}
\getchunk{defclass LinearSystemFromPowerSeriesPackageType}
\getchunk{defclass LinearSystemMatrixPackageType}
\getchunk{defclass LinearSystemMatrixPackage1Type}
\getchunk{defclass LinearSystemPolynomialPackageType}
\getchunk{defclass LinGroebnerPackageType}
\getchunk{defclass LinesOpPackType}
\getchunk{defclass LiouvillianFunctionType}
\getchunk{defclass ListFunctions2Type}
\getchunk{defclass ListFunctions3Type}
\getchunk{defclass ListToMapType}
\getchunk{defclass LocalParametrizationOfSimplePointPackageType}
\getchunk{defclass MakeBinaryCompiledFunctionType}
\getchunk{defclass MakeFloatCompiledFunctionType}
\getchunk{defclass MakeFunctionType}
\getchunk{defclass MakeRecordType}
\getchunk{defclass MakeUnaryCompiledFunctionType}
\getchunk{defclass MappingPackageInternalHacks1Type}
\getchunk{defclass MappingPackageInternalHacks2Type}
\getchunk{defclass MappingPackageInternalHacks3Type}
\getchunk{defclass MappingPackage1Type}
\getchunk{defclass MappingPackage2Type}
\getchunk{defclass MappingPackage3Type}
\getchunk{defclass MappingPackage4Type}
\getchunk{defclass MatrixCategoryFunctions2Type}
\getchunk{defclass MatrixCommonDenominatorType}
\getchunk{defclass MatrixLinearAlgebraFunctionsType}
\getchunk{defclass MatrixManipulationType}
\getchunk{defclass MergeThingType}
\getchunk{defclass MeshCreationRoutinesForThreeDimensionsType}
\getchunk{defclass ModularDistinctDegreeFactorizerType}
\getchunk{defclass ModularHermitianRowReductionType}
\getchunk{defclass MonoidRingFunctions2Type}
\getchunk{defclass MonomialExtensionToolsType}
\getchunk{defclass MoreSystemCommandsType}
\getchunk{defclass MPolyCatPolyFactorizerType}
\getchunk{defclass MPolyCatRationalFunctionFactorizerType}
\getchunk{defclass MPolyCatFunctions2Type}
\getchunk{defclass MPolyCatFunctions3Type}
\getchunk{defclass MRationalFactorizeType}
\getchunk{defclass MultFiniteFactorizeType}
\getchunk{defclass MultipleMapType}
\getchunk{defclass MultiVariableCalculusFunctionsType}
\getchunk{defclass MultivariateFactorizeType}
\getchunk{defclass MultivariateLiftingType}
\getchunk{defclass MultivariateSquareFreeType}
\getchunk{defclass NagEigenPackageType}
\getchunk{defclass NagFittingPackageType}
\getchunk{defclass NagLinearEquationSolvingPackageType}
\getchunk{defclass NAGLinkSupportPackageType}
\getchunk{defclass NagIntegrationPackageType}
\getchunk{defclass NagInterpolationPackageType}
\getchunk{defclass NagLapackType}
\getchunk{defclass NagMatrixOperationsPackageType}
\getchunk{defclass NagOptimisationPackageType}
\getchunk{defclass NagOrdinaryDifferentialEquationsPackageType}
\getchunk{defclass NagPartialDifferentialEquationsPackageType}
\getchunk{defclass NagPolynomialRootsPackageType}
\getchunk{defclass NagRootFindingPackageType}
\getchunk{defclass NagSeriesSummationPackageType}
\getchunk{defclass NagSpecialFunctionsPackageType}
\getchunk{defclass NewSparseUnivariatePolynomialFunctions2Type}
\getchunk{defclass NewtonInterpolationType}
\getchunk{defclass NewtonPolygonType}
\getchunk{defclass NonCommutativeOperatorDivisionType}
\getchunk{defclass NoneFunctions1Type}
\getchunk{defclass NonLinearFirstOrderODESolverType}
\getchunk{defclass NonLinearSolvePackageType}
\getchunk{defclass NormalizationPackageType}
\getchunk{defclass NormInMonogenicAlgebraType}
\getchunk{defclass NormRetractPackageType}
\getchunk{defclass NPCoefType}
\getchunk{defclass NumberFieldIntegralBasisType}
\getchunk{defclass NumberFormatsType}
\getchunk{defclass NumberTheoreticPolynomialFunctionsType}
\getchunk{defclass NumericType}
\getchunk{defclass NumericalOrdinaryDifferentialEquationsType}
\getchunk{defclass NumericalQuadratureType}
\getchunk{defclass NumericComplexEigenPackageType}
\getchunk{defclass NumericContinuedFractionType}
\getchunk{defclass NumericRealEigenPackageType}
\getchunk{defclass NumericTubePlotType}
\getchunk{defclass OctonionCategoryFunctions2Type}
\getchunk{defclass ODEIntegrationType}
\getchunk{defclass ODEToolsType}
\getchunk{defclass OneDimensionalArrayFunctions2Type}
\getchunk{defclass OnePointCompletionFunctions2Type}
\getchunk{defclass OpenMathPackageType}
\getchunk{defclass OpenMathServerPackageType}
\getchunk{defclass OperationsQueryType}
\getchunk{defclass OrderedCompletionFunctions2Type}
\getchunk{defclass OrderingFunctionsType}
\getchunk{defclass OrthogonalPolynomialFunctionsType}
\getchunk{defclass OutputPackageType}
\getchunk{defclass PackageForAlgebraicFunctionFieldType}
\getchunk{defclass PackageForAlgebraicFunctionFieldOverFiniteFieldType}
\getchunk{defclass PackageForPolyType}
\getchunk{defclass PadeApproximantPackageType}
\getchunk{defclass PadeApproximantsType}
\getchunk{defclass PAdicWildFunctionFieldIntegralBasisType}
\getchunk{defclass ParadoxicalCombinatorsForStreamsType}
\getchunk{defclass ParametricLinearEquationsType}
\getchunk{defclass ParametricPlaneCurveFunctions2Type}
\getchunk{defclass ParametricSpaceCurveFunctions2Type}
\getchunk{defclass ParametricSurfaceFunctions2Type}
\getchunk{defclass ParametrizationPackageType}
\getchunk{defclass PartialFractionPackageType}
\getchunk{defclass PartitionsAndPermutationsType}
\getchunk{defclass PatternFunctions1Type}
\getchunk{defclass PatternFunctions2Type}
\getchunk{defclass PatternMatchType}
\getchunk{defclass PatternMatchAssertionsType}
\getchunk{defclass PatternMatchFunctionSpaceType}
\getchunk{defclass PatternMatchIntegerNumberSystemType}
\getchunk{defclass PatternMatchIntegrationType}
\getchunk{defclass PatternMatchKernelType}
\getchunk{defclass PatternMatchListAggregateType}
\getchunk{defclass PatternMatchPolynomialCategoryType}
\getchunk{defclass PatternMatchPushDownType}
\getchunk{defclass PatternMatchQuotientFieldCategoryType}
\getchunk{defclass PatternMatchResultFunctions2Type}
\getchunk{defclass PatternMatchSymbolType}
\getchunk{defclass PatternMatchToolsType}
\getchunk{defclass PermanentType}
\getchunk{defclass PermutationGroupExamplesType}
\getchunk{defclass PiCoercionsType}
\getchunk{defclass PlotFunctions1Type}
\getchunk{defclass PlotToolsType}
\getchunk{defclass ProjectiveAlgebraicSetPackageType}
\getchunk{defclass PointFunctions2Type}
\getchunk{defclass PointPackageType}
\getchunk{defclass PointsOfFiniteOrderType}
\getchunk{defclass PointsOfFiniteOrderRationalType}
\getchunk{defclass PointsOfFiniteOrderToolsType}
\getchunk{defclass PolynomialPackageForCurveType}
\getchunk{defclass PolToPolType}
\getchunk{defclass PolyGroebnerType}
\getchunk{defclass PolynomialAN2ExpressionType}
\getchunk{defclass PolynomialCategoryLiftingType}
\getchunk{defclass PolynomialCategoryQuotientFunctionsType}
\getchunk{defclass PolynomialCompositionType}
\getchunk{defclass PolynomialDecompositionType}
\getchunk{defclass PolynomialFactorizationByRecursionType}
\getchunk{defclass PolynomialFactorizationByRecursionUnivariateType}
\getchunk{defclass PolynomialFunctions2Type}
\getchunk{defclass PolynomialGcdPackageType}
\getchunk{defclass PolynomialInterpolationType}
\getchunk{defclass PolynomialInterpolationAlgorithmsType}
\getchunk{defclass PolynomialNumberTheoryFunctionsType}
\getchunk{defclass PolynomialRootsType}
\getchunk{defclass PolynomialSetUtilitiesPackageType}
\getchunk{defclass PolynomialSolveByFormulasType}
\getchunk{defclass PolynomialSquareFreeType}
\getchunk{defclass PolynomialToUnivariatePolynomialType}
\getchunk{defclass PowerSeriesLimitPackageType}
\getchunk{defclass PrecomputedAssociatedEquationsType}
\getchunk{defclass PrimitiveArrayFunctions2Type}
\getchunk{defclass PrimitiveElementType}
\getchunk{defclass PrimitiveRatDEType}
\getchunk{defclass PrimitiveRatRicDEType}
\getchunk{defclass PrintPackageType}
\getchunk{defclass PseudoLinearNormalFormType}
\getchunk{defclass PseudoRemainderSequenceType}
\getchunk{defclass PureAlgebraicIntegrationType}
\getchunk{defclass PureAlgebraicLODEType}
\getchunk{defclass PushVariablesType}
\getchunk{defclass QuasiAlgebraicSet2Type}
\getchunk{defclass QuasiComponentPackageType}
\getchunk{defclass QuotientFieldCategoryFunctions2Type}
\getchunk{defclass QuaternionCategoryFunctions2Type}
\getchunk{defclass RadicalEigenPackageType}
\getchunk{defclass RadicalSolvePackageType}
\getchunk{defclass RadixUtilitiesType}
\getchunk{defclass RandomDistributionsType}
\getchunk{defclass RandomFloatDistributionsType}
\getchunk{defclass RandomIntegerDistributionsType}
\getchunk{defclass RandomNumberSourceType}
\getchunk{defclass RationalFactorizeType}
\getchunk{defclass RationalFunctionType}
\getchunk{defclass RationalFunctionDefiniteIntegrationType}
\getchunk{defclass RationalFunctionFactorType}
\getchunk{defclass RationalFunctionFactorizerType}
\getchunk{defclass RationalFunctionIntegrationType}
\getchunk{defclass RationalFunctionLimitPackageType}
\getchunk{defclass RationalFunctionSignType}
\getchunk{defclass RationalFunctionSumType}
\getchunk{defclass RationalIntegrationType}
\getchunk{defclass RationalInterpolationType}
\getchunk{defclass RationalLODEType}
\getchunk{defclass RationalRetractionsType}
\getchunk{defclass RationalRicDEType}
\getchunk{defclass RationalUnivariateRepresentationPackageType}
\getchunk{defclass RealPolynomialUtilitiesPackageType}
\getchunk{defclass RealSolvePackageType}
\getchunk{defclass RealZeroPackageType}
\getchunk{defclass RealZeroPackageQType}
\getchunk{defclass RectangularMatrixCategoryFunctions2Type}
\getchunk{defclass RecurrenceOperatorType}
\getchunk{defclass ReducedDivisorType}
\getchunk{defclass ReduceLODEType}
\getchunk{defclass ReductionOfOrderType}
\getchunk{defclass RegularSetDecompositionPackageType}
\getchunk{defclass RegularTriangularSetGcdPackageType}
\getchunk{defclass RepeatedDoublingType}
\getchunk{defclass RepeatedSquaringType}
\getchunk{defclass RepresentationPackage1Type}
\getchunk{defclass RepresentationPackage2Type}
\getchunk{defclass ResolveLatticeCompletionType}
\getchunk{defclass RetractSolvePackageType}
\getchunk{defclass RootsFindingPackageType}
\getchunk{defclass SAERationalFunctionAlgFactorType}
\getchunk{defclass ScriptFormulaFormat1Type}
\getchunk{defclass SegmentBindingFunctions2Type}
\getchunk{defclass SegmentFunctions2Type}
\getchunk{defclass SimpleAlgebraicExtensionAlgFactorType}
\getchunk{defclass SimplifyAlgebraicNumberConvertPackageType}
\getchunk{defclass SmithNormalFormType}
\getchunk{defclass SortedCacheType}
\getchunk{defclass SortPackageType}
\getchunk{defclass SparseUnivariatePolynomialFunctions2Type}
\getchunk{defclass SpecialOutputPackageType}
\getchunk{defclass SquareFreeQuasiComponentPackageType}
\getchunk{defclass SquareFreeRegularSetDecompositionPackageType}
\getchunk{defclass SquareFreeRegularTriangularSetGcdPackageType}
\getchunk{defclass StorageEfficientMatrixOperationsType}
\getchunk{defclass StreamFunctions1Type}
\getchunk{defclass StreamFunctions2Type}
\getchunk{defclass StreamFunctions3Type}
\getchunk{defclass StreamInfiniteProductType}
\getchunk{defclass StreamTaylorSeriesOperationsType}
\getchunk{defclass StreamTensorType}
\getchunk{defclass StreamTranscendentalFunctionsType}
\getchunk{defclass StreamTranscendentalFunctionsNonCommutativeType}
\getchunk{defclass StructuralConstantsPackageType}
\getchunk{defclass SturmHabichtPackageType}
\getchunk{defclass SubResultantPackageType}
\getchunk{defclass SupFractionFactorizerType}
\getchunk{defclass SystemODESolverType}
\getchunk{defclass SystemSolvePackageType}
\getchunk{defclass SymmetricGroupCombinatoricFunctionsType}
\getchunk{defclass SymmetricFunctionsType}
\getchunk{defclass TableauxBumpersType}
\getchunk{defclass TabulatedComputationPackageType}
\getchunk{defclass TangentExpansionsType}
\getchunk{defclass TaylorSolveType}
\getchunk{defclass TemplateUtilitiesType}
\getchunk{defclass TexFormat1Type}
\getchunk{defclass ToolsForSignType}
\getchunk{defclass TopLevelDrawFunctionsType}
\getchunk{defclass TopLevelDrawFunctionsForAlgebraicCurvesType}
\getchunk{defclass TopLevelDrawFunctionsForCompiledFunctionsType}
\getchunk{defclass TopLevelDrawFunctionsForPointsType}
\getchunk{defclass TopLevelThreeSpaceType}
\getchunk{defclass TranscendentalHermiteIntegrationType}
\getchunk{defclass TranscendentalIntegrationType}
\getchunk{defclass TranscendentalManipulationsType}
\getchunk{defclass TranscendentalRischDEType}
\getchunk{defclass TranscendentalRischDESystemType}
\getchunk{defclass TransSolvePackageType}
\getchunk{defclass TransSolvePackageServiceType}
\getchunk{defclass TriangularMatrixOperationsType}
\getchunk{defclass TrigonometricManipulationsType}
\getchunk{defclass TubePlotToolsType}
\getchunk{defclass TwoDimensionalPlotClippingType}
\getchunk{defclass TwoFactorizeType}
\getchunk{defclass UnivariateFactorizeType}
\getchunk{defclass UnivariateFormalPowerSeriesFunctionsType}
\getchunk{defclass UnivariateLaurentSeriesFunctions2Type}
\getchunk{defclass UnivariatePolynomialCategoryFunctions2Type}
\getchunk{defclass UnivariatePolynomialCommonDenominatorType}
\getchunk{defclass UnivariatePolynomialDecompositionPackageType}
\getchunk{defclass UnivariatePolynomialDivisionPackageType}
\getchunk{defclass UnivariatePolynomialFunctions2Type}
\getchunk{defclass UnivariatePolynomialMultiplicationPackageType}
\getchunk{defclass UnivariatePolynomialSquareFreeType}
\getchunk{defclass UnivariatePuiseuxSeriesFunctions2Type}
\getchunk{defclass UnivariateSkewPolynomialCategoryOpsType}
\getchunk{defclass UnivariateTaylorSeriesFunctions2Type}
\getchunk{defclass UnivariateTaylorSeriesODESolverType}
\getchunk{defclass UniversalSegmentFunctions2Type}
\getchunk{defclass UserDefinedPartialOrderingType}
\getchunk{defclass UserDefinedVariableOrderingType}
\getchunk{defclass UTSodetoolsType}
\getchunk{defclass U32VectorPolynomialOperationsType}
\getchunk{defclass VectorFunctions2Type}
\getchunk{defclass ViewDefaultsPackageType}
\getchunk{defclass ViewportPackageType}
\getchunk{defclass WeierstrassPreparationType}
\getchunk{defclass WildFunctionFieldIntegralBasisType}
\getchunk{defclass XExponentialPackageType}
\getchunk{defclass ZeroDimensionalSolvePackageType}

\end{chunk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cleardoublepage
\chapter{Bibliography}
\bibliographystyle{axiom}
\bibliography{axiom}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cleardoublepage
\chapter{Documetation Index}
\printindex[doc]
\chapter{Code Index}
\printindex[code]
\chapter{Category Index}
\printindex[cat]
\chapter{Domain Index}
\printindex[dom]
\chapter{Package Index}
\printindex[pkg]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
