From MAILER-DAEMON Sun Mar 01 13:31:26 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LdqRi-0004SA-GX
	for mharc-axiom-developer@gnu.org; Sun, 01 Mar 2009 13:31:26 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LdqRf-0004Pm-OF
	for axiom-developer@nongnu.org; Sun, 01 Mar 2009 13:31:23 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LdqRe-0004Np-0e
	for axiom-developer@nongnu.org; Sun, 01 Mar 2009 13:31:23 -0500
Received: from [199.232.76.173] (port=37853 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LdqRd-0004Na-Kz
	for axiom-developer@nongnu.org; Sun, 01 Mar 2009 13:31:21 -0500
Received: from mx-7.zoominternet.net ([24.154.1.26]:37830
	helo=cm-1.zoominternet.net)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LdqRd-0001vs-91
	for axiom-developer@nongnu.org; Sun, 01 Mar 2009 13:31:21 -0500
X-SpamGroup: 2000
X-CM-Cat: Undefined:Undefined
X-CNFS-Analysis: v=1.0 c=1 a=E8rTNAPPKTgA:10 a=9x1qJYSYWOoMgoVr+WVG7Q==:17
	a=kQdW4eRVv-W8tftlqXYA:9 a=u56mCrToxNyG-5CPT2igB294TroA:4
	a=8b0TY1xhFYQA:10
X-CM-Score: 0
X-Scanned-by: Cloudmark Authority Engine
Received: from [24.154.1.45] ([24.154.1.45:57536] helo=pop-2.zoominternet.net)
	by mx-7.zoominternet.net (envelope-from <daly@axiom-developer.org>)
	(ecelerity 2.2.2.30 r(24168)) with ESMTP
	id 11/A4-13570-674DAA94; Sun, 01 Mar 2009 13:31:18 -0500
Received: (qmail 9862 invoked from network); 1 Mar 2009 18:31:18 -0000
Received: from unknown (HELO localhost.localdomain) ([72.23.19.139])
	(envelope-sender <daly@axiom-developer.org>)
	by pop-2.zoominternet.net (qmail-ldap-1.03) with SMTP
	for <daly@axiom-developer.org>; 1 Mar 2009 18:31:18 -0000
Received: (from root@localhost)
	by localhost.localdomain (8.11.6/8.11.6) id n215BJg28837;
	Sun, 1 Mar 2009 00:11:19 -0500
Date: Sun, 1 Mar 2009 00:11:19 -0500
Message-Id: <200903010511.n215BJg28837@localhost.localdomain>
From: root <daly@axiom-developer.org>
To: camm@maguirefamily.org
In-reply-to: <87ab86ryhj.fsf@maguirefamily.org> (message from Camm Maguire on
	Sat, 28 Feb 2009 17:24:40 -0500)
References: <200812170459.mBH4xOd17234@localhost.localdomain>
	<87eiyd8na4.fsf@maguirefamily.org>
	<200902051354.n15Dsb221922@localhost.localdomain>
	<87iqn41rbp.fsf@maguirefamily.org>
	<200902220708.n1M78vt15122@localhost.localdomain>
	<87vdr1ate8.fsf_-_@maguirefamily.org>
	<200902232250.n1NMoBR23993@localhost.localdomain>
	<87skm32x6x.fsf_-_@maguirefamily.org>
	<200902250355.n1P3tQm25134@localhost.localdomain>
	<200902270047.n1R0lDf26998@localhost.localdomain>
	<87ab86ryhj.fsf@maguirefamily.org>
X-detected-operating-system: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: axiom-developer@nongnu.org, gcl-devel@gnu.org
Subject: [Axiom-developer] Re: Debian axiom build failures
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
Reply-To: daly@axiom-developer.org
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sun, 01 Mar 2009 18:31:24 -0000

Camm,

#\Newline is a character in the input stream. 
If (read-char-no-hang) returns nil when there is no character
and it retuns nil on a newline how can I distinguish the cases?

Tim



From MAILER-DAEMON Sun Mar 01 13:31:26 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LdqRi-0004SL-P0
	for mharc-axiom-developer@gnu.org; Sun, 01 Mar 2009 13:31:26 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LdqRf-0004Pt-UB
	for axiom-developer@nongnu.org; Sun, 01 Mar 2009 13:31:24 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LdqRd-0004N1-6B
	for axiom-developer@nongnu.org; Sun, 01 Mar 2009 13:31:21 -0500
Received: from [199.232.76.173] (port=37848 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LdqRd-0004Mo-0X
	for axiom-developer@nongnu.org; Sun, 01 Mar 2009 13:31:21 -0500
Received: from mx-7.zoominternet.net ([24.154.1.26]:37830
	helo=cm-1.zoominternet.net)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LdqRc-0001vs-Oj
	for axiom-developer@nongnu.org; Sun, 01 Mar 2009 13:31:20 -0500
X-SpamGroup: 2000
X-CM-Cat: Undefined:Undefined
X-CNFS-Analysis: v=1.0 c=1 a=E8rTNAPPKTgA:10 a=9x1qJYSYWOoMgoVr+WVG7Q==:17
	a=EyYNy4HPGMF-m8bVJx4A:9 a=_LD5mVI6u-Mq49aYC102jMby0BUA:4
	a=8b0TY1xhFYQA:10
X-CM-Score: 0
X-Scanned-by: Cloudmark Authority Engine
Received: from [24.154.1.45] ([24.154.1.45:57507] helo=pop-2.zoominternet.net)
	by mx-7.zoominternet.net (envelope-from <daly@axiom-developer.org>)
	(ecelerity 2.2.2.30 r(24168)) with ESMTP
	id ED/94-13570-574DAA94; Sun, 01 Mar 2009 13:31:17 -0500
Received: (qmail 9820 invoked from network); 1 Mar 2009 18:31:17 -0000
Received: from unknown (HELO localhost.localdomain) ([72.23.19.139])
	(envelope-sender <daly@axiom-developer.org>)
	by pop-2.zoominternet.net (qmail-ldap-1.03) with SMTP
	for <daly@axiom-developer.org>; 1 Mar 2009 18:31:17 -0000
Received: (from root@localhost)
	by localhost.localdomain (8.11.6/8.11.6) id n216QhR28847;
	Sun, 1 Mar 2009 01:26:43 -0500
Date: Sun, 1 Mar 2009 01:26:43 -0500
Message-Id: <200903010626.n216QhR28847@localhost.localdomain>
From: root <daly@axiom-developer.org>
To: camm@maguirefamily.org
In-reply-to: <87ab86ryhj.fsf@maguirefamily.org> (message from Camm Maguire on
	Sat, 28 Feb 2009 17:24:40 -0500)
References: <200812170459.mBH4xOd17234@localhost.localdomain>
	<87eiyd8na4.fsf@maguirefamily.org>
	<200902051354.n15Dsb221922@localhost.localdomain>
	<87iqn41rbp.fsf@maguirefamily.org>
	<200902220708.n1M78vt15122@localhost.localdomain>
	<87vdr1ate8.fsf_-_@maguirefamily.org>
	<200902232250.n1NMoBR23993@localhost.localdomain>
	<87skm32x6x.fsf_-_@maguirefamily.org>
	<200902250355.n1P3tQm25134@localhost.localdomain>
	<200902270047.n1R0lDf26998@localhost.localdomain>
	<87ab86ryhj.fsf@maguirefamily.org>
X-detected-operating-system: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: axiom-developer@nongnu.org, gcl-devel@gnu.org
Subject: [Axiom-developer] Re: Debian axiom build failures
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
Reply-To: daly@axiom-developer.org
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sun, 01 Mar 2009 18:31:24 -0000

Camm,

It appears that the change to read-char-no-hang no longer returns EOF in:

(read-char-no-hang str nil 'eof)

It returns NIL instead. Thus I cannot distinguish between the lack of
a character and the end of the input data, causing an infinite loop.

Tim



From MAILER-DAEMON Sun Mar 01 13:31:27 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LdqRj-0004Sc-2a
	for mharc-axiom-developer@gnu.org; Sun, 01 Mar 2009 13:31:27 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LdqRg-0004QJ-EG
	for axiom-developer@nongnu.org; Sun, 01 Mar 2009 13:31:24 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LdqRe-0004O1-0W
	for axiom-developer@nongnu.org; Sun, 01 Mar 2009 13:31:23 -0500
Received: from [199.232.76.173] (port=37850 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LdqRd-0004NK-CC
	for axiom-developer@nongnu.org; Sun, 01 Mar 2009 13:31:21 -0500
Received: from mx-7.zoominternet.net ([24.154.1.26]:37830
	helo=cm-1.zoominternet.net)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LdqRc-0001vs-Vy
	for axiom-developer@nongnu.org; Sun, 01 Mar 2009 13:31:21 -0500
X-SpamGroup: 2000
X-CM-Cat: Undefined:Undefined
X-CNFS-Analysis: v=1.0 c=1 a=E8rTNAPPKTgA:10 a=9x1qJYSYWOoMgoVr+WVG7Q==:17
	a=InqQCJTQsiYkZ4iyn1IA:9 a=nMl-nVxfzPgG9oKl9NXZurxkbl0A:4
	a=8b0TY1xhFYQA:10
X-CM-Score: 0
X-Scanned-by: Cloudmark Authority Engine
Received: from [24.154.1.45] ([24.154.1.45:57527] helo=pop-2.zoominternet.net)
	by mx-7.zoominternet.net (envelope-from <daly@axiom-developer.org>)
	(ecelerity 2.2.2.30 r(24168)) with ESMTP
	id 5F/94-13570-574DAA94; Sun, 01 Mar 2009 13:31:17 -0500
Received: (qmail 9846 invoked from network); 1 Mar 2009 18:31:17 -0000
Received: from unknown (HELO localhost.localdomain) ([72.23.19.139])
	(envelope-sender <daly@axiom-developer.org>)
	by pop-2.zoominternet.net (qmail-ldap-1.03) with SMTP
	for <daly@axiom-developer.org>; 1 Mar 2009 18:31:17 -0000
Received: (from root@localhost)
	by localhost.localdomain (8.11.6/8.11.6) id n215ARD28835;
	Sun, 1 Mar 2009 00:10:27 -0500
Date: Sun, 1 Mar 2009 00:10:27 -0500
Message-Id: <200903010510.n215ARD28835@localhost.localdomain>
From: root <daly@axiom-developer.org>
To: camm@maguirefamily.org
In-reply-to: <87ab86ryhj.fsf@maguirefamily.org> (message from Camm Maguire on
	Sat, 28 Feb 2009 17:24:40 -0500)
References: <200812170459.mBH4xOd17234@localhost.localdomain>
	<87eiyd8na4.fsf@maguirefamily.org>
	<200902051354.n15Dsb221922@localhost.localdomain>
	<87iqn41rbp.fsf@maguirefamily.org>
	<200902220708.n1M78vt15122@localhost.localdomain>
	<87vdr1ate8.fsf_-_@maguirefamily.org>
	<200902232250.n1NMoBR23993@localhost.localdomain>
	<87skm32x6x.fsf_-_@maguirefamily.org>
	<200902250355.n1P3tQm25134@localhost.localdomain>
	<200902270047.n1R0lDf26998@localhost.localdomain>
	<87ab86ryhj.fsf@maguirefamily.org>
X-detected-operating-system: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: axiom-developer@nongnu.org, gcl-devel@gnu.org
Subject: [Axiom-developer] Re: Debian axiom build failures
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
Reply-To: daly@axiom-developer.org
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sun, 01 Mar 2009 18:31:24 -0000

Camm,

I never implemented this change because I never understood compiler::link

Tim



From MAILER-DAEMON Sun Mar 01 20:47:21 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LdxFZ-00021b-Hh
	for mharc-axiom-developer@gnu.org; Sun, 01 Mar 2009 20:47:21 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LdxFX-0001zF-Au
	for axiom-developer@nongnu.org; Sun, 01 Mar 2009 20:47:19 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LdxFW-0001yS-Ez
	for axiom-developer@nongnu.org; Sun, 01 Mar 2009 20:47:18 -0500
Received: from [199.232.76.173] (port=35895 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LdxFW-0001yI-8V
	for axiom-developer@nongnu.org; Sun, 01 Mar 2009 20:47:18 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:42031
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LdxFV-0006xn-QG
	for axiom-developer@nongnu.org; Sun, 01 Mar 2009 20:47:18 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n221lGug019860;
	Sun, 1 Mar 2009 19:47:16 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n221lC3V019847;
	Sun, 1 Mar 2009 19:47:12 -0600
Date: Sun, 1 Mar 2009 19:47:12 -0600
Message-Id: <200903020147.n221lC3V019847@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090228.01.tpd.patch (fix read-char-no-hang hang
	in )browse)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 02 Mar 2009 01:47:19 -0000

The )browse function was failing because read-char-no-hang was not
returning EOF when the stream from the browser finished. This was
recently changed in GCL and this patch backs out that change.

Tim
======================================================================
diff --git a/changelog b/changelog
index 6fdafc0..4f70b09 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,8 @@
+20090228 tpd src/axiom-website/patches.html 20090228.01.tpd.patch
+20090228 tpd lsp/Makefile add patch for read-char-no-hang
+20090228 tpd zips/gcl-2.6.8pre3.o.read.d.patch fix read-char-no-hang hang
+20090227 tpd src/axiom-website/patches.html 20090227.03.tpd.patch
+20090227 tpd books/bookvol4 Hyperdoc tutorial on making new pages
 20090227 tpd src/axiom-website/patches.html 20090227.02.tpd.patch
 20090227 tpd books/bookvol5 remove initializeInterpreterFrameRing duplicate
 20090227 tpd src/axiom-website/patches.html 20090227.01.lxx.patch
diff --git a/lsp/Makefile.pamphlet b/lsp/Makefile.pamphlet
index 0743ff6..6bdbf8d 100644
--- a/lsp/Makefile.pamphlet
+++ b/lsp/Makefile.pamphlet
@@ -217,6 +217,16 @@ but, since no initialization is needed, we simply create empty files.
 	  touch ${OBJ}/${SYS}/lib/cfuns-c.ini ; \
 	  touch ${OBJ}/${SYS}/lib/sockio-c.ini )
 @
+\subsubsection{read.d patch}
+The new read-char-no-hang change no longer returns EOF so we have
+no way to know when the browser is finished talking. This causes 
+AXSERV to hang waiting for more input which never comes. The browser
+hangs waiting for a response.
+<<gcl-2.6.8pre3.read.patch>>=
+	@(cd ${GCLVERSION}/o ; \
+	  echo 100 applying read.d patch to o/read.d ; \
+	  ${PATCH} <${SPD}/zips/${GCLVERSION}.o.read.d.patch )
+@
 \subsubsection{fortran patch}
 Communication over sockets (basically to the NAG fortran library)
 requires us to have XDR enabled.
@@ -1222,6 +1232,7 @@ gcldir:
 <<gcl-2.6.8pre3.libspad.patch>>
 <<gcl-2.6.8pre3.toploop.patch>>
 <<gcl-2.6.8pre3.collectfn.fix>>
+<<gcl-2.6.8pre3.read.patch>>
 <<gclConfigureMake>>
 	@echo 13 finished system build on `date` | tee >gcldir
 
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index c029a9f..f2372ac 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -977,5 +977,7 @@ bookvol10.3 document UnivariateSkewPolynomial<br/>
 bookvol5 remove duplicate function<br/>
 <a href="patches/20090227.03.tpd.patch">20090227.03.tpd.patch</a>
 bookvol4 Hyperdoc tutorial on making new pages<br/>
+<a href="patches/20090228.01.tpd.patch">20090228.01.tpd.patch</a>
+gcl-2.6.8pre3.o.read.d.patch fix read-char-no-hang<br/>
  </body>
 </html>
diff --git a/zips/gcl-2.6.8pre3.o.read.d.patch b/zips/gcl-2.6.8pre3.o.read.d.patch
new file mode 100644
index 0000000..2c14c82
--- /dev/null
+++ b/zips/gcl-2.6.8pre3.o.read.d.patch
@@ -0,0 +1,11 @@
+--- read.tpd	2009-02-20 00:02:00.000000000 -0500
++++ read.d	2009-02-20 00:02:52.000000000 -0500
+@@ -2272,7 +2272,7 @@
+ 	else if (strm == Ct)
+ 		strm = symbol_value(sLAterminal_ioA);
+ 	check_type_stream(&strm);
+-	if (stream_at_end(strm)) {
++	if (!listen_stream(strm)) {
+ 		if (eof_errorp == Cnil)
+ 			@(return eof_value)
+ 		else



From MAILER-DAEMON Tue Mar 03 07:17:45 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LeTZB-00012F-AK
	for mharc-axiom-developer@gnu.org; Tue, 03 Mar 2009 07:17:45 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LeTZ9-00011X-Jx
	for axiom-developer@nongnu.org; Tue, 03 Mar 2009 07:17:43 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LeTZ7-00010r-O0
	for axiom-developer@nongnu.org; Tue, 03 Mar 2009 07:17:42 -0500
Received: from [199.232.76.173] (port=52327 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LeTZ7-00010m-IK
	for axiom-developer@nongnu.org; Tue, 03 Mar 2009 07:17:41 -0500
Received: from mx-8.zoominternet.net ([24.154.1.27]:35230
	helo=cm-2.zoominternet.net)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LeTZ7-0001Uq-4z
	for axiom-developer@nongnu.org; Tue, 03 Mar 2009 07:17:41 -0500
X-SpamGroup: 2000
X-CM-Cat: Undefined:Undefined
X-CNFS-Analysis: v=1.0 c=1 a=E8rTNAPPKTgA:10 a=9x1qJYSYWOoMgoVr+WVG7Q==:17
	a=x28F8WKIEYrvlVzX1n8A:9 a=b3bWEaX64ajTTMIch81hLY0ORR0A:4
	a=7mayv77iRtYA:10
X-CM-Score: 0
X-Scanned-by: Cloudmark Authority Engine
Received: from [24.154.1.47] ([24.154.1.47:40790] helo=pop-4.zoominternet.net)
	by mx-8.zoominternet.net (envelope-from <daly@axiom-developer.org>)
	(ecelerity 2.2.2.30 r(24168)) with ESMTP
	id E8/58-09796-5DF1DA94; Tue, 03 Mar 2009 07:17:25 -0500
Received: (qmail 2059 invoked from network); 3 Mar 2009 12:17:28 -0000
Received: from unknown (HELO localhost.localdomain) ([72.23.19.139])
	(envelope-sender <daly@axiom-developer.org>)
	by pop-4.zoominternet.net (qmail-ldap-1.03) with SMTP
	for <daly@axiom-developer.org>; 3 Mar 2009 12:17:28 -0000
Received: (from root@localhost)
	by localhost.localdomain (8.11.6/8.11.6) id n23D3s305351;
	Tue, 3 Mar 2009 08:03:54 -0500
Date: Tue, 3 Mar 2009 08:03:54 -0500
Message-Id: <200903031303.n23D3s305351@localhost.localdomain>
From: root <daly@axiom-developer.org>
To: "Waldek Hebisch" <hebisch@math.uni.wroc.pl>,
	"Martin Rubey" <martin.rubey@univie.ac.at>
X-detected-operating-system: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: axiom-developer@nongnu.org
Subject: [Axiom-developer] getDomains
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
Reply-To: daly@axiom-developer.org
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Tue, 03 Mar 2009 12:17:43 -0000

Your function

getDomains(cat:Symbol):Set Symbol ==
 set map(d+->symbol first destruct first destruct d, destruct domainsOf(cat,nil)$Lisp)

can trigger an autoload of the browser if you add |domainsOf| to the
browser-functions list in util.lisp

alternatively, you can call:

)lisp (|browserAutoloadOnceTrigger|) 

before using the function.

Tim

         



From MAILER-DAEMON Tue Mar 03 13:48:01 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LeZer-0007Pu-63
	for mharc-axiom-developer@gnu.org; Tue, 03 Mar 2009 13:48:01 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LeZep-0007PV-St
	for axiom-developer@nongnu.org; Tue, 03 Mar 2009 13:47:59 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LeZek-0007Nh-JK
	for axiom-developer@nongnu.org; Tue, 03 Mar 2009 13:47:58 -0500
Received: from [199.232.76.173] (port=33263 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LeZek-0007Ne-EZ
	for axiom-developer@nongnu.org; Tue, 03 Mar 2009 13:47:54 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:55535
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LeZeh-0003by-DH
	for axiom-developer@nongnu.org; Tue, 03 Mar 2009 13:47:53 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n23Ilnug020590;
	Tue, 3 Mar 2009 12:47:49 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n23Illsp020575;
	Tue, 3 Mar 2009 12:47:47 -0600
Date: Tue, 3 Mar 2009 12:47:47 -0600
Message-Id: <200903031847.n23Illsp020575@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090302.01.tpd.patch (bookvol5 add user command
	documentation)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Tue, 03 Mar 2009 18:48:00 -0000

The first level of structure for user commands was added to 
book volume 5: Axiom Interpreter

This is the first step in the process of tree-shaking out the user
command code.


======================================================================
diff --git a/books/bookvol0.pamphlet b/books/bookvol0.pamphlet
index cbe733b..caca555 100644
--- a/books/bookvol0.pamphlet
+++ b/books/bookvol0.pamphlet
@@ -67820,4 +67820,3 @@ Springer-Verlag, New York, NY 1992 ISBN 0-387-97855-0
 \end{thebibliography}
 \printindex
 \end{document}
->
\ No newline at end of file
diff --git a/books/bookvol5.pamphlet b/books/bookvol5.pamphlet
index 850e46d..c2c2f17 100644
--- a/books/bookvol5.pamphlet
+++ b/books/bookvol5.pamphlet
@@ -23,6 +23,17 @@
 \special{pdf:dest (#1) [ @thispage /FitH @ypos ]}}
 
 %%
+%% cmdhead consolidates standard command page setup
+%%
+\newcommand{\cmdhead}[1]{% e.g. \cmdhead{name}
+\chapter{)#1~Command}%
+\label{#1}%
+\index{#1}%
+\section{#1 man page}%
+\index{mapage!#1}%
+\index{#1!manpage}}
+
+%%
 %% pagehead consolidates standard page indexing
 %%
 \newcommand{\pagehead}[2]{% e.g. \pagehead{name}{abb}
@@ -80,6 +91,11 @@
 \index{#2!#1}%
 #2}
 
+%% these commands are used in the man page descriptions for each command
+%% they should probably be replaced by other equivalents
+\newcommand{\lanb}{{\tt [}}
+\newcommand{\ranb}{{\tt ]}}
+\newcommand{\vertline}{$|$}
 
 % struggle with latex figure-floating behavior
 \renewcommand\floatpagefraction{.9}
@@ -345,15 +361,7 @@ information is initialized.
 
 @
 \subsection{defun spad}
-\begin{verbatim}
-spad() ==
-  -- starts the interpreter but does not read in profiles, etc.
-  $PrintCompilerMessageIfTrue: local
-  $inLispVM : local := nil
-  setOutputAlgebra "%initialize%"
-  runspad()
-  'EndOfSpad
-\end{verbatim}
+Starts the interpreter but does not read in profiles, etc.
 <<defun spad>>=
 (defun |spad| () 
  (prog (|$PrintCompilerMessageIfTrue| |$inLispVM|) 
@@ -368,14 +376,6 @@ spad() ==
 
 @
 \subsection{defun runspad}
-\begin{verbatim}
-runspad() ==
-  mode:='restart
-  while mode='restart repeat
-    resetStackLimits()
-    CATCH($quitTag, CATCH('coerceFailure,
-                  mode:=CATCH('top__level, ncTopLevel())))
-\end{verbatim}
 <<defun runspad>>=
 (defun |runspad| () 
  (prog (mode) 
@@ -395,34 +395,21 @@ runspad() ==
 
 @
 \subsection{defun ncTopLevel}
-\begin{verbatim}
-ncTopLevel() ==
--- Top-level read-parse-eval-print loop for the interpreter.  Uses
--- the Bill Burge's parser.
-  IN_-STREAM: fluid := CURINSTREAM
-  _*EOF_*: fluid := NIL
-  $InteractiveMode :fluid := true
-  $BOOT: fluid := NIL
-  $NEWSPAD: fluid := true
-  $SPAD: fluid := true
-  $e:fluid := $InteractiveFrame
-  ncIntLoop()
-\end{verbatim}
+Top-level read-parse-eval-print loop for the interpreter.  Uses
+the Bill Burge's parser.
 <<defun ncTopLevel>>=
 (defun |ncTopLevel| ()
- (prog (|$e| $spad $newspad $boot |$InteractiveMode| *eof* in-stream) 
+ (let (|$e| $spad $newspad $boot |$InteractiveMode| *eof* in-stream) 
   (declare (special |$e| $spad $newspad $boot |$InteractiveMode| *eof*
              in-stream |$InteractiveFrame|)) 
-   (return
-    (progn 
-     (setq in-stream curinstream) 
-     (setq *eof* nil) 
-     (setq |$InteractiveMode| t) 
-     (setq $boot nil) 
-     (setq $newspad t) 
-     (setq $spad t) 
-     (setq |$e| |$InteractiveFrame|) 
-     (|ncIntLoop|)))))
+   (setq in-stream curinstream) 
+   (setq *eof* nil) 
+   (setq |$InteractiveMode| t) 
+   (setq $boot nil) 
+   (setq $newspad t) 
+   (setq $spad t) 
+   (setq |$e| |$InteractiveFrame|) 
+   (|ncIntLoop|)))
 
 @
 \subsection{defun ncIntLoop}
@@ -479,39 +466,6 @@ suppressed and input does not use piles. If this is true then the
 library loading routines might output messages and piles are expected
 on input (as from a file).
 \end{list}
-\begin{verbatim}
-SpadInterpretStream(str, source, interactive?) ==
-    $fn              : local := source
-    pile?                    := not interactive?
-    $libQuiet        : local := not interactive?
-    $newcompMode     : local := false
---  following seems useless and causes ccl package problems
---    $InteractiveMode : local := false
- 
-    $newcompErrorCount: local := 0 -- SMW Feb 2/90.
-                                   -- Used in highComplete, ncHardError etc.
- 
-    $okToExecuteMachineCode: local := true -- set false on error
-    $inclAssertions: local := ["AIX", "CommonLisp"] -- Jan 28/90
- 
- 
-    $lastPos               : local := $nopos   ------------>!!!
-    $erMsgToss             : local := false --------------->!!!
-    $ncMsgList             : local := nil
- 
-    $systemCommandFunction : local := function InterpExecuteSpadSystemCommand
-    $shoeReadLineFunction  : local := function serverReadLine
-    $promptMsg             : local := 'S2CTP023
- 
-    interactive? =>
-                PRINC(MKPROMPT())
-                intloopReadConsole('"", str)
-                []
-    intloopInclude (source,0)
-    []
- 
-    -----------------------------------------------------------------
-\end{verbatim}
 <<defun SpadInterpretStream>>=
 (defun |SpadInterpretStream| (str source interactive?) 
  (prog (|$promptMsg| |$shoeReadLineFunction| |$systemCommandFunction| 
@@ -694,9 +648,6 @@ Prefix a filename with the {\bf AXIOM} shell variable.
 @
 
 \subsection{defun makeInitialModemapFrame}
-\begin{verbatim}
-makeInitialModemapFrame() == COPY $InitialModemapFrame
-\end{verbatim}
 <<defun makeInitialModemapFrame>>=
 (defun |makeInitialModemapFrame| ()
   (copy |$InitialModemapFrame|)) 
@@ -753,8 +704,8 @@ NAG distribution back to the original form. If you need the NAG
 version you can push {\bf :tpd} on the {\bf *features*} variable
 before compiling this file. A correct call looks like:
 \begin{verbatim}
-(in-package "BOOT")
-(reroot "/spad/mnt/${SYS}")
+  (in-package "BOOT")
+  (reroot "/spad/mnt/${SYS}")
 \end{verbatim}
 where the [[${SYS}]] variable is the same one set at build time.
 <<defun reroot>>=
@@ -821,6 +772,46 @@ Thus, to see they copyright you type:
 New commands need to be added to this table. The command invoked will
 be the first entry of the pair and the ``user level'' of the command
 will be the second entry. 
+
+See:\\
+\begin{itemize}
+\item The \fnref{abbreviations} command
+\item The \fnref{boot} command
+\item The \fnref{browse} command
+\item The \fnref{cd} command
+\item The \fnref{clear} command
+\item The \fnref{close} command
+\item The \fnref{compiler} command
+\item The \fnref{copyright} command
+\item The \fnref{credits} command
+\item The \fnref{display} command
+\item The \fnref{edit} command
+\item The \fnref{fin} command
+\item The \fnref{frame} command
+\item The \fnref{help} command
+\item The \fnref{history} command
+\item The \fnref{lisp} command
+\item The \fnref{library} command
+\item The \fnref{load} command
+\item The \fnref{ltrace} command
+\item The \fnref{pquit} command
+\item The \fnref{quit} command
+\item The \fnref{read} command
+\item The \fnref{savesystem} command
+\item The \fnref{set} command
+\item The \fnref{show} command
+\item The \fnref{spool} command
+\item The \fnref{summary} command
+\item The \fnref{synonym} command
+\item The \fnref{system} command
+\item The \fnref{trace} command
+\item The \fnref{undo} command
+\item The \fnref{what} command
+\item The \fnref{with} command
+\item The \fnref{workfiles} command
+\item The \fnref{zsystemdevelopment} command
+\end{itemize}
+
 <<initvars>>=
 (defvar |$systemCommands| nil)
 
@@ -1082,8 +1073,802 @@ token in the string. If the string only 0 or more blanks it returns nil.
      (list (subseq x nonblank) "")))))
 
 @
-\chapter{The Display Command}
-\section{)display}
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{abbreviations}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+\par\noindent{\bf User Level Required:} compiler
+
+\par\noindent{\bf Command Syntax:}
+\begin{list}{}
+\item {\tt )abbreviation query  \lanb{}{\it nameOrAbbrev}\ranb{}}
+\item {\tt )abbreviation category  {\it abbrev  fullname} \lanb{})quiet\ranb{}}
+\item {\tt )abbreviation domain  {\it abbrev  fullname}   \lanb{})quiet\ranb{}}
+\item {\tt )abbreviation package  {\it abbrev  fullname}  \lanb{})quiet\ranb{}}
+\item {\tt )abbreviation remove  {\it nameOrAbbrev}}
+\end{list}
+
+\par\noindent{\bf Command Description:}
+
+This command is used to query, set and remove abbreviations for category,
+domain and package constructors.
+Every constructor must have a unique abbreviation.
+This abbreviation is part of the name of the subdirectory
+under which the components of the compiled constructor are
+stored.
+%% BEGIN OBSOLETE
+% It is this abbreviation that is used to bring compiled code into
+% Axiom with the {\tt )load} command.
+%% END OBSOLETE
+Furthermore, by issuing this command you
+let the system know what file to load automatically if you use a new
+constructor.
+Abbreviations must start with a letter and then be followed by
+up to seven letters or digits.
+Any letters appearing in the abbreviation must be in uppercase.
+
+When used with the {\tt query} argument,
+\index{abbreviation query}
+this command may be used to list the name
+associated with a  particular abbreviation or the  abbreviation for a
+constructor.
+If no abbreviation or name is given, the names and corresponding
+abbreviations for {\it all} constructors are listed.
+
+The following shows the abbreviation for the constructor {\tt List}:
+\begin{verbatim}
+)abbreviation query List
+\end{verbatim}
+The following shows the constructor name corresponding to the
+abbreviation {\tt NNI}:
+\begin{verbatim}
+)abbreviation query NNI
+\end{verbatim}
+The following lists all constructor names and their abbreviations.
+\begin{verbatim}
+)abbreviation query
+\end{verbatim}
+
+To add an abbreviation for a constructor, use this command with
+{\tt category}, {\tt domain} or {\tt package}.
+\index{abbreviation package}
+\index{abbreviation domain}
+\index{abbreviation category}
+The following add abbreviations to the system for a
+category, domain and package, respectively:
+\begin{verbatim}
+)abbreviation domain   SET Set
+)abbreviation category COMPCAT  ComplexCategory
+)abbreviation package  LIST2MAP ListToMap
+\end{verbatim}
+If the {\tt )quiet} option is used,
+no output is displayed from this command.
+You would normally only define an abbreviation in a library source file.
+If this command is issued for a constructor that has already been loaded, the
+constructor will be reloaded next time it is referenced.  In particular, you
+can use this command to force the automatic reloading of constructors.
+
+To remove an abbreviation, the {\tt remove} argument is used.
+\index{abbreviation remove}
+This is usually
+only used to correct a previous command that set an abbreviation for a
+constructor name.
+If, in fact, the abbreviation does exist, you are prompted
+for confirmation of the removal request.
+Either of the following commands
+will remove the abbreviation {\tt VECTOR2} and the
+constructor name {\tt VectorFunctions2} from the system:
+\begin{verbatim}
+)abbreviation remove VECTOR2
+)abbreviation remove VectorFunctions2
+\end{verbatim}
+
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{boot}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+\par\noindent{\bf User Level Required:} development
+
+\par\noindent{\bf Command Syntax:}
+\begin{list}{}
+\item {\tt )boot} {\it bootExpression}
+\end{list}
+
+\par\noindent{\bf Command Description:}
+
+This command is used by Axiom system developers to execute
+expressions written in the BOOT language.
+For example,
+\begin{verbatim}
+)boot times3(x) == 3*x
+\end{verbatim}
+creates and compiles the Common Lisp function ``times3''
+obtained by translating the BOOT code.
+
+\par\noindent{\bf Also See:}
+\fnref{fin},
+\fnref{lisp},
+\fnref{set}, and
+\fnref{system}
+
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{browse}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+\par\noindent{\bf User Level Required:} development
+
+\par\noindent{\bf Command Syntax:}
+\begin{list}{}
+\item {\tt )browse}
+\end{list}
+
+\par\noindent{\bf Command Description:}
+
+This command is used by Axiom system users to start the Axiom top
+level loop listening for browser connections.
+
+\section{Overview}
+The Axiom book on the help browser is a complete rewrite of the 
+hyperdoc mechanism. There are several components that were needed
+to make this function. Most of the web browser components are
+described in bookvol11.pamphlet. This portion describes some of
+the design issues needed to support the interface.
+
+The axServer command takes a port (defaulting to 8085) and a
+program to handle the browser interaction (defaulting to multiServ).
+The axServer function opens the port, constructs the stream, and
+passes the stream to multiServ. The multiServ loop processes one
+interaction at a time.
+
+So the basic process is that the Axiom ``)browse'' command opens a
+socket and listens for http requests. Based on the type of request
+(either 'GET' or 'POST') and the content of the request, which is
+one of:
+\begin{itemize}
+\item command - algebra request/response
+\item lispcall - a lisp s-expression to be evaluated
+\item showcall - an Axiom )show command
+\end{itemize}
+the multiServ function will call a handler function to evaluate
+the command line and construct a response. GET requests result
+in a new browser page. POST requests result in an inline result.
+
+Most responses contain the fields:
+\begin{itemize}
+\item stepnum - this is the Axiom step number 
+\item command - this is the original command from the browser
+\item algebra - this is the Axiom 2D algebra output
+\item mathml - this is the MathML version of the Axiom algebra
+\item type - this is the type of the Axiom result
+\end{itemize}
+
+\section{Browsers, MathML, and Fonts}
+This work has the Firefox browser as its target. Firefox has built-in
+support for MathML, javascript, and XMLHttpRequest handling. More details
+are available in bookvol11.pamphlet but the very basic machinery for 
+communication with the browser involves a dance between the browser
+and the multiServ function (see the axserver.spad.pamphlet). 
+
+In particular, a simple request is embedded in a web page as:
+\begin{verbatim}
+<ul>
+ <li>
+  <input type="submit" id="p3" class="subbut" 
+    onclick="makeRequest('p3');"
+    value="sin(x)" />
+  <div id="ansp3"><div></div></div>
+ </li>
+</ul>
+\end{verbatim}
+which says that this is an html ``input'' field of type ``submit''.
+The CSS display class is ``subbut'' which is of a different color
+than the surrounding text to make it obvious that you can click on
+this field. Clickable fields that have no response text are of class
+``noresult''.
+
+The javascript call to ``makeRequest'' gives the ``id'' of this input
+field, which must be unique in the page, as an argument. In this case,
+the argument is 'p3'. The ``value'' field holds the display text which
+will be passed back to Axiom as a command.
+
+When the result arrives the ``showanswer'' function will select out
+the mathml field of the response, construct the ``id'' of the html
+div to hold the response by concatenating the string ``ans'' (answer)
+to the ``id'' of the request resulting, in this case, as ``ansp3''.
+The ``showanswer'' function will find this div and replace it with a
+div containing the mathml result.
+
+The ``makeRequest'' function is:
+\begin{verbatim}
+ function makeRequest(arg) {
+   http_request = new XMLHttpRequest();         
+   var command = commandline(arg);
+   //alert(command);
+   http_request.open('POST', '127.0.0.1:8085', true);
+   http_request.onreadystatechange = handleResponse;
+   http_request.setRequestHeader('Content-Type', 'text/plain');
+   http_request.send("command="+command);
+   return(false);
+\end{verbatim}
+It contains a request to open a local server connection to Axiom,
+sets ``handleResponse'' as the function to call on reply, sets up
+the type of request, fills in the command field, and sends off the
+http request.
+
+When a response is received, the ``handleResponse'' function checks
+for the correct reply state, strips out the important text, and
+calls ``showanswer''.
+\begin{verbatim}
+ function handleResponse() {
+  if (http_request.readyState == 4) {
+   if (http_request.status == 200) {
+    showanswer(http_request.responseText,'mathAns');
+   } else
+   {
+     alert('There was a problem with the request.'+ http_request.statusText);
+   }
+  }
+ }
+\end{verbatim}
+See bookvol11.pamphlet for further details.
+
+\section{The axServer/multiServ loop}
+The basic call to start an Axiom browser listener is:
+\begin{verbatim}
+  )set message autoload off
+  )set output mathml on
+  axServer(8085,multiServ)$AXSERV
+\end{verbatim}
+
+This call sets the port, opens a socket, attaches it to a stream,
+and then calls ``multiServ'' with that stream. The ``multiServ''
+function loops serving web responses to that port.
+
+\section{The )browse command}
+In order to make the whole process cleaner the function ``)browse''
+handles the details. This code creates the command-line function for )browse
+
+The browse function does the internal equivalent of the following 3 command
+line statments:
+\begin{verbatim}
+  )set message autoload off
+  )set output mathml on
+  axServer(8085,multiServ)$AXSERV
+\end{verbatim}
+which causes Axiom to start serving web pages on port 8085
+
+For those unfamiliar with calling algebra from lisp there are a 
+few points to mention. 
+
+The loadLib needs to be called to load the algebra code into the image.
+Normally this is automatic but we are not using the interpreter so
+we need to do this ``by hand''.
+
+Each algebra file contains a "constructor function" which builds the
+domain, which is a vector, and then caches the vector so that every
+call to the contructor returns an EQ vector, that is, the same vector.
+In this case, we call the constructor $\vert$AxiomServer$\vert$
+
+The axServer function was mangled internally to 
+$\vert$AXSERV;axServer;IMV;2$\vert$.
+The multiServ function was mangled to $\vert$AXSERV;multiServ;SeV;3$\vert$
+Note well that if you change axserver.spad these names might change
+which will generate the error message along the lines of:
+\begin{verbatim}
+    System error:
+    The function $\vert$AXSERV;axServer;IMV;2$\vert$ is undefined.
+\end{verbatim}
+
+To fix this you need to look at int/algebra/AXSERV.nrlib/code.lsp
+and find the new mangled function name. A better solution would
+be to dynamically look up the surface names in the domain vector.
+
+Each Axiom function expects the domain vector as the last argument.
+This is not obvious from the call as the interpreter supplies it.
+We must do that ``by hand''.
+
+We don't call the multiServ function. We pass it as a parameter to
+the axServer function. When it does get called by the SPADCALL
+macro it needs to be a lisp pair whose car is the function and
+whose cdr is the domain vector. We construct that pair here as
+the second argument to axServer. The third, hidden, argument to
+axServer is the domain vector which we supply ``by hand''.
+
+The socket can be supplied on the command line but defaults to 8085.
+Axiom supplies the arguments as a list.
+<<defun browse>>=
+(defun |browse| (socket)
+ (let (axserv browser)
+  (if socket 
+    (setq socket (car socket))
+    (setq socket 8085))
+  (|set| '(|mes| |auto| |off|))
+  (|set| '(|out| |mathml| |on|))
+  (|loadLib| '|AxiomServer|)
+  (setq axserv (|AxiomServer|))
+  (setq browser 
+   (|AXSERV;axServer;IMV;2| socket
+    (cons #'|AXSERV;multiServ;SeV;3| axserv) axserv))))
+
+@
+Now we have to bolt it into Axiom. This involves two lookups.
+
+We create the lisp pair 
+\begin{verbatim}
+  (|browse| . |development|)
+\end{verbatim} 
+and cons it into the \$systemCommands command table.  This allows the
+command to be executed in development mode.  This lookup decides if
+this command is allowed. It also has the side-effect of putting the
+command into the \$SYSCOMMANDS variable which is used to determine
+if the token is a command.
+
+\section{The server support code}
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{cd}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+\par\noindent{\bf User Level Required:} interpreter
+
+\par\noindent{\bf Command Syntax:}
+\begin{list}{}
+\item {\tt )cd} {\it directory}
+\end{list}
+
+\par\noindent{\bf Command Description:}
+
+This command sets the Axiom working current directory.
+The current directory is used for looking for
+input files (for {\tt )read}),
+Axiom library source files (for {\tt )compile}),
+saved history environment files (for {\tt )history )restore}),
+compiled Axiom library files (for {\tt )library}), and
+files to edit (for {\tt )edit}).
+It is also used for writing
+spool files (via {\tt )spool}),
+writing history input files (via {\tt )history )write}) and
+history environment files (via {\tt )history )save}),and
+compiled Axiom library files (via {\tt )compile}).
+\index{read}
+\index{compile}
+\index{history )restore}
+\index{edit}
+\index{spool}
+\index{history )write}
+\index{history )save}
+
+If issued with no argument, this command sets the Axiom
+current directory to your home directory.
+If an argument is used, it must be a valid directory name.
+Except for the ``{\tt )}'' at the beginning of the command,
+this has the same syntax as the operating system {\tt cd} command.
+
+\par\noindent{\bf Also See:}
+\fnref{compiler},
+\fnref{edit},
+\fnref{history},
+\fnref{library},
+\fnref{read}, and
+\fnref{spool}
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{clear}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+\par\noindent{\bf User Level Required:} interpreter
+
+\par\noindent{\bf Command Syntax:}
+\begin{list}{}
+\item{\tt )clear all}
+\item{\tt )clear completely}
+\item{\tt )clear properties all}
+\item{\tt )clear properties}  {\it obj1 \lanb{}obj2 ...\ranb{}}
+\item{\tt )clear value      all}
+\item{\tt )clear value}     {\it obj1 \lanb{}obj2 ...\ranb{}}
+\item{\tt )clear mode       all}
+\item{\tt )clear mode}      {\it obj1 \lanb{}obj2 ...\ranb{}}
+\end{list}
+\par\noindent{\bf Command Description:}
+
+This command is used to remove function and variable declarations, definitions
+and values  from the workspace.
+To  empty the entire workspace  and reset the
+step counter to 1, issue
+\begin{verbatim}
+)clear all
+\end{verbatim}
+To remove everything in the workspace but not reset the step counter, issue
+\begin{verbatim}
+)clear properties all
+\end{verbatim}
+To remove everything about the object {\tt x}, issue
+\begin{verbatim}
+)clear properties x
+\end{verbatim}
+To remove everything about the objects {\tt x, y} and {\tt f}, issue
+\begin{verbatim}
+)clear properties x y f
+\end{verbatim}
+
+The word {\tt properties} may be abbreviated to the single letter
+``{\tt p}''.
+\begin{verbatim}
+)clear p all
+)clear p x
+)clear p x y f
+\end{verbatim}
+All definitions of functions and values of variables may be removed by either
+\begin{verbatim}
+)clear value all
+)clear v all
+\end{verbatim}
+This retains whatever declarations the objects had.  To remove definitions and
+values for the specific objects {\tt x, y} and {\tt f}, issue
+\begin{verbatim}
+)clear value x y f
+)clear v x y f
+\end{verbatim}
+To remove  the declarations  of everything while  leaving the  definitions and
+values, issue
+\begin{verbatim}
+)clear mode  all
+)clear m all
+\end{verbatim}
+To remove declarations for the specific objects {\tt x, y} and {\tt f}, issue
+\begin{verbatim}
+)clear mode x y f
+)clear m x y f
+\end{verbatim}
+The {\tt )display names} and {\tt )display properties} commands  may be used
+to see what is currently in the workspace.
+
+The command
+\begin{verbatim}
+)clear completely
+\end{verbatim}
+does everything that {\tt )clear all} does, and also clears the internal
+system function and constructor caches.
+
+\par\noindent{\bf Also See:}
+\fnref{display},
+\fnref{history}, 
+\fnref{frame}, and
+\fnref{undo}
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{close}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{compiler}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+\par\noindent{\bf User Level Required:} compiler
+
+\par\noindent{\bf Command Syntax:}
+
+\begin{list}{}
+\item {\tt )compile}
+\item {\tt )compile {\it fileName}}
+\item {\tt )compile {\it fileName}.as}
+\item {\tt )compile {\it directory/fileName}.as}
+\item {\tt )compile {\it fileName}.ao}
+\item {\tt )compile {\it directory/fileName}.ao}
+\item {\tt )compile {\it fileName}.al}
+\item {\tt )compile {\it directory/fileName}.al}
+\item {\tt )compile {\it fileName}.lsp}
+\item {\tt )compile {\it directory/fileName}.lsp}
+\item {\tt )compile {\it fileName}.spad}
+\item {\tt )compile {\it directory/fileName}.spad}
+\item {\tt )compile {\it fileName} )new}
+\item {\tt )compile {\it fileName} )old}
+\item {\tt )compile {\it fileName} )translate}
+\item {\tt )compile {\it fileName} )quiet}
+\item {\tt )compile {\it fileName} )noquiet}
+\item {\tt )compile {\it fileName} )moreargs}
+\item {\tt )compile {\it fileName} )onlyargs}
+\item {\tt )compile {\it fileName} )break}
+\item {\tt )compile {\it fileName} )nobreak}
+\item {\tt )compile {\it fileName} )library}
+\item {\tt )compile {\it fileName} )nolibrary}
+\item {\tt )compile {\it fileName} )vartrace}
+\item {\tt )compile {\it fileName} )constructor} {\it nameOrAbbrev}
+\end{list}
+
+\par\noindent{\bf Command Description:}
+
+You use this command to invoke the new Axiom library compiler or
+the old Axiom system compiler.
+The {\tt )compile} system command is actually a combination of
+Axiom processing and a call to the Aldor compiler.
+It is performing double-duty, acting as a front-end to
+both the Aldor compiler and the old Axiom system
+compiler.
+(The old Axiom system compiler was written in Lisp and was
+an integral part of the Axiom environment.
+The Aldor compiler is written in C and executed by the operating system
+when called from within Axiom.)
+
+This command compiles files with file extensions {\it .as, .ao}
+and {\it .al} with the
+Aldor compiler and files with file extension {\it .spad} with the
+old Axiom system compiler.
+It also can compile files with file extension {\it .lsp}. These
+are assumed to be Lisp files genererated by the Aldor
+compiler.
+If you omit the file extension, the command looks to see if you
+have specified the {\tt )new} or {\tt )old} option.
+If you have given one of these options, the corresponding compiler
+is used.
+Otherwise, the command first looks in the standard system
+directories for files with extension {\it .as, .ao} and {\it
+.al} and then files with extension {\it .spad}.
+The first file found has the appropriate compiler invoked on it.
+If the command cannot find a matching file, an error message is
+displayed and the command terminates.
+
+The {\tt )translate} option is used to invoke a special version
+of the old system compiler that will translate a {\it .spad} file
+to a {\it .as} file. That is, the {\it .spad} file will be parsed and
+analyzed and a file using the new syntax will be created. By default,
+the {\it .as} file is created in the same directory as the
+{\it .spad} file. If that directory is not writable, the current
+directory is used. If the current directory is not writable, an
+error message is given and the command terminates.
+Note that {\tt )translate} implies the {\tt )old} option so the
+file extension can safely be omitted. If {\tt )translate} is
+given, all other options are ignored.
+Please be aware that the translation is not necessarily one
+hundred percent complete or correct.
+You should attempt to compile the output with the Aldor compiler
+and make any necessary corrections.
+
+We now describe the options for the new Aldor compiler.
+
+The first thing {\tt )compile} does is look for a source code
+filename among its arguments.
+Thus
+\begin{verbatim}
+)compile mycode.as
+)compile /u/jones/as/mycode.as
+)compile mycode
+\end{verbatim}
+all invoke {\tt )compiler} on the file {\tt
+/u/jones/as/mycode.as} if the current Axiom working
+directory is {\tt /u/jones/as.} (Recall that you can set the
+working directory via the {\tt )cd} command. If you don't set it
+explicitly, it is the directory from which you started
+Axiom.)
+
+This is frequently all you need to compile your file.
+This simple command:
+\begin{enumerate}
+\item Invokes the Aldor compiler and produces Lisp output.
+\item Calls the Lisp compiler if the Aldor compilation was
+successful.
+\item Uses the {\tt )library} command to tell Axiom about
+the contents of your compiled file and arrange to have those
+contents loaded on demand.
+\end{enumerate}
+
+Should you not want the {\tt )library} command automatically
+invoked, call {\tt )compile} with the {\tt )nolibrary} option.
+For example,
+\begin{verbatim}
+)compile mycode.as )nolibrary
+\end{verbatim}
+
+The general description of Aldor command line arguments is in
+the Aldor documentation.
+The default options used by the {\tt )compile} command can be
+viewed and set using the {\tt )set compiler args} Axiom
+system command.
+The current defaults are
+\begin{verbatim}
+-O -Fasy -Fao -Flsp -laxiom -Mno-AXL_W_WillObsolete -DAxiom
+\end{verbatim}
+These options mean:
+\begin{itemize}
+\item {\tt -O}: perform all optimizations,
+\item {\tt -Fasy}: generate a {\tt .asy} file,
+\item {\tt -Fao}: generate a {\tt .ao} file,
+\item {\tt -Flsp}: generate a {\tt .lsp} (Lisp)
+file,
+\index{Lisp!code generation}
+\item {\tt -laxiom}: use the {\tt axiom} library {\tt libaxiom.al},
+\item {\tt -Mno-AXL\_W\_WillObsolete}: do not display messages
+about older generated files becoming obsolete, and
+\item {\tt -DAxiom}: define the global assertion {\tt Axiom} so that the
+Aldor libraries for generating stand-alone code
+are not accidentally used with Axiom.
+\end{itemize}
+
+To supplement these default arguments, use the {\tt )moreargs} option on
+{\tt )compile.}
+For example,
+\begin{verbatim}
+)compile mycode.as )moreargs "-v"
+\end{verbatim}
+uses the default arguments and appends the {\tt -v} (verbose)
+argument flag.
+The additional argument specification {\bf must be enclosed in
+double quotes.}
+
+To completely replace these default arguments for a particular
+use of {\tt )compile}, use the {\tt )onlyargs} option.
+For example,
+\begin{verbatim}
+)compile mycode.as )onlyargs "-v -O"
+\end{verbatim}
+only uses the {\tt -v} (verbose) and {\tt -O} (optimize)
+arguments.
+The argument specification {\bf must be enclosed in double quotes.}
+In this example, Lisp code is not produced and so the compilation
+output will not be available to Axiom.
+
+To completely replace the default arguments for all calls to {\tt
+)compile} within your Axiom session, use {\tt )set compiler args.}
+For example, to use the above arguments for all compilations, issue
+\begin{verbatim}
+)set compiler args "-v -O"
+\end{verbatim}
+Make sure you include the necessary {\tt -l} and {\tt -Y}
+arguments along with those needed for Lisp file creation.
+As above, {\bf the argument specification must be enclosed in double
+quotes.}
+
+By default, the {\tt )library} system command {\it exposes} all
+domains and categories it processes.
+This means that the Axiom intepreter will consider those
+domains and categories when it is trying to resolve a reference
+to a function.
+Sometimes domains and categories should not be exposed.
+For example, a domain may just be used privately by another
+domain and may not be meant for top-level use.
+The {\tt )library} command should still be used, though, so that
+the code will be loaded on demand.
+In this case, you should use the {\tt )nolibrary} option on {\tt
+)compile} and the {\tt )noexpose} option in the {\tt )library}
+command. For example,
+\begin{verbatim}
+)compile mycode.as )nolibrary
+)library mycode )noexpose
+\end{verbatim}
+
+Once you have established your own collection of compiled code,
+you may find it handy to use the {\tt )dir} option on the
+{\tt )library} command.
+This causes {\tt )library} to process all compiled code in the
+specified directory. For example,
+\begin{verbatim}
+)library )dir /u/jones/as/quantum
+\end{verbatim}
+You must give an explicit directory after {\tt )dir}, even if you
+want all compiled code in the current working directory
+processed, e.g.
+\begin{verbatim}
+)library )dir .
+\end{verbatim}
+
+The {\tt )compile} command works with several file extensions. We saw
+above what happens when it is invoked on a file with extension {\tt
+.as.} A {\tt .ao} file is a portable binary compiled version of a
+{\tt .as} file, and {\tt )compile} simply passes the {\tt .ao} file
+onto Aldor. The generated Lisp file is compiled and {\tt )library}
+is automatically called, just as if you had specified a {\tt .as} file.
+
+A {\tt .al} file is an archive file containing {\tt .ao} files. The
+archive is created (on Unix systems) with the {\tt ar} program. When
+{\tt )compile} is given a {\tt .al} file, it creates a directory whose
+name is based on that of the archive. For example, if you issue
+\begin{verbatim}
+)compile mylib.al
+\end{verbatim}
+the directory {\tt mylib.axldir} is created. All
+members of the archive are unarchived into the
+directory and {\tt )compile} is called on each {\tt .ao} file found. It
+is your responsibility to remove the directory and its contents, if you
+choose to do so.
+
+A {\tt .lsp} file is a Lisp source file, presumably, in our context,
+generated by Aldor when called with the {\tt -Flsp} option. When
+{\tt )compile} is used with a {\tt .lsp} file, the Lisp file is
+compiled and {\tt )library} is called. You must also have present a
+{\tt .asy} generated from the same source file.
+
+The following are descriptions of options for the old system compiler.
+
+You can compile category, domain, and package constructors
+contained in files with file extension {\it .spad}.
+You can compile individual constructors or every constructor
+in a file.
+
+The full filename is remembered between invocations of this command and
+{\tt )edit} commands.
+The sequence of commands
+\begin{verbatim}
+)compile matrix.spad
+)edit
+)compile
+\end{verbatim}
+will call the compiler, edit, and then call the compiler again
+on the file {\bf matrix.spad.}
+If you do not specify a {\it directory,} the working current
+directory is searched for the file.
+If the file is not found, the standard system directories are searched.
+
+If you do not give any options, all constructors within a file are
+compiled.
+Each constructor should have an {\tt )abbreviation} command in
+the file in which it is defined.
+We suggest that you place the {\tt )abbreviation} commands at the
+top of the file in the order in which the constructors are
+defined.
+The list of commands serves as a table of contents for the file.
+\index{abbreviation}
+
+The {\tt )library} option causes directories containing the
+compiled code for each constructor
+to be created in the working current directory.
+The name of such a directory consists of the constructor
+abbreviation and the {\bf .nrlib} file extension.
+For example, the directory containing the compiled code for
+the {\tt MATRIX} constructor is called {\bf MATRIX.nrlib.}
+The {\tt )nolibrary} option says that such files should not
+be created.
+The default is {\tt )library.}
+Note that the semantics of {\tt )library} and {\tt )nolibrary}
+for the new Aldor compiler and for the old system compiler are
+completely different.
+
+The {\tt )vartrace} option causes the compiler to generate
+extra code for the constructor to support conditional tracing of
+variable assignments. Without
+this option, this code is suppressed and one cannot use
+the {\tt )vars} option for the trace command.
+
+The {\tt )constructor} option is used to
+specify a particular constructor to compile.
+All other constructors in the file are ignored.
+The constructor name or abbreviation follows {\tt )constructor.}
+Thus either
+\begin{verbatim}
+)compile matrix.spad )constructor RectangularMatrix
+\end{verbatim}
+or
+\begin{verbatim}
+)compile matrix.spad )constructor RMATRIX
+\end{verbatim}
+compiles  the {\tt RectangularMatrix} constructor
+defined in {\bf matrix.spad.}
+
+The {\tt )break} and {\tt )nobreak} options determine what
+the old system compiler does when it encounters an error.
+{\tt )break} is the default and it indicates that processing
+should stop at the first error.
+The value of the {\tt )set break} variable then controls what happens.
+
+\par\noindent{\bf Also See:}
+{\tt )abbreviations},
+{\tt )edit}, and 
+{\tt )library}
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{copyright}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{credits}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{display}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
 \begin{verbatim}
   )display abbreviations 
   )display abbreviations [obj]
@@ -1126,7 +1911,6 @@ The command
 \end{verbatim}
 will show all of the macros in the current workspace.
 
-
 The command
 \begin{verbatim}
   )display names
@@ -1321,10 +2105,15 @@ displayed. If the answer is either Y or YES we return true else nil.
         (cond
          ((|member| macro pmacs)
            (cond
-            (first (|sayBrightly| (cons '|%l| (cons "User-defined macros:" nil))) (setq first nil)))
+            (first (|sayBrightly|
+             (cons '|%l| (cons "User-defined macros:" nil))) (setq first nil)))
            (|displayParserMacro| macro))
          ((|member| macro imacs) '|iterate|)
-         (t (|sayBrightly| (cons "   " (cons '|%b| (cons macro (cons '|%d| (cons " is not a known Axiom macro." nil)))))))))))
+         (t (|sayBrightly|
+          (cons "   "
+           (cons '|%b|
+            (cons macro
+             (cons '|%d| (cons " is not a known Axiom macro." nil)))))))))))
      (setq first t)
      (do ((t1 macros (cdr t1)) (macro nil))
          ((or (atom t1) (progn (setq macro (car t1)) nil)) nil)
@@ -1432,10 +2221,12 @@ next brace but the problem does not arise in practice.
 (defun cleanupLine (line)
  (do ((mark (search "{}" line) (search "{}" line)))
   ((null mark))
-  (setq line (concatenate 'string (subseq line 0 mark) (subseq line (+ mark 2)))))
+  (setq line
+   (concatenate 'string (subseq line 0 mark) (subseq line (+ mark 2)))))
  (do ((mark (search "\\" line) (search "\\" line)))
   ((null mark))
-  (setq line (concatenate 'string (subseq line 0 mark) (subseq line (+ mark 1)))))
+  (setq line
+   (concatenate 'string (subseq line 0 mark) (subseq line (+ mark 1)))))
  (do ((mark (search "spad{" line) (search "spad{" line)))
   ((null mark))
   (let (left point mid right)
@@ -1448,12 +2239,1015 @@ next brace but the problem does not arise in practice.
 
 @
 
-\chapter{The History Mechanism}
-\section{)history}
-\index{ugSysCmdhistory}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{edit}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+
+\par\noindent{\bf User Level Required:} interpreter
+
+\par\noindent{\bf Command Syntax:}
+\begin{list}{}
+\item{\tt )edit} \lanb{}{\it filename}\ranb{}
+\end{list}
+\par\noindent{\bf Command Description:}
+
+This command is  used to edit files.
+It works in conjunction  with the {\tt )read}
+and {\tt )compile} commands to remember the name
+of the file on which you are working.
+By specifying the name fully, you  can edit any file you wish.
+Thus
+\begin{verbatim}
+)edit /u/julius/matrix.input
+\end{verbatim}
+will place  you in an editor looking at the  file
+{\tt /u/julius/matrix.input}.
+\index{editing files}
+By default, the editor is {\tt vi},
+\index{vi}
+but if you have an EDITOR shell environment variable defined, that editor
+will be used.
+When Axiom is running under the X Window System,
+it will try to open a separate {\tt xterm} running your editor if
+it thinks one is necessary.
+\index{Korn shell}
+For example, under the Korn shell, if you issue
+\begin{verbatim}
+export EDITOR=emacs
+\end{verbatim}
+then the emacs
+\index{emacs}
+editor will be used by {\tt )edit}.
+
+If you do not specify a file name, the last file you edited,
+read or compiled will be used.
+If there is no ``last file'' you will be placed in the editor editing
+an empty unnamed file.
+
+It is possible to use the {\tt )system} command to edit a file directly.
+For example,
+\begin{verbatim}
+)system emacs /etc/rc.tcpip
+\end{verbatim}
+calls {\tt emacs} to edit the file.
+\index{emacs}
+
+\par\noindent{\bf Also See:}
+\fnref{system},
+\fnref{compiler}, and
+\fnref{read}
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{fin}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+\par\noindent{\bf User Level Required:} development
+
+\par\noindent{\bf Command Syntax:}
+\begin{list}{}
+\item {\tt )fin}
+\end{list}
+\par\noindent{\bf Command Description:}
+
+This command is used by Axiom
+developers to leave the Axiom system and return
+to the underlying Common Lisp system.
+To return to Axiom, issue the
+``{\tt (\vertline{}spad\vertline{})}''
+function call to Common Lisp.
+
+\par\noindent{\bf Also See:}
+\fnref{pquit} and 
+\fnref{quit}
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{frame}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+\par\noindent{\bf Command Syntax:}
+\begin{list}{}
+\item{\tt )frame  new  {\it frameName}}
+\item{\tt )frame  drop  {\it [frameName]}}
+\item{\tt )frame  next}
+\item{\tt )frame  last}
+\item{\tt )frame  names}
+\item{\tt )frame  import {\it frameName} {\it [objectName1 [objectName2 ...]]}}
+\item{\tt )set message frame on | off}
+\item{\tt )set message prompt frame}
+\end{list}
+
+\par\noindent{\bf Command Description:}
+
+A {\it frame} can be thought of as a logical session within the
+physical session that you get when you start the system.  You can
+have as many frames as you want, within the limits of your computer's
+storage, paging space, and so on.
+Each frame has its own {\it step number}, {\it environment} and {\it history.}
+You can have a variable named {\tt a} in one frame and it will
+have nothing to do with anything that might be called {\tt a} in
+any other frame.
+
+Some frames are created by the HyperDoc program and these can
+have pretty strange names, since they are generated automatically.
+\index{frame names}
+To find out the names
+of all frames, issue
+\begin{verbatim}
+)frame names
+\end{verbatim}
+It will indicate the name of the current frame.
+
+You create a new frame
+\index{frame new}
+``{\bf quark}'' by issuing
+\begin{verbatim}
+)frame new quark
+\end{verbatim}
+The history facility can be turned on by issuing either
+{\tt )set history on} or {\tt )history )on}.
+If the history facility is on and you are saving history information
+in a file rather than in the Axiom environment
+then a history file with filename {\bf quark.axh} will
+be created as you enter commands.
+If you wish to go back to what
+you were doing in the
+\index{frame next}
+``{\bf initial}'' frame, use
+\index{frame last}
+\begin{verbatim}
+)frame next
+\end{verbatim}
+or
+\begin{verbatim}
+)frame last
+\end{verbatim}
+to cycle through the ring of available frames to get back to
+``{\bf initial}''.
+
+If you want to throw
+away a frame (say ``{\bf quark}''), issue
+\begin{verbatim}
+)frame drop quark
+\end{verbatim}
+If you omit the name, the current frame is dropped.
+\index{frame drop}
+
+If you do use frames with the history facility on and writing to a file,
+you may want to delete some of the older history files.
+\index{file!history}
+These are directories, so you may want to issue a command like
+{\tt rm -r quark.axh} to the operating system.
+
+You can bring things from another frame by using
+\index{frame import}
+{\tt )frame import}.
+For example, to bring the {\tt f} and {\tt g} from the frame ``{\bf quark}''
+to the current frame, issue
+\begin{verbatim}
+)frame import quark f g
+\end{verbatim}
+If you want everything from the frame ``{\bf quark}'', issue
+\begin{verbatim}
+)frame import quark
+\end{verbatim}
+You will be asked to verify that you really want everything.
+
+There are two {\tt )set} flags
+\index{set message frame}
+to make it easier to tell where you are.
+\begin{verbatim}
+)set message frame on | off
+\end{verbatim}
+will print more messages about frames when it is set on.
+By default, it is off.
+\begin{verbatim}
+)set message prompt frame
+\end{verbatim}
+will give a prompt
+\index{set message prompt frame}
+that looks like
+\begin{verbatim}
+initial (1) ->
+\end{verbatim}
+\index{prompt!with frame name}
+when you start up. In this case, the frame name and step make up the
+prompt.
+
+\par\noindent{\bf Also See:}
+\fnref{history} and
+\fnref{set}
+
+\section{Variables Used}
+The frame mechanism uses several dollar variables.
+\subsection{Primary variables}
+Primary variables are those which exist solely to make the frame
+mechanism work. 
+
+The \$interpreterFrameName contains a symbol which is the name
+of the current frame in use. 
+
+The \$interpreterFrameRing contains a list of all of the existing
+frames. The first frame on the list is the ``current'' frame. When
+AXIOMsys is started directly there is only one frame named ``initial''.
+
+If the system is started under sman (using the axiom shell script,
+for example), there are two frames, ``initial'' and ``frame0''. In
+this case, ``frame0'' is the current frame. This can cause subtle
+problems because functions defined in the axiom initialization file
+(.axiom.input) will be defined in frame ``initial'' but the current
+frame will be ``frame0''. They will appear to be undefined. However,
+if the user does ``)frame next'' they can switch to the ``initial''
+frame and see the functions correctly defined.
+
+The \$frameMessages variable controls when frame messages will be
+displayed. The variable is initially NIL. It can be set on (T) or off (NIL)
+using the system command:
+\begin{verbatim}
+    )set message frame on | off
+\end{verbatim}
+Setting frame messages on will output a line detailing the 
+current frame after every output is complete. 
+
+\subsection{Used variables}
+
+The frame collects and uses a few top level variables. These are:
+\$InteractiveFrame, \$IOindex, \$HiFiAccess, \$HistList, \$HistListLen,
+\$HistListAct, \$HistRecord, \$internalHistoryTable, and \$localExposureData.
+
+These variables can also be changed by the frame mechanism when the user
+requests changing to a different frame.
+
+\section{Data Structures}
+\subsection{Frames and the Interpreter Frame Ring}
+
+Axiom has the notion of ``frames''. A frame is a data structure which
+holds all the vital data from an Axiom session. There can be multiple
+frames and these live in a top-level variable called
+\$interpreterFrameRing. This variable holds a circular list of frames.
+The parts of a frame and their initial, default values are:
+
+\begin{verbatim}
+  $interpreterFrameName      a string, named on creation
+  $InteractiveFrame          (list (list nil))
+  $IOindex                   an integer, 1
+  $HiFiAccess                $HiFiAccess, see the variable description
+  $HistList                  $HistList, see the variable description
+  $HistListLen               $HistListLen, see the variable description
+  $HistListAct               $HistListAct, see the variable description
+  $HistRecord                $HistRecord, see the variable description
+  $internalHistoryTable      nil
+  $localExposureData         a copy of $localExposureData
+\end{verbatim}
+
+\section{Accessor Functions}
+These could be macros but we wish to export them to the API code
+in the algebra so we keep them as functions.
+\subsection{0th Frame Component -- frameName}
+\subsection{defun frameName}
+<<defun frameName>>=
+(defun frameName (frame)
+ (car frame)) 
+
+@
+\subsection{1st Frame Component -- frameInteractive}
+<<defun frameInteractive>>=
+(defun frameInteractive (frame)
+ (nth 1 frame))
+
+@
+\subsection{2nd Frame Component -- frameIOIndex}
+<<defun frameIOIndex>>=
+(defun frameIOIndex (frame)
+ (nth 2 frame))
+
+@
+\subsection{3rd Frame Component -- frameHiFiAccess}
+<<defun frameHiFiAccess>>=
+(defun frameHiFiAccess (frame)
+ (nth 3 frame))
+
+@
+\subsection{4th Frame Component -- frameHistList}
+<<defun frameHistList>>=
+(defun frameHistList (frame)
+ (nth 4 frame))
+
+@
+\subsection{5th Frame Component -- frameHistListLen}
+<<defun frameHistListLen>>=
+(defun frameHistListLen (frame)
+ (nth 5 frame))
+
+@
+\subsection{6th Frame Component -- frameHistListAct}
+<<defun frameHistListAct>>=
+(defun frameHistListAct (frame)
+ (nth 6 frame))
+
+@
+\subsection{7th Frame Component -- frameHistRecord}
+<<defun frameHistRecord>>=
+(defun frameHistRecord (frame)
+ (nth 7 frame))
+
+@
+\subsection{8th Frame Component -- frameHistoryTable}
+<<defun frameHistoryTable>>=
+(defun frameHistoryTable (frame)
+ (nth 8 frame))
+
+@
+\subsection{9th Frame Component -- frameExposureData}
+<<defun frameExposureData>>=
+(defun frameExposureData (frame)
+ (nth 9 frame))
+
+@
+
+\section{Variables Used}
+\section{Data Structures}
+\section{Functions}
+\subsection{Initializing the Interpreter Frame Ring}
+
+Now that we know what a frame looks like we need a function to
+initialize the list of frames. This function sets the initial frame
+name to ``initial'' and creates a list of frames containing an empty
+frame. This list is the interpreter frame ring and is not actually
+circular but is managed as a circular list. 
+
+As a final step we update the world from this frame. This has the
+side-effect of resetting all the important global variables to their
+initial values.
+
+<<defun initializeInterpreterFrameRing>>=
+(defun |initializeInterpreterFrameRing| ()
+ (setq |$interpreterFrameName| '|initial|)
+ (setq |$interpreterFrameRing|
+   (list (|emptyInterpreterFrame| |$interpreterFrameName|)))
+ (|updateFromCurrentInterpreterFrame|)
+ nil) 
+
+@
+\subsection{Creating a List of all of the Frame Names}
+\subsection{defun frameNames}
+This function simply walks across the frame in the frame ring and
+returns a list of the name of each frame. 
+<<defun frameNames>>=
+(defun |frameNames| () 
+ (mapcar #'frameName |$interpreterFrameRing|))
+
+@
 
-\index{history}
+\subsection{Get Named Frame Environment (aka Interactive)}
+If the frame is found we return the environment portion of the frame
+otherwise we construct an empty environment and return it.
+The initial values of an empty frame are created here. This function
+returns a single frame that will be placed in the frame ring.
+\subsection{defun frameEnvironment}
+<<defun frameEnvironment>>=
+(defun |frameEnvironment| (fname)
+ (let ((frame (|findFrameInRing| fname)))
+  (if frame
+   (frameInteractive frame)
+   (list (list nil)))))
+
+@
+\subsection{defun emptyInterpreterFrame}
+\begin{verbatim}
+emptyInterpreterFrame(name) ==
+  LIST(name,                            -- frame name
+       LIST LIST NIL,                   -- environment
+       1,                               -- $IOindex
+       $HiFiAccess,                     -- $HiFiAccess
+       $HistList,                       -- $HistList
+       $HistListLen,                    -- $HistListLen
+       $HistListAct,                    -- $HistListAct
+       $HistRecord,                     -- $HistRecord
+       NIL,                             -- $internalHistoryTable
+       COPY_-SEQ $localExposureDataDefault        -- $localExposureData
+      )
+\end{verbatim}
+<<defun emptyInterpreterFrame>>=
+(defun |emptyInterpreterFrame| (name)
+ (list name
+   (list (list nil))
+   1 
+   |$HiFiAccess| 
+   |$HistList| 
+   |$HistListLen| 
+   |$HistListAct| 
+   |$HistRecord| 
+   nil 
+   (copy-seq |$localExposureDataDefault|))) 
 
+@
+\subsection{Collecting up the Environment into a Frame}
+
+We can collect up all the current environment information into
+one frame element with this call. It creates a list of the current
+values of the global variables and returns this as a frame element.
+
+\subsection{defun createCurrentInterpreterFrame}
+<<defun createCurrentInterpreterFrame>>=
+(defun |createCurrentInterpreterFrame| ()
+ (list 
+   |$interpreterFrameName| 
+   |$InteractiveFrame| 
+   |$IOindex| 
+   |$HiFiAccess| 
+   |$HistList| 
+   |$HistListLen| 
+   |$HistListAct| 
+   |$HistRecord| 
+   |$internalHistoryTable| 
+   |$localExposureData|)) 
+
+@
+\subsection{Updating from the Current Frame}
+
+The frames are kept on a circular list. The first element on that
+list is known as ``the current frame''. This will initialize all
+of the interesting interpreter data structures from that frame.
+
+\subsection{defun updateFromCurrentInterpreterFrame}
+\begin{verbatim}
+updateFromCurrentInterpreterFrame() ==
+  [$interpreterFrameName,          _
+   $InteractiveFrame,              _
+   $IOindex,                       _
+   $HiFiAccess,                    _
+   $HistList,                      _
+   $HistListLen,                   _
+   $HistListAct,                   _
+   $HistRecord,                    _
+   $internalHistoryTable,          _
+   $localExposureData              _
+   ] := first $interpreterFrameRing
+  if $frameMessages then
+    sayMessage ['"   Current interpreter frame is called",:bright
+      $interpreterFrameName]
+  NIL
+\end{verbatim}
+<<defun updateFromCurrentInterpreterFrame>>=
+(defun |updateFromCurrentInterpreterFrame| ()
+ (let (tmp1)
+  (setq tmp1 (first |$interpreterFrameRing|))
+  (setq |$interpreterFrameName| (nth 0 tmp1))
+  (setq |$InteractiveFrame|     (nth 1 tmp1))
+  (setq |$IOindex|              (nth 2 tmp1))
+  (setq |$HiFiAccess|           (nth 3 tmp1))
+  (setq |$HistList|             (nth 4 tmp1))
+  (setq |$HistListLen|          (nth 5 tmp1))
+  (setq |$HistListAct|          (nth 6 tmp1))
+  (setq |$HistRecord|           (nth 7 tmp1))
+  (setq |$internalHistoryTable| (nth 8 tmp1))
+  (setq |$localExposureData|    (nth 9 tmp1))
+  (when |$frameMessages| 
+   (|sayMessage| 
+    (cons "   Current interpreter frame is called" |$interpreterFrameName|)))))
+
+@
+\subsection{Find a Frame in the Frame Ring by Name}
+Each frame contains its name as the 0th element.  We simply walk all
+the frames and if we find one we return it.
+\subsection{defun findFrameInRing}
+\begin{verbatim}
+findFrameInRing(name) ==
+  val := NIL
+  for frame in $interpreterFrameRing repeat
+    CAR frame = name =>
+      val := frame
+      return frame
+  val
+\end{verbatim}
+<<defun findFrameInRing>>=
+(defun |findFrameInRing| (name)
+ (block ()
+  (dolist (frame |$interpreterFrameRing|)
+   (when (boot-equal (frameName frame) name) (return frame)))))
+
+@
+\subsection{Update the Current Interpreter Frame}
+
+This function collects the normal contents of the world into a 
+frame object, places it first on the frame list, and then sets
+the current values of the world from the frame object. 
+
+\subsection{defun updateCurrentInterpreterFrame}
+\begin{verbatim}
+updateCurrentInterpreterFrame() ==
+  RPLACA($interpreterFrameRing,createCurrentInterpreterFrame())
+  updateFromCurrentInterpreterFrame()
+  NIL
+\end{verbatim}
+<<defun updateCurrentInterpreterFrame>>=
+(defun |updateCurrentInterpreterFrame| ()
+  (rplaca |$interpreterFrameRing| (|createCurrentInterpreterFrame|))
+  (|updateFromCurrentInterpreterFrame|)
+  nil)
+
+@
+\subsection{defun nextInterpreterFrame}
+
+This function updates the current frame to make sure all of the
+current information is recorded. If there are more frame elements
+in the list then this will destructively move the current frame
+to the end of the list, that is, assume the frame list reads (1 2 3)
+this function will destructively change it to (2 3 1).
+
+Note: the nconc2 function destructively inserts the second list at the
+end of the first.
+\begin{verbatim}
+nextInterpreterFrame() ==
+  updateCurrentInterpreterFrame()
+  null rest $interpreterFrameRing => NIL  -- nothing to do
+  $interpreterFrameRing :=
+    NCONC2(rest $interpreterFrameRing,[first $interpreterFrameRing])
+  updateFromCurrentInterpreterFrame()
+\end{verbatim}
+<<defun nextInterpreterFrame>>=
+(defun |nextInterpreterFrame| ()
+  (when (cdr |$interpreterFrameRing|)
+   (setq |$interpreterFrameRing|
+    (nconc2 (cdr |$interpreterFrameRing|) 
+      (list (car |$interpreterFrameRing|))))
+   (|updateFromCurrentInterpreterFrame|)))
+
+@
+\subsection{defun changeToNamedInterpreterFrame}
+\begin{verbatim}
+changeToNamedInterpreterFrame(name) ==
+  updateCurrentInterpreterFrame()
+  frame := findFrameInRing(name)
+  null frame => NIL
+  $interpreterFrameRing := [frame,:NREMOVE($interpreterFrameRing, frame)]
+  updateFromCurrentInterpreterFrame()
+\end{verbatim}
+<<defun changeToNamedInterpreterFrame>>=
+(defun |changeToNamedInterpreterFrame| (name)
+ (prog (frame)
+  (return
+   (progn 
+    (|updateCurrentInterpreterFrame|)
+    (spadlet frame (|findFrameInRing| name))
+    (cond 
+     ((null frame) 
+       nil)
+     (t 
+       (spadlet |$interpreterFrameRing|
+        (cons frame (nremove |$interpreterFrameRing| frame)))
+       (|updateFromCurrentInterpreterFrame|))))))) 
+
+@
+\subsection{defun previousInterpreterFrame}
+\begin{verbatim}
+previousInterpreterFrame() ==
+  updateCurrentInterpreterFrame()
+  null rest $interpreterFrameRing => NIL  -- nothing to do
+  [:b,l] := $interpreterFrameRing
+  $interpreterFrameRing := NCONC2([l],b)
+  updateFromCurrentInterpreterFrame()
+\end{verbatim}
+<<defun previousInterpreterFrame>>=
+(defun |previousInterpreterFrame| ()
+ (prog (tmp1 l b)
+  (return
+   (progn
+    (|updateCurrentInterpreterFrame|)
+    (cond
+     ((null (cdr |$interpreterFrameRing|))
+       nil)
+     (t
+       (spadlet tmp1 (reverse |$interpreterFrameRing|))
+       (spadlet l (car tmp1))
+       (spadlet b (nreverse (cdr tmp1)))
+       (spadlet |$interpreterFrameRing| (nconc2 (cons l nil) b))
+       (|updateFromCurrentInterpreterFrame|))))))) 
+
+@
+\subsection{defun addNewInterpreterFrame}
+\begin{verbatim}
+addNewInterpreterFrame(name) ==
+  null name => throwKeyedMsg("S2IZ0018",NIL)
+  updateCurrentInterpreterFrame()
+  -- see if we already have one by that name
+  for f in $interpreterFrameRing repeat
+    name = frameName(f) => throwKeyedMsg("S2IZ0019",[name])
+  initHistList()
+  $interpreterFrameRing := CONS(emptyInterpreterFrame(name),
+    $interpreterFrameRing)
+  updateFromCurrentInterpreterFrame()
+  _$ERASE histFileName()
+\end{verbatim}
+<<defun addNewInterpreterFrame>>=
+(defun |addNewInterpreterFrame| (name)
+ (seq
+  (cond
+   ((null name)
+    (|throwKeyedMsg| 'S2IZ0018 nil))  ; you must provide a name for new frame
+   (t
+     (|updateCurrentInterpreterFrame|)
+     (seq
+      (do ((tmp0 |$interpreterFrameRing| (cdr tmp0)) (f nil))
+          ((or (atom tmp0) 
+               (progn (setq f (car tmp0)) nil))
+             nil)
+       (seq
+        (exit
+         (when (boot-equal name (frameName f))
+          (exit 
+           (|throwKeyedMsg| 'S2IZ0019 ; existing frame with same name
+            (cons name nil)))))))
+      (|initHistList|)
+      (spadlet |$interpreterFrameRing|
+       (cons (|emptyInterpreterFrame| name) |$interpreterFrameRing|))
+      (|updateFromCurrentInterpreterFrame|)
+      ($erase (|histFileName|))))))) 
+
+@
+\subsection{defun closeInterpreterFrame}
+\begin{verbatim}
+closeInterpreterFrame(name) ==
+  -- if name = NIL then it means the current frame
+  null rest $interpreterFrameRing =>
+    name and (name ^= $interpreterFrameName) =>
+      throwKeyedMsg("S2IZ0020",[$interpreterFrameName])
+    throwKeyedMsg("S2IZ0021",NIL)
+  if null name then $interpreterFrameRing := rest $interpreterFrameRing
+  else   -- find the frame
+    found := nil
+    ifr := NIL
+    for f in $interpreterFrameRing repeat
+      found or (name ^= frameName(f)) => ifr := CONS(f,ifr)
+      found := true
+    not found => throwKeyedMsg("S2IZ0022",[name])
+    _$ERASE makeHistFileName(name)
+    $interpreterFrameRing := nreverse ifr
+  updateFromCurrentInterpreterFrame()
+\end{verbatim}
+<<defun closeInterpreterFrame>>=
+(defun |closeInterpreterFrame| (name)
+ (prog (ifr found)
+  (return
+   (seq
+    (cond
+     ((null (cdr |$interpreterFrameRing|))
+       (cond
+        ((and name (nequal name |$interpreterFrameName|))
+          (|throwKeyedMsg| 'S2IZ0020 ; 1 frame left. not the correct name.
+            (cons |$interpreterFrameName| nil))) 
+        (t (|throwKeyedMsg| 'S2IZ0021 nil)))) ; only 1 frame left, not closed
+     (t
+       (cond
+        ((null name)
+          (spadlet |$interpreterFrameRing| (cdr |$interpreterFrameRing|)))
+        (t 
+          (spadlet found nil)
+          (spadlet ifr nil)
+          (do ((tmp0 |$interpreterFrameRing| (cdr tmp0)) (f nil))
+              ((or (atom tmp0) (progn (setq f (car tmp0)) nil)) nil)
+           (seq
+            (exit
+             (cond
+              ((or found (nequal name (frameName f)))
+                (spadlet ifr (cons f ifr)))
+              (t 
+                (spadlet found t))))))
+          (cond
+           ((null found) 
+              (|throwKeyedMsg| 'S2IZ0022 (cons name nil)))
+           (t
+              ($erase (|makeHistFileName| name))
+              (spadlet |$interpreterFrameRing| (nreverse ifr))))))
+       (|updateFromCurrentInterpreterFrame|))))))) 
+
+@
+\subsection{defun displayFrameNames}
+\begin{verbatim}
+displayFrameNames() ==
+  fs := "append"/[ ['%l,'"     ",:bright frameName f] for f in
+    $interpreterFrameRing]
+  sayKeyedMsg("S2IZ0024",[fs])
+\end{verbatim}
+<<defun displayFrameNames>>=
+(defun |displayFrameNames| ()
+ (prog (fs)
+  (return
+   (seq
+    (progn
+     (spadlet fs
+      (prog (tmp0)
+       (spadlet tmp0 NIL)
+       (return
+        (do ((tmp1 |$interpreterFrameRing| (cdr tmp1)) (f nil))
+            ((or (atom tmp1)
+                 (progn (setq f (car tmp1)) nil))
+               tmp0)
+         (seq
+          (exit
+           (setq tmp0
+            (append tmp0 (cons '|%l| 
+              (cons (makestring "     ") (|bright| (frameName f))))))))))))
+      (|sayKeyedMsg| 'S2IZ0024 (cons fs nil))))))) ; frame names are ...
+
+@
+\subsection{defun importFromFrame}
+\begin{verbatim}
+importFromFrame args ==
+  -- args should have the form [frameName,:varNames]
+  if args and atom args then args := [args]
+  null args => throwKeyedMsg("S2IZ0073",NIL)
+  [fname,:args] := args
+  not member(fname,frameNames()) =>
+    throwKeyedMsg("S2IZ0074",[fname])
+  fname = frameName first $interpreterFrameRing =>
+    throwKeyedMsg("S2IZ0075",NIL)
+  fenv := frameEnvironment fname
+  null args =>
+    x := UPCASE queryUserKeyedMsg("S2IZ0076",[fname])
+    MEMQ(STRING2ID_-N(x,1),'(Y YES)) =>
+      vars := NIL
+      for [v,:props] in CAAR fenv repeat
+        v = "--macros" =>
+          for [m,:.] in props repeat vars := cons(m,vars)
+        vars := cons(v,vars)
+      importFromFrame [fname,:vars]
+    sayKeyedMsg("S2IZ0077",[fname])
+  for v in args repeat
+    plist := GETALIST(CAAR fenv,v)
+    plist =>
+      -- remove anything with the same name in the current frame
+      clearCmdParts ['propert,v]
+      for [prop,:val] in plist repeat
+        putHist(v,prop,val,$InteractiveFrame)
+    (m := get("--macros--",v,fenv)) =>
+      putHist("--macros--",v,m,$InteractiveFrame)
+    sayKeyedMsg("S2IZ0079",[v,fname])
+  sayKeyedMsg("S2IZ0078",[fname])
+\end{verbatim}
+<<defun importFromFrame>>=
+(defun |importFromFrame| (args)
+ (prog (temp1 fname fenv x v props vars plist prop val m)
+  (return
+   (seq
+    (progn
+     (when (and args (atom args))
+       (spadlet args (cons args nil))) 
+     (cond
+      ((null args)
+        (|throwKeyedMsg| 'S2IZ0073 nil)) ; missing frame name
+      (t
+        (spadlet temp1 args)
+        (spadlet fname (car temp1))
+        (spadlet args (cdr temp1))
+        (cond
+         ((null (|member| fname (|frameNames|)))
+           (|throwKeyedMsg| 'S2IZ0074 (cons fname nil))) ; not frame name
+         ((boot-equal fname (frameName (car |$interpreterFrameRing|)))
+           (|throwKeyedMsg| 'S2IZ0075 NIL)) ; cannot import from curr frame
+         (t
+           (spadlet fenv (|frameEnvironment| fname))
+           (cond
+            ((null args)
+              (spadlet x
+                (upcase (|queryUserKeyedMsg| 'S2IZ0076 (cons fname nil))))
+                                             ; import everything?
+              (cond
+               ((memq (string2id-n x 1) '(y yes))
+                 (spadlet vars nil)
+                 (do ((tmp0 (caar fenv) (cdr tmp0)) (tmp1 nil))
+                     ((or (atom tmp0) 
+                          (progn (setq tmp1 (car tmp0)) nil)
+                          (progn 
+                           (progn 
+                            (spadlet v (car tmp1))
+                            (spadlet props (cdr tmp1))
+                            tmp1)
+                           nil))
+                       nil)
+                  (seq
+                   (exit
+                    (cond
+                     ((boot-equal v '|--macros|)
+                       (do ((tmp2 props (cdr tmp2))
+                            (tmp3 nil))
+                           ((or (atom tmp2) 
+                                (progn (setq tmp3 (car tmp2)) nil)
+                                (progn 
+                                 (progn (spadlet m (car tmp3)) tmp3)
+                                 nil))
+                              nil)
+                        (seq
+                         (exit
+                          (spadlet vars (cons m vars))))))
+                     (t (spadlet vars (cons v vars)))))))
+                 (|importFromFrame| (cons fname vars)))
+               (t
+                 (|sayKeyedMsg| 'S2IZ0077 (cons fname nil)))))
+            (t
+             (do ((tmp4 args (cdr tmp4)) (v nil))
+                 ((or (atom tmp4) (progn (setq v (car tmp4)) nil)) nil)
+              (seq
+               (exit
+                (progn
+                 (spadlet plist (getalist (caar fenv) v))
+                 (cond
+                  (plist 
+                   (|clearCmdParts| (cons '|propert| (cons v nil)))
+                   (do ((tmp5 plist (cdr tmp5)) (tmp6 nil))
+                       ((or (atom tmp5)
+                            (progn (setq tmp6 (car tmp5)) nil)
+                            (progn 
+                             (progn 
+                              (spadlet prop (car tmp6))
+                              (spadlet val (cdr tmp6))
+                              tmp6)
+                             nil))
+                          nil)
+                    (seq
+                     (exit (|putHist| v prop val |$InteractiveFrame|)))))
+                  ((spadlet m (|get| '|--macros--| v fenv))
+                    (|putHist| '|--macros--| v m |$InteractiveFrame|))
+                  (t 
+                    (|sayKeyedMsg| 'S2IZ0079 ; frame not found
+                      (cons v (cons fname nil)))))))))
+             (|sayKeyedMsg| 'S2IZ0078 ; import complete
+               (cons fname nil))))))))))))) 
+
+@
+\subsection{defun frame}
+\begin{verbatim}
+-- the system command
+
+frame l == frameSpad2Cmd l
+\end{verbatim}
+<<defun frame>>=
+(defun |frame| (l)
+ (|frameSpad2Cmd| l)) 
+
+@
+\subsection{defun frameSpad2Cmd}
+\begin{verbatim}
+frameSpad2Cmd args ==
+  frameArgs := '(drop import last names new next)
+  $options => throwKeyedMsg("S2IZ0016",['")frame"])
+  null(args) => helpSpad2Cmd ['frame]
+  arg  := selectOptionLC(first args,frameArgs,'optionError)
+  args := rest args
+  if args is [a] then args := a
+  if ATOM args then args := object2Identifier args
+  arg = 'drop  =>
+    args and PAIRP(args) => throwKeyedMsg("S2IZ0017",[args])
+    closeInterpreterFrame(args)
+  arg = 'import =>  importFromFrame args
+  arg = 'last  =>   previousInterpreterFrame()
+  arg = 'names =>   displayFrameNames()
+  arg = 'new   =>
+    args and PAIRP(args) => throwKeyedMsg("S2IZ0017",[args])
+    addNewInterpreterFrame(args)
+  arg = 'next  =>   nextInterpreterFrame()
+
+  NIL
+\end{verbatim}
+<<defun frameSpad2Cmd>>=
+(defun |frameSpad2Cmd| (args)
+ (prog (frameArgs arg a)
+  (return
+   (progn
+    (spadlet frameArgs '(|drop| |import| |last| |names| |new| |next|))
+    (cond
+     (|$options|
+      (|throwKeyedMsg| 'S2IZ0016 ; frame command does not take options
+       (cons (makestring ")frame") nil)))
+     ((null args) 
+       (|helpSpad2Cmd| (cons '|frame| nil)))
+     (t
+       (spadlet arg 
+         (|selectOptionLC| (car args) frameArgs '|optionError|))
+       (spadlet args (cdr args))
+       (cond
+        ((and (pairp args) 
+              (eq (qcdr args) nil)
+              (progn (spadlet a (qcar args)) t))
+          (spadlet args a)))
+       (when (atom args)
+          (spadlet args (|object2Identifier| args)))
+       (cond
+        ((boot-equal arg '|drop|)
+          (cond
+           ((and args (pairp args))
+             (|throwKeyedMsg| 'S2IZ0017 ; not a valid frame name
+               (cons args nil)))
+           (t (|closeInterpreterFrame| args))))
+        ((boot-equal arg '|import|)
+          (|importFromFrame| args))
+        ((boot-equal arg '|last|)
+          (|previousInterpreterFrame|))
+        ((boot-equal arg '|names|)
+          (|displayFrameNames|))
+        ((boot-equal arg '|new|)
+          (cond 
+           ((and args (pairp args))
+             (|throwKeyedMsg| 'S2IZ0017 ; not a valid frame name
+               (cons args nil)))
+           (t
+             (|addNewInterpreterFrame| args))))
+        ((boot-equal arg '|next|)
+          (|nextInterpreterFrame|))
+        (t nil)))))))) 
+
+@
+\section{Frame File Messages}
+<<Frame File Messages>>=
+S2IZ0016
+ The %1b system command takes arguments but no options.
+S2IZ0017
+ %1b is not a valid frame name
+S2IZ0018
+ You must provide a name for the new frame.
+S2IZ0019
+ You cannot use the name %1b for a new frame because an existing
+ frame already has that name.
+S2IZ0020
+ There is only one frame active and therefore that cannot be closed.
+ Furthermore, the frame name you gave is not the name of the current frame.
+ The current frame is called %1b .
+S2IZ0021
+ The current frame is the only active one.  Issue %b )clear all %d to
+ clear its contents.
+S2IZ0022
+ There is no frame called %1b and so your command cannot be
+ processed.
+S2IZ0024
+ The names of the existing frames are: %1 %l
+ The current frame is the first one listed.
+S2IZ0073
+ %b )frame import %d must be followed by the frame name. The names
+ of objects in that frame can then optionally follow the frame name.
+ For example,
+ %ceon %b )frame import calculus %d %ceoff
+ imports all objects in the %b calculus %d frame, and
+ %ceon %b )frame import calculus epsilon delta %d %ceoff
+ imports the objects named %b epsilon %d and %b delta %d from the
+ frame %b calculus %d .
+ Please note that if the current frame contained any information
+ about objects with these names, then that information would be
+ cleared before the import took place.
+S2IZ0074
+ You cannot import anything from the frame %1b because that is not
+ the name of an existing frame.
+S2IZ0075
+ You cannot import from the current frame (nor is there a need!).
+S2IZ0076
+ User verification required:
+ do you really want to import everything from the frame %1b ?
+ If so, please enter %b y %d or %b yes %d :
+S2IZ0077
+ On your request, AXIOM will not import everything from frame %1b.
+S2IZ0078
+ Import from frame %1b is complete. Please issue %b )display all %d
+ if you wish to see the contents of the current frame.
+S2IZ0079
+ AXIOM cannot import %1b from frame %2b because it cannot be found.
+@
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{help}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+\par\noindent{\bf User Level Required:} interpreter
+
+\par\noindent{\bf Command Syntax:}
+\begin{list}{}
+\item{\tt )help}
+\item{\tt )help} {\it commandName}
+\end{list}
+
+\par\noindent{\bf Command Description:}
+
+This command displays help information about system commands.
+If you issue
+\begin{verbatim}
+)help
+\end{verbatim}
+then this very text will be shown.
+You can also give the name or abbreviation of a system command
+to display information about it.
+For example,
+\begin{verbatim}
+)help clear
+\end{verbatim}
+will display the description of the {\tt )clear} system command.
+
+All this material is available in the Axiom User Guide
+and in HyperDoc.
+In HyperDoc, choose the {\bf Commands} item from the
+{\bf Reference} menu.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{history}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
 \par\noindent{\bf User Level Required:} interpreter
 
@@ -1521,15 +3315,14 @@ If an invalid step number is given, Axiom will signal an error.
 The {\it environment} information can either be saved in a file or entirely in
 memory (the default).
 Each frame 
-(\ref{ugSysCmdframe} on page~\pageref{ugSysCmdframe})
 has its own history database.
 When it is kept in a file, some of it may also be kept in memory for
 efficiency.
 When the information is saved in a file, the name of the file is
 of the form {\bf FRAME.axh} where ``{\bf FRAME}'' is the name of the
 current frame.
-The history file is placed in the current working directory
-(see \ref{ugSysCmdcd} on page~\pageref{ugSysCmdcd}).
+The history file is placed in the current working directory.
+
 Note that these history database files are not text files (in fact,
 they are directories themselves), and so are not in human-readable
 format.
@@ -1591,8 +3384,8 @@ for a file called {\bf last.axh}.
 
 \item[{\tt )save} {\it savedHistoryName}]
 is used to save  a snapshot of the environment in a file.
-This file is placed in the current working directory
-(see \ref{ugSysCmdcd} on page~\pageref{ugSysCmdcd}).
+This file is placed in the current working directory.
+
 Use {\tt )history )restore} to restore the environment to the state
 preserved in the file.
 This option also creates an input file containing all the lines of input
@@ -1631,19 +3424,19 @@ the contents.
 \end{description}
 
 \par\noindent{\bf Also See:}
-{\tt )frame} \index{ugSysCmdframe},
-{\tt )read} \index{ugSysCmdread},
-{\tt )set} \index{ugSysCmdset}, and
-{\tt )undo} \index{ugSysCmdundo}.
+{\tt )frame},
+{\tt )read},
+{\tt )set}, and 
+{\tt )undo}
 
 
 History recording is done in two different ways:
 \begin{itemize}
 \item all changes in variable bindings (i.e. previous values) are
-    written to [[$HistList]], which is a circular list
+written to [[$HistList]], which is a circular list
 \item all new bindings (including the binding to [[%]]) are written to a
-    file called [[histFileName()]]
-    one older session is accessible via the file [[$oldHistFileName()]]
+file called [[histFileName()]]
+one older session is accessible via the file [[$oldHistFileName()]]
 \end{itemize}
 
 \section{Variables Used}
@@ -3938,934 +5731,836 @@ S2IH0038
  You must specify a file name to the history write command
 @
 
-\chapter{The Frame Mechanism}
-\section{)frame}
-\label{TheFrameMechanism}
-\index{TheFrameMechanism}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{library}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+\par\noindent{\bf User Level Required:} interpreter
+
 \par\noindent{\bf Command Syntax:}
 \begin{list}{}
-\item{\tt )frame  new  {\it frameName}}
-\item{\tt )frame  drop  {\it [frameName]}}
-\item{\tt )frame  next}
-\item{\tt )frame  last}
-\item{\tt )frame  names}
-\item{\tt )frame  import {\it frameName} {\it [objectName1 [objectName2 ...]]}}
-\item{\tt )set message frame on | off}
-\item{\tt )set message prompt frame}
+\item{\tt )library {\it libName1  \lanb{}libName2 ...\ranb{}}}
+\item{\tt )library )dir {\it dirName}}
+\item{\tt )library )only {\it objName1  \lanb{}objlib2 ...\ranb{}}}
+\item{\tt )library )noexpose}
 \end{list}
 
 \par\noindent{\bf Command Description:}
 
-A {\it frame} can be thought of as a logical session within the
-physical session that you get when you start the system.  You can
-have as many frames as you want, within the limits of your computer's
-storage, paging space, and so on.
-Each frame has its own {\it step number}, {\it environment} and {\it history.}
-You can have a variable named {\tt a} in one frame and it will
-have nothing to do with anything that might be called {\tt a} in
-any other frame.
+This command replaces the {\tt )load} system command that
+was available in Axiom releases before version 2.0.
+The {\tt )library} command makes available to Axiom the compiled
+objects in the libraries listed.
+
+For example, if you {\tt )compile dopler.as} in your home
+directory, issue {\tt )library dopler} to have Axiom look
+at the library, determine the category and domain constructors present,
+update the internal database with various properties of the
+constructors, and arrange for the constructors to be
+automatically loaded when needed.
+If the {\tt )noexpose} option has not been given, the
+constructors will be exposed (that is, available) in the current
+frame.
+
+If you compiled a file with the old system compiler, you will
+have an {\it nrlib} present, for example, {\it DOPLER.nrlib,}
+where {\tt DOPLER} is a constructor abbreviation.
+The command {\tt )library DOPLER} will then do the analysis and
+database updates as above.
+
+To tell the system about all libraries in a directory, use
+{\tt )library )dir dirName} where {\tt dirName} is an explicit
+directory.
+You may specify ``.'' as the directory, which means the current
+directory from which you started the system or the one you set
+via the {\tt )cd} command. The directory name is required.
+
+You may only want to tell the system about particular
+constructors within a library. In this case, use the {\tt )only}
+option. The command {\tt )library dopler )only Test1} will only
+cause the {\sf Test1} constructor to be analyzed, autoloaded,
+etc..
+
+Finally, each constructor in a library  are usually automatically exposed when the
+{\tt )library} command is used. Use the {\tt )noexpose}
+option if you not want them exposed. At a later time you can use
+{\tt )set expose add constructor} to expose any hidden
+constructors.
+
+{\bf Note for Axiom beta testers:} At various times this
+command was called {\tt )local} and {\tt )with} before the name
+{\tt )library} became the official name.
 
-Some frames are created by the HyperDoc program and these can
-have pretty strange names, since they are generated automatically.
-\index{frame names}
-To find out the names
-of all frames, issue
-\begin{verbatim}
-)frame names
-\end{verbatim}
-It will indicate the name of the current frame.
+\par\noindent{\bf Also See:}
+\fnref{cd}, 
+\fnref{compiler},
+\fnref{frame}, and
+\fnref{set}
 
-You create a new frame
-\index{frame new}
-``{\bf quark}'' by issuing
-\begin{verbatim}
-)frame new quark
-\end{verbatim}
-The history facility can be turned on by issuing either
-{\tt )set history on} or {\tt )history )on}.
-If the history facility is on and you are saving history information
-in a file rather than in the Axiom environment
-then a history file with filename {\bf quark.axh} will
-be created as you enter commands.
-If you wish to go back to what
-you were doing in the
-\index{frame next}
-``{\bf initial}'' frame, use
-\index{frame last}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{lisp}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+\par\noindent{\bf User Level Required:} development
+
+\par\noindent{\bf Command Syntax:}
+\begin{list}{}
+\item {\tt )lisp} {\it\lanb{}lispExpression\ranb{}}
+\end{list}
+
+\par\noindent{\bf Command Description:}
+
+This command is used by Axiom system developers to have single
+expressions evaluated by the Common Lisp system on which
+Axiom is built.
+The {\it lispExpression} is read by the Common Lisp reader and
+evaluated.
+If this expression is not complete (unbalanced parentheses, say), the reader
+will wait until a complete expression is entered.
+
+Since this command is only useful  for evaluating single expressions, the
+{\tt )fin}
+command may be used to  drop out  of Axiom  into Common Lisp.
+
+\par\noindent{\bf Also See:}
+\fnref{system},
+\fnref{boot}, and
+\fnref{fin}
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{load}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+\par\noindent{\bf User Level Required:} interpreter
+\par\noindent{\bf Command Description:}
+
+This command is obsolete. Use {\tt )library} instead.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{ltrace}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+\par\noindent{\bf User Level Required:} development
+
+\par\noindent{\bf Command Syntax:}
+
+This command has the same arguments as options as the
+{\tt )trace} command.
+
+\par\noindent{\bf Command Description:}
+
+This command is used by Axiom system developers to trace
+Common Lisp or
+BOOT functions.
+It is not supported for general use.
+
+\par\noindent{\bf Also See:}
+\fnref{boot},
+\fnref{lisp}, and
+\fnref{trace}
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{pquit}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+\par\noindent{\bf User Level Required:} interpreter
+
+\par\noindent{\bf Command Syntax:}
+\begin{list}{}
+\item{\tt )pquit}
+\end{list}
+
+\par\noindent{\bf Command Description:}
+
+This command is used to terminate Axiom  and return to the
+operating system.
+Other than by redoing all your computations or by
+using the {\tt )history )restore}
+command to try to restore your working environment,
+you cannot return to Axiom in the same state.
+
+{\tt )pquit} differs from the {\tt )quit} in that it always asks for
+confirmation that you want to terminate Axiom (the ``p'' is for
+``protected'').
+\index{quit}
+When you enter the {\tt )pquit} command, Axiom responds
+%
+\begin{center}
+Please enter {\bf y} or {\bf yes} if you really want to leave the interactive \\
+environment and return to the operating system:
+\end{center}
+%
+If you respond with {\tt y} or {\tt yes}, you will see the message
+%
+\begin{center}
+You are now leaving the Axiom interactive environment. \\
+Issue the command {\bf axiom} to the operating system to start a new session.
+\end{center}
+%
+and Axiom will terminate and return you to the operating
+system (or the environment from which you invoked the system).
+If you responded with something other than {\tt y} or {\tt yes}, then
+the message
+%
+\begin{center}
+You have chosen to remain in the Axiom interactive environment.
+\end{center}
+%
+will be displayed and, indeed, Axiom would still be running.
+
+\par\noindent{\bf Also See:}
+\fnref{fin},
+\fnref{history},
+\fnref{close},
+\fnref{quit}, and
+\fnref{system}
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{quit}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+\par\noindent{\bf User Level Required:} interpreter
+
+\par\noindent{\bf Command Syntax:}
+\begin{list}{}
+\item{\tt )quit}
+\item{\tt )set quit protected \vertline{} unprotected}
+\end{list}
+
+\par\noindent{\bf Command Description:}
+
+This command is used to terminate Axiom  and return to the
+operating system.
+Other than by redoing all your computations or by
+using the {\tt )history )restore}
+command to try to restore your working environment,
+you cannot return to Axiom in the same state.
+
+{\tt )quit} differs from the {\tt )pquit} in that it asks for
+\index{pquit}
+confirmation only if the command
 \begin{verbatim}
-)frame next
+)set quit protected
 \end{verbatim}
-or
+has been issued.
+\index{set quit protected}
+Otherwise, {\tt )quit} will make Axiom terminate and return you
+to the operating system (or the environment from which you invoked the
+system).
+
+The default setting is {\tt )set quit protected} so that {\tt )quit}
+and {\tt )pquit} behave in the same way.
+If you do issue
 \begin{verbatim}
-)frame last
+)set quit unprotected
 \end{verbatim}
-to cycle through the ring of available frames to get back to
-``{\bf initial}''.
+we
+\index{set quit unprotected}
+suggest that you do not (somehow) assign {\tt )quit} to be
+executed when you press, say, a function key.
 
-If you want to throw
-away a frame (say ``{\bf quark}''), issue
+\par\noindent{\bf Also See:}
+\fnref{fin},
+\fnref{history},
+\fnref{close},
+\fnref{pquit}, and
+\fnref{system}
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{read}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+
+\par\noindent{\bf User Level Required:} interpreter
+
+\par\noindent{\bf Command Syntax:}
+\begin{list}{}
+\item {\tt )read} {\it \lanb{}fileName\ranb{}}
+\item {\tt )read} {\it \lanb{}fileName\ranb{}} \lanb{}{\tt )quiet}\ranb{} \lanb{}{\tt )ifthere}\ranb{}
+\end{list}
+\par\noindent{\bf Command Description:}
+
+This command is used to read {\bf .input} files into Axiom.
+\index{file!input}
+The command
 \begin{verbatim}
-)frame drop quark
+)read matrix.input
 \end{verbatim}
-If you omit the name, the current frame is dropped.
-\index{frame drop}
+will read the contents of the file {\bf matrix.input} into
+Axiom.
+The ``.input'' file extension is optional.
 
-If you do use frames with the history facility on and writing to a file,
-you may want to delete some of the older history files.
-\index{file!history}
-These are directories, so you may want to issue a command like
-{\tt rm -r quark.axh} to the operating system.
+This command remembers the previous file you edited, read or compiled.
+If you do not specify a file name, the previous file will be read.
 
-You can bring things from another frame by using
-\index{frame import}
-{\tt )frame import}.
-For example, to bring the {\tt f} and {\tt g} from the frame ``{\bf quark}''
-to the current frame, issue
+The {\tt )ifthere} option checks to see whether the {\bf .input} file
+exists.
+If it does not, the  {\tt )read} command does nothing.
+If you do not use this option and the file does not exist,
+you are asked to give the name of an existing {\bf .input} file.
+
+The {\tt )quiet} option suppresses output while the file is being read.
+
+\par\noindent{\bf Also See:}
+\fnref{compiler},
+\fnref{edit}, and
+\fnref{history}
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{savesystem}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{set}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+\par\noindent{\bf User Level Required:} interpreter
+
+\par\noindent{\bf Command Syntax:}
+\begin{list}{}
+\item {\tt )set}
+\item {\tt )set} {\it label1 \lanb{}... labelN\ranb{}}
+\item {\tt )set} {\it label1 \lanb{}... labelN\ranb{} newValue}
+\end{list}
+\par\noindent{\bf Command Description:}
+
+The {\tt )set} command is used to view or set system variables that
+control what messages are displayed, the type of output desired, the
+status of the history facility, the way Axiom user functions are
+cached, and so on.
+Since this collection is very large, we will not discuss them here.
+Rather, we will show how the facility is used.
+We urge you to explore the {\tt )set} options to familiarize yourself
+with how you can modify your Axiom working environment.
+There is a HyperDoc version of this same facility available from the
+main HyperDoc menu.
+
+
+The {\tt )set} command is command-driven with a menu display.
+It is tree-structured.
+To see all top-level nodes, issue {\tt )set} by itself.
 \begin{verbatim}
-)frame import quark f g
+)set
 \end{verbatim}
-If you want everything from the frame ``{\bf quark}'', issue
+Variables with values have them displayed near the right margin.
+Subtrees of selections have ``{\tt ...}''
+displayed in the value field.
+For example, there are many kinds of messages, so issue
+{\tt )set message} to see the choices.
 \begin{verbatim}
-)frame import quark
+)set message
 \end{verbatim}
-You will be asked to verify that you really want everything.
-
-There are two {\tt )set} flags
-\index{set message frame}
-to make it easier to tell where you are.
+The current setting  for the variable that displays
+\index{computation timings!displaying}
+whether computation times
+\index{timings!displaying}
+are displayed is visible in the menu displayed by the last command.
+To see more information, issue
 \begin{verbatim}
-)set message frame on | off
+)set message time
 \end{verbatim}
-will print more messages about frames when it is set on.
-By default, it is off.
+This shows that time printing is on now.
+To turn it off, issue
 \begin{verbatim}
-)set message prompt frame
+)set message time off
 \end{verbatim}
-will give a prompt
-\index{set message prompt frame}
-that looks like
+\index{set message time}
+
+As noted above, not all settings have so many qualifiers.
+For example, to change the {\tt )quit} command to being unprotected
+(that is, you will not be prompted for verification), you need only issue
 \begin{verbatim}
-initial (1) ->
+)set quit unprotected
 \end{verbatim}
-\index{prompt!with frame name}
-when you start up. In this case, the frame name and step make up the
-prompt.
+\index{set quit unprotected}
 
 \par\noindent{\bf Also See:}
-{\tt )history} \index{ugSysCmdhistory} and
-{\tt )set} \index{ugSysCmdset}.
+\fnref{quit}
 
-\section{Variables Used}
-The frame mechanism uses several dollar variables.
-\subsection{Primary variables}
-Primary variables are those which exist solely to make the frame
-mechanism work. 
-
-The \$interpreterFrameName contains a symbol which is the name
-of the current frame in use. 
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{show}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
-The \$interpreterFrameRing contains a list of all of the existing
-frames. The first frame on the list is the ``current'' frame. When
-AXIOMsys is started directly there is only one frame named ``initial''.
+\par\noindent{\bf User Level Required:} interpreter
 
-If the system is started under sman (using the axiom shell script,
-for example), there are two frames, ``initial'' and ``frame0''. In
-this case, ``frame0'' is the current frame. This can cause subtle
-problems because functions defined in the axiom initialization file
-(.axiom.input) will be defined in frame ``initial'' but the current
-frame will be ``frame0''. They will appear to be undefined. However,
-if the user does ``)frame next'' they can switch to the ``initial''
-frame and see the functions correctly defined.
+\par\noindent{\bf Command Syntax:}
+\begin{list}{}
+\item {\tt )show {\it nameOrAbbrev}}
+\item {\tt )show {\it nameOrAbbrev} )operations}
+\item {\tt )show {\it nameOrAbbrev} )attributes}
+\end{list}
 
-The \$frameMessages variable controls when frame messages will be
-displayed. The variable is initially NIL. It can be set on (T) or off (NIL)
-using the system command:
+\par\noindent{\bf Command Description:}
+This command displays information about Axiom
+domain, package and category {\it constructors}.
+If no options are given, the {\tt )operations} option is assumed.
+For example,
 \begin{verbatim}
-    )set message frame on | off
+)show POLY
+)show POLY )operations
+)show Polynomial
+)show Polynomial )operations
+\end{verbatim}
+each display basic information about the
+{\tt Polynomial} domain constructor and then provide a
+listing of operations.
+Since {\tt Polynomial} requires a {\tt Ring} (for example,
+{\tt Integer}) as argument, the above commands all refer
+to a unspecified ring {\tt R}.
+In the list of operations, {\tt \$} means
+{\tt Polynomial(R)}.
+
+The basic information displayed includes the {\it signature}
+of the constructor (the name and arguments), the constructor
+{\it abbreviation}, the {\it exposure status} of the constructor, and the
+name of the {\it library source file} for the constructor.
+
+If operation information about a specific domain is wanted,
+the full or abbreviated domain name may be used.
+For example,
+\begin{verbatim}
+)show POLY INT
+)show POLY INT )operations
+)show Polynomial Integer
+)show Polynomial Integer )operations
 \end{verbatim}
-Setting frame messages on will output a line detailing the 
-current frame after every output is complete. 
+are among  the combinations that will
+display the operations exported  by the
+domain {\tt Polynomial(Integer)} (as opposed to the general
+{\it domain constructor} {\tt Polynomial}).
+Attributes may be listed by using the {\tt )attributes} option.
 
-\subsection{Used variables}
+\par\noindent{\bf Also See:}
+\fnref{display},
+\fnref{set}, and
+\fnref{what}
 
-The frame collects and uses a few top level variables. These are:
-\$InteractiveFrame, \$IOindex, \$HiFiAccess, \$HistList, \$HistListLen,
-\$HistListAct, \$HistRecord, \$internalHistoryTable, and \$localExposureData.
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{spool}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
-These variables can also be changed by the frame mechanism when the user
-requests changing to a different frame.
+\par\noindent{\bf User Level Required:} interpreter
 
-\section{Data Structures}
-\subsection{Frames and the Interpreter Frame Ring}
+\par\noindent{\bf Command Syntax:}
+\begin{list}{}
+\item{\tt )spool} \lanb{}{\it fileName}\ranb{}
+\item{\tt )spool}
+\end{list}
 
-Axiom has the notion of ``frames''. A frame is a data structure which
-holds all the vital data from an Axiom session. There can be multiple
-frames and these live in a top-level variable called
-\$interpreterFrameRing. This variable holds a circular list of frames.
-The parts of a frame and their initial, default values are:
+\par\noindent{\bf Command Description:}
 
+This command is used to save {\it (spool)} all Axiom input and output
+\index{file!spool}
+into a file, called a {\it spool file.}
+You can only have one spool file active at a time.
+To start spool, issue this command with a filename. For example,
 \begin{verbatim}
-  $interpreterFrameName      a string, named on creation
-  $InteractiveFrame          (list (list nil))
-  $IOindex                   an integer, 1
-  $HiFiAccess                $HiFiAccess, see the variable description
-  $HistList                  $HistList, see the variable description
-  $HistListLen               $HistListLen, see the variable description
-  $HistListAct               $HistListAct, see the variable description
-  $HistRecord                $HistRecord, see the variable description
-  $internalHistoryTable      nil
-  $localExposureData         a copy of $localExposureData
+)spool integrate.out
 \end{verbatim}
+To stop spooling, issue {\tt )spool} with no filename.
 
-\section{Accessor Functions}
-These could be macros but we wish to export them to the API code
-in the algebra so we keep them as functions.
-\subsection{0th Frame Component -- frameName}
-\subsection{defun frameName}
-<<defun frameName>>=
-(defun frameName (frame)
- (car frame)) 
-
-@
-\subsection{1st Frame Component -- frameInteractive}
-<<defun frameInteractive>>=
-(defun frameInteractive (frame)
- (nth 1 frame))
+If the filename is qualified with a directory, then the output will
+be placed in that directory.
+If no directory information is given, the spool file will be placed in the
+\index{directory!for spool files}
+{\it current directory.}
+The current directory is the directory from which you started
+Axiom or is the directory you specified using the
+{\tt )cd} command.
+\index{cd}
 
-@
-\subsection{2nd Frame Component -- frameIOIndex}
-<<defun frameIOIndex>>=
-(defun frameIOIndex (frame)
- (nth 2 frame))
-
-@
-\subsection{3rd Frame Component -- frameHiFiAccess}
-<<defun frameHiFiAccess>>=
-(defun frameHiFiAccess (frame)
- (nth 3 frame))
-
-@
-\subsection{4th Frame Component -- frameHistList}
-<<defun frameHistList>>=
-(defun frameHistList (frame)
- (nth 4 frame))
-
-@
-\subsection{5th Frame Component -- frameHistListLen}
-<<defun frameHistListLen>>=
-(defun frameHistListLen (frame)
- (nth 5 frame))
-
-@
-\subsection{6th Frame Component -- frameHistListAct}
-<<defun frameHistListAct>>=
-(defun frameHistListAct (frame)
- (nth 6 frame))
-
-@
-\subsection{7th Frame Component -- frameHistRecord}
-<<defun frameHistRecord>>=
-(defun frameHistRecord (frame)
- (nth 7 frame))
-
-@
-\subsection{8th Frame Component -- frameHistoryTable}
-<<defun frameHistoryTable>>=
-(defun frameHistoryTable (frame)
- (nth 8 frame))
-
-@
-\subsection{9th Frame Component -- frameExposureData}
-<<defun frameExposureData>>=
-(defun frameExposureData (frame)
- (nth 9 frame))
+\par\noindent{\bf Also See:}
+\fnref{cd}
 
-@
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{summary}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
-\section{Variables Used}
-\section{Data Structures}
-\section{Functions}
-\subsection{Initializing the Interpreter Frame Ring}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{synonym}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
-Now that we know what a frame looks like we need a function to
-initialize the list of frames. This function sets the initial frame
-name to ``initial'' and creates a list of frames containing an empty
-frame. This list is the interpreter frame ring and is not actually
-circular but is managed as a circular list. 
+\par\noindent{\bf User Level Required:} interpreter
 
-As a final step we update the world from this frame. This has the
-side-effect of resetting all the important global variables to their
-initial values.
+\par\noindent{\bf Command Syntax:}
+\begin{list}{}
+\item{\tt )synonym}
+\item{\tt )synonym} {\it synonym fullCommand}
+\item{\tt )what synonyms}
+\end{list}
 
-<<defun initializeInterpreterFrameRing>>=
-(defun |initializeInterpreterFrameRing| ()
- (setq |$interpreterFrameName| '|initial|)
- (setq |$interpreterFrameRing|
-   (list (|emptyInterpreterFrame| |$interpreterFrameName|)))
- (|updateFromCurrentInterpreterFrame|)
- nil) 
+\par\noindent{\bf Command Description:}
 
-@
-\subsection{Creating a List of all of the Frame Names}
-\subsection{defun frameNames}
-This function simply walks across the frame in the frame ring and
-returns a list of the name of each frame. 
+This command is used to create short synonyms for system command expressions.
+For example, the following synonyms  might simplify commands you often
+use.
 \begin{verbatim}
-frameNames() == [frameName f for f in $interpreterFrameRing]
+)synonym save         history )save
+)synonym restore      history )restore
+)synonym mail         system mail
+)synonym ls           system ls
+)synonym fortran      set output fortran
 \end{verbatim}
-<<defun frameNames>>=
-(defun |frameNames| () 
- (mapcar #'frameName |$interpreterFrameRing|))
-
-@
-
-\subsection{Get Named Frame Environment (aka Interactive)}
-If the frame is found we return the environment portion of the frame
-otherwise we construct an empty environment and return it.
-The initial values of an empty frame are created here. This function
-returns a single frame that will be placed in the frame ring.
-\subsection{defun frameEnvironment}
+Once defined, synonyms can be
+used in place of the longer  command expressions.
+Thus
 \begin{verbatim}
-frameEnvironment fname ==
-  -- extracts the environment portion of a frame
-  -- if fname is not a valid frame name then the empty environment
-  -- is returned
-  fname = frameName first $interpreterFrameRing => $InteractiveFrame
-  ifr := rest $interpreterFrameRing
-  e := LIST LIST NIL
-  while ifr repeat
-    [f,:ifr] := ifr
-    if fname = frameName f   then
-      e := CADR f
-      ifr := NIL
-  e
+)fortran on
 \end{verbatim}
-<<defun frameEnvironment>>=
-(defun |frameEnvironment| (fname)
- (let ((frame (|findFrameInRing| fname)))
-  (if frame
-   (frameInteractive frame)
-   (list (list nil)))))
-
-@
-\subsection{defun emptyInterpreterFrame}
+is the same as the longer
 \begin{verbatim}
-emptyInterpreterFrame(name) ==
-  LIST(name,                            -- frame name
-       LIST LIST NIL,                   -- environment
-       1,                               -- $IOindex
-       $HiFiAccess,                     -- $HiFiAccess
-       $HistList,                       -- $HistList
-       $HistListLen,                    -- $HistListLen
-       $HistListAct,                    -- $HistListAct
-       $HistRecord,                     -- $HistRecord
-       NIL,                             -- $internalHistoryTable
-       COPY_-SEQ $localExposureDataDefault        -- $localExposureData
-      )
+)set fortran output on
+\end{verbatim}
+To list all defined synonyms, issue either of
+\begin{verbatim}
+)synonyms
+)what synonyms
+\end{verbatim}
+To list, say, all synonyms that contain the substring
+``{\tt ap}'', issue
+\begin{verbatim}
+)what synonyms ap
 \end{verbatim}
-<<defun emptyInterpreterFrame>>=
-(defun |emptyInterpreterFrame| (name)
- (list name
-   (list (list nil))
-   1 
-   |$HiFiAccess| 
-   |$HistList| 
-   |$HistListLen| 
-   |$HistListAct| 
-   |$HistRecord| 
-   nil 
-   (copy-seq |$localExposureDataDefault|))) 
 
-@
-\subsection{Collecting up the Environment into a Frame}
+\par\noindent{\bf Also See:}
+\fnref{set} and
+\fnref{what}
 
-We can collect up all the current environment information into
-one frame element with this call. It creates a list of the current
-values of the global variables and returns this as a frame element.
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{system}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
-\subsection{defun createCurrentInterpreterFrame}
-\begin{verbatim}
-createCurrentInterpreterFrame() ==
-  LIST($interpreterFrameName,           -- frame name
-       $InteractiveFrame,               -- environment
-       $IOindex,                        -- $IOindex
-       $HiFiAccess,                     -- $HiFiAccess
-       $HistList,                       -- $HistList
-       $HistListLen,                    -- $HistListLen
-       $HistListAct,                    -- $HistListAct
-       $HistRecord,                     -- $HistRecord
-       $internalHistoryTable,           -- $internalHistoryTable
-       $localExposureData               -- $localExposureData
-      )
-\end{verbatim}
-<<defun createCurrentInterpreterFrame>>=
-(defun |createCurrentInterpreterFrame| ()
- (list 
-   |$interpreterFrameName| 
-   |$InteractiveFrame| 
-   |$IOindex| 
-   |$HiFiAccess| 
-   |$HistList| 
-   |$HistListLen| 
-   |$HistListAct| 
-   |$HistRecord| 
-   |$internalHistoryTable| 
-   |$localExposureData|)) 
+\par\noindent{\bf User Level Required:} interpreter
 
-@
-\subsection{Updating from the Current Frame}
+\par\noindent{\bf Command Syntax:}
+\begin{list}{}
+\item{\tt )system} {\it cmdExpression}
+\end{list}
 
-The frames are kept on a circular list. The first element on that
-list is known as ``the current frame''. This will initialize all
-of the interesting interpreter data structures from that frame.
+\par\noindent{\bf Command Description:}
 
-\subsection{defun updateFromCurrentInterpreterFrame}
-\begin{verbatim}
-updateFromCurrentInterpreterFrame() ==
-  [$interpreterFrameName,          _
-   $InteractiveFrame,              _
-   $IOindex,                       _
-   $HiFiAccess,                    _
-   $HistList,                      _
-   $HistListLen,                   _
-   $HistListAct,                   _
-   $HistRecord,                    _
-   $internalHistoryTable,          _
-   $localExposureData              _
-   ] := first $interpreterFrameRing
-  if $frameMessages then
-    sayMessage ['"   Current interpreter frame is called",:bright
-      $interpreterFrameName]
-  NIL
-\end{verbatim}
-<<defun updateFromCurrentInterpreterFrame>>=
-(defun |updateFromCurrentInterpreterFrame| ()
- (let (tmp1)
-  (setq tmp1 (first |$interpreterFrameRing|))
-  (setq |$interpreterFrameName| (nth 0 tmp1))
-  (setq |$InteractiveFrame|     (nth 1 tmp1))
-  (setq |$IOindex|              (nth 2 tmp1))
-  (setq |$HiFiAccess|           (nth 3 tmp1))
-  (setq |$HistList|             (nth 4 tmp1))
-  (setq |$HistListLen|          (nth 5 tmp1))
-  (setq |$HistListAct|          (nth 6 tmp1))
-  (setq |$HistRecord|           (nth 7 tmp1))
-  (setq |$internalHistoryTable| (nth 8 tmp1))
-  (setq |$localExposureData|    (nth 9 tmp1))
-  (when |$frameMessages| 
-   (|sayMessage| 
-    (cons "   Current interpreter frame is called" |$interpreterFrameName|)))))
+This command may be used to issue commands to the operating system while
+remaining in Axiom.
+The {\it cmdExpression} is passed to the operating system for
+execution.
+
+To get an operating system shell, issue, for example,
+{\tt )system sh}.
+When you enter the key combination,
+\fbox{\bf Ctrl}--\fbox{\bf D}
+(pressing and holding the
+\fbox{\bf Ctrl} key and then pressing the
+\fbox{\bf D} key)
+the shell will terminate and you will return to Axiom.
+We do not recommend this way of creating a shell because
+Common Lisp may field some interrupts instead of the shell.
+If possible, use a shell running in another window.
+
+If you execute programs that misbehave you may not be able to return to
+Axiom.
+If this happens, you may have no other choice than to restart
+Axiom and restore the environment via {\tt )history )restore}, if
+possible.
 
-@
-\subsection{Find a Frame in the Frame Ring by Name}
-Each frame contains its name as the 0th element.  We simply walk all
-the frames and if we find one we return it.
-\subsection{defun findFrameInRing}
-\begin{verbatim}
-findFrameInRing(name) ==
-  val := NIL
-  for frame in $interpreterFrameRing repeat
-    CAR frame = name =>
-      val := frame
-      return frame
-  val
-\end{verbatim}
-<<defun findFrameInRing>>=
-(defun |findFrameInRing| (name)
- (block ()
-  (dolist (frame |$interpreterFrameRing|)
-   (when (boot-equal (frameName frame) name) (return frame)))))
+\par\noindent{\bf Also See:}
+\fnref{boot},
+\fnref{fin},
+\fnref{lisp},
+\fnref{pquit}, and
+\fnref{quit}
 
-@
-\subsection{Update the Current Interpreter Frame}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{trace}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
-This function collects the normal contents of the world into a 
-frame object, places it first on the frame list, and then sets
-the current values of the world from the frame object. 
+\par\noindent{\bf User Level Required:} interpreter
 
-\subsection{defun updateCurrentInterpreterFrame}
-\begin{verbatim}
-updateCurrentInterpreterFrame() ==
-  RPLACA($interpreterFrameRing,createCurrentInterpreterFrame())
-  updateFromCurrentInterpreterFrame()
-  NIL
-\end{verbatim}
-<<defun updateCurrentInterpreterFrame>>=
-(defun |updateCurrentInterpreterFrame| ()
-  (rplaca |$interpreterFrameRing| (|createCurrentInterpreterFrame|))
-  (|updateFromCurrentInterpreterFrame|)
-  nil)
+\par\noindent{\bf Command Syntax:}
+\begin{list}{}
+\item{\tt )trace}
+\item{\tt )trace )off}
 
-@
-\subsection{defun nextInterpreterFrame}
+\item{\tt )trace} {\it function \lanb{}options\ranb{}}
+\item{\tt )trace} {\it constructor \lanb{}options\ranb{}}
+\item{\tt )trace} {\it domainOrPackage \lanb{}options\ranb{}}
+\end{list}
+%
+where options can be one or more of
+%
+\begin{list}{}
+\item{\tt )after} {\it S-expression}
+\item{\tt )before} {\it S-expression}
+\item{\tt )break after}
+\item{\tt )break before}
+\item{\tt )cond} {\it S-expression}
+\item{\tt )count}
+\item{\tt )count} {\it n}
+\item{\tt )depth} {\it n}
+\item{\tt )local} {\it op1 \lanb{}... opN\ranb{}}
+\item{\tt )nonquietly}
+\item{\tt )nt}
+\item{\tt )off}
+\item{\tt )only} {\it listOfDataToDisplay}
+\item{\tt )ops}
+\item{\tt )ops} {\it op1 \lanb{}... opN \ranb{}}
+\item{\tt )restore}
+\item{\tt )stats}
+\item{\tt )stats reset}
+\item{\tt )timer}
+\item{\tt )varbreak}
+\item{\tt )varbreak} {\it var1 \lanb{}... varN \ranb{}}
+\item{\tt )vars}
+\item{\tt )vars} {\it var1 \lanb{}... varN \ranb{}}
+\item{\tt )within} {\it executingFunction}
+\end{list}
 
-This function updates the current frame to make sure all of the
-current information is recorded. If there are more frame elements
-in the list then this will destructively move the current frame
-to the end of the list, that is, assume the frame list reads (1 2 3)
-this function will destructively change it to (2 3 1).
+\par\noindent{\bf Command Description:}
 
-Note: the nconc2 function destructively inserts the second list at the
-end of the first.
-\begin{verbatim}
-nextInterpreterFrame() ==
-  updateCurrentInterpreterFrame()
-  null rest $interpreterFrameRing => NIL  -- nothing to do
-  $interpreterFrameRing :=
-    NCONC2(rest $interpreterFrameRing,[first $interpreterFrameRing])
-  updateFromCurrentInterpreterFrame()
-\end{verbatim}
-<<defun nextInterpreterFrame>>=
-(defun |nextInterpreterFrame| ()
-  (when (cdr |$interpreterFrameRing|)
-   (setq |$interpreterFrameRing|
-    (nconc2 (cdr |$interpreterFrameRing|) 
-      (list (car |$interpreterFrameRing|))))
-   (|updateFromCurrentInterpreterFrame|)))
+This command is used to trace the execution of functions that make
+up the Axiom system, functions defined by users,
+and functions from the system library.
+Almost all options are available for each type of function but
+exceptions will be noted below.
 
-@
-\subsection{defun changeToNamedInterpreterFrame}
+To list all functions, constructors, domains and packages that are
+traced, simply issue
 \begin{verbatim}
-changeToNamedInterpreterFrame(name) ==
-  updateCurrentInterpreterFrame()
-  frame := findFrameInRing(name)
-  null frame => NIL
-  $interpreterFrameRing := [frame,:NREMOVE($interpreterFrameRing, frame)]
-  updateFromCurrentInterpreterFrame()
+)trace
 \end{verbatim}
-<<defun changeToNamedInterpreterFrame>>=
-(defun |changeToNamedInterpreterFrame| (name)
- (prog (frame)
-  (return
-   (progn 
-    (|updateCurrentInterpreterFrame|)
-    (spadlet frame (|findFrameInRing| name))
-    (cond 
-     ((null frame) 
-       nil)
-     (t 
-       (spadlet |$interpreterFrameRing|
-        (cons frame (nremove |$interpreterFrameRing| frame)))
-       (|updateFromCurrentInterpreterFrame|))))))) 
-
-@
-\subsection{defun previousInterpreterFrame}
+To untrace everything that is traced, issue
 \begin{verbatim}
-previousInterpreterFrame() ==
-  updateCurrentInterpreterFrame()
-  null rest $interpreterFrameRing => NIL  -- nothing to do
-  [:b,l] := $interpreterFrameRing
-  $interpreterFrameRing := NCONC2([l],b)
-  updateFromCurrentInterpreterFrame()
+)trace )off
 \end{verbatim}
-<<defun previousInterpreterFrame>>=
-(defun |previousInterpreterFrame| ()
- (prog (tmp1 l b)
-  (return
-   (progn
-    (|updateCurrentInterpreterFrame|)
-    (cond
-     ((null (cdr |$interpreterFrameRing|))
-       nil)
-     (t
-       (spadlet tmp1 (reverse |$interpreterFrameRing|))
-       (spadlet l (car tmp1))
-       (spadlet b (nreverse (cdr tmp1)))
-       (spadlet |$interpreterFrameRing| (nconc2 (cons l nil) b))
-       (|updateFromCurrentInterpreterFrame|))))))) 
+When a function is traced, the default system action is to display
+the arguments to the function and the return value when the
+function is exited.
+Note that if a function is left via an action such as a {\tt THROW}, no
+return value will be displayed.
+Also, optimization of tail recursion may decrease the number of
+times a function is actually invoked and so may cause less trace
+information to be displayed.
+Other information can be displayed or collected when a function is
+traced and this is controlled by the various options.
+Most options will be of interest only to Axiom system
+developers.
+If a domain or package is traced, the default action is to trace
+all functions exported.
 
-@
-\subsection{defun addNewInterpreterFrame}
+Individual interpreter, lisp or boot
+functions can be traced by listing their names after
+{\tt )trace}.
+Any options that are present must follow the functions to be
+traced.
 \begin{verbatim}
-addNewInterpreterFrame(name) ==
-  null name => throwKeyedMsg("S2IZ0018",NIL)
-  updateCurrentInterpreterFrame()
-  -- see if we already have one by that name
-  for f in $interpreterFrameRing repeat
-    name = frameName(f) => throwKeyedMsg("S2IZ0019",[name])
-  initHistList()
-  $interpreterFrameRing := CONS(emptyInterpreterFrame(name),
-    $interpreterFrameRing)
-  updateFromCurrentInterpreterFrame()
-  _$ERASE histFileName()
+)trace f
 \end{verbatim}
-<<defun addNewInterpreterFrame>>=
-(defun |addNewInterpreterFrame| (name)
- (seq
-  (cond
-   ((null name)
-    (|throwKeyedMsg| 'S2IZ0018 nil))  ; you must provide a name for new frame
-   (t
-     (|updateCurrentInterpreterFrame|)
-     (seq
-      (do ((tmp0 |$interpreterFrameRing| (cdr tmp0)) (f nil))
-          ((or (atom tmp0) 
-               (progn (setq f (car tmp0)) nil))
-             nil)
-       (seq
-        (exit
-         (when (boot-equal name (frameName f))
-          (exit 
-           (|throwKeyedMsg| 'S2IZ0019 ; existing frame with same name
-            (cons name nil)))))))
-      (|initHistList|)
-      (spadlet |$interpreterFrameRing|
-       (cons (|emptyInterpreterFrame| name) |$interpreterFrameRing|))
-      (|updateFromCurrentInterpreterFrame|)
-      ($erase (|histFileName|))))))) 
-
-@
-\subsection{defun closeInterpreterFrame}
+traces the function {\tt f}.
+To untrace {\tt f}, issue
 \begin{verbatim}
-closeInterpreterFrame(name) ==
-  -- if name = NIL then it means the current frame
-  null rest $interpreterFrameRing =>
-    name and (name ^= $interpreterFrameName) =>
-      throwKeyedMsg("S2IZ0020",[$interpreterFrameName])
-    throwKeyedMsg("S2IZ0021",NIL)
-  if null name then $interpreterFrameRing := rest $interpreterFrameRing
-  else   -- find the frame
-    found := nil
-    ifr := NIL
-    for f in $interpreterFrameRing repeat
-      found or (name ^= frameName(f)) => ifr := CONS(f,ifr)
-      found := true
-    not found => throwKeyedMsg("S2IZ0022",[name])
-    _$ERASE makeHistFileName(name)
-    $interpreterFrameRing := nreverse ifr
-  updateFromCurrentInterpreterFrame()
+)trace f )off
 \end{verbatim}
-<<defun closeInterpreterFrame>>=
-(defun |closeInterpreterFrame| (name)
- (prog (ifr found)
-  (return
-   (seq
-    (cond
-     ((null (cdr |$interpreterFrameRing|))
-       (cond
-        ((and name (nequal name |$interpreterFrameName|))
-          (|throwKeyedMsg| 'S2IZ0020 ; 1 frame left. not the correct name.
-            (cons |$interpreterFrameName| nil))) 
-        (t (|throwKeyedMsg| 'S2IZ0021 nil)))) ; only 1 frame left, not closed
-     (t
-       (cond
-        ((null name)
-          (spadlet |$interpreterFrameRing| (cdr |$interpreterFrameRing|)))
-        (t 
-          (spadlet found nil)
-          (spadlet ifr nil)
-          (do ((tmp0 |$interpreterFrameRing| (cdr tmp0)) (f nil))
-              ((or (atom tmp0) (progn (setq f (car tmp0)) nil)) nil)
-           (seq
-            (exit
-             (cond
-              ((or found (nequal name (frameName f)))
-                (spadlet ifr (cons f ifr)))
-              (t 
-                (spadlet found t))))))
-          (cond
-           ((null found) 
-              (|throwKeyedMsg| 'S2IZ0022 (cons name nil)))
-           (t
-              ($erase (|makeHistFileName| name))
-              (spadlet |$interpreterFrameRing| (nreverse ifr))))))
-       (|updateFromCurrentInterpreterFrame|))))))) 
-
-@
-\subsection{defun displayFrameNames}
+Note that if a function name contains a special character, it will
+be necessary to escape the character with an underscore
+%
 \begin{verbatim}
-displayFrameNames() ==
-  fs := "append"/[ ['%l,'"     ",:bright frameName f] for f in
-    $interpreterFrameRing]
-  sayKeyedMsg("S2IZ0024",[fs])
+)trace _/D_,1
 \end{verbatim}
-<<defun displayFrameNames>>=
-(defun |displayFrameNames| ()
- (prog (fs)
-  (return
-   (seq
-    (progn
-     (spadlet fs
-      (prog (tmp0)
-       (spadlet tmp0 NIL)
-       (return
-        (do ((tmp1 |$interpreterFrameRing| (cdr tmp1)) (f nil))
-            ((or (atom tmp1)
-                 (progn (setq f (car tmp1)) nil))
-               tmp0)
-         (seq
-          (exit
-           (setq tmp0
-            (append tmp0 (cons '|%l| 
-              (cons (makestring "     ") (|bright| (frameName f))))))))))))
-      (|sayKeyedMsg| 'S2IZ0024 (cons fs nil))))))) ; frame names are ...
-
-@
-\subsection{defun importFromFrame}
+%
+To trace all domains or packages that are or will be created from a particular
+constructor, give the constructor name or abbreviation after
+{\tt )trace}.
+%
 \begin{verbatim}
-importFromFrame args ==
-  -- args should have the form [frameName,:varNames]
-  if args and atom args then args := [args]
-  null args => throwKeyedMsg("S2IZ0073",NIL)
-  [fname,:args] := args
-  not member(fname,frameNames()) =>
-    throwKeyedMsg("S2IZ0074",[fname])
-  fname = frameName first $interpreterFrameRing =>
-    throwKeyedMsg("S2IZ0075",NIL)
-  fenv := frameEnvironment fname
-  null args =>
-    x := UPCASE queryUserKeyedMsg("S2IZ0076",[fname])
-    MEMQ(STRING2ID_-N(x,1),'(Y YES)) =>
-      vars := NIL
-      for [v,:props] in CAAR fenv repeat
-        v = "--macros" =>
-          for [m,:.] in props repeat vars := cons(m,vars)
-        vars := cons(v,vars)
-      importFromFrame [fname,:vars]
-    sayKeyedMsg("S2IZ0077",[fname])
-  for v in args repeat
-    plist := GETALIST(CAAR fenv,v)
-    plist =>
-      -- remove anything with the same name in the current frame
-      clearCmdParts ['propert,v]
-      for [prop,:val] in plist repeat
-        putHist(v,prop,val,$InteractiveFrame)
-    (m := get("--macros--",v,fenv)) =>
-      putHist("--macros--",v,m,$InteractiveFrame)
-    sayKeyedMsg("S2IZ0079",[v,fname])
-  sayKeyedMsg("S2IZ0078",[fname])
+)trace MATRIX
+)trace List Integer
 \end{verbatim}
-<<defun importFromFrame>>=
-(defun |importFromFrame| (args)
- (prog (temp1 fname fenv x v props vars plist prop val m)
-  (return
-   (seq
-    (progn
-     (when (and args (atom args))
-       (spadlet args (cons args nil))) 
-     (cond
-      ((null args)
-        (|throwKeyedMsg| 'S2IZ0073 nil)) ; missing frame name
-      (t
-        (spadlet temp1 args)
-        (spadlet fname (car temp1))
-        (spadlet args (cdr temp1))
-        (cond
-         ((null (|member| fname (|frameNames|)))
-           (|throwKeyedMsg| 'S2IZ0074 (cons fname nil))) ; not frame name
-         ((boot-equal fname (frameName (car |$interpreterFrameRing|)))
-           (|throwKeyedMsg| 'S2IZ0075 NIL)) ; cannot import from curr frame
-         (t
-           (spadlet fenv (|frameEnvironment| fname))
-           (cond
-            ((null args)
-              (spadlet x
-                (upcase (|queryUserKeyedMsg| 'S2IZ0076 (cons fname nil))))
-                                             ; import everything?
-              (cond
-               ((memq (string2id-n x 1) '(y yes))
-                 (spadlet vars nil)
-                 (do ((tmp0 (caar fenv) (cdr tmp0)) (tmp1 nil))
-                     ((or (atom tmp0) 
-                          (progn (setq tmp1 (car tmp0)) nil)
-                          (progn 
-                           (progn 
-                            (spadlet v (car tmp1))
-                            (spadlet props (cdr tmp1))
-                            tmp1)
-                           nil))
-                       nil)
-                  (seq
-                   (exit
-                    (cond
-                     ((boot-equal v '|--macros|)
-                       (do ((tmp2 props (cdr tmp2))
-                            (tmp3 nil))
-                           ((or (atom tmp2) 
-                                (progn (setq tmp3 (car tmp2)) nil)
-                                (progn 
-                                 (progn (spadlet m (car tmp3)) tmp3)
-                                 nil))
-                              nil)
-                        (seq
-                         (exit
-                          (spadlet vars (cons m vars))))))
-                     (t (spadlet vars (cons v vars)))))))
-                 (|importFromFrame| (cons fname vars)))
-               (t
-                 (|sayKeyedMsg| 'S2IZ0077 (cons fname nil)))))
-            (t
-             (do ((tmp4 args (cdr tmp4)) (v nil))
-                 ((or (atom tmp4) (progn (setq v (car tmp4)) nil)) nil)
-              (seq
-               (exit
-                (progn
-                 (spadlet plist (getalist (caar fenv) v))
-                 (cond
-                  (plist 
-                   (|clearCmdParts| (cons '|propert| (cons v nil)))
-                   (do ((tmp5 plist (cdr tmp5)) (tmp6 nil))
-                       ((or (atom tmp5)
-                            (progn (setq tmp6 (car tmp5)) nil)
-                            (progn 
-                             (progn 
-                              (spadlet prop (car tmp6))
-                              (spadlet val (cdr tmp6))
-                              tmp6)
-                             nil))
-                          nil)
-                    (seq
-                     (exit (|putHist| v prop val |$InteractiveFrame|)))))
-                  ((spadlet m (|get| '|--macros--| v fenv))
-                    (|putHist| '|--macros--| v m |$InteractiveFrame|))
-                  (t 
-                    (|sayKeyedMsg| 'S2IZ0079 ; frame not found
-                      (cons v (cons fname nil)))))))))
-             (|sayKeyedMsg| 'S2IZ0078 ; import complete
-               (cons fname nil))))))))))))) 
+%
+The first command traces all domains currently instantiated with
+{\tt Matrix}.
+If additional domains are instantiated with this constructor
+(for example, if you have used {\tt Matrix(Integer)} and
+{\tt Matrix(Float)}), they will be automatically traced.
+The second command traces {\tt List(Integer)}.
+It is possible to trace individual functions in a domain or
+package.
+See the {\tt )ops} option below.
+
+The following are the general options for the {\tt )trace}
+command.
 
-@
-\subsection{defun frame}
-\begin{verbatim}
--- the system command
+%!! system command parser doesn't treat general s-expressions correctly,
+%!! I recommand not documenting )after )before and )cond
+\begin{description}
+%\item[{\tt )after} {\it S-expression}]
+%causes the given Common Lisp {\it S-expression} to be
+%executed after exiting the traced function.
+
+%\item[{\tt )before} {\it S-expression}]
+%causes the given Common Lisp {\it S-expression} to be
+%executed before entering the traced function.
+
+\item[{\tt )break after}]
+causes a Common Lisp break loop to be entered after
+exiting the traced function.
+
+\item[{\tt )break before}]
+causes a Common Lisp break loop to be entered before
+entering the traced function.
+
+\item[{\tt )break}]
+is the same as {\tt )break before}.
+
+%\item[{\tt )cond} {\it S-expression}]
+%causes trace information to be shown only if the given
+%Common Lisp {\it S-expression} evaluates to non-NIL.  For
+%example, the following command causes the system function
+%{\tt resolveTT} to be traced but to have the information
+%displayed only if the value of the variable
+%{\tt \$reportBottomUpFlag} is non-NIL.
+%\begin{verbatim}
+%)trace resolveTT )cond \_\$reportBottomUpFlag}
+%\end{verbatim}
+
+\item[{\tt )count}]
+causes the system to keep a count of the number of times the
+traced function is entered.  The total can be displayed with
+{\tt )trace )stats} and cleared with {\tt )trace )stats reset}.
+
+\item[{\tt )count} {\it n}]
+causes information about the traced function to be displayed for
+the first {\it n} executions.  After the \it n-th execution, the
+function is untraced.
+
+\item[{\tt )depth} {\it n}]
+causes trace information to be shown for only {\it n} levels of
+recursion of the traced function.  The command
+\begin{verbatim}
+)trace fib )depth 10
+\end{verbatim}
+will cause the display of only 10 levels of trace information for
+the recursive execution of a user function {\bf fib}.
+
+\item[{\tt )math}]
+causes the function arguments and return value to be displayed in the
+Axiom monospace two-dimensional math format.
+
+\item[{\tt )nonquietly}]
+causes the display of additional messages when a function is
+traced.
+
+\item[{\tt )nt}]
+This suppresses all normal trace information.  This option is
+useful if the {\tt )count} or {\tt )timer} options are used and
+you are interested in the statistics but not the function calling
+information.
 
-frame l == frameSpad2Cmd l
-\end{verbatim}
-<<defun frame>>=
-(defun |frame| (l)
- (|frameSpad2Cmd| l)) 
+\item[{\tt )off}]
+causes untracing of all or specific functions.  Without an
+argument, all functions, constructors, domains and packages are
+untraced.  Otherwise, the given functions and other objects
+are untraced.  To
+immediately retrace the untraced functions, issue {\tt )trace
+)restore}.
+
+\item[{\tt )only} {\it listOfDataToDisplay}]
+causes only specific trace information to be shown.  The items are
+listed by using the following abbreviations:
+\begin{description}
+\item[a]        display all arguments
+\item[v]        display return value
+\item[1]        display first argument
+\item[2]        display second argument
+\item[15]       display the 15th argument, and so on
+\end{description}
+\end{description}
+\begin{description}
 
-@
-\subsection{defun frameSpad2Cmd}
-\begin{verbatim}
-frameSpad2Cmd args ==
-  frameArgs := '(drop import last names new next)
-  $options => throwKeyedMsg("S2IZ0016",['")frame"])
-  null(args) => helpSpad2Cmd ['frame]
-  arg  := selectOptionLC(first args,frameArgs,'optionError)
-  args := rest args
-  if args is [a] then args := a
-  if ATOM args then args := object2Identifier args
-  arg = 'drop  =>
-    args and PAIRP(args) => throwKeyedMsg("S2IZ0017",[args])
-    closeInterpreterFrame(args)
-  arg = 'import =>  importFromFrame args
-  arg = 'last  =>   previousInterpreterFrame()
-  arg = 'names =>   displayFrameNames()
-  arg = 'new   =>
-    args and PAIRP(args) => throwKeyedMsg("S2IZ0017",[args])
-    addNewInterpreterFrame(args)
-  arg = 'next  =>   nextInterpreterFrame()
+\item[{\tt )restore}]
+causes the last untraced functions to be retraced.  If additional
+options are present, they are added to those previously in effect.
+
+\item[{\tt )stats}]
+causes the display of statistics collected by the use of the
+{\tt )count} and {\tt )timer} options.
+
+\item[{\tt )stats reset}]
+resets to 0 the statistics collected by the use of the
+{\tt )count} and {\tt )timer} options.
+
+\item[{\tt )timer}]
+causes the system to keep a count of execution times for the
+traced function.  The total can be displayed with {\tt )trace
+)stats} and cleared with {\tt )trace )stats reset}.
+
+%!! only for lisp, boot, may not work in any case, recommend removing
+%\item[{\tt )varbreak}]
+%causes a Common Lisp break loop to be entered after
+%the assignment to any variable in the traced function.
+
+\item[{\tt )varbreak} {\it var1 \lanb{}... varN\ranb{}}]
+causes a Common Lisp break loop to be entered after
+the assignment to any of the listed variables in the traced
+function.
+
+\item[{\tt )vars}]
+causes the display of the value of any variable after it is
+assigned in the traced function.
+Note that library code must
+have been compiled
+using the {\tt )vartrace} option in order
+to support this option.
+
+\item[{\tt )vars} {\it var1 \lanb{}... varN\ranb{}}]
+causes the display of the value of any of the specified variables
+after they are assigned in the traced function.
+Note that library code must
+have been compiled
+using the {\tt )vartrace} option in order
+to support this option.
+
+\item[{\tt )within} {\it executingFunction}]
+causes the display of trace information only if the traced
+function is called when the given {\it executingFunction} is running.
+\end{description}
 
-  NIL
+The following are the options for tracing constructors, domains
+and packages.
+
+\begin{description}
+\item[{\tt )local} {\it \lanb{}op1 \lanb{}... opN\ranb{}\ranb{}}]
+causes local functions of the constructor to be traced.  Note that
+to untrace an individual local function, you must use the fully
+qualified internal name, using the escape character
+{\tt \_} before the semicolon.
+\begin{verbatim}
+)trace FRAC )local
+)trace FRAC_;cancelGcd )off
 \end{verbatim}
-<<defun frameSpad2Cmd>>=
-(defun |frameSpad2Cmd| (args)
- (prog (frameArgs arg a)
-  (return
-   (progn
-    (spadlet frameArgs '(|drop| |import| |last| |names| |new| |next|))
-    (cond
-     (|$options|
-      (|throwKeyedMsg| 'S2IZ0016 ; frame command does not take options
-       (cons (makestring ")frame") nil)))
-     ((null args) 
-       (|helpSpad2Cmd| (cons '|frame| nil)))
-     (t
-       (spadlet arg 
-         (|selectOptionLC| (car args) frameArgs '|optionError|))
-       (spadlet args (cdr args))
-       (cond
-        ((and (pairp args) 
-              (eq (qcdr args) nil)
-              (progn (spadlet a (qcar args)) t))
-          (spadlet args a)))
-       (when (atom args)
-          (spadlet args (|object2Identifier| args)))
-       (cond
-        ((boot-equal arg '|drop|)
-          (cond
-           ((and args (pairp args))
-             (|throwKeyedMsg| 'S2IZ0017 ; not a valid frame name
-               (cons args nil)))
-           (t (|closeInterpreterFrame| args))))
-        ((boot-equal arg '|import|)
-          (|importFromFrame| args))
-        ((boot-equal arg '|last|)
-          (|previousInterpreterFrame|))
-        ((boot-equal arg '|names|)
-          (|displayFrameNames|))
-        ((boot-equal arg '|new|)
-          (cond 
-           ((and args (pairp args))
-             (|throwKeyedMsg| 'S2IZ0017 ; not a valid frame name
-               (cons args nil)))
-           (t
-             (|addNewInterpreterFrame| args))))
-        ((boot-equal arg '|next|)
-          (|nextInterpreterFrame|))
-        (t nil)))))))) 
 
-@
-\section{Frame File Messages}
-<<Frame File Messages>>=
-S2IZ0016
- The %1b system command takes arguments but no options.
-S2IZ0017
- %1b is not a valid frame name
-S2IZ0018
- You must provide a name for the new frame.
-S2IZ0019
- You cannot use the name %1b for a new frame because an existing
- frame already has that name.
-S2IZ0020
- There is only one frame active and therefore that cannot be closed.
- Furthermore, the frame name you gave is not the name of the current frame.
- The current frame is called %1b .
-S2IZ0021
- The current frame is the only active one.  Issue %b )clear all %d to
- clear its contents.
-S2IZ0022
- There is no frame called %1b and so your command cannot be
- processed.
-S2IZ0024
- The names of the existing frames are: %1 %l
- The current frame is the first one listed.
-S2IZ0073
- %b )frame import %d must be followed by the frame name. The names
- of objects in that frame can then optionally follow the frame name.
- For example,
- %ceon %b )frame import calculus %d %ceoff
- imports all objects in the %b calculus %d frame, and
- %ceon %b )frame import calculus epsilon delta %d %ceoff
- imports the objects named %b epsilon %d and %b delta %d from the
- frame %b calculus %d .
- Please note that if the current frame contained any information
- about objects with these names, then that information would be
- cleared before the import took place.
-S2IZ0074
- You cannot import anything from the frame %1b because that is not
- the name of an existing frame.
-S2IZ0075
- You cannot import from the current frame (nor is there a need!).
-S2IZ0076
- User verification required:
- do you really want to import everything from the frame %1b ?
- If so, please enter %b y %d or %b yes %d :
-S2IZ0077
- On your request, AXIOM will not import everything from frame %1b.
-S2IZ0078
- Import from frame %1b is complete. Please issue %b )display all %d
- if you wish to see the contents of the current frame.
-S2IZ0079
- AXIOM cannot import %1b from frame %2b because it cannot be found.
-@
-\chapter{The Undo Mechanism}
-\section{)undo}
-\index{ugSysCmdundo}
+\item[{\tt )ops} {\it op1 \lanb{}... opN\ranb{}}]
+By default, all operations from a domain or package are traced
+when the domain or package is traced.  This option allows you to
+specify that only particular operations should be traced.  The
+command
+%
+\begin{verbatim}
+)trace Integer )ops min max _+ _-
+\end{verbatim}
+%
+traces four operations from the domain {\tt Integer}.  Since
+{\tt +} and {\tt -} are special
+characters, it is necessary
+to escape them with an underscore.
+\end{description}
 
-\index{undo}
+\par\noindent{\bf Also See:}
+\fnref{boot},
+\fnref{lisp}, and
+\fnref{ltrace}
 
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{undo}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
 \par\noindent{\bf User Level Required:} interpreter
 
@@ -4932,8 +6627,8 @@ created by the last {\tt )undo} command.
 This file consists of all user input lines, excluding those
 backtracked over due to a previous {\tt )undo}.
 
-\par\noindent{\bf Also See:}
-{\tt )history} \index{ugSysCmdhistory}.
+\par\noindent{\bf Also See:} \fnref{history}
+
 The command {\tt )history )write} will eliminate the ``undone'' command
 lines of your program.
 \section{Variables Used}
@@ -5689,219 +7384,127 @@ removeUndoLines u == --called by writeInputLines
 
 @
 
-\chapter{The Spad Server Mechanism}
-<<initvars>>=
-(defvar $openServerIfTrue t "t means try starting an open server")
-(defconstant $SpadServerName "/tmp/.d" "the name of the spad server socket")
-(defvar |$SpadServer| nil "t means Scratchpad acts as a remote server")
-
-@
-
-\pagehead{openserver}{openserver}
-This is a cover function for the C code used for communication interface.
-<<defun openserver>>=
-(defun openserver (name)
-  (open_server name))
-
-@
-
-\chapter{The Help Browser Mechanism}
-The Axiom book on the help browser is a complete rewrite of the 
-hyperdoc mechanism. There are several components that were needed
-to make this function. Most of the web browser components are
-described in bookvol11.pamphlet. This portion describes some of
-the design issues needed to support the interface.
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{what}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
-The axServer command takes a port (defaulting to 8085) and a
-program to handle the browser interaction (defaulting to multiServ).
-The axServer function opens the port, constructs the stream, and
-passes the stream to multiServ. The multiServ loop processes one
-interaction at a time.
-
-So the basic process is that the Axiom ``)browse'' command opens a
-socket and listens for http requests. Based on the type of request
-(either 'GET' or 'POST') and the content of the request, which is
-one of:
-\begin{itemize}
-\item command - algebra request/response
-\item lispcall - a lisp s-expression to be evaluated
-\item showcall - an Axiom )show command
-\end{itemize}
-the multiServ function will call a handler function to evaluate
-the command line and construct a response. GET requests result
-in a new browser page. POST requests result in an inline result.
+\par\noindent{\bf User Level Required:} interpreter
 
-Most responses contain the fields:
-\begin{itemize}
-\item stepnum - this is the Axiom step number 
-\item command - this is the original command from the browser
-\item algebra - this is the Axiom 2D algebra output
-\item mathml - this is the MathML version of the Axiom algebra
-\item type - this is the type of the Axiom result
-\end{itemize}
+\par\noindent{\bf Command Syntax:}
+\begin{list}{}
+\item{\tt )what categories} {\it pattern1} \lanb{}{\it pattern2 ...\ranb{}}
+\item{\tt )what commands  } {\it pattern1} \lanb{}{\it pattern2 ...\ranb{}}
+\item{\tt )what domains   } {\it pattern1} \lanb{}{\it pattern2 ...\ranb{}}
+\item{\tt )what operations} {\it pattern1} \lanb{}{\it pattern2 ...\ranb{}}
+\item{\tt )what packages  } {\it pattern1} \lanb{}{\it pattern2 ...\ranb{}}
+\item{\tt )what synonym   } {\it pattern1} \lanb{}{\it pattern2 ...\ranb{}}
+\item{\tt )what things    } {\it pattern1} \lanb{}{\it pattern2 ...\ranb{}}
+\item{\tt )apropos        } {\it pattern1} \lanb{}{\it pattern2 ...\ranb{}}
+\end{list}
 
-\section{Browsers, MathML, and Fonts}
-This work has the Firefox browser as its target. Firefox has built-in
-support for MathML, javascript, and XMLHttpRequest handling. More details
-are available in bookvol11.pamphlet but the very basic machinery for 
-communication with the browser involves a dance between the browser
-and the multiServ function (see the axserver.spad.pamphlet). 
+\par\noindent{\bf Command Description:}
 
-In particular, a simple request is embedded in a web page as:
+This command is used to display lists of things in the system.  The
+patterns are all strings and, if present, restrict the contents of the
+lists.  Only those items that contain one or more of the strings as
+substrings are displayed.  For example,
 \begin{verbatim}
-<ul>
- <li>
-  <input type="submit" id="p3" class="subbut" 
-    onclick="makeRequest('p3');"
-    value="sin(x)" />
-  <div id="ansp3"><div></div></div>
- </li>
-</ul>
+)what synonym
 \end{verbatim}
-which says that this is an html ``input'' field of type ``submit''.
-The CSS display class is ``subbut'' which is of a different color
-than the surrounding text to make it obvious that you can click on
-this field. Clickable fields that have no response text are of class
-``noresult''.
-
-The javascript call to ``makeRequest'' gives the ``id'' of this input
-field, which must be unique in the page, as an argument. In this case,
-the argument is 'p3'. The ``value'' field holds the display text which
-will be passed back to Axiom as a command.
-
-When the result arrives the ``showanswer'' function will select out
-the mathml field of the response, construct the ``id'' of the html
-div to hold the response by concatenating the string ``ans'' (answer)
-to the ``id'' of the request resulting, in this case, as ``ansp3''.
-The ``showanswer'' function will find this div and replace it with a
-div containing the mathml result.
-
-The ``makeRequest'' function is:
+displays all command synonyms,
 \begin{verbatim}
- function makeRequest(arg) {
-   http_request = new XMLHttpRequest();         
-   var command = commandline(arg);
-   //alert(command);
-   http_request.open('POST', '127.0.0.1:8085', true);
-   http_request.onreadystatechange = handleResponse;
-   http_request.setRequestHeader('Content-Type', 'text/plain');
-   http_request.send("command="+command);
-   return(false);
+)what synonym ver
 \end{verbatim}
-It contains a request to open a local server connection to Axiom,
-sets ``handleResponse'' as the function to call on reply, sets up
-the type of request, fills in the command field, and sends off the
-http request.
-
-When a response is received, the ``handleResponse'' function checks
-for the correct reply state, strips out the important text, and
-calls ``showanswer''.
+displays all command synonyms containing the substring ``{\tt ver}'',
 \begin{verbatim}
- function handleResponse() {
-  if (http_request.readyState == 4) {
-   if (http_request.status == 200) {
-    showanswer(http_request.responseText,'mathAns');
-   } else
-   {
-     alert('There was a problem with the request.'+ http_request.statusText);
-   }
-  }
- }
+)what synonym ver pr
 \end{verbatim}
-See bookvol11.pamphlet for further details.
-
-\section{The axServer/multiServ loop}
-The basic call to start an Axiom browser listener is:
+displays all command synonyms
+containing the substring  ``{\tt ver}'' or  the substring
+``{\tt pr}''.
+Output similar to the following will be displayed
 \begin{verbatim}
-  )set message autoload off
-  )set output mathml on
-  axServer(8085,multiServ)$AXSERV
-\end{verbatim}
+---------------- System Command Synonyms -----------------
 
-This call sets the port, opens a socket, attaches it to a stream,
-and then calls ``multiServ'' with that stream. The ``multiServ''
-function loops serving web responses to that port.
+user-defined synonyms satisfying patterns:
+      ver pr
 
-\section{The )browse command}
-In order to make the whole process cleaner the function ``)browse''
-handles the details. This code creates the command-line function for )browse
-
-The browse function does the internal equivalent of the following 3 command
-line statments:
-\begin{verbatim}
-  )set message autoload off
-  )set output mathml on
-  axServer(8085,multiServ)$AXSERV
+  )apr ........................... )what things
+  )apropos ....................... )what things
+  )prompt ........................ )set message prompt
+  )version ....................... )lisp *yearweek*
 \end{verbatim}
-which causes Axiom to start serving web pages on port 8085
 
-For those unfamiliar with calling algebra from lisp there are a 
-few points to mention. 
+Several other things can be listed with the {\tt )what} command:
 
-The loadLib needs to be called to load the algebra code into the image.
-Normally this is automatic but we are not using the interpreter so
-we need to do this ``by hand''.
-
-Each algebra file contains a "constructor function" which builds the
-domain, which is a vector, and then caches the vector so that every
-call to the contructor returns an EQ vector, that is, the same vector.
-In this case, we call the constructor $\vert$AxiomServer$\vert$
+\begin{description}
+\item[{\tt categories}] displays a list of category constructors.
+\index{what categories}
+\item[{\tt commands}]  displays a list of  system commands available  at your
+user-level.
+\index{what commands}
+Your user-level
+\index{user-level}
+is set via the  {\tt )set userlevel} command.
+\index{set userlevel}
+To get a description of a particular command, such as ``{\tt )what}'', issue
+{\tt )help what}.
+\item[{\tt domains}]   displays a list of domain constructors.
+\index{what domains}
+\item[{\tt operations}] displays a list of operations in  the system library.
+\index{what operations}
+It  is recommended that you  qualify this command with one or
+more patterns, as there are thousands of operations available.  For
+example, say you are looking for functions that involve computation of
+eigenvalues.  To find their names, try {\tt )what operations eig}.
+A rather large list of operations  is loaded into the workspace when
+this command  is first issued.  This  list will be deleted  when you
+clear the workspace  via {\tt )clear all} or {\tt )clear completely}.
+It will be re-created if it is needed again.
+\item[{\tt packages}]  displays a list of package constructors.
+\index{what packages}
+\item[{\tt synonym}]  lists system command synonyms.
+\index{what synonym}
+\item[{\tt things}]    displays all  of the  above types for  items containing
+\index{what things}
+the pattern strings as  substrings.
+The command synonym  {\tt )apropos} is equivalent to
+\index{apropos}
+{\tt )what things}.
+\end{description}
 
-The axServer function was mangled internally to 
-$\vert$AXSERV;axServer;IMV;2$\vert$.
-The multiServ function was mangled to $\vert$AXSERV;multiServ;SeV;3$\vert$
-Note well that if you change axserver.spad these names might change
-which will generate the error message along the lines of:
-\begin{verbatim}
-    System error:
-    The function $\vert$AXSERV;axServer;IMV;2$\vert$ is undefined.
-\end{verbatim}
+\par\noindent{\bf Also See:}
+\fnref{display},
+\fnref{set}, and
+\fnref{show}
 
-To fix this you need to look at int/algebra/AXSERV.nrlib/code.lsp
-and find the new mangled function name. A better solution would
-be to dynamically look up the surface names in the domain vector.
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{with}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
-Each Axiom function expects the domain vector as the last argument.
-This is not obvious from the call as the interpreter supplies it.
-We must do that ``by hand''.
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{workfiles}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
-We don't call the multiServ function. We pass it as a parameter to
-the axServer function. When it does get called by the SPADCALL
-macro it needs to be a lisp pair whose car is the function and
-whose cdr is the domain vector. We construct that pair here as
-the second argument to axServer. The third, hidden, argument to
-axServer is the domain vector which we supply ``by hand''.
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{zsystemdevelopment}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
-The socket can be supplied on the command line but defaults to 8085.
-Axiom supplies the arguments as a list.
-<<defun browse>>=
-(defun |browse| (socket)
- (let (axserv browser)
-  (if socket 
-    (setq socket (car socket))
-    (setq socket 8085))
-  (|set| '(|mes| |auto| |off|))
-  (|set| '(|out| |mathml| |on|))
-  (|loadLib| '|AxiomServer|)
-  (setq axserv (|AxiomServer|))
-  (setq browser 
-   (|AXSERV;axServer;IMV;2| socket
-    (cons #'|AXSERV;multiServ;SeV;3| axserv) axserv))))
+\chapter{The Spad Server Mechanism}
+<<initvars>>=
+(defvar $openServerIfTrue t "t means try starting an open server")
+(defconstant $SpadServerName "/tmp/.d" "the name of the spad server socket")
+(defvar |$SpadServer| nil "t means Scratchpad acts as a remote server")
 
 @
-Now we have to bolt it into Axiom. This involves two lookups.
 
-We create the lisp pair 
-\begin{verbatim}
-(|browse| . |development|)
-\end{verbatim} 
-and cons it into the \$systemCommands command table.  This allows the
-command to be executed in development mode.  This lookup decides if
-this command is allowed. It also has the side-effect of putting the
-command into the \$SYSCOMMANDS variable which is used to determine
-if the token is a command.
+\pagehead{openserver}{openserver}
+This is a cover function for the C code used for communication interface.
+<<defun openserver>>=
+(defun openserver (name)
+  (open_server name))
 
-\section{The server support code}
+@
 
 \chapter{Axiom Build-time Functions}
 \subsection{defun spad-save}
diff --git a/changelog b/changelog
index 4f70b09..d1d652d 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,6 @@
+20090302 tpd src/axiom-website/patches.html 20090302.01.tpd.patch
+20090302 tpd books/bookvol5 add user command documentation
+20090302 tpd books/bookvol0 fix typo
 20090228 tpd src/axiom-website/patches.html 20090228.01.tpd.patch
 20090228 tpd lsp/Makefile add patch for read-char-no-hang
 20090228 tpd zips/gcl-2.6.8pre3.o.read.d.patch fix read-char-no-hang hang
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index f2372ac..c71f4fc 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -979,5 +979,7 @@ bookvol5 remove duplicate function<br/>
 bookvol4 Hyperdoc tutorial on making new pages<br/>
 <a href="patches/20090228.01.tpd.patch">20090228.01.tpd.patch</a>
 gcl-2.6.8pre3.o.read.d.patch fix read-char-no-hang<br/>
+<a href="patches/20090302.01.tpd.patch">20090302.01.tpd.patch</a>
+bookvol5 add user command documentation<br/>
  </body>
 </html>



From MAILER-DAEMON Tue Mar 03 19:26:39 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LeewZ-0000tH-Ez
	for mharc-axiom-developer@gnu.org; Tue, 03 Mar 2009 19:26:39 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LeewX-0000sz-CK
	for axiom-developer@nongnu.org; Tue, 03 Mar 2009 19:26:37 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LeewS-0000rl-Pf
	for axiom-developer@nongnu.org; Tue, 03 Mar 2009 19:26:36 -0500
Received: from [199.232.76.173] (port=55442 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LeewS-0000ri-HP
	for axiom-developer@nongnu.org; Tue, 03 Mar 2009 19:26:32 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:34363
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LeewP-0005co-Rx
	for axiom-developer@nongnu.org; Tue, 03 Mar 2009 19:26:32 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n240QSug027794;
	Tue, 3 Mar 2009 18:26:28 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n240QSCA027790;
	Tue, 3 Mar 2009 18:26:28 -0600
Date: Tue, 3 Mar 2009 18:26:28 -0600
Message-Id: <200903040026.n240QSCA027790@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090302.02.mxr.patch (bookvol10.4
	ApplicationProgrammingInterface)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Wed, 04 Mar 2009 00:26:37 -0000

A new package, ApplicationProgrammingInterface (API) was added to the system
with a single function called getDomains. This new package will be the
cover for exporting Axiom internal functions to the algebra level.

The getDomains function was originally proposed by Martin Rubey.
This is a slightly different implementation to keep the compiler happy.

Help documentation and a regression test were written and added.


Additionally, some Nag domains were documented.
No code was changed for the Nag routines.

Tim
======================================================================
diff --git a/books/bookvol10.4.pamphlet b/books/bookvol10.4.pamphlet
index a72d13e..e26e653 100644
--- a/books/bookvol10.4.pamphlet
+++ b/books/bookvol10.4.pamphlet
@@ -3641,6 +3641,120 @@ AnyFunctions1(S:Type): with
 
 @
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\section{package API ApplicationProgramInterface}
+<<ApplicationProgramInterface.input>>=
+)sys rm -f ApplicationProgramInterface.output
+)spool ApplicationProgramInterface.output
+)set message test on
+)set message auto off
+)clear all
+--S 1 of 3
+getDomains 'Collection
+--R
+--R   (1)
+--R   {AssociationList, Bits, CharacterClass, DataList, EqTable, FlexibleArray,
+--R    GeneralPolynomialSet, GeneralSparseTable, GeneralTriangularSet, HashTable,
+--R    IndexedBits, IndexedFlexibleArray, IndexedList, IndexedOneDimensionalArray,
+--R    IndexedString, IndexedVector, InnerTable, KeyedAccessFile, Library, List,
+--R    ListMultiDictionary, Multiset, OneDimensionalArray, Point, PrimitiveArray,
+--R    RegularChain, RegularTriangularSet, Result, RoutinesTable, Set,
+--R    SparseTable, SquareFreeRegularTriangularSet, Stream, String, StringTable,
+--R    Table, Vector, WuWenTsunTriangularSet}
+--R                                                             Type: Set Symbol
+--E 1
+
+--S 2 of 3
+difference(getDomains 'IndexedAggregate,getDomains 'Collection)
+--R
+--R   (2)
+--R   {DirectProduct, DirectProductMatrixModule, DirectProductModule,
+--R    HomogeneousDirectProduct, OrderedDirectProduct,
+--R    SplitHomogeneousDirectProduct}
+--R                                                             Type: Set Symbol
+--E 2
+
+--S 3 of 3
+)show ApplicationProgramInterface
+--R ApplicationProgramInterface  is a package constructor
+--R Abbreviation for ApplicationProgramInterface is API 
+--R This constructor is exposed in this frame.
+--R Issue )edit bookvol10.4.pamphlet to see algebra source code for API 
+--R
+--R------------------------------- Operations --------------------------------
+--R getDomains : Symbol -> Set Symbol    
+--R
+--E 3
+)spool
+)lisp (bye)
+@
+<<ApplicationProgramInterface.help>>=
+====================================================================
+ApplicationProgramInterface examples
+====================================================================
+
+The ApplicationProgramInterface exposes Axiom internal functions
+which might be useful for understanding, debugging, or creating
+tools.
+
+The getDomains function takes the name of a category and returns
+a set of domains which inherit from that category:
+
+  getDomains 'Collection
+
+   {AssociationList, Bits, CharacterClass, DataList, EqTable, FlexibleArray,
+    GeneralPolynomialSet, GeneralSparseTable, GeneralTriangularSet, HashTable,
+    IndexedBits, IndexedFlexibleArray, IndexedList, IndexedOneDimensionalArray,
+    IndexedString, IndexedVector, InnerTable, KeyedAccessFile, Library, List,
+    ListMultiDictionary, Multiset, OneDimensionalArray, Point, PrimitiveArray,
+    RegularChain, RegularTriangularSet, Result, RoutinesTable, Set,
+    SparseTable, SquareFreeRegularTriangularSet, Stream, String, StringTable,
+    Table, Vector, WuWenTsunTriangularSet}
+                                                             Type: Set Symbol
+
+This can be used to form the set-difference of two categories:
+
+  difference(getDomains 'IndexedAggregate, getDomains 'Collection)
+
+   {DirectProduct, DirectProductMatrixModule, DirectProductModule,
+    HomogeneousDirectProduct, OrderedDirectProduct,
+    SplitHomogeneousDirectProduct}
+                                                             Type: Set Symbol
+
+@
+\pagehead{ApplicationProgramInterface}{API}
+\pagepic{ps/v104applicationprograminterface.ps}{API}{1.00}
+
+{\bf Exports:}\\
+\begin{tabular}{ll}
+\end{tabular}
+
+<<package API ApplicationProgramInterface>>=
+)abbrev package API ApplicationProgramInterface
+++ Author: Timothy Daly, Martin Rubey
+++ Date Created: 3 March 2009
+++ Date Last Updated: 3 March 2009
+++ Description: This package contains useful functions that 
+++ expose Axiom system internals
+ApplicationProgramInterface(): Exports == Implementation where
+  Exports ==> with
+    getDomains : Symbol -> Set Symbol
+      ++ getDomains takes a category and returns the list of domains
+      ++ that have that category
+      ++
+      ++X getDomains 'IndexedAggregate
+  Implementation ==> add
+    getDomains(cat:Symbol):Set(Symbol) == 
+      set [symbol car first destruct a _
+        for a in (destruct domainsOf(cat,NIL$Lisp)$Lisp)::List(SExpression)]
+
+@
+<<API.dotabb>>=
+"API" [color="#FF4488",href="bookvol10.4.pdf#nameddest=APPRULE"]
+"ORDSET" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ORDSET"]
+"API" -> "ORDSET"
+
+@
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \section{package APPRULE ApplyRules}
 \pagehead{ApplyRules}{APPRULE}
 \pagepic{ps/v104applyrules.ps}{APPRULE}{1.00}
@@ -63433,6 +63547,685 @@ NagPartialDifferentialEquationsPackage(): Exports == Implementation where
 @
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \section{package NAGC02 NagPolynomialRootsPackage}
+<<NagPolynomialRootsPackage.help>>=
+
+     C02(3NAG)         Foundation Library (12/10/92)         C02(3NAG)
+
+          C02 -- Zeros of Polynomials                   Introduction -- C02
+                                    Chapter C02
+                               Zeros of Polynomials
+
+          1. Scope of the Chapter
+
+          This chapter is concerned with computing the zeros of a
+          polynomial with real or complex coefficients.
+
+          2. Background to the Problems
+
+          Let f(z) be a polynomial of degree n with complex coefficients
+          a :
+           i
+
+                            n    n-1    n-2
+                   f(z)==a z +a z   +a z   +...+a   z+a ,  a /=0.
+                          0    1      2          n-1   n    0
+
+          A complex number z  is called a zero of f(z) (or equivalently a
+                            1
+          root of the equation f(z)=0), if:
+
+                                      f(z )=0.
+                                         1
+
+          If z  is a zero, then f(z) can be divided by a factor (z-z ):
+              1                                                     1
+
+                                f(z)=(z-z )f (z)                        (1)
+                                         1  1
+
+          where f (z) is a polynomial of degree n-1. By the Fundamental
+                 1
+          Theorem of Algebra, a polynomial f(z) always has a zero, and so
+          the process of dividing out factors (z-z ) can be continued until
+                                                  i
+          we have a complete factorization of f(z)
+
+                           f(z)==a (z-z )(z-z )...(z-z ).
+                                  0    1     2        n
+
+          Here the complex numbers z ,z ,...,z  are the zeros of f(z); they
+                                    1  2      n
+          may not all be distinct, so it is sometimes more convenient to
+          write:
+
+                                   m       m          m
+                                    1       2          k
+                     f(z)==a (z-z )  (z-z )  ...(z-z )  ,  k<=n,
+                            0    1       2          k
+
+          with distinct zeros z ,z ,...,z  and multiplicities m >=1. If
+                               1  2      k                     i
+          m =1, z  is called a single zero, if m >1, z  is called a
+           i     i                              i     i
+          multiple or repeated zero; a multiple zero is also a zero of the
+          derivative of f(z).
+
+          If the coefficients of f(z) are all real, then the zeros of f(z)
+          are either real or else occur as pairs of conjugate complex
+          numbers x+iy and x-iy. A pair of complex conjugate zeros are the
+                                                 2
+          zeros of a quadratic factor of f(z), (z +rz+s), with real
+          coefficients r and s.
+
+          Mathematicians are accustomed to thinking of polynomials as
+          pleasantly simple functions to work with. However the problem of
+          numerically computing the zeros of an arbitrary polynomial is far
+          from simple. A great variety of algorithms have been proposed, of
+          which a number have been widely used in practice; for a fairly
+          comprehensive survey, see Householder [1]. All general algorithms
+          are iterative. Most converge to one zero at a time; the
+          corresponding factor can then be divided out as in equation (1)
+          above - this process is called deflation or, loosely, dividing
+          out the zero - and the algorithm can be applied again to the
+          polynomial f (z). A pair of complex conjugate zeros can be
+                      1
+          divided out together - this corresponds to dividing f(z) by a
+          quadratic factor.
+
+          Whatever the theoretical basis of the algorithm, a number of
+          practical problems arise: for a thorough discussion of some of
+          them see Peters and Wilkinson [2] and Wilkinson [3]. The most
+          elementary point is that, even if z  is mathematically an exact
+                                             1
+          zero of f(z), because of the fundamental limitations of computer
+          arithmetic the computed value of f(z ) will not necessarily be
+                                              1
+          exactly 0.0. In practice there is usually a small region of
+          values of z about the exact zero at which the computed value of
+          f(z) becomes swamped by rounding errors. Moreover in many
+          algorithms this inaccuracy in the computed value of f(z) results
+          in a similar inaccuracy in the computed step from one iterate to
+          the next. This limits the precision with which any zero can be
+          computed. Deflation is another potential cause of trouble, since,
+          in the notation of equation (1), the computed coefficients of
+          f (z) will not be completely accurate, especially if z  is not an
+           1                                                    1
+          exact zero of f(z); so the zeros of the computed f (z) will
+                                                            1
+          deviate from the zeros of f(z).
+
+          A zero is called ill-conditioned if it is sensitive to small
+          changes in the coefficients of the polynomial. An ill-conditioned
+          zero is likewise sensitive to the computational inaccuracies just
+          mentioned. Conversely a zero is called well-conditioned if it is
+          comparatively insensitive to such perturbations. Roughly speaking
+          a zero which is well separated from other zeros is well-
+          conditioned, while zeros which are close together are ill-
+          conditioned, but in talking about 'closeness' the decisive factor
+          is not the absolute distance between neighbouring zeros but their
+          ratio: if the ratio is close to 1 the zeros are ill-conditioned.
+          In particular, multiple zeros are ill-conditioned. A multiple
+          zero is usually split into a cluster of zeros by perturbations in
+          the polynomial or computational inaccuracies.
+
+          2.1. References
+
+          [1]   Householder A S (1970) The Numerical Treatment of a Single
+                Nonlinear Equation. McGraw-Hill.
+
+          [2]   Peters G and Wilkinson J H (1971) Practical Problems Arising
+                in the Solution of Polynomial Equations. J. Inst. Maths
+                Applics. 8 16--35.
+
+          [3]   Wilkinson J H (1963) Rounding Errors in Algebraic Processes,
+                Chapter 2. HMSO.
+
+          3. Recommendations on Choice and Use of Routines
+
+          3.1. Discussion
+
+          Two routines are available: C02AFF for polynomials with complex
+          coefficients and C02AGF for polynomials with real coefficients.
+
+          C02AFF and C02AGF both use a variant of Laguerre's Method due to
+          BT Smith to calculate each zero until the degree of the deflated
+          polynomial is less than 3, whereupon the remaining zeros are
+          obtained using the 'standard' closed formulae for a quadratic or
+          linear equation.
+
+          The accuracy of the roots will depend on how ill-conditioned they
+          are. Peters and Wilkinson [2] describe techniques for estimating
+          the errors in the zeros after they have been computed.
+
+          3.2. Index
+
+           Zeros of a complex polynomial                             C02AFF
+           Zeros of a real polynomial                                C02AGF
+
+
+          C02 -- Zeros of Polynomials                       Contents -- C02
+          Chapter C02
+
+          Zeros of Polynomials
+
+          C02AFF  All zeros of complex polynomial, modified Laguerre method
+
+          C02AGF  All zeros of real polynomial, modified Laguerre method
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+     C02AFF(3NAG)      Foundation Library (12/10/92)      C02AFF(3NAG)
+
+          C02 -- Zeros of Polynomials                                C02AFF
+                  C02AFF -- NAG Foundation Library Routine Document
+
+          Note: Before using this routine, please read the Users' Note for
+          your implementation to check implementation-dependent details.
+          The symbol (*) after a NAG routine name denotes a routine that is
+          not included in the Foundation Library.
+
+          1. Purpose
+
+          C02AFF finds all the roots of a complex polynomial equation,
+          using a variant of Laguerre's Method.
+
+          2. Specification
+
+                 SUBROUTINE C02AFF (A, N, SCALE, Z, W, IFAIL)
+                 INTEGER          N, IFAIL
+                 DOUBLE PRECISION A(2,N+1), Z(2,N), W(4*(N+1))
+                 LOGICAL          SCALE
+
+          3. Description
+
+          The routine attempts to find all the roots of the nth degree
+          complex polynomial equation
+
+                               n    n-1    n-2
+                       P(z)=a z +a z   +a z   +...+a   z+a =0.
+                             0    1      2          n-1   n
+
+          The roots are located using a modified form of Laguerre's Method,
+          originally proposed by Smith [2].
+
+          The method of Laguerre [3] can be described by the iterative
+          scheme
+
+                                             -n*P(z )
+                                                   k
+                          L(z )=z   -z = ----------------,
+                             k   k+1  k             
+                                         P'(z )+-  /H(z )
+                                             k   \/    k
+
+                                           2
+          where H(z )=(n-1)*[(n-1)*(P'(z )) -n*P(z )P''(z )], and z  is
+                   k                    k         k      k         0
+          specified.
+
+          The sign in the denominator is chosen so that the modulus of the
+          Laguerre step at z , viz. |L(z )|, is as small as possible. The
+                            k           k
+          method can be shown to be cubically convergent for isolated roots
+          (real or complex) and linearly convergent for multiple roots.
+          The routine generates a sequence of iterates z , z , z ,..., such
+                                                        1   2   3
+          that |P(z   )|<|P(z )| and ensures that z   +L(z   ) 'roughly'
+                   k+1       k                     k+1    k+1
+          lies inside a circular region of radius |F| about z  known to
+                                                             k
+          contain a zero of P(z); that is, |L(z   )|<=|F|, where F denotes
+                                               k+1
+          the Fejer bound (see Marden [1]) at the point z . Following Smith
+                                                         k
+          [2], F is taken to be min(B,1.445*n*R), where B is an upper bound
+          for the magnitude of the smallest zero given by
+
+                                                         1/n
+                      B=1.0001*min(\/n*L(z ),|r |,|a /a |   ),
+                                          k    1    n  0
+
+          r  is the zero X of smaller magnitude of the quadratic equation
+           1
+
+                                           2
+                    2(P''(z )/(2*n*(n-1)))X +2(P'(z )/n)X+P(z )=0
+                           k                       k         k
+
+          and the Cauchy lower bound R for the smallest zero is computed
+          (using Newton's Method) as the positive root of the polynomial
+          equation
+
+                         n      n-1      n-2
+                    |a |z +|a |z   +|a |z   +...+|a   |z-|a |=0.
+                      0      1        2            n-1     n
+
+          Starting from the origin, successive iterates are generated
+          according to the rule z   =z +L(z ) for k = 1,2,3,... and L(z )
+                                 k+1  k    k                           k
+          is 'adjusted' so that |P(z   )|<|P(z )| and |L(z   )|<=|F|. The
+                                    k+1       k           k+1
+          iterative procedure terminates if P(z   ) is smaller in absolute
+                                               k+1
+          value than the bound on the rounding error in P(z   ) and the
+                                                           k+1
+          current iterate z =z    is taken to be a zero of P(z). The
+                           p  k+1
+                              ~
+          deflated polynomial P(z)=P(z)/(z-z ) of degree n-1 is then
+                                            p
+          formed, and the above procedure is repeated on the deflated
+          polynomial until n<3, whereupon the remaining roots are obtained
+          via the 'standard' closed formulae for a linear (n = 1) or
+          quadratic (n = 2) equation.
+
+          To obtain the roots of a quadratic polynomial, C02AHF(*) can be
+          used.
+
+          4. References
+
+          [1]   Marden M (1966) Geometry of Polynomials. Mathematical
+                Surveys. 3 Am. Math. Soc., Providence, RI.
+
+          [2]   Smith B T (1967) ZERPOL: A Zero Finding Algorithm for
+                Polynomials Using Laguerre's Method. Technical Report.
+                Department of Computer Science, University of Toronto,
+                Canada.
+
+          [3]   Wilkinson J H (1965) The Algebraic Eigenvalue Problem.
+                Clarendon Press.
+
+          5. Parameters
+
+           1:  A(2,N+1) -- DOUBLE PRECISION array                     Input
+               On entry: if A is declared with bounds (2,0:N), then A(1,i)
+               and A(2,i) must contain the real and imaginary parts of a
+                                                                        i
+                                          n-i
+               (i.e., the coefficient of z   ), for i=0,1,...,n.
+               Constraint: A(1,0) /= 0.0 or A(2,0) /= 0.0.
+
+           2:  N -- INTEGER                                           Input
+               On entry: the degree of the polynomial, n. Constraint: N >=
+               1.
+
+           3:  SCALE -- LOGICAL                                       Input
+               On entry: indicates whether or not the polynomial is to be
+               scaled. See Section 8 for advice on when it may be
+               preferable to set SCALE = .FALSE. and for a description of
+               the scaling strategy. Suggested value: SCALE = .TRUE..
+
+           4:  Z(2,N) -- DOUBLE PRECISION array                      Output
+               On exit: the real and imaginary parts of the roots are
+               stored in Z(1,i) and Z(2,i) respectively, for i=1,2,...,n.
+
+           5:  W(4*(N+1)) -- DOUBLE PRECISION array               Workspace
+
+           6:  IFAIL -- INTEGER                                Input/Output
+               On entry: IFAIL must be set to 0, -1 or 1. For users not
+               familiar with this parameter (described in the Essential
+               Introduction) the recommended value is 0.
+
+               On exit: IFAIL = 0 unless the routine detects an error (see
+               Section 6).
+
+          6. Error Indicators and Warnings
+
+          Errors detected by the routine:
+
+          If on entry IFAIL = 0 or -1, explanatory error messages are
+          output on the current error message unit (as defined by X04AAF).
+
+          IFAIL= 1
+               On entry A(1,0) = 0.0 and A(2,0) = 0.0,
+
+               or       N < 1.
+
+          IFAIL= 2
+               The iterative procedure has failed to converge. This error
+               is very unlikely to occur. If it does, please contact NAG
+               immediately, as some basic assumption for the arithmetic has
+               been violated. See also Section 8.
+
+          IFAIL= 3
+               Either overflow or underflow prevents the evaluation of P(z)
+               near some of its zeros. This error is very unlikely to
+               occur. If it does, please contact NAG immediately. See also
+               Section 8.
+
+          7. Accuracy
+
+          All roots are evaluated as accurately as possible, but because of
+          the inherent nature of the problem complete accuracy cannot be
+          guaranteed.
+
+          8. Further Comments
+
+          If SCALE = .TRUE., then a scaling factor for the coefficients is
+          chosen as a power of the base B of the machine so that the
+                                                                EMAX-P
+          largest coefficient in magnitude approaches THRESH = B      .
+          Users should note that no scaling is performed if the largest
+          coefficient in magnitude exceeds THRESH, even if SCALE = .TRUE..
+          (For definition of B, EMAX and P see the Chapter Introduction
+          X02.)
+
+          However, with SCALE = .TRUE., overflow may be encountered when
+          the input coefficients a ,a ,a ,...,a  vary widely in magnitude,
+                                  0  1  2      n
+                                                    (4*P)
+          particularly on those machines for which B      overflows. In
+          such cases, SCALE should be set to .FALSE. and the coefficients
+          scaled so that the largest coefficient in magnitude does not
+                  (EMAX-2*P)
+          exceed B          .
+
+          Even so, the scaling strategy used in C02AFF is sometimes
+          insufficient to avoid overflow and/or underflow conditions. In
+          such cases, the user is recommended to scale the independent
+          variable (z) so that the disparity between the largest and
+          smallest coefficient in magnitude is reduced. That is, use the
+          routine to locate the zeros of the polynomial d*P(cz) for some
+          suitable values of c and d. For example, if the original
+                               -100   100 20                   -10
+          polynomial was P(z)=2    i+2   z  , then choosing c=2    and
+             100                                                     20
+          d=2   , for instance, would yield the scaled polynomial i+z  ,
+          which is well-behaved relative to overflow and underflow and has
+                           10
+          zeros which are 2   times those of P(z).
+
+          If the routine fails with IFAIL = 2 or 3, then the real and
+          imaginary parts of any roots obtained before the failure occurred
+          are stored in Z in the reverse order in which they were found.
+          Let n  denote the number of roots found before the failure
+               R
+          occurred. Then Z(1,n) and Z(2,n) contain the real and imaginary
+          parts of the 1st root found, Z(1,n-1) and Z(2,n-1) contain the
+          real and imaginary parts of the 2nd root found, ..., Z(1,n ) and
+                                                                    R
+          Z(2,n ) contain the real and imaginary parts of the n th root
+               R                                               R
+          found. After the failure has occurred, the remaining 2*(n-n )
+                                                                     R
+          elements of Z contain a large negative number (equal to
+                         
+
+          -1/(X02AMF().\/2)).
+
+          9. Example
+
+                                                 5    4    3    2
+          To find the roots of the polynomial a z +a z +a z +a z +a z+a =0,
+                                               0    1    2    3    4   5
+          where a =(5.0+6.0i), a =(30.0+20.0i), a =-(0.2+6.0i),
+                 0              1                2
+          a =(50.0+100000.0i), a =-(2.0-40.0i) and a =(10.0+1.0i).
+           3                    4                   5
+
+          The example program is not reproduced here. The source code for
+          all example programs is distributed with the NAG Foundation
+          Library software and should be available on-line.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+     C02AGF(3NAG)      Foundation Library (12/10/92)      C02AGF(3NAG)
+
+          C02 -- Zeros of Polynomials                                C02AGF
+                  C02AGF -- NAG Foundation Library Routine Document
+
+          Note: Before using this routine, please read the Users' Note for
+          your implementation to check implementation-dependent details.
+          The symbol (*) after a NAG routine name denotes a routine that is
+          not included in the Foundation Library.
+
+          1. Purpose
+
+          C02AGF finds all the roots of a real polynomial equation, using a
+          variant of Laguerre's Method.
+
+          2. Specification
+
+                 SUBROUTINE C02AGF (A, N, SCALE, Z, W, IFAIL)
+                 INTEGER          N, IFAIL
+                 DOUBLE PRECISION A(N+1), Z(2,N), W(2*(N+1))
+                 LOGICAL          SCALE
+
+          3. Description
+
+          The routine attempts to find all the roots of the nth degree real
+          polynomial equation
+
+                               n    n-1    n-2
+                       P(z)=a z +a z   +a z   +...+a   z+a =0.
+                             0    1      2          n-1   n
+
+          The roots are located using a modified form of Laguerre's Method,
+          originally proposed by Smith [2].
+
+          The method of Laguerre [3] can be described by the iterative
+          scheme
+
+                                             -n*P(z )
+                                                   k
+                          L(z )=z   -z = ----------------,
+                             k   k+1  k             
+                                         P'(z )+-  /H(z )
+                                             k   \/    k
+
+                                           2
+          where H(z )=(n-1)*[(n-1)*(P'(z )) -n*P(z )P''(z )], and z  is
+                   k                    k         k      k         0
+          specified.
+
+          The sign in the denominator is chosen so that the modulus of the
+          Laguerre step at z , viz. |L(z )|, is as small as possible. The
+                            k           k
+          method can be shown to be cubically convergent for isolated roots
+          (real or complex) and linearly convergent for multiple roots.
+          The routine generates a sequence of iterates z , z , z ,..., such
+                                                        1   2   3
+          that |P(z +1)|<|P(z )| and ensures that z   +L(z   ) 'roughly'
+                   k         k                     k+1    k+1
+          lies inside a circular region of radius |F| about z  known to
+                                                             k
+          contain a zero of P(z); that is, |L(z   )|<=|F|, where F denotes
+                                               k+1
+          the Fejer bound (see Marden [1]) at the point z . Following Smith
+                                                         k
+          [2], F is taken to be min(B,1.445*n*R), where B is an upper bound
+          for the magnitude of the smallest zero given by
+
+                                                         1/n
+                      B=1.0001*min(\/n*L(z ),|r |,|a /a |   ),
+                                          k    1    n  0
+
+          r  is the zero X of smaller magnitude of the quadratic equation
+           1
+
+                                           2
+                    2(P''(z )/(2*n*(n-1)))X +2(P'(z )/n)X+P(z )=0
+                           k                       k         k
+
+          and the Cauchy lower bound R for the smallest zero is computed
+          (using Newton's Method) as the positive root of the polynomial
+          equation
+
+                         n      n-1      n-2
+                    |a |z +|a |z   +|a |z   +...+|a   |z-|a |=0.
+                      0      1        2            n-1     n
+
+          Starting from the origin, successive iterates are generated
+          according to the rule z   =z +L(z ) for k=1,2,3,... and L(z ) is
+                                 k+1  k    k                         k
+                                 k+1       k           k+1
+          iterative procedure terminates if P(z   ) is smaller in absolute
+                                               k+1
+          value than the bound on the rounding error in P(z   ) and the
+                                                           k+1
+          current iterate z =z    is taken to be a zero of P(z) (as is its
+                           p  k-1
+                    
+
+          conjugate z  if z  is complex). The deflated polynomial
+                     p     p
+          ~
+          P(z)=P(z)/(z-z ) of degree n-1 if z  is real
+                        p                    p
+           ~                   
+          (P(z)=P(z)/((z-z )(z-z )) of degree n-2 if z  is complex) is then
+                          p     p                     p
+          formed, and the above procedure is repeated on the deflated
+          polynomial until n<3, whereupon the remaining roots are obtained
+          via the 'standard' closed formulae for a linear (n = 1) or
+          quadratic (n = 2) equation.
+
+          To obtain the roots of a quadratic polynomial, C02AJF(*) can be
+          used.
+
+          4. References
+
+          [1]   Marden M (1966) Geometry of Polynomials. Mathematical
+                Surveys. 3 Am. Math. Soc., Providence, RI.
+
+          [2]   Smith B T (1967) ZERPOL: A Zero Finding Algorithm for
+                Polynomials Using Laguerre's Method. Technical Report.
+                Department of Computer Science, University of Toronto,
+                Canada.
+
+          [3]   Wilkinson J H (1965) The Algebraic Eigenvalue Problem.
+                Clarendon Press.
+
+          5. Parameters
+
+           1:  A(N+1) -- DOUBLE PRECISION array                       Input
+               On entry: if A is declared with bounds (0:N), then A(i)
+                                                          n-i
+               must contain a  (i.e., the coefficient of z   ), for
+                             i
+               i=0,1,...,n. Constraint: A(0) /= 0.0.
+
+           2:  N -- INTEGER                                           Input
+               On entry: the degree of the polynomial, n. Constraint: N >=
+               1.
+
+           3:  SCALE -- LOGICAL                                       Input
+               On entry: indicates whether or not the polynomial is to be
+               scaled. See Section 8 for advice on when it may be
+               preferable to set SCALE = .FALSE. and for a description of
+               the scaling strategy. Suggested value: SCALE = .TRUE..
+
+           4:  Z(2,N) -- DOUBLE PRECISION array                      Output
+               On exit: the real and imaginary parts of the roots are
+               stored in Z(1,i) and Z(2,i) respectively, for i=1,2,...,n.
+               Complex conjugate pairs of roots are stored in consecutive
+               pairs of elements of Z; that is, Z(1,i+1) = Z(1,i) and
+               Z(2,i+1)=-Z(2,i).
+
+           5:  W(2*(N+1)) -- DOUBLE PRECISION array               Workspace
+
+           6:  IFAIL -- INTEGER                                Input/Output
+               On entry: IFAIL must be set to 0, -1 or 1. For users not
+               familiar with this parameter (described in the Essential
+               Introduction) the recommended value is 0.
+               On exit: IFAIL = 0 unless the routine detects an error (see
+               Section 6).
+
+          6. Error Indicators and Warnings
+
+          Errors detected by the routine:
+
+          If on entry IFAIL = 0 or -1, explanatory error messages are
+          output on the current error message unit (as defined by X04AAF).
+
+          IFAIL= 1
+               On entry A(0) = 0.0,
+
+               or       N < 1.
+
+          IFAIL= 2
+               The iterative procedure has failed to converge. This error
+               is very unlikely to occur. If it does, please contact NAG
+               immediately, as some basic assumption for the arithmetic has
+               been violated. See also Section 8.
+
+          IFAIL= 3
+               Either overflow or underflow prevents the evaluation of P(z)
+               near some of its zeros. This error is very unlikely to
+               occur. If it does, please contact NAG immediately. See also
+               Section 8.
+
+          7. Accuracy
+
+          All roots are evaluated as accurately as possible, but because of
+          the inherent nature of the problem complete accuracy cannot be
+          guaranteed.
+
+          8. Further Comments
+
+          If SCALE = .TRUE., then a scaling factor for the coefficients is
+          chosen as a power of the base B of the machine so that the
+                                                                EMAX-P
+          largest coefficient in magnitude approaches THRESH = B      .
+          Users should note that no scaling is performed if the largest
+          coefficient in magnitude exceeds THRESH, even if SCALE = .TRUE..
+          (For definition of B, EMAX and P see the Chapter Introduction
+          X02.)
+
+          However, with SCALE = .TRUE., overflow may be encountered when
+          the input coefficients a ,a ,a ,...,a  vary widely in magnitude,
+                                  0  1  2      n
+                                                    (4*P)
+          particularly on those machines for which B      overflows. In
+          such cases, SCALE should be set to .FALSE. and the coefficients
+          scaled so that the largest coefficient in magnitude does not
+                  (EMAX-2*P)
+          exceed B          .
+
+          Even so, the scaling strategy used in C02AGF is sometimes
+          insufficient to avoid overflow and/or underflow conditions. In
+          such cases, the user is recommended to scale the independent
+          variable (z) so that the disparity between the largest and
+          smallest coefficient in magnitude is reduced. That is, use the
+          routine to locate the zeros of the polynomial d*P(cz) for some
+          suitable values of c and d. For example, if the original
+                               -100  100 20                   -10
+          polynomial was P(z)=2    +2   z  , then choosing c=2    and
+             100                                                     20
+          d=2   , for instance, would yield the scaled polynomial 1+z  ,
+          which is well-behaved relative to overflow and underflow and has
+                           10
+          zeros which are 2   times those of P(z).
+
+          If the routine fails with IFAIL = 2 or 3, then the real and
+          imaginary parts of any roots obtained before the failure occurred
+          are stored in Z in the reverse order in which they were found.
+          Let n  denote the number of roots found before the failure
+               R
+          occurred. Then Z(1,n) and Z(2,n) contain the real and imaginary
+          parts of the 1st root found, Z(1,n-1) and Z(2,n-1) contain the
+          real and imaginary parts of the 2nd root found, ..., Z(1,n ) and
+                                                                    R
+          Z(2,n ) contain the real and imaginary parts of the n th root
+               R                                               R
+          found. After the failure has occurred, the remaining 2*(n-n )
+                                                                     R
+          elements of Z contain a large negative number (equal to
+                         
+
+          -1/(X02AMF().\/2)).
+
+          9. Example
+
+          To find the roots of the 5th degree polynomial
+           5   4   3   2
+          z +2z +3z +4z +5z+6=0.
+
+          The example program is not reproduced here. The source code for
+          all example programs is distributed with the NAG Foundation
+          Library software and should be available on-line.
+
+@
 \pagehead{NagPolynomialRootsPackage}{NAGC02}
 \pagepic{ps/v104nagpolynomialrootspackage.ps}{NAGC02}{1.00}
 
@@ -63525,6 +64318,831 @@ NagPolynomialRootsPackage(): Exports == Implementation where
 @
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \section{package NAGC05 NagRootFindingPackage}
+<<NagRootFindingPackage.help>>=
+
+     C05(3NAG)         Foundation Library (12/10/92)         C05(3NAG)
+
+          C05 -- Roots of One or More Transcendental Equations
+                                                         Introduction -- C05
+                                    Chapter C05
+                   Roots of One or More Transcendental Equations
+
+          1. Scope of the Chapter
+
+          This chapter is concerned with the calculation of real zeros of
+          continuous real functions of one or more variables. (Complex
+          equations must be expressed in terms of the equivalent larger
+          system of real equations.)
+
+          2. Background to the Problems
+
+          The chapter divides naturally into two parts.
+
+          2.1. A Single Equation
+
+          The first deals with the real zeros of a real function of a
+          single variable f(x).
+
+          At present, there is only one routine with a simple calling
+          sequence. This routine assumes that the user can determine an
+          initial interval [a,b] within which the desired zero lies, that
+          is f(a)*f(b)<0, and outside which all other zeros lie. The
+          routine then systematically subdivides the interval to produce a
+          final interval containing the zero. This final interval has a
+          length bounded by the user's specified error requirements; the
+          end of the interval where the function has smallest magnitude is
+          returned as the zero. This routine is guaranteed to converge to a
+          simple zero of the function. (Here we define a simple zero as a
+          zero corresponding to a sign-change of the function.) The
+          algorithm used is due to Bus and Dekker.
+
+          2.2. Systems of Equations
+
+          The routines in the second part of this chapter are designed to
+          solve a set of nonlinear equations in n unknowns
+
+
+                                                           T
+                   f (x)=0,  i=1,2,...,n,  x=(x ,x ,...,x )             (1)
+                    i                          1  2      n
+
+          where T stands for transpose.
+
+          It is assumed that the functions are continuous and
+          differentiable so that the matrix of first partial derivatives of
+          the functions, the Jacobian matrix J  (x)=ddf /ddx  evaluated at
+                                              ij       i    j
+          the point x, exists, though it may not be possible to calculate
+          it directly.
+
+          The functions f  must be independent, otherwise there will be an
+                         i
+          infinity of solutions and the methods will fail. However, even
+          when the functions are independent the solutions may not be
+          unique. Since the methods are iterative, an initial guess at the
+          solution has to be supplied, and the solution located will
+          usually be the one closest to this initial guess.
+
+          2.3. References
+
+          [1]   Gill P E and Murray W (1976) Algorithms for the Solution of
+                the Nonlinear Least-squares Problem. NAC 71 National
+                Physical Laboratory.
+
+          [2]   More J J, Garbow B S and Hillstrom K E (1974) User Guide for
+                Minpack-1. ANL-80-74 Argonne National Laboratory.
+
+          [3]   Ortega J M and Rheinboldt W C (1970) Iterative Solution of
+                Nonlinear Equations in Several Variables. Academic Press.
+
+          [4]   Rabinowitz P (1970) Numerical Methods for Nonlinear
+                Algebraic Equations. Gordon and Breach.
+
+          3. Recommendations on Choice and Use of Routines
+
+          3.1. Zeros of Functions of One Variable
+
+          There is only one routine (C05ADF) for solving a single nonlinear
+          equation. This routine is designed for solving problems where the
+          function f(x) whose zero is to be calculated, can be coded as a
+          user-supplied routine.
+
+          C05ADF may only be used when the user can supply an interval
+          [a,b] containing the zero, that is f(a)*f(b)<0.
+
+          3.2. Solution of Sets of Nonlinear Equations
+
+          The solution of a set of nonlinear equations
+
+                        f (x ,x ,...,x )=0,  i=1,2,...,n                (2)
+                         i  1  2      n
+
+          can be regarded as a special case of the problem of finding a
+          minimum of a sum of squares
+
+                           m
+                           /                    2
+                     s(x)= |  [f (x ,x ,...,x )]   (m>=n).              (3)
+                           /    i  1  2      n
+                           i=1
+
+          So the routines in Chapter E04 of the Library are relevant as
+          well as the special nonlinear equations routines.
+
+          There are two routines (C05NBF and C05PBF) for solving a set of
+          nonlinear equations. These routines require the f  (and possibly
+                                                           i
+          their derivatives) to be calculated in user-supplied routines.
+          These should be set up carefully so the Library routines can work
+          as efficiently as possible.
+
+          The main decision which has to be made by the user is whether to
+                                  ddf
+                                     i
+          supply the derivatives  ----. It is advisable to do so if
+                                  ddx
+                                     j
+          possible, since the results obtained by algorithms which use
+          derivatives are generally more reliable than those obtained by
+          algorithms which do not use derivatives.
+
+          C05PBF requires the user to provide the derivatives, whilst
+          C05NBF does not. C05NBF and C05PBF are easy-to-use routines. A
+          routine, C05ZAF, is provided for use in conjunction with C05PBF
+          to check the user-provided derivatives for consistency with the
+          functions themselves. The user is strongly advised to make use of
+          this routine whenever C05PBF is used.
+
+          Firstly, the calculation of the functions and their derivatives
+          should be ordered so that cancellation errors are avoided. This
+          is particularly important in a routine that uses these quantities
+          to build up estimates of higher derivatives.
+
+          Secondly, scaling of the variables has a considerable effect on
+          the efficiency of a routine. The problem should be designed so
+          that the elements of x are of similar magnitude. The same comment
+          applies to the functions, all the f  should be of comparable
+                                             i
+          size.
+
+          The accuracy is usually determined by the accuracy parameters of
+          the routines, but the following points may be useful:
+
+          (i)   Greater accuracy in the solution may be requested by
+                choosing smaller input values for the accuracy parameters.
+                However, if unreasonable accuracy is demanded, rounding
+                errors may become important and cause a failure.
+
+          (ii)  Some idea of the accuracies of the x  may be obtained by
+                                                    i
+                monitoring the progress of the routine to see how many
+                figures remain unchanged during the last few iterations.
+
+          (iii) An approximation to the error in the solution x, given by e
+                where e is the solution to the set of linear equations
+
+                J(x)e=-f(x)
+
+                                                  T
+                where f(x)=(f (x),f (x),...,f (x))  (see Chapter F04).
+                             1     2         n
+
+          (iv)  If the functions f (x) are changed by small amounts
+                                  i
+                (epsilon) , for i=1,2,...,n, then the corresponding change
+                         i
+                in the solution x is given approximately by (sigma), where
+                (sigma) is the solution of the set of linear equations
+
+                J(x)(sigma)=-(epsilon), (see Chapter F04).
+
+                Thus one can estimate the sensitivity of x to any
+                uncertainties in the specification of f (x), for
+                                                       i
+                i=1,2,...,n.
+
+          3.3. Index
+
+          Zeros of functions of one variable:
+               Bus and Dekker algorithm                              C05ADF
+          Zeros of functions of several variables:
+               easy-to-use                                           C05NBF
+               easy-to-use, derivatives required                     C05PBF
+          Checking Routine:
+               Checks user-supplied Jacobian                         C05ZAF
+
+
+          C05 -- Roots of One or More Transcendental Equations
+                                                             Contents -- C05
+          Chapter C05
+
+          Roots of One or More Transcendental Equations
+
+          C05ADF  Zero of continuous function in given interval, Bus and
+                  Dekker algorithm
+
+          C05NBF  Solution of system of nonlinear equations using function
+                  values only
+
+          C05PBF  Solution of system of nonlinear equations using 1st
+                  derivatives
+
+          C05ZAF  Check user's routine for calculating 1st derivatives
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+     C05ADF(3NAG)      Foundation Library (12/10/92)      C05ADF(3NAG)
+
+          C05 -- Roots of One or More Transcendental Equations       C05ADF
+                  C05ADF -- NAG Foundation Library Routine Document
+
+          Note: Before using this routine, please read the Users' Note for
+          your implementation to check implementation-dependent details.
+          The symbol (*) after a NAG routine name denotes a routine that is
+          not included in the Foundation Library.
+
+          1. Purpose
+
+          C05ADF locates a zero of a continuous function in a given
+          interval by a combination of the methods of linear interpolation,
+          extrapolation and bisection.
+
+          2. Specification
+
+                 SUBROUTINE C05ADF (A, B, EPS, ETA, F, X, IFAIL)
+                 INTEGER          IFAIL
+                 DOUBLE PRECISION A, B, EPS, ETA, F, X
+                 EXTERNAL         F
+
+          3. Description
+
+          The routine attempts to obtain an approximation to a simple zero
+          of the function f(x) given an initial interval [a,b] such that
+          f(a)*f(b)<=0. The zero is found by calls to C05AZF(*) whose
+          specification should be consulted for details of the method used.
+
+          The approximation x to the zero (alpha) is determined so that one
+          or both of the following criteria are satisfied:
+
+               (i) |x-(alpha)|<EPS,
+
+               (ii) |f(x)|<ETA.
+
+          4. References
+
+          None.
+
+          5. Parameters
+
+           1:  A -- DOUBLE PRECISION                                  Input
+               On entry: the lower bound of the interval, a.
+
+           2:  B -- DOUBLE PRECISION                                  Input
+               On entry: the upper bound of the interval, b. Constraint: B
+               /= A.
+
+           3:  EPS -- DOUBLE PRECISION                                Input
+               On entry: the absolute tolerance to which the zero is
+               required (see Section 3). Constraint: EPS > 0.0.
+
+           4:  ETA -- DOUBLE PRECISION                                Input
+               On entry: a value such that if |f(x)|<ETA, x is accepted as
+               the zero. ETA may be specified as 0.0 (see Section 7).
+
+           5:  F -- DOUBLE PRECISION FUNCTION, supplied by the user.
+                                                    External Procedure
+               F must evaluate the function f whose zero is to be
+               determined.
+
+               Its specification is:
+
+                      DOUBLE PRECISION FUNCTION F (XX)
+                      DOUBLE PRECISION XX
+
+                1:  XX -- DOUBLE PRECISION                            Input
+                    On entry: the point at which the function must be
+                    evaluated.
+               F must be declared as EXTERNAL in the (sub)program from
+               which C05ADF is called. Parameters denoted as Input
+               must not be changed by this procedure.
+
+           6:  X -- DOUBLE PRECISION                                 Output
+               On exit: the approximation to the zero.
+
+           7:  IFAIL -- INTEGER                                Input/Output
+               Before entry, IFAIL must be assigned a value. For users not
+               familiar with this parameter (described in the Essential
+               Introduction) the recommended value is 0.
+
+               Unless the routine detects an error (see Section 6), IFAIL
+               contains 0 on exit.
+
+          6. Error Indicators and Warnings
+
+          Errors detected by the routine:
+
+          IFAIL= 1
+               On entry EPS <= 0.0,
+
+               or       A = B,
+
+               or       F(A)*F(B)>0.0.
+
+          IFAIL= 2
+               Too much accuracy has been requested in the computation,
+               that is, EPS is too small for the computer being used. The
+               final value of X is an accurate approximation to the zero.
+
+          IFAIL= 3
+               A change in sign of f(x) has been determined as occurring
+               near the point defined by the final value of X. However,
+               there is some evidence that this sign-change corresponds to
+               a pole of f(x).
+
+          IFAIL= 4
+               Indicates that a serious error has occurred in C05AZF(*).
+               Check all routine calls. Seek expert help.
+
+          7. Accuracy
+
+          This depends on the value of EPS and ETA. If full machine
+          accuracy is required, they may be set very small, resulting in an
+          error exit with IFAIL = 2, although this may involve more
+          iterations than a lesser accuracy. The user is recommended to set
+          ETA = 0.0 and to use EPS to control the accuracy, unless he has
+          considerable knowledge of the size of f(x) for values of x near
+          the zero.
+
+          8. Further Comments
+
+          The time taken by the routine depends primarily on the time spent
+          evaluating F (see Section 5).
+
+          If it is important to determine an interval of length less than
+          EPS containing the zero, or if the function F is expensive to
+          evaluate and the number of calls to F is to be restricted, then
+          use of C05AZF(*) is recommended. Use of C05AZF(*) is also
+          recommended when the structure of the problem to be solved does
+          not permit a simple function F to be written: the reverse
+          communication facilities of C05AZF(*) are more flexible than the
+          direct communication of F required by C05ADF.
+
+          9. Example
+
+                                                            -x
+          The example program below calculates the zero of e  -x within the
+          interval [0,1] to approximately 5 decimal places.
+
+          The example program is not reproduced here. The source code for
+          all example programs is distributed with the NAG Foundation
+          Library software and should be available on-line.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+     C05NBF(3NAG)      Foundation Library (12/10/92)      C05NBF(3NAG)
+
+          C05 -- Roots of One or More Transcendental Equations       C05NBF
+                  C05NBF -- NAG Foundation Library Routine Document
+
+          Note: Before using this routine, please read the Users' Note for
+          your implementation to check implementation-dependent details.
+          The symbol (*) after a NAG routine name denotes a routine that is
+          not included in the Foundation Library.
+
+          1. Purpose
+
+          C05NBF is an easy-to-use routine to find a solution of a system
+          of nonlinear equations by a modification of the Powell hybrid
+          method.
+
+          2. Specification
+
+                 SUBROUTINE C05NBF (FCN, N, X, FVEC, XTOL, WA, LWA, IFAIL)
+                 INTEGER          N, LWA, IFAIL
+                 DOUBLE PRECISION X(N), FVEC(N), XTOL, WA(LWA)
+                 EXTERNAL         FCN
+
+          3. Description
+
+          The system of equations is defined as:
+
+                        f (x ,x ,...,x )=0, for i=1,2,...,n.
+                         i  1  2      n
+
+          C05NBF is based upon the MINPACK routine HYBRD1 (More et al [1]).
+          It chooses the correction at each step as a convex combination of
+          the Newton and scaled gradient directions. Under reasonable
+          conditions this guarantees global convergence for starting points
+          far from the solution and a fast rate of convergence. The
+          Jacobian is updated by the rank-1 method of Broyden. At the
+          starting point the Jacobian is approximated by forward
+          differences, but these are not used again until the rank-1 method
+          fails to produce satisfactory progress. For more details see
+          Powell [2].
+
+          4. References
+
+          [1]   More J J, Garbow B S and Hillstrom K E User Guide for
+                MINPACK-1. Technical Report ANL-80-74. Argonne National
+                Laboratory.
+
+          [2]   Powell M J D (1970) A Hybrid Method for Nonlinear Algebraic
+                Equations. Numerical Methods for Nonlinear Algebraic
+                Equations. (ed P Rabinowitz) Gordon and Breach.
+
+          5. Parameters
+
+           1:  FCN -- SUBROUTINE, supplied by the user.
+                                                    External Procedure
+               FCN must return the values of the functions f  at a point x.
+                                                            i
+
+               Its specification is:
+
+                      SUBROUTINE FCN (N, X, FVEC, IFLAG)
+                      INTEGER          N, IFLAG
+                      DOUBLE PRECISION X(N), FVEC(N)
+
+                1:  N -- INTEGER                                      Input
+                    On entry: the number of equations, n.
+
+                2:  X(N) -- DOUBLE PRECISION array                    Input
+                    On entry: the components of the point x at which the
+                    functions must be evaluated.
+
+                3:  FVEC(N) -- DOUBLE PRECISION array                Output
+                    On exit: the function values f (x) (unless IFLAG is
+                                                  i
+                    set to a negative value by FCN).
+
+                4:  IFLAG -- INTEGER                           Input/Output
+                    On entry: IFLAG > 0. On exit: in general, IFLAG should
+                    not be reset by FCN. If, however, the user wishes to
+                    terminate execution (perhaps because some illegal point
+                    X has been reached), then IFLAG should be set to a
+                    negative integer. This value will be returned through
+                    IFAIL.
+               FCN must be declared as EXTERNAL in the (sub)program
+               from which C05NBF is called. Parameters denoted as
+               Input must not be changed by this procedure.
+
+           2:  N -- INTEGER                                           Input
+               On entry: the number of equations, n. Constraint: N > 0.
+
+           3:  X(N) -- DOUBLE PRECISION array                  Input/Output
+               On entry: an initial guess at the solution vector. On
+               exit: the final estimate of the solution vector.
+
+           4:  FVEC(N) -- DOUBLE PRECISION array                     Output
+               On exit: the function values at the final point, X.
+
+           5:  XTOL -- DOUBLE PRECISION                               Input
+               On entry: the accuracy in X to which the solution is
+               required. Suggested value: the square root of the machine
+               precision. Constraint: XTOL >= 0.0.
+
+           6:  WA(LWA) -- DOUBLE PRECISION array                  Workspace
+
+           7:  LWA -- INTEGER                                         Input
+               On entry: the dimension of the array WA. Constraint:
+               LWA>=N*(3*N+13)/2.
+
+           8:  IFAIL -- INTEGER                                Input/Output
+               On entry: IFAIL must be set to 0, -1 or 1. For users not
+               familiar with this parameter (described in the Essential
+               Introduction) the recommended value is 0.
+
+               On exit: IFAIL = 0 unless the routine detects an error (see
+               Section 6).
+
+          6. Error Indicators and Warnings
+
+          Errors detected by the routine:
+
+          If on entry IFAIL = 0 or -1, explanatory error messages are
+          output on the current error message unit (as defined by X04AAF).
+
+          IFAIL< 0
+               The user has set IFLAG negative in FCN. The value of IFAIL
+               will be the same as the user's setting of IFLAG.
+
+          IFAIL= 1
+               On entry N <= 0,
+
+               or       XTOL < 0.0,
+
+               or       LWA<N*(3*N+13)/2.
+
+          IFAIL= 2
+               There have been at least 200*(N+1) evaluations of FCN.
+               Consider restarting the calculation from the final point
+               held in X.
+
+          IFAIL= 3
+               No further improvement in the approximate solution X is
+               possible; XTOL is too small.
+
+          IFAIL= 4
+               The iteration is not making good progress. This failure exit
+               may indicate that the system does not have a zero, or that
+               the solution is very close to the origin (see Section 7).
+               Otherwise, rerunning C05NBF from a different starting point
+               may avoid the region of difficulty.
+
+          7. Accuracy
+
+             ^
+          If x is the true solution, C05NBF tries to ensure that
+
+                                   ^             ^
+                              ||x-x||<=XTOL*||x||.
+
+                                                     -k
+          If this condition is satisfied with XTOL=10  , then the larger
+          components of x have k significant decimal digits. There is a
+          danger that the smaller components of x may have large relative
+          errors, but the fast rate of convergence of C05NBF usually avoids
+          this possibility.
+
+          If XTOL is less than machine precision, and the above test is
+          satisfied with the machine precision in place of XTOL, then the
+          routine exits with IFAIL = 3.
+
+          Note: this convergence test is based purely on relative error,
+          and may not indicate convergence if the solution is very close to
+          the origin.
+
+          The test assumes that the functions are reasonably well behaved.
+          If this condition is not satisfied, then C05NBF may incorrectly
+          indicate convergence. The validity of the answer can be checked,
+          for example, by rerunning C05NBF with a tighter tolerance.
+
+          8. Further Comments
+
+          The time required by C05NBF to solve a given problem depends on n
+          , the behaviour of the functions, the accuracy requested and the
+          starting point. The number of arithmetic operations executed by
+                                                            2
+          C05NBF to process each call of FCN is about 11.5*n . Unless FCN
+          can be evaluated quickly, the timing of C05NBF will be strongly
+          influenced by the time spent in FCN.
+
+          Ideally the problem should be scaled so that at the solution the
+          function values are of comparable magnitude.
+
+          9. Example
+
+          To determine the values x ,..., x  which satisfy the tridiagonal
+                                   1       9
+          equations:
+
+                                  (3-2x )x -2x =-1
+                                       1  1   2
+
+                       -x -1+(3-2x )x -2x   =-1,  i=2,3,...,8
+                         i        i  i   i+1
+
+                                  -x +(3-2x )x =-1.
+                                    8      9  9
+
+          The example program is not reproduced here. The source code for
+          all example programs is distributed with the NAG Foundation
+          Library software and should be available on-line.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+     C05PBF(3NAG)      Foundation Library (12/10/92)      C05PBF(3NAG)
+
+          C05 -- Roots of One or More Transcendental Equations       C05PBF
+                  C05PBF -- NAG Foundation Library Routine Document
+
+          Note: Before using this routine, please read the Users' Note for
+          your implementation to check implementation-dependent details.
+          The symbol (*) after a NAG routine name denotes a routine that is
+          not included in the Foundation Library.
+
+          1. Purpose
+
+          C05PBF is an easy-to-use routine to find a solution of a system
+          of nonlinear equations by a modification of the Powell hybrid
+          method. The user must provide the Jacobian.
+
+          2. Specification
+
+                 SUBROUTINE C05PBF (FCN, N, X, FVEC, FJAC, LDFJAC, XTOL,
+                1                   WA, LWA, IFAIL)
+                 INTEGER          N, LDFJAC, LWA, IFAIL
+                 DOUBLE PRECISION X(N), FVEC(N), FJAC(LDFJAC,N), XTOL, WA
+                1                 (LWA)
+                 EXTERNAL         FCN
+
+          3. Description
+
+          The system of equations is defined as:
+
+                          f (x ,x ,...,x )=0, i=1,2,...,n.
+                           i  1  2      n
+
+          C05PBF is based upon the MINPACK routine HYBRJ1 (More et al [1]).
+          It chooses the correction at each step as a convex combination of
+          the Newton and scaled gradient directions. Under reasonable
+          conditions this guarantees global convergence for starting points
+          far from the solution and a fast rate of convergence. The
+          Jacobian is updated by the rank-1 method of Broyden. At the
+          starting point the Jacobian is calculated, but it is not
+          recalculated until the rank-1 method fails to produce
+          satisfactory progress. For more details see Powell [2].
+
+          4. References
+
+          [1]   More J J, Garbow B S and Hillstrom K E User Guide for
+                MINPACK-1. Technical Report ANL-80-74. Argonne National
+                Laboratory.
+
+          [2]   Powell M J D (1970) A Hybrid Method for Nonlinear Algebraic
+                Equations. Numerical Methods for Nonlinear Algebraic
+                Equations. (ed P Rabinowitz) Gordon and Breach.
+
+          5. Parameters
+
+           1:  FCN -- SUBROUTINE, supplied by the user.
+                                                    External Procedure
+               Depending upon the value of IFLAG, FCN must either return
+               the values of the functions f  at a point x or return the
+                                            i
+               Jacobian at x.
+
+               Its specification is:
+
+                      SUBROUTINE FCN (N, X, FVEC, FJAC, LDFJAC, IFLAG)
+                      INTEGER          N, LDFJAC, IFLAG
+                      DOUBLE PRECISION X(N), FVEC(N), FJAC(LDFJAC,N)
+
+                1:  N -- INTEGER                                      Input
+                    On entry: the number of equations, n.
+
+                2:  X(N) -- DOUBLE PRECISION array                    Input
+                    On entry: the components of the point x at which the
+                    functions or the Jacobian must be evaluated.
+
+                3:  FVEC(N) -- DOUBLE PRECISION array                Output
+                    On exit: if IFLAG = 1 on entry, FVEC must contain the
+                    function values f (x) (unless IFLAG is set to a
+                                     i
+                    negative value by FCN). If IFLAG = 2 on entry, FVEC
+                    must not be changed.
+
+                4:  FJAC(LDFJAC,N) -- DOUBLE PRECISION array         Output
+                    On exit: if IFLAG = 2 on entry, FJAC(i,j) must contain
+                                  ddf
+                                     i
+                    the value of  ---- at the point x, for i,j=1,2,...,n
+                                  ddx
+                                     j
+                    (unless IFLAG is set to a negative value by FCN).
+
+                    If IFLAG = 1 on entry, FJAC must not be changed.
+
+                5:  LDFJAC -- INTEGER                                 Input
+                    On entry: the first dimension of FJAC.
+
+                6:  IFLAG -- INTEGER                           Input/Output
+                    On entry: IFLAG = 1 or 2:
+                         if IFLAG = 1, FVEC is to be updated;
+
+                         if IFLAG = 2, FJAC is to be updated.
+                    On exit: in general, IFLAG should not be reset by FCN.
+                    If, however, the user wishes to terminate execution
+                    (perhaps because some illegal point x has been reached)
+                    then IFLAG should be set to a negative integer. This
+                    value will be returned through IFAIL.
+               FCN must be declared as EXTERNAL in the (sub)program
+               from which C05PBF is called. Parameters denoted as
+               Input must not be changed by this procedure.
+
+           2:  N -- INTEGER                                           Input
+               On entry: the number of equations, n. Constraint: N > 0.
+
+           3:  X(N) -- DOUBLE PRECISION array                  Input/Output
+               On entry: an initial guess at the solution vector. On
+               exit: the final estimate of the solution vector.
+
+           4:  FVEC(N) -- DOUBLE PRECISION array                     Output
+               On exit: the function values at the final point, X.
+
+           5:  FJAC(LDFJAC,N) -- DOUBLE PRECISION array              Output
+               On exit: the orthogonal matrix Q produced by the QR
+               factorization of the final approximate Jacobian.
+
+           6:  LDFJAC -- INTEGER                                      Input
+               On entry:
+               the first dimension of the array FJAC as declared in the
+               (sub)program from which C05PBF is called.
+               Constraint: LDFJAC >= N.
+
+           7:  XTOL -- DOUBLE PRECISION                               Input
+               On entry: the accuracy in X to which the solution is
+               required. Suggested value: the square root of the machine
+               precision. Constraint: XTOL >= 0.0.
+
+           8:  WA(LWA) -- DOUBLE PRECISION array                  Workspace
+
+           9:  LWA -- INTEGER                                         Input
+               On entry: the dimension of the array WA. Constraint:
+               LWA>=N*(N+13)/2.
+
+          10:  IFAIL -- INTEGER                                Input/Output
+               On entry: IFAIL must be set to 0, -1 or 1. For users not
+               familiar with this parameter (described in the Essential
+               Introduction) the recommended value is 0.
+
+               On exit: IFAIL = 0 unless the routine detects an error (see
+               Section 6).
+
+          6. Error Indicators and Warnings
+
+          Errors detected by the routine:
+
+          If on entry IFAIL = 0 or -1, explanatory error messages are
+          output on the current error message unit (as defined by X04AAF).
+
+          IFAIL< 0
+               A negative value of IFAIL indicates an exit from C05PBF
+               because the user has set IFLAG negative in FCN. The value of
+               IFAIL will be the same as the user's setting of IFLAG.
+
+          IFAIL= 1
+               On entry N <= 0,
+
+               or       LDFJAC < N,
+
+               or       XTOL < 0.0,
+
+               or       LWA<N*(N+13)/2.
+
+          IFAIL= 2
+               There have been 100*(N+1) evaluations of the functions.
+               Consider restarting the calculation from the final point
+               held in X.
+
+          IFAIL= 3
+               No further improvement in the approximate solution X is
+               possible; XTOL is too small.
+
+          IFAIL= 4
+               The iteration is not making good progress. This failure exit
+               may indicate that the system does not have a zero or that
+               the solution is very close to the origin (see Section 7).
+               Otherwise, rerunning C05PBF from a different starting point
+               may avoid the region of difficulty.
+
+          7. Accuracy
+
+             ^
+          If x is the true solution, C05PBF tries to ensure that
+
+                                  ^              ^
+                             ||x-x|| <=XTOL*||x|| .
+                                    2            2
+
+                                                     -k
+          If this condition is satisfied with XTOL=10  , then the larger
+          components of x have k significant decimal digits. There is a
+          danger that the smaller components of x may have large relative
+          errors, but the fast rate of convergence of C05PBF usually avoids
+          the possibility.
+
+          If XTOL is less than machine precision and the above test is
+          satisfied with the machine precision in place of XTOL, then the
+          routine exits with IFAIL = 3.
+
+          Note: this convergence test is based purely on relative error,
+          and may not indicate convergence if the solution is very close to
+          the origin.
+
+          The test assumes that the functions and Jacobian are coded
+          consistently and that the functions are reasonably well behaved.
+          If these conditions are not satisfied then C05PBF may incorrectly
+          indicate convergence. The coding of the Jacobian can be checked
+          using C05ZAF. If the Jacobian is coded correctly, then the
+          validity of the answer can be checked by rerunning C05PBF with a
+          tighter tolerance.
+
+          8. Further Comments
+
+          The time required by C05PBF to solve a given problem depends on n
+          , the behaviour of the functions, the accuracy requested and the
+          starting point. The number of arithmetic operations executed by
+                                2
+          C05PBF is about 11.5*n  to process each evaluation of the
+                                   3
+          functions and about 1.3*n  to process each evaluation of the
+          Jacobian. Unless FCN can be evaluated quickly, the timing of
+          C05PBF will be strongly influenced by the time spent in FCN.
+
+          Ideally the problem should be scaled so that, at the solution,
+          the function values are of comparable magnitude.
+
+          9. Example
+
+          To determine the values x ,..., x  which satisfy the tridiagonal
+                                   1       9
+          equations:
+
+                                  (3-2x )x -2x =-1
+                                       1  1   2
+
+                        -x   +(3-2x )x -2x   =-1,  i=2,3,...,8.
+                          i-1      i  i   i+1
+
+                                  -x +(3-2x )x =-1.
+                                    8      9  9
+
+          The example program is not reproduced here. The source code for
+          all example programs is distributed with the NAG Foundation
+          Library software and should be available on-line.
+
+@
 \pagehead{NagRootFindingPackage}{NAGC05}
 \pagepic{ps/v104nagrootfindingpackage.ps}{NAGC05}{1.00}
 
@@ -63664,6 +65282,2213 @@ NagRootFindingPackage(): Exports == Implementation where
 @
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \section{package NAGC06 NagSeriesSummationPackage}
+<<NagSeriesSummationPackage.help>>=
+
+     C06(3NAG)         Foundation Library (12/10/92)         C06(3NAG)
+
+
+
+          C06 -- Summation of Series                    Introduction -- C06
+                                    Chapter C06
+                                Summation of Series
+
+          1. Scope of the Chapter
+
+          This chapter is concerned with calculating the discrete Fourier
+          transform of a sequence of real or complex data values, and
+          applying it to calculate convolutions and correlations.
+
+          2. Background to the Problems
+
+          2.1. Discrete Fourier Transforms
+
+          2.1.1.  Complex transforms
+
+          Most of the routines in this chapter calculate the finite
+          discrete Fourier transform  (DFT) of a sequence of n complex
+          numbers z , for j=0,1,...,n-1. The transform is defined by:
+                   j
+
+                                  n-1
+                          ^    1  --      (   2(pi)jk)
+                          z = --- >  z exp(-i -------)                  (1)
+                           k      --  j   (      n   )
+                              \/n j=0
+
+          for k=0,1,...,n-1. Note that equation (1) makes sense for all
+                                             ^
+          integral k and with this extension z  is periodic with period n,
+                                              k
+               ^  ^                        ^   ^
+          i.e. z =z    , and in particular z  =z   .
+                k  k+-n                     -k  n-k
+
+                                    ^                                 ^
+          If we write z =x +iy  and z =a +ib , then the definition of z
+                       j  j   j      k  k   k                          k
+          may be written in terms of sines and cosines as:
+
+                            n-1
+                         1  -- (     ( 2(pi)jk)      ( 2(pi)jk))
+                    a = --- >  (x cos( -------)+y sin( -------))
+                     k      -- ( j   (    n   )  j   (    n   ))
+                        \/n j=0
+
+                            n-1
+                         1  -- (     ( 2(pi)jk)      ( 2(pi)jk))
+                    b = --- >  (y cos( -------)-x sin( -------)).
+                     k      -- ( j   (    n   )  j   (    n   ))
+                        \/n j=0
+
+          The original data values z  may conversely be recovered from the
+                                    j
+                    ^
+          transform z  by an  inverse discrete Fourier transform:
+                     k
+
+
+                                  n-1
+                               1  -- ^    (   2(pi)jk)
+                          z = --- >  z exp(+i -------)                  (2)
+                           j      --  k   (      n   )
+                              \/n k=0
+
+          for j=0,1,...,n-1. If we take the complex conjugate of (2), we
+                                                               
+
+                                                               ^
+          find that the sequence z  is the DFT of the sequence z . Hence
+                                  j                             k
+                                          ^
+          the inverse DFT of the sequence z  may be obtained by: taking the
+                                           k
+                                    ^
+          complex conjugates of the z ; performing a DFT; and taking the
+                                     k
+          complex conjugates of the result.
+
+          Notes: definitions of the discrete Fourier transform vary.
+          Sometimes (2) is used as the definition of the DFT, and (1) as
+                                                                      
+
+          the definition of the inverse. Also the scale-factor of 1/\/n may
+          be omitted in the definition of the DFT, and replaced by 1/n in
+          the definition of the inverse.
+
+          2.1.2. Real transforms
+
+          If the original sequence is purely real valued, i.e. z =x , then
+                                                                j  j
+
+                                        n-1
+                         ^           1  --      (   2(pi)jk)
+                         z =a +ib = --- >  x exp(-i -------)
+                          k  k   k      --  j   (      n   )
+                                    \/n j=0
+
+              ^                                ^
+          and z    is the complex conjugate of z . Thus the DFT of a real
+               n-k                              k
+          sequence is a particular type of complex sequence, called a
+          Hermitian sequence, or  half-complex or  conjugate symmetric with
+          the properties:
+                         a   =a  b   =-b  b =0 and, if n is even, b   =0.
+                          n-k  k  n-k   k  0                       n/2
+
+          Thus a Hermitian sequence of n complex data values can be
+          represented by only n, rather than 2n, independent real values.
+          This can obviously lead to economies in storage, the following
+          scheme being used in this chapter: the real parts a  for
+                                                             k
+          0<=k<=n/2 are stored in normal order in the first n/2+1 locations
+          of an array X of length n; the corresponding non-zero imaginary
+          parts are stored in reverse order in the remaining locations of
+          X. In other words, if X is declared with bounds (0:n-1) in the
+                                                               ^
+          user's (sub)program, the real and imaginary parts of z  are
+                                                                k
+          stored as follows:
+
+                         if n=2s    if n=2s-1
+
+              X(0)       a          a
+                          0          0
+
+              X(1)       a          a
+                          1          1
+
+              X(2)       a          a
+                          2          2
+
+              .          .          .
+
+              .          .          .
+
+              .          .          .
+
+              X(s-1)     a          a
+                          s-1        s-1
+
+              X(s)       a          b
+                          s          s-1
+
+              X(s+1)     b          b
+                          s-1        s-2
+
+              .          .          .
+
+              .          .          .
+
+              .          .          .
+
+              X(n-2)     b          b
+                          2          2
+
+              X(n-1)     b          b
+                          1          1
+
+
+                         (     n/2-1                                      )
+                       1 (     --   (     ( 2(pi)jk)      ( 2(pi)jk))     )
+          Hence   x = ---(a +2 >    (a cos( -------)-b sin( -------))+a   )
+                   j     ( 0   --   ( k   (    n   )  k   (    n   ))  n/2)
+                      \/n(     k=0                                        )
+
+          where a    = 0 if n is odd.
+                 n/2
+
+          2.1.3.  Fourier integral transforms
+
+          The usual application of the discrete Fourier transform is that
+          of obtaining an approximation of the  Fourier integral transform
+
+
+                                +infty
+                                /
+                          F(s)= |     f(t)exp(-i2(pi)st)dt
+                                /
+                                -infty
+
+          when f(t) is negligible outside some region (0,c). Dividing the
+          region into n equal intervals we have
+
+                                    n-1
+                                  c --
+                           F(s)~= - >  f exp(-i2(pi)sjc/n)
+                                  n --  j
+                                    j=0
+
+          and so
+
+                                   n-1
+                                 c --
+                            F ~= - >  f exp(-i2(pi)jk/n)
+                             k   n --  j
+                                   j=0
+
+          for k=0,1,...,n-1, where f =f(jc/n) and F =F(k/c).
+                                    j              k
+
+          Hence the discrete Fourier transform gives an approximation to
+          the Fourier integral transform in the region s=0 to s=n/c.
+
+          If the function f(t) is defined over some more general interval
+          (a,b), then the integral transform can still be approximated by
+          the discrete transform provided a shift is applied to move the
+          point a to the origin.
+
+          2.1.4.  Convolutions and correlations
+
+          One of the most important applications of the discrete Fourier
+          transform is to the computation of the discrete convolution or
+          correlation of two vectors x and y defined (as in Brigham [1])
+          by:
+
+                                n-1
+                                --
+               convolution: z = >  x y
+                             k  --  j k-j
+                                j=0
+
+                                n-1
+                                -- 
+               correlation: w = >  x y
+                             k  --  j k+j
+                                j=0
+
+          (Here x and y are assumed to be periodic with period n.)
+
+          Under certain circumstances (see Brigham [1]) these can be used
+          as approximations to the convolution or correlation integrals
+          defined by:
+
+                                    +infty
+                                    /
+                              z(s)= |     x(t)y(s-t)dt
+                                    /
+                                    -infty
+
+          and
+
+                          +infty
+                          /     
+                    w(s)= |     x(t)y(s+t)dt,   -infty<s<+infty.
+                          /
+                          -infty
+
+          For more general advice on the use of Fourier transforms, see
+          Hamming [2]; more detailed information on the fast Fourier
+          transform algorithm can be found in Van Loan [3] and Brigham [1].
+
+          2.2. References
+
+          [1]   Brigham E O (1973) The Fast Fourier Transform. Prentice-
+                Hall.
+
+          [2]   Hamming R W (1962) Numerical Methods for Scientists and
+                Engineers. McGraw-Hill.
+
+          [3]   Van Loan C (1992) Computational Frameworks for the Fast
+                Fourier Transform. SIAM Philadelphia.
+
+          3. Recommendations on Choice and Use of Routines
+
+          3.1. One-dimensional Fourier Transforms
+
+          The choice of routine is determined first of all by whether the
+          data values constitute a real, Hermitian or general complex
+          sequence. It is wasteful of time and storage to use an
+          inappropriate routine.
+
+          Two groups, each of three routines, are provided
+
+                                   Group 1      Group 2
+
+              Real sequences       C06EAF       C06FPF
+
+              Hermitian sequences  C06EBF       C06FQF
+
+              General complex      C06ECF       C06FRF
+              sequences
+
+          Group 1 routines each compute a single transform of length n,
+          without requiring any extra working storage. The Group 1 routines
+          impose some restrictions on the value of n, namely that no prime
+          factor of n may exceed 19 and the total number of prime factors
+          (including repetitions) may not exceed 20 (though the latter
+                                                     6
+          restriction only becomes relevant when n>10 ).
+
+          Group 2 routines are designed to perform several transforms in a
+          single call, all with the same value of n. They do however
+          require more working storage. Even on scalar processors, they may
+          be somewhat faster than repeated calls to Group 1 routines
+          because of reduced overheads and because they pre-compute and
+          store the required values of trigonometric functions. Group 2
+          routines impose no practical restrictions on the value of n;
+          however the fast Fourier transform algorithm ceases to be 'fast'
+          if applied to values of n which cannot be expressed as a product
+          of small prime factors. All the above routines are particularly
+          efficient if the only prime factors of n are 2, 3 or 5.
+
+          If extensive use is to be made of these routines, users who are
+          concerned about efficiency are advised to conduct their own
+          timing tests.
+
+          To compute inverse discrete Fourier transforms the above routines
+          should be used in conjunction with the utility routines C06GBF,
+          C06GCF and C06GQF which form the complex conjugate of a Hermitian
+          or general sequence of complex data values.
+
+          3.2. Multi-dimensional Fourier Transforms
+
+          C06FUF computes a 2-dimensional discrete Fourier transform of a
+          2-dimensional sequence of complex data values. This is defined by
+
+                         n -1 n -1
+                          1    2          (   2(pi)j k )   (   2(pi)j k )
+          ^         1    --   --          (         1 1)   (         2 2)
+          z    = ------- >    >   z    exp(-i ---------)exp(-i ---------).
+                         --   --          (      n     )   (      n     )
+           k k     /n n  j =0 j =0 j j    (       1    )   (       2    )
+            1 2  \/  1 2  1    2    1 2
+
+          3.3. Convolution and Correlation
+
+          C06EKF computes either the discrete convolution or the discrete
+          correlation of two real vectors.
+
+          3.4. Index
+
+          Complex conjugate,
+               complex sequence                                      C06GCF
+               Hermitian sequence                                    C06GBF
+               multiple Hermitian sequences                          C06GQF
+          Complex sequence from Hermitian sequences                  C06GSF
+          Convolution or Correlation
+               real vectors                                          C06EKF
+          Discrete Fourier Transform
+               two-dimensional
+                    complex sequence                                 C06FUF
+               one-dimensional, multiple transforms
+                    complex sequence                                 C06FRF
+                    Hermitian sequence                               C06FQF
+                    real sequence                                    C06FPF
+               one-dimensional, single transforms
+                    complex sequence                                 C06ECF
+                    Hermitian sequence                               C06EBF
+                    real sequence                                    C06EAF
+
+
+
+          C06 -- Summation of Series                        Contents -- C06
+          Chapter C06
+
+          Summation of Series
+
+          C06EAF  Single 1-D real discrete Fourier transform, no extra
+                  workspace
+
+          C06EBF  Single 1-D Hermitian discrete Fourier transform, no extra
+                  workspace
+
+          C06ECF  Single 1-D complex discrete Fourier transform, no extra
+                  workspace
+
+          C06EKF  Circular convolution or correlation of two real vectors,
+                  no extra workspace
+
+          C06FPF  Multiple 1-D real discrete Fourier transforms
+
+          C06FQF  Multiple 1-D Hermitian discrete Fourier transforms
+
+          C06FRF  Multiple 1-D complex discrete Fourier transforms
+
+          C06FUF  2-D complex discrete Fourier transform
+
+          C06GBF  Complex conjugate of Hermitian sequence
+
+          C06GCF  Complex conjugate of complex sequence
+
+          C06GQF  Complex conjugate of multiple Hermitian sequences
+
+          C06GSF  Convert Hermitian sequences to general complex sequences
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+     C06EAF(3NAG)      Foundation Library (12/10/92)      C06EAF(3NAG)
+
+          C06 -- Summation of Series                                 C06EAF
+                  C06EAF -- NAG Foundation Library Routine Document
+
+          Note: Before using this routine, please read the Users' Note for
+          your implementation to check implementation-dependent details.
+          The symbol (*) after a NAG routine name denotes a routine that is
+          not included in the Foundation Library.
+
+          1. Purpose
+
+          C06EAF calculates the discrete Fourier transform of a sequence of
+          n real data values. (No extra workspace required.)
+
+          2. Specification
+
+                 SUBROUTINE C06EAF (X, N, IFAIL)
+                 INTEGER          N, IFAIL
+                 DOUBLE PRECISION X(N)
+
+          3. Description
+
+          Given a sequence of n real data values x , for j=0,1,...,n-1,
+                                                  j
+          this routine calculates their discrete Fourier transform defined
+          by:
+
+                            n-1
+                    ^    1  --       (   2(pi)jk)
+                    z = --- >  x *exp(-i -------), k=0,1,...,n-1.
+                     k      --  j    (      n   )
+                        \/n j=0
+
+                                      1
+          (Note the scale factor of  --- in this definition.) The
+                                       
+
+                                     \/n
+                             ^
+          transformed values z  are complex, but they form a Hermitian
+                              k
+                          ^                                ^
+          sequence (i.e., z    is the complex conjugate of z ), so they are
+                           n-k                              k
+          completely determined by n real numbers (see also the Chapter
+          Introduction).
+
+          To compute the inverse discrete Fourier transform defined by:
+
+                                   n-1
+                           ^    1  --       (   2(pi)jk)
+                           w = --- >  x *exp(+i -------),
+                            k      --  j    (      n   )
+                               \/n j=0
+
+          this routine should be followed by a call of C06GBF to form the
+                                    ^
+          complex conjugates of the z .
+                                     k
+
+          The routine uses the fast Fourier transform (FFT) algorithm
+          (Brigham [1]). There are some restrictions on the value of n (see
+          Section 5).
+
+          4. References
+
+          [1]   Brigham E O (1973) The Fast Fourier Transform. Prentice-
+                Hall.
+
+          5. Parameters
+
+           1:  X(N) -- DOUBLE PRECISION array                  Input/Output
+               On entry: if X is declared with bounds (0:N-1) in the (sub)
+               program from which C06EAF is called, then X(j) must contain
+               x , for j=0,1,...,n-1. On exit: the discrete Fourier
+                j
+               transform stored in Hermitian form. If the components of the
+                         ^
+               transform z  are written as a +ib , and if X is declared
+                          k                 k   k
+               with bounds (0:N-1) in the (sub)program from which C06EAF is
+               called, then for 0<=k<=n/2, a  is contained in X(k), and for
+                                            k
+               1<=k<=(n-1)/2, b  is contained in X(n-k). (See also Section
+                               k
+               2.1.2 of the Chapter Introduction, and the Example Program.)
+
+           2:  N -- INTEGER                                           Input
+               On entry: the number of data values, n. The largest prime
+               factor of N must not exceed 19, and the total number of
+               prime factors of N, counting repetitions, must not exceed
+               20. Constraint: N > 1.
+
+           3:  IFAIL -- INTEGER                                Input/Output
+               On entry: IFAIL must be set to 0, -1 or 1. For users not
+               familiar with this parameter (described in the Essential
+               Introduction) the recommended value is 0.
+
+               On exit: IFAIL = 0 unless the routine detects an error (see
+               Section 6).
+
+          6. Error Indicators and Warnings
+
+          Errors detected by the routine:
+
+          IFAIL= 1
+               At least one of the prime factors of N is greater than 19.
+
+          IFAIL= 2
+               N has more than 20 prime factors.
+
+          IFAIL= 3
+               N <= 1.
+
+          7. Accuracy
+
+          Some indication of accuracy can be obtained by performing a
+          subsequent inverse transform and comparing the results with the
+          original sequence (in exact arithmetic they would be identical).
+
+          8. Further Comments
+
+          The time taken by the routine is approximately proportional to
+          n*logn, but also depends on the factorization of n. The routine
+          is somewhat faster than average if the only prime factors of n
+          are 2, 3 or 5; and fastest of all if n is a power of 2.
+
+          On the other hand, the routine is particularly slow if n has
+          several unpaired prime factors, i.e., if the 'square-free' part
+          of n has several factors. For such values of n, routine C06FAF(*)
+          (which requires an additional n elements of workspace) is
+          considerably faster.
+
+          9. Example
+
+          This program reads in a sequence of real data values, and prints
+          their discrete Fourier transform (as computed by C06EAF), after
+          expanding it from Hermitian form into a full complex sequence.
+
+          It then performs an inverse transform using C06GBF and C06EBF,
+          and prints the sequence so obtained alongside the original data
+          values.
+
+          The example program is not reproduced here. The source code for
+          all example programs is distributed with the NAG Foundation
+          Library software and should be available on-line.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+     C06EBF(3NAG)      Foundation Library (12/10/92)      C06EBF(3NAG)
+
+          C06 -- Summation of Series                                 C06EBF
+                  C06EBF -- NAG Foundation Library Routine Document
+
+          Note: Before using this routine, please read the Users' Note for
+          your implementation to check implementation-dependent details.
+          The symbol (*) after a NAG routine name denotes a routine that is
+          not included in the Foundation Library.
+
+          1. Purpose
+
+          C06EBF calculates the discrete Fourier transform of a Hermitian
+          sequence of n complex data values. (No extra workspace required.)
+
+          2. Specification
+
+                 SUBROUTINE C06EBF (X, N, IFAIL)
+                 INTEGER          N, IFAIL
+                 DOUBLE PRECISION X(N)
+
+          3. Description
+
+          Given a Hermitian sequence of n complex data values z  (i.e., a
+                                                               j
+          sequence such that z  is real and z    is the complex conjugate
+                              0              n-j
+          of z , for j=1,2,...,n-1) this routine calculates their discrete
+              j
+          Fourier transform defined by:
+
+                            n-1
+                    ^    1  --       (   2(pi)jk)
+                    x = --- >  z *exp(-i -------), k=0,1,...,n-1.
+                     k      --  j    (      n   )
+                        \/n j=0
+
+                                      1
+          (Note the scale factor of  --- in this definition.) The
+                                       
+
+                                     \/n
+                             ^
+          transformed values x  are purely real (see also the the Chapter
+                              k
+          Introduction).
+
+          To compute the inverse discrete Fourier transform defined by:
+
+                                   n-1
+                           ^    1  --       (   2(pi)jk)
+                           y = --- >  z *exp(+i -------),
+                            k      --  j    (      n   )
+                               \/n j=0
+
+          this routine should be preceded by a call of C06GBF to form the
+          complex conjugates of the z .
+                                     j
+
+          The routine uses the fast Fourier transform (FFT) algorithm
+          (Brigham [1]). There are some restrictions on the value of n (see
+          Section 5).
+
+          4. References
+
+          [1]   Brigham E O (1973) The Fast Fourier Transform. Prentice-
+                Hall.
+
+          5. Parameters
+
+           1:  X(N) -- DOUBLE PRECISION array                  Input/Output
+               On entry: the sequence to be transformed stored in
+               Hermitian form. If the data values z  are written as x +iy ,
+                                                   j                 j   j
+               and if X is declared with bounds (0:N-1) in the subroutine
+               from which C06EBF is called, then for 0<=j<=n/2, x  is
+                                                                 j
+               contained in X(j), and for 1<=j<=(n-1)/2, y  is contained in
+                                                          j
+               X(n-j). (See also Section 2.1.2 of the Chapter Introduction
+               and the Example Program.) On exit: the components of the
+                                          ^
+               discrete Fourier transform x . If X is declared with bounds
+                                           k
+               (0:N-1) in the (sub)program from which C06EBF is called,
+                    ^
+               then x  is stored in X(k), for k=0,1,...,n-1.
+                     k
+
+           2:  N -- INTEGER                                           Input
+               On entry: the number of data values, n. The largest prime
+               factor of N must not exceed 19, and the total number of
+               prime factors of N, counting repetitions, must not exceed
+               20. Constraint: N > 1.
+
+           3:  IFAIL -- INTEGER                                Input/Output
+               On entry: IFAIL must be set to 0, -1 or 1. For users not
+               familiar with this parameter (described in the Essential
+               Introduction) the recommended value is 0.
+
+               On exit: IFAIL = 0 unless the routine detects an error (see
+               Section 6).
+
+          6. Error Indicators and Warnings
+
+          Errors detected by the routine:
+
+          IFAIL= 1
+               At least one of the prime factors of N is greater than 19.
+
+          IFAIL= 2
+               N has more than 20 prime factors.
+
+          IFAIL= 3
+               N <= 1.
+
+          7. Accuracy
+
+          Some indication of accuracy can be obtained by performing a
+          subsequent inverse transform and comparing the results with the
+          original sequence (in exact arithmetic they would be identical).
+
+          8. Further Comments
+
+          The time taken by the routine is approximately proportional to
+          n*logn, but also depends on the factorization of n. The routine
+          is somewhat faster than average if the only prime factors of n
+          are 2, 3 or 5; and fastest of all if n is a power of 2.
+
+          On the other hand, the routine is particularly slow if n has
+          several unpaired prime factors, i.e., if the 'square-free' part
+          of n has several factors. For such values of n, routine C06FBF(*)
+          (which requires an additional n elements of workspace) is
+          considerably faster.
+
+          9. Example
+
+          This program reads in a sequence of real data values which is
+          assumed to be a Hermitian sequence of complex data values stored
+          in Hermitian form. The input sequence is expanded into a full
+          complex sequence and printed alongside the original sequence. The
+          discrete Fourier transform (as computed by C06EBF) is printed
+          out.
+
+          The program then performs an inverse transform using C06EAF and
+          C06GBF, and prints the sequence so obtained alongside the
+          original data values.
+
+          The example program is not reproduced here. The source code for
+          all example programs is distributed with the NAG Foundation
+          Library software and should be available on-line.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+     C06ECF(3NAG)      Foundation Library (12/10/92)      C06ECF(3NAG)
+
+          C06 -- Summation of Series                                 C06ECF
+                  C06ECF -- NAG Foundation Library Routine Document
+
+          Note: Before using this routine, please read the Users' Note for
+          your implementation to check implementation-dependent details.
+          The symbol (*) after a NAG routine name denotes a routine that is
+          not included in the Foundation Library.
+
+          1. Purpose
+
+          C06ECF calculates the discrete Fourier transform of a sequence of
+          n complex data values. (No extra workspace required.)
+
+          2. Specification
+
+                 SUBROUTINE C06ECF (X, Y, N, IFAIL)
+                 INTEGER          N, IFAIL
+                 DOUBLE PRECISION X(N), Y(N)
+
+          3. Description
+
+          Given a sequence of n complex data values z , for j=0,1,...,n-1,
+                                                     j
+          this routine calculates their discrete Fourier transform defined
+          by:
+
+                            n-1
+                    ^    1  --       (   2(pi)jk)
+                    z = --- >  z *exp(-i -------), k=0,1,...,n-1.
+                     k      --  j    (      n   )
+                        \/n j=0
+
+                                      1
+          (Note the scale factor of  --- in this definition.)
+                                       
+
+                                     \/n
+
+          To compute the inverse discrete Fourier transform defined by:
+
+                                   n-1
+                           ^    1  --       (   2(pi)jk)
+                           w = --- >  z *exp(+i -------),
+                            k      --  j    (      n   )
+                               \/n j=0
+
+          this routine should be preceded and followed by calls of C06GCF
+                                                           ^
+          to form the complex conjugates of the z  and the z .
+                                                 j          k
+
+          The routine uses the fast Fourier transform (FFT) algorithm
+          (Brigham [1]). There are some restrictions on the value of n (see
+          Section 5).
+
+          4. References
+
+          [1]   Brigham E O (1973) The Fast Fourier Transform. Prentice-
+                Hall.
+
+          5. Parameters
+
+           1:  X(N) -- DOUBLE PRECISION array                  Input/Output
+               On entry: if X is declared with bounds (0:N-1) in the (sub)
+               program from which C06ECF is called, then X(j) must contain
+               x , the real part of z , for j=0,1,...,n-1. On exit: the
+                j                    j
+               real parts a  of the components of the discrete Fourier
+                           k
+               transform. If X is declared with bounds (0:N-1) in the (sub)
+               program from which C06ECF is called, then a  is contained in
+                                                          k
+               X(k), for k=0,1,...,n-1.
+
+           2:  Y(N) -- DOUBLE PRECISION array                  Input/Output
+               On entry: if Y is declared with bounds (0:N-1) in the (sub)
+               program from which C06ECF is called, then Y(j) must contain
+               y , the imaginary part of z , for j=0,1,...,n-1. On exit:
+                j                         j
+               the imaginary parts b  of the components of the discrete
+                                    k
+               Fourier transform. If Y is declared with bounds (0:N-1) in
+               the (sub)program from which C06ECF is called, then b  is
+                                                                   k
+               contained in Y(k), for k=0,1,...,n-1.
+
+           3:  N -- INTEGER                                           Input
+               On entry: the number of data values, n. The largest prime
+               factor of N must not exceed 19, and the total number of
+               prime factors of N, counting repetitions, must not exceed
+               20. Constraint: N > 1.
+
+           4:  IFAIL -- INTEGER                                Input/Output
+               On entry: IFAIL must be set to 0, -1 or 1. For users not
+               familiar with this parameter (described in the Essential
+               Introduction) the recommended value is 0.
+
+               On exit: IFAIL = 0 unless the routine detects an error (see
+               Section 6).
+
+          6. Error Indicators and Warnings
+
+          Errors detected by the routine:
+
+          IFAIL= 1
+               At least one of the prime factors of N is greater than 19.
+
+          IFAIL= 2
+               N has more than 20 prime factors.
+
+          IFAIL= 3
+               N <= 1.
+
+          7. Accuracy
+
+          Some indication of accuracy can be obtained by performing a
+          subsequent inverse transform and comparing the results with the
+          original sequence (in exact arithmetic they would be identical).
+
+          8. Further Comments
+
+          The time taken by the routine is approximately proportional to
+          n*logn, but also depends on the factorization of n. The routine
+          is somewhat faster than average if the only prime factors of n
+          are 2, 3 or 5; and fastest of all if n is a power of 2.
+
+          On the other hand, the routine is particularly slow if n has
+          several unpaired prime factors, i.e., if the 'square-free' part
+          of n has several factors. For such values of n, routine C06FCF(*)
+          (which requires an additional n real elements of workspace) is
+          considerably faster.
+
+          9. Example
+
+          This program reads in a sequence of complex data values and
+          prints their discrete Fourier transform.
+
+          It then performs an inverse transform using C06GCF and C06ECF,
+          and prints the sequence so obtained alongside the original data
+          values.
+
+          The example program is not reproduced here. The source code for
+          all example programs is distributed with the NAG Foundation
+          Library software and should be available on-line.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+     C06EKF(3NAG)      Foundation Library (12/10/92)      C06EKF(3NAG)
+
+          C06 -- Summation of Series                                 C06EKF
+                  C06EKF -- NAG Foundation Library Routine Document
+
+          Note: Before using this routine, please read the Users' Note for
+          your implementation to check implementation-dependent details.
+          The symbol (*) after a NAG routine name denotes a routine that is
+          not included in the Foundation Library.
+
+          1. Purpose
+
+          C06EKF calculates the circular convolution or correlation of two
+          real vectors of period n. No extra workspace is required.
+
+          2. Specification
+
+                 SUBROUTINE C06EKF (JOB, X, Y, N, IFAIL)
+                 INTEGER          JOB, N, IFAIL
+                 DOUBLE PRECISION X(N), Y(N)
+
+          3. Description
+
+          This routine computes:
+
+          if JOB =1, the discrete convolution of x and y, defined by:
+
+                                  n-1        n-1
+                                  --         --
+                              z = >  x y   = >  x   y ;
+                               k  --  j k-j  --  k-j j
+                                  j=0        j=0
+
+          if JOB =2, the discrete correlation of x and y defined by:
+
+                                       n-1
+                                       --
+                                   w = >  x y   .
+                                    k  --  j k+j
+                                       j=0
+
+          Here x and y are real vectors, assumed to be periodic, with
+          period n, i.e., x =x    =x     =...; z and w are then also
+                           j  j+-n  j+-2n
+          periodic with period n.
+
+          Note: this usage of the terms 'convolution' and 'correlation' is
+          taken from Brigham [1]. The term 'convolution' is sometimes used
+          to denote both these computations.
+
+             ^  ^  ^     ^
+          If x, y, z and w are the discrete Fourier transforms of these
+          sequences,
+
+                        n-1
+                ^    1  --       (   2(pi)jk)
+          i.e., x = --- >  x *exp(-i -------), etc,
+                 k      --  j    (      n   )
+                    \/n j=0
+
+                ^      ^ ^
+          then  z =\/n.x y
+                 k      k k
+
+                       
+
+                ^      ^ ^
+          and   w =\/n.x y
+                 k      k k
+
+          (the bar denoting complex conjugate).
+
+          This routine calls the same auxiliary routines as C06EAF and
+          C06EBF to compute discrete Fourier transforms, and there are some
+          restrictions on the value of n.
+
+          4. References
+
+          [1]   Brigham E O (1973) The Fast Fourier Transform. Prentice-
+                Hall.
+
+          5. Parameters
+
+           1:  JOB -- INTEGER                                         Input
+               On entry: the computation to be performed:
+                                    n-1
+                                    --
+                    if JOB = 1, z = >  x y    (convolution);
+                                 k  --  j k-j
+                                    j=0
+
+                                    n-1
+                                    --
+                    if JOB = 2, w = >  x y    (correlation).
+                                 k  --  j k+j
+                                    j=0
+               Constraint: JOB = 1 or 2.
+
+           2:  X(N) -- DOUBLE PRECISION array                  Input/Output
+               On entry: the elements of one period of the vector x. If X
+               is declared with bounds (0:N-1) in the (sub)program from
+               which C06EKF is called, then X(j) must contain x , for
+                                                               j
+               j=0,1,...,n-1. On exit: the corresponding elements of the
+               discrete convolution or correlation.
+
+           3:  Y(N) -- DOUBLE PRECISION array                  Input/Output
+               On entry: the elements of one period of the vector y. If Y
+               is declared with bounds (0:N-1) in the (sub)program from
+               which C06EKF is called, then Y(j) must contain y , for
+                                                               j
+               j=0,1,...,n-1. On exit: the discrete Fourier transform of
+               the convolution or correlation returned in the array X; the
+               transform is stored in Hermitian form, exactly as described
+               in the document  C06EAF.
+
+           4:  N -- INTEGER                                           Input
+               On entry: the number of values, n, in one period of the
+               vectors X and Y. The largest prime factor of N must not
+               exceed 19, and the total number of prime factors of N,
+               counting repetitions, must not exceed 20. Constraint: N > 1.
+
+           5:  IFAIL -- INTEGER                                Input/Output
+               On entry: IFAIL must be set to 0, -1 or 1. For users not
+               familiar with this parameter (described in the Essential
+               Introduction) the recommended value is 0.
+
+               On exit: IFAIL = 0 unless the routine detects an error (see
+               Section 6).
+
+          6. Error Indicators and Warnings
+
+          Errors detected by the routine:
+
+          IFAIL= 1
+               At least one of the prime factors of N is greater than 19.
+
+          IFAIL= 2
+               N has more than 20 prime factors.
+
+          IFAIL= 3
+               N <= 1.
+
+          IFAIL= 4
+               JOB /= 1 or 2.
+
+          7. Accuracy
+
+          The results should be accurate to within a small multiple of the
+          machine precision.
+
+          8. Further Comments
+
+          The time taken by the routine is approximately proportional to
+          n*logn, but also depends on the factorization of n. The routine
+          is faster than average if the only prime factors are 2, 3 or 5;
+          and fastest of all if n is a power of 2.
+
+          The routine is particularly slow if n has several unpaired prime
+          factors, i.e., if the 'square free' part of n has several
+          factors. For such values of n, routine C06FKF(*) is considerably
+          faster (but requires an additional workspace of n elements).
+
+          9. Example
+
+          This program reads in the elements of one period of two real
+          vectors x and y and prints their discrete convolution and
+          correlation (as computed by C06EKF). In realistic computations
+          the number of data values would be much larger.
+
+          The example program is not reproduced here. The source code for
+          all example programs is distributed with the NAG Foundation
+          Library software and should be available on-line.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+     C06FPF(3NAG)      Foundation Library (12/10/92)      C06FPF(3NAG)
+
+          C06 -- Summation of Series                                 C06FPF
+                  C06FPF -- NAG Foundation Library Routine Document
+
+          Note: Before using this routine, please read the Users' Note for
+          your implementation to check implementation-dependent details.
+          The symbol (*) after a NAG routine name denotes a routine that is
+          not included in the Foundation Library.
+
+          1. Purpose
+
+          C06FPF computes the discrete Fourier transforms of m sequences,
+          each containing n real data values. This routine is designed to
+          be particularly efficient on vector processors.
+
+          2. Specification
+
+                 SUBROUTINE C06FPF (M, N, X, INIT, TRIG, WORK, IFAIL)
+                 INTEGER          M, N, IFAIL
+                 DOUBLE PRECISION X(M*N), TRIG(2*N), WORK(M*N)
+                 CHARACTER*1      INIT
+
+          3. Description
+
+                                                   p
+          Given m sequences of n real data values x , for j=0,1,...,n-1;
+                                                   j
+          p=1,2,...,m, this routine simultaneously calculates the Fourier
+          transforms of all the sequences defined by:
+
+                     n-1
+             ^p   1  --  p    (   2(pi)jk)
+             z = --- >  x *exp(-i -------), k=0,1,...,n-1; p=1,2,...,m.
+              k      --  j    (      n   )
+                 \/n j=0
+
+                                   1
+          (Note the scale factor  --- in this definition.)
+                                    
+
+                                  \/n
+
+                                 ^p
+          The transformed values z  are complex, but for each value of p
+                                  k
+              ^p                                 ^p
+          the z  form a Hermitian sequence (i.e.,z    is the complex
+               k                                  n-k
+                       ^p
+          conjugate of z ), so they are completely determined by mn real
+                        k
+          numbers (see also the Chapter Introduction).
+
+          The discrete Fourier transform is sometimes defined using a
+          positive sign in the exponential term:
+
+                                   n-1
+                           ^p   1  --  p    (   2(pi)jk)
+                           z = --- >  x *exp(+i -------).
+                            k      --  j    (      n   )
+                               \/n j=0
+
+          To compute this form, this routine should be followed by a call
+                                                          ^p
+          to C06GQF to form the complex conjugates of the z .
+                                                           k
+
+          The routine uses a variant of the fast Fourier transform (FFT)
+          algorithm (Brigham [1]) known as the Stockham self-sorting
+          algorithm, which is described in Temperton [2]. Special coding is
+          provided for the factors 2, 3, 4, 5 and 6. This routine is
+          designed to be particularly efficient on vector processors, and
+          it becomes especially fast as M, the number of transforms to be
+          computed in parallel, increases.
+
+          4. References
+
+          [1]   Brigham E O (1973) The Fast Fourier Transform. Prentice-
+                Hall.
+
+          [2]   Temperton C (1983) Fast Mixed-Radix Real Fourier Transforms.
+                J. Comput. Phys. 52 340--350.
+
+          5. Parameters
+
+           1:  M -- INTEGER                                           Input
+               On entry: the number of sequences to be transformed, m.
+               Constraint: M >= 1.
+
+           2:  N -- INTEGER                                           Input
+               On entry: the number of real values in each sequence, n.
+               Constraint: N >= 1.
+
+           3:  X(M,N) -- DOUBLE PRECISION array                Input/Output
+               On entry: the data must be stored in X as if in a two-
+               dimensional array of dimension (1:M,0:N-1); each of the m
+               sequences is stored in a row of the array. In other words,
+               if the data values of the pth sequence to be transformed are
+                           p
+               denoted by x , for j=0,1,...,n-1, then the mn elements of
+                           j
+               the array X must contain the values
+                    1  2      m   1  2       m      1    2        m
+                   x ,x ,...,x , x ,x ,..., x ,...,x   ,x   ,...,x   .
+                    0  0      0   1  1       1      n-1  n-1      n-1
+               On exit: the m discrete Fourier transforms stored as if in
+               a two-dimensional array of dimension (1:M,0:N-1). Each of
+               the m transforms is stored in a row of the array in
+               Hermitian form, overwriting the corresponding original
+               sequence. If the n components of the discrete Fourier
+                         ^p                 p   p                       p
+               transform z  are written as a +ib , then for 0<=k<=n/2, a
+                          k                 k   k                       k
+                                                               p
+               is contained in X(p,k), and for 1<=k<=(n-1)/2, b  is
+                                                               k
+               contained in X(p,n-k). (See also Section 2.1.2 of the
+               Chapter Introduction.)
+
+           4:  INIT -- CHARACTER*1                                    Input
+               On entry: if the trigonometric coefficients required to
+               compute the transforms are to be calculated by the routine
+               and stored in the array TRIG, then INIT must be set equal to
+               'I' (Initial call).
+
+               If INIT contains 'S' (Subsequent call), then the routine
+               assumes that trigonometric coefficients for the specified
+               value of n are supplied in the array TRIG, having been
+               calculated in a previous call to one of C06FPF, C06FQF or
+               C06FRF.
+
+               If INIT contains 'R' (Restart then the routine assumes that
+               trigonometric coefficients for the particular value of n are
+               supplied in the array TRIG, but does not check that C06FPF,
+               C06FQF or C06FRF have previously been called. This option
+               allows the TRIG array to be stored in an external file, read
+               in and re-used without the need for a call with INIT equal
+               to 'I'. The routine carries out a simple test to check that
+               the current value of n is consistent with the array TRIG.
+               Constraint: INIT = 'I', 'S' or 'R'.
+
+           5:  TRIG(2*N) -- DOUBLE PRECISION array             Input/Output
+               On entry: if INIT = 'S' or 'R', TRIG must contain the
+               required coefficients calculated in a previous call of the
+               routine. Otherwise TRIG need not be set. On exit: TRIG
+               contains the required coefficients (computed by the routine
+               if INIT = 'I').
+
+           6:  WORK(M*N) -- DOUBLE PRECISION array                Workspace
+
+           7:  IFAIL -- INTEGER                                Input/Output
+               On entry: IFAIL must be set to 0, -1 or 1. For users not
+               familiar with this parameter (described in the Essential
+               Introduction) the recommended value is 0.
+
+               On exit: IFAIL = 0 unless the routine detects an error (see
+               Section 6).
+
+
+          6. Error Indicators and Warnings
+
+          Errors detected by the routine:
+
+          If on entry IFAIL = 0 or -1, explanatory error messages are
+          output on the current error message unit (as defined by X04AAF).
+
+          IFAIL= 1
+               On entry M < 1.
+
+          IFAIL= 2
+               N < 1.
+
+          IFAIL= 3
+               INIT is not one of 'I', 'S' or 'R'.
+
+          IFAIL= 4
+               INIT = 'S', but none of C06FPF, C06FQF or C06FRF has
+               previously been called.
+
+          IFAIL= 5
+               INIT = 'S' or 'R', but the array TRIG and the current value
+               of N are inconsistent.
+
+          7. Accuracy
+
+          Some indication of accuracy can be obtained by performing a
+          subsequent inverse transform and comparing the results with the
+          original sequence (in exact arithmetic they would be identical).
+
+          8. Further Comments
+
+          The time taken by the routine is approximately proportional to
+          nm*logn, but also depends on the factors of n. The routine is
+          fastest if the only prime factors of n are 2, 3 and 5, and is
+          particularly slow if n is a large prime, or has large prime
+          factors.
+
+          9. Example
+
+          This program reads in sequences of real data values and prints
+          their discrete Fourier transforms (as computed by C06FPF). The
+          Fourier transforms are expanded into full complex form using
+          C06GSF and printed. Inverse transforms are then calculated by
+          calling C06GQF followed by C06FQF showing that the original
+          sequences are restored.
+
+          The example program is not reproduced here. The source code for
+          all example programs is distributed with the NAG Foundation
+          Library software and should be available on-line.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+     C06FQF(3NAG)      Foundation Library (12/10/92)      C06FQF(3NAG)
+
+          C06 -- Summation of Series                                 C06FQF
+                  C06FQF -- NAG Foundation Library Routine Document
+
+          Note: Before using this routine, please read the Users' Note for
+          your implementation to check implementation-dependent details.
+          The symbol (*) after a NAG routine name denotes a routine that is
+          not included in the Foundation Library.
+
+          1. Purpose
+
+          C06FQF computes the discrete Fourier transforms of m Hermitian
+          sequences, each containing n complex data values. This routine is
+          designed to be particularly efficient on vector processors.
+
+          2. Specification
+
+                 SUBROUTINE C06FQF (M, N, X, INIT, TRIG, WORK, IFAIL)
+                 INTEGER          M, N, IFAIL
+                 DOUBLE PRECISION X(M*N), TRIG(2*N), WORK(M*N)
+                 CHARACTER*1      INIT
+
+          3. Description
+
+                                                                p
+          Given m Hermitian sequences of n complex data values z , for
+                                                                j
+          j=0,1,...,n-1; p=1,2,...,m, this routine simultaneously
+          calculates the Fourier transforms of all the sequences defined
+          by:
+
+                     n-1
+             ^p   1  --  p    (   2(pi)jk)
+             x = --- >  z *exp(-i -------), k=0,1,...,n-1; p=1,2,...,m.
+              k      --  j    (      n   )
+                 \/n j=0
+
+                                   1
+          (Note the scale factor  --- in this definition.)
+                                    
+
+                                  \/n
+
+          The transformed values are purely real (see also the Chapter
+          Introduction).
+
+          The discrete Fourier transform is sometimes defined using a
+          positive sign in the exponential term
+
+                                   n-1
+                           ^p   1  --  p    (   2(pi)jk)
+                           x = --- >  z *exp(+i -------).
+                            k      --  j    (      n   )
+                               \/n j=0
+
+          To compute this form, this routine should be preceded by a call
+                                                          ^p
+          to C06GQF to form the complex conjugates of the z .
+                                                           j
+
+          The routine uses a variant of the fast Fourier transform (FFT)
+          algorithm (Brigham [1]) known as the Stockham self-sorting
+          algorithm, which is described in Temperton [2]. Special code is
+          included for the factors 2, 3, 4, 5 and 6. This routine is
+          designed to be particularly efficient on vector processors, and
+          it becomes especially fast as m, the number of transforms to be
+          computed in parallel, increases.
+
+          4. References
+
+          [1]   Brigham E O (1973) The Fast Fourier Transform. Prentice-
+                Hall.
+
+          [2]   Temperton C (1983) Fast Mixed-Radix Real Fourier Transforms.
+                J. Comput. Phys. 52 340--350.
+
+          5. Parameters
+
+           1:  M -- INTEGER                                           Input
+               On entry: the number of sequences to be transformed, m.
+               Constraint: M >= 1.
+
+           2:  N -- INTEGER                                           Input
+               On entry: the number of data values in each sequence, n.
+               Constraint: N >= 1.
+
+           3:  X(M,N) -- DOUBLE PRECISION array                Input/Output
+               On entry: the data must be stored in X as if in a two-
+               dimensional array of dimension (1:M,0:N-1); each of the m
+               sequences is stored in a row of the array in Hermitian form.
+                                     p                 p   p
+               If the n data values z  are written as x +iy , then for
+                                     j                 j   j
+                           p
+               0<=j<=n/2, x  is contained in X(p,j), and for 1<=j<=(n-1)/2,
+                           j
+                p
+               y  is contained in X(p,n-j). (See also Section 2.1.2 of the
+                j
+               Chapter Introduction.) On exit: the components of the m
+               discrete Fourier transforms, stored as if in a two-
+               dimensional array of dimension (1:M,0:N-1). Each of the m
+               transforms is stored as a row of the array, overwriting the
+               corresponding original sequence. If the n components of the
+                                                         ^p
+               discrete Fourier transform are denoted by x , for
+                                                          k
+               k=0,1,...,n-1, then the mn elements of the array X contain
+               the values
+                   ^1 ^2     ^m  ^1 ^2      ^m     ^1   ^2       ^m
+                   x ,x ,...,x , x ,x ,..., x ,...,x   ,x   ,...,x   .
+                    0  0      0   1  1       1      n-1  n-1      n-1
+
+           4:  INIT -- CHARACTER*1                                    Input
+               On entry: if the trigonometric coefficients required to
+               compute the transforms are to be calculated by the routine
+               and stored in the array TRIG, then INIT must be set equal to
+               'I' (Initial call).
+
+               If INIT contains 'S' (Subsequent call), then the routine
+               assumes that trigonometric coefficients for the specified
+               value of n are supplied in the array TRIG, having been
+               calculated in a previous call to one of C06FPF, C06FQF or
+               C06FRF.
+
+               If INIT contains 'R' (Restart), then the routine assumes
+               that trigonometric coefficients for the particular value of
+               N are supplied in the array TRIG, but does not check that
+               C06FPF, C06FQF or C06FRF have previously been called. This
+               option allows the TRIG array to be stored in an external
+               file, read in and re-used without the need for a call with
+               INIT equal to 'I'. The routine carries out a simple test to
+               check that the current value of n is compatible with the
+               array TRIG. Constraint: INIT = 'I', 'S' or 'R'.
+
+           5:  TRIG(2*N) -- DOUBLE PRECISION array             Input/Output
+               On entry: if INIT = 'S' or 'R', TRIG must contain the
+               required coefficients calculated in a previous call of the
+               routine. Otherwise TRIG need not be set. On exit: TRIG
+               contains the required coefficients (computed by the routine
+               if INIT = 'I').
+
+           6:  WORK(M*N) -- DOUBLE PRECISION array                Workspace
+
+           7:  IFAIL -- INTEGER                                Input/Output
+               On entry: IFAIL must be set to 0, -1 or 1. For users not
+               familiar with this parameter (described in the Essential
+               Introduction) the recommended value is 0.
+
+               On exit: IFAIL = 0 unless the routine detects an error (see
+               Section 6).
+
+          6. Error Indicators and Warnings
+
+          Errors detected by the routine:
+
+          If on entry IFAIL = 0 or -1, explanatory error messages are
+          output on the current error message unit (as defined by X04AAF).
+
+          IFAIL= 1
+               On entry M < 1.
+
+          IFAIL= 2
+               On entry N < 1.
+
+          IFAIL= 3
+               On entry INIT is not one of 'I', 'S' or 'R'.
+
+          IFAIL= 4
+               On entry INIT = 'S', but none of C06FPF, C06FQF and C06FRF
+               has previously been called.
+
+          IFAIL= 5
+               On entry INIT = 'S' or 'R', but the array TRIG and the
+               current value of n are inconsistent.
+
+          7. Accuracy
+
+          Some indication of accuracy can be obtained by performing a
+          subsequent inverse transform and comparing the results with the
+          original sequence (in exact arithmetic they would be identical).
+
+          8. Further Comments
+
+          The time taken by the routine is approximately proportional to
+          nm*logn, but also depends on the factors of n. The routine is
+          fastest if the only prime factors of n are 2, 3 and 5, and is
+          particularly slow if n is a large prime, or has large prime
+          factors.
+
+          9. Example
+
+          This program reads in sequences of real data values which are
+          assumed to be Hermitian sequences of complex data stored in
+          Hermitian form. The sequences are expanded into full complex form
+          using C06GSF and printed. The discrete Fourier transforms are
+          then computed (using C06FQF) and printed out. Inverse transforms
+          are then calculated by calling C06FPF followed by C06GQF showing
+          that the original sequences are restored.
+
+          The example program is not reproduced here. The source code for
+          all example programs is distributed with the NAG Foundation
+          Library software and should be available on-line.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+     C06FRF(3NAG)      Foundation Library (12/10/92)      C06FRF(3NAG)
+
+          C06 -- Summation of Series                                 C06FRF
+                  C06FRF -- NAG Foundation Library Routine Document
+
+          Note: Before using this routine, please read the Users' Note for
+          your implementation to check implementation-dependent details.
+          The symbol (*) after a NAG routine name denotes a routine that is
+          not included in the Foundation Library.
+
+          1. Purpose
+
+          C06FRF computes the discrete Fourier transforms of m sequences,
+          each containing n complex data values. This routine is designed
+          to be particularly efficient on vector processors.
+
+          2. Specification
+
+                 SUBROUTINE C06FRF (M, N, X, Y, INIT, TRIG, WORK, IFAIL)
+                 INTEGER          M, N, IFAIL
+                 DOUBLE PRECISION X(M*N), Y(M*N), TRIG(2*N), WORK(2*M*N)
+                 CHARACTER*1      INIT
+
+          3. Description
+
+                                                      p
+          Given m sequences of n complex data values z , for j=0,1,...,n-1;
+                                                      j
+          p=1,2,...,m, this routine simultaneously calculates the Fourier
+          transforms of all the sequences defined by:
+
+                     n-1
+             ^p   1  --  p    (   2(pi)jk)
+             z = --- >  z *exp(-i -------), k=0,1,...,n-1; p=1,2,...,m.
+              k      --  j    (      n   )
+                 \/n j=0
+
+                                   1
+          (Note the scale factor  --- in this definition.)
+                                    
+
+                                  \/n
+
+          The discrete Fourier transform is sometimes defined using a
+          positive sign in the exponential term
+
+                                   n-1
+                           ^p   1  --  p    (   2(pi)jk)
+                           z = --- >  z *exp(+i -------).
+                            k      --  j    (      n   )
+                               \/n j=0
+
+          To compute this form, this routine should be preceded and
+          followed by a call of C06GCF to form the complex conjugates of
+               p         ^p
+          the z  and the z .
+               j          k
+
+          The routine uses a variant of the fast Fourier transform (FFT)
+          algorithm (Brigham [1]) known as the Stockham self-sorting
+          algorithm, which is described in Temperton [2]. Special code is
+          provided for the factors 2, 3, 4, 5 and 6. This routine is
+          designed to be particularly efficient on vector processors, and
+          it becomes especially fast as m, the number of transforms to be
+          computed in parallel, increases.
+
+          4. References
+
+          [1]   Brigham E O (1973) The Fast Fourier Transform. Prentice-
+                Hall.
+
+          [2]   Temperton C (1983) Self-sorting Mixed-radix Fast Fourier
+                Transforms. J. Comput. Phys. 52 1--23.
+
+          5. Parameters
+
+           1:  M -- INTEGER                                           Input
+               On entry: the number of sequences to be transformed, m.
+               Constraint: M >= 1.
+
+           2:  N -- INTEGER                                           Input
+               On entry: the number of complex values in each sequence, n.
+               Constraint: N >= 1.
+
+           3:  X(M,N) -- DOUBLE PRECISION array                Input/Output
+
+           4:  Y(M,N) -- DOUBLE PRECISION array                Input/Output
+               On entry: the real and imaginary parts of the complex data
+               must be stored in X and Y respectively as if in a two-
+               dimensional array of dimension (1:M,0:N-1); each of the m
+               sequences is stored in a row of each array. In other words,
+               if the real parts of the pth sequence to be transformed are
+                           p
+               denoted by x , for j=0,1,...,n-1, then the mn elements of
+                           j
+               the array X must contain the values
+                    1  2      m   1  2      m       1    2        m
+                   x ,x ,...,x , x ,x ,...,x ,..., x   ,x   ,...,x   .
+                    0  0      0   1  1      1       n-1  n-1      n-1
+               On exit: X and Y are overwritten by the real and imaginary
+               parts of the complex transforms.
+
+           5:  INIT -- CHARACTER*1                                    Input
+               On entry: if the trigonometric coefficients required to
+               compute the transforms are to be calculated by the routine
+               and stored in the array TRIG, then INIT must be set equal to
+               'I' (Initial call).
+
+               If INIT contains 'S' (Subsequent call), then the routine
+               assumes that trigonometric coefficients for the specified
+               value of n are supplied in the array TRIG, having been
+               calculated in a previous call to one of C06FPF, C06FQF or
+               C06FRF.
+
+               If INIT contains 'R' (Restart) then the routine assumes that
+               trigonometric coefficients for the particular value of n are
+               supplied in the array TRIG, but does not check that C06FPF,
+               C06FQF or C06FRF have previously been called. This option
+               allows the TRIG array to be stored in an external file, read
+               in and re-used without the need for a call with INIT equal
+               to 'I'. The routine carries out a simple test to check that
+               the current value of n is compatible with the array TRIG.
+               Constraint: INIT = 'I', 'S' or 'R'.
+
+           6:  TRIG(2*N) -- DOUBLE PRECISION array             Input/Output
+               On entry: if INIT = 'S' or 'R', TRIG must contain the
+               required coefficients calculated in a previous call of the
+               routine. Otherwise TRIG need not be set. On exit: TRIG
+               contains the required coefficients (computed by the routine
+               if INIT = 'I').
+
+           7:  WORK(2*M*N) -- DOUBLE PRECISION array              Workspace
+
+           8:  IFAIL -- INTEGER                                Input/Output
+               On entry: IFAIL must be set to 0, -1 or 1. For users not
+               familiar with this parameter (described in the Essential
+               Introduction) the recommended value is 0.
+
+               On exit: IFAIL = 0 unless the routine detects an error (see
+               Section 6).
+
+          6. Error Indicators and Warnings
+
+          Errors detected by the routine:
+
+          If on entry IFAIL = 0 or -1, explanatory error messages are
+          output on the current error message unit (as defined by X04AAF).
+
+          IFAIL= 1
+               On entry M < 1.
+
+          IFAIL= 2
+               On entry N < 1.
+
+          IFAIL= 3
+               On entry INIT is not one of 'I', 'S' or 'R'.
+
+          IFAIL= 4
+               On entry INIT = 'S', but none of C06FPF, C06FQF and C06FRF
+               has previously been called.
+
+          IFAIL= 5
+               On entry INIT = 'S' or 'R', but the array TRIG and the
+               current value of n are inconsistent.
+
+          7. Accuracy
+
+          Some indication of accuracy can be obtained by performing a
+          subsequent inverse transform and comparing the results with the
+          original sequence (in exact arithmetic they would be identical).
+
+          8. Further Comments
+
+          The time taken by the routine is approximately proportional to
+          nm*logn, but also depends on the factors of n. The routine is
+          fastest if the only prime factors of n are 2, 3 and 5, and is
+          particularly slow if n is a large prime, or has large prime
+          factors.
+
+          9. Example
+
+          This program reads in sequences of complex data values and prints
+          their discrete Fourier transforms (as computed by C06FRF).
+          Inverse transforms are then calculated using C06GCF and C06FRF
+          and printed out, showing that the original sequences are
+          restored.
+
+          The example program is not reproduced here. The source code for
+          all example programs is distributed with the NAG Foundation
+          Library software and should be available on-line.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+     C06FUF(3NAG)      Foundation Library (12/10/92)      C06FUF(3NAG)
+
+          C06 -- Summation of Series                                 C06FUF
+                  C06FUF -- NAG Foundation Library Routine Document
+
+          Note: Before using this routine, please read the Users' Note for
+          your implementation to check implementation-dependent details.
+          The symbol (*) after a NAG routine name denotes a routine that is
+          not included in the Foundation Library.
+
+          1. Purpose
+
+          C06FUF computes the two-dimensional discrete Fourier transform of
+          a bivariate sequence of complex data values. This routine is
+          designed to be particularly efficient on vector processors.
+
+          2. Specification
+
+                 SUBROUTINE C06FUF (M, N, X, Y, INIT, TRIGM, TRIGN, WORK,
+                1                   IFAIL)
+                 INTEGER          M, N, IFAIL
+                 DOUBLE PRECISION X(M*N), Y(M*N), TRIGM(2*M), TRIGN(2*N),
+                1                 WORK(2*M*N)
+                 CHARACTER*1      INIT
+
+          3. Description
+
+          This routine computes the two-dimensional discrete Fourier
+          transform of a bivariate sequence of complex data values z    ,
+                                                                    j j
+                                                                     1 2
+          where j =0,1,...,m-1, j =0,1,...,n-1.
+                 1               2
+
+          The discrete Fourier transform is here defined by:
+
+                            m-1  n-1          (       ( j k   j k ))
+                ^       1   --   --           (       (  1 1   2 2))
+                z    = ---- >    >   z    *exp(-2(pi)i( ----+ ----)),
+                            --   --   j j     (       (  m     n  ))
+                 k k   \/mn j =0 j =0  1 2
+                  1 2        1    2
+
+          where k =0,1,...,m-1, k =0,1,...,n-1.
+                 1               2
+
+                                      1
+          (Note the scale factor of  ---- in this definition.)
+                                       
+
+                                     \/mn
+
+          To compute the inverse discrete Fourier transform, defined with
+          exp(+2(pi)i(...)) in the above formula instead of exp(-
+          2(pi)i(...)), this routine should be preceded and followed by
+          calls of C06GCF to form the complex conjugates of the data values
+          and the transform.
+
+          This routine calls C06FRF to perform multiple one-dimensional
+          discrete Fourier transforms by the fast Fourier transform (FFT)
+          algorithm in Brigham [1]. It is designed to be particularly
+          efficient on vector processors.
+
+          4. References
+
+          [1]   Brigham E O (1973) The Fast Fourier Transform. Prentice-
+                Hall.
+
+          [2]   Temperton C (1983) Self-sorting Mixed-radix Fast Fourier
+                Transforms. J. Comput. Phys. 52 1--23.
+
+          5. Parameters
+
+           1:  M -- INTEGER                                           Input
+               On entry: the number of rows, m, of the arrays X and Y.
+               Constraint: M >= 1.
+
+           2:  N -- INTEGER                                           Input
+               On entry: the number of columns, n, of the arrays X and Y.
+               Constraint: N >= 1.
+
+           3:  X(M,N) -- DOUBLE PRECISION array                Input/Output
+
+           4:  Y(M,N) -- DOUBLE PRECISION array                Input/Output
+               On entry: the real and imaginary parts of the complex data
+               values must be stored in arrays X and Y respectively. If X
+               and Y are regarded as two-dimensional arrays of dimension
+               (0:M-1,0:N-1), then X(j ,j ) and Y(j ,j ) must contain the
+                                      1  2         1  2
+               real and imaginary parts of z    . On exit: the real and
+                                            j j
+                                             1 2
+               imaginary parts respectively of the corresponding elements
+               of the computed transform.
+
+           5:  INIT -- CHARACTER*1                                    Input
+               On entry: if the trigonometric coefficients required to
+               compute the transforms are to be calculated by the routine
+               and stored in the arrays TRIGM and TRIGN, then INIT must be
+               set equal to 'I', (Initial call).
+
+               If INIT contains 'S', (Subsequent call), then the routine
+               assumes that trigonometric coefficients for the specified
+               values of m and n are supplied in the arrays TRIGM and
+               TRIGN, having been calculated in a previous call to the
+               routine.
+
+               If INIT contains 'R', (Restart), then the routine assumes
+               that trigonometric coefficients for the particular values of
+               m and n are supplied in the arrays TRIGM and TRIGN, but does
+               not check that the routine has previously been called. This
+               option allows the TRIGM and TRIGN arrays to be stored in an
+               external file, read in and re-used without the need for a
+               call with INIT equal to 'I'. The routine carries out a
+               simple test to check that the current values of m and n are
+               compatible with the arrays TRIGM and TRIGN. Constraint: INIT
+               = 'I', 'S' or 'R'.
+
+           6:  TRIGM(2*M) -- DOUBLE PRECISION array            Input/Output
+
+           7:  TRIGN(2*N) -- DOUBLE PRECISION array            Input/Output
+               On entry: if INIT = 'S' or 'R',TRIGM and TRIGN must contain
+               the required coefficients calculated in a previous call of
+               the routine. Otherwise TRIGM and TRIGN need not be set.
+
+               If m=n the same array may be supplied for TRIGM and TRIGN.
+               On exit: TRIGM and TRIGN contain the required coefficients
+               (computed by the routine if INIT = 'I').
+
+           8:  WORK(2*M*N) -- DOUBLE PRECISION array              Workspace
+
+           9:  IFAIL -- INTEGER                                Input/Output
+               On entry: IFAIL must be set to 0, -1 or 1. For users not
+               familiar with this parameter (described in the Essential
+               Introduction) the recommended value is 0.
+
+               On exit: IFAIL = 0 unless the routine detects an error (see
+               Section 6).
+
+          6. Error Indicators and Warnings
+
+          Errors detected by the routine:
+
+          If on entry IFAIL = 0 or -1, explanatory error messages are
+          output on the current error message unit (as defined by X04AAF).
+
+          IFAIL= 1
+               On entry M < 1.
+
+          IFAIL= 2
+               On entry N < 1.
+
+          IFAIL= 3
+               On entry INIT is not one of 'I', 'S' or 'R'.
+
+          IFAIL= 4
+               On entry INIT = 'S', but C06FUF has not previously been
+               called.
+
+          IFAIL= 5
+               On entry INIT = 'S' or 'R', but at least one of the arrays
+               TRIGM and TRIGN is inconsistent with the current value of M
+               or N.
+
+          7. Accuracy
+
+          Some indication of accuracy can be obtained by performing a
+          subsequent inverse transform and comparing the results with the
+          original sequence (in exact arithmetic they would be identical).
+
+          8. Further Comments
+
+          The time taken by the routine is approximately proportional to
+          mn*log(mn), but also depends on the factorization of the
+          individual dimensions m and n. The routine is somewhat faster
+          than average if their only prime factors are 2, 3 or 5; and
+          fastest of all if they are powers of 2.
+
+          9. Example
+
+          This program reads in a bivariate sequence of complex data values
+          and prints the two-dimensional Fourier transform. It then
+          performs an inverse transform and prints the sequence so
+          obtained, which may be compared to the original data values.
+
+          The example program is not reproduced here. The source code for
+          all example programs is distributed with the NAG Foundation
+          Library software and should be available on-line.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+     C06GBF(3NAG)      Foundation Library (12/10/92)      C06GBF(3NAG)
+
+          C06 -- Summation of Series                                 C06GBF
+                  C06GBF -- NAG Foundation Library Routine Document
+
+          Note: Before using this routine, please read the Users' Note for
+          your implementation to check implementation-dependent details.
+          The symbol (*) after a NAG routine name denotes a routine that is
+          not included in the Foundation Library.
+
+          1. Purpose
+
+          C06GBF forms the complex conjugate of a Hermitian sequence of n
+          data values.
+
+          2. Specification
+
+                 SUBROUTINE C06GBF (X, N, IFAIL)
+                 INTEGER          N, IFAIL
+                 DOUBLE PRECISION X(N)
+
+          3. Description
+
+          This is a utility routine for use in conjunction with C06EAF,
+          C06EBF, C06FAF(*) or C06FBF(*) to calculate inverse discrete
+          Fourier transforms (see the Chapter Introduction).
+
+          4. References
+
+          None.
+
+          5. Parameters
+
+           1:  X(N) -- DOUBLE PRECISION array                  Input/Output
+               On entry: if the data values z  are written as x +iy  and
+                                             j                 j   j
+               if X is declared with bounds (0:N-1) in the (sub)program
+               from which C06GBF is called, then for 0<=j<=n/2, X(j) must
+               contain x (=x   ), while for n/2<j<=n-1, X(j) must contain
+                        j   n-j
+               -y (=y   ). In other words, X must contain the Hermitian
+                 j   n-j
+               sequence in Hermitian form. (See also Section 2.1.2 of the
+               Chapter Introduction). On exit: the imaginary parts y  are
+                                                                    j
+               negated. The real parts x  are not referenced.
+                                        j
+
+           2:  N -- INTEGER                                           Input
+               On entry: the number of data values, n. Constraint: N >= 1.
+
+           3:  IFAIL -- INTEGER                                Input/Output
+               On entry: IFAIL must be set to 0, -1 or 1. For users not
+               familiar with this parameter (described in the Essential
+               Introduction) the recommended value is 0.
+
+               On exit: IFAIL = 0 unless the routine detects an error (see
+               Section 6).
+
+          6. Error Indicators and Warnings
+
+          Errors detected by the routine:
+
+          IFAIL= 1
+               N < 1.
+
+          7. Accuracy
+
+          Exact.
+
+          8. Further Comments
+
+          The time taken by the routine is negligible.
+
+          9. Example
+
+          This program reads in a sequence of real data values, calls
+          C06EAF followed by C06GBF to compute their inverse discrete
+          Fourier transform, and prints this after expanding it from
+          Hermitian form into a full complex sequence.
+
+          The example program is not reproduced here. The source code for
+          all example programs is distributed with the NAG Foundation
+          Library software and should be available on-line.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+     C06GCF(3NAG)      Foundation Library (12/10/92)      C06GCF(3NAG)
+
+          C06 -- Summation of Series                                 C06GCF
+                  C06GCF -- NAG Foundation Library Routine Document
+
+          Note: Before using this routine, please read the Users' Note for
+          your implementation to check implementation-dependent details.
+          The symbol (*) after a NAG routine name denotes a routine that is
+          not included in the Foundation Library.
+
+          1. Purpose
+
+          C06GCF forms the complex conjugate of a sequence of n data
+          values.
+
+          2. Specification
+
+                 SUBROUTINE C06GCF (Y, N, IFAIL)
+                 INTEGER          N, IFAIL
+                 DOUBLE PRECISION Y(N)
+
+          3. Description
+
+          This is a utility routine for use in conjunction with C06ECF or
+          C06FCF(*) to calculate inverse discrete Fourier transforms (see
+          the Chapter Introduction).
+
+          4. References
+
+          None.
+
+          5. Parameters
+
+           1:  Y(N) -- DOUBLE PRECISION array                  Input/Output
+               On entry: if Y is declared with bounds (0:N-1) in the (sub)
+               program which C06GCF is called, then Y(j) must contain the
+               imaginary part of the jth data value, for 0<=j<=n-1. On
+               exit: these values are negated.
+
+           2:  N -- INTEGER                                           Input
+               On entry: the number of data values, n. Constraint: N >= 1.
+
+           3:  IFAIL -- INTEGER                                Input/Output
+               On entry: IFAIL must be set to 0, -1 or 1. For users not
+               familiar with this parameter (described in the Essential
+               Introduction) the recommended value is 0.
+
+               On exit: IFAIL = 0 unless the routine detects an error (see
+               Section 6).
+
+          6. Error Indicators and Warnings
+
+          Errors detected by the routine:
+
+          IFAIL= 1
+               N < 1.
+
+          7. Accuracy
+
+          Exact.
+
+          8. Further Comments
+
+          The time taken by the routine is negligible.
+
+          9. Example
+
+          This program reads in a sequence of complex data values and
+          prints their inverse discrete Fourier transform as computed by
+          calling C06GCF, followed by C06ECF and C06GCF again.
+
+          The example program is not reproduced here. The source code for
+          all example programs is distributed with the NAG Foundation
+          Library software and should be available on-line.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+     C06GQF(3NAG)      Foundation Library (12/10/92)      C06GQF(3NAG)
+
+          C06 -- Summation of Series                                 C06GQF
+                  C06GQF -- NAG Foundation Library Routine Document
+
+          Note: Before using this routine, please read the Users' Note for
+          your implementation to check implementation-dependent details.
+          The symbol (*) after a NAG routine name denotes a routine that is
+          not included in the Foundation Library.
+
+          1. Purpose
+
+          C06GQF forms the complex conjugates of m Hermitian sequences,
+          each containing n data values.
+
+          2. Specification
+
+                 SUBROUTINE C06GQF (M, N, X, IFAIL)
+                 INTEGER          M, N, IFAIL
+                 DOUBLE PRECISION X(M*N)
+
+          3. Description
+
+          This is a utility routine for use in conjunction with C06FPF and
+          C06FQF to calculate inverse discrete Fourier transforms (see the
+          Chapter Introduction).
+
+          4. References
+
+          None.
+
+          5. Parameters
+
+           1:  M -- INTEGER                                           Input
+               On entry: the number of Hermitian sequences to be
+               conjugated, m. Constraint: M >= 1.
+
+           2:  N -- INTEGER                                           Input
+               On entry: the number of data values in each Hermitian
+               sequence, n. Constraint: N >= 1.
+
+           3:  X(M,N) -- DOUBLE PRECISION array                Input/Output
+               On entry: the data must be stored in array X as if in a
+               two-dimensional array of dimension (1:M,0:N-1); each of the
+               m sequences is stored in a row of the array in Hermitian
+                                           p                 p   p
+               form. If the n data values z  are written as x +iy , then
+                                           j                 j   j
+                               p
+               for 0<=j<=n/2, x  is contained in X(p,j), and for 1<=j<=(n-
+                               j
+                      p
+               1)/2, y  is contained in X(p,n-j). (See also Section 2.1.2
+                      j
+               of the Chapter Introduction.) On exit: the imaginary parts
+                p                              p
+               y  are negated. The real parts x  are not referenced.
+                j                              j
+
+           4:  IFAIL -- INTEGER                                Input/Output
+               On entry: IFAIL must be set to 0, -1 or 1. For users not
+               familiar with this parameter (described in the Essential
+               Introduction) the recommended value is 0.
+
+               On exit: IFAIL = 0 unless the routine detects an error (see
+               Section 6).
+
+          6. Error Indicators and Warnings
+
+          Errors detected by the routine:
+
+          If on entry IFAIL = 0 or -1, explanatory error messages are
+          output on the current error message unit (as defined by X04AAF).
+
+          IFAIL= 1
+               On entry M < 1.
+
+          IFAIL= 2
+               On entry N < 1.
+
+          7. Accuracy
+
+          Exact.
+
+          8. Further Comments
+
+          None.
+
+          9. Example
+
+          This program reads in sequences of real data values which are
+          assumed to be Hermitian sequences of complex data stored in
+          Hermitian form. The sequences are expanded into full complex form
+          using C06GSF and printed. The sequences are then conjugated
+          (using C06GQF) and the conjugated sequences are expanded into
+          complex form using C06GSF and printed out.
+
+          The example program is not reproduced here. The source code for
+          all example programs is distributed with the NAG Foundation
+          Library software and should be available on-line.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+     C06GSF(3NAG)      Foundation Library (12/10/92)      C06GSF(3NAG)
+
+          C06 -- Summation of Series                                 C06GSF
+                  C06GSF -- NAG Foundation Library Routine Document
+
+          Note: Before using this routine, please read the Users' Note for
+          your implementation to check implementation-dependent details.
+          The symbol (*) after a NAG routine name denotes a routine that is
+          not included in the Foundation Library.
+
+          1. Purpose
+
+          C06GSF takes m Hermitian sequences, each containing n data
+          values, and forms the real and imaginary parts of the m
+          corresponding complex sequences.
+
+          2. Specification
+
+                 SUBROUTINE C06GSF (M, N, X, U, V, IFAIL)
+                 INTEGER          M, N, IFAIL
+                 DOUBLE PRECISION X(M*N), U(M*N), V(M*N)
+
+          3. Description
+
+          This is a utility routine for use in conjunction with C06FPF and
+          C06FQF (see the Chapter Introduction).
+
+          4. References
+
+          None.
+
+          5. Parameters
+
+           1:  M -- INTEGER                                           Input
+               On entry: the number of Hermitian sequences, m, to be
+               converted into complex form. Constraint: M >= 1.
+
+           2:  N -- INTEGER                                           Input
+               On entry: the number of data values, n, in each sequence.
+               Constraint: N >= 1.
+
+           3:  X(M,N) -- DOUBLE PRECISION array                       Input
+               On entry: the data must be stored in X as if in a two-
+               dimensional array of dimension (1:M,0:N-1); each of the m
+               sequences is stored in a row of the array in Hermitian form.
+                                     p                 p   p
+               If the n data values z  are written as x +iy , then for
+                                     j                 j   j
+                           p
+               0<=j<=n/2, x  is contained in X(p,j), and for 1<=j<=(n-1)/2,
+                           j
+                p
+               y  is contained in X(p,n-j). (See also Section 2.1.2 of the
+                j
+               Chapter Introduction.)
+
+           4:  U(M,N) -- DOUBLE PRECISION array                      Output
+
+           5:  V(M,N) -- DOUBLE PRECISION array                      Output
+               On exit: the real and imaginary parts of the m sequences of
+               length n, are stored in U and V respectively, as if in two-
+               dimensional arrays of dimension (1:M,0:N-1); each of the m
+               sequences is stored as if in a row of each array. In other
+               words, if the real parts of the pth sequence are denoted by
+                p
+               x , for j=0,1,...,n-1 then the mn elements of the array U
+                j
+               contain the values
+                     1  2      m   1  2      m       1    2        m
+                    x ,x ,...,x , x ,x ,...,x ,..., x   ,x   ,...,x
+                     0  0      0   1  1      1       n-1  n-1      n-1
+
+           6:  IFAIL -- INTEGER                                Input/Output
+               On entry: IFAIL must be set to 0, -1 or 1. For users not
+               familiar with this parameter (described in the Essential
+               Introduction) the recommended value is 0.
+
+               On exit: IFAIL = 0 unless the routine detects an error (see
+               Section 6).
+
+          6. Error Indicators and Warnings
+
+          Errors detected by the routine:
+
+          If on entry IFAIL = 0 or -1, explanatory error messages are
+          output on the current error message unit (as defined by X04AAF).
+
+          IFAIL= 1
+               On entry M < 1.
+
+          IFAIL= 2
+               On entry N < 1.
+
+          7. Accuracy
+
+          Exact.
+
+          8. Further Comments
+
+          None.
+
+          9. Example
+
+          This program reads in sequences of real data values which are
+          assumed to be Hermitian sequences of complex data stored in
+          Hermitian form. The sequences are then expanded into full complex
+          form using C06GSF and printed.
+
+          The example program is not reproduced here. The source code for
+          all example programs is distributed with the NAG Foundation
+          Library software and should be available on-line.
+
+@
 \pagehead{NagSeriesSummationPackage}{NAGC06}
 \pagepic{ps/v104nagseriessummationpackage.ps}{NAGC06}{1.00}
 
diff --git a/books/ps/v104applicationprograminterface.ps b/books/ps/v104applicationprograminterface.ps
new file mode 100644
index 0000000..fd9fbb7
--- /dev/null
+++ b/books/ps/v104applicationprograminterface.ps
@@ -0,0 +1,281 @@
+%!PS-Adobe-2.0
+%%Creator: Graphviz version 2.16.1 (Mon Jul  7 18:20:33 UTC 2008)
+%%For: (root) root
+%%Title: pic
+%%Pages: (atend)
+%%BoundingBox: (atend)
+%%EndComments
+save
+%%BeginProlog
+/DotDict 200 dict def
+DotDict begin
+
+/setupLatin1 {
+mark
+/EncodingVector 256 array def
+ EncodingVector 0
+
+ISOLatin1Encoding 0 255 getinterval putinterval
+EncodingVector 45 /hyphen put
+
+% Set up ISO Latin 1 character encoding
+/starnetISO {
+        dup dup findfont dup length dict begin
+        { 1 index /FID ne { def }{ pop pop } ifelse
+        } forall
+        /Encoding EncodingVector def
+        currentdict end definefont
+} def
+/Times-Roman starnetISO def
+/Times-Italic starnetISO def
+/Times-Bold starnetISO def
+/Times-BoldItalic starnetISO def
+/Helvetica starnetISO def
+/Helvetica-Oblique starnetISO def
+/Helvetica-Bold starnetISO def
+/Helvetica-BoldOblique starnetISO def
+/Courier starnetISO def
+/Courier-Oblique starnetISO def
+/Courier-Bold starnetISO def
+/Courier-BoldOblique starnetISO def
+cleartomark
+} bind def
+
+%%BeginResource: procset graphviz 0 0
+/coord-font-family /Times-Roman def
+/default-font-family /Times-Roman def
+/coordfont coord-font-family findfont 8 scalefont def
+
+/InvScaleFactor 1.0 def
+/set_scale {
+       dup 1 exch div /InvScaleFactor exch def
+       scale
+} bind def
+
+% styles
+/solid { [] 0 setdash } bind def
+/dashed { [9 InvScaleFactor mul dup ] 0 setdash } bind def
+/dotted { [1 InvScaleFactor mul 6 InvScaleFactor mul] 0 setdash } bind def
+/invis {/fill {newpath} def /stroke {newpath} def /show {pop newpath} def} bind def
+/bold { 2 setlinewidth } bind def
+/filled { } bind def
+/unfilled { } bind def
+/rounded { } bind def
+/diagonals { } bind def
+
+% hooks for setting color 
+/nodecolor { sethsbcolor } bind def
+/edgecolor { sethsbcolor } bind def
+/graphcolor { sethsbcolor } bind def
+/nopcolor {pop pop pop} bind def
+
+/beginpage {	% i j npages
+	/npages exch def
+	/j exch def
+	/i exch def
+	/str 10 string def
+	npages 1 gt {
+		gsave
+			coordfont setfont
+			0 0 moveto
+			(\() show i str cvs show (,) show j str cvs show (\)) show
+		grestore
+	} if
+} bind def
+
+/set_font {
+	findfont exch
+	scalefont setfont
+} def
+
+% draw text fitted to its expected width
+/alignedtext {			% width text
+	/text exch def
+	/width exch def
+	gsave
+		width 0 gt {
+			[] 0 setdash
+			text stringwidth pop width exch sub text length div 0 text ashow
+		} if
+	grestore
+} def
+
+/boxprim {				% xcorner ycorner xsize ysize
+		4 2 roll
+		moveto
+		2 copy
+		exch 0 rlineto
+		0 exch rlineto
+		pop neg 0 rlineto
+		closepath
+} bind def
+
+/ellipse_path {
+	/ry exch def
+	/rx exch def
+	/y exch def
+	/x exch def
+	matrix currentmatrix
+	newpath
+	x y translate
+	rx ry scale
+	0 0 1 0 360 arc
+	setmatrix
+} bind def
+
+/endpage { showpage } bind def
+/showpage { } def
+
+/layercolorseq
+	[	% layer color sequence - darkest to lightest
+		[0 0 0]
+		[.2 .8 .8]
+		[.4 .8 .8]
+		[.6 .8 .8]
+		[.8 .8 .8]
+	]
+def
+
+/layerlen layercolorseq length def
+
+/setlayer {/maxlayer exch def /curlayer exch def
+	layercolorseq curlayer 1 sub layerlen mod get
+	aload pop sethsbcolor
+	/nodecolor {nopcolor} def
+	/edgecolor {nopcolor} def
+	/graphcolor {nopcolor} def
+} bind def
+
+/onlayer { curlayer ne {invis} if } def
+
+/onlayers {
+	/myupper exch def
+	/mylower exch def
+	curlayer mylower lt
+	curlayer myupper gt
+	or
+	{invis} if
+} def
+
+/curlayer 0 def
+
+%%EndResource
+%%EndProlog
+%%BeginSetup
+14 default-font-family set_font
+1 setmiterlimit
+% /arrowlength 10 def
+% /arrowwidth 5 def
+
+% make sure pdfmark is harmless for PS-interpreters other than Distiller
+/pdfmark where {pop} {userdict /pdfmark /cleartomark load put} ifelse
+% make '<<' and '>>' safe on PS Level 1 devices
+/languagelevel where {pop languagelevel}{1} ifelse
+2 lt {
+    userdict (<<) cvn ([) cvn load put
+    userdict (>>) cvn ([) cvn load put
+} if
+
+%%EndSetup
+setupLatin1
+%%Page: 1 1
+%%PageBoundingBox: 36 36 114 152
+%%PageOrientation: Portrait
+0 0 1 beginpage
+gsave
+36 36 78 116 boxprim clip newpath
+1 1 set_scale 0 rotate 40 40 translate
+0.167 0.600 1.000 graphcolor
+newpath -4 -4 moveto
+-4 716 lineto
+536 716 lineto
+536 -4 lineto
+closepath fill
+1 setlinewidth
+0.167 0.600 1.000 graphcolor
+newpath -4 -4 moveto
+-4 716 lineto
+536 716 lineto
+536 -4 lineto
+closepath stroke
+% API
+gsave
+[ /Rect [ 8 72 62 108 ]
+  /Border [ 0 0 0 ]
+  /Action << /Subtype /URI /URI (bookvol10.4.pdf#nameddest=APPRULE) >>
+  /Subtype /Link
+/ANN pdfmark
+0.939 0.733 1.000 nodecolor
+newpath 62 108 moveto
+8 108 lineto
+8 72 lineto
+62 72 lineto
+closepath fill
+1 setlinewidth
+filled
+0.939 0.733 1.000 nodecolor
+newpath 62 108 moveto
+8 108 lineto
+8 72 lineto
+62 72 lineto
+closepath stroke
+0.000 0.000 0.000 nodecolor
+14.00 /Times-Roman set_font
+24 85.9 moveto 22 (API) alignedtext
+grestore
+% ORDSET
+gsave
+[ /Rect [ 0 0 70 36 ]
+  /Border [ 0 0 0 ]
+  /Action << /Subtype /URI /URI (bookvol10.2.pdf#nameddest=ORDSET) >>
+  /Subtype /Link
+/ANN pdfmark
+0.606 0.733 1.000 nodecolor
+newpath 70 36 moveto
+2.73566e-14 36 lineto
+6.33868e-15 1.06581e-14 lineto
+70 0 lineto
+closepath fill
+1 setlinewidth
+filled
+0.606 0.733 1.000 nodecolor
+newpath 70 36 moveto
+2.73566e-14 36 lineto
+6.33868e-15 1.06581e-14 lineto
+70 0 lineto
+closepath stroke
+0.000 0.000 0.000 nodecolor
+14.00 /Times-Roman set_font
+7.5 13.9 moveto 55 (ORDSET) alignedtext
+grestore
+% API->ORDSET
+gsave
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 35 72 moveto
+35 64 35 55 35 46 curveto
+stroke
+0.000 0.000 0.000 edgecolor
+newpath 38.5001 46 moveto
+35 36 lineto
+31.5001 46 lineto
+closepath fill
+1 setlinewidth
+solid
+0.000 0.000 0.000 edgecolor
+newpath 38.5001 46 moveto
+35 36 lineto
+31.5001 46 lineto
+closepath stroke
+grestore
+endpage
+showpage
+grestore
+%%PageTrailer
+%%EndPage: 1
+%%Trailer
+%%Pages: 1
+%%BoundingBox: 36 36 114 152
+end
+restore
+%%EOF
diff --git a/changelog b/changelog
index d1d652d..970fe18 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,9 @@
+20090302 tpd src/axiom-website/patches.html 20090302.02.mxr.patch
+20090302 tpd src/algebra/exposed.lsp add ApplicationProgramInterface 
+20090302 tpd src/algebra/Makefile add API ApplicationProgramInterface
+20090302 tpd src/interp/util.lisp add domainsOf to browser autoload
+20090302 mxr books/bookvol10.4 add API ApplicationProgramInterface
+20090302 mxr books/ps/v104applicationprograminterface.ps
 20090302 tpd src/axiom-website/patches.html 20090302.01.tpd.patch
 20090302 tpd books/bookvol5 add user command documentation
 20090302 tpd books/bookvol0 fix typo
diff --git a/src/algebra/Makefile.pamphlet b/src/algebra/Makefile.pamphlet
index bd760c9..08f7c1a 100644
--- a/src/algebra/Makefile.pamphlet
+++ b/src/algebra/Makefile.pamphlet
@@ -790,7 +790,7 @@ OASGP PDRING
 <<layer2>>=
 
 LAYER2=\
-  ${OUT}/ASP29.o    \
+  ${OUT}/API.o      ${OUT}/ASP29.o    \
   ${OUT}/ATRIG.o    ${OUT}/ATRIG-.o   ${OUT}/BMODULE.o  ${OUT}/CACHSET.o  \
   ${OUT}/CHARNZ.o   ${OUT}/CHARZ.o    ${OUT}/DVARCAT.o  ${OUT}/DVARCAT-.o \
   ${OUT}/ELEMFUN.o  ${OUT}/ELEMFUN-.o ${OUT}/ESTOOLS2.o ${OUT}/EVALAB.o   \
@@ -854,9 +854,10 @@ LAYER2=\
 /*"ABELSG-" -> {"CABMON"; "ABELMON"; "SGROUP"; "MONOID"}*/
 "ABELSG-" -> "LMODULE/SGROUP"
 
-"ASP29" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ASP29"]
-"ASP29" -> "FORTCAT"
-/*"ASP29" -> {"TYPE"; "KOERCE"; "BOOLEAN"}*/
+"API"  [color="#FF4488",href="bookvol10.4.pdf#nameddest=API"]
+/*"API" -> {"INT"; "LIST"; "ILIST"}*/
+"API" -> "ORDSET"
+/*"API" -> {"SETCAT"; "BASTYPE"; "KOERCE"}*/
 
 "ATRIG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ATRIG"]
 /*"ATRIG" -> {"RING"; "RNG"; "ABELGRP"; "CABMON"; "ABELMON"; "ABELSG"}*/
@@ -16431,6 +16432,7 @@ This keeps the regression test list in the algebra Makefile.
 HELPFILE=${INT}/doc/help.helplist
 
 SPADHELP=\
+ ${HELP}/ApplicationProgramInterface.help \
  ${HELP}/ArrayStack.help \
  ${HELP}/AssociationList.help        ${HELP}/BalancedBinaryTree.help \
  ${HELP}/BasicOperator.help          ${HELP}/BinaryExpansion.help \
@@ -16504,6 +16506,7 @@ is put into a int/Makefile.algebra and then executed by make.
 TESTSYS=  ${OBJ}/${SYS}/bin/interpsys
 
 REGRESS=\
+ ApplicationProgramInterface.regress \
  ArrayStack.regress \
  AssociationList.regress        BalancedBinaryTree.regress \
  BasicOperator.regress          BinaryExpansion.regress \
@@ -16589,6 +16592,18 @@ all: ${REGRESS}
 	@echo algebra test cases complete.
 @
 <<spadhelp>>=
+${HELP}/ApplicationProgramInterface.help: ${BOOKS}/bookvol10.4.pamphlet
+	@echo 6999 create ApplicationProgramInterface.help from \
+           ${BOOKS}/bookvol10.4.pamphlet
+	@${TANGLE} -R"ApplicationProgramInterface.help" \
+           ${BOOKS}/bookvol10.4.pamphlet \
+           >${HELP}/ApplicationProgramInterface.help
+	@cp ${HELP}/ApplicationProgramInterface.help ${HELP}/API.help
+	@${TANGLE} -R"ApplicationProgramInterface.input" \
+            ${BOOKS}/bookvol10.4.pamphlet \
+            >${INPUT}/ApplicationProgramInterface.input
+	@echo "ApplicationProgramInterface (API)" >>${HELPFILE}
+
 ${HELP}/ArrayStack.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo 7000 create ArrayStack.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"ArrayStack.help" ${BOOKS}/bookvol10.3.pamphlet \
diff --git a/src/algebra/exposed.lsp.pamphlet b/src/algebra/exposed.lsp.pamphlet
index e211650..cc850fc 100644
--- a/src/algebra/exposed.lsp.pamphlet
+++ b/src/algebra/exposed.lsp.pamphlet
@@ -58,6 +58,7 @@
   (|AlgebraGivenByStructuralConstants| . ALGSC)
   (|Any| . ANY)
   (|AnyFunctions1| . ANY1)
+  (|ApplicationProgramInterface| . API)
   (|ArrayStack| . ASTACK)
   (|AssociatedJordanAlgebra| . JORDAN)
   (|AssociatedLieAlgebra| . LIE)
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index c71f4fc..1838797 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -981,5 +981,7 @@ bookvol4 Hyperdoc tutorial on making new pages<br/>
 gcl-2.6.8pre3.o.read.d.patch fix read-char-no-hang<br/>
 <a href="patches/20090302.01.tpd.patch">20090302.01.tpd.patch</a>
 bookvol5 add user command documentation<br/>
+<a href="patches/20090302.02.mxr.patch">20090302.02.mxr.patch</a>
+bookvol10.4 add API ApplicationProgrammingInterface<br/>
  </body>
 </html>
diff --git a/src/interp/util.lisp.pamphlet b/src/interp/util.lisp.pamphlet
index 85dac2f..a754b43 100644
--- a/src/interp/util.lisp.pamphlet
+++ b/src/interp/util.lisp.pamphlet
@@ -403,6 +403,7 @@ if you use the browse function of the {\bf hypertex} system.
         |abSearch|
         |detailedSearch|
 	|ancestorsOf|
+	|domainsOf|
 	|aPage|
 	|dbGetOrigin|
 	|dbGetParams|



From MAILER-DAEMON Tue Mar 03 23:29:24 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LeijT-0000qK-VY
	for mharc-axiom-developer@gnu.org; Tue, 03 Mar 2009 23:29:24 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LeijR-0000qF-KP
	for axiom-developer@nongnu.org; Tue, 03 Mar 2009 23:29:21 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LeijP-0000pt-5s
	for axiom-developer@nongnu.org; Tue, 03 Mar 2009 23:29:21 -0500
Received: from [199.232.76.173] (port=51190 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LeijO-0000pl-Vp
	for axiom-developer@nongnu.org; Tue, 03 Mar 2009 23:29:19 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:48183
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LeijO-0004dG-H3
	for axiom-developer@nongnu.org; Tue, 03 Mar 2009 23:29:18 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n244THug016373;
	Tue, 3 Mar 2009 22:29:17 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n244TEAC016363;
	Tue, 3 Mar 2009 22:29:14 -0600
Date: Tue, 3 Mar 2009 22:29:14 -0600
Message-Id: <200903040429.n244TEAC016363@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090302.03.tpd.patch (add Nag documentation)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Wed, 04 Mar 2009 04:29:22 -0000

The Nag packages were documented and help files were generated.

The patch is too large to post. See
http://axiom-developer.org/axiom-website/patches.html

Tim



From MAILER-DAEMON Wed Mar 04 17:56:40 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Lf012-00080T-Mk
	for mharc-axiom-developer@gnu.org; Wed, 04 Mar 2009 17:56:40 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Lf010-0007zz-O8
	for axiom-developer@nongnu.org; Wed, 04 Mar 2009 17:56:38 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Lf00x-0007zh-Us
	for axiom-developer@nongnu.org; Wed, 04 Mar 2009 17:56:37 -0500
Received: from [199.232.76.173] (port=53911 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Lf00x-0007ze-Oc
	for axiom-developer@nongnu.org; Wed, 04 Mar 2009 17:56:35 -0500
Received: from an-out-0708.google.com ([209.85.132.242]:40140)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <antoine.hersen@gmail.com>) id 1Lf00x-0002T7-CY
	for axiom-developer@nongnu.org; Wed, 04 Mar 2009 17:56:35 -0500
Received: by an-out-0708.google.com with SMTP id b6so2195252ana.37
	for <axiom-developer@nongnu.org>; Wed, 04 Mar 2009 14:56:34 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=gmail.com; s=gamma;
	h=domainkey-signature:mime-version:received:date:message-id:subject
	:from:to:content-type:content-transfer-encoding;
	bh=PSE4mVWLCLqSzxp2E5Q4knixbLw7Y9OVcTxuc5c/qWQ=;
	b=nQoZw7SPDOJgwAhMQpBsHx9SCq2tL34N+1dFV2YM6+NRGigjlt4SAOqUWdb2camBcM
	SLpaaGg/ZD82lL9EM7EdJgbcutiB26pElEeBN4o35ETs3kns5Un07BSi1xxGK1H9ciYm
	UbE2jYJu2cBt1191Lj7PJgnfoRrpDtco8x9zE=
DomainKey-Signature: a=rsa-sha1; c=nofws; d=gmail.com; s=gamma;
	h=mime-version:date:message-id:subject:from:to:content-type
	:content-transfer-encoding;
	b=SBqalGSIZ6raXIYG1/pg9O2GtMVQYrIfc+/Tt/6NQK0Z4wwkHbyjVHTaPlIcCWujL6
	A1jaTWUcIxqV6HlUTJkeTqIKtXxYibZHknRbHYAX8jTITsYoZKcB0ttJnEcawktiUsPb
	czGl3+0BK8qRNVz/32eUshFpDnyquay14yPdQ=
MIME-Version: 1.0
Received: by 10.100.164.12 with SMTP id m12mr361406ane.144.1236207392682; Wed, 
	04 Mar 2009 14:56:32 -0800 (PST)
Date: Wed, 4 Mar 2009 16:56:32 -0600
Message-ID: <c281860e0903041456w75558f80yea8364516f626d2a@mail.gmail.com>
From: Antoine Hersen <antoine.hersen@gmail.com>
To: axiom-developer <axiom-developer@nongnu.org>
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6 (newer, 2)
Subject: [Axiom-developer] music from Bethan
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Wed, 04 Mar 2009 22:56:38 -0000

that's one of the best things about music though!

a lot of the things i like really remind me of my exboyfriend

so i'm quite excited about finding lots of new music that doesn't

not in a bad way

i'll always love the other stuff

but now i want things that remind me of liverpool

and now!

ok, recommendations

http://www.last.fm/music/El+Guincho

http://www.last.fm/music/Woods

these are just some of my favourite things at the moment

http://www.last.fm/music/Castanets

i just heard this band tonight and i think they're quite lovely

i cna recommend dancey stuff too

i think

maybe
-- 
Website: http://www.societylab.net/
Blog: http://endymion2021.livejournal.com/
Tel: 916 397-4254



From MAILER-DAEMON Thu Mar 05 06:39:51 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LfBvb-0007Jo-0q
	for mharc-axiom-developer@gnu.org; Thu, 05 Mar 2009 06:39:51 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LfBvY-0007Jc-RT
	for axiom-developer@nongnu.org; Thu, 05 Mar 2009 06:39:48 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LfBvW-0007JQ-3R
	for axiom-developer@nongnu.org; Thu, 05 Mar 2009 06:39:47 -0500
Received: from [199.232.76.173] (port=42126 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LfBvV-0007JN-Uz
	for axiom-developer@nongnu.org; Thu, 05 Mar 2009 06:39:46 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:56186
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LfBvU-0000iZ-Hc
	for axiom-developer@nongnu.org; Thu, 05 Mar 2009 06:39:45 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n25Bdgug025793;
	Thu, 5 Mar 2009 05:39:42 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n25Bdfwt025786;
	Thu, 5 Mar 2009 05:39:41 -0600
Date: Thu, 5 Mar 2009 05:39:41 -0600
Message-Id: <200903051139.n25Bdfwt025786@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090304.01.tpd.patch (bookvol5 add user level
	command roots)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Thu, 05 Mar 2009 11:39:49 -0000

The root code for the zsystemdevelopment, workfiles, with, and what commands
were moved to bookvol5. These multiple roots will be used to tree-shake
the rest of the system for live code.

Tim.
===========================================================================
diff --git a/books/bookvol10.4.pamphlet b/books/bookvol10.4.pamphlet
index 5f323e0..33d51d4 100644
--- a/books/bookvol10.4.pamphlet
+++ b/books/bookvol10.4.pamphlet
@@ -3678,7 +3678,7 @@ difference(getDomains 'IndexedAggregate,getDomains 'Collection)
 --R ApplicationProgramInterface  is a package constructor
 --R Abbreviation for ApplicationProgramInterface is API 
 --R This constructor is exposed in this frame.
---R Issue )edit bookvol10.4.pamphlet to see algebra source code for API 
+--R Issue )edit bookvol10.4.spad.pamphlet to see algebra source code for API 
 --R
 --R------------------------------- Operations --------------------------------
 --R getDomains : Symbol -> Set Symbol    
diff --git a/books/bookvol5.pamphlet b/books/bookvol5.pamphlet
index c2c2f17..2b28252 100644
--- a/books/bookvol5.pamphlet
+++ b/books/bookvol5.pamphlet
@@ -1543,6 +1543,42 @@ system function and constructor caches.
 \cmdhead{close}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
+\par\noindent{\bf User Level Required:} interpreter
+
+\par\noindent{\bf Command Syntax:}
+\begin{list}{}
+\item{\tt )close}
+\item{\tt )close )quietly}
+\end{list}
+\par\noindent{\bf Command Description:}
+
+This command is used to close down interpreter client processes.
+Such processes are started by HyperDoc to run Axiom examples
+when you click on their text. When you have finished examining or modifying the
+example and you do not want the extra window around anymore, issue
+\begin{verbatim}
+)close
+\end{verbatim}
+to the Axiom prompt in the window.
+
+If you try to close down the last remaining interpreter client
+process, Axiom will offer to close down the entire Axiom
+session and return you to the operating system by displaying something
+like
+\begin{verbatim}
+   This is the last AXIOM session. Do you want to kill AXIOM?
+\end{verbatim}
+Type ``{\tt y}'' (followed by the Return key) if this is what you had in mind.
+Type ``{\tt n}'' (followed by the Return key) to cancel the command.
+
+You can use the {\tt )quietly} option to force Axiom to
+close down the interpreter client process without closing down
+the entire Axiom session.
+
+\par\noindent{\bf Also See:}
+\fnref{quit} and 
+\fnref{pquit}
+
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{compiler}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@@ -2243,7 +2279,6 @@ next brace but the problem does not arise in practice.
 \cmdhead{edit}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
-
 \par\noindent{\bf User Level Required:} interpreter
 
 \par\noindent{\bf Command Syntax:}
@@ -5970,7 +6005,6 @@ executed when you press, say, a function key.
 \cmdhead{read}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
-
 \par\noindent{\bf User Level Required:} interpreter
 
 \par\noindent{\bf Command Syntax:}
@@ -6010,6 +6044,35 @@ The {\tt )quiet} option suppresses output while the file is being read.
 \cmdhead{savesystem}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
+\par\noindent{\bf User Level Required:} interpreter 
+ 
+\par\noindent{\bf Command Syntax:}
+\begin{list}{}
+\item {\tt )savesystem filename}
+\end{list}
+\par\noindent{\bf Command Description:} 
+ 
+This command is used to save an AXIOM image to disk.  This creates an
+executable file which, when started, has everything loaded into it
+that was there when the image was saved.  Thus, after executing commands
+which cause the loading of some packages, the command:
+ 
+\begin{verbatim}
+)savesystem /tmp/savesys
+\end{verbatim}
+
+will create an image that can be restarted  with the UNIX command:
+
+\begin{verbatim}
+axiom -ws /tmp/savesys
+\end{verbatim}
+
+This new system will not need to reload the packages and domains that
+were already loaded when the system was saved.
+
+There is currently a restriction that only systems started with the 
+command "AXIOMsys" may be saved.
+
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{set}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@@ -6705,11 +6768,11 @@ undo(l) ==
                  (eq (qcdr tmp1) nil)
                  (progn (spadlet key (qcar tmp1)) t)))
        (cond
-        ((|stringPrefix?| (spadlet s (pname key)) (makestring "redo"))
+        ((|stringPrefix?| (spadlet s (pname key)) "redo")
           (spadlet |$options| nil) 
           (|read| '(|redo.input|)))
-        ((null (|stringPrefix?| s (makestring "before")))
-          (|userError| (makestring "only option to undo is \")redo\"")))
+        ((null (|stringPrefix?| s "before"))
+          (|userError| "only option to undo is \")redo\""))
         (t 
           (spadlet undoWhen '|before|)))))
     (if (null l)
@@ -6719,7 +6782,7 @@ undo(l) ==
       (spadlet n (parse-integer (pname n)))
       (cond
        ((null (fixp n)) 
-         (|userError| (makestring "undo argument must be an integer")))
+         (|userError| "undo argument must be an integer"))
        (t 
          nil)))
     (spadlet |$InteractiveFrame| (|undoSteps| (|undoCount| n) undoWhen))
@@ -6978,7 +7041,7 @@ reportUndo acc ==
       (exit
        (progn
         (|sayBrightly|
-          (strconc '|Properties of | (pname name) (makestring " ::")))
+          (strconc '|Properties of | (pname name) " ::"))
         (spadlet curproplist (lassoc name (caar |$InteractiveFrame|)))
         (do ((tmp2 proplist (cdr tmp2)) (tmp3 nil))
             ((or (atom tmp2) 
@@ -6994,14 +7057,10 @@ reportUndo acc ==
           (exit
            (progn
             (|sayBrightlyNT|
-             (cons
-              (makestring "  ")
-              (cons prop (cons (makestring " was: ") nil))))
+             (cons "  " (cons prop (cons " was: " nil))))
             (|pp| value)
             (|sayBrightlyNT| 
-             (cons 
-              (makestring "  ") 
-              (cons prop (cons (makestring " is:  ") nil))))
+             (cons "  " (cons prop (cons " is:  " nil))))
             (|pp| (lassoc prop curproplist)))))))))))))) 
 
 @
@@ -7045,10 +7104,8 @@ undoCount(n) ==  --computes the number of undo's, given $IOindex
     (cond
      ((>= m |$IOindex|)
        (|userError| 
-        (strconc
-         (makestring 
-           "Magnitude of undo argument must be less than step number (")
-           (stringimage |$IOindex|) (makestring ")."))))
+        (strconc "Magnitude of undo argument must be less than step number ("
+           (stringimage |$IOindex|) ").")))
      (t m)))))) 
 
 @
@@ -7304,7 +7361,7 @@ removeUndoLines u == --called by writeInputLines
          (seq
           (exit
            (cond
-            ((null (|stringPrefix?| (makestring ")history") x))
+            ((null (|stringPrefix?| ")history" x))
               (setq tmp0 (cons x tmp0))))))))))
      (spadlet u (append u xtra))
      (cond
@@ -7317,7 +7374,7 @@ removeUndoLines u == --called by writeInputLines
            (seq
             (exit
              (setq tmp2 
-               (or tmp2 (|stringPrefix?| (makestring ")undo") x))))))))) u)
+               (or tmp2 (|stringPrefix?| ")undo" x))))))))) u)
       (t
         (spadlet savedIOindex |$IOindex|)
         (spadlet |$IOindex| 1)
@@ -7328,11 +7385,11 @@ removeUndoLines u == --called by writeInputLines
            (cond
             ((boot-equal (elt (spadlet x (car y)) 0) (|char| '|)|))
               (cond
-               ((|stringPrefix?| (makestring ")undo") 
+               ((|stringPrefix?| ")undo"
                                  (spadlet s (|trimString| x)))
                 (spadlet s1 (|trimString| (substring s 5 nil)))
                 (cond
-                  ((nequal s1 (makestring ")redo"))
+                  ((nequal s1 ")redo")
                     (spadlet m (|charPosition| (|char| '|)|) s1 0))
                     (spadlet code
                      (cond
@@ -7341,13 +7398,13 @@ removeUndoLines u == --called by writeInputLines
                     (spadlet s2 (|trimString| (substring s1 0 m)))))
                 (spadlet n
                  (cond
-                  ((boot-equal s1 (makestring ")redo"))
+                  ((boot-equal s1 ")redo")
                      0)
-                  ((nequal s2 (makestring ""))
+                  ((nequal s2 "")
                     (|undoCount| (parse-integer s2)))
                   (t (spaddifference 1))))
                 (rplaca y
-                  (concat (makestring ">") code (stringimage n))))
+                  (concat ">" code (stringimage n))))
                (t nil)))
             (t (spadlet |$IOindex| (plus |$IOindex| 1)))))))
         (spadlet acc nil)
@@ -7380,7 +7437,7 @@ removeUndoLines u == --called by writeInputLines
                  (spadlet acc (cons c acc)))))
             (t (spadlet acc (cons x acc)))))))
         (spadlet |$IOindex| savedIOindex)
-        acc))))))) 
+        acc)))))))
 
 @
 
@@ -7478,18 +7535,514 @@ The command synonym  {\tt )apropos} is equivalent to
 \fnref{set}, and
 \fnref{show}
 
+\begin{verbatim}
+what l == whatSpad2Cmd l
+\end{verbatim}
+<<defun what>>=
+(defun |what| (l)
+ (|whatSpad2Cmd| l)) 
+
+@
+
+\begin{verbatim}
+whatSpad2Cmd l ==
+  $e:local := $EmptyEnvironment
+  null l => reportWhatOptions()
+  [key0,:args] := l
+  key := selectOptionLC(key0,$whatOptions,nil)
+  null key => sayKeyedMsg("S2IZ0043",NIL)
+  args := [fixpat p for p in args] where
+    fixpat x ==
+      x is [x',:.] => DOWNCASE x'
+      DOWNCASE x
+  key = 'things =>
+    for opt in $whatOptions repeat
+      not MEMQ(opt,'(things)) => whatSpad2Cmd [opt,:args]
+  key = 'categories =>
+    filterAndFormatConstructors('category,'"Categories",args)
+  key = 'commands =>
+    whatCommands(args)
+  key = 'domains =>
+    filterAndFormatConstructors('domain,'"Domains",args)
+  key = 'operations =>
+    apropos args
+  key = 'packages =>
+    filterAndFormatConstructors('package,'"Packages",args)
+  key = 'synonyms =>
+    printSynonyms(args)
+\end{verbatim}
+
+<<defun whatSpad2Cmd,fixpat>>=
+(defun |whatSpad2Cmd,fixpat| (|x|)
+ (prog (|x'|)
+  (return
+   (seq
+    (if (and (pairp |x|) (progn (spadlet |x'| (qcar |x|)) t))
+      (exit (downcase |x'|)))
+    (exit (downcase |x|)))))) 
+
+@
+<<defun whatSpad2Cmd>>=
+(defun |whatSpad2Cmd| (|l|)
+ (prog (|$e| |key0| |key| |args|)
+  (declare (special |$e|))
+  (return
+   (seq
+    (progn
+     (spadlet |$e| |$EmptyEnvironment|)
+     (cond
+      ((null |l|) (|reportWhatOptions|))
+      (t
+        (spadlet |key0| (car |l|))
+        (spadlet |args| (cdr |l|))
+        (spadlet |key| (|selectOptionLC| |key0| |$whatOptions| nil))
+        (cond
+         ((null |key|) (|sayKeyedMsg| 's2iz0043 nil))
+         (t
+          (spadlet |args|
+           (prog (t0)
+            (spadlet t0 nil)
+            (return
+              (do ((t1 |args| (cdr t1)) (|p| nil))
+                  ((or (atom t1)
+                       (progn (setq |p| (car t1)) nil))
+                 (nreverse0 t0))
+               (seq
+                (exit
+                 (setq t0 (cons (|whatSpad2Cmd,fixpat| |p|) t0))))))))
+          (seq
+           (cond
+            ((boot-equal |key| '|things|)
+              (do ((t2 |$whatOptions| (cdr t2)) (|opt| nil))
+                  ((or (atom t2) (progn (setq |opt| (CAR t2)) nil)) nil)
+               (seq
+                (exit
+                 (cond
+                  ((null (memq |opt| '(|things|)))
+                    (exit (|whatSpad2Cmd| (cons |opt| |args|)))))))))
+            ((boot-equal |key| '|categories|)
+              (|filterAndFormatConstructors| '|category| "Categories" |args|))
+            ((boot-equal |key| '|commands|) (|whatCommands| |args|))
+            ((boot-equal |key| '|domains|)
+              (|filterAndFormatConstructors| '|domain| "Domains" |args|))
+            ((boot-equal |key| '|operations|)
+               (|apropos| |args|))
+            ((boot-equal |key| '|packages|)
+              (|filterAndFormatConstructors| '|package| "Packages" |args|))
+            (t
+             (cond ((boot-equal |key| '|synonyms|)
+                      (|printSynonyms| |args|))))))))))))))) 
+
+@
+\begin{verbatim}
+filterAndFormatConstructors(constrType,label,patterns) ==
+  centerAndHighlight(label,$LINELENGTH,specialChar 'hbar)
+  l := filterListOfStringsWithFn(patterns,whatConstructors constrType,
+        function CDR)
+  if patterns then
+    null l =>
+      sayMessage ['"   No ",label,'" with names matching patterns:",
+        '%l,'"   ",'%b,:blankList patterns,'%d]
+    sayMessage [label,'" with names matching patterns:",
+      '%l,'"   ",'%b,:blankList patterns,'%d]
+  l => pp2Cols l
+\end{verbatim}
+
+<<defun filterAndFormatConstructors>>=
+(defun |filterAndFormatConstructors| (|constrType| |label| |patterns|)
+ (prog (|l|)
+  (return
+   (progn (|centerAndHighlight| |label| $linelength 
+           (|specialChar| '|hbar|))
+    (spadlet |l|
+     (|filterListOfStringsWithFn| |patterns|
+       (|whatConstructors| |constrType|)
+       (|function| cdr)))
+    (cond (|patterns|
+     (cond
+      ((null |l|)
+       (|sayMessage|
+        (cons "   No "
+         (cons |label|
+          (cons " with names matching patterns:"
+           (cons '|%l|
+            (cons "   "
+             (cons '|%b|
+              (append (|blankList| |patterns|)
+               (cons '|%d| nil))))))))))
+      (t
+        (|sayMessage|
+         (cons |label|
+          (cons " with names matching patterns:"
+           (cons '|%l|
+            (cons "   "
+             (cons '|%b|
+              (append (|blankList| |patterns|)
+               (cons '|%d| nil))))))))))))
+    (cond (|l| (|pp2Cols| |l|)))))))
+
+@ 
+
+\begin{verbatim}
+whatConstructors constrType ==
+  -- here constrType should be one of 'category, 'domain, 'package
+  MSORT [CONS(GETDATABASE(con,'ABBREVIATION), STRING(con))
+    for con in allConstructors()
+      | GETDATABASE(con,'CONSTRUCTORKIND) = constrType]
+\end{verbatim}
+
+<<defun whatConstructors>>=
+(defun |whatConstructors| (|constrType|)
+ (prog nil
+  (return 
+   (seq
+    (msort
+     (prog (t0)
+      (spadlet t0 nil)
+      (return
+       (do ((t1 (|allConstructors|) (cdr t1)) (|con| nil))
+           ((or (atom t1) (progn (setq |con| (car t1)) nil)) (nreverse0 t0))
+        (seq
+         (exit
+          (cond
+           ((boot-equal (getdatabase |con| 'constructorkind)
+                        |constrType|)
+             (setq t0
+              (cons
+               (cons
+                (getdatabase |con| 'abbreviation)
+                (string |con|))
+               t0)))))))))))))) 
+
+@
+\begin{verbatim}
+apropos l ==
+  -- l is a list of operation name fragments
+  -- this displays all operation names containing these fragments
+  ops :=
+    null l => allOperations()
+    filterListOfStrings([(DOWNCASE STRINGIMAGE p) for p in l],allOperations())
+  ops =>
+    sayMessage '"Operations whose names satisfy the above pattern(s):"
+    sayAsManyPerLineAsPossible MSORT ops
+    sayKeyedMsg("S2IF0011",[first ops])
+  sayMessage '"   There are no operations containing those patterns"
+  NIL
+\end{verbatim}
+
+<<defun apropos>>=
+(defun |apropos| (|l|)
+ (prog (|ops|)
+  (return
+   (seq
+    (progn
+     (spadlet |ops|
+      (cond 
+       ((null |l|) (|allOperations|))
+       (t
+         (|filterListOfStrings|
+          (prog (t0)
+           (spadlet t0 nil)
+           (return
+            (do ((t1 |l| (cdr t1)) (|p| nil))
+                ((or (atom t1) (progn (setq |p| (car t1)) nil))
+                  (nreverse0 t0))
+            (seq (exit (setq t0 (cons (downcase (stringimage |p|)) t0)))))))
+          (|allOperations|)))))
+     (cond
+      (|ops|
+       (|sayMessage| "Operations whose names satisfy the above pattern(s):")
+       (|sayAsManyPerLineAsPossible| (msort |ops|))
+       (|sayKeyedMsg| 's2if0011 (cons (car |ops|) nil)))
+      (t
+       (|sayMessage| "   There are no operations containing those patterns")
+       nil))))))) 
+
+@
+
+
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{with}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
+; )library top level command  -- soon to be obsolete
+
+<<defun with>>=
+(defun |with| (args)
+ (|library| args))
+
+@
+
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{workfiles}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\begin{verbatim}
+workfiles l == workfilesSpad2Cmd l
+\end{verbatim}
+<<defun workfiles>>=
+(defun |workfiles| (l)
+ (|workfilesSpad2Cmd| l)) 
+
+@
+\begin{verbatim}
+workfilesSpad2Cmd args ==
+  args => throwKeyedMsg("S2IZ0047",NIL)
+  deleteFlag := nil
+  for [type,:.] in $options repeat
+    type1 := selectOptionLC(type,'(boot lisp meta delete),nil)
+    null type1 => throwKeyedMsg("S2IZ0048",[type])
+    type1 = 'delete => deleteFlag := true
+  for [type,:flist] in $options repeat
+    type1 := selectOptionLC(type,'(boot lisp meta delete),nil)
+    type1 = 'delete => nil
+    for file in flist repeat
+      fl := pathname [file,type1,'"*"]
+      deleteFlag => SETQ($sourceFiles,DELETE(fl,$sourceFiles))
+      null (MAKE_-INPUT_-FILENAME fl) => sayKeyedMsg("S2IZ0035",[namestring fl])
+      updateSourceFiles fl
+  SAY " "
+  centerAndHighlight(" User-specified work files ",$LINELENGTH,specialChar 'hbar)
+  SAY " "
+  null $sourceFiles => SAY '"   no files specified"
+  SETQ($sourceFiles,SORTBY('pathnameType,$sourceFiles))
+  for fl in $sourceFiles repeat sayBrightly ["   " ,namestring fl]
+\end{verbatim}
+<<defun workfilesSpad2Cmd>>=
+(defun |workfilesSpad2Cmd| (|args|)
+ (prog (|deleteFlag| |type| |flist| |type1| |fl|)
+  (return
+   (seq
+    (cond 
+     (|args| (|throwKeyedMsg| 's2iz0047 nil))
+     (t
+       (spadlet |deleteFlag| nil)
+       (do ((t0 |$options| (cdr t0)) (t1 nil))
+           ((or (atom t0)
+                (progn (setq t1 (car t0)) nil)
+                (progn (progn (spadlet |type| (car t1)) t1) nil))
+             nil)
+        (seq
+         (exit
+          (progn 
+           (spadlet |type1|
+            (|selectOptionLC| |type| '(|boot| |lisp| |meta| |delete|) nil))
+           (cond
+            ((null |type1|)
+              (|throwKeyedMsg| 's2iz0048 (cons |type| nil)))
+            ((boot-equal |type1| '|delete|)
+              (spadlet |deleteFlag| t)))))))
+       (do ((t2 |$options| (cdr t2)) (t3 NIL))
+           ((or (atom t2)
+            (progn (setq t3 (CAR t2)) nil)
+            (progn
+             (progn 
+              (spadlet |type| (car t3))
+              (spadlet |flist| (cdr t3)) t3)
+             nil))
+            nil)
+       (seq
+        (exit
+         (progn
+          (spadlet |type1|
+           (|selectOptionLC| |type| '(|boot| |lisp| |meta| |delete|) nil))
+          (cond
+           ((boot-equal |type1| '|delete|) nil)
+           (t
+            (do ((t4 |flist| (CDR t4)) (|file| nil))
+                ((or (atom t4) (progn (setq |file| (car t4)) nil)) nil)
+             (seq
+              (exit
+               (progn
+                (spadlet |fl|
+                 (|pathname|
+                  (cons |file| (cons |type1| (cons "*" nil)))))
+                (cond 
+                 (|deleteFlag|
+                  (setq |$sourceFiles| (|delete| |fl| |$sourceFiles|)))
+                 ((null (make-input-filename |fl|))
+                  (|sayKeyedMsg|
+                   's2iz0035 (cons (|namestring| |fl|) nil)))
+                 (t (|updateSourceFiles| |fl|)))))))))))))
+       (say " ")
+       (|centerAndHighlight|
+        '| User-specified work files |
+        $linelength
+        (|specialChar| '|hbar|))
+       (say " ")
+       (cond
+        ((null |$sourceFiles|)
+          (say "   no files specified"))
+        (t
+          (setq |$sourceFiles| (sortby '|pathnameType| |$sourceFiles|))
+          (do ((t5 |$sourceFiles| (cdr t5)) (|fl| nil))
+              ((or (atom t5) (progn (setq |fl| (car t5)) nil)) nil)
+           (seq
+            (exit
+             (|sayBrightly|
+               (cons "   " (cons (|namestring| |fl|) nil)))))))))))))) 
+
+@
 
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{zsystemdevelopment}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\begin{verbatim}
+zsystemdevelopment l == zsystemDevelopmentSpad2Cmd l
+\end{verbatim}
+<<defun zsystemdevelopment>>=
+(defun |zsystemdevelopment| (|l|)
+ (|zsystemDevelopmentSpad2Cmd| |l|)) 
+
+@
+\begin{verbatim}
+zsystemDevelopmentSpad2Cmd l == zsystemdevelopment1 (l,$InteractiveMode)
+\end{verbatim}
+<<defun zsystemDevelopmentSpad2Cmd>>=
+(defun |zsystemDevelopmentSpad2Cmd| (|l|)
+ (|zsystemdevelopment1| |l| |$InteractiveMode|)) 
+
+@
+\begin{verbatim}
+zsystemdevelopment1(l,im) ==
+  $InteractiveMode : local := im
+  fromopt := nil
+  -- cycle through once to see if )from is mentioned
+  for [opt,:optargs] in $options repeat
+    opt1 := selectOptionLC(opt,'(from),nil)
+    opt1 = 'from => fromopt := [['FROM,:optargs]]
+  for [opt,:optargs] in $options repeat
+    if null optargs then optargs := l
+    newopt := APPEND(optargs,fromopt)
+    opt1 := selectOptionLC(opt,'(from),nil)
+    opt1 = 'from => nil
+    opt = "c"   => _/D_,1 (newopt ,_/COMP(),NIL,NIL)
+    opt = "d"   => _/D_,1 (newopt ,'DEFINE,NIL,NIL)
+    opt = "dt"  => _/D_,1 (newopt ,'DEFINE,NIL,true)
+    opt = "ct"  => _/D_,1 (newopt ,_/COMP(),NIL,true)
+    opt = "ctl"  => _/D_,1 (newopt ,_/COMP(),NIL,'TRACELET)
+    opt = "ec"  => _/D_,1 (newopt ,_/COMP(),true,NIL)
+    opt = "ect" => _/D_,1 (newopt ,_/COMP(),true,true)
+    opt = "e"   => _/D_,1 (newopt ,NIL,true,NIL)
+    opt = "version" => version()
+    opt = "pause" =>
+      conStream := DEFIOSTREAM ('((DEVICE . CONSOLE) (QUAL . V)),120,0)
+      NEXT conStream
+      SHUT conStream
+    opt = "update" or opt = "patch" =>
+      $InteractiveMode := nil
+      upf := [KAR optargs or _/VERSION, KADR optargs or _/WSNAME,
+              KADDR optargs or '_*]
+      fun := (opt = "patch" => '_/UPDATE_-LIB_-1; '_/UPDATE_-1)
+      CATCH('FILENAM, FUNCALL(fun, upf))
+      sayMessage '"   Update/patch is completed."
+    null optargs =>
+      sayBrightly ['"   An argument is required for",:bright opt]
+    sayMessage ['"   Unknown option:",:bright opt,"    ",'%l,
+      '"   Available options are", _
+      :bright '"c ct e ec ect cls pause update patch compare record"]
+\end{verbatim}
+<<defun zsystemdevelopment1>>=
+(defun |zsystemdevelopment1| (|l| |im|)
+ (prog (|$InteractiveMode| |fromopt| |opt| |optargs| |newopt| |opt1|
+        |conStream| |upf| |fun|)
+  (declare (special |$InteractiveMode|))
+  (return
+   (seq
+    (progn
+     (spadlet |$InteractiveMode| |im|)
+     (spadlet |fromopt| NIL)
+     (do ((t0 |$options| (cdr t0)) (t1 NIL))
+         ((or (atom t0)
+              (progn (setq t1 (car t0)) nil)
+              (progn
+               (progn
+                (spadlet |opt| (CAR t1))
+                (spadlet |optargs| (CDR t1))
+                t1)
+               nil))
+           nil)
+      (seq
+       (exit
+        (progn
+         (spadlet |opt1| (|selectOptionLC| |opt| '(|from|) nil))
+         (cond
+          ((boot-equal |opt1| '|from|)
+            (spadlet |fromopt| (cons (cons 'from |optargs|) nil))))))))
+     (do ((t2 |$options| (cdr t2)) (t3 NIL))
+         ((or (atom t2)
+              (progn (setq t3 (car t2)) nil)
+              (progn
+               (progn
+                (spadlet |opt| (car t3))
+                (spadlet |optargs| (cdr t3))
+                t3)
+               nil))
+          nil)
+      (seq
+       (exit
+        (progn
+         (cond ((null |optargs|) (spadlet |optargs| |l|)))
+         (spadlet |newopt| (append |optargs| |fromopt|))
+         (spadlet |opt1| (|selectOptionLC| |opt| '(|from|) nil))
+         (cond
+          ((boot-equal |opt1| '|from|)
+            nil)
+          ((boot-equal |opt| '|c|)
+            (|/D,1| |newopt| (/COMP) nil nil))
+          ((boot-equal |opt| '|d|)
+            (|/D,1| |newopt| 'define nil nil))
+          ((boot-equal |opt| '|dt|)
+            (|/D,1| |newopt| 'define nil t))
+          ((boot-equal |opt| '|ct|)
+            (|/D,1| |newopt| (/COMP) nil t))
+          ((boot-equal |opt| '|ctl|)
+            (|/D,1| |newopt| (/COMP) nil 'tracelet))
+          ((boot-equal |opt| '|ec|)
+            (|/D,1| |newopt| (/COMP) t nil))
+          ((boot-equal |opt| '|ect|)
+            (|/D,1| |newopt| (/COMP) t t))
+          ((boot-equal |opt| '|e|)
+            (|/D,1| |newopt| nil t nil))
+          ((boot-equal |opt| '|version|)
+            (|version|))
+          ((boot-equal |opt| '|pause|)
+            (spadlet |conStream|
+              (defiostream '((device . console) (qual . v)) 120 0))
+            (next |conStream|)
+            (shut |conStream|))
+          ((or 
+              (boot-equal |opt| '|update|)
+              (boot-equal |opt| '|patch|))
+            (spadlet |$InteractiveMode| nil)
+            (spadlet |upf|
+             (cons
+              (or (kar |optargs|) /version)
+              (cons
+               (or (kadr |optargs|) /wsname)
+               (cons (or (kaddr |optargs|) '*) nil))))
+            (spadlet |fun|
+             (cond
+              ((boot-equal |opt| '|patch|) '/update-lib-1)
+              (t '/update-1)))
+            (catch 'filenam (funcall |fun| |upf|))
+            (|sayMessage| "   Update/patch is completed."))
+          ((null |optargs|)
+           (|sayBrightly|
+            (cons
+             "   An argument is required for"
+             (|bright| |opt|))))
+          (t
+           (|sayMessage|
+            (cons
+             "   Unknown option:"
+             (append
+              (|bright| |opt|)
+              (cons '|    | (cons '|%l| (cons "   Available options are"
+                 (|bright|
+                   "c ct e ec ect cls pause update patch compare record")
+                )))))))))))))))))
 
+@
 \chapter{The Spad Server Mechanism}
 <<initvars>>=
 (defvar $openServerIfTrue t "t means try starting an open server")
@@ -7611,6 +8164,7 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<initvars>>
 
 <<defun addNewInterpreterFrame>>
+<<defun apropos>>
 
 <<defun browse>>
 
@@ -7636,6 +8190,7 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun emptyInterpreterFrame>>
 
 <<defun fetchOutput>>
+<<defun filterAndFormatConstructors>>
 <<defun findFrameInRing>>
 <<defun frame>>
 <<defun frameEnvironment>>
@@ -7744,6 +8299,13 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun updateHist>>
 <<defun updateInCoreHist>>
 
+<<defun what>>
+<<defun whatConstructors>>
+<<defun whatSpad2Cmd>>
+<<defun whatSpad2Cmd,fixpat>>
+<<defun with>>
+<<defun workfiles>>
+<<defun workfilesSpad2Cmd>>
 <<defun writify>>
 <<defun writify,writifyInner>>
 <<defun writifyComplain>>
@@ -7753,6 +8315,9 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 
 <<defun yesanswer>>
 
+<<defun zsystemdevelopment>>
+<<defun zsystemdevelopment1>>
+<<defun zsystemDevelopmentSpad2Cmd>>
 @
 \chapter{The Global Variables}
 \section{Star Global Variables}
diff --git a/changelog b/changelog
index 6d8ab58..eda3d93 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,11 @@
+20090304 tpd src/axiom-website/patches.html 20090304.01.tpd.patch
+20090304 tpd books/bookvol10.4 fix typo
+20090304 tpd books/bookvol5 add user level command roots
+20090304 tpd src/input/Makefile add unittest1
+20090304 tpd src/input/unittest1.input unit test axiom commands
+20090304 tpd src/interp/daase.lisp move commands to bookvol5
+20090304 tpd src/interp/i-syscmd.boot move commands to bookvol5
+20090303 tpd books/bookvol10.4 fix API failing regression test
 20090302 tpd src/axiom-website/patches.html 20090302.03.tpd.patch
 20090302 tpd src/algebra/Makefile add Nag help files
 20090302 tpd books/bookvol10.4 add Nag documentation
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index 8ac75a0..18722ce 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -985,5 +985,7 @@ bookvol5 add user command documentation<br/>
 bookvol10.4 add API ApplicationProgramInterface<br/>
 <a href="patches/20090302.03.tpd.patch">20090302.03.tpd.patch</a>
 bookvol10.4 add Nag documentation<br/>
+<a href="patches/20090304.01.tpd.patch">20090304.01.tpd.patch</a>
+bookvol5 add user level command roots<br/>
  </body>
 </html>
diff --git a/src/input/Makefile.pamphlet b/src/input/Makefile.pamphlet
index f373c0f..57c7c6b 100644
--- a/src/input/Makefile.pamphlet
+++ b/src/input/Makefile.pamphlet
@@ -378,7 +378,8 @@ REGRES= algaggr.regress algbrbf.regress  algfacob.regress alist.regress  \
     tanhcoth.regress  tanatan.regress  tbagg.regress    test.regress \
     textfile.regress  torus.regress \
     triglim.regress   tsetcatvermeer.regress            tutchap1.regress \
-    typetower.regress void.regress      uniseg.regress
+    typetower.regress void.regress      uniseg.regress \
+    unittest1.regress
 
 IN=     ${SRC}/input
 MID=	${INT}/input
@@ -687,7 +688,7 @@ FILES= ${OUT}/algaggr.input  ${OUT}/algbrbf.input    ${OUT}/algfacob.input \
        ${OUT}/tutchap1.input ${OUT}/tutchap2.input   ${OUT}/tutchap3.input \
        ${OUT}/tutchap4.input ${OUT}/tutchap67.input  ${OUT}/typetower.input \
        ${OUT}/typo.input     \
-       ${OUT}/uniseg.input   ${OUT}/up.input \
+       ${OUT}/uniseg.input   ${OUT}/up.input         ${OUT}/unittest1.input \
        ${OUT}/vector.input   ${OUT}/vectors.input    ${OUT}/viewdef.input \
        ${OUT}/void.input     ${OUT}/wiggle.input   \
        ${OUT}/wutset.input \
@@ -1044,7 +1045,8 @@ DOCFILES= \
   ${DOC}/tutchap3.input.dvi    ${DOC}/tutchap4.input.dvi   \
   ${DOC}/tutchap67.input.dvi   ${DOC}/typetower.input.dvi  \
   ${DOC}/typo.input.dvi       \
-  ${DOC}/uniseg.input.dvi      ${DOC}/up.input.dvi         \
+  ${DOC}/uniseg.input.dvi      ${DOC}/unittest1.input.dvi \
+  ${DOC}/up.input.dvi         \
   ${DOC}/vector.input.dvi      ${DOC}/vectors.input.dvi    \
   ${DOC}/viewdef.input.dvi     ${DOC}/void.input.dvi       \
   ${DOC}/wester.input.dvi      ${DOC}/wiggle.input.dvi     \
diff --git a/src/input/unittest1.input.pamphlet b/src/input/unittest1.input.pamphlet
new file mode 100644
index 0000000..8a94acc
--- /dev/null
+++ b/src/input/unittest1.input.pamphlet
@@ -0,0 +1,769 @@
+\documentclass{article}
+\usepackage{axiom}
+\begin{document}
+\title{\$SPAD/src/input unittest1.input}
+\author{Timothy Daly}
+\maketitle
+\begin{abstract}
+Unit test the user level commands
+\end{abstract}
+\eject
+\tableofcontents
+\eject
+<<*>>=
+)set break resume
+)sys rm -f unittest1.output
+)spool unittest1.output
+)set mes auto off
+)clear all
+
+@
+The )with command is the same as the )library command and really
+should be a synonym.
+<<*>>= 
+--S 1
+)with API
+--R   )library cannot find the file API.
+--E 1
+
+@
+
+The )apropos command is the same as a )what command
+<<*>>= 
+--S 2
+)apropos matrix
+--R
+--ROperations whose names satisfy the above pattern(s):
+--R
+--RbezoutMatrix                       createGenericMatrix                
+--RcreateMultiplicationMatrix         diagonalMatrix                     
+--ReigenMatrix                        firstUncouplingMatrix              
+--RgetMultiplicationMatrix            idealiserMatrix                    
+--RidentityMatrix                     identitySquareMatrix               
+--RintegralDerivationMatrix           integralMatrix                     
+--RintegralMatrixAtInfinity           inverseIntegralMatrix              
+--RinverseIntegralMatrixAtInfinity    leftTraceMatrix                    
+--RlinearMatrix                       mapMatrixIfCan                     
+--Rmatrix                             matrixConcat3D                     
+--RmatrixDimensions                   matrixGcd                          
+--RrectangularMatrix                  rightTraceMatrix                   
+--RscalarMatrix                       setsubMatrix!                      
+--RsquareMatrix                       subMatrix                          
+--RsylvesterMatrix                    traceMatrix                        
+--RwronskianMatrix                    zeroMatrix                         
+--RzeroSquareMatrix                   
+--R   
+--R      To get more information about an operation such as identityMatrix
+--R      , issue the command )display op identityMatrix 
+--R------------------------------- Categories --------------------------------
+--R
+--RCategories with names matching patterns:
+--R     matrix 
+--R
+--R FMC      FortranMatrixCategory
+--R FMFUN    FortranMatrixFunctionCategory
+--R MATCAT   MatrixCategory               RMATCAT  RectangularMatrixCategory
+--R SMATCAT  SquareMatrixCategory
+--R--------------------------------- Domains ---------------------------------
+--R
+--RDomains with names matching patterns:
+--R     matrix 
+--R
+--R DHMATRIX DenavitHartenbergMatrix      DPMM     DirectProductMatrixModule
+--R IMATRIX  IndexedMatrix                LSQM     LieSquareMatrix
+--R M3D      ThreeDimensionalMatrix       MATCAT-  MatrixCategory&
+--R MATRIX   Matrix                       RMATCAT- RectangularMatrixCategory&
+--R RMATRIX  RectangularMatrix            SMATCAT- SquareMatrixCategory&
+--R SQMATRIX SquareMatrix
+--R-------------------------------- Packages ---------------------------------
+--R
+--RPackages with names matching patterns:
+--R     matrix 
+--R
+--R BEZOUT   BezoutMatrix                 CVMP     CoerceVectorMatrixPackage
+--R IMATLIN  InnerMatrixLinearAlgebraFunctions
+--R IMATQF   InnerMatrixQuotientFieldFunctions
+--R LSMP     LinearSystemMatrixPackage    LSMP1    LinearSystemMatrixPackage1
+--R MATCAT2  MatrixCategoryFunctions2     MATLIN   MatrixLinearAlgebraFunctions
+--R MATSTOR  StorageEfficientMatrixOperations
+--R MCDEN    MatrixCommonDenominator      NAGF01   NagMatrixOperationsPackage
+--R RMCAT2   RectangularMatrixCategoryFunctions2
+--R TRIMAT   TriangularMatrixOperations
+--R--------------- System Commands for User Level: development ---------------
+--R
+--RNo system commands at this level matching patterns:
+--R     matrix 
+--R
+--R------------------------- System Command Synonyms -------------------------
+--R
+--R   No user-defined synonyms satisfying patterns:
+--R       matrix 
+--R
+--E 2
+
+--S 3
+)what categories set
+--R------------------------------- Categories --------------------------------
+--R
+--RCategories with names matching patterns:
+--R     set 
+--R
+--R CACHSET  CachableSet                  FSAGG    FiniteSetAggregate
+--R MSETAGG  MultisetAggregate
+--R NTSCAT   NormalizedTriangularSetCategory
+--R OMSAGG   OrderedMultisetAggregate     ORDSET   OrderedSet
+--R PSETCAT  PolynomialSetCategory        RSETCAT  RegularTriangularSetCategory
+--R SETAGG   SetAggregate                 SETCAT   SetCategory
+--R SFRTCAT  SquareFreeRegularTriangularSetCategory
+--R SNTSCAT  SquareFreeNormalizedTriangularSetCategory
+--R TSETCAT  TriangularSetCategory
+--E 3
+
+--S 4
+)what commands set
+--R--------------- System Commands for User Level: development ---------------
+--R
+--RSystem commands at this level matching patterns:
+--R     set 
+--R
+--Rset    
+--R 
+--E 4
+
+--S 5
+)what domains set
+--R--------------------------------- Domains ---------------------------------
+--R
+--RDomains with names matching patterns:
+--R     set 
+--R
+--R FSAGG-   FiniteSetAggregate&          GPOLSET  GeneralPolynomialSet
+--R GSTBL    GeneralSparseTable           GTSET    GeneralTriangularSet
+--R MKCHSET  MakeCachableSet              MSET     Multiset
+--R ORDSET-  OrderedSet&                  OSI      OrdSetInts
+--R PSETCAT- PolynomialSetCategory&       QALGSET  QuasiAlgebraicSet
+--R REGSET   RegularTriangularSet
+--R RSETCAT- RegularTriangularSetCategory&
+--R RULESET  Ruleset                      SAOS     SingletonAsOrderedSet
+--R SET      Set                          SETAGG-  SetAggregate&
+--R SETCAT-  SetCategory&                 SETMN    SetOfMIntegersInOneToN
+--R SREGSET  SquareFreeRegularTriangularSet
+--R STBL     SparseTable                  TSETCAT- TriangularSetCategory&
+--R WUTSET   WuWenTsunTriangularSet
+--E 5
+
+--S 6
+)what operations set
+--R
+--ROperations whose names satisfy the above pattern(s):
+--R
+--ROMsetEncoding                                   
+--RbasicSet                                        
+--RcharacteristicSet                               
+--RcrushedSet                                      
+--Rfactorset                                       
+--RfirstSubsetGray                                 
+--RinternalSubPolSet?                              
+--RinternalZeroSetSplit                            
+--RinvertibleSet                                   
+--RmedialSet                                       
+--Rminset                                          
+--Rmultiset                                        
+--RnextSubsetGray                                  
+--Roverset?                                        
+--Rqsetelt!                                        
+--RquasiAlgebraicSet                               
+--Rreset                                           
+--RresetAttributeButtons                           
+--RresetBadValues                                  
+--RresetNew                                        
+--RresetVariableOrder                              
+--RrewriteSetByReducingWithParticularGenerators    
+--RrewriteSetWithReduction                         
+--RroughBasicSet                                   
+--Rruleset                                         
+--Rset                                             
+--RsetAdaptive                                     
+--RsetAdaptive3D                                   
+--RsetAttributeButtonStep                          
+--RsetButtonValue                                  
+--RsetClipValue                                    
+--RsetClosed                                       
+--RsetColumn!                                      
+--RsetCondition!                                   
+--RsetDifference                                   
+--RsetEmpty!                                       
+--RsetEpilogue!                                    
+--RsetErrorBound                                   
+--RsetFieldInfo                                    
+--RsetFormula!                                     
+--RsetImagSteps                                    
+--RsetIntersection                                 
+--RsetLabelValue                                   
+--RsetLegalFortranSourceExtensions                 
+--RsetMaxPoints                                    
+--RsetMaxPoints3D                                  
+--RsetMinPoints                                    
+--RsetMinPoints3D                                  
+--RsetOfMinN                                       
+--RsetOrder                                        
+--RsetPoly                                         
+--RsetPosition                                     
+--RsetPredicates                                   
+--RsetPrologue!                                    
+--RsetProperties                                   
+--RsetProperty                                     
+--RsetRealSteps                                    
+--RsetRow!                                         
+--RsetScreenResolution                             
+--RsetScreenResolution3D                           
+--RsetStatus                                       
+--RsetStatus!                                      
+--RsetTex!                                         
+--RsetTopPredicate                                 
+--RsetUnion                                        
+--RsetValue!                                       
+--RsetVariableOrder                                
+--Rsetchildren!                                    
+--Rsetelt                                          
+--Rsetelt!                                         
+--Rsetfirst!                                       
+--Rsetlast!                                        
+--Rsetleaves!                                      
+--Rsetleft!                                        
+--Rsetnext!                                        
+--Rsetprevious!                                    
+--Rsetref                                          
+--Rsetrest!                                        
+--Rsetright!                                       
+--RsetsubMatrix!                                   
+--Rsetvalue!                                       
+--RstartTableInvSet!                               
+--RstopTableInvSet!                                
+--RstoseInvertibleSet                              
+--RstoseInvertibleSetreg                           
+--RstoseInvertibleSetsqfreg                        
+--RsubPolSet?                                      
+--RsubSet                                          
+--RsubTriSet?                                      
+--Rsubset?                                         
+--RtoseInvertibleSet                               
+--RzeroSetSplit                                    
+--RzeroSetSplitIntoTriangularSystems               
+--R   
+--R      To get more information about an operation such as setMaxPoints ,
+--R      issue the command )display op setMaxPoints 
+--E 6
+
+--S 7
+)what packages set
+--R-------------------------------- Packages ---------------------------------
+--R
+--RPackages with names matching patterns:
+--R     set 
+--R
+--R FSAGG2   FiniteSetAggregateFunctions2 LAZM3PK  LazardSetSolvingPackage
+--R PSETPK   PolynomialSetUtilitiesPackage
+--R QALGSET2 QuasiAlgebraicSet2
+--R RSDCMPK  RegularSetDecompositionPackage
+--R RSETGCD  RegularTriangularSetGcdPackage
+--R SFRGCD   SquareFreeRegularTriangularSetGcdPackage
+--R SRDCMPK  SquareFreeRegularSetDecompositionPackage
+--E 7
+
+--S 8
+)what synonym set
+--R------------------------- System Command Synonyms -------------------------
+--R
+--R   No user-defined synonyms satisfying patterns:
+--R       set 
+--R
+--E 8
+
+--S 9
+)what things set
+--R
+--ROperations whose names satisfy the above pattern(s):
+--R
+--ROMsetEncoding                                   
+--RbasicSet                                        
+--RcharacteristicSet                               
+--RcrushedSet                                      
+--Rfactorset                                       
+--RfirstSubsetGray                                 
+--RinternalSubPolSet?                              
+--RinternalZeroSetSplit                            
+--RinvertibleSet                                   
+--RmedialSet                                       
+--Rminset                                          
+--Rmultiset                                        
+--RnextSubsetGray                                  
+--Roverset?                                        
+--Rqsetelt!                                        
+--RquasiAlgebraicSet                               
+--Rreset                                           
+--RresetAttributeButtons                           
+--RresetBadValues                                  
+--RresetNew                                        
+--RresetVariableOrder                              
+--RrewriteSetByReducingWithParticularGenerators    
+--RrewriteSetWithReduction                         
+--RroughBasicSet                                   
+--Rruleset                                         
+--Rset                                             
+--RsetAdaptive                                     
+--RsetAdaptive3D                                   
+--RsetAttributeButtonStep                          
+--RsetButtonValue                                  
+--RsetClipValue                                    
+--RsetClosed                                       
+--RsetColumn!                                      
+--RsetCondition!                                   
+--RsetDifference                                   
+--RsetEmpty!                                       
+--RsetEpilogue!                                    
+--RsetErrorBound                                   
+--RsetFieldInfo                                    
+--RsetFormula!                                     
+--RsetImagSteps                                    
+--RsetIntersection                                 
+--RsetLabelValue                                   
+--RsetLegalFortranSourceExtensions                 
+--RsetMaxPoints                                    
+--RsetMaxPoints3D                                  
+--RsetMinPoints                                    
+--RsetMinPoints3D                                  
+--RsetOfMinN                                       
+--RsetOrder                                        
+--RsetPoly                                         
+--RsetPosition                                     
+--RsetPredicates                                   
+--RsetPrologue!                                    
+--RsetProperties                                   
+--RsetProperty                                     
+--RsetRealSteps                                    
+--RsetRow!                                         
+--RsetScreenResolution                             
+--RsetScreenResolution3D                           
+--RsetStatus                                       
+--RsetStatus!                                      
+--RsetTex!                                         
+--RsetTopPredicate                                 
+--RsetUnion                                        
+--RsetValue!                                       
+--RsetVariableOrder                                
+--Rsetchildren!                                    
+--Rsetelt                                          
+--Rsetelt!                                         
+--Rsetfirst!                                       
+--Rsetlast!                                        
+--Rsetleaves!                                      
+--Rsetleft!                                        
+--Rsetnext!                                        
+--Rsetprevious!                                    
+--Rsetref                                          
+--Rsetrest!                                        
+--Rsetright!                                       
+--RsetsubMatrix!                                   
+--Rsetvalue!                                       
+--RstartTableInvSet!                               
+--RstopTableInvSet!                                
+--RstoseInvertibleSet                              
+--RstoseInvertibleSetreg                           
+--RstoseInvertibleSetsqfreg                        
+--RsubPolSet?                                      
+--RsubSet                                          
+--RsubTriSet?                                      
+--Rsubset?                                         
+--RtoseInvertibleSet                               
+--RzeroSetSplit                                    
+--RzeroSetSplitIntoTriangularSystems               
+--R   
+--R      To get more information about an operation such as setMaxPoints ,
+--R      issue the command )display op setMaxPoints 
+--R------------------------------- Categories --------------------------------
+--R
+--RCategories with names matching patterns:
+--R     set 
+--R
+--R CACHSET  CachableSet                  FSAGG    FiniteSetAggregate
+--R MSETAGG  MultisetAggregate
+--R NTSCAT   NormalizedTriangularSetCategory
+--R OMSAGG   OrderedMultisetAggregate     ORDSET   OrderedSet
+--R PSETCAT  PolynomialSetCategory        RSETCAT  RegularTriangularSetCategory
+--R SETAGG   SetAggregate                 SETCAT   SetCategory
+--R SFRTCAT  SquareFreeRegularTriangularSetCategory
+--R SNTSCAT  SquareFreeNormalizedTriangularSetCategory
+--R TSETCAT  TriangularSetCategory
+--R--------------------------------- Domains ---------------------------------
+--R
+--RDomains with names matching patterns:
+--R     set 
+--R
+--R FSAGG-   FiniteSetAggregate&          GPOLSET  GeneralPolynomialSet
+--R GSTBL    GeneralSparseTable           GTSET    GeneralTriangularSet
+--R MKCHSET  MakeCachableSet              MSET     Multiset
+--R ORDSET-  OrderedSet&                  OSI      OrdSetInts
+--R PSETCAT- PolynomialSetCategory&       QALGSET  QuasiAlgebraicSet
+--R REGSET   RegularTriangularSet
+--R RSETCAT- RegularTriangularSetCategory&
+--R RULESET  Ruleset                      SAOS     SingletonAsOrderedSet
+--R SET      Set                          SETAGG-  SetAggregate&
+--R SETCAT-  SetCategory&                 SETMN    SetOfMIntegersInOneToN
+--R SREGSET  SquareFreeRegularTriangularSet
+--R STBL     SparseTable                  TSETCAT- TriangularSetCategory&
+--R WUTSET   WuWenTsunTriangularSet
+--R-------------------------------- Packages ---------------------------------
+--R
+--RPackages with names matching patterns:
+--R     set 
+--R
+--R FSAGG2   FiniteSetAggregateFunctions2 LAZM3PK  LazardSetSolvingPackage
+--R PSETPK   PolynomialSetUtilitiesPackage
+--R QALGSET2 QuasiAlgebraicSet2
+--R RSDCMPK  RegularSetDecompositionPackage
+--R RSETGCD  RegularTriangularSetGcdPackage
+--R SFRGCD   SquareFreeRegularTriangularSetGcdPackage
+--R SRDCMPK  SquareFreeRegularSetDecompositionPackage
+--R--------------- System Commands for User Level: development ---------------
+--R
+--RSystem commands at this level matching patterns:
+--R     set 
+--R
+--Rset    
+--R 
+--R------------------------- System Command Synonyms -------------------------
+--R
+--R   No user-defined synonyms satisfying patterns:
+--R       set 
+--R
+--E 9
+
+--S 10
+)apropos set
+--R
+--ROperations whose names satisfy the above pattern(s):
+--R
+--ROMsetEncoding                                   
+--RbasicSet                                        
+--RcharacteristicSet                               
+--RcrushedSet                                      
+--Rfactorset                                       
+--RfirstSubsetGray                                 
+--RinternalSubPolSet?                              
+--RinternalZeroSetSplit                            
+--RinvertibleSet                                   
+--RmedialSet                                       
+--Rminset                                          
+--Rmultiset                                        
+--RnextSubsetGray                                  
+--Roverset?                                        
+--Rqsetelt!                                        
+--RquasiAlgebraicSet                               
+--Rreset                                           
+--RresetAttributeButtons                           
+--RresetBadValues                                  
+--RresetNew                                        
+--RresetVariableOrder                              
+--RrewriteSetByReducingWithParticularGenerators    
+--RrewriteSetWithReduction                         
+--RroughBasicSet                                   
+--Rruleset                                         
+--Rset                                             
+--RsetAdaptive                                     
+--RsetAdaptive3D                                   
+--RsetAttributeButtonStep                          
+--RsetButtonValue                                  
+--RsetClipValue                                    
+--RsetClosed                                       
+--RsetColumn!                                      
+--RsetCondition!                                   
+--RsetDifference                                   
+--RsetEmpty!                                       
+--RsetEpilogue!                                    
+--RsetErrorBound                                   
+--RsetFieldInfo                                    
+--RsetFormula!                                     
+--RsetImagSteps                                    
+--RsetIntersection                                 
+--RsetLabelValue                                   
+--RsetLegalFortranSourceExtensions                 
+--RsetMaxPoints                                    
+--RsetMaxPoints3D                                  
+--RsetMinPoints                                    
+--RsetMinPoints3D                                  
+--RsetOfMinN                                       
+--RsetOrder                                        
+--RsetPoly                                         
+--RsetPosition                                     
+--RsetPredicates                                   
+--RsetPrologue!                                    
+--RsetProperties                                   
+--RsetProperty                                     
+--RsetRealSteps                                    
+--RsetRow!                                         
+--RsetScreenResolution                             
+--RsetScreenResolution3D                           
+--RsetStatus                                       
+--RsetStatus!                                      
+--RsetTex!                                         
+--RsetTopPredicate                                 
+--RsetUnion                                        
+--RsetValue!                                       
+--RsetVariableOrder                                
+--Rsetchildren!                                    
+--Rsetelt                                          
+--Rsetelt!                                         
+--Rsetfirst!                                       
+--Rsetlast!                                        
+--Rsetleaves!                                      
+--Rsetleft!                                        
+--Rsetnext!                                        
+--Rsetprevious!                                    
+--Rsetref                                          
+--Rsetrest!                                        
+--Rsetright!                                       
+--RsetsubMatrix!                                   
+--Rsetvalue!                                       
+--RstartTableInvSet!                               
+--RstopTableInvSet!                                
+--RstoseInvertibleSet                              
+--RstoseInvertibleSetreg                           
+--RstoseInvertibleSetsqfreg                        
+--RsubPolSet?                                      
+--RsubSet                                          
+--RsubTriSet?                                      
+--Rsubset?                                         
+--RtoseInvertibleSet                               
+--RzeroSetSplit                                    
+--RzeroSetSplitIntoTriangularSystems               
+--R   
+--R      To get more information about an operation such as setMaxPoints ,
+--R      issue the command )display op setMaxPoints 
+--R------------------------------- Categories --------------------------------
+--R
+--RCategories with names matching patterns:
+--R     set 
+--R
+--R CACHSET  CachableSet                  FSAGG    FiniteSetAggregate
+--R MSETAGG  MultisetAggregate
+--R NTSCAT   NormalizedTriangularSetCategory
+--R OMSAGG   OrderedMultisetAggregate     ORDSET   OrderedSet
+--R PSETCAT  PolynomialSetCategory        RSETCAT  RegularTriangularSetCategory
+--R SETAGG   SetAggregate                 SETCAT   SetCategory
+--R SFRTCAT  SquareFreeRegularTriangularSetCategory
+--R SNTSCAT  SquareFreeNormalizedTriangularSetCategory
+--R TSETCAT  TriangularSetCategory
+--R--------------------------------- Domains ---------------------------------
+--R
+--RDomains with names matching patterns:
+--R     set 
+--R
+--R FSAGG-   FiniteSetAggregate&          GPOLSET  GeneralPolynomialSet
+--R GSTBL    GeneralSparseTable           GTSET    GeneralTriangularSet
+--R MKCHSET  MakeCachableSet              MSET     Multiset
+--R ORDSET-  OrderedSet&                  OSI      OrdSetInts
+--R PSETCAT- PolynomialSetCategory&       QALGSET  QuasiAlgebraicSet
+--R REGSET   RegularTriangularSet
+--R RSETCAT- RegularTriangularSetCategory&
+--R RULESET  Ruleset                      SAOS     SingletonAsOrderedSet
+--R SET      Set                          SETAGG-  SetAggregate&
+--R SETCAT-  SetCategory&                 SETMN    SetOfMIntegersInOneToN
+--R SREGSET  SquareFreeRegularTriangularSet
+--R STBL     SparseTable                  TSETCAT- TriangularSetCategory&
+--R WUTSET   WuWenTsunTriangularSet
+--R-------------------------------- Packages ---------------------------------
+--R
+--RPackages with names matching patterns:
+--R     set 
+--R
+--R FSAGG2   FiniteSetAggregateFunctions2 LAZM3PK  LazardSetSolvingPackage
+--R PSETPK   PolynomialSetUtilitiesPackage
+--R QALGSET2 QuasiAlgebraicSet2
+--R RSDCMPK  RegularSetDecompositionPackage
+--R RSETGCD  RegularTriangularSetGcdPackage
+--R SFRGCD   SquareFreeRegularTriangularSetGcdPackage
+--R SRDCMPK  SquareFreeRegularSetDecompositionPackage
+--R--------------- System Commands for User Level: development ---------------
+--R
+--RSystem commands at this level matching patterns:
+--R     set 
+--R
+--Rset    
+--R 
+--R------------------------- System Command Synonyms -------------------------
+--R
+--R   No user-defined synonyms satisfying patterns:
+--R       set 
+--R
+--E 10
+
+--S 11
+)prompt
+--R---------------------------- The prompt Option ----------------------------
+--R
+--R Description: set type of input prompt to display
+--R
+--R The prompt option may be followed by any one of the following:
+--R
+--R    none
+--R    frame
+--R    plain
+--R -> step 
+--R    verbose
+--R
+--R The current setting is indicated within the list.
+--R
+--E 11
+
+--S 12
+)version
+--R 
+--IValue = "Saturday February 21, 2009 at 17:59:27 "
+--E 12
+
+--S 13
+)zsys )from )c
+--R 
+--R 
+--R   >> System error:
+--I   Cannot open the file /research/test/mnt/fedora10/../../src/interp/TAGS.
+--R
+--R   Continuing to read the file...
+--R
+--E 13
+
+--S 14
+)zsys )from )d
+--R 
+--R 
+--R   >> System error:
+--I   Cannot open the file /research/test/mnt/fedora10/../../src/interp/TAGS.
+--R
+--R   Continuing to read the file...
+--R
+--E 14
+
+--S 15
+)zsys )from )dt
+--R 
+--R 
+--R   >> System error:
+--I   Cannot open the file /research/test/mnt/fedora10/../../src/interp/TAGS.
+--R
+--R   Continuing to read the file...
+--R
+--E 15
+
+--S 16
+)zsys )from )ct
+--R 
+--R 
+--R   >> System error:
+--I   Cannot open the file /research/test/mnt/fedora10/../../src/interp/TAGS.
+--R
+--R   Continuing to read the file...
+--R
+--E 16
+
+--S 17
+)zsys )from )ctl
+--R 
+--R 
+--R   >> System error:
+--I   Cannot open the file /research/test/mnt/fedora10/../../src/interp/TAGS.
+--R
+--R   Continuing to read the file...
+--R
+--E 17
+
+--S 18
+)zsys )from )ec
+--R 
+--R 
+--R   >> System error:
+--I   Cannot open the file /research/test/mnt/fedora10/../../src/interp/TAGS.
+--R
+--R   Continuing to read the file...
+--R
+--E 18
+
+--S 19
+)zsys )from )ect
+--R 
+--R 
+--R   >> System error:
+--I   Cannot open the file /research/test/mnt/fedora10/../../src/interp/TAGS.
+--R
+--R   Continuing to read the file...
+--R
+--E 19
+
+--S 20
+)zsys )from )e
+--R 
+--R 
+--R   >> System error:
+--I   Cannot open the file /research/test/mnt/fedora10/../../src/interp/TAGS.
+--R
+--R   Continuing to read the file...
+--R
+--E 20
+
+--S 21
+)zsys )from )version
+--R 
+--E 21
+
+--S 22
+)zsys )from )update
+--R 
+--R 
+--R   >> System error:
+--R   /UPDATE-1 [or a callee] requires more than one argument.
+--R
+--R   Continuing to read the file...
+--R
+--E 22
+
+--S 23
+)zsys )from )patch
+--R 
+--R 
+--R   >> System error:
+--R   The function /UPDATE-LIB-1 is undefined.
+--R
+--R   Continuing to read the file...
+--R
+--E 23
+
+--S 24
+)zsys )from )there 1
+--R 
+--R
+--R   Unknown option: there     
+--R   Available options are c ct e ec ect cls pause update patch compare record 
+--R
+--E 24
+
+--S 25
+)zsys )from )compare
+--R 
+--R   An argument is required for compare 
+--E 25
+
+--S 26
+)zsys )from )record
+--R 
+--R   An argument is required for record 
+--E 26
+
+)spool
+)lisp (bye)
+ 
+@
+\eject
+\begin{thebibliography}{99}
+\bibitem{1} nothing
+\end{thebibliography}
+\end{document}
diff --git a/src/interp/daase.lisp.pamphlet b/src/interp/daase.lisp.pamphlet
index ccf699b..c9498a3 100644
--- a/src/interp/daase.lisp.pamphlet
+++ b/src/interp/daase.lisp.pamphlet
@@ -806,11 +806,6 @@ database.
        (setq data (concatenate 'string $spadroot "/algebra/" data ".o")))))))
   data))
 
-; )library top level command  -- soon to be obsolete
-
-(defun |with| (args)
- (|library| args))
-
 ; )library top level command
 
 (defun |library| (args)
diff --git a/src/interp/i-syscmd.boot.pamphlet b/src/interp/i-syscmd.boot.pamphlet
index b9a20d3..997c527 100644
--- a/src/interp/i-syscmd.boot.pamphlet
+++ b/src/interp/i-syscmd.boot.pamphlet
@@ -1440,69 +1440,6 @@ processSynonymLine line ==
             line.j ^= " " => return (SUBSTRING (line, j, nil)))
   [key, :value]
 
---% )what
-
-
-what l == whatSpad2Cmd l
-
-whatSpad2Cmd l ==
-  $e:local := $EmptyEnvironment
-  null l => reportWhatOptions()
-  [key0,:args] := l
-  key := selectOptionLC(key0,$whatOptions,nil)
-  null key => sayKeyedMsg("S2IZ0043",NIL)
-  args := [fixpat p for p in args] where
-    fixpat x ==
-      x is [x',:.] => DOWNCASE x'
-      DOWNCASE x
-  key = 'things =>
-    for opt in $whatOptions repeat
-      not MEMQ(opt,'(things)) => whatSpad2Cmd [opt,:args]
-  key = 'categories =>
-    filterAndFormatConstructors('category,'"Categories",args)
-  key = 'commands =>
-    whatCommands(args)
-  key = 'domains =>
-    filterAndFormatConstructors('domain,'"Domains",args)
-  key = 'operations =>
-    apropos args
-  key = 'packages =>
-    filterAndFormatConstructors('package,'"Packages",args)
-  key = 'synonyms =>
-    printSynonyms(args)
-
-filterAndFormatConstructors(constrType,label,patterns) ==
-  centerAndHighlight(label,$LINELENGTH,specialChar 'hbar)
-  l := filterListOfStringsWithFn(patterns,whatConstructors constrType,
-        function CDR)
-  if patterns then
-    null l =>
-      sayMessage ['"   No ",label,'" with names matching patterns:",
-        '%l,'"   ",'%b,:blankList patterns,'%d]
-    sayMessage [label,'" with names matching patterns:",
-      '%l,'"   ",'%b,:blankList patterns,'%d]
-  l => pp2Cols l
-
-whatConstructors constrType ==
-  -- here constrType should be one of 'category, 'domain, 'package
-  MSORT [CONS(GETDATABASE(con,'ABBREVIATION), STRING(con))
-    for con in allConstructors()
-      | GETDATABASE(con,'CONSTRUCTORKIND) = constrType]
-
-apropos l ==
-  -- l is a list of operation name fragments
-  -- this displays all operation names containing these fragments
-  ops :=
-    null l => allOperations()
-    filterListOfStrings([(DOWNCASE STRINGIMAGE p) for p in l],allOperations())
-  ops =>
-    sayMessage '"Operations whose names satisfy the above pattern(s):"
-    sayAsManyPerLineAsPossible MSORT ops
-    sayKeyedMsg("S2IF0011",[first ops])
-  sayMessage '"   There are no operations containing those patterns"
-  NIL
-
-
 printSynonyms(patterns) ==
   centerAndHighlight("System Command Synonyms",$LINELENGTH,specialChar 'hbar)
   ls := filterListOfStringsWithFn(patterns, [[STRINGIMAGE a,:b]
@@ -1590,76 +1527,6 @@ satisfiesRegularExpressions(name,patterns) ==
 
 --% )with ... defined in daase.lisp (boot won't parse it)
 
---% )workfiles
-
-workfiles l == workfilesSpad2Cmd l
-
-workfilesSpad2Cmd args ==
-  args => throwKeyedMsg("S2IZ0047",NIL)
-  deleteFlag := nil
-  for [type,:.] in $options repeat
-    type1 := selectOptionLC(type,'(boot lisp meta delete),nil)
-    null type1 => throwKeyedMsg("S2IZ0048",[type])
-    type1 = 'delete => deleteFlag := true
-  for [type,:flist] in $options repeat
-    type1 := selectOptionLC(type,'(boot lisp meta delete),nil)
-    type1 = 'delete => nil
-    for file in flist repeat
-      fl := pathname [file,type1,'"*"]
-      deleteFlag => SETQ($sourceFiles,DELETE(fl,$sourceFiles))
-      null (MAKE_-INPUT_-FILENAME fl) => sayKeyedMsg("S2IZ0035",[namestring fl])
-      updateSourceFiles fl
-  SAY " "
-  centerAndHighlight(" User-specified work files ",$LINELENGTH,specialChar 'hbar)
-  SAY " "
-  null $sourceFiles => SAY '"   no files specified"
-  SETQ($sourceFiles,SORTBY('pathnameType,$sourceFiles))
-  for fl in $sourceFiles repeat sayBrightly ["   " ,namestring fl]
-
---% )zsystemdevelopment
-
-zsystemdevelopment l == zsystemDevelopmentSpad2Cmd l
-
-zsystemDevelopmentSpad2Cmd l == zsystemdevelopment1 (l,$InteractiveMode)
-
-zsystemdevelopment1(l,im) ==
-  $InteractiveMode : local := im
-  fromopt := nil
-  -- cycle through once to see if )from is mentioned
-  for [opt,:optargs] in $options repeat
-    opt1 := selectOptionLC(opt,'(from),nil)
-    opt1 = 'from => fromopt := [['FROM,:optargs]]
-  for [opt,:optargs] in $options repeat
-    if null optargs then optargs := l
-    newopt := APPEND(optargs,fromopt)
-    opt1 := selectOptionLC(opt,'(from),nil)
-    opt1 = 'from => nil
-    opt = "c"   => _/D_,1 (newopt ,_/COMP(),NIL,NIL)
-    opt = "d"   => _/D_,1 (newopt ,'DEFINE,NIL,NIL)
-    opt = "dt"  => _/D_,1 (newopt ,'DEFINE,NIL,true)
-    opt = "ct"  => _/D_,1 (newopt ,_/COMP(),NIL,true)
-    opt = "ctl"  => _/D_,1 (newopt ,_/COMP(),NIL,'TRACELET)
-    opt = "ec"  => _/D_,1 (newopt ,_/COMP(),true,NIL)
-    opt = "ect" => _/D_,1 (newopt ,_/COMP(),true,true)
-    opt = "e"   => _/D_,1 (newopt ,NIL,true,NIL)
-    opt = "version" => version()
-    opt = "pause" =>
-      conStream := DEFIOSTREAM ('((DEVICE . CONSOLE) (QUAL . V)),120,0)
-      NEXT conStream
-      SHUT conStream
-    opt = "update" or opt = "patch" =>
-      $InteractiveMode := nil
-      upf := [KAR optargs or _/VERSION, KADR optargs or _/WSNAME,
-              KADDR optargs or '_*]
-      fun := (opt = "patch" => '_/UPDATE_-LIB_-1; '_/UPDATE_-1)
-      CATCH('FILENAM, FUNCALL(fun, upf))
-      sayMessage '"   Update/patch is completed."
-    null optargs =>
-      sayBrightly ['"   An argument is required for",:bright opt]
-    sayMessage ['"   Unknown option:",:bright opt,"    ",'%l,
-      '"   Available options are", _
-      :bright '"c ct e ec ect cls pause update patch compare record"]
-
 --% Synonym File Reader
 
 --------------------> NEW DEFINITION (override in util.lisp.pamphlet)



From MAILER-DAEMON Fri Mar 06 06:33:36 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LfYJ6-0003Rf-Fr
	for mharc-axiom-developer@gnu.org; Fri, 06 Mar 2009 06:33:36 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LfYJ5-0003Ra-4W
	for axiom-developer@nongnu.org; Fri, 06 Mar 2009 06:33:35 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LfYJ3-0003RO-DL
	for axiom-developer@nongnu.org; Fri, 06 Mar 2009 06:33:33 -0500
Received: from [199.232.76.173] (port=48761 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LfYJ3-0003RL-6s
	for axiom-developer@nongnu.org; Fri, 06 Mar 2009 06:33:33 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:33878
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LfYJ2-0008MJ-Lc
	for axiom-developer@nongnu.org; Fri, 06 Mar 2009 06:33:33 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n26BXRug029962;
	Fri, 6 Mar 2009 05:33:27 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n26BXQhL029953;
	Fri, 6 Mar 2009 05:33:26 -0600
Date: Fri, 6 Mar 2009 05:33:26 -0600
Message-Id: <200903061133.n26BXQhL029953@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: Error: [-] ERROR:
	/var/run/p0f.sock: Connection refused
Cc: 
Subject: [Axiom-developer] 20090305.01.tpd.patch (bookvol10.3 add
	Grabmeier/Hebisch Float fix)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Fri, 06 Mar 2009 11:33:35 -0000

Johannes Grabmeier pointed out failures in Float output when
manipulating the outputFixed parameter and posted fixes.  Waldek
Hebisch rewrote and added to the fix. Both have been added to
bookvol10.3 Axiom Domains / Float / fixed function has been modified
with these fixes.

=======================================================================
diff --git a/books/bookvol10.3.pamphlet b/books/bookvol10.3.pamphlet
index 2972ab5..014f47c 100644
--- a/books/bookvol10.3.pamphlet
+++ b/books/bookvol10.3.pamphlet
@@ -32211,13 +32211,12 @@ It is currently unknown whether the unexpected behaviour
 of shift for negative arguments will cause bugs in other
 parts of Axiom.
 <<Float.input>>=
--- float.spad.pamphlet Float.input
 )sys rm -f Float.output
 )spool Float.output
 )set message test on
 )set message auto off
 )clear all
---S 1 of 37
+--S 1 of 64
 1.234
 --R 
 --R
@@ -32225,7 +32224,7 @@ parts of Axiom.
 --R                                                                  Type: Float
 --E 1
 
---S 2 of 37
+--S 2 of 64
 1.234E2
 --R 
 --R
@@ -32233,7 +32232,7 @@ parts of Axiom.
 --R                                                                  Type: Float
 --E 2
 
---S 3 of 37
+--S 3 of 64
 sqrt(1.2 + 2.3 / 3.4 ** 4.5)
 --R 
 --R
@@ -32241,7 +32240,7 @@ sqrt(1.2 + 2.3 / 3.4 ** 4.5)
 --R                                                                  Type: Float
 --E 3
 
---S 4 of 37
+--S 4 of 64
 i := 3 :: Float
 --R 
 --R
@@ -32249,7 +32248,7 @@ i := 3 :: Float
 --R                                                                  Type: Float
 --E 4
 
---S 5 of 37
+--S 5 of 64
 i :: Integer
 --R 
 --R
@@ -32257,7 +32256,7 @@ i :: Integer
 --R                                                                Type: Integer
 --E 5
 
---S 6 of 37
+--S 6 of 64
 i :: Fraction Integer 
 --R 
 --R
@@ -32265,7 +32264,7 @@ i :: Fraction Integer
 --R                                                       Type: Fraction Integer
 --E 6
 
---S 7 of 37
+--S 7 of 64
 r := 3/7 :: Float 
 --R 
 --R
@@ -32273,7 +32272,7 @@ r := 3/7 :: Float
 --R                                                                  Type: Float
 --E 7
 
---S 8 of 37
+--S 8 of 64
 r :: Fraction Integer
 --R 
 --R
@@ -32283,7 +32282,7 @@ r :: Fraction Integer
 --R                                                       Type: Fraction Integer
 --E 8
 
---S 9 of 37
+--S 9 of 64
 r :: Integer
 --R 
 --R 
@@ -32293,7 +32292,7 @@ r :: Integer
 --R
 --E 9
 
---S 10 of 37
+--S 10 of 64
 truncate 3.6
 --R 
 --R
@@ -32301,7 +32300,7 @@ truncate 3.6
 --R                                                                  Type: Float
 --E 10
 
---S 11 of 37
+--S 11 of 64
 round 3.6
 --R 
 --R
@@ -32309,7 +32308,7 @@ round 3.6
 --R                                                                  Type: Float
 --E 11
 
---S 12 of 37
+--S 12 of 64
 truncate(-3.6)
 --R 
 --R
@@ -32317,7 +32316,7 @@ truncate(-3.6)
 --R                                                                  Type: Float
 --E 12
 
---S 13 of 37
+--S 13 of 64
 round(-3.6)
 --R 
 --R
@@ -32325,7 +32324,7 @@ round(-3.6)
 --R                                                                  Type: Float
 --E 13
 
---S 14 of 37
+--S 14 of 64
 fractionPart 3.6
 --R 
 --R
@@ -32333,7 +32332,7 @@ fractionPart 3.6
 --R                                                                  Type: Float
 --E 14
 
---S 15 of 37
+--S 15 of 64
 digits 40 
 --R 
 --R
@@ -32341,7 +32340,7 @@ digits 40
 --R                                                        Type: PositiveInteger
 --E 15
 
---S 16 of 37
+--S 16 of 64
 sqrt 0.2
 --R 
 --R
@@ -32349,7 +32348,7 @@ sqrt 0.2
 --R                                                                  Type: Float
 --E 16
 
---S 17 of 37
+--S 17 of 64
 pi()$Float
 --R 
 --R
@@ -32357,7 +32356,7 @@ pi()$Float
 --R                                                                  Type: Float
 --E 17
 
---S 18 of 37
+--S 18 of 64
 digits 500
 --R 
 --R
@@ -32365,7 +32364,7 @@ digits 500
 --R                                                        Type: PositiveInteger
 --E 18
 
---S 19 of 37
+--S 19 of 64
 pi()$Float
 --R 
 --R
@@ -32381,7 +32380,7 @@ pi()$Float
 --R                                                                  Type: Float
 --E 19
 
---S 20 of 37
+--S 20 of 64
 digits 20
 --R 
 --R
@@ -32389,7 +32388,7 @@ digits 20
 --R                                                        Type: PositiveInteger
 --E 20
 
---S 21 of 37
+--S 21 of 64
 outputSpacing 0; x := sqrt 0.2
 --R 
 --R
@@ -32397,7 +32396,7 @@ outputSpacing 0; x := sqrt 0.2
 --R                                                                  Type: Float
 --E 21
 
---S 22 of 37
+--S 22 of 64
 outputSpacing 5; x
 --R 
 --R
@@ -32405,7 +32404,7 @@ outputSpacing 5; x
 --R                                                                  Type: Float
 --E 22
 
---S 23 of 37
+--S 23 of 64
 y := x/10**10
 --R 
 --R
@@ -32413,7 +32412,7 @@ y := x/10**10
 --R                                                                  Type: Float
 --E 23
 
---S 24 of 37
+--S 24 of 64
 outputFloating(); x 
 --R 
 --R
@@ -32421,7 +32420,7 @@ outputFloating(); x
 --R                                                                  Type: Float
 --E 24
 
---S 25 of 37
+--S 25 of 64
 outputFixed(); y 
 --R 
 --R
@@ -32429,7 +32428,7 @@ outputFixed(); y
 --R                                                                  Type: Float
 --E 25
 
---S 26 of 37
+--S 26 of 64
 outputFloating 2; y 
 --R 
 --R
@@ -32437,7 +32436,7 @@ outputFloating 2; y
 --R                                                                  Type: Float
 --E 26
 
---S 27 of 37
+--S 27 of 64
 outputFixed 2; x 
 --R 
 --R
@@ -32445,13 +32444,13 @@ outputFixed 2; x
 --R                                                                  Type: Float
 --E 27
 
---S 28 of 37
+--S 28 of 64
 outputGeneral()
 --R 
 --R                                                                   Type: Void
 --E 28
 
---S 29 of 37
+--S 29 of 64
 a: Matrix Fraction Integer := matrix [ [1/(i+j+1) for j in 0..9] for i in 0..9]
 --R 
 --R
@@ -32497,7 +32496,7 @@ a: Matrix Fraction Integer := matrix [ [1/(i+j+1) for j in 0..9] for i in 0..9]
 --R                                                Type: Matrix Fraction Integer
 --E 29
 
---S 30 of 37
+--S 30 of 64
 d:= determinant a
 --R 
 --R
@@ -32507,7 +32506,7 @@ d:= determinant a
 --R                                                       Type: Fraction Integer
 --E 30
 
---S 31 of 37
+--S 31 of 64
 d :: Float
 --R 
 --R
@@ -32515,7 +32514,7 @@ d :: Float
 --R                                                                  Type: Float
 --E 31
 
---S 32 of 37
+--S 32 of 64
 b: Matrix DoubleFloat := matrix [ [1/(i+j+1$DoubleFloat) for j in 0..9] for i in 0..9]
 --R 
 --R
@@ -32575,7 +32574,7 @@ b: Matrix DoubleFloat := matrix [ [1/(i+j+1$DoubleFloat) for j in 0..9] for i in
 --R                                                     Type: Matrix DoubleFloat
 --E 32
 
---S 33 of 37
+--S 33 of 64
 determinant b
 --R 
 --R
@@ -32583,7 +32582,7 @@ determinant b
 --R                                                            Type: DoubleFloat
 --E 33
 
---S 34 of 37
+--S 34 of 64
 digits 40 
 --R 
 --R
@@ -32591,7 +32590,7 @@ digits 40
 --R                                                        Type: PositiveInteger
 --E 34
 
---S 35 of 37
+--S 35 of 64
 c: Matrix Float := matrix [ [1/(i+j+1$Float) for j in 0..9] for i in 0..9]
 --R 
 --R
@@ -32685,7 +32684,7 @@ c: Matrix Float := matrix [ [1/(i+j+1$Float) for j in 0..9] for i in 0..9]
 --R                                                           Type: Matrix Float
 --E 35
 
---S 36 of 37
+--S 36 of 64
 determinant c
 --R 
 --R
@@ -32693,13 +32692,208 @@ determinant c
 --R                                                                  Type: Float
 --E 36
 
---S 37 of 37
+--S 37 of 64
 digits 20
 --R 
 --R
 --R   (36)  40
 --R                                                        Type: PositiveInteger
 --E 37
+
+)clear all
+
+--S 38 of 64
+outputFixed()
+--R 
+--R                                                                   Type: Void
+--E 38
+
+--S 39 of 64
+a:=3.0
+--R 
+--R
+--R   (2)  3.0
+--R                                                                  Type: Float
+--E 39
+
+--S 40 of 64
+b:=3.1
+--R 
+--R
+--R   (3)  3.1
+--R                                                                  Type: Float
+--E 40
+
+--S 41 of 64
+c:=numeric pi()
+--R 
+--R
+--R   (4)  3.14159 26535 89793 2385
+--R                                                                  Type: Float
+--E 41
+
+--S 42 of 64
+d:=0.0
+--R 
+--R
+--R   (5)  0.0
+--R                                                                  Type: Float
+--E 42
+
+--S 43 of 64
+outputFixed 2
+--R 
+--R                                                                   Type: Void
+--E 43
+
+--S 44 of 64
+a
+--R 
+--R
+--R   (7)  3.00
+--R                                                                  Type: Float
+--E 44
+
+--S 45 of 64
+b
+--R 
+--R
+--R   (8)  3.10
+--R                                                                  Type: Float
+--E 45
+
+--S 46 of 64
+c
+--R 
+--R
+--R   (9)  3.14
+--R                                                                  Type: Float
+--E 46
+
+--S 47 of 64
+d
+--R 
+--R
+--R   (10)  0.00
+--R                                                                  Type: Float
+--E 47
+
+--S 48 of 64
+outputFixed 0
+--R 
+--R                                                                   Type: Void
+--E 48
+
+--S 49 of 64
+a
+--R 
+--R
+--R   (12)  3.0
+--R                                                                  Type: Float
+--E 49
+
+--S 50 of 64
+b
+--R 
+--R
+--R   (13)  3.
+--R                                                                  Type: Float
+--E 50
+
+--S 51 of 64
+c
+--R 
+--R
+--R   (14)  3.
+--R                                                                  Type: Float
+--E 51
+
+--S 52 of 64
+31.1
+--R 
+--R
+--R   (15)  31.
+--R                                                                  Type: Float
+--E 52
+
+--S 53 of 64
+310.1
+--R 
+--R
+--R   (16)  310.
+--R                                                                  Type: Float
+--E 53
+
+--S 54 of 64
+d
+--R 
+--R
+--R   (17)  0.0
+--R                                                                  Type: Float
+--E 54
+
+--S 55 of 64
+outputFixed(0)
+--R                                                                   Type: Void
+--E 55
+
+--S 56 of 64
+1.1
+--R
+--R   (19)  1.
+--R                                                                  Type: Float
+--E 56
+
+--S 57 of 64
+3111.1
+--R
+--R   (20)  3111.
+--R                                                                  Type: Float
+--E 57
+
+--S 58 of 64
+1234567890.1
+--R
+--R   (21)  12345 67890.
+--R                                                                  Type: Float
+--E 58
+
+--S 59 of 64
+outputFixed(12)
+--R                                                                   Type: Void
+--E 59
+
+--S 60 of 64
+1234567890.1
+--R
+--R   (23)  12345 67890.09999 99999 99
+--R                                                                  Type: Float
+--E 60
+
+--S 61 of 64
+outputFixed(15)
+--R                                                                   Type: Void
+--E 61
+
+--S 62 of 64
+1234567890.1
+--R
+--R   (25)  12345 67890.09999 99999 98545
+--R                                                                  Type: Float
+--E 62
+
+--S 63 of 64
+outputFixed(2)
+--R                                                                   Type: Void
+--E 63
+
+--S 64 of 64
+1234567890.1
+--R
+--R   (27)  12345 67890.10
+--R                                                                  Type: Float
+--E 64
+
 )spool
 )lisp (bye)
 @
@@ -33975,13 +34169,23 @@ Float():
       t
 
    fixed f ==
-      zero? f => "0.0"
+      d := if OUTPREC() = -1 then digits::I else OUTPREC()
+      dpos:N:= if (d > 0) then d::N else 1::N
+      zero? f =>
+        OUTPREC() = -1 => "0.0"
+        concat("0",concat(".",padFromLeft new(dpos,zero)))
       zero? exponent f =>
-        padFromRight concat(convert(mantissa f)@S, ".0")
+        concat(padFromRight convert(mantissa f)@S,
+               concat(".",padFromLeft new(dpos,zero)))
       negative? f => concat("-", fixed abs f)
-      d := if OUTPREC() = -1 then digits::I else OUTPREC()
---    g := convert10(abs f,digits); m := g.mantissa; e := g.exponent
-      g := convert10(abs f,d); m := g.mantissa; e := g.exponent
+      bl := LENGTH(f.mantissa) + f.exponent
+      dd :=
+        OUTPREC() = -1 => d
+        bl > 0 => (146*bl) quo 485 + 1 + d
+        d
+      g := convert10(abs f,dd)
+      m := g.mantissa
+      e := g.exponent
       if OUTPREC() ^= -1 then
          -- round g to OUTPREC digits after the decimal point
          l := length10 m
diff --git a/changelog b/changelog
index eda3d93..9d2a7f5 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,8 @@
+20090305 tpd src/axiom-website/patches.html 20090305.01.tpd.patch
+20090305 jxb books/bookvol10.3 fix Float outputFixed handling
+20090305 jxb Johannes Grabmeier <grabm@heidelbg.ibm.com>
+20090305 tpd src/input/ndftip.input fix count mismatch
+20090305 tpd src/input/test.input fix count mismatch
 20090304 tpd src/axiom-website/patches.html 20090304.01.tpd.patch
 20090304 tpd books/bookvol10.4 fix typo
 20090304 tpd books/bookvol5 add user level command roots
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index 18722ce..b2dbc9c 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -987,5 +987,7 @@ bookvol10.4 add API ApplicationProgramInterface<br/>
 bookvol10.4 add Nag documentation<br/>
 <a href="patches/20090304.01.tpd.patch">20090304.01.tpd.patch</a>
 bookvol5 add user level command roots<br/>
+<a href="patches/20090305.01.tpd.patch">20090305.01.tpd.patch</a>
+bookvol10.3 add Grabmeier/Waldek fixes to Float<br/>
  </body>
 </html>
diff --git a/src/input/ndftip.input.pamphlet b/src/input/ndftip.input.pamphlet
index 3e4c0ab..11945fc 100644
--- a/src/input/ndftip.input.pamphlet
+++ b/src/input/ndftip.input.pamphlet
@@ -586,7 +586,7 @@ hdftsD := nagHermitianDFT seqsD;
 --S 34 of 45 used to work?
 map(expand,hdftsD) :: List Vector Complex Float
 --R 
---R   There are 68 exposed and 9 unexposed library operations named map 
+--R   There are 74 exposed and 8 unexposed library operations named map 
 --R      having 2 argument(s) but none was determined to be applicable. 
 --R      Use HyperDoc Browse, or issue
 --R                               )display op map
diff --git a/src/input/test.input.pamphlet b/src/input/test.input.pamphlet
index 09163a6..e4f29ea 100644
--- a/src/input/test.input.pamphlet
+++ b/src/input/test.input.pamphlet
@@ -846,7 +846,7 @@ m = [[1,2],[2,3]]  -- Should return type EQ POLY SQMATRIX(2, INT)
 --S 65 of 188
 1/"asd"
 --R 
---R   There are 13 exposed and 12 unexposed library operations named / 
+--R   There are 14 exposed and 12 unexposed library operations named / 
 --R      having 2 argument(s) but none was determined to be applicable. 
 --R      Use HyperDoc Browse, or issue
 --R                                )display op /




From MAILER-DAEMON Sat Mar 07 21:27:25 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Lg8jd-0002FA-5b
	for mharc-axiom-developer@gnu.org; Sat, 07 Mar 2009 21:27:25 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Lg8jb-0002Co-71
	for axiom-developer@nongnu.org; Sat, 07 Mar 2009 21:27:23 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Lg8jW-00026v-Oa
	for axiom-developer@nongnu.org; Sat, 07 Mar 2009 21:27:22 -0500
Received: from [199.232.76.173] (port=56037 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Lg8jW-00026c-IJ
	for axiom-developer@nongnu.org; Sat, 07 Mar 2009 21:27:18 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:50300
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1Lg8jU-0001Io-Ew
	for axiom-developer@nongnu.org; Sat, 07 Mar 2009 21:27:18 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n282REug022509;
	Sat, 7 Mar 2009 20:27:14 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n282REjJ022506;
	Sat, 7 Mar 2009 20:27:14 -0600
Date: Sat, 7 Mar 2009 20:27:14 -0600
Message-Id: <200903080227.n282REjJ022506@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090307.01.tpd.patch (bookvol5 add trace root)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sun, 08 Mar 2009 02:27:23 -0000

The )trace function was contained in a single file, trace.boot.
This file was removed and all of the code merged into bookvol5
A first patch cleanup of the lisp code was done.

Tim
=======================================================================
diff --git a/books/bookvol5.pamphlet b/books/bookvol5.pamphlet
index 2b28252..8b2dfe0 100644
--- a/books/bookvol5.pamphlet
+++ b/books/bookvol5.pamphlet
@@ -384,7 +384,7 @@ Starts the interpreter but does not read in profiles, etc.
     (progn 
      (spadlet mode '|restart|) 
      (do () 
-         ((null (boot-equal mode '|restart|)) NIL)
+         ((null (boot-equal mode '|restart|)) nil)
       (seq 
        (exit 
         (progn 
@@ -639,7 +639,7 @@ minus any leading spaces.
 
 @
 
-\subsection{make-absolute-filename}
+\subsection{defun make-absolute-filename}
 Prefix a filename with the {\bf AXIOM} shell variable.
 <<defun make-absolute-filename>>=
 (defun make-absolute-filename (name)
@@ -2973,7 +2973,7 @@ displayFrameNames() ==
     (progn
      (spadlet fs
       (prog (tmp0)
-       (spadlet tmp0 NIL)
+       (spadlet tmp0 nil)
        (return
         (do ((tmp1 |$interpreterFrameRing| (cdr tmp1)) (f nil))
             ((or (atom tmp1)
@@ -2983,7 +2983,7 @@ displayFrameNames() ==
           (exit
            (setq tmp0
             (append tmp0 (cons '|%l| 
-              (cons (makestring "     ") (|bright| (frameName f))))))))))))
+              (cons "     " (|bright| (frameName f))))))))))))
       (|sayKeyedMsg| 'S2IZ0024 (cons fs nil))))))) ; frame names are ...
 
 @
@@ -3154,7 +3154,7 @@ frameSpad2Cmd args ==
     (cond
      (|$options|
       (|throwKeyedMsg| 'S2IZ0016 ; frame command does not take options
-       (cons (makestring ")frame") nil)))
+       (cons ")frame" nil)))
      ((null args) 
        (|helpSpad2Cmd| (cons '|frame| nil)))
      (t
@@ -3603,7 +3603,7 @@ initHistList() ==
         (spadlet li (cons nil li)))))
      (rplacd |$HistList| li) 
      (spadlet |$HistListAct| 0) 
-     (spadlet |$HistRecord| NIL))))))
+     (spadlet |$HistRecord| nil))))))
  
 @
 \subsection{defun history}
@@ -3674,7 +3674,7 @@ historySpad2Cmd() ==
       (prog (tmp1) 
         (spadlet tmp1 nil) 
         (return 
-         (do ((tmp2 |$options| (cdr tmp2)) (tmp3 NIL))
+         (do ((tmp2 |$options| (cdr tmp2)) (tmp3 nil))
              ((or (atom tmp2) 
                   (progn 
                     (setq tmp3 (car tmp2)) 
@@ -3810,20 +3810,20 @@ setHistoryCore inCore ==
   (cond 
    ((boot-equal inCore |$useInternalHistoryTable|) 
      (if inCore 
-        (|sayKeyedMsg| 'S2IH0030 NIL) ; memory history already in use
-        (|sayKeyedMsg| 'S2IH0029 NIL))) ; file history already in use
+        (|sayKeyedMsg| 'S2IH0030 nil) ; memory history already in use
+        (|sayKeyedMsg| 'S2IH0029 nil))) ; file history already in use
    ((null |$HiFiAccess|) 
      (spadlet |$useInternalHistoryTable| inCore) 
      (if inCore 
-        (|sayKeyedMsg| 'S2IH0032 NIL) ; use memory history
-        (|sayKeyedMsg| 'S2IH0031 NIL))) ; use file history
+        (|sayKeyedMsg| 'S2IH0032 nil) ; use memory history
+        (|sayKeyedMsg| 'S2IH0031 nil))) ; use file history
    (inCore 
      (spadlet |$internalHistoryTable| nil) 
      (cond 
       ((nequal |$IOindex| 0) 
         (spadlet l (length (rkeyids (|histFileName|)))) 
         (do ((|i| 1 (qsadd1 |i|)))
-            ((qsgreaterp |i| l) NIL)
+            ((qsgreaterp |i| l) nil)
          (seq 
           (exit 
            (progn 
@@ -3844,7 +3844,7 @@ setHistoryCore inCore ==
             (cons 'file (|histFileName|))
              nil))))
      (do ((tmp0 (reverse |$internalHistoryTable|) (cdr tmp0))
-          (tmp1 NIL))
+          (tmp1 nil))
          ((or (atom tmp0) 
               (progn 
                 (setq tmp1 (car tmp0))
@@ -3863,7 +3863,7 @@ setHistoryCore inCore ==
      (spadlet |$HiFiAccess| t)
      (spadlet |$internalHistoryTable| nil)
      (spadlet |$useInternalHistoryTable| nil)
-     (|sayKeyedMsg| 'S2IH0031 NIL))))) ; use file history
+     (|sayKeyedMsg| 'S2IH0031 nil))))) ; use file history
 
 @
 \subsection{defun writeInputLines}
@@ -4273,7 +4273,7 @@ undoChanges(li) ==
     (progn
      (when (null (boot-equal (cdr li) |$HistList|))
        (|undoChanges| (cdr li)))
-     (do ((tmp0 (car li) (cdr tmp0)) (p1 NIL))
+     (do ((tmp0 (car li) (cdr tmp0)) (p1 nil))
          ((or (atom tmp0) (progn (setq p1 (car tmp0)) nil)) nil)
       (seq
        (exit
@@ -4517,7 +4517,7 @@ restoreHistory(fn) ==
          (|sayKeyedMsg| 'S2IH0024  ; file does not exist
             (cons (|namestring| restfile) nil)))
        (t 
-         (spadlet |$options| NIL)
+         (spadlet |$options| nil)
          (|clearSpad2Cmd| '(|all|))
          (spadlet curfile (|histFileName|))
          (|histFileErase| curfile)
@@ -4660,9 +4660,9 @@ showHistory(arg) ==
               (t
                 (|sayMSG| 
                   (|concat| 
-                   (makestring "  ")
+                   "  "
                    (|bright| arg1)
-                   (makestring "is an invalid argument.")))))))))
+                   "is an invalid argument."))))))))
          (when (>= n |$IOindex|)
            (spadlet n (spaddifference |$IOindex| 1)))
          (spadlet mini (spaddifference |$IOindex| n))
@@ -4706,7 +4706,7 @@ showInput(mini,maxi) ==
   (return
    (seq
     (do ((|ind| mini (+ |ind| 1)))
-        ((> |ind| maxi) NIL)
+        ((> |ind| maxi) nil)
      (seq
       (exit
        (progn
@@ -4720,21 +4720,21 @@ showInput(mini,maxi) ==
           ((stringp l)
             (|sayMSG| 
              (cons 
-              (makestring "   [")
+              "   ["
               (cons |ind| 
-               (cons (makestring "] ")
+               (cons "] "
                 (cons (car vec) nil))))))
           (t
             (|sayMSG|
-             (cons (makestring "   [")
+             (cons "   ["
               (cons |ind|
-               (cons (makestring "] ") nil))))
+               (cons "] " nil))))
            (do ((tmp0 l (cdr tmp0)) (|ln| nil))
                ((or (atom tmp0) (progn (setq |ln| (car tmp0)) nil)) nil)
             (seq
              (exit
               (|sayMSG|
-               (cons (makestring "      ") (cons |ln| nil)))))))))))))))) 
+               (cons "      " (cons |ln| nil)))))))))))))))) 
 
 @
 \subsection{defun showInOut}
@@ -5035,7 +5035,7 @@ writifyComplain s ==
 <<defun writifyComplain>>=
 (defun |writifyComplain| (s)
  (cond 
-   ((boot-equal |$writifyComplained| t) NIL)
+   ((boot-equal |$writifyComplained| t) nil)
    (t
     (spadlet |$writifyComplained| t)
     (|sayKeyedMsg| 'S2IH0027 (cons s nil))))) ; cannot save value
@@ -5205,7 +5205,7 @@ writify ob ==
        (hput |$seen| ob nob)
        (hput |$seen| nob nob)
        (do ((|i| 0 (qsadd1 |i|)))
-           ((qsgreaterp |i| n) NIL)
+           ((qsgreaterp |i| n) nil)
         (seq
          (exit
           (qsetvelt nob |i| (|writify,writifyInner| (QVELT ob |i|))))))
@@ -5435,9 +5435,9 @@ dewritify ob ==
             (when (intp oname) (exit (eval (gensymmer oname))))
             (exit (symbol-function oname))))
           (when (null (compiled-function-p f))
-           (exit (|error| (makestring "A required BPI does not exist."))))
+           (exit (|error| "A required BPI does not exist.")))
           (when (and (> (|#| ob) 3) (nequal (hasheq f) (elt ob 3)))
-           (exit (|error| (makestring "A required BPI has been redefined."))))
+           (exit (|error| "A required BPI has been redefined.")))
           (hput |$seen| ob f)
           (exit f))))
        (when (boot-equal type 'hashtable)
@@ -5479,8 +5479,7 @@ dewritify ob ==
           (when (null (fboundp name))
            (exit
             (|error| 
-             (strconc (makestring "undefined function: ")
-              (symbol-name name)))))
+             (strconc "undefined function: " (symbol-name name)))))
           (spadlet nob (cons (symbol-function name) vec))
           (hput |$seen| ob nob)
           (hput |$seen| nob nob)
@@ -5493,7 +5492,7 @@ dewritify ob ==
           (hput |$seen| nob nob)
           (exit nob))))
        (when (boot-equal type 'readtable)
-        (exit (|error| (makestring "Cannot de-writify a read table."))))
+        (exit (|error| "Cannot de-writify a read table.")))
        (when (boot-equal type 'nullstream)
         (exit |$NullStream|))
        (when (boot-equal type 'nonnullstream) 
@@ -5512,7 +5511,7 @@ dewritify ob ==
           (when (minusp sign)
            (exit (spaddifference fval)))
           (exit fval))))
-       (exit (|error| (makestring "Unknown type to de-writify."))))))
+       (exit (|error| "Unknown type to de-writify.")))))
     (when (pairp ob)
      (exit
       (seq
@@ -5626,7 +5625,7 @@ gensymInt g ==
    (seq
     (cond 
      ((null (gensymp g)) 
-       (|error| (makestring "Need a GENSYM")))
+       (|error| "Need a GENSYM"))
      (t
        (spadlet p (pname g))
        (spadlet n 0)
@@ -5654,7 +5653,7 @@ charDigitVal c ==
   (return
    (seq
     (progn
-     (spadlet digits (makestring "0123456789"))
+     (spadlet digits "0123456789")
      (spadlet n (spaddifference 1)) 
      (do ((tmp0 (spaddifference (|#| digits) 1)) (|i| 0 (qsadd1 |i|)))
          ((or (qsgreaterp |i| tmp0) (null (minusp n))) nil)
@@ -5664,7 +5663,7 @@ charDigitVal c ==
          ((boot-equal c (elt digits |i|)) (spadlet n |i|))
          (t nil)))))
      (cond
-      ((minusp n) (|error| (makestring "Character is not a digit")))
+      ((minusp n) (|error| "Character is not a digit"))
       (t n)))))))
 
 @
@@ -6621,6 +6620,3081 @@ to escape them with an underscore.
 \fnref{lisp}, and
 \fnref{ltrace}
 
+\subsection{The trace global variables}
+This decides when to give trace and untrace messages.
+<<initvars>>=
+(defvar |$traceNoisely| nil) 
+
+@
+
+This reports the traced functions
+<<initvars>>=
+(defvar |$reportSpadTrace| nil) 
+
+@
+
+<<initvars>>=
+(defvar |$optionAlist| nil) 
+
+@
+
+<<initvars>>=
+(defvar |$tracedMapSignatures| nil) 
+
+@
+
+<<initvars>>=
+(defvar |$traceOptionList|
+ '(|after| |before| |break| |cond| |count| |depth| |local| |mathprint| 
+   |nonquietly| |nt| |of| |only| |ops| |restore| |timer| |varbreak| 
+   |vars| |within|))
+
+@ 
+
+\subsection{defun trace}
+<<defun trace>>=
+(defun |trace| (l)
+ (|traceSpad2Cmd| l)) 
+
+@
+
+\subsection{defun traceSpad2Cmd}
+\begin{verbatim}
+;traceSpad2Cmd l ==
+;  if l is ['Tuple, l1] then l := l1
+;  $mapSubNameAlist:= getMapSubNames(l)
+;  trace1 augmentTraceNames(l,$mapSubNameAlist)
+;  traceReply()
+\end{verbatim}
+
+<<defun traceSpad2Cmd>>=
+(defun |traceSpad2Cmd| (l)
+ (let (tmp1 l1)
+  (cond
+   ((and (pairp l)
+         (eq (qcar l) '|Tuple|)
+         (progn
+          (setq tmp1 (qcdr l))
+          (and (pairp tmp1)
+               (eq (qcdr tmp1) nil)
+               (progn 
+                (setq l1 (qcar tmp1))
+                t))))
+      (setq l l1)))
+    (setq |$mapSubNameAlist| (|getMapSubNames| l))
+    (|trace1| (|augmentTraceNames| l |$mapSubNameAlist|))
+    (|traceReply|)))
+
+@
+
+\subsection{defun trace1}
+\begin{verbatim}
+;trace1 l ==
+;  $traceNoisely: local := NIL
+;  if hasOption($options,'nonquietly) then $traceNoisely := true
+;  hasOption($options,'off) =>
+;    (ops := hasOption($options,'ops)) or
+;      (lops := hasOption($options,'local)) =>
+;        null l => throwKeyedMsg("S2IT0019",NIL)
+;        constructor := unabbrev
+;          atom l => l
+;          null rest l =>
+;            atom first l => first l
+;            first first l
+;          NIL
+;        not(isFunctor constructor) => throwKeyedMsg("S2IT0020",NIL)
+;        if ops then
+;          ops := getTraceOption ops
+;          NIL
+;        if lops then
+;          lops := rest getTraceOption lops
+;          untraceDomainLocalOps(constructor,lops)
+;    (1 < # $options) and not hasOption($options,'nonquietly) =>
+;      throwKeyedMsg("S2IT0021",NIL)
+;    untrace l
+;  hasOption($options,'stats) =>
+;    (1 < # $options) =>
+;      throwKeyedMsg("S2IT0001",['")trace ... )stats"])
+;    [.,:opt] := CAR $options
+;    -- look for )trace )stats       to list the statistics
+;    --          )trace )stats reset to reset them
+;    null opt =>      -- list the statistics
+;      centerAndHighlight('"Traced function execution times",78,"-")
+;      ptimers ()
+;      SAY '" "
+;      centerAndHighlight('"Traced function execution counts",78,"-")
+;      pcounters ()
+;    selectOptionLC(first opt,'(reset),'optionError)
+;    resetSpacers()
+;    resetTimers()
+;    resetCounters()
+;    throwKeyedMsg("S2IT0002",NIL)
+;  a:= hasOption($options,'restore) =>
+;    null(oldL:= $lastUntraced) => nil
+;    newOptions:= DELETE(a,$options)
+;    null l => trace1 oldL
+;    for x in l repeat
+;      x is [domain,:opList] and VECP domain =>
+;        sayKeyedMsg("S2IT0003",[devaluate domain])
+;      $options:= [:newOptions,:LASSOC(x,$optionAlist)]
+;      trace1 LIST x
+;  null l => nil
+;  l is ["?"] => _?t()
+;  traceList:= [transTraceItem x for x in l] or return nil
+;  for x in traceList repeat $optionAlist:=
+;    ADDASSOC(x,$options,$optionAlist)
+;  optionList:= getTraceOptions $options
+;  argument:=
+;    domainList:= LASSOC("of",optionList) =>
+;      LASSOC("ops",optionList) =>
+;        throwKeyedMsg("S2IT0004",NIL)
+;      opList:=
+;        traceList => LIST ["ops",:traceList]
+;        nil
+;      varList:=
+;        y:= LASSOC("vars",optionList) => LIST ["vars",:y]
+;        nil
+;      [:domainList,:opList,:varList]
+;    optionList => [:traceList,:optionList]
+;    traceList
+;  _/TRACE_,0 [funName for funName in argument]
+;  saveMapSig [funName for funName in argument]
+\end{verbatim}
+
+<<defun trace1>>=
+(defun |trace1| (|l|)
+ (prog (|$traceNoisely| |constructor| |ops| |lops| temp1 |opt| |a| 
+        |oldL| |newOptions| |domain| |traceList| |optionList| |domainList| 
+        |opList| |y| |varList| |argument|)
+  (declare (special |$traceNoisely|))
+  (return
+   (seq
+    (progn 
+     (spadlet |$traceNoisely| nil)
+     (cond
+      ((|hasOption| |$options| '|nonquietly|)
+        (spadlet |$traceNoisely| t)))
+     (cond
+      ((|hasOption| |$options| '|off|)
+       (cond
+        ((or (spadlet |ops| (|hasOption| |$options| '|ops|))
+             (spadlet |lops| (|hasOption| |$options| '|local|)))
+          (cond
+           ((null |l|) (|throwKeyedMsg| 's2it0019 nil))
+           (t
+             (spadlet |constructor|
+              (|unabbrev|
+               (cond
+                ((atom |l|) |l|)
+                ((null (cdr |l|))
+                  (cond
+                   ((atom (car |l|)) (car |l|))
+                   (t (car (car |l|)))))
+                (t nil))))
+             (cond
+              ((null (|isFunctor| |constructor|))
+                (|throwKeyedMsg| 's2it0020 nil))
+              (t
+                (cond (|ops| (spadlet |ops| (|getTraceOption| |ops|)) nil))
+                (cond 
+                 (|lops|
+                  (spadlet |lops| (cdr (|getTraceOption| |lops|)))
+                  (|untraceDomainLocalOps| |constructor| |lops|))
+                 (t nil)))))))
+        ((and (qslessp 1 (|#| |$options|))
+              (null (|hasOption| |$options| '|nonquietly|)))
+          (|throwKeyedMsg| 's2it0021 nil))
+        (t (|untrace| |l|))))
+      ((|hasOption| |$options| '|stats|)
+        (cond
+         ((qslessp 1 (|#| |$options|))
+          (|throwKeyedMsg| 's2it0001 (cons ")trace ... )stats" nil)))
+         (t
+           (spadlet temp1 (car |$options|))
+           (spadlet |opt| (cdr temp1))
+           (cond
+            ((null |opt|)
+              (|centerAndHighlight| "Traced function execution times" 78 '-)
+              (|ptimers|)
+              (say " ")
+              (|centerAndHighlight| "Traced function execution counts" 78 '-)
+              (|pcounters|))
+            (t
+              (|selectOptionLC| (car |opt|) '(|reset|) '|optionError|)
+              (|resetSpacers|)
+              (|resetTimers|)
+              (|resetCounters|)
+              (|throwKeyedMsg| 's2it0002 nil))))))
+      ((spadlet |a| (|hasOption| |$options| '|restore|))
+        (cond
+         ((null (spadlet |oldL| |$lastUntraced|)) nil)
+         (t
+           (spadlet |newOptions| (|delete| |a| |$options|))
+           (cond
+            ((null |l|) (|trace1| |oldL|))
+            (t
+             (do ((t0 |l| (cdr t0)) (|x|l nil))
+                 ((or (atom t0) (progn (setq |x| (car t0)) nil)) nil)
+              (seq
+               (exit
+                (cond
+                 ((and (pairp |x|)
+                       (progn
+                        (spadlet |domain| (qcar |x|))
+                        (spadlet |opList| (qcdr |x|))
+                        t)
+                       (vecp |domain|))
+                   (|sayKeyedMsg| 's2it0003 (cons (|devaluate| |domain|) nil)))
+                 (t
+                   (spadlet |$options|
+                    (append |newOptions| (lassoc |x| |$optionAlist|)))
+                   (|trace1| (list |x|))))))))))))
+      ((null |l|) nil)
+      ((and (pairp |l|) (eq (qcdr |l|) nil) (eq (qcar |l|) '?)) (|?t|))
+      (t
+       (spadlet |traceList|
+        (or
+         (prog (t1)
+          (spadlet t1 nil)
+          (return
+           (do ((t2 |l| (cdr t2)) (|x| nil))
+               ((or (atom t2) 
+                    (progn (setq |x| (car t2)) nil))
+                (nreverse0 t1))
+            (seq
+             (exit
+              (setq t1 (cons (|transTraceItem| |x|) t1)))))))
+         (return nil)))
+       (do ((t3 |traceList| (cdr t3)) (|x| nil))
+           ((or (atom t3) (progn (setq |x| (car t3)) nil)) nil)
+         (seq
+          (exit 
+           (spadlet |$optionAlist| (addassoc |x| |$options| |$optionAlist|)))))
+       (spadlet |optionList| (|getTraceOptions| |$options|))
+       (spadlet |argument|
+        (cond
+         ((spadlet |domainList| (lassoc '|of| |optionList|))
+           (cond
+            ((lassoc '|ops| |optionList|)
+              (|throwKeyedMsg| 's2it0004 nil))
+            (t
+              (spadlet |opList|
+               (cond
+                (|traceList| (list (cons '|ops| |traceList|)))
+                (t nil)))
+              (spadlet |varList|
+               (cond
+                ((spadlet |y| (lassoc '|vars| |optionList|))
+                  (list (cons '|vars| |y|)))
+                (t nil)))
+              (append |domainList| (append |opList| |varList|)))))
+         (|optionList| (append |traceList| |optionList|))
+         (t |traceList|)))
+       (|/TRACE,0|
+        (prog (t4)
+         (spadlet t4 nil)
+         (return
+          (do ((t5 |argument| (cdr t5)) (|funName| nil))
+              ((or (atom t5) 
+                   (progn (setq |funName| (car t5)) nil))
+                (nreverse0 t4))
+           (seq
+            (exit
+             (setq t4 (cons |funName| t4))))))))
+       (|saveMapSig|
+        (prog (t6)
+         (spadlet t6 nil)
+         (return
+          (do ((t7 |argument| (cdr t7)) (|funName| nil))
+              ((or (atom t7)
+                   (progn (setq |funName| (car t7)) nil))
+                (nreverse0 t6))
+           (seq
+            (exit
+             (setq t6 (cons |funName| t6))))))))))))))) 
+
+@
+
+\subsection{defun getTraceOptions}
+\begin{verbatim}
+;getTraceOptions options ==
+;  $traceErrorStack: local := nil
+;  optionList:= [getTraceOption x for x in options]
+;  $traceErrorStack =>
+;    null rest $traceErrorStack =>
+;      [key,parms] := first $traceErrorStack
+;      throwKeyedMsg(key,['"",:parms])
+;    throwListOfKeyedMsgs("S2IT0017",[# $traceErrorStack],
+;      NREVERSE $traceErrorStack)
+;  optionList
+\end{verbatim}
+
+<<defun getTraceOptions>>=
+(defun |getTraceOptions| (|options|)
+ (prog (|$traceErrorStack| |optionList| temp1 |key| |parms|)
+  (declare (special |$traceErrorStack|))
+  (return
+   (seq
+    (progn
+     (spadlet |$traceErrorStack| nil)
+     (spadlet |optionList|
+      (prog (t0) 
+       (spadlet t0 nil)
+       (return
+        (do ((t1 |options| (cdr t1)) (|x| nil))
+            ((or (atom t1) (progn (setq |x| (car t1)) nil)) (nreverse0 t0))
+         (seq
+          (exit
+           (setq t0 (cons (|getTraceOption| |x|) t0))))))))
+     (cond
+      (|$traceErrorStack|
+       (cond
+        ((null (cdr |$traceErrorStack|))
+          (spadlet temp1 (car |$traceErrorStack|))
+          (spadlet |key| (car temp1))
+          (spadlet |parms| (cadr temp1))
+          (|throwKeyedMsg| |key| (cons "" |parms|)))
+        (t
+          (|throwListOfKeyedMsgs| 's2it0017
+           (cons (|#| |$traceErrorStack|) nil)
+           (nreverse |$traceErrorStack|)))))
+      (t |optionList|))))))) 
+
+@
+
+\subsection{defun saveMapSig}
+\begin{verbatim}
+;saveMapSig(funNames) ==
+;  for name in funNames repeat
+;    map:= RASSOC(name,$mapSubNameAlist) =>
+;      $tracedMapSignatures:= ADDASSOC(name,getMapSig(map,name),
+;        $tracedMapSignatures)
+\end{verbatim}
+
+<<defun saveMapSig>>=
+(defun |saveMapSig| (|funNames|)
+ (prog (|map|)
+  (return
+   (seq
+    (do ((t0 |funNames| (cdr t0)) (|name| nil))
+        ((or (atom t0) (progn (setq |name| (car t0)) nil)) nil)
+     (seq
+      (exit
+       (cond
+        ((spadlet |map| (|rassoc| |name| |$mapSubNameAlist|))
+         (exit
+          (spadlet |$tracedMapSignatures|
+           (addassoc |name| (|getMapSig| |map| |name|)
+                     |$tracedMapSignatures|)))))))))))) 
+
+@
+
+\subsection{defun getMapSig}
+\begin{verbatim}
+;getMapSig(mapName,subName) ==
+;  lmms:= get(mapName,'localModemap,$InteractiveFrame) =>
+;    for mm in lmms until sig repeat
+;      CADR mm = subName => sig:= CDAR mm
+;    sig
+\end{verbatim}
+
+<<defun getMapSig>>=
+(defun |getMapSig| (|mapName| |subName|)
+ (PROG (|lmms| |sig|)
+  (RETURN
+   (SEQ
+    (COND
+     ((SPADLET |lmms| (|get| |mapName| '|localModemap| |$InteractiveFrame|))
+      (EXIT
+       (SEQ
+        (DO ((t0 |lmms| (CDR t0)) (|mm| nil) (t1 nil |sig|))
+            ((OR (ATOM t0) (PROGN (SETQ |mm| (CAR t0)) nil) t1) nil)
+         (SEQ
+          (EXIT
+           (COND 
+            ((BOOT-EQUAL (CADR |mm|) |subName|)
+              (EXIT 
+               (SPADLET |sig| (CDAR |mm|))))))))
+        (EXIT |sig|))))))))) 
+
+@
+
+\subsection{defun getTraceOption}
+\begin{verbatim}
+;getTraceOption (x is [key,:l]) ==
+;  key:= selectOptionLC(key,$traceOptionList,'traceOptionError)
+;  x := [key,:l]
+;  MEMQ(key,'(nonquietly timer nt)) => x
+;  key='break =>
+;    null l => ['break,'before]
+;    opts := [selectOptionLC(y,'(before after),NIL) for y in l]
+;    and/[IDENTP y for y in opts] => ['break,:opts]
+;    stackTraceOptionError ["S2IT0008",NIL]
+;  key='restore =>
+;    null l => x
+;    stackTraceOptionError ["S2IT0009",[STRCONC('")",object2String key)]]
+;  key='only => ['only,:transOnlyOption l]
+;  key='within =>
+;    l is [a] and IDENTP a => x
+;    stackTraceOptionError ["S2IT0010",['")within"]]
+;  MEMQ(key,'(cond before after)) =>
+;    key:=
+;      key="cond" => "when"
+;      key
+;    l is [a] => [key,:l]
+;    stackTraceOptionError ["S2IT0011",[STRCONC('")",object2String key)]]
+;  key='depth =>
+;    l is [n] and FIXP n => x
+;    stackTraceOptionError ["S2IT0012",['")depth"]]
+;  key='count =>
+;    (null l) or (l is [n] and FIXP n) => x
+;    stackTraceOptionError ["S2IT0012",['")count"]]
+;  key="of" =>
+;    ["of",:[hn y for y in l]] where
+;      hn x ==
+;        atom x and not UPPER_-CASE_-P (STRINGIMAGE x).(0) =>
+;          isDomainOrPackage EVAL x => x
+;          stackTraceOptionError ["S2IT0013",[x]]
+;        g:= domainToGenvar x => g
+;        stackTraceOptionError ["S2IT0013",[x]]
+;  MEMQ(key,'(local ops vars)) =>
+;    null l or l is ["all"] => [key,:"all"]
+;    isListOfIdentifiersOrStrings l => x
+;    stackTraceOptionError ["S2IT0015",[STRCONC('")",object2String key)]]
+;  key='varbreak =>
+;    null l or l is ["all"] => ["varbreak",:"all"]
+;    isListOfIdentifiers l => x
+;    stackTraceOptionError ["S2IT0016",[STRCONC('")",object2String key)]]
+;  key='mathprint =>
+;    null l => x
+;    stackTraceOptionError ["S2IT0009",[STRCONC('")",object2String key)]]
+;  key => throwKeyedMsg("S2IT0005",[key])
+\end{verbatim}
+
+<<defun getTraceOption,hn>>=
+(defun |getTraceOption,hn| (|x|)
+ (prog (|g|)
+  (return
+   (seq
+    (if (and (atom |x|) (null (upper-case-p (elt (stringimage |x|) 0))))
+     (exit
+      (seq
+       (if (|isDomainOrPackage| (eval |x|)) (exit |x|))
+       (exit 
+        (|stackTraceOptionError|
+         (cons 's2it0013 (cons (cons |x| nil) nil)))))))
+    (if (spadlet |g| (|domainToGenvar| |x|)) (exit |g|))
+    (exit
+     (|stackTraceOptionError| (cons 's2it0013 (cons (cons |x| nil) nil)))))))) 
+
+@
+
+<<defun getTraceOption>>=
+(defun |getTraceOption| (|x|)
+ (prog (|l| |opts| |key| |a| |n|)
+  (return
+   (seq
+    (progn
+     (spadlet |key| (car |x|))
+     (spadlet |l| (cdr |x|))
+     (spadlet |key|
+       (|selectOptionLC| |key| |$traceOptionList| '|traceOptionError|))
+     (spadlet |x| (cons |key| |l|))
+     (cond
+      ((memq |key| '(|nonquietly| |timer| |nt|)) |x|)
+      ((boot-equal |key| '|break|)
+       (cond
+        ((null |l|) (cons '|break| (cons '|before| nil)))
+        (t
+          (spadlet |opts|
+           (prog (t0)
+            (spadlet t0 nil)
+            (return
+             (do ((t1 |l| (cdr t1)) (|y| nil))
+                 ((or (atom t1)
+                      (progn (setq |y| (car t1)) nil))
+                    (nreverse0 t0))
+              (seq 
+               (exit 
+                (setq t0 
+                 (cons 
+                  (|selectOptionLC| |y| '(|before| |after|) nil) t0))))))))
+          (cond
+           ((prog (t2)
+             (spadlet t2 t)
+             (return 
+              (do ((t3 nil (null t2)) (t4 |opts| (cdr t4)) (|y| nil))
+                  ((or t3 (atom t4) (progn (setq |y| (car t4)) nil)) t2)
+                 (seq
+                  (exit
+                   (setq t2 (and t2 (identp |y|))))))))
+              (cons '|break| |opts|))
+           (t
+            (|stackTraceOptionError| (cons 's2it0008 (cons nil nil))))))))
+      ((boot-equal |key| '|restore|)
+       (cond
+        ((null |l|) |x|)
+        (t 
+         (|stackTraceOptionError| 
+          (cons 's2it0009 
+           (cons (cons (strconc ")" (|object2String| |key|)) nil) nil))))))
+      ((boot-equal |key| '|only|) (cons '|only| (|transOnlyOption| |l|)))
+      ((boot-equal |key| '|within|)
+        (cond
+         ((and (pairp |l|) 
+               (eq (qcdr |l|) nil)
+               (progn (spadlet |a| (qcar |l|)) t)
+               (identp |a|))
+           |x|)
+         (t 
+           (|stackTraceOptionError| 
+            (cons 's2it0010 (cons (cons ")within" nil) nil))))))
+      ((memq |key| '(|cond| |before| |after|))
+        (spadlet |key| 
+         (cond 
+          ((boot-equal |key| '|cond|) '|when|)
+          (t |key|)))
+        (cond
+         ((and (pairp |l|) 
+               (eq (qcdr |l|) nil)
+               (progn (spadlet |a| (qcar |l|)) t))
+            (cons |key| |l|))
+         (t 
+          (|stackTraceOptionError|
+           (cons 's2it0011
+            (cons
+             (cons (strconc ")"
+              (|object2String| |key|)) nil) nil))))))
+      ((boot-equal |key| '|depth|)
+        (cond 
+         ((and (pairp |l|) 
+               (eq (qcdr |l|) nil)
+               (progn (spadlet |n| (qcar |l|)) t)
+               (fixp |n|))
+           |x|)
+         (t 
+          (|stackTraceOptionError| 
+           (cons 's2it0012 (cons (cons ")depth" nil) nil))))))
+      ((boot-equal |key| '|count|)
+        (cond 
+         ((or (null |l|) 
+              (and (pairp |l|) 
+                   (eq (qcdr |l|) nil)
+                   (progn (spadlet |n| (qcar |l|)) t)
+                   (fixp |n|)))
+            |x|)
+         (t 
+          (|stackTraceOptionError|
+            (cons 's2it0012 (cons (cons ")count" nil) nil))))))
+      ((boot-equal |key| '|of|)
+        (cons '|of|
+         (prog (t5)
+          (spadlet t5 nil)
+          (return
+           (do ((t6 |l| (cdr t6)) (|y| nil))
+               ((or (atom t6) (progn (setq |y| (car t6)) nil)) (nreverse0 t5))
+            (seq
+             (exit
+              (setq t5 (cons (|getTraceOption,hn| |y|) t5)))))))))
+      ((memq |key| '(|local| |ops| |vars|))
+        (cond
+         ((or (null |l|)
+              (and (pairp |l|) (eq (qcdr |l|) nil) (eq (qcar |l|) '|all|)))
+           (cons |key| '|all|))
+         ((|isListOfIdentifiersOrStrings| |l|) |x|)
+         (t
+           (|stackTraceOptionError|
+            (cons 's2it0015
+             (cons
+              (cons (strconc ")" (|object2String| |key|)) nil) nil))))))
+      ((boot-equal |key| '|varbreak|)
+        (cond
+         ((or (null |l|) 
+              (and (pairp |l|) (eq (qcdr |l|) nil) (eq (qcar |l|) '|all|)))
+           (cons '|varbreak| '|all|))
+         ((|isListOfIdentifiers| |l|) |x|)
+         (t
+           (|stackTraceOptionError|
+            (cons 's2it0016
+             (cons
+              (cons (strconc ")" (|object2String| |key|)) nil) nil))))))
+      ((boot-equal |key| '|mathprint|)
+        (cond
+         ((null |l|) |x|)
+         (t
+           (|stackTraceOptionError|
+            (cons 's2it0009
+             (cons
+              (cons (strconc ")" (|object2String| |key|)) nil) nil))))))
+      (|key| (|throwKeyedMsg| 's2it0005 (CONS |key| nil))))))))) 
+
+@
+
+\subsection{defun traceOptionError}
+\begin{verbatim}
+;traceOptionError(opt,keys) ==
+;  null keys => stackTraceOptionError ["S2IT0007",[opt]]
+;  commandAmbiguityError("trace option",opt,keys)
+\end{verbatim}
+
+<<defun traceOptionError>>=
+(defun |traceOptionError| (|opt| |keys|)
+ (cond
+  ((null |keys|)
+    (|stackTraceOptionError| (cons 's2it0007 (cons (cons |opt| nil) nil))))
+  (t
+   (|commandAmbiguityError| '|trace option| |opt| |keys|)))) 
+
+@
+
+\subsection{defun resetTimers}
+\begin{verbatim}
+;resetTimers () ==
+;  for timer in _/TIMERLIST repeat
+;    SET(INTERN STRCONC(timer,'"_,TIMER"),0)
+\end{verbatim}
+
+<<defun resetTimers>>=
+(defun |resetTimers| ()
+ (seq
+  (do ((t0 /timerlist (cdr t0)) (|timer| nil))
+      ((or (atom t0) (progn (setq |timer| (car t0)) nil)) nil)
+   (seq
+    (exit
+     (set (intern (strconc |timer| ",TIMER")) 0)))))) 
+
+@
+
+\subsection{defun resetSpacers}
+\begin{verbatim}
+;resetSpacers () ==
+;  for spacer in _/SPACELIST repeat
+;    SET(INTERN STRCONC(spacer,'"_,SPACE"),0)
+\end{verbatim}
+
+<<defun resetSpacers>>=
+(defun |resetSpacers| ()
+ (seq
+  (do ((t0 /spacelist (cdr t0)) (|spacer| nil))
+      ((or (atom t0) (progn (setq |spacer| (car t0)) nil)) nil)
+   (seq
+    (exit
+     (set (intern (strconc |spacer| ",SPACE")) 0)))))) 
+
+@
+\subsection{defun resetCounters}
+\begin{verbatim}
+;resetCounters () ==
+;  for k in _/COUNTLIST repeat
+;    SET(INTERN STRCONC(k,'"_,COUNT"),0)
+\end{verbatim}
+
+<<defun resetCounters>>=
+(defun |resetCounters| ()
+ (seq
+  (do ((t0 /countlist (cdr t0)) (|k| nil))
+      ((or (atom t0) (progn (setq |k| (car t0)) nil)) nil)
+    (seq
+     (exit
+      (set (intern (strconc |k| ",COUNT")) 0)))))) 
+
+@
+
+\subsection{defun ptimers}
+\begin{verbatim}
+;ptimers() ==
+;  null _/TIMERLIST => sayBrightly '"   no functions are timed"
+;  for timer in _/TIMERLIST repeat
+;    sayBrightly ["  ",:bright timer,'_:,'" ",
+;      EVAL(INTERN STRCONC(timer,'"_,TIMER")) / float $timerTicksPerSecond,'" sec."]
+\end{verbatim}
+
+<<defun ptimers>>=
+(defun |ptimers| ()
+ (seq
+  (cond
+   ((null /timerlist) (|sayBrightly| "   no functions are timed"))
+   (t
+    (do ((t0 /timerlist (cdr t0)) (|timer| nil))
+        ((or (atom t0) (progn (setq |timer| (car t0)) nil)) nil)
+     (seq
+      (exit
+       (|sayBrightly|
+        (cons "  "
+         (append
+          (|bright| |timer|)
+          (cons '|:|
+           (cons " "
+            (cons 
+             (quotient
+              (eval (intern (strconc |timer| ",TIMER")))
+              (|float| |$timerTicksPerSecond|))
+             (cons " sec." nil)))))))))))))) 
+
+@
+
+\subsection{defun pspacers}
+\begin{verbatim}
+;pspacers() ==
+;  null _/SPACELIST => sayBrightly '"   no functions have space monitored"
+;  for spacer in _/SPACELIST repeat
+;    sayBrightly ["  ",:bright spacer,'_:,'" ",
+;      EVAL INTERN STRCONC(spacer,'"_,SPACE"),'" bytes"]
+\end{verbatim}
+
+<<defun pspacers>>=
+(defun |pspacers| ()
+ (seq
+  (cond
+   ((null /spacelist) (|sayBrightly| "   no functions have space monitored"))
+   (t
+    (do ((t0 /spacelist (cdr t0)) (|spacer| nil))
+        ((or (atom t0) (progn (setq |spacer| (car t0)) nil)) nil)
+     (seq
+      (exit
+       (|sayBrightly|
+        (cons "  "
+         (append
+          (|bright| |spacer|)
+          (cons '|:|
+           (cons " "
+            (cons 
+             (eval (intern (strconc |spacer| ",SPACE")))
+             (cons " bytes" nil)))))))))))))) 
+
+@
+
+\subsection{defun pcounters}
+\begin{verbatim}
+;pcounters() ==
+;  null _/COUNTLIST => sayBrightly '"   no functions are being counted"
+;  for k in _/COUNTLIST repeat
+;    sayBrightly ["  ",:bright k,'_:,'" ",
+;      EVAL INTERN STRCONC(k,'"_,COUNT"),'" times"]
+\end{verbatim}
+
+<<defun pcounters>>=
+(defun |pcounters| ()
+ (seq
+  (cond
+   ((null /countlist) (|sayBrightly| "   no functions are being counted"))
+   (t
+    (do ((t0 /countlist (cdr t0)) (|k| nil))
+        ((or (atom t0) (progn (setq |k| (car t0)) nil)) nil)
+     (seq
+      (exit
+       (|sayBrightly|
+        (cons "  "
+         (append
+          (|bright| |k|)
+          (cons '|:|
+           (cons " "
+            (cons
+             (eval (intern (strconc |k| ",COUNT")))
+             (cons " times" nil)))))))))))))) 
+
+@
+
+\subsection{defun transOnlyOption}
+\begin{verbatim}
+;transOnlyOption l ==
+;  l is [n,:y] =>
+;    FIXP n => [n,:transOnlyOption y]
+;    MEMQ(n:= UPCASE n,'(V A C)) => [n,:transOnlyOption y]
+;    stackTraceOptionError ["S2IT0006",[n]]
+;    transOnlyOption y
+;  nil
+\end{verbatim}
+
+<<defun transOnlyOption>>=
+(defun |transOnlyOption| (|l|)
+ (prog (|y| |n|)
+  (return
+   (cond
+    ((and (pairp |l|) 
+          (progn (spadlet |n| (qcar |l|)) (spadlet |y| (qcdr |l|)) t))
+      (cond
+       ((fixp |n|)
+         (cons |n| (|transOnlyOption| |y|)))
+       ((memq (spadlet |n| (upcase |n|)) '(V A C))
+         (cons |n| (|transOnlyOption| |y|)))
+       (t 
+         (|stackTraceOptionError|
+           (cons 's2it0006 (cons (cons |n| nil) nil)))
+         (|transOnlyOption| |y|))))
+    (t nil))))) 
+
+@
+
+\subsection{defun stackTraceOptionError}
+<<defun stackTraceOptionError>>=
+(defun |stackTraceOptionError| (x)
+ (push x |$traceErrorStack|)
+ nil)
+
+@
+
+\subsection{defun removeOption}
+\begin{verbatim}
+;removeOption(op,options) ==
+;  [optEntry for (optEntry:=[opt,:.]) in options | opt ^= op]
+\end{verbatim}
+
+<<defun removeOption>>=
+(defun |removeOption| (|op| |options|)
+ (prog (|opt|)
+  (return
+   (seq
+    (prog (t0)
+     (spadlet t0 nil)
+     (return
+      (do ((t1 |options| (cdr t1)) (|optEntry| nil))
+          ((or (atom t1)
+               (progn (setq |optEntry| (car t1)) nil)
+               (progn (progn (spadlet |opt| (CAR |optEntry|)) |optEntry|) nil))
+        (nreverse0 t0))
+       (seq
+        (exit
+         (cond
+          ((nequal |opt| |op|) (setq t0 (cons |optEntry| t0))))))))))))) 
+
+@
+
+\subsection{defun domainToGenvar}
+\begin{verbatim}
+;domainToGenvar x ==
+;  $doNotAddEmptyModeIfTrue: local:= true
+;  (y:= unabbrevAndLoad x) and GETDATABASE(opOf y,'CONSTRUCTORKIND) = 'domain =>
+;    g:= genDomainTraceName y
+;    SET(g,evalDomain y)
+;    g
+\end{verbatim}
+
+<<defun domainToGenvar>>=
+(defun |domainToGenvar| (|x|)
+ (prog (|$doNotAddEmptyModeIfTrue| |y| |g|)
+  (declare (special |$doNotAddEmptyModeIfTrue|))
+  (return
+   (progn
+    (spadlet |$doNotAddEmptyModeIfTrue| t)
+    (cond
+     ((and (spadlet |y| (|unabbrevAndLoad| |x|))
+           (boot-equal (getdatabase (|opOf| |y|) 'constructorkind) '|domain|))
+       (progn
+        (spadlet |g| (|genDomainTraceName| |y|))
+        (set |g| (|evalDomain| |y|)) |g|))))))) 
+
+@
+
+\subsection{defun genDomainTraceName}
+\begin{verbatim}
+;genDomainTraceName y ==
+;  u:= LASSOC(y,$domainTraceNameAssoc) => u
+;  g:= GENVAR()
+;  $domainTraceNameAssoc:= [ [y,:g],:$domainTraceNameAssoc]
+;  g
+\end{verbatim}
+
+<<defun genDomainTraceName>>=
+(defun |genDomainTraceName| (y)
+ (prog (u g)
+  (return
+   (cond
+    ((spadlet u (lassoc y |$domainTraceNameAssoc|)) u)
+    (t
+     (spadlet g (genvar))
+     (spadlet |$domainTraceNameAssoc|
+      (cons (cons y g) |$domainTraceNameAssoc|))
+     g))))) 
+
+@
+
+\subsection{defun untrace}
+\begin{verbatim}
+;--this is now called from trace with the )off option
+;untrace l ==
+;  $lastUntraced:=
+;    null l => COPY _/TRACENAMES
+;    l
+;  untraceList:= [transTraceItem x for x in l]
+;  _/UNTRACE_,0 [lassocSub(funName,$mapSubNameAlist) for
+;      funName in untraceList]
+;  removeTracedMapSigs untraceList
+\end{verbatim}
+
+<<defun untrace>>=
+(defun |untrace| (|l|)
+ (prog (|untraceList|)
+  (return
+   (seq
+    (progn
+     (spadlet |$lastUntraced| (cond ((null |l|) (copy /tracenames)) (t |l|)))
+     (spadlet |untraceList|
+      (prog (t0)
+       (spadlet t0 nil)
+       (return
+        (do ((t1 |l| (cdr t1)) (|x| nil))
+            ((or (atom t1) (progn (setq |x| (car t1)) nil)) (nreverse0 t0))
+         (seq
+          (exit
+           (setq t0 (cons (|transTraceItem| |x|) t0))))))))
+     (|/UNTRACE,0|
+      (prog (t2)
+       (spadlet t2 nil)
+       (return
+        (do ((t3 |untraceList|l (cdr t3)) (|funName| nil))
+            ((or (atom t3) 
+                 (progn (setq |funName| (car t3)) nil))
+           (nreverse0 t2))
+         (seq
+          (exit
+           (setq t2 (cons (|lassocSub| |funName| |$mapSubNameAlist|) t2))))))))
+     (|removeTracedMapSigs| |untraceList|)))))) 
+
+@
+
+\subsection{defun transTraceItem}
+\begin{verbatim}
+;transTraceItem x ==
+;  $doNotAddEmptyModeIfTrue: local:=true
+;  atom x =>
+;    (value:=get(x,"value",$InteractiveFrame)) and
+;      (objMode value in '((Mode) (Domain) (SubDomain (Domain)))) =>
+;        x := objVal value
+;        (y:= domainToGenvar x) => y
+;        x
+;    UPPER_-CASE_-P (STRINGIMAGE x).(0) =>
+;      y := unabbrev x
+;      constructor?(y) => y
+;      PAIRP(y) and constructor?(CAR y) => CAR y
+;      (y:= domainToGenvar x) => y
+;      x
+;    x
+;  VECP first x => transTraceItem devaluate first x
+;  y:= domainToGenvar x => y
+;  throwKeyedMsg("S2IT0018",[x])
+\end{verbatim}
+
+<<defun transTraceItem>>=
+(defun |transTraceItem| (|x|)
+ (prog (|$doNotAddEmptyModeIfTrue| |value| |y|)
+  (declare (special |$doNotAddEmptyModeIfTrue|))
+  (return
+   (progn
+    (spadlet |$doNotAddEmptyModeIfTrue| t)
+    (cond
+     ((atom |x|)
+       (cond
+        ((and (spadlet |value| (|get| |x| '|value| |$InteractiveFrame|))
+              (|member| (|objMode| |value|)
+                '((|Mode|) (|Domain|) (|SubDomain| (|Domain|)))))
+          (spadlet |x| (|objVal| |value|))
+          (cond 
+           ((spadlet |y| (|domainToGenvar| |x|)) |y|)
+           (t |x|)))
+        ((upper-case-p (elt (stringimage |x|) 0))
+          (spadlet |y| (|unabbrev| |x|))
+          (cond
+           ((|constructor?| |y|) |y|)
+           ((and (pairp |y|) (|constructor?| (car |y|))) (car |y|))
+           ((spadlet |y| (|domainToGenvar| |x|)) |y|)
+           (t |x|)))
+        (t |x|)))
+     ((vecp (car |x|)) (|transTraceItem| (|devaluate| (car |x|))))
+     ((spadlet |y| (|domainToGenvar| |x|)) |y|)
+     (t (|throwKeyedMsg| 's2it0018 (cons |x| nil)))))))) 
+
+@
+
+\subsection{defun removeTracedMapSigs}
+\begin{verbatim}
+;removeTracedMapSigs untraceList ==
+;  for name in untraceList repeat
+;    REMPROP(name,$tracedMapSignatures)
+\end{verbatim}
+
+<<defun removeTracedMapSigs>>=
+(defun |removeTracedMapSigs| (|untraceList|)
+ (seq
+  (do ((t0 |untraceList| (cdr t0)) (|name| nil))
+      ((or (atom t0) (progn (setq |name| (car t0)) nil)) nil)
+   (seq
+    (exit
+     (remprop |name| |$tracedMapSignatures|)))))) 
+
+@
+
+\subsection{defun coerceTraceArgs2E}
+\begin{verbatim}
+;coerceTraceArgs2E(traceName,subName,args) ==
+;  MEMQ(name:= subName,$mathTraceList) =>
+;    SPADSYSNAMEP PNAME name => coerceSpadArgs2E(reverse CDR reverse args)
+;    [ ["=",name,objValUnwrap coerceInteractive(objNewWrap(arg,type),$OutputForm)]
+;      for name in '(arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15 arg16 arg17 arg18 arg19 )
+;       for arg in args for type in CDR LASSOC(subName,
+;        $tracedMapSignatures)]
+;  SPADSYSNAMEP PNAME name => reverse CDR reverse args
+;  args
+\end{verbatim}
+
+<<defun coerceTraceArgs2E>>=
+(defun |coerceTraceArgs2E| (|traceName| |subName| |args|)
+ (prog (|name|)
+  (return
+   (seq
+    (cond
+     ((memq (spadlet |name| |subName|) |$mathTraceList|)
+       (cond
+        ((spadsysnamep (pname |name|))
+          (|coerceSpadArgs2E| (reverse (cdr (reverse |args|)))))
+        (t
+         (prog (t0)
+          (spadlet t0 nil)
+          (return
+           (do ((t1 '(|arg1| |arg2| |arg3| |arg4| |arg5| |arg6| |arg7| |arg8| 
+                      |arg9| |arg10| |arg11| |arg12| |arg13| |arg14| |arg15| 
+                      |arg16| |arg17| |arg18| |arg19|) (cdr t1))
+                (|name| nil)
+                (t2 |args| (cdr t2))
+                (|arg| nil)
+                (t3 (cdr (lassoc |subName| |$tracedMapSignatures|)) (cdr t3))
+                (|type| nil))
+               ((or (atom t1)
+                    (progn (setq |name| (car t1)) nil)
+                    (atom t2)
+                    (progn (setq |arg| (car t2)) nil)
+                    (atom t3)
+                    (progn (setq |type| (car t3)) nil)) 
+                  (nreverse0 t0))
+             (seq
+              (exit 
+               (setq t0
+                (cons
+                 (cons '= 
+                  (cons |name| 
+                   (cons (|objValUnwrap|
+                     (|coerceInteractive|
+                      (|objNewWrap| |arg| |type|) |$OutputForm|))
+                        nil)))
+                     t0))))))))))
+     ((spadsysnamep (pname |name|)) (reverse (cdr (reverse |args|))))
+     (t |args|)))))) 
+
+@
+
+\subsection{defun coerceSpadArgs2E}
+\begin{verbatim}
+;coerceSpadArgs2E(args) ==
+;  -- following binding is to prevent forcing calculation of stream elements
+;  $streamCount:local := 0
+;  [ ["=",name,objValUnwrap coerceInteractive(objNewWrap(arg,type),$OutputForm)]
+;      for name in '(arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15 arg16 arg17 arg18 arg19 )
+;        for arg in args for type in CDR $tracedSpadModemap]
+\end{verbatim}
+
+<<defun coerceSpadArgs2E>>=
+(defun |coerceSpadArgs2E| (|args|)
+ (prog (|$streamCount|)
+  (declare (special |$streamCount|))
+  (return
+   (seq
+    (progn 
+     (spadlet |$streamCount| 0)
+     (prog (t0)
+      (spadlet t0 nil)
+      (return
+       (do ((t1 '(|arg1| |arg2| |arg3| |arg4| |arg5| |arg6| |arg7| |arg8| 
+                  |arg9| |arg10| |arg11| |arg12| |arg13| |arg14| |arg15| 
+                  |arg16| |arg17| |arg18| |arg19|) (cdr t1))
+            (|name| nil)
+            (t2 |args| (cdr t2))
+            (|arg| nil)
+            (t3 (cdr |$tracedSpadModemap|) (cdr t3))
+            (|type| nil))
+           ((or (atom t1)
+                (progn (setq |name| (car t1)) nil)
+                (atom t2)
+                (progn (setq |arg| (car t2)) nil)
+                (atom t3)
+                (progn (setq |type| (car t3)) nil))
+             (nreverse0 t0))
+         (seq
+          (exit
+           (setq t0
+            (cons
+             (cons '=
+              (cons |name|
+               (cons (|objValUnwrap|
+                 (|coerceInteractive| 
+                  (|objNewWrap| |arg| |type|)
+                  |$OutputForm|)) nil)))
+              t0)))))))))))) 
+
+@
+
+\subsection{defun subTypes}
+\begin{verbatim}
+;subTypes(mm,sublist) ==
+;  ATOM mm =>
+;    (s:= LASSOC(mm,sublist)) => s
+;    mm
+;  [subTypes(m,sublist) for m in mm]
+\end{verbatim}
+
+<<defun subTypes>>=
+(defun |subTypes| (|mm| |sublist|)
+ (prog (|s|)
+  (return
+   (seq
+    (cond
+     ((atom |mm|) 
+       (cond ((spadlet |s| (lassoc |mm| |sublist|)) |s|) (t |mm|)))
+     (t
+      (prog (t0)
+       (spadlet t0 nil)
+       (return
+        (do ((t1 |mm| (cdr t1)) (|m| nil))
+            ((or (atom t1) (progn (setq |m| (car t1)) nil)) (nreverse0 t0))
+         (seq
+          (exit
+           (setq t0 (cons (|subTypes| |m| |sublist|) t0))))))))))))) 
+
+@
+
+\subsection{defun coerceTraceFunValue2E}
+\begin{verbatim}
+;coerceTraceFunValue2E(traceName,subName,value) ==
+;  MEMQ(name:= subName,$mathTraceList) =>
+;    SPADSYSNAMEP PNAME traceName => coerceSpadFunValue2E(value)
+;    (u:=LASSOC(subName,$tracedMapSignatures)) =>
+;      objValUnwrap coerceInteractive(objNewWrap(value,CAR u),$OutputForm)
+;    value
+;  value
+\end{verbatim}
+
+<<defun coerceTraceFunValue2E>>=
+(defun |coerceTraceFunValue2E| (|traceName| |subName| |value|)
+ (prog (|name| |u|)
+  (return
+   (cond
+    ((memq (spadlet |name| |subName|) |$mathTraceList|)
+      (cond
+       ((spadsysnamep (pname |traceName|)) (|coerceSpadFunValue2E| |value|))
+       ((spadlet |u| (lassoc |subName| |$tracedMapSignatures|))
+         (|objValUnwrap|
+          (|coerceInteractive|
+           (|objNewWrap| |value| (CAR |u|))
+             |$OutputForm|)))
+       (t |value|)))
+    (t |value|))))) 
+
+@
+
+\subsection{defun coerceSpadFunValue2E}
+\begin{verbatim}
+;coerceSpadFunValue2E(value) ==
+;  -- following binding is to prevent forcing calculation of stream elements
+;  $streamCount:local := 0
+;  objValUnwrap coerceInteractive(objNewWrap(value,CAR $tracedSpadModemap),
+;    $OutputForm)
+\end{verbatim}
+
+<<defun coerceSpadFunValue2E>>=
+(defun |coerceSpadFunValue2E| (|value|)
+ (prog (|$streamCount|)
+  (declare (special |$streamCount|))
+  (return
+   (progn
+    (spadlet |$streamCount| 0)
+    (|objValUnwrap|
+     (|coerceInteractive|
+      (|objNewWrap| |value| (CAR |$tracedSpadModemap|))
+      |$OutputForm|)))))) 
+
+@
+
+\subsection{defun isListOfIdentifiers}
+\begin{verbatim}
+;isListOfIdentifiers l == and/[IDENTP x for x in l]
+\end{verbatim}
+
+<<defun isListOfIdentifiers>>=
+(defun |isListOfIdentifiers| (|l|)
+ (prog () 
+  (return
+   (seq
+    (prog (t0)
+     (spadlet t0 t)
+     (return
+      (do ((t1 nil (null t0)) (t2 |l| (cdr t2)) (|x| nil))
+          ((or t1 (atom t2) (progn (setq |x| (car t2)) nil)) t0)
+       (seq
+        (exit
+         (setq t0 (and t0 (identp |x|)))))))))))) 
+
+@
+
+\subsection{defun isListOfIdentifiersOrStrings}
+\begin{verbatim}
+;isListOfIdentifiersOrStrings l == and/[IDENTP x or STRINGP x for x in l]
+\end{verbatim}
+
+<<defun isListOfIdentifiersOrStrings>>=
+(defun |isListOfIdentifiersOrStrings| (|l|)
+ (prog () 
+  (return
+   (seq
+    (prog (t0)
+     (spadlet t0 t)
+     (return
+      (do ((t1 nil (null t0)) (t2 |l| (cdr t2)) (|x| nil))
+          ((or t1 (atom t2) (progn (setq |x| (car t2)) nil)) t0)
+       (seq
+        (exit
+         (setq t0 (and t0 (or (identp |x|) (stringp |x|))))))))))))) 
+
+@
+
+\subsection{defun getMapSubNames}
+\begin{verbatim}
+;getMapSubNames(l) ==
+;  subs:= nil
+;  for mapName in l repeat
+;    lmm:= get(mapName,'localModemap,$InteractiveFrame) =>
+;      subs:= APPEND([ [mapName,:CADR mm] for mm in lmm],subs)
+;  UNION(subs,getPreviousMapSubNames UNIONQ(_/TRACENAMES,
+;    $lastUntraced))
+\end{verbatim}
+
+<<defun getMapSubNames>>=
+(defun |getMapSubNames| (|l|)
+ (prog (|lmm| |subs|)
+  (return
+   (seq
+    (progn
+     (spadlet |subs| nil)
+     (seq
+      (do ((t0 |l| (cdr t0)) (|mapName| nil))
+          ((or (atom t0) (progn (setq |mapName| (CAR t0)) nil)) nil)
+       (seq
+        (exit
+         (cond
+          ((spadlet |lmm|
+            (|get| |mapName| '|localModemap| |$InteractiveFrame|))
+           (exit
+            (spadlet |subs|
+             (append
+              (prog (t1)
+               (spadlet t1 nil)
+               (return
+                (do ((t2 |lmm| (cdr t2)) (|mm| nil))
+                    ((or (atom t2)
+                         (progn (setq |mm| (CAR t2)) nil)) (nreverse0 t1))
+                 (seq
+                  (exit
+                   (setq t1 (cons (cons |mapName| (cadr |mm|)) t1)))))))
+              |subs|))))))))
+      (|union| |subs|
+        (|getPreviousMapSubNames| (unionq /tracenames |$lastUntraced|))))))))) 
+
+@
+
+\subsection{defun getPreviousMapSubNames}
+\begin{verbatim}
+;getPreviousMapSubNames(traceNames) ==
+;  subs:= nil
+;  for mapName in ASSOCLEFT CAAR $InteractiveFrame repeat
+;    lmm:= get(mapName,'localModemap,$InteractiveFrame) =>
+;      MEMQ(CADAR lmm,traceNames) =>
+;        for mm in lmm repeat
+;          subs:= [ [mapName,:CADR mm],:subs]
+;  subs
+\end{verbatim}
+
+<<defun getPreviousMapSubNames>>=
+(defun |getPreviousMapSubNames| (|traceNames|)
+ (prog (|lmm| |subs|)
+  (return
+   (seq
+    (progn
+     (spadlet |subs| nil)
+     (seq
+      (do ((t0 (assocleft (caar |$InteractiveFrame|)) (cdr t0))
+           (|mapName| nil))
+          ((or (atom t0) (progn (setq |mapName| (car t0)) nil)) nil)
+       (seq
+        (exit
+         (cond
+          ((spadlet |lmm|
+             (|get| |mapName| '|localModemap| |$InteractiveFrame|))
+            (exit
+             (cond
+              ((memq (cadar |lmm|) |traceNames|)
+               (exit
+                (do ((t1 |lmm| (cdr t1)) (|mm| nil))
+                    ((or (atom t1) (progn (setq |mm| (car t1)) nil)) nil)
+                 (seq
+                  (exit
+                   (spadlet |subs|
+                    (cons (cons |mapName| (cadr |mm|)) |subs|))))))))))))))
+      (exit |subs|))))))) 
+
+@
+
+\subsection{defun lassocSub}
+\begin{verbatim}
+;lassocSub(x,subs)  ==
+;  y:= LASSQ(x,subs) => y
+;  x
+\end{verbatim}
+
+<<defun lassocSub>>=
+(defun |lassocSub| (|x| |subs|)
+ (prog (|y|) 
+  (return 
+   (cond 
+    ((spadlet |y| (lassq |x| |subs|)) |y|)
+    (t |x|))))) 
+
+@
+
+\subsection{defun rassocSub}
+\begin{verbatim}
+;rassocSub(x,subs) ==
+;  y:= RASSOC(x,subs) => y
+;  x
+\end{verbatim}
+
+<<defun rassocSub>>=
+(defun |rassocSub| (|x| |subs|)
+ (prog (|y|)
+  (return
+   (cond
+    ((spadlet |y| (|rassoc| |x| |subs|)) |y|)
+    (t |x|))))) 
+
+@
+
+\subsection{defun isUncompiledMap}
+\begin{verbatim}
+;isUncompiledMap(x) ==
+;  y:= get(x,'value,$InteractiveFrame) =>
+;    (CAAR y) = 'MAP and null get(x,'localModemap,$InteractiveFrame)
+\end{verbatim}
+
+<<defun isUncompiledMap>>=
+(defun |isUncompiledMap| (x)
+ (prog (y)
+  (return
+   (seq 
+    (cond
+     ((spadlet y (|get| x '|value| |$InteractiveFrame|))
+       (exit
+        (and
+         (boot-equal (caar y) 'map)
+         (null (|get| x '|localModemap| |$InteractiveFrame|)))))))))) 
+
+@
+
+\subsection{defun isInterpOnlyMap}
+\begin{verbatim}
+;isInterpOnlyMap(map) ==
+;  x:= get(map,'localModemap,$InteractiveFrame) =>
+;    (CAAAR x) = 'interpOnly
+\end{verbatim}
+
+<<defun isInterpOnlyMap>>=
+(defun |isInterpOnlyMap| (map)
+ (prog (x)
+  (return
+   (seq
+    (cond
+     ((spadlet x (|get| map '|localModemap| |$InteractiveFrame|))
+      (exit
+       (boot-equal (caaar x) '|interpOnly|)))))))) 
+
+@
+
+\subsection{defun augmentTraceNames}
+\begin{verbatim}
+;augmentTraceNames(l,mapSubNames) ==
+;  res:= nil
+;  for traceName in l repeat
+;    mml:= get(traceName,'localModemap,$InteractiveFrame) =>
+;      res:= APPEND([CADR mm for mm in mml],res)
+;    res:= [traceName,:res]
+;  res
+\end{verbatim}
+
+<<defun augmentTraceNames>>=
+(defun |augmentTraceNames| (|l| |mapSubNames|)
+ (prog (|mml| |res|)
+  (return
+   (seq
+    (progn
+     (spadlet |res| nil)
+     (do ((t0 |l| (cdr t0)) (|traceName| nil))
+         ((or (atom t0) (progn (setq |traceName| (car t0)) nil)) nil)
+      (seq
+       (exit
+        (cond
+         ((spadlet |mml|
+            (|get| |traceName| '|localModemap| |$InteractiveFrame|))
+           (spadlet |res|
+            (append
+             (prog (t1)
+              (spadlet t1 nil)
+              (return
+               (do ((t2 |mml| (cdr t2)) (|mm| nil))
+                   ((or (atom t2) 
+                        (progn (setq |mm| (CAR t2)) nil))
+                     (nreverse0 t1))
+                (seq
+                 (exit 
+                  (setq t1 (cons (cadr |mm|) t1)))))))
+            |res|)))
+         (t (spadlet |res| (cons |traceName| |res|)))))))
+     |res|))))) 
+@
+
+\subsection{defun isSubForRedundantMapName}
+\begin{verbatim}
+;isSubForRedundantMapName(subName) ==
+;  mapName:= rassocSub(subName,$mapSubNameAlist) =>
+;    tail:=MEMBER([mapName,:subName],$mapSubNameAlist) =>
+;      MEMQ(mapName,CDR ASSOCLEFT tail)
+\end{verbatim}
+
+<<defun isSubForRedundantMapName>>=
+(defun |isSubForRedundantMapName| (|subName|)
+ (prog (|mapName| |tail|)
+  (return
+   (seq
+    (cond
+     ((spadlet |mapName| (|rassocSub| |subName| |$mapSubNameAlist|))
+       (exit
+        (cond
+         ((spadlet |tail|
+            (|member| (cons |mapName| |subName|) |$mapSubNameAlist|))
+           (exit
+            (memq |mapName| (cdr (assocleft |tail|))))))))))))) 
+
+@
+
+\subsection{defun untraceMapSubNames}
+\begin{verbatim}
+;untraceMapSubNames traceNames ==
+;  null($mapSubNameAlist:local:= getPreviousMapSubNames traceNames) => nil
+;  for name in (subs:= ASSOCRIGHT $mapSubNameAlist)
+;    | MEMQ(name,_/TRACENAMES) repeat
+;      _/UNTRACE_,2(name,nil)
+;      $lastUntraced:= SETDIFFERENCE($lastUntraced,subs)
+\end{verbatim}
+
+<<defun untraceMapSubNames>>=
+(defun |untraceMapSubNames| (|traceNames|)
+ (prog (|$mapSubNameAlist| |subs|)
+  (declare (special |$mapSubNameAlist|))
+  (return
+   (seq
+    (cond
+     ((null
+        (spadlet |$mapSubNameAlist| (|getPreviousMapSubNames| |traceNames|)))
+       nil)
+     (t
+      (do ((t0 (spadlet |subs| (assocright |$mapSubNameAlist|)) (CDR t0))
+           (|name| nil))
+          ((or (atom t0) (progn (setq |name| (car t0)) nil)) nil)
+       (seq
+        (exit
+         (cond
+          ((memq |name| /tracenames)
+           (progn
+            (|/UNTRACE,2| |name| nil)
+            (spadlet |$lastUntraced|
+             (setdifference |$lastUntraced| |subs|)))))))))))))) 
+
+@
+
+\subsection{defmacro funfind}
+\begin{verbatim}
+;funfind("functor","opname") ==
+;  ops:= isFunctor functor
+;  [u for u in ops | u is [[ =opname,:.],:.]]
+\end{verbatim}
+
+<<defun funfind,LAM>>=
+(defun |funfind,LAM| (functor opname)
+ (prog (ops tmp1)
+  (return
+   (seq
+    (progn
+     (spadlet ops (|isFunctor| functor))
+     (prog (t0)
+      (spadlet t0 nil)
+      (return
+       (do ((t1 ops (cdr t1)) (|u| nil))
+           ((or (atom t1) (progn (setq |u| (car t1)) nil)) (nreverse0 t0))
+        (seq
+         (exit
+          (cond
+           ((and (pairp |u|)
+                 (progn
+                  (spadlet tmp1 (qcar |u|))
+                  (and (pairp tmp1) (equal (qcar tmp1) opname))))
+             (setq t0 (cons |u| t0)))))))))))))) 
+
+@
+
+<<defmacro funfind>>=
+(defmacro |funfind| (&whole t0 &rest notused &aux t1)
+ (dsetq t1 t0)
+ (cons '|funfind,LAM| (vmlisp::wrap (cdr t1) '(quote quote)))) 
+
+@
+
+\subsection{defun isDomainOrPackage}
+\begin{verbatim}
+;isDomainOrPackage dom ==
+;  REFVECP dom and #dom>0 and isFunctor opOf dom.(0)
+\end{verbatim}
+
+<<defun isDomainOrPackage>>=
+(defun |isDomainOrPackage| (dom)
+ (and
+  (refvecp dom)
+  (> (|#| dom) 0)
+  (|isFunctor| (|opOf| (elt dom 0))))) 
+
+@
+
+\subsection{defun isTraceGensym}
+<<defun isTraceGensym>>=
+(defun |isTraceGensym| (x)
+ (gensymp x)) 
+
+@
+
+\subsection{defun spadTrace}
+\begin{verbatim}
+;spadTrace(domain,options) ==
+;  $fromSpadTrace:= true
+;  $tracedModemap:local:= nil
+;  PAIRP domain and REFVECP CAR domain and (CAR domain).0 = 0 =>
+;      aldorTrace(domain,options)
+;  not isDomainOrPackage domain => userError '"bad argument to trace"
+;  listOfOperations:=
+;    [g x for x in getOption("OPS",options)] where
+;      g x ==
+;        STRINGP x => INTERN x
+;        x
+;  if listOfVariables := getOption("VARS",options) then
+;    options := removeOption("VARS",options)
+;  if listOfBreakVars := getOption("VARBREAK",options) then
+;    options := removeOption("VARBREAK",options)
+;  anyifTrue:= null listOfOperations
+;  domainId:= opOf domain.(0)
+;  currentEntry:= ASSOC(domain,_/TRACENAMES)
+;  currentAlist:= KDR currentEntry
+;  opStructureList:= flattenOperationAlist getOperationAlistFromLisplib domainId
+;  sigSlotNumberAlist:=
+;    [triple
+;      --new form is (<op> <signature> <slotNumber> <condition> <kind>)
+;      for [op,sig,n,.,kind] in opStructureList | kind = 'ELT
+;        and (anyifTrue or MEMQ(op,listOfOperations)) and
+;         FIXP n and
+;          isTraceable(triple:= [op,sig,n],domain)] where
+;            isTraceable(x is [.,.,n,:.],domain) ==
+;              atom domain.n => nil
+;              functionSlot:= first domain.n
+;              GENSYMP functionSlot =>
+;                (reportSpadTrace("Already Traced",x); nil)
+;              null (BPINAME functionSlot) =>
+;                (reportSpadTrace("No function for",x); nil)
+;              true
+;  if listOfVariables then
+;    for [.,.,n] in sigSlotNumberAlist repeat
+;      fn := first domain.n
+;      $letAssoc := AS_-INSERT(BPINAME fn,
+;        listOfVariables,$letAssoc)
+;  if listOfBreakVars then
+;    for [.,.,n] in sigSlotNumberAlist repeat
+;      fn := first domain.n
+;      $letAssoc := AS_-INSERT(BPINAME fn,
+;        [["BREAK",:listOfBreakVars]],$letAssoc)
+;  for (pair:= [op,mm,n]) in sigSlotNumberAlist repeat
+;    alias:= spadTraceAlias(domainId,op,n)
+;    $tracedModemap:= subTypes(mm,constructSubst(domain.0))
+;    traceName:= BPITRACE(first domain.n,alias, options)
+;    NCONC(pair,[listOfVariables,first domain.n,traceName,alias])
+;    RPLAC(first domain.n,traceName)
+;  sigSlotNumberAlist:= [x for x in sigSlotNumberAlist | CDDDR x]
+;  if $reportSpadTrace then
+;    if $traceNoisely then printDashedLine()
+;    for x in orderBySlotNumber sigSlotNumberAlist repeat
+;      reportSpadTrace("TRACING",x)
+;  if $letAssoc then SETLETPRINTFLAG true
+;  currentEntry =>
+;    RPLAC(rest currentEntry,[:sigSlotNumberAlist,:currentAlist])
+;  SETQ(_/TRACENAMES,[ [domain,:sigSlotNumberAlist],:_/TRACENAMES])
+;  spadReply()
+\end{verbatim}
+
+<<defun spadTrace,g>>=
+(defun |spadTrace,g| (|x|)
+ (seq
+  (if (stringp |x|) (exit (intern |x|)))
+  (exit |x|))) 
+
+@
+
+<<defun spadTrace,isTraceable>>=
+(defun |spadTrace,isTraceable| (|x| |domain|)
+ (prog (|n| |functionSlot|)
+  (return
+   (seq
+    (progn
+     (spadlet |n| (caddr |x|))
+     |x|
+     (seq
+      (if (atom (elt |domain| |n|)) (exit nil))
+      (spadlet |functionSlot| (car (elt |domain| |n|)))
+      (if (gensymp |functionSlot|) 
+       (exit (seq (|reportSpadTrace| '|Already Traced| |x|) (exit nil))))
+      (if (null (bpiname |functionSlot|))
+       (exit
+        (seq
+         (|reportSpadTrace| '|No function for| |x|)
+         (exit nil))))
+      (exit t))))))) 
+
+@
+
+<<defun spadTrace>>=
+(defun |spadTrace| (|domain| |options|)
+ (prog (|$tracedModemap| |listOfOperations| |listOfVariables| 
+        |listOfBreakVars| |anyifTrue| |domainId| |currentEntry| 
+        |currentAlist| |opStructureList| |sig| |kind| |triple| |fn| |op| 
+        |mm| |n| |alias| |traceName| |sigSlotNumberAlist|)
+ (declare (special |$tracedModemap|))
+ (return
+  (seq
+   (progn
+    (spadlet |$fromSpadTrace| t)
+    (spadlet |$tracedModemap| nil)
+    (cond
+     ((and (pairp |domain|)
+           (refvecp (car |domain|))
+           (eql (elt (car |domain|) 0) 0))
+       (|aldorTrace| |domain| |options|))
+     ((null (|isDomainOrPackage| |domain|))
+       (|userError| "bad argument to trace"))
+     (t
+      (spadlet |listOfOperations|
+       (prog (t0)
+        (spadlet t0 nil)
+        (return
+         (do ((t1 (|getOption| 'ops |options|) (cdr t1)) (|x| nil))
+             ((or (atom t1) (progn (setq |x| (car t1)) nil)) (nreverse0 t0))
+          (seq
+           (exit
+            (setq t0 (cons (|spadTrace,g| |x|) t0))))))))
+      (cond
+       ((spadlet |listOfVariables| (|getOption| 'vars |options|))
+         (spadlet |options| (|removeOption| 'vars |options|))))
+      (cond
+       ((spadlet |listOfBreakVars| (|getOption| 'varbreak |options|))
+         (spadlet |options| (|removeOption| 'varbreak |options|))))
+      (spadlet |anyifTrue| (null |listOfOperations|))
+      (spadlet |domainId| (|opOf| (elt |domain| 0)))
+      (spadlet |currentEntry| (|assoc| |domain| /tracenames))
+      (spadlet |currentAlist| (kdr |currentEntry|))
+      (spadlet |opStructureList| 
+       (|flattenOperationAlist| (|getOperationAlistFromLisplib| |domainId|)))
+      (spadlet |sigSlotNumberAlist|
+       (prog (t2)
+        (spadlet t2 nil)
+        (return
+         (do ((t3 |opStructureList| (cdr t3)) (t4 nil))
+             ((or (atom t3)
+                  (progn (setq t4 (CAR t3)) nil)
+                  (progn
+                   (progn
+                    (spadlet |op| (car t4))
+                    (spadlet |sig| (cadr t4))
+                    (spadlet |n| (caddr t4))
+                    (spadlet |kind| (car (cddddr t4))) t4)
+                   nil))
+                (nreverse0 t2))
+          (seq
+           (exit
+            (cond
+             ((and (boot-equal |kind| 'ELT)
+                   (or |anyifTrue| (memq |op| |listOfOperations|))
+                   (fixp |n|)
+                   (|spadTrace,isTraceable|
+                    (spadlet |triple|
+                     (cons |op| (cons |sig| (cons |n| nil)))) |domain|))
+                (setq t2 (cons |triple| t2))))))))))
+      (cond 
+       (|listOfVariables|
+        (do ((t5 |sigSlotNumberAlist| (cdr t5)) (t6 nil))
+            ((or (atom t5)
+                 (progn (setq t6 (car t5)) nil)
+                 (progn (progn (spadlet |n| (caddr t6)) t6) nil))
+              nil)
+         (seq
+          (exit
+           (progn
+            (spadlet |fn| (car (elt |domain| |n|)))
+            (spadlet |$letAssoc|
+             (as-insert (bpiname |fn|) |listOfVariables| |$letAssoc|))))))))
+      (cond
+       (|listOfBreakVars|
+        (do ((t7 |sigSlotNumberAlist| (cdr t7)) (t8 nil))
+            ((or (atom t7)
+                 (progn (setq t8 (car t7)) nil)
+                 (progn (progn (spadlet |n| (caddr t8)) t8) nil))
+                nil)
+         (seq
+          (exit
+           (progn
+            (spadlet |fn| (car (elt |domain| |n|)))
+            (spadlet |$letAssoc|
+             (as-insert (bpiname |fn|)
+              (cons (cons 'break |listOfBreakVars|) nil) |$letAssoc|))))))))
+      (do ((t9 |sigSlotNumberAlist| (cdr t9)) (|pair| nil))
+          ((or (atom t9)
+               (progn (setq |pair| (car t9)) nil)
+               (progn
+                (progn
+                 (spadlet |op| (car |pair|))
+                 (spadlet |mm| (cadr |pair|))
+                 (spadlet |n| (caddr |pair|))
+                 |pair|)
+                 nil))
+               nil)
+       (seq
+        (exit
+         (progn 
+          (spadlet |alias| (|spadTraceAlias| |domainId| |op| |n|))
+          (spadlet |$tracedModemap|
+            (|subTypes| |mm| (|constructSubst| (elt |domain| 0))))
+          (spadlet |traceName|
+            (bpitrace (car (elt |domain| |n|)) |alias| |options|))
+          (nconc |pair|
+            (cons |listOfVariables|
+             (cons (car (elt |domain| |n|))
+              (cons |traceName| (cons |alias| nil)))))
+          (rplac (car (elt |domain| |n|)) |traceName|)))))
+      (spadlet |sigSlotNumberAlist|
+       (prog (t10)
+        (spadlet t10 nil)
+        (return
+         (do ((t11 |sigSlotNumberAlist| (cdr t11)) (|x| nil))
+             ((or (atom t11) (progn (setq |x| (car t11)) nil)) (nreverse0 t10))
+          (seq
+           (exit
+            (cond ((cdddr |x|) (setq t10 (cons |x| t10))))))))))
+      (cond
+       (|$reportSpadTrace|
+        (cond (|$traceNoisely| (|printDashedLine|)))
+        (do ((t12 (|orderBySlotNumber| |sigSlotNumberAlist|) (cdr t12))
+             (|x| nil))
+            ((or (atom t12)
+                 (progn (setq |x| (car t12)) nil))
+                nil)
+             (seq (exit (|reportSpadTrace| 'tracing |x|))))))
+      (cond (|$letAssoc| (setletprintflag t)))
+      (cond 
+       (|currentEntry|
+        (rplac (cdr |currentEntry|)
+          (append |sigSlotNumberAlist| |currentAlist|)))
+       (t 
+        (setq /tracenames
+         (cons (cons |domain| |sigSlotNumberAlist|) /tracenames))
+          (|spadReply|)))))))))) 
+
+@
+
+\subsection{defun traceDomainLocalOps}
+\begin{verbatim}
+;traceDomainLocalOps(dom,lops,options) ==
+; sayMSG ['"  ",'"The )local option has been withdrawn"]
+; sayMSG ['"  ",'"Use )ltr to trace local functions."]
+; NIL
+\end{verbatim}
+
+<<defun traceDomainLocalOps>>=
+(defun |traceDomainLocalOps| (|dom| |lops| |options|)
+ (progn
+  (|sayMSG| (cons "  " (cons "The )local option has been withdrawn" nil)))
+  (|sayMSG| (cons "  " (cons "Use )ltr to trace local functions." nil)))
+  nil)) 
+
+@
+
+\subsection{defun untraceDomainLocalOps}
+\begin{verbatim}
+;--  abb := abbreviate dom
+;--  loadLibIfNotLoaded abb
+;--  actualLops := getLocalOpsFromLisplib abb
+;--  null actualLops =>
+;--    sayMSG ['"  ",:bright abb,'"has no local functions to trace."]
+;--  lops = 'all => _/TRACE_,1(actualLops,options)
+;--  l := NIL
+;--  for lop in lops repeat
+;--    internalName := INTERN STRCONC(PNAME abb,'";",PNAME lop)
+;--    not MEMQ(internalName,actualLops) =>
+;--      sayMSG ['"  ",:bright abb,'"does not have a local",
+;--        '" function called",:bright lop]
+;--    l := cons(internalName,l)
+;--  l => _/TRACE_,1(l,options)
+;--  nil
+;untraceDomainLocalOps(dom,lops) ==
+; sayMSG ['"  ",:bright abb,'"has no local functions to untrace."]
+; NIL
+\end{verbatim}
+
+<<defun untraceDomainLocalOps>>=
+(defun |untraceDomainLocalOps| (|dom| |lops|)
+ (progn
+  (|sayMSG|
+   (cons "  "
+    (append (|bright| |abb|) (cons "has no local functions to untrace." nil))))
+  nil)) 
+
+@
+
+\subsection{defun untraceAllDomainLocalOps}
+\begin{verbatim}
+;--  lops = "all" => untraceAllDomainLocalOps(dom)
+;--  abb := abbreviate dom
+;--  loadLibIfNotLoaded abb
+;--  actualLops := getLocalOpsFromLisplib abb
+;--  null actualLops =>
+;--    sayMSG ['"  ",:bright abb,'"has no local functions to untrace."]
+;--  l := NIL
+;--  for lop in lops repeat
+;--    internalName := INTERN STRCONC(PNAME abb,'";",PNAME lop)
+;--    not MEMQ(internalName,actualLops) =>
+;--      sayMSG ['"  ",:bright abb,'"does not have a local",
+;--        '" function called",:bright lop]
+;--    l := cons(internalName,l)
+;--  l => untrace l
+;--  nil
+;untraceAllDomainLocalOps(dom) == NIL
+\end{verbatim}
+
+<<defun untraceAllDomainLocalOps>>=
+(defun |untraceAllDomainLocalOps| (|dom|) nil) 
+
+@
+
+\subsection{defun traceDomainConstructor}
+\begin{verbatim}
+;--  abb := abbreviate dom
+;--  actualLops := getLocalOpsFromLisplib abb
+;--  null (l := INTERSECTION(actualLops,_/TRACENAMES)) => NIL
+;--  _/UNTRACE_,1(l,NIL)
+;--  NIL
+;traceDomainConstructor(domainConstructor,options) ==
+;  -- Trace all domains built with the given domain constructor,
+;  -- including all presently instantiated domains, and all future
+;  -- instantiations, while domain constructor is traced.
+;  loadFunctor domainConstructor
+;  listOfLocalOps := getOption("LOCAL",options)
+;  if listOfLocalOps then
+;    traceDomainLocalOps(domainConstructor,listOfLocalOps,
+;      [opt for opt in options | opt isnt ['LOCAL,:.]])
+;  listOfLocalOps and not getOption("OPS",options) => NIL
+;  for [argl,.,:domain] in HGET($ConstructorCache,domainConstructor)
+;    repeat spadTrace(domain,options)
+;  SETQ(_/TRACENAMES,[domainConstructor,:_/TRACENAMES])
+;  innerDomainConstructor := INTERN STRCONC(domainConstructor,'";")
+;  if FBOUNDP innerDomainConstructor then domainConstructor := innerDomainConstructor
+;  EMBED(domainConstructor,
+;    ['LAMBDA, ['_&REST, 'args],
+;      ['PROG, ['domain],
+;        ['SETQ,'domain,['APPLY,domainConstructor,'args]],
+;        ['spadTrace,'domain,MKQ options],
+;        ['RETURN,'domain]]] )
+\end{verbatim}
+
+<<defun traceDomainConstructor>>=
+(defun |traceDomainConstructor| (|domainConstructor| |options|)
+ (prog (|listOfLocalOps| |argl| |domain| |innerDomainConstructor|)
+  (return
+   (seq
+    (progn
+     (|loadFunctor| |domainConstructor|)
+     (spadlet |listOfLocalOps| (|getOption| 'local |options|))
+     (cond
+      (|listOfLocalOps|
+       (|traceDomainLocalOps| |domainConstructor| |listOfLocalOps|
+        (prog (t0)
+         (spadlet t0 nil)
+         (return
+          (do ((t1 |options| (cdr t1)) (|opt| nil))
+              ((or (atom t1) (progn (setq |opt| (car t1)) nil)) (nreverse0 t0))
+           (seq
+            (exit
+             (cond 
+              ((null (and (pairp |opt|) (eq (qcar |opt|) 'local)))
+                (setq t0 (cons |opt| t0))))))))))))
+     (cond 
+      ((and |listOfLocalOps| (null (|getOption| 'ops |options|))) nil)
+      (t
+       (do ((t2 (hget |$ConstructorCache| |domainConstructor|) (cdr t2))
+            (t3 nil))
+           ((or (atom t2) 
+                (progn (setq t3 (car t2)) nil)
+                (progn 
+                 (progn 
+                  (spadlet |argl| (car t3))
+                  (spadlet |domain| (cddr t3)) t3)
+                 nil))
+                nil)
+         (seq
+          (exit
+           (|spadTrace| |domain| |options|))))
+       (setq /tracenames (cons |domainConstructor| /tracenames))
+       (spadlet |innerDomainConstructor|
+         (intern (strconc |domainConstructor| ";")))
+       (cond
+        ((fboundp |innerDomainConstructor|)
+          (spadlet |domainConstructor| |innerDomainConstructor|)))
+       (embed |domainConstructor|
+        (cons 'lambda
+         (cons 
+          (cons '&rest
+           (cons '|args| nil))
+          (cons
+           (cons 'prog
+            (cons
+             (cons '|domain| nil)
+             (cons
+              (cons 'setq
+               (cons '|domain|
+                (cons
+                 (cons 'apply (cons |domainConstructor|
+                  (cons '|args| nil))) nil)))
+              (cons
+               (cons '|spadTrace|
+                (cons '|domain|
+                 (cons (mkq |options|) nil)))
+               (cons (cons 'return (cons '|domain| nil)) nil)))))
+           nil))))))))))) 
+
+@
+
+\subsection{defun untraceDomainConstructor}
+\begin{verbatim}
+;untraceDomainConstructor domainConstructor ==
+;  --untrace all the domains in domainConstructor, and unembed it
+;  SETQ(_/TRACENAMES,
+;    [df for df in _/TRACENAMES | keepTraced?(df, domainConstructor)]) where
+;      keepTraced?(df, domainConstructor) ==
+;        (df is [dc,:.]) and (isDomainOrPackage dc) and
+;           ((KAR devaluate dc) = domainConstructor) =>
+;               _/UNTRACE_,0 [dc]
+;               false
+;        true
+;  untraceAllDomainLocalOps domainConstructor
+;  innerDomainConstructor := INTERN STRCONC(domainConstructor,'";")
+;  if FBOUNDP innerDomainConstructor then UNEMBED innerDomainConstructor
+;    else UNEMBED domainConstructor
+;  SETQ(_/TRACENAMES,DELETE(domainConstructor,_/TRACENAMES))
+\end{verbatim}
+
+<<defun untraceDomainConstructor,keepTraced?>>=
+(defun |untraceDomainConstructor,keepTraced?| (|df| |domainConstructor|)
+ (prog (|dc|)
+  (return
+   (seq
+    (if (and 
+         (and
+          (and (pairp |df|) (progn (spadlet |dc| (qcar |df|)) t))
+           (|isDomainOrPackage| |dc|))
+         (boot-equal (kar (|devaluate| |dc|)) |domainConstructor|))
+     (exit (seq (|/UNTRACE,0| (cons |dc| nil)) (exit nil))))
+    (exit t))))) 
+
+@
+
+<<defun untraceDomainConstructor>>=
+(defun |untraceDomainConstructor| (|domainConstructor|)
+ (prog (|innerDomainConstructor|)
+  (return
+   (seq
+    (progn
+     (setq /tracenames
+      (prog (t0)
+       (spadlet t0 nil)
+       (return
+        (do ((t1 /tracenames (cdr t1)) (|df| nil))
+            ((or (atom t1) (progn (setq |df| (car t1)) nil)) (nreverse0 t0))
+         (seq
+          (exit
+           (cond ((|untraceDomainConstructor,keepTraced?|
+                    |df| |domainConstructor|)
+             (setq t0 (cons |df| t0))))))))))
+     (|untraceAllDomainLocalOps| |domainConstructor|)
+     (spadlet |innerDomainConstructor|
+      (intern (strconc |domainConstructor| ";")))
+     (cond
+      ((fboundp |innerDomainConstructor|) (unembed |innerDomainConstructor|))
+      (t (unembed |domainConstructor|)))
+     (setq /tracenames (|delete| |domainConstructor| /tracenames))))))) 
+
+@
+
+\subsection{defun flattenOperationAlist}
+\begin{verbatim}
+;flattenOperationAlist(opAlist) ==
+;   res:= nil
+;   for [op,:mmList] in opAlist repeat
+;     res:=[:res,:[[op,:mm] for mm in mmList]]
+;   res
+\end{verbatim}
+
+<<defun flattenOperationAlist>>=
+(defun |flattenOperationAlist| (|opAlist|)
+ (prog (|op| |mmList| |res|)
+  (return
+   (seq
+    (progn
+     (spadlet |res| nil)
+     (do ((t0 |opAlist| (cdr t0)) (t1 nil))
+         ((or (atom t0) 
+              (progn (setq t1 (car t0)) nil)
+              (progn
+               (progn (spadlet |op| (car t1)) (spadlet |mmList| (cdr t1)) t1)
+               nil)) 
+             nil)
+      (seq
+       (exit
+        (spadlet |res|
+         (append |res|
+          (prog (t2)
+           (spadlet t2 nil)
+           (return
+            (do ((t3 |mmList| (cdr t3)) (|mm| nil))
+                ((or (atom t3)
+                     (progn (setq |mm| (car t3)) nil)) (nreverse0 t2))
+             (seq
+              (exit
+               (setq t2 (cons (cons |op| |mm|) t2))))))))))))
+     |res|))))) 
+
+@
+
+\subsection{defun mapLetPrint}
+\begin{verbatim}
+;mapLetPrint(x,val,currentFunction) ==
+;  x:= getAliasIfTracedMapParameter(x,currentFunction)
+;  currentFunction:= getBpiNameIfTracedMap currentFunction
+;  letPrint(x,val,currentFunction)
+\end{verbatim}
+
+<<defun mapLetPrint>>=
+(defun |mapLetPrint| (x val currentFunction)
+  (spadlet x (|getAliasIfTracedMapParameter| x currentFunction))
+  (spadlet currentFunction (|getBpiNameIfTracedMap| currentFunction))
+  (|letPrint| x val currentFunction))
+
+@
+
+\subsection{defun letPrint}
+\begin{verbatim}
+;-- This is the version for use when we have no idea
+;-- what print representation to use for the data object
+;letPrint(x,val,currentFunction) ==
+;  if $letAssoc and
+;    ((y:= LASSOC(currentFunction,$letAssoc)) or (y:= LASSOC("all",$letAssoc))) then
+;      if (y="all" or MEMQ(x,y)) and
+;        not (IS__GENVAR(x) or isSharpVarWithNum(x) or GENSYMP x) then
+;         sayBrightlyNT [:bright x,": "]
+;         PRIN0 shortenForPrinting val
+;         TERPRI()
+;      if (y:= hasPair("BREAK",y)) and
+;        (y="all" or MEMQ(x,y) and
+;          (not MEMQ((PNAME x).(0),'($ _#)) and not GENSYMP x)) then
+;            break [:bright currentFunction,'"breaks after",:bright x,'":= ",
+;              shortenForPrinting val]
+;  val
+\end{verbatim}
+
+<<defun letPrint>>=
+(defun |letPrint| (|x| |val| |currentFunction|)
+ (prog (|y|)
+  (return
+   (progn
+    (cond ((and |$letAssoc| 
+                (or
+                 (spadlet |y| (lassoc |currentFunction| |$letAssoc|))
+                 (spadlet |y| (lassoc '|all| |$letAssoc|))))
+     (cond
+      ((and (or (boot-equal |y| '|all|)
+                 (memq |x| |y|))
+            (null 
+             (or (is_genvar |x|) (|isSharpVarWithNum| |x|) (gensymp |x|))))
+        (|sayBrightlyNT| (append (|bright| |x|) (cons '|: | nil)))
+        (prin0 (|shortenForPrinting| |val|))
+        (terpri)))
+     (cond
+      ((and (spadlet |y| (|hasPair| 'break |y|))
+            (or (boot-equal |y| '|all|)
+                (and (memq |x| |y|)
+                     (null (memq (elt (pname |x|) 0) '($ |#|)))
+                     (null (gensymp |x|)))))
+       (|break|
+        (append 
+         (|bright| |currentFunction|)
+         (cons "breaks after"
+          (append
+           (|bright| |x|)
+           (cons ":= " (cons (|shortenForPrinting| |val|) nil)))))))
+      (t nil))))
+    |val|)))) 
+
+@
+
+\subsection{defun letPrint2}
+\begin{verbatim}
+;-- This is the version for use when we have already
+;-- converted the data into type "Expression"
+;letPrint2(x,printform,currentFunction) ==
+;  $BreakMode:local := nil
+;  if $letAssoc and
+;    ((y:= LASSOC(currentFunction,$letAssoc)) or (y:= LASSOC("all",$letAssoc))) then
+;      if (y="all" or MEMQ(x,y)) and
+;        not (IS__GENVAR(x) or isSharpVarWithNum(x) or GENSYMP x) then
+;         $BreakMode:='letPrint2
+;         flag:=nil
+;         CATCH('letPrint2,mathprint ["=",x,printform],flag)
+;         if flag='letPrint2 then print printform
+;      if (y:= hasPair("BREAK",y)) and
+;        (y="all" or MEMQ(x,y) and
+;          (not MEMQ((PNAME x).(0),'($ _#)) and not GENSYMP x)) then
+;            break [:bright currentFunction,'"breaks after",:bright x,":= ",
+;              printform]
+;  x
+\end{verbatim}
+
+<<defun letPrint2>>=
+(defun |letPrint2| (|x| |printform| |currentFunction|)
+ (prog (|$BreakMode| |flag| |y|)
+  (declare (special |$BreakMode|))
+  (return
+   (progn
+    (spadlet |$BreakMode| nil)
+    (cond
+     ((and |$letAssoc| 
+           (or (spadlet |y| (lassoc |currentFunction| |$letAssoc|))
+               (spadlet |y| (lassoc '|all| |$letAssoc|))))
+      (cond
+       ((and
+          (or (boot-equal |y| '|all|) (memq |x| |y|))
+          (null (or (is_genvar |x|) (|isSharpVarWithNum| |x|) (gensymp |x|))))
+         (spadlet |$BreakMode| '|letPrint2|)
+         (spadlet |flag| nil)
+         (catch '|letPrint2| 
+          (|mathprint| (cons '= (cons |x| (cons |printform| nil)))) |flag|)
+         (cond 
+          ((boot-equal |flag| '|letPrint2|) (|print| |printform|))
+          (t nil))))
+      (cond 
+       ((and 
+         (spadlet |y| (|hasPair| 'break |y|))
+         (or (boot-equal |y| '|all|)
+             (and 
+              (memq |x| |y|)
+              (null (memq (elt (pname |x|) 0) '($ |#|)))
+              (null (gensymp |x|)))))
+        (|break|
+         (append
+          (|bright| |currentFunction|)
+          (cons "breaks after" 
+           (append (|bright| |x|) (cons '|:= | (cons |printform| nil)))))))
+       (t nil))))
+    |x|)))) 
+
+@
+
+\subsection{defun letPrint3}
+\begin{verbatim}
+;-- This is the version for use when we have our hands on a function
+;-- to convert the data into type "Expression"
+;letPrint3(x,xval,printfn,currentFunction) ==
+;  $BreakMode:local := nil
+;  if $letAssoc and
+;    ((y:= LASSOC(currentFunction,$letAssoc)) or (y:= LASSOC("all",$letAssoc))) then
+;      if (y="all" or MEMQ(x,y)) and
+;        not (IS__GENVAR(x) or isSharpVarWithNum(x) or GENSYMP x) then
+;         $BreakMode:='letPrint2
+;         flag:=nil
+;         CATCH('letPrint2,mathprint ["=",x,SPADCALL(xval,printfn)],flag)
+;         if flag='letPrint2 then print xval
+;      if (y:= hasPair("BREAK",y)) and
+;        (y="all" or MEMQ(x,y) and
+;          (not MEMQ((PNAME x).(0),'($ _#)) and not GENSYMP x)) then
+;            break [:bright currentFunction,'"breaks after",:bright x,'":= ",
+;              xval]
+;  x
+\end{verbatim}
+
+<<defun letPrint3>>=
+(defun |letPrint3| (|x| |xval| |printfn| |currentFunction|)
+ (prog (|$BreakMode| |flag| |y|)
+  (declare (special |$BreakMode|))
+  (return
+   (progn
+    (spadlet |$BreakMode| nil)
+    (cond
+     ((and |$letAssoc| 
+       (or (spadlet |y| (lassoc |currentFunction| |$letAssoc|))
+           (spadlet |y| (lassoc '|all| |$letAssoc|))))
+       (cond
+        ((and
+           (or (boot-equal |y| '|all|) (memq |x| |y|))
+           (null (or (is_genvar |x|) (|isSharpVarWithNum| |x|) (gensymp |x|))))
+          (spadlet |$BreakMode| '|letPrint2|)
+          (spadlet |flag| nil)
+          (catch '|letPrint2|
+           (|mathprint|
+            (cons '= (cons |x| (cons (spadcall |xval| |printfn|) nil))))
+           |flag|)
+          (cond
+           ((boot-equal |flag| '|letPrint2|) (|print| |xval|))
+           (t nil))))
+       (cond
+        ((and
+          (spadlet |y| (|hasPair| 'break |y|))
+          (or
+           (boot-equal |y| '|all|)
+           (and
+            (memq |x| |y|)
+            (null (memq (elt (pname |x|) 0) '($ |#|)))
+            (null (gensymp |x|)))))
+          (|break|
+           (append
+            (|bright| |currentFunction|)
+            (cons "breaks after"
+             (append (|bright| |x|) (cons ":= " (cons |xval| nil)))))))
+        (t nil))))
+    |x|)))) 
+
+@
+\subsection{defun getAliasIfTracedMapParameter}
+\begin{verbatim}
+;getAliasIfTracedMapParameter(x,currentFunction) ==
+;  isSharpVarWithNum x =>
+;    aliasList:= get(currentFunction,'alias,$InteractiveFrame) =>
+;      aliasList.(STRING2PINT_-N(SUBSTRING(PNAME x,1,NIL),1)-1)
+;  x
+\end{verbatim}
+
+<<defun getAliasIfTracedMapParameter>>=
+(defun |getAliasIfTracedMapParameter| (|x| |currentFunction|)
+ (prog (|aliasList|)
+  (return
+   (seq
+    (cond
+     ((|isSharpVarWithNum| |x|)
+       (cond
+        ((spadlet |aliasList|
+           (|get| |currentFunction| '|alias| |$InteractiveFrame|))
+         (exit
+          (elt |aliasList|
+           (spaddifference
+            (string2pint-n (substring (pname |x|) 1 nil) 1) 1))))))
+     (t |x|)))))) 
+
+@
+
+\subsection{defun getBpiNameIfTracedMap}
+\begin{verbatim}
+;getBpiNameIfTracedMap(name) ==
+;  lmm:= get(name,'localModemap,$InteractiveFrame) =>
+;    MEMQ(bpiName:= CADAR lmm,_/TRACENAMES) => bpiName
+;  name
+\end{verbatim}
+
+<<defun getBpiNameIfTracedMap>>=
+(defun |getBpiNameIfTracedMap| (|name|)
+ (prog (|lmm| |bpiName|)
+  (return
+   (seq
+    (cond 
+     ((spadlet |lmm| (|get| |name| '|localModemap| |$InteractiveFrame|))
+       (cond
+        ((memq (spadlet |bpiName| (cadar |lmm|)) /tracenames)
+           (exit |bpiName|))))
+     (t |name|)))))) 
+
+@
+
+\subsection{defun hasPair}
+\begin{verbatim}
+;hasPair(key,l) ==
+;  atom l => nil
+;  l is [ [ =key,:a],:.] => a
+;  hasPair(key,rest l)
+\end{verbatim}
+
+<<defun hasPair>>=
+(defun |hasPair| (|key| |l|)
+ (prog (tmp1 |a|)
+  (return 
+   (cond
+    ((atom |l|) nil)
+    ((and (pairp |l|)
+          (progn
+           (spadlet tmp1 (qcar |l|))
+           (and (pairp tmp1)
+                (equal (qcar tmp1) |key|)
+                (progn (spadlet |a| (qcdr tmp1)) t))))
+       |a|)
+    (t (|hasPair| |key| (cdr |l|))))))) 
+
+@
+
+\subsection{defun shortenForPrinting}
+\begin{verbatim}
+;shortenForPrinting val ==
+;  isDomainOrPackage val => devaluate val
+;  val
+\end{verbatim}
+
+<<defun shortenForPrinting>>=
+(defun |shortenForPrinting| (|val|)
+ (if (|isDomainOrPackage| |val|)
+  (|devaluate| |val|)
+  |val|))
+
+@
+
+\subsection{defun spadTraceAlias}
+\begin{verbatim}
+;spadTraceAlias(domainId,op,n) ==
+;  INTERNL(domainId,".",op,",",STRINGIMAGE n)
+\end{verbatim}
+
+<<defun spadTraceAlias>>=
+(defun |spadTraceAlias| (|domainId| |op| |n|)
+ (internl |domainId| (intern "." "boot") |op| '|,| (stringimage |n|))) 
+
+@
+
+\subsection{defun getOption}
+\begin{verbatim}
+;getOption(opt,l) ==
+;  y:= ASSOC(opt,l) => rest y
+\end{verbatim}
+
+<<defun getOption>>=
+(defun |getOption| (opt l)
+ (prog (y)
+  (return
+   (seq
+    (cond ((spadlet y (|assoc| opt l)) (exit (cdr y)))))))) 
+
+@
+
+\subsection{defun reportSpadTrace}
+\begin{verbatim}
+;reportSpadTrace(header,[op,sig,n,:t]) ==
+;  null $traceNoisely => nil
+;  msg:= [header,'%b,op,":",'%d,rest sig," -> ",first sig," in slot ",n]
+;  namePart:= nil --(t is (.,.,name,:.) => (" named ",name); NIL)
+;  tracePart:=
+;    t is [y,:.] and not null y =>
+;      (y="all" => ['%b,"all",'%d,"vars"]; [" vars: ",y])
+;    NIL
+;  sayBrightly [:msg,:namePart,:tracePart]
+\end{verbatim}
+
+<<defun reportSpadTrace>>=
+(defun |reportSpadTrace| (|header| t0)
+ (prog (|op| |sig| |n| |t| |msg| |namePart| |y| |tracePart|)
+  (return 
+   (progn
+    (spadlet |op| (car t0))
+    (spadlet |sig| (cadr t0))
+    (spadlet |n| (caddr t0))
+    (spadlet |t| (cdddr t0))
+    (cond
+     ((null |$traceNoisely|) nil)
+     (t
+      (spadlet |msg|
+       (cons |header|
+        (cons '|%b|
+         (cons |op|
+          (cons '|:|
+           (cons '|%d|
+            (cons (CDR |sig|)
+             (cons '| -> |
+              (cons (car |sig|)
+               (cons '| in slot |
+                (cons |n| nil)))))))))))
+      (spadlet |namePart| nil)
+      (spadlet |tracePart|
+       (cond
+        ((and (pairp |t|) (progn (spadlet |y| (qcar |t|)) t) (null (null |y|)))
+          (cond
+           ((boot-equal |y| '|all|)
+             (cons '|%b| (cons '|all| (cons '|%d| (cons '|vars| nil)))))
+           (t (cons '| vars: | (cons |y| nil)))))
+        (t nil)))
+      (|sayBrightly| (append |msg| (append |namePart| |tracePart|))))))))) 
+
+@
+
+\subsection{defun orderBySlotNumber}
+\begin{verbatim}
+;orderBySlotNumber l ==
+;  ASSOCRIGHT orderList [ [n,:x] for (x:= [.,.,n,:.]) in l]
+\end{verbatim}
+
+<<defun orderBySlotNumber>>=
+(defun |orderBySlotNumber| (|l|)
+ (prog (|n|)
+  (return 
+   (seq
+    (assocright
+     (|orderList|
+      (prog (t0)
+       (spadlet t0 nil)
+       (return
+        (do ((t1 |l| (cdr t1)) (|x| nil))
+            ((or (atom t1)
+                 (progn (setq |x| (car t1)) nil)
+                 (progn (progn (spadlet |n| (caddr |x|)) |x|) nil))
+               (nreverse0 t0))
+         (seq
+          (exit
+           (setq t0 (cons (cons |n| |x|) t0))))))))))))) 
+
+@
+
+\subsection{defun /tracereply}
+\begin{verbatim}
+;_/TRACEREPLY() ==
+;  null _/TRACENAMES => MAKESTRING '"   Nothing is traced."
+;  for x in _/TRACENAMES repeat
+;    x is [d,:.] and isDomainOrPackage d =>
+;      domainList:= [devaluate d,:domainList]
+;    functionList:= [x,:functionList]
+;  [:functionList,:domainList,"traced"]
+\end{verbatim}
+
+<<defun /tracereply>>=
+(defun /tracereply () 
+ (prog (|d| |domainList| |functionList|)
+  (return
+   (seq
+    (cond
+     ((null /tracenames) "   Nothing is traced.")
+     (t
+       (do ((t0 /tracenames (cdr t0)) (|x| nil))
+           ((or (atom t0) (progn (setq |x| (car t0)) nil)) nil)
+        (seq
+         (exit
+          (cond
+           ((and (pairp |x|) 
+                 (progn (spadlet |d| (qcar |x|)) t)
+                 (|isDomainOrPackage| |d|))
+              (spadlet |domainList| (cons (|devaluate| |d|) |domainList|)))
+           (t 
+            (spadlet |functionList| (cons |x| |functionList|)))))))
+       (append |functionList|
+        (append |domainList| (cons '|traced| nil))))))))) 
+
+@
+
+\subsection{defun spadReply}
+\begin{verbatim}
+;spadReply() ==
+;  [printName x for x in _/TRACENAMES] where
+;    printName x ==
+;      x is [d,:.] and isDomainOrPackage d => devaluate d
+;      x
+\end{verbatim}
+
+<<defun spadReply,printName>>=
+(defun |spadReply,printName| (|x|)
+ (prog (|d|)
+  (return
+   (seq
+    (if (and (and (pairp |x|) (progn (spadlet |d| (qcar |x|)) t))
+             (|isDomainOrPackage| |d|))
+       (exit (|devaluate| |d|)))
+     (exit |x|))))) 
+
+@
+
+<<defun spadReply>>=
+(defun |spadReply| ()
+ (prog () 
+  (return
+   (seq
+    (prog (t0)
+     (spadlet t0 nil)
+     (return
+       (do ((t1 /tracenames (cdr t1)) (|x| nil))
+           ((or (atom t1) (progn (setq |x| (car t1)) nil)) (nreverse0 t0))
+        (seq
+         (exit
+          (setq t0 (cons (|spadReply,printName| |x|) t0))))))))))) 
+
+@
+
+\subsection{defun spadUntrace}
+\begin{verbatim}
+;spadUntrace(domain,options) ==
+;  not isDomainOrPackage domain => userError '"bad argument to untrace"
+;  anyifTrue:= null options
+;  listOfOperations:= getOption("ops:",options)
+;  domainId := devaluate domain
+;  null (pair:= ASSOC(domain,_/TRACENAMES)) =>
+;    sayMSG ['"   No functions in",
+;      :bright prefix2String domainId,'"are now traced."]
+;  sigSlotNumberAlist:= rest pair
+;  for (pair:= [op,sig,n,lv,bpiPointer,traceName,alias]) in sigSlotNumberAlist |
+;    anyifTrue or MEMQ(op,listOfOperations) repeat
+;      BPIUNTRACE(traceName,alias)
+;      RPLAC(first domain.n,bpiPointer)
+;      RPLAC(CDDDR pair,nil)
+;      if assocPair:=ASSOC(BPINAME bpiPointer,$letAssoc) then
+;        $letAssoc := REMOVER($letAssoc,assocPair)
+;        if null $letAssoc then SETLETPRINTFLAG nil
+;  newSigSlotNumberAlist:= [x for x in sigSlotNumberAlist | CDDDR x]
+;  newSigSlotNumberAlist => RPLAC(rest pair,newSigSlotNumberAlist)
+;  SETQ(_/TRACENAMES,DELASC(domain,_/TRACENAMES))
+;  spadReply()
+\end{verbatim}
+
+<<defun spadUntrace>>=
+(defun |spadUntrace| (|domain| |options|)
+ (prog (|anyifTrue| |listOfOperations| |domainId| |pair| |sigSlotNumberAlist| 
+        |op| |sig| |n| |lv| |bpiPointer| |traceName| |alias| |assocPair| 
+        |newSigSlotNumberAlist|)
+  (return
+   (seq
+    (cond
+     ((null (|isDomainOrPackage| |domain|))
+       (|userError| "bad argument to untrace"))
+     (t
+      (spadlet |anyifTrue| (null |options|))
+      (spadlet |listOfOperations| (|getOption| '|ops:| |options|))
+      (spadlet |domainId| (|devaluate| |domain|))
+      (cond
+       ((null (spadlet |pair| (|assoc| |domain| /tracenames)))
+         (|sayMSG| 
+          (cons "   No functions in" 
+           (append
+            (|bright| (|prefix2String| |domainId|))
+            (cons "are now traced." nil)))))
+       (t 
+        (spadlet |sigSlotNumberAlist| (cdr |pair|))
+        (do ((t0 |sigSlotNumberAlist| (cdr t0)) (|pair| nil))
+            ((or (atom t0) 
+                 (progn (setq |pair| (car t0)) nil)
+                 (progn
+                  (progn
+                   (spadlet |op| (car |pair|))
+                   (spadlet |sig| (cadr |pair|))
+                   (spadlet |n| (caddr |pair|))
+                   (spadlet |lv| (cadddr |pair|))
+                   (spadlet |bpiPointer| (car (cddddr |pair|)))
+                   (spadlet |traceName| (cadr (cddddr |pair|)))
+                   (spadlet |alias| (caddr (cddddr |pair|)))
+                   |pair|)
+                  nil))
+                 nil)
+         (seq
+          (exit
+           (cond
+            ((or |anyifTrue| (memq |op| |listOfOperations|))
+              (progn
+                (bpiuntrace |traceName| |alias|)
+                (rplac (car (elt |domain| |n|)) |bpiPointer|)
+                (rplac (cdddr |pair|) nil)
+                (cond
+                 ((spadlet |assocPair|
+                     (|assoc| (bpiname |bpiPointer|) |$letAssoc|))
+                   (spadlet |$letAssoc| (remover |$letAssoc| |assocPair|))
+                   (cond 
+                    ((null |$letAssoc|) (setletprintflag nil))
+                    (t nil)))
+                 (t nil))))))))
+        (spadlet |newSigSlotNumberAlist|
+         (prog (t1) 
+          (spadlet t1 nil)
+          (return
+           (do ((t2 |sigSlotNumberAlist| (cdr t2)) (|x| nil))
+               ((or (atom t2) (progn (setq |x| (car t2)) nil)) (nreverse0 t1))
+             (seq
+              (exit
+               (cond ((cdddr |x|) (setq t1 (cons |x| t1))))))))))
+        (cond 
+         (|newSigSlotNumberAlist| 
+          (rplac (cdr |pair|) |newSigSlotNumberAlist|))
+         (t 
+          (setq /tracenames (delasc |domain| /tracenames))
+          (|spadReply|))))))))))) 
+
+@
+\subsection{defun prTraceNames}
+\begin{verbatim}
+;prTraceNames() ==
+;  (for x in _/TRACENAMES repeat PRINT fn x; nil) where
+;    fn x ==
+;      x is [d,:t] and isDomainOrPackage d => [devaluate d,:t]
+;      x
+\end{verbatim}
+
+<<defun prTraceNames,fn>>=
+(defun |prTraceNames,fn| (|x|)
+ (prog (|d| |t|)
+  (return
+   (seq
+    (if (and (and (pairp |x|) 
+                  (progn (spadlet |d| (qcar |x|)) (spadlet |t| (qcdr |x|)) t))
+              (|isDomainOrPackage| |d|))
+      (exit (cons (|devaluate| |d|) |t|)))
+    (exit |x|))))) 
+
+@
+
+<<defun prTraceNames>>=
+(defun |prTraceNames| ()
+ (seq
+  (progn
+   (do ((t0 /tracenames (cdr t0)) (|x| nil))
+       ((or (atom t0) (progn (setq |x| (car t0)) nil)) nil)
+    (seq
+     (exit
+      (print (|prTraceNames,fn| |x|))))) nil))) 
+
+@
+
+\subsection{defun traceReply}
+\begin{verbatim}
+;traceReply() ==
+;  $domains: local:= nil
+;  $packages: local:= nil
+;  $constructors: local:= nil
+;  null _/TRACENAMES =>
+;    sayMessage '"   Nothing is traced now."
+;  sayBrightly '" "
+;  for x in _/TRACENAMES repeat
+;    x is [d,:.] and (isDomainOrPackage d) => addTraceItem d
+;    atom x =>
+;      isFunctor x => addTraceItem x
+;      (IS__GENVAR x =>
+;        addTraceItem EVAL x; functionList:= [x,:functionList])
+;    userError '"bad argument to trace"
+;  functionList:= "append"/[ [rassocSub(x,$mapSubNameAlist),'" "]
+;    for x in functionList | ^isSubForRedundantMapName x]
+;  if functionList then
+;    2 = #functionList =>
+;      sayMSG ["   Function traced: ",:functionList]
+;    (22 + sayBrightlyLength functionList) <= $LINELENGTH =>
+;      sayMSG ["   Functions traced: ",:functionList]
+;    sayBrightly "   Functions traced:"
+;    sayBrightly flowSegmentedMsg(functionList,$LINELENGTH,6)
+;  if $domains then
+;    displayList:= concat(prefix2String first $domains,
+;          [:concat('",",'" ",prefix2String x) for x in rest $domains])
+;    if atom displayList then displayList:= [displayList]
+;    sayBrightly '"   Domains traced: "
+;    sayBrightly flowSegmentedMsg(displayList,$LINELENGTH,6)
+;  if $packages then
+;    displayList:= concat(prefix2String first $packages,
+;          [:concat(", ",prefix2String x) for x in rest $packages])
+;    if atom displayList then displayList:= [displayList]
+;    sayBrightly '"   Packages traced: "
+;    sayBrightly flowSegmentedMsg(displayList,$LINELENGTH,6)
+;  if $constructors then
+;    displayList:= concat(abbreviate first $constructors,
+;          [:concat(", ",abbreviate x) for x in rest $constructors])
+;    if atom displayList then displayList:= [displayList]
+;    sayBrightly '"   Parameterized constructors traced:"
+;    sayBrightly flowSegmentedMsg(displayList,$LINELENGTH,6)
+\end{verbatim}
+
+<<defun traceReply>>=
+(defun |traceReply| ()
+ (prog (|$domains| |$packages| |$constructors| |d| |functionList| 
+        |displayList|)
+  (declare (special |$domains| |$packages| |$constructors|))
+  (return
+   (seq
+    (progn
+     (spadlet |$domains| nil)
+     (spadlet |$packages| nil)
+     (spadlet |$constructors| nil)
+     (cond
+      ((null /tracenames) (|sayMessage| "   Nothing is traced now."))
+      (t
+        (|sayBrightly| " ")
+        (do ((t0 /tracenames (cdr t0)) (|x| nil))
+             ((or (atom t0) (progn (setq |x| (car t0)) nil)) nil)
+         (seq
+          (exit
+           (cond
+            ((and (pairp |x|) 
+                  (progn (spadlet |d| (qcar |x|)) t) (|isDomainOrPackage| |d|))
+               (|addTraceItem| |d|))
+            ((atom |x|)
+               (cond
+                ((|isFunctor| |x|) (|addTraceItem| |x|))
+                ((is_genvar |x|) (|addTraceItem| (EVAL |x|)))
+                (t (spadlet |functionList| (CONS |x| |functionList|)))))
+            (t (|userError| "bad argument to trace"))))))
+        (spadlet |functionList|
+          (prog (t1)
+           (spadlet t1 nil)
+           (return
+            (do ((t2 |functionList| (cdr t2)) (|x| nil))
+                ((or (atom t2) (progn (setq |x| (car t2)) nil)) t1)
+              (seq
+               (exit
+                (cond 
+                 ((null (|isSubForRedundantMapName| |x|))
+                   (setq t1 
+                    (append t1 
+                     (cons (|rassocSub| |x| |$mapSubNameAlist|)
+                           (cons " " nil))))))))))))
+       (cond 
+        (|functionList| 
+         (cond 
+          ((eql 2 (|#| |functionList|))
+             (|sayMSG| (cons '|   Function traced: | |functionList|)))
+          ((<= (PLUS 22 (|sayBrightlyLength| |functionList|)) $linelength)
+             (|sayMSG| (cons '|   Functions traced: | |functionList|)))
+          (t 
+             (|sayBrightly| "   Functions traced:")
+             (|sayBrightly|
+              (|flowSegmentedMsg| |functionList| $linelength 6))))))
+       (cond 
+        (|$domains|
+         (spadlet |displayList|
+          (|concat|
+           (|prefix2String| (CAR |$domains|))
+           (prog (t3)
+            (spadlet t3 nil)
+            (return
+             (do ((t4 (cdr |$domains|) (cdr t4)) (|x| nil))
+                 ((or (atom t4) (progn (setq |x| (car t4)) nil)) t3)
+              (seq
+               (exit
+                (setq t3
+                 (append t3 (|concat| "," " " (|prefix2String| |x|)))))))))))
+         (cond 
+          ((atom |displayList|)
+           (spadlet |displayList| (cons |displayList| nil))))
+         (|sayBrightly| "   Domains traced: ")
+         (|sayBrightly| (|flowSegmentedMsg| |displayList| $LINELENGTH 6))))
+       (cond 
+        (|$packages|
+          (spadlet |displayList|
+           (|concat|
+            (|prefix2String| (CAR |$packages|))
+            (prog (t5)
+             (spadlet t5 nil)
+             (return
+              (do ((t6 (cdr |$packages|) (cdr t6)) (|x| nil))
+                  ((or (atom t6) (progn (setq |x| (car t6)) nil)) t5)
+               (seq
+                (exit
+                 (setq t5
+                  (append t5 (|concat| '|, | (|prefix2String| |x|)))))))))))
+          (cond ((atom |displayList|)
+              (spadlet |displayList| (cons |displayList| nil))))
+          (|sayBrightly| "   Packages traced: ")
+          (|sayBrightly| (|flowSegmentedMsg| |displayList| $linelength 6))))
+       (cond 
+        (|$constructors|
+         (spadlet |displayList|
+          (|concat|
+           (|abbreviate| (CAR |$constructors|))
+           (prog (t7)
+            (spadlet t7 nil)
+             (return 
+              (do ((t8 (cdr |$constructors|) (cdr t8)) (|x| nil))
+                  ((or (atom t8) (progn (setq |x| (car t8)) nil)) t7)
+               (seq
+                (exit
+                 (setq t7
+                 (append t7 (|concat| '|, | (|abbreviate| |x|)))))))))))
+         (cond ((atom |displayList|)
+            (spadlet |displayList| (CONS |displayList| nil))))
+         (|sayBrightly| "   Parameterized constructors traced:")
+         (|sayBrightly| (|flowSegmentedMsg| |displayList| $linelength 6)))
+        (t nil))))))))) 
+
+@
+
+\subsection{defun addTraceItem}
+\begin{verbatim}
+;addTraceItem d ==
+;  constructor? d => $constructors:=[d,:$constructors]
+;  isDomain d => $domains:= [devaluate d,:$domains]
+;  isDomainOrPackage d => $packages:= [devaluate d,:$packages]
+\end{verbatim}
+
+<<defun addTraceItem>>=
+(defun |addTraceItem| (|d|)
+ (cond
+  ((|constructor?| |d|)
+    (spadlet |$constructors| (cons |d| |$constructors|)))
+  ((|isDomain| |d|)
+    (spadlet |$domains| (cons (|devaluate| |d|) |$domains|)))
+  ((|isDomainOrPackage| |d|)
+    (spadlet |$packages| (cons (|devaluate| |d|) |$packages|))))) 
+
+@
+
+\subsection{defun ?t}
+\begin{verbatim}
+;_?t() ==
+;  null _/TRACENAMES => sayMSG bright '"nothing is traced"
+;  for x in _/TRACENAMES | atom x and not IS__GENVAR x repeat
+;    if llm:= get(x,'localModemap,$InteractiveFrame) then
+;      x:= (LIST (CADAR llm))
+;    sayMSG ['"Function",:bright rassocSub(x,$mapSubNameAlist),'"traced"]
+;  for x in _/TRACENAMES | x is [d,:l] and isDomainOrPackage d repeat
+;    suffix:=
+;      isDomain d => '"domain"
+;      '"package"
+;    sayBrightly ['"   Functions traced in ",suffix,'%b,devaluate d,'%d,":"]
+;    for x in orderBySlotNumber l repeat reportSpadTrace("   ",take(4,x))
+;    TERPRI()
+\end{verbatim}
+
+<<defun ?t>>=
+(defun |?t| ()
+ (prog (|llm| |x| |d| |l| |suffix|)
+  (return
+   (seq
+    (cond
+     ((null /tracenames) (|sayMSG| (|bright| "nothing is traced")))
+     (t
+      (do ((t0 /tracenames (cdr t0)) (|x| nil))
+          ((or (atom t0) (progn (setq |x| (car t0)) nil)) nil)
+       (seq
+        (exit
+         (cond
+          ((and (atom |x|) (null (is_genvar |x|)))
+           (progn
+            (cond
+             ((spadlet |llm| (|get| |x| '|localModemap| |$InteractiveFrame|))
+               (spadlet |x| (list (cadar |llm|)))))
+            (|sayMSG|
+             (cons "Function"
+              (append
+               (|bright| (|rassocSub| |x| |$mapSubNameAlist|))
+               (cons "traced" nil))))))))))
+      (do ((t1 /tracenames (cdr t1)) (|x| nil))
+          ((or (atom t1) (progn (setq |x| (car t1)) nil)) nil)
+       (seq
+        (exit
+         (cond
+          ((and (pairp |x|) 
+                (progn (spadlet |d| (qcar |x|)) (spadlet |l| (qcdr |x|)) t)
+                (|isDomainOrPackage| |d|))
+           (progn
+            (spadlet |suffix| (cond ((|isDomain| |d|) "domain") (t "package")))
+            (|sayBrightly|
+             (cons "   Functions traced in "
+              (cons |suffix|
+               (cons '|%b| 
+                (cons (|devaluate| |d|) 
+                 (cons '|%d| 
+                  (cons ":" nil)))))))
+            (do ((t2 (|orderBySlotNumber| |l|) (cdr t2)) (|x| nil))
+                ((or (atom t2) (progn (setq |x| (car t2)) nil)) nil)
+              (seq
+               (exit
+                (|reportSpadTrace| '|   | (TAKE 4 |x|)))))
+            (terpri))))))))))))) 
+
+@
+\subsection{defun tracelet}
+\begin{verbatim}
+;tracelet(fn,vars) ==
+;  if GENSYMP fn and stupidIsSpadFunction EVAL fn then
+;    fn := EVAL fn
+;    if COMPILED_-FUNCTION_-P fn then fn:=BPINAME fn
+;  fn = 'Undef => nil
+;  vars:=
+;    vars="all" => "all"
+;    l:= LASSOC(fn,$letAssoc) => UNION(vars,l)
+;    vars
+;  $letAssoc:= [ [fn,:vars],:$letAssoc]
+;  if $letAssoc then SETLETPRINTFLAG true
+;  $TRACELETFLAG : local := true
+;  $QuickLet : local := false
+;  ^MEMQ(fn,$traceletFunctions) and ^IS__GENVAR fn and COMPILED_-FUNCTION_-P SYMBOL_-FUNCTION fn
+;    and not stupidIsSpadFunction fn and not GENSYMP fn =>
+;      ($traceletFunctions:= [fn,:$traceletFunctions]; compileBoot fn ;
+;       $traceletFunctions:= DELETE(fn,$traceletFunctions) )
+\end{verbatim}
+
+<<defun tracelet>>=
+(defun |tracelet| (|fn| |vars|)
+ (prog ($traceletflag |$QuickLet| |l|)
+  (declare (special $traceletflag |$QuickLet|))
+  (return
+   (progn
+    (cond
+     ((and (gensymp |fn|) (|stupidIsSpadFunction| (eval |fn|)))
+       (spadlet |fn| (eval |fn|))
+       (cond
+        ((compiled-function-p |fn|) (spadlet |fn| (bpiname |fn|)))
+        (t nil))))
+    (cond
+     ((boot-equal |fn| '|Undef|) nil)
+     (t
+       (spadlet |vars|
+         (cond
+          ((boot-equal |vars| '|all|) '|all|)
+          ((spadlet |l| (lassoc |fn| |$letAssoc|)) (|union| |vars| |l|))
+          (t |vars|)))
+       (spadlet |$letAssoc| (cons (cons |fn| |vars|) |$letAssoc|))
+       (cond (|$letAssoc| (setletprintflag t)))
+       (spadlet $traceletflag t)
+       (spadlet |$QuickLet| nil)
+       (cond
+        ((and (null (memq |fn| |$traceletFunctions|))
+              (null (is_genvar |fn|))
+              (compiled-function-p (symbol-function |fn|))
+              (null (|stupidIsSpadFunction| |fn|))
+              (null (gensymp |fn|)))
+          (progn
+           (spadlet |$traceletFunctions| (cons |fn| |$traceletFunctions|))
+           (|compileBoot| |fn|)
+           (spadlet |$traceletFunctions|
+             (|delete| |fn| |$traceletFunctions|))))))))))) 
+
+@
+\subsection{defun breaklet}
+\begin{verbatim}
+;breaklet(fn,vars) ==
+;                       --vars is "all" or a list of variables
+;  --$letAssoc ==> (.. (=fn .. (BREAK . all))) OR (.. (=fn .. (BREAK . vl)))
+;  if GENSYMP fn and stupidIsSpadFunction EVAL fn then
+;    fn := EVAL fn
+;    if COMPILED_-FUNCTION_-P fn then fn:= BPINAME fn
+;  fn = "Undef" => nil
+;  fnEntry:= LASSOC(fn,$letAssoc)
+;  vars:=
+;    pair:= ASSOC("BREAK",fnEntry) => UNION(vars,rest pair)
+;    vars
+;  $letAssoc:=
+;    null fnEntry => [[fn,:LIST ["BREAK",:vars]],:$letAssoc]
+;    pair => (RPLACD(pair,vars); $letAssoc)
+;  if $letAssoc then SETLETPRINTFLAG true
+;  $QuickLet:local := false
+;  ^MEMQ(fn,$traceletFunctions) and not stupidIsSpadFunction fn
+;    and not GENSYMP fn =>
+;      $traceletFunctions:= [fn,:$traceletFunctions]
+;      compileBoot fn
+;      $traceletFunctions:= DELETE(fn,$traceletFunctions)
+\end{verbatim}
+
+;;;     ***       |breaklet| REDEFINED
+<<defun breaklet>>=
+(defun |breaklet| (|fn| |vars|)
+ (prog (|$QuickLet| |fnEntry| |pair|)
+  (declare (special |$QuickLet|))
+  (return
+   (progn
+    (cond
+     ((and (gensymp |fn|) (|stupidIsSpadFunction| (eval |fn|)))
+       (spadlet |fn| (eval |fn|))
+       (cond
+        ((compiled-function-p |fn|) (spadlet |fn| (bpiname |fn|)))
+        (t nil))))
+    (cond
+     ((boot-equal |fn| '|Undef|) nil)
+     (t
+      (spadlet |fnEntry| (lassoc |fn| |$letAssoc|))
+      (spadlet |vars|
+       (cond
+        ((spadlet |pair| (|assoc| 'break |fnEntry|))
+          (|union| |vars| (cdr |pair|)))
+        (t |vars|)))
+      (spadlet |$letAssoc|
+       (cond
+        ((null |fnEntry|)
+          (cons (cons |fn| (list (cons 'break |vars|))) |$letAssoc|))
+        (|pair| (rplacd |pair| |vars|) |$letAssoc|)))
+      (cond (|$letAssoc| (setletprintflag t)))
+      (spadlet |$QuickLet| nil)
+      (cond
+       ((and (null (memq |fn| |$traceletFunctions|))
+             (null (|stupidIsSpadFunction| |fn|))
+             (null (gensymp |fn|)))
+        (progn
+         (spadlet |$traceletFunctions| (cons |fn| |$traceletFunctions|))
+         (|compileBoot| |fn|)
+         (spadlet |$traceletFunctions|
+          (|delete| |fn| |$traceletFunctions|))))))))))) 
+
+@
+\subsection{defun stupidIsSpadFunction}
+\begin{verbatim}
+;stupidIsSpadFunction fn ==
+;  -- returns true if the function pname has a semi-colon in it
+;  -- eventually, this will use isSpadFunction from luke boot
+;  STRPOS('"_;",PNAME fn,0,NIL)
+\end{verbatim}
+
+<<defun stupidIsSpadFunction>>=
+(defun |stupidIsSpadFunction| (|fn|)
+ (strpos ";" (pname |fn|) 0 nil)) 
+
+@
+
+\subsection{defun break}
+\begin{verbatim}
+;break msg ==
+;  condition:= MONITOR_,EVALTRAN(_/BREAKCONDITION,nil)
+;  -- The next line is to try to deal with some reported cases of unwanted
+;  -- backtraces appearing, MCD.
+;  ENABLE_-BACKTRACE(nil)
+;  EVAL condition =>
+;    sayBrightly msg
+;    INTERRUPT()
+\end{verbatim}
+
+;;;     ***       |break| REDEFINED
+
+<<defun break>>=
+(defun |break| (|msg|)
+ (prog (|condition|)
+  (return
+   (progn
+    (spadlet |condition| (|MONITOR,EVALTRAN| /breakcondition nil))
+    (enable-backtrace nil)
+    (cond ((eval |condition|) (progn (|sayBrightly| |msg|) (interrupt)))))))) 
+
+@
+\subsection{defun compileBoot}
+\begin{verbatim}
+;compileBoot fn == _/D_,1(LIST fn,'(_/COMP),nil,nil)
+\end{verbatim}
+
+<<defun compileBoot>>=
+(defun |compileBoot| (|fn|)
+ (|/D,1| (list |fn|) '(/comp) nil nil)) 
+
+@
+
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{undo}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@@ -7265,7 +10339,7 @@ undoLocalModemapHack changeList ==
   (return
    (seq
     (prog (tmp0)
-     (spadlet tmp0 NIL)
+     (spadlet tmp0 nil)
      (return
       (do ((tmp1 changeList (cdr tmp1)) (pair nil))
           ((or (atom tmp1) 
@@ -7535,6 +10609,7 @@ The command synonym  {\tt )apropos} is equivalent to
 \fnref{set}, and
 \fnref{show}
 
+\subsection{defun what}
 \begin{verbatim}
 what l == whatSpad2Cmd l
 \end{verbatim}
@@ -7544,6 +10619,7 @@ what l == whatSpad2Cmd l
 
 @
 
+\subsection{defun whatSpad2Cmd}
 \begin{verbatim}
 whatSpad2Cmd l ==
   $e:local := $EmptyEnvironment
@@ -7572,6 +10648,7 @@ whatSpad2Cmd l ==
     printSynonyms(args)
 \end{verbatim}
 
+\subsection{defun whatSpad2Cmd,fixpat}
 <<defun whatSpad2Cmd,fixpat>>=
 (defun |whatSpad2Cmd,fixpat| (|x|)
  (prog (|x'|)
@@ -7582,6 +10659,8 @@ whatSpad2Cmd l ==
     (exit (downcase |x|)))))) 
 
 @
+
+\subsection{defun whatSpad2Cmd}
 <<defun whatSpad2Cmd>>=
 (defun |whatSpad2Cmd| (|l|)
  (prog (|$e| |key0| |key| |args|)
@@ -7634,6 +10713,8 @@ whatSpad2Cmd l ==
                       (|printSynonyms| |args|))))))))))))))) 
 
 @
+
+\subsection{defun filterAndFormatConstructors}
 \begin{verbatim}
 filterAndFormatConstructors(constrType,label,patterns) ==
   centerAndHighlight(label,$LINELENGTH,specialChar 'hbar)
@@ -7683,6 +10764,7 @@ filterAndFormatConstructors(constrType,label,patterns) ==
 
 @ 
 
+\subsection{defun whatConstructors}
 \begin{verbatim}
 whatConstructors constrType ==
   -- here constrType should be one of 'category, 'domain, 'package
@@ -7715,6 +10797,8 @@ whatConstructors constrType ==
                t0)))))))))))))) 
 
 @
+
+\subsection{defun apropos}
 \begin{verbatim}
 apropos l ==
   -- l is a list of operation name fragments
@@ -7767,6 +10851,7 @@ apropos l ==
 
 ; )library top level command  -- soon to be obsolete
 
+\subsection{defun with}
 <<defun with>>=
 (defun |with| (args)
  (|library| args))
@@ -7776,6 +10861,7 @@ apropos l ==
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{workfiles}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\subsection{defun workfiles}
 \begin{verbatim}
 workfiles l == workfilesSpad2Cmd l
 \end{verbatim}
@@ -7784,6 +10870,8 @@ workfiles l == workfilesSpad2Cmd l
  (|workfilesSpad2Cmd| l)) 
 
 @
+
+\subsection{defun workfilesSpad2Cmd}
 \begin{verbatim}
 workfilesSpad2Cmd args ==
   args => throwKeyedMsg("S2IZ0047",NIL)
@@ -7831,7 +10919,7 @@ workfilesSpad2Cmd args ==
               (|throwKeyedMsg| 's2iz0048 (cons |type| nil)))
             ((boot-equal |type1| '|delete|)
               (spadlet |deleteFlag| t)))))))
-       (do ((t2 |$options| (cdr t2)) (t3 NIL))
+       (do ((t2 |$options| (cdr t2)) (t3 nil))
            ((or (atom t2)
             (progn (setq t3 (CAR t2)) nil)
             (progn
@@ -7886,6 +10974,7 @@ workfilesSpad2Cmd args ==
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{zsystemdevelopment}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\subsection{defun zsystemdevelopment}
 \begin{verbatim}
 zsystemdevelopment l == zsystemDevelopmentSpad2Cmd l
 \end{verbatim}
@@ -7894,6 +10983,8 @@ zsystemdevelopment l == zsystemDevelopmentSpad2Cmd l
  (|zsystemDevelopmentSpad2Cmd| |l|)) 
 
 @
+
+\subsection{defun zsystemDevelopmentSpad2Cmd}
 \begin{verbatim}
 zsystemDevelopmentSpad2Cmd l == zsystemdevelopment1 (l,$InteractiveMode)
 \end{verbatim}
@@ -7902,6 +10993,8 @@ zsystemDevelopmentSpad2Cmd l == zsystemdevelopment1 (l,$InteractiveMode)
  (|zsystemdevelopment1| |l| |$InteractiveMode|)) 
 
 @
+
+\subsection{defun zsystemdevelopment1}
 \begin{verbatim}
 zsystemdevelopment1(l,im) ==
   $InteractiveMode : local := im
@@ -7950,8 +11043,8 @@ zsystemdevelopment1(l,im) ==
    (seq
     (progn
      (spadlet |$InteractiveMode| |im|)
-     (spadlet |fromopt| NIL)
-     (do ((t0 |$options| (cdr t0)) (t1 NIL))
+     (spadlet |fromopt| nil)
+     (do ((t0 |$options| (cdr t0)) (t1 nil))
          ((or (atom t0)
               (progn (setq t1 (car t0)) nil)
               (progn
@@ -7968,7 +11061,7 @@ zsystemdevelopment1(l,im) ==
          (cond
           ((boot-equal |opt1| '|from|)
             (spadlet |fromopt| (cons (cons 'from |optargs|) nil))))))))
-     (do ((t2 |$options| (cdr t2)) (t3 NIL))
+     (do ((t2 |$options| (cdr t2)) (t3 nil))
          ((or (atom t2)
               (progn (setq t3 (car t2)) nil)
               (progn
@@ -8164,8 +11257,12 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<initvars>>
 
 <<defun addNewInterpreterFrame>>
+<<defun addTraceItem>>
 <<defun apropos>>
+<<defun augmentTraceNames>>
 
+<<defun break>>
+<<defun breaklet>>
 <<defun browse>>
 
 <<defun changeHistListLen>>
@@ -8174,6 +11271,11 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun cleanupLine>>
 <<defun clearFrame>>
 <<defun closeInterpreterFrame>>
+<<defun compileBoot>>
+<<defun coerceSpadArgs2E>>
+<<defun coerceSpadFunValue2E>>
+<<defun coerceTraceArgs2E>>
+<<defun coerceTraceFunValue2E>>
 <<defun createCurrentInterpreterFrame>>
 
 <<defun dewritify>>
@@ -8186,12 +11288,14 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun displayMacros>>
 <<defun displayOperations>>
 <<defun displaySpad2Cmd>>
+<<defun domainToGenvar>>
 
 <<defun emptyInterpreterFrame>>
 
 <<defun fetchOutput>>
 <<defun filterAndFormatConstructors>>
 <<defun findFrameInRing>>
+<<defun flattenOperationAlist>>
 <<defun frame>>
 <<defun frameEnvironment>>
 <<defun frameExposureData>>
@@ -8207,9 +11311,18 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun frameNames>>
 <<defun frameSpad2Cmd>>
 
+<<defun getAliasIfTracedMapParameter>>
+<<defun getBpiNameIfTracedMap>>
+<<defun genDomainTraceName>>
 <<defun getenviron>>
+<<defun getMapSig>>
+<<defun getOption>>
+<<defun getTraceOption>>
+<<defun getTraceOptions>>
+<<defun getTraceOption,hn>>
 <<defun gensymInt>>
 
+<<defun hasPair>>
 <<defun histFileErase>>
 <<defun history>>
 <<defun histFileName>>
@@ -8227,12 +11340,31 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun intloop>>
 <<defun intloopPrefix?>>
 <<defun intloopReadConsole>>
-
+<<defun isDomainOrPackage>>
+<<defun isInterpOnlyMap>>
+<<defun isSubForRedundantMapName>>
+<<defun isTraceGensym>>
+<<defun isUncompiledMap>>
+
+<<defun lassocSub>>
+<<defun letPrint>>
+<<defun letPrint2>>
+<<defun letPrint3>>
 <<defun loadExposureGroupData>>
 
+<<defmacro funfind>>
+<<defun funfind,LAM>>
+
+<<defun getMapSubNames>>
+<<defun getPreviousMapSubNames>>
+
+<<defun isListOfIdentifiers>>
+<<defun isListOfIdentifiersOrStrings>>
+
 <<defun make-absolute-filename>>
 <<defun makeHistFileName>>
 <<defun makeInitialModemapFrame>>
+<<defun mapLetPrint>>
 
 <<defun ncIntLoop>>
 <<defun ncloopCommand>>
@@ -8246,10 +11378,17 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 
 <<defun oldHistFileName>>
 <<defun openserver>>
+<<defun orderBySlotNumber>>
 
+<<defun pcounters>>
 <<defun previousInterpreterFrame>>
+<<defun prTraceNames>>
+<<defun prTraceNames,fn>>
+<<defun pspacers>>
+<<defun ptimers>>
 <<defun putHist>>
 
+<<defun rassocSub>>
 <<defun readHiFi>>
 <<defun reclaim>>
 <<defun recordNewValue>>
@@ -8257,21 +11396,29 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun recordOldValue>>
 <<defun recordOldValue0>>
 <<defun recordFrame>>
+<<defun removeOption>>
+<<defun removeTracedMapSigs>>
 <<defun removeUndoLines>>
+<<defun reportSpadTrace>>
 <<defun reportUndo>>
 <<defun reroot>>
+<<defun resetCounters>>
 <<defun resetInCoreHist>>
+<<defun resetSpacers>>
+<<defun resetTimers>>
 <<defun restart>>
 <<defun restoreHistory>>
 <<defun runspad>>
 
 <<defun safeWritify>>
 <<defun saveHistory>>
+<<defun saveMapSig>>
 <<defun sayExample>>
 <<defun ScanOrPairVec>>
 <<defun setCurrentLine>>
 <<defun setHistoryCore>>
 <<defun set-restart-hook>>
+<<defun shortenForPrinting>>
 <<defun showInOut>>
 <<defun showInput>>
 <<defun setIOindex>>
@@ -8280,10 +11427,33 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun spad-save>>
 <<defun spadClosure?>>
 <<defun SpadInterpretStream>>
+<<defun spadReply>>
+<<defun spadReply,printName>>
 <<defun SPADRREAD>>
 <<defun SPADRWRITE>>
 <<defun SPADRWRITE0>>
+<<defun spadTrace>>
+<<defun spadTrace,isTraceable>>
+<<defun spadTrace,g>>
+<<defun spadTraceAlias>>
+<<defun spadUntrace>>
+<<defun stackTraceOptionError>>
 <<defun statisticsInitialization>>
+<<defun stupidIsSpadFunction>>
+<<defun subTypes>>
+
+<<defun ?t>>
+<<defun trace>>
+<<defun trace1>>
+<<defun traceDomainConstructor>>
+<<defun traceDomainLocalOps>>
+<<defun tracelet>>
+<<defun /tracereply>>
+<<defun transOnlyOption>>
+<<defun traceOptionError>>
+<<defun traceReply>>
+<<defun traceSpad2Cmd>>
+<<defun transTraceItem>>
 
 <<defun undo>>
 <<defun undoChanges>>
@@ -8293,6 +11463,12 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun undoLocalModemapHack>>
 <<defun undoSingleStep>>
 <<defun undoSteps>>
+<<defun untrace>>
+<<defun untraceAllDomainLocalOps>>
+<<defun untraceDomainConstructor>>
+<<defun untraceDomainConstructor,keepTraced?>>
+<<defun untraceDomainLocalOps>>
+<<defun untraceMapSubNames>>
 <<defun unwritable?>>
 <<defun updateCurrentInterpreterFrame>>
 <<defun updateFromCurrentInterpreterFrame>>
@@ -8318,6 +11494,8 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun zsystemdevelopment>>
 <<defun zsystemdevelopment1>>
 <<defun zsystemDevelopmentSpad2Cmd>>
+
+
 @
 \chapter{The Global Variables}
 \section{Star Global Variables}
diff --git a/changelog b/changelog
index 9d2a7f5..a9ffdb8 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,9 @@
+20090307 tpd src/axiom-website/patches.html 20090307.01.tpd.patch
+20090307 tpd src/interp/debugsys.lisp stop loading trace.clisp
+20090307 tpd src/interp/Makefile remove trace.boot
+20090307 tpd src/interp/trace.boot removed. moved to bookvol5
+20090307 tpd src/input/unittest1.input clean up breakage
+20090307 tpd books/bookvol5 add trace root code
 20090305 tpd src/axiom-website/patches.html 20090305.01.tpd.patch
 20090305 jxb books/bookvol10.3 fix Float outputFixed handling
 20090305 jxb Johannes Grabmeier <grabm@heidelbg.ibm.com>
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index b2dbc9c..3f6e161 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -989,5 +989,7 @@ bookvol10.4 add Nag documentation<br/>
 bookvol5 add user level command roots<br/>
 <a href="patches/20090305.01.tpd.patch">20090305.01.tpd.patch</a>
 bookvol10.3 add Grabmeier/Waldek fixes to Float<br/>
+<a href="patches/20090307.01.tpd.patch">20090307.01.tpd.patch</a>
+bookvol5 add trace root<br/>
  </body>
 </html>
diff --git a/src/input/unittest1.input.pamphlet b/src/input/unittest1.input.pamphlet
index 8a94acc..c5c9bd3 100644
--- a/src/input/unittest1.input.pamphlet
+++ b/src/input/unittest1.input.pamphlet
@@ -32,6 +32,7 @@ The )apropos command is the same as a )what command
 <<*>>= 
 --S 2
 )apropos matrix
+--R 
 --R
 --ROperations whose names satisfy the above pattern(s):
 --R
@@ -53,8 +54,9 @@ The )apropos command is the same as a )what command
 --RwronskianMatrix                    zeroMatrix                         
 --RzeroSquareMatrix                   
 --R   
---R      To get more information about an operation such as identityMatrix
---R      , issue the command )display op identityMatrix 
+--R      To get more information about an operation such as 
+--R      rectangularMatrix , issue the command )display op 
+--R      rectangularMatrix 
 --R------------------------------- Categories --------------------------------
 --R
 --RCategories with names matching patterns:
@@ -103,6 +105,7 @@ The )apropos command is the same as a )what command
 
 --S 3
 )what categories set
+--R 
 --R------------------------------- Categories --------------------------------
 --R
 --RCategories with names matching patterns:
@@ -121,6 +124,7 @@ The )apropos command is the same as a )what command
 
 --S 4
 )what commands set
+--R 
 --R--------------- System Commands for User Level: development ---------------
 --R
 --RSystem commands at this level matching patterns:
@@ -132,6 +136,7 @@ The )apropos command is the same as a )what command
 
 --S 5
 )what domains set
+--R 
 --R--------------------------------- Domains ---------------------------------
 --R
 --RDomains with names matching patterns:
@@ -154,6 +159,7 @@ The )apropos command is the same as a )what command
 
 --S 6
 )what operations set
+--R 
 --R
 --ROperations whose names satisfy the above pattern(s):
 --R
@@ -251,12 +257,14 @@ The )apropos command is the same as a )what command
 --RzeroSetSplit                                    
 --RzeroSetSplitIntoTriangularSystems               
 --R   
---R      To get more information about an operation such as setMaxPoints ,
---R      issue the command )display op setMaxPoints 
+--R      To get more information about an operation such as 
+--R      setAttributeButtonStep , issue the command )display op 
+--R      setAttributeButtonStep 
 --E 6
 
 --S 7
 )what packages set
+--R 
 --R-------------------------------- Packages ---------------------------------
 --R
 --RPackages with names matching patterns:
@@ -273,6 +281,7 @@ The )apropos command is the same as a )what command
 
 --S 8
 )what synonym set
+--R 
 --R------------------------- System Command Synonyms -------------------------
 --R
 --R   No user-defined synonyms satisfying patterns:
@@ -282,6 +291,7 @@ The )apropos command is the same as a )what command
 
 --S 9
 )what things set
+--R 
 --R
 --ROperations whose names satisfy the above pattern(s):
 --R
@@ -379,8 +389,9 @@ The )apropos command is the same as a )what command
 --RzeroSetSplit                                    
 --RzeroSetSplitIntoTriangularSystems               
 --R   
---R      To get more information about an operation such as setMaxPoints ,
---R      issue the command )display op setMaxPoints 
+--R      To get more information about an operation such as 
+--R      setAttributeButtonStep , issue the command )display op 
+--R      setAttributeButtonStep 
 --R------------------------------- Categories --------------------------------
 --R
 --RCategories with names matching patterns:
diff --git a/src/interp/Makefile.pamphlet b/src/interp/Makefile.pamphlet
index 3586ffb..2ad3ebe 100644
--- a/src/interp/Makefile.pamphlet
+++ b/src/interp/Makefile.pamphlet
@@ -212,7 +212,6 @@ OBJS= ${OUT}/vmlisp.${O}      ${OUT}/hash.${O} \
       ${OUT}/sockio.${O}      ${OUT}/spad.${O} \
       ${OUT}/spaderror.${O}    \
       ${OUT}/template.${O}    ${OUT}/termrw.${O} \
-      ${OUT}/trace.${O} \
       ${OUT}/union.${O}       ${OUT}/daase.${O}   \
       ${OUT}/fortcall.${O}
 
@@ -502,7 +501,6 @@ DOCFILES=${DOC}/alql.boot.dvi \
 	 ${DOC}/spaderror.lisp.dvi ${DOC}/spad.lisp.dvi \
 	 ${DOC}/sys-pkg.lisp.dvi ${DOC}/template.boot.dvi \
 	 ${DOC}/termrw.boot.dvi ${DOC}/topics.boot.dvi \
-	 ${DOC}/trace.boot.dvi \
 	 ${DOC}/union.lisp.dvi ${DOC}/unlisp.lisp.dvi \
 	 ${DOC}/util.lisp.dvi ${DOC}/varini.boot.dvi \
 	 ${DOC}/vmlisp.lisp.dvi ${DOC}/wi1.boot.dvi \
@@ -6025,48 +6023,6 @@ ${DOC}/termrw.boot.dvi: ${IN}/termrw.boot.pamphlet
 
 @
 
-\subsection{trace.boot}
-<<trace.o (OUT from MID)>>=
-${OUT}/trace.${O}: ${MID}/trace.clisp 
-	@ echo 413 making ${OUT}/trace.${O} from ${MID}/trace.clisp
-	@ (cd ${MID} ; \
-	  if [ -z "${NOISE}" ] ; then \
-	   echo '(progn  (compile-file "${MID}/trace.clisp"' \
-             ':output-file "${OUT}/trace.${O}") (${BYE}))' |  ${DEPSYS} ; \
-	  else \
-	   echo '(progn  (compile-file "${MID}/trace.clisp"' \
-             ':output-file "${OUT}/trace.${O}") (${BYE}))' |  ${DEPSYS} \
-             >${TMP}/trace ; \
-	  fi )
-
-@
-<<trace.clisp (MID from IN)>>=
-${MID}/trace.clisp: ${IN}/trace.boot.pamphlet
-	@ echo 414 making ${MID}/trace.clisp from ${IN}/trace.boot.pamphlet
-	@ (cd ${MID} ; \
-	  ${TANGLE} ${IN}/trace.boot.pamphlet >trace.boot ; \
-	  if [ -z "${NOISE}" ] ; then \
-	   echo '(progn (boottran::boottocl "trace.boot") (${BYE}))' \
-                | ${DEPSYS} ; \
-	  else \
-	   echo '(progn (boottran::boottocl "trace.boot") (${BYE}))' \
-                | ${DEPSYS} >${TMP}/trace ; \
-	  fi ; \
-	  rm trace.boot )
-
-@
-<<trace.boot.dvi (DOC from IN)>>=
-${DOC}/trace.boot.dvi: ${IN}/trace.boot.pamphlet 
-	@echo 415 making ${DOC}/trace.boot.dvi from ${IN}/trace.boot.pamphlet
-	@(cd ${DOC} ; \
-	cp ${IN}/trace.boot.pamphlet ${DOC} ; \
-	${DOCUMENT} ${NOISE} trace.boot ; \
-	rm -f ${DOC}/trace.boot.pamphlet ; \
-	rm -f ${DOC}/trace.boot.tex ; \
-	rm -f ${DOC}/trace.boot )
-
-@
-
 \subsection{as.boot}
 <<as.o (OUT from MID)>>=
 ${OUT}/as.${O}: ${MID}/as.clisp 
@@ -9315,10 +9271,6 @@ clean:
 <<topics.clisp (MID from IN)>>
 <<topics.boot.dvi (DOC from IN)>>
 
-<<trace.o (OUT from MID)>>
-<<trace.clisp (MID from IN)>>
-<<trace.boot.dvi (DOC from IN)>>
-
 <<union.o (OUT from MID)>>
 <<union.lisp (MID from IN)>>
 <<union.lisp.dvi (DOC from IN)>>
diff --git a/src/interp/debugsys.lisp.pamphlet b/src/interp/debugsys.lisp.pamphlet
index 1674e8f..e1e1855 100644
--- a/src/interp/debugsys.lisp.pamphlet
+++ b/src/interp/debugsys.lisp.pamphlet
@@ -174,7 +174,6 @@ loaded by hand we need to establish a value.
       (thesymb "/int/interp/spaderror.lisp")
       (thesymb "/int/interp/template.clisp")
       (thesymb "/int/interp/termrw.clisp")
-      (thesymb "/int/interp/trace.clisp")
       (thesymb "/int/interp/union.lisp")
       (thesymb "/int/interp/daase.lisp")
       (thesymb "/int/interp/fortcall.clisp"))
diff --git a/src/interp/trace.boot.pamphlet b/src/interp/trace.boot.pamphlet
deleted file mode 100644
index 184763b..0000000
--- a/src/interp/trace.boot.pamphlet
+++ /dev/null
@@ -1,849 +0,0 @@
-\documentclass{article}
-\usepackage{axiom}
-\begin{document}
-\title{\$SPAD/src/interp trace.boot}
-\author{The Axiom Team}
-\maketitle
-\begin{abstract}
-\end{abstract}
-\eject
-\tableofcontents
-\eject
-\section{License}
-<<license>>=
--- Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--- All rights reserved.
---
--- Redistribution and use in source and binary forms, with or without
--- modification, are permitted provided that the following conditions are
--- met:
---
---     - Redistributions of source code must retain the above copyright
---       notice, this list of conditions and the following disclaimer.
---
---     - Redistributions in binary form must reproduce the above copyright
---       notice, this list of conditions and the following disclaimer in
---       the documentation and/or other materials provided with the
---       distribution.
---
---     - Neither the name of The Numerical ALgorithms Group Ltd. nor the
---       names of its contributors may be used to endorse or promote products
---       derived from this software without specific prior written permission.
---
--- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--- IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--- TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--- PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--- OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--- EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--- PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--- PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--- LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--- NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--- SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-@
-<<*>>=
-<<license>>
-
---% Code for tracing functions
-
--- This code supports the )trace system command and allows the
--- tracing of LISP, BOOT and SPAD functions and interpreter maps.
-
-SETANDFILEQ($traceNoisely,NIL)  -- give trace and untrace messages
-
-SETANDFILEQ($reportSpadTrace,NIL)  -- reports traced funs
-
-SETANDFILEQ($optionAlist,NIL)
-
-SETANDFILEQ($tracedMapSignatures, NIL)
-
-SETANDFILEQ($traceOptionList,'(
-    after _
-    before _
-    break_
-    cond_
-    count_
-    depth_
-    local_
-    mathprint _
-    nonquietly_
-    nt_
-    of_
-    only_
-    ops_
-    restore_
-    timer_
-    varbreak _
-    vars_
-    within _
-    ))
-
-trace l == traceSpad2Cmd l
-
-traceSpad2Cmd l ==
-  if l is ['Tuple, l1] then l := l1
-  $mapSubNameAlist:= getMapSubNames(l)
-  trace1 augmentTraceNames(l,$mapSubNameAlist)
-  traceReply()
-
-trace1 l ==
-  $traceNoisely: local := NIL
-  if hasOption($options,'nonquietly) then $traceNoisely := true
-  hasOption($options,'off) =>
-    (ops := hasOption($options,'ops)) or
-      (lops := hasOption($options,'local)) =>
-        null l => throwKeyedMsg("S2IT0019",NIL)
-        constructor := unabbrev
-          atom l => l
-          null rest l =>
-            atom first l => first l
-            first first l
-          NIL
-        not(isFunctor constructor) => throwKeyedMsg("S2IT0020",NIL)
-        if ops then
-          ops := getTraceOption ops
-          NIL
-        if lops then
-          lops := rest getTraceOption lops
-          untraceDomainLocalOps(constructor,lops)
-    (1 < # $options) and not hasOption($options,'nonquietly) =>
-      throwKeyedMsg("S2IT0021",NIL)
-    untrace l
-  hasOption($options,'stats) =>
-    (1 < # $options) =>
-      throwKeyedMsg("S2IT0001",['")trace ... )stats"])
-    [.,:opt] := CAR $options
-    -- look for )trace )stats       to list the statistics
-    --          )trace )stats reset to reset them
-    null opt =>      -- list the statistics
-      centerAndHighlight('"Traced function execution times",78,"-")
-      ptimers ()
-      SAY '" "
-      centerAndHighlight('"Traced function execution counts",78,"-")
-      pcounters ()
-    selectOptionLC(first opt,'(reset),'optionError)
-    resetSpacers()
-    resetTimers()
-    resetCounters()
-    throwKeyedMsg("S2IT0002",NIL)
-  a:= hasOption($options,'restore) =>
-    null(oldL:= $lastUntraced) => nil
-    newOptions:= DELETE(a,$options)
-    null l => trace1 oldL
-    for x in l repeat
-      x is [domain,:opList] and VECP domain =>
-        sayKeyedMsg("S2IT0003",[devaluate domain])
-      $options:= [:newOptions,:LASSOC(x,$optionAlist)]
-      trace1 LIST x
-  null l => nil
-  l is ["?"] => _?t()
-  traceList:= [transTraceItem x for x in l] or return nil
-  for x in traceList repeat $optionAlist:=
-    ADDASSOC(x,$options,$optionAlist)
-  optionList:= getTraceOptions $options
-  argument:=
-    domainList:= LASSOC("of",optionList) =>
-      LASSOC("ops",optionList) =>
-        throwKeyedMsg("S2IT0004",NIL)
-      opList:=
-        traceList => LIST ["ops",:traceList]
-        nil
-      varList:=
-        y:= LASSOC("vars",optionList) => LIST ["vars",:y]
-        nil
-      [:domainList,:opList,:varList]
-    optionList => [:traceList,:optionList]
-    traceList
-  _/TRACE_,0 [funName for funName in argument]
-  saveMapSig [funName for funName in argument]
-
-getTraceOptions options ==
-  $traceErrorStack: local := nil
-  optionList:= [getTraceOption x for x in options]
-  $traceErrorStack =>
-    null rest $traceErrorStack =>
-      [key,parms] := first $traceErrorStack
-      throwKeyedMsg(key,['"",:parms])
-    throwListOfKeyedMsgs("S2IT0017",[# $traceErrorStack],
-      NREVERSE $traceErrorStack)
-  optionList
-
-saveMapSig(funNames) ==
-  for name in funNames repeat
-    map:= RASSOC(name,$mapSubNameAlist) =>
-      $tracedMapSignatures:= ADDASSOC(name,getMapSig(map,name),
-        $tracedMapSignatures)
-
-getMapSig(mapName,subName) ==
-  lmms:= get(mapName,'localModemap,$InteractiveFrame) =>
-    for mm in lmms until sig repeat
-      CADR mm = subName => sig:= CDAR mm
-    sig
-
-getTraceOption (x is [key,:l]) ==
-  key:= selectOptionLC(key,$traceOptionList,'traceOptionError)
-  x := [key,:l]
-  MEMQ(key,'(nonquietly timer nt)) => x
-  key='break =>
-    null l => ['break,'before]
-    opts := [selectOptionLC(y,'(before after),NIL) for y in l]
-    and/[IDENTP y for y in opts] => ['break,:opts]
-    stackTraceOptionError ["S2IT0008",NIL]
-  key='restore =>
-    null l => x
-    stackTraceOptionError ["S2IT0009",[STRCONC('")",object2String key)]]
-  key='only => ['only,:transOnlyOption l]
-  key='within =>
-    l is [a] and IDENTP a => x
-    stackTraceOptionError ["S2IT0010",['")within"]]
-  MEMQ(key,'(cond before after)) =>
-    key:=
-      key="cond" => "when"
-      key
-    l is [a] => [key,:l]
-    stackTraceOptionError ["S2IT0011",[STRCONC('")",object2String key)]]
-  key='depth =>
-    l is [n] and FIXP n => x
-    stackTraceOptionError ["S2IT0012",['")depth"]]
-  key='count =>
-    (null l) or (l is [n] and FIXP n) => x
-    stackTraceOptionError ["S2IT0012",['")count"]]
-  key="of" =>
-    ["of",:[hn y for y in l]] where
-      hn x ==
-        atom x and not UPPER_-CASE_-P (STRINGIMAGE x).(0) =>
-          isDomainOrPackage EVAL x => x
-          stackTraceOptionError ["S2IT0013",[x]]
-        g:= domainToGenvar x => g
-        stackTraceOptionError ["S2IT0013",[x]]
-  MEMQ(key,'(local ops vars)) =>
-    null l or l is ["all"] => [key,:"all"]
-    isListOfIdentifiersOrStrings l => x
-    stackTraceOptionError ["S2IT0015",[STRCONC('")",object2String key)]]
-  key='varbreak =>
-    null l or l is ["all"] => ["varbreak",:"all"]
-    isListOfIdentifiers l => x
-    stackTraceOptionError ["S2IT0016",[STRCONC('")",object2String key)]]
-  key='mathprint =>
-    null l => x
-    stackTraceOptionError ["S2IT0009",[STRCONC('")",object2String key)]]
-  key => throwKeyedMsg("S2IT0005",[key])
-
-traceOptionError(opt,keys) ==
-  null keys => stackTraceOptionError ["S2IT0007",[opt]]
-  commandAmbiguityError("trace option",opt,keys)
-
-resetTimers () ==
-  for timer in _/TIMERLIST repeat
-    SET(INTERN STRCONC(timer,'"_,TIMER"),0)
-
-resetSpacers () ==
-  for spacer in _/SPACELIST repeat
-    SET(INTERN STRCONC(spacer,'"_,SPACE"),0)
-
-resetCounters () ==
-  for k in _/COUNTLIST repeat
-    SET(INTERN STRCONC(k,'"_,COUNT"),0)
-
-ptimers() ==
-  null _/TIMERLIST => sayBrightly '"   no functions are timed"
-  for timer in _/TIMERLIST repeat
-    sayBrightly ["  ",:bright timer,'_:,'" ",
-      EVAL(INTERN STRCONC(timer,'"_,TIMER")) / float $timerTicksPerSecond,'" sec."]
-
-pspacers() ==
-  null _/SPACELIST => sayBrightly '"   no functions have space monitored"
-  for spacer in _/SPACELIST repeat
-    sayBrightly ["  ",:bright spacer,'_:,'" ",
-      EVAL INTERN STRCONC(spacer,'"_,SPACE"),'" bytes"]
-
-pcounters() ==
-  null _/COUNTLIST => sayBrightly '"   no functions are being counted"
-  for k in _/COUNTLIST repeat
-    sayBrightly ["  ",:bright k,'_:,'" ",
-      EVAL INTERN STRCONC(k,'"_,COUNT"),'" times"]
-
-transOnlyOption l ==
-  l is [n,:y] =>
-    FIXP n => [n,:transOnlyOption y]
-    MEMQ(n:= UPCASE n,'(V A C)) => [n,:transOnlyOption y]
-    stackTraceOptionError ["S2IT0006",[n]]
-    transOnlyOption y
-  nil
-
-stackTraceOptionError x ==
-  $traceErrorStack:= [x,:$traceErrorStack]
-  nil
-
-removeOption(op,options) ==
-  [optEntry for (optEntry:=[opt,:.]) in options | opt ^= op]
-
-domainToGenvar x ==
-  $doNotAddEmptyModeIfTrue: local:= true
-  (y:= unabbrevAndLoad x) and GETDATABASE(opOf y,'CONSTRUCTORKIND) = 'domain =>
-    g:= genDomainTraceName y
-    SET(g,evalDomain y)
-    g
-
-genDomainTraceName y ==
-  u:= LASSOC(y,$domainTraceNameAssoc) => u
-  g:= GENVAR()
-  $domainTraceNameAssoc:= [[y,:g],:$domainTraceNameAssoc]
-  g
-
---this is now called from trace with the )off option
-untrace l ==
-  $lastUntraced:=
-    null l => COPY _/TRACENAMES
-    l
-  untraceList:= [transTraceItem x for x in l]
-  _/UNTRACE_,0 [lassocSub(funName,$mapSubNameAlist) for
-      funName in untraceList]
-  removeTracedMapSigs untraceList
-
-transTraceItem x ==
-  $doNotAddEmptyModeIfTrue: local:=true
-  atom x =>
-    (value:=get(x,"value",$InteractiveFrame)) and
-      (objMode value in '((Mode) (Domain) (SubDomain (Domain)))) =>
-        x := objVal value
-        (y:= domainToGenvar x) => y
-        x
-    UPPER_-CASE_-P (STRINGIMAGE x).(0) =>
-      y := unabbrev x
-      constructor?(y) => y
-      PAIRP(y) and constructor?(CAR y) => CAR y
-      (y:= domainToGenvar x) => y
-      x
-    x
-  VECP first x => transTraceItem devaluate first x
-  y:= domainToGenvar x => y
-  throwKeyedMsg("S2IT0018",[x])
-
-removeTracedMapSigs untraceList ==
-  for name in untraceList repeat
-    REMPROP(name,$tracedMapSignatures)
-
-coerceTraceArgs2E(traceName,subName,args) ==
-  MEMQ(name:= subName,$mathTraceList) =>
-    SPADSYSNAMEP PNAME name => coerceSpadArgs2E(reverse CDR reverse args)
-    [["=",name,objValUnwrap coerceInteractive(objNewWrap(arg,type),$OutputForm)]
-      for name in '(arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15 arg16 arg17 arg18 arg19 )
-       for arg in args for type in CDR LASSOC(subName,
-        $tracedMapSignatures)]
-  SPADSYSNAMEP PNAME name => reverse CDR reverse args
-  args
-
-coerceSpadArgs2E(args) ==
-  -- following binding is to prevent forcing calculation of stream elements
-  $streamCount:local := 0
-  [["=",name,objValUnwrap coerceInteractive(objNewWrap(arg,type),$OutputForm)]
-      for name in '(arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15 arg16 arg17 arg18 arg19 )
-        for arg in args for type in CDR $tracedSpadModemap]
-
-subTypes(mm,sublist) ==
-  ATOM mm =>
-    (s:= LASSOC(mm,sublist)) => s
-    mm
-  [subTypes(m,sublist) for m in mm]
-
-coerceTraceFunValue2E(traceName,subName,value) ==
-  MEMQ(name:= subName,$mathTraceList) =>
-    SPADSYSNAMEP PNAME traceName => coerceSpadFunValue2E(value)
-    (u:=LASSOC(subName,$tracedMapSignatures)) =>
-      objValUnwrap coerceInteractive(objNewWrap(value,CAR u),$OutputForm)
-    value
-  value
-
-coerceSpadFunValue2E(value) ==
-  -- following binding is to prevent forcing calculation of stream elements
-  $streamCount:local := 0
-  objValUnwrap coerceInteractive(objNewWrap(value,CAR $tracedSpadModemap),
-    $OutputForm)
-
-isListOfIdentifiers l == and/[IDENTP x for x in l]
-
-isListOfIdentifiersOrStrings l == and/[IDENTP x or STRINGP x for x in l]
-
-getMapSubNames(l) ==
-  subs:= nil
-  for mapName in l repeat
-    lmm:= get(mapName,'localModemap,$InteractiveFrame) =>
-      subs:= APPEND([[mapName,:CADR mm] for mm in lmm],subs)
-  UNION(subs,getPreviousMapSubNames UNIONQ(_/TRACENAMES,
-    $lastUntraced))
-
-getPreviousMapSubNames(traceNames) ==
-  subs:= nil
-  for mapName in ASSOCLEFT CAAR $InteractiveFrame repeat
-    lmm:= get(mapName,'localModemap,$InteractiveFrame) =>
-      MEMQ(CADAR lmm,traceNames) =>
-        for mm in lmm repeat
-          subs:= [[mapName,:CADR mm],:subs]
-  subs
-
-lassocSub(x,subs)  ==
-  y:= LASSQ(x,subs) => y
-  x
-
-rassocSub(x,subs) ==
-  y:= RASSOC(x,subs) => y
-  x
-
-isUncompiledMap(x) ==
-  y:= get(x,'value,$InteractiveFrame) =>
-    (CAAR y) = 'MAP and null get(x,'localModemap,$InteractiveFrame)
-
-isInterpOnlyMap(map) ==
-  x:= get(map,'localModemap,$InteractiveFrame) =>
-    (CAAAR x) = 'interpOnly
-
-augmentTraceNames(l,mapSubNames) ==
-  res:= nil
-  for traceName in l repeat
-    mml:= get(traceName,'localModemap,$InteractiveFrame) =>
-      res:= APPEND([CADR mm for mm in mml],res)
-    res:= [traceName,:res]
-  res
-
-isSubForRedundantMapName(subName) ==
-  mapName:= rassocSub(subName,$mapSubNameAlist) =>
-    tail:=MEMBER([mapName,:subName],$mapSubNameAlist) =>
-      MEMQ(mapName,CDR ASSOCLEFT tail)
-
-untraceMapSubNames traceNames ==
-  null($mapSubNameAlist:local:= getPreviousMapSubNames traceNames) => nil
-  for name in (subs:= ASSOCRIGHT $mapSubNameAlist)
-    | MEMQ(name,_/TRACENAMES) repeat
-      _/UNTRACE_,2(name,nil)
-      $lastUntraced:= SETDIFFERENCE($lastUntraced,subs)
-
-funfind("functor","opname") ==
-  ops:= isFunctor functor
-  [u for u in ops | u is [[ =opname,:.],:.]]
-
-isDomainOrPackage dom ==
-  REFVECP dom and #dom>0 and isFunctor opOf dom.(0)
-
-isTraceGensym x == GENSYMP x
-
-spadTrace(domain,options) ==
-  $fromSpadTrace:= true
-  $tracedModemap:local:= nil
-  PAIRP domain and REFVECP CAR domain and (CAR domain).0 = 0 =>
-      aldorTrace(domain,options)
-  not isDomainOrPackage domain => userError '"bad argument to trace"
-  listOfOperations:=
-    [g x for x in getOption("OPS",options)] where
-      g x ==
-        STRINGP x => INTERN x
-        x
-  if listOfVariables := getOption("VARS",options) then
-    options := removeOption("VARS",options)
-  if listOfBreakVars := getOption("VARBREAK",options) then
-    options := removeOption("VARBREAK",options)
-  anyifTrue:= null listOfOperations
-  domainId:= opOf domain.(0)
-  currentEntry:= ASSOC(domain,_/TRACENAMES)
-  currentAlist:= KDR currentEntry
-  opStructureList:= flattenOperationAlist getOperationAlistFromLisplib domainId
-  sigSlotNumberAlist:=
-    [triple
-      --new form is (<op> <signature> <slotNumber> <condition> <kind>)
-      for [op,sig,n,.,kind] in opStructureList | kind = 'ELT
-        and (anyifTrue or MEMQ(op,listOfOperations)) and
-         FIXP n and
-          isTraceable(triple:= [op,sig,n],domain)] where
-            isTraceable(x is [.,.,n,:.],domain) ==
-              atom domain.n => nil
-              functionSlot:= first domain.n
-              GENSYMP functionSlot =>
-                (reportSpadTrace("Already Traced",x); nil)
-              null (BPINAME functionSlot) =>
-                (reportSpadTrace("No function for",x); nil)
-              true
-  if listOfVariables then
-    for [.,.,n] in sigSlotNumberAlist repeat
-      fn := first domain.n
-      $letAssoc := AS_-INSERT(BPINAME fn,
-        listOfVariables,$letAssoc)
-  if listOfBreakVars then
-    for [.,.,n] in sigSlotNumberAlist repeat
-      fn := first domain.n
-      $letAssoc := AS_-INSERT(BPINAME fn,
-        [["BREAK",:listOfBreakVars]],$letAssoc)
-  for (pair:= [op,mm,n]) in sigSlotNumberAlist repeat
-    alias:= spadTraceAlias(domainId,op,n)
-    $tracedModemap:= subTypes(mm,constructSubst(domain.0))
-    traceName:= BPITRACE(first domain.n,alias, options)
-    NCONC(pair,[listOfVariables,first domain.n,traceName,alias])
-    RPLAC(first domain.n,traceName)
-  sigSlotNumberAlist:= [x for x in sigSlotNumberAlist | CDDDR x]
-  if $reportSpadTrace then
-    if $traceNoisely then printDashedLine()
-    for x in orderBySlotNumber sigSlotNumberAlist repeat
-      reportSpadTrace("TRACING",x)
-  if $letAssoc then SETLETPRINTFLAG true
-  currentEntry =>
-    RPLAC(rest currentEntry,[:sigSlotNumberAlist,:currentAlist])
-  SETQ(_/TRACENAMES,[[domain,:sigSlotNumberAlist],:_/TRACENAMES])
-  spadReply()
-
-traceDomainLocalOps(dom,lops,options) ==
- sayMSG ['"  ",'"The )local option has been withdrawn"]
- sayMSG ['"  ",'"Use )ltr to trace local functions."]
- NIL
---  abb := abbreviate dom
---  loadLibIfNotLoaded abb
---  actualLops := getLocalOpsFromLisplib abb
---  null actualLops =>
---    sayMSG ['"  ",:bright abb,'"has no local functions to trace."]
---  lops = 'all => _/TRACE_,1(actualLops,options)
---  l := NIL
---  for lop in lops repeat
---    internalName := INTERN STRCONC(PNAME abb,'";",PNAME lop)
---    not MEMQ(internalName,actualLops) =>
---      sayMSG ['"  ",:bright abb,'"does not have a local",
---        '" function called",:bright lop]
---    l := cons(internalName,l)
---  l => _/TRACE_,1(l,options)
---  nil
-
-untraceDomainLocalOps(dom,lops) ==
- sayMSG ['"  ",:bright abb,'"has no local functions to untrace."]
- NIL
---  lops = "all" => untraceAllDomainLocalOps(dom)
---  abb := abbreviate dom
---  loadLibIfNotLoaded abb
---  actualLops := getLocalOpsFromLisplib abb
---  null actualLops =>
---    sayMSG ['"  ",:bright abb,'"has no local functions to untrace."]
---  l := NIL
---  for lop in lops repeat
---    internalName := INTERN STRCONC(PNAME abb,'";",PNAME lop)
---    not MEMQ(internalName,actualLops) =>
---      sayMSG ['"  ",:bright abb,'"does not have a local",
---        '" function called",:bright lop]
---    l := cons(internalName,l)
---  l => untrace l
---  nil
-
-untraceAllDomainLocalOps(dom) == NIL
---  abb := abbreviate dom
---  actualLops := getLocalOpsFromLisplib abb
---  null (l := INTERSECTION(actualLops,_/TRACENAMES)) => NIL
---  _/UNTRACE_,1(l,NIL)
---  NIL
-
-traceDomainConstructor(domainConstructor,options) ==
-  -- Trace all domains built with the given domain constructor,
-  -- including all presently instantiated domains, and all future
-  -- instantiations, while domain constructor is traced.
-  loadFunctor domainConstructor
-  listOfLocalOps := getOption("LOCAL",options)
-  if listOfLocalOps then
-    traceDomainLocalOps(domainConstructor,listOfLocalOps,
-      [opt for opt in options | opt isnt ['LOCAL,:.]])
-  listOfLocalOps and not getOption("OPS",options) => NIL
-  for [argl,.,:domain] in HGET($ConstructorCache,domainConstructor)
-    repeat spadTrace(domain,options)
-  SETQ(_/TRACENAMES,[domainConstructor,:_/TRACENAMES])
-  innerDomainConstructor := INTERN STRCONC(domainConstructor,'";")
-  if FBOUNDP innerDomainConstructor then domainConstructor := innerDomainConstructor
-  EMBED(domainConstructor,
-    ['LAMBDA, ['_&REST, 'args],
-      ['PROG, ['domain],
-        ['SETQ,'domain,['APPLY,domainConstructor,'args]],
-        ['spadTrace,'domain,MKQ options],
-        ['RETURN,'domain]]] )
-
-untraceDomainConstructor domainConstructor ==
-  --untrace all the domains in domainConstructor, and unembed it
-  SETQ(_/TRACENAMES, 
-    [df for df in _/TRACENAMES | keepTraced?(df, domainConstructor)]) where 
-      keepTraced?(df, domainConstructor) ==
-        (df is [dc,:.]) and (isDomainOrPackage dc) and 
-           ((KAR devaluate dc) = domainConstructor) =>
-               _/UNTRACE_,0 [dc]
-               false
-        true
-  untraceAllDomainLocalOps domainConstructor
-  innerDomainConstructor := INTERN STRCONC(domainConstructor,'";")
-  if FBOUNDP innerDomainConstructor then UNEMBED innerDomainConstructor
-    else UNEMBED domainConstructor
-  SETQ(_/TRACENAMES,DELETE(domainConstructor,_/TRACENAMES))
-
-flattenOperationAlist(opAlist) ==
-   res:= nil
-   for [op,:mmList] in opAlist repeat
-     res:=[:res,:[[op,:mm] for mm in mmList]]
-   res
-
-mapLetPrint(x,val,currentFunction) ==
-  x:= getAliasIfTracedMapParameter(x,currentFunction)
-  currentFunction:= getBpiNameIfTracedMap currentFunction
-  letPrint(x,val,currentFunction)
-
--- This is the version for use when we have no idea
--- what print representation to use for the data object
-
-letPrint(x,val,currentFunction) ==
-  if $letAssoc and
-    ((y:= LASSOC(currentFunction,$letAssoc)) or (y:= LASSOC("all",$letAssoc))) then
-      if (y="all" or MEMQ(x,y)) and
-        not (IS__GENVAR(x) or isSharpVarWithNum(x) or GENSYMP x) then
-         sayBrightlyNT [:bright x,": "]
-         PRIN0 shortenForPrinting val
-         TERPRI()
-      if (y:= hasPair("BREAK",y)) and
-        (y="all" or MEMQ(x,y) and
-          (not MEMQ((PNAME x).(0),'($ _#)) and not GENSYMP x)) then
-            break [:bright currentFunction,'"breaks after",:bright x,'":= ",
-              shortenForPrinting val]
-  val
-
--- This is the version for use when we have already
--- converted the data into type "Expression"
-letPrint2(x,printform,currentFunction) ==
-  $BreakMode:local := nil
-  if $letAssoc and
-    ((y:= LASSOC(currentFunction,$letAssoc)) or (y:= LASSOC("all",$letAssoc))) then
-      if (y="all" or MEMQ(x,y)) and
-        not (IS__GENVAR(x) or isSharpVarWithNum(x) or GENSYMP x) then
-         $BreakMode:='letPrint2
-         flag:=nil
-         CATCH('letPrint2,mathprint ["=",x,printform],flag)
-         if flag='letPrint2 then print printform
-      if (y:= hasPair("BREAK",y)) and
-        (y="all" or MEMQ(x,y) and
-          (not MEMQ((PNAME x).(0),'($ _#)) and not GENSYMP x)) then
-            break [:bright currentFunction,'"breaks after",:bright x,":= ",
-              printform]
-  x
-
--- This is the version for use when we have our hands on a function
--- to convert the data into type "Expression"
-
-letPrint3(x,xval,printfn,currentFunction) ==
-  $BreakMode:local := nil
-  if $letAssoc and
-    ((y:= LASSOC(currentFunction,$letAssoc)) or (y:= LASSOC("all",$letAssoc))) then
-      if (y="all" or MEMQ(x,y)) and
-        not (IS__GENVAR(x) or isSharpVarWithNum(x) or GENSYMP x) then
-         $BreakMode:='letPrint2
-         flag:=nil
-         CATCH('letPrint2,mathprint ["=",x,SPADCALL(xval,printfn)],flag)
-         if flag='letPrint2 then print xval
-      if (y:= hasPair("BREAK",y)) and
-        (y="all" or MEMQ(x,y) and
-          (not MEMQ((PNAME x).(0),'($ _#)) and not GENSYMP x)) then
-            break [:bright currentFunction,'"breaks after",:bright x,'":= ",
-              xval]
-  x
-
-getAliasIfTracedMapParameter(x,currentFunction) ==
-  isSharpVarWithNum x =>
-    aliasList:= get(currentFunction,'alias,$InteractiveFrame) =>
-      aliasList.(STRING2PINT_-N(SUBSTRING(PNAME x,1,NIL),1)-1)
-  x
-
-getBpiNameIfTracedMap(name) ==
-  lmm:= get(name,'localModemap,$InteractiveFrame) =>
-    MEMQ(bpiName:= CADAR lmm,_/TRACENAMES) => bpiName
-  name
-
-hasPair(key,l) ==
-  atom l => nil
-  l is [[ =key,:a],:.] => a
-  hasPair(key,rest l)
-
-shortenForPrinting val ==
-  isDomainOrPackage val => devaluate val
-  val
-
-spadTraceAlias(domainId,op,n) ==
-  INTERNL(domainId,".",op,",",STRINGIMAGE n)
-
-getOption(opt,l) ==
-  y:= ASSOC(opt,l) => rest y
-
-reportSpadTrace(header,[op,sig,n,:t]) ==
-  null $traceNoisely => nil
-  msg:= [header,'%b,op,":",'%d,rest sig," -> ",first sig," in slot ",n]
-  namePart:= nil --(t is (.,.,name,:.) => (" named ",name); NIL)
-  tracePart:=
-    t is [y,:.] and not null y =>
-      (y="all" => ['%b,"all",'%d,"vars"]; [" vars: ",y])
-    NIL
-  sayBrightly [:msg,:namePart,:tracePart]
-
-orderBySlotNumber l ==
-  ASSOCRIGHT orderList [[n,:x] for (x:= [.,.,n,:.]) in l]
-
-_/TRACEREPLY() ==
-  null _/TRACENAMES => MAKESTRING '"   Nothing is traced."
-  for x in _/TRACENAMES repeat
-    x is [d,:.] and isDomainOrPackage d =>
-      domainList:= [devaluate d,:domainList]
-    functionList:= [x,:functionList]
-  [:functionList,:domainList,"traced"]
-
-spadReply() ==
-  [printName x for x in _/TRACENAMES] where
-    printName x ==
-      x is [d,:.] and isDomainOrPackage d => devaluate d
-      x
-
-spadUntrace(domain,options) ==
-  not isDomainOrPackage domain => userError '"bad argument to untrace"
-  anyifTrue:= null options
-  listOfOperations:= getOption("ops:",options)
-  domainId := devaluate domain
-  null (pair:= ASSOC(domain,_/TRACENAMES)) =>
-    sayMSG ['"   No functions in",
-      :bright prefix2String domainId,'"are now traced."]
-  sigSlotNumberAlist:= rest pair
-  for (pair:= [op,sig,n,lv,bpiPointer,traceName,alias]) in sigSlotNumberAlist |
-    anyifTrue or MEMQ(op,listOfOperations) repeat
-      BPIUNTRACE(traceName,alias)
-      RPLAC(first domain.n,bpiPointer)
-      RPLAC(CDDDR pair,nil)
-      if assocPair:=ASSOC(BPINAME bpiPointer,$letAssoc) then
-        $letAssoc := REMOVER($letAssoc,assocPair)
-        if null $letAssoc then SETLETPRINTFLAG nil
-  newSigSlotNumberAlist:= [x for x in sigSlotNumberAlist | CDDDR x]
-  newSigSlotNumberAlist => RPLAC(rest pair,newSigSlotNumberAlist)
-  SETQ(_/TRACENAMES,DELASC(domain,_/TRACENAMES))
-  spadReply()
-
-prTraceNames() ==
-  (for x in _/TRACENAMES repeat PRINT fn x; nil) where
-    fn x ==
-      x is [d,:t] and isDomainOrPackage d => [devaluate d,:t]
-      x
-
-traceReply() ==
-  $domains: local:= nil
-  $packages: local:= nil
-  $constructors: local:= nil
-  null _/TRACENAMES =>
-    sayMessage '"   Nothing is traced now."
-  sayBrightly '" "
-  for x in _/TRACENAMES repeat
-    x is [d,:.] and (isDomainOrPackage d) => addTraceItem d
-    atom x =>
-      isFunctor x => addTraceItem x
-      (IS__GENVAR x =>
-        addTraceItem EVAL x; functionList:= [x,:functionList])
-    userError '"bad argument to trace"
-  functionList:= "append"/[[rassocSub(x,$mapSubNameAlist),'" "]
-    for x in functionList | ^isSubForRedundantMapName x]
-  if functionList then
-    2 = #functionList =>
-      sayMSG ["   Function traced: ",:functionList]
-    (22 + sayBrightlyLength functionList) <= $LINELENGTH =>
-      sayMSG ["   Functions traced: ",:functionList]
-    sayBrightly "   Functions traced:"
-    sayBrightly flowSegmentedMsg(functionList,$LINELENGTH,6)
-  if $domains then
-    displayList:= concat(prefix2String first $domains,
-          [:concat('",",'" ",prefix2String x) for x in rest $domains])
-    if atom displayList then displayList:= [displayList]
-    sayBrightly '"   Domains traced: "
-    sayBrightly flowSegmentedMsg(displayList,$LINELENGTH,6)
-  if $packages then
-    displayList:= concat(prefix2String first $packages,
-          [:concat(", ",prefix2String x) for x in rest $packages])
-    if atom displayList then displayList:= [displayList]
-    sayBrightly '"   Packages traced: "
-    sayBrightly flowSegmentedMsg(displayList,$LINELENGTH,6)
-  if $constructors then
-    displayList:= concat(abbreviate first $constructors,
-          [:concat(", ",abbreviate x) for x in rest $constructors])
-    if atom displayList then displayList:= [displayList]
-    sayBrightly '"   Parameterized constructors traced:"
-    sayBrightly flowSegmentedMsg(displayList,$LINELENGTH,6)
-
-addTraceItem d ==
-  constructor? d => $constructors:=[d,:$constructors]
-  isDomain d => $domains:= [devaluate d,:$domains]
-  isDomainOrPackage d => $packages:= [devaluate d,:$packages]
-
-_?t() ==
-  null _/TRACENAMES => sayMSG bright '"nothing is traced"
-  for x in _/TRACENAMES | atom x and not IS__GENVAR x repeat
-    if llm:= get(x,'localModemap,$InteractiveFrame) then
-      x:= (LIST (CADAR llm))
-    sayMSG ['"Function",:bright rassocSub(x,$mapSubNameAlist),'"traced"]
-  for x in _/TRACENAMES | x is [d,:l] and isDomainOrPackage d repeat
-    suffix:=
-      isDomain d => '"domain"
-      '"package"
-    sayBrightly ['"   Functions traced in ",suffix,'%b,devaluate d,'%d,":"]
-    for x in orderBySlotNumber l repeat reportSpadTrace("   ",take(4,x))
-    TERPRI()
-
-tracelet(fn,vars) ==
-  if GENSYMP fn and stupidIsSpadFunction EVAL fn then
-    fn := EVAL fn
-    if COMPILED_-FUNCTION_-P fn then fn:=BPINAME fn
-  fn = 'Undef => nil
-  vars:=
-    vars="all" => "all"
-    l:= LASSOC(fn,$letAssoc) => UNION(vars,l)
-    vars
-  $letAssoc:= [[fn,:vars],:$letAssoc]
-  if $letAssoc then SETLETPRINTFLAG true
-  $TRACELETFLAG : local := true
-  $QuickLet : local := false
-  ^MEMQ(fn,$traceletFunctions) and ^IS__GENVAR fn and COMPILED_-FUNCTION_-P SYMBOL_-FUNCTION fn
-    and not stupidIsSpadFunction fn and not GENSYMP fn =>
-      ($traceletFunctions:= [fn,:$traceletFunctions]; compileBoot fn ;
-       $traceletFunctions:= DELETE(fn,$traceletFunctions) )
-
-breaklet(fn,vars) ==
-                       --vars is "all" or a list of variables
-  --$letAssoc ==> (.. (=fn .. (BREAK . all))) OR (.. (=fn .. (BREAK . vl)))
-  if GENSYMP fn and stupidIsSpadFunction EVAL fn then
-    fn := EVAL fn
-    if COMPILED_-FUNCTION_-P fn then fn:= BPINAME fn
-  fn = "Undef" => nil
-  fnEntry:= LASSOC(fn,$letAssoc)
-  vars:=
-    pair:= ASSOC("BREAK",fnEntry) => UNION(vars,rest pair)
-    vars
-  $letAssoc:=
-    null fnEntry => [[fn,:LIST ["BREAK",:vars]],:$letAssoc]
-    pair => (RPLACD(pair,vars); $letAssoc)
-  if $letAssoc then SETLETPRINTFLAG true
-  $QuickLet:local := false
-  ^MEMQ(fn,$traceletFunctions) and not stupidIsSpadFunction fn
-    and not GENSYMP fn =>
-      $traceletFunctions:= [fn,:$traceletFunctions]
-      compileBoot fn
-      $traceletFunctions:= DELETE(fn,$traceletFunctions)
-
-stupidIsSpadFunction fn ==
-  -- returns true if the function pname has a semi-colon in it
-  -- eventually, this will use isSpadFunction from luke boot
-  STRPOS('"_;",PNAME fn,0,NIL)
-
-break msg ==
-  condition:= MONITOR_,EVALTRAN(_/BREAKCONDITION,nil)
-  -- The next line is to try to deal with some reported cases of unwanted
-  -- backtraces appearing, MCD.
-  ENABLE_-BACKTRACE(nil)
-  EVAL condition =>
-    sayBrightly msg
-    INTERRUPT()
-
-compileBoot fn == _/D_,1(LIST fn,'(_/COMP),nil,nil)
-
-@
-\eject
-\begin{thebibliography}{99}
-\bibitem{1} nothing
-\end{thebibliography}
-\end{document}



From MAILER-DAEMON Sun Mar 08 10:24:09 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LgJvF-0006S7-H1
	for mharc-axiom-developer@gnu.org; Sun, 08 Mar 2009 10:24:09 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LgJvC-0006QV-Ro
	for axiom-developer@nongnu.org; Sun, 08 Mar 2009 10:24:06 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LgJvB-0006Py-Jr
	for axiom-developer@nongnu.org; Sun, 08 Mar 2009 10:24:06 -0400
Received: from [199.232.76.173] (port=50888 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LgJvB-0006Pt-FZ
	for axiom-developer@nongnu.org; Sun, 08 Mar 2009 10:24:05 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:41982
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LgJv5-0002XX-UR
	for axiom-developer@nongnu.org; Sun, 08 Mar 2009 10:24:05 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n28ENnug009539;
	Sun, 8 Mar 2009 08:23:49 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n28ENnZf009532;
	Sun, 8 Mar 2009 08:23:49 -0600
Date: Sun, 8 Mar 2009 08:23:49 -0600
Message-Id: <200903081423.n28ENnZf009532@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090308.01.tpd.patch (bookvol5 add include,
	abbreviation roots)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sun, 08 Mar 2009 14:24:07 -0000

It turns out that )include is nowhere documented. This has been fixed
by adding it in the Jenks book as well as the interpreter book.

Add )abbreviation code from i-syscmd.boot and clean it up a bit

=======================================================================
diff --git a/books/bookvol0.pamphlet b/books/bookvol0.pamphlet
index caca555..fa734b8 100644
--- a/books/bookvol0.pamphlet
+++ b/books/bookvol0.pamphlet
@@ -61193,14 +61193,10 @@ and in HyperDoc.
 In HyperDoc, choose the {\bf Commands} item from the
 {\bf Reference} menu.
 
-
-
 \section{)history}
 \index{ugSysCmdhistory}
-
 \index{history}
 
-
 \par\noindent{\bf User Level Required:} interpreter
 
 \par\noindent{\bf Command Syntax:}
@@ -61383,12 +61379,28 @@ the contents.
 {\tt )undo} \index{ugSysCmdundo}.
 
 
+\section{)include}
+\index{ugSysCmdinclude}
+\index{include}
+
+\par\noindent{\bf User Level Required:} interpreter
+
+\par\noindent{\bf Command Syntax:}
+\begin{list}{}
+\item{\tt )include {\it filename}}
+\end{list}
+
+\par\noindent{\bf Command Description:}
+
+The \verb|)include| command can be used in \verb|.input| files
+to place the contents of another file inline with the current file.
+The path can be an absolute or relative pathname.
+
+
 \section{)library}
 \index{ugSysCmdlibrary}
-
 \index{library}
 
-
 \par\noindent{\bf User Level Required:} interpreter
 
 \par\noindent{\bf Command Syntax:}
diff --git a/books/bookvol5.pamphlet b/books/bookvol5.pamphlet
index 8b2dfe0..ba91b7b 100644
--- a/books/bookvol5.pamphlet
+++ b/books/bookvol5.pamphlet
@@ -466,6 +466,10 @@ suppressed and input does not use piles. If this is true then the
 library loading routines might output messages and piles are expected
 on input (as from a file).
 \end{list}
+The system commands are handled by the function kept in the ``hook''
+variable \verb|$systemCommandFunction| which
+has the default function \verb|InterpExecuteSpadSystemCommand|.
+Thus, when a system command is entered this function is called.
 <<defun SpadInterpretStream>>=
 (defun |SpadInterpretStream| (str source interactive?) 
  (prog (|$promptMsg| |$shoeReadLineFunction| |$systemCommandFunction| 
@@ -998,6 +1002,14 @@ during a session are pushed onto this list for later lookup.
 \subsection{defun ncloopCommand}
 The \$systemCommandFunction is set in SpadInterpretStream
 to point to the function InterpExecuteSpadSystemCommand.
+The system commands are handled by the function kept in the ``hook''
+variable \verb|$systemCommandFunction| which
+has the default function \verb|InterpExecuteSpadSystemCommand|.
+Thus, when a system command is entered this function is called.
+
+The only exception is the \verb|)include| function which inserts
+the contents of a file inline in the input stream. This is useful
+for processing \verb|)read| of input files.
 <<defun ncloopCommand>>=
 (defun |ncloopCommand| (line n)
  (declare (special |$systemCommandFunction|))
@@ -1019,61 +1031,6 @@ we return the remainder of the string without the leading prefix.
   (subseq whole (length prefix))))
 
 @
-\subsection{defun ncloopInclude1}
-<<defun ncloopInclude1>>=
-(defun |ncloopInclude1| (name n)
- (let (a)
-  (if (setq a (|ncloopIncFileName| name))
-    (|ncloopInclude| a n)
-    n)))
-
-@
-\subsection{defun ncloopIncFileName}
-Returns the first non-blank substring of the given string.
-<<defun ncloopIncFileName>>=
-(defun |ncloopIncFileName| (string)
- (let (fn)
-  (unless (setq fn (|incFileName| string))
-   (write-line (concat string " not found")))
- fn))
-
-@
-
-\subsection{defun ncloopInclude}
-Open the file and read it in. The ncloopInclude0 function is part
-of the parser and lives in int-top.boot.
-<<defun ncloopInclude>>=
-(defun |ncloopInclude| (name n)
-  (with-open-file (st name) (|ncloopInclude0| st name n)))
-
-@
-
-\subsection{defun incFileName}
-Given a string we return the first token from the string which is
-the first non-blank substring.
-<<defun incFileName>>=
-(defun |incFileName| (x)
-  (car (|incBiteOff| x)))
-
-@
-
-\subsection{defun incBiteOff}
-Takes a sequence and returns the a list of the first token and the
-remaining string characters. If there are no remaining string characters
-the second string is of length 0. Effectively it "bites off" the first 
-token in the string. If the string only 0 or more blanks it returns nil.
-<<defun incBiteOff>>=
-(defun |incBiteOff| (x)
- (let (blank nonblank)
-  (setq x (string x))
-  (when (setq nonblank (position #\space x :test-not #'char=))
-    (setq blank (position #\space x :start nonblank))
-    (if blank
-     (list (subseq x nonblank blank) (subseq x blank))
-     (list (subseq x nonblank) "")))))
-
-@
-
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{abbreviations}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@@ -1164,6 +1121,133 @@ constructor name {\tt VectorFunctions2} from the system:
 )abbreviation remove VectorFunctions2
 \end{verbatim}
 
+\subsection{defun abbreviations}
+<<defun abbreviations>>=
+(defun |abbreviations| (l)
+ (|abbreviationsSpad2Cmd| l)) 
+
+@
+\subsection{defun abbreviationsSpad2Cmd}
+\begin{verbatim}
+;abbreviationsSpad2Cmd l ==
+;  null l => helpSpad2Cmd '(abbreviations)
+;  abopts := '(query domain category package remove)
+;  quiet := nil
+;  for [opt] in $options repeat
+;    opt := selectOptionLC(opt,'(quiet),'optionError)
+;    opt = 'quiet => quiet := true
+;  l is [opt,:al] =>
+;    key := opOf CAR al
+;    type := selectOptionLC(opt,abopts,'optionError)
+;    type is 'query =>
+;      null al => listConstructorAbbreviations()
+;      constructor := abbreviation?(key) => abbQuery(constructor)
+;      abbQuery(key)
+;    type is 'remove =>
+;      DELDATABASE(key,'ABBREVIATION)
+;    ODDP SIZE al => sayKeyedMsg("S2IZ0002",[type])
+;    repeat
+;      null al => return 'fromLoop
+;      [a,b,:al] := al
+;      mkUserConstructorAbbreviation(b,a,type)
+;      SETDATABASE(b,'ABBREVIATION,a)
+;      SETDATABASE(b,'CONSTRUCTORKIND,type)
+;    null quiet =>
+;      sayKeyedMsg("S2IZ0001",[a,type,opOf b])
+;      nil
+;  nil
+\end{verbatim}
+
+<<defun abbreviationsSpad2Cmd>>=
+(defun |abbreviationsSpad2Cmd| (arg)
+ (prog (abopts quiet opt key type constructor t2 a b al)
+  (return
+   (seq
+    (cond
+     ((null arg) (|helpSpad2Cmd| '(|abbreviations|)))
+     (t
+      (spadlet abopts '(|query| |domain| |category| |package| |remove|))
+      (spadlet quiet NIL)
+      (do ((t0 |$options| (cdr t0)) (t1 nil))
+          ((or (atom t0) 
+               (progn (setq t1 (car t0)) nil)
+               (progn (progn (spadlet opt (car t1)) t1) nil))
+            nil)
+       (seq
+        (exit
+         (progn
+          (spadlet opt
+           (|selectOptionLC| opt '(|quiet|) '|optionError|))
+          (cond ((boot-equal opt '|quiet|)
+            (spadlet quiet t)))))))
+      (cond
+       ((and (pairp arg) 
+             (progn 
+              (spadlet opt (qcar arg))
+              (spadlet al (qcdr arg))
+              t))
+         (spadlet key (|opOf| (car al)))
+         (spadlet type
+           (|selectOptionLC| opt abopts '|optionError|))
+         (cond
+          ((eq type '|query|)
+           (cond 
+            ((null al) (|listConstructorAbbreviations|))
+            ((spadlet constructor (|abbreviation?| key))
+              (|abbQuery| constructor))
+            (t (|abbQuery| key))))
+          ((eq type '|remove|)
+           (deldatabase key 'abbreviation))
+          ((oddp (size al))
+           (|sayKeyedMsg| 's2iz0002 (cons type nil)))
+          (t
+           (do () (nil nil)
+            (seq 
+             (exit 
+              (cond
+               ((null al) (return '|fromLoop|))
+               (t
+                 (spadlet t2 al)
+                 (spadlet a (CAR t2))
+                 (spadlet b (CADR t2))
+                 (spadlet al (CDDR t2))
+                 (|mkUserConstructorAbbreviation| b a type)
+                 (setdatabase b 'abbreviation a)
+                 (setdatabase b 'constructorkind type))))))
+           (cond ((null quiet)
+            (progn
+             (|sayKeyedMsg| 's2iz0001
+               (cons a (cons type (cons (|opOf| b) nil)))) nil))))))
+       (t nil)))))))) 
+
+@
+
+\subsection{defun listConstructorAbbreviations}
+\begin{verbatim}
+;listConstructorAbbreviations() ==
+;  x := UPCASE queryUserKeyedMsg("S2IZ0056",NIL)
+;  MEMQ(STRING2ID_-N(x,1),'(Y YES)) =>
+;    whatSpad2Cmd '(categories)
+;    whatSpad2Cmd '(domains)
+;    whatSpad2Cmd '(packages)
+;  sayKeyedMsg("S2IZ0057",NIL)
+\end{verbatim}
+
+<<defun listConstructorAbbreviations>>=
+(defun |listConstructorAbbreviations| ()
+ (prog (x)
+  (return
+   (progn
+    (spadlet x (upcase (|queryUserKeyedMsg| 's2iz0056 nil)))
+    (cond
+     ((memq (string2id-n x 1) '(Y YES))
+       (|whatSpad2Cmd| '(|categories|))
+       (|whatSpad2Cmd| '(|domains|))
+       (|whatSpad2Cmd| '(|packages|)))
+     (t
+       (|sayKeyedMsg| 's2iz0057 nil))))))) 
+
+@
 
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{boot}
@@ -5766,6 +5850,78 @@ S2IH0038
 @
 
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\cmdhead{include}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+\par\noindent{\bf User Level Required:} interpreter
+
+\par\noindent{\bf Command Syntax:}
+\begin{list}{}
+\item{\tt )include {\it filename}}
+\end{list}
+
+\par\noindent{\bf Command Description:}
+
+The \verb|)include| command can be used in \verb|.input| files
+to place the contents of another file inline with the current file.
+The path can be an absolute or relative pathname.
+
+\subsection{defun ncloopInclude1}
+<<defun ncloopInclude1>>=
+(defun |ncloopInclude1| (name n)
+ (let (a)
+  (if (setq a (|ncloopIncFileName| name))
+    (|ncloopInclude| a n)
+    n)))
+
+@
+\subsection{defun ncloopIncFileName}
+Returns the first non-blank substring of the given string.
+<<defun ncloopIncFileName>>=
+(defun |ncloopIncFileName| (string)
+ (let (fn)
+  (unless (setq fn (|incFileName| string))
+   (write-line (concat string " not found")))
+ fn))
+
+@
+
+\subsection{defun ncloopInclude}
+Open the file and read it in. The ncloopInclude0 function is part
+of the parser and lives in int-top.boot.
+<<defun ncloopInclude>>=
+(defun |ncloopInclude| (name n)
+  (with-open-file (st name) (|ncloopInclude0| st name n)))
+
+@
+
+\subsection{defun incFileName}
+Given a string we return the first token from the string which is
+the first non-blank substring.
+<<defun incFileName>>=
+(defun |incFileName| (x)
+  (car (|incBiteOff| x)))
+
+@
+
+\subsection{defun incBiteOff}
+Takes a sequence and returns the a list of the first token and the
+remaining string characters. If there are no remaining string characters
+the second string is of length 0. Effectively it "bites off" the first 
+token in the string. If the string only 0 or more blanks it returns nil.
+<<defun incBiteOff>>=
+(defun |incBiteOff| (x)
+ (let (blank nonblank)
+  (setq x (string x))
+  (when (setq nonblank (position #\space x :test-not #'char=))
+    (setq blank (position #\space x :start nonblank))
+    (if blank
+     (list (subseq x nonblank blank) (subseq x blank))
+     (list (subseq x nonblank) "")))))
+
+@
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{library}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
@@ -6762,8 +6918,8 @@ This reports the traced functions
 \end{verbatim}
 
 <<defun trace1>>=
-(defun |trace1| (|l|)
- (prog (|$traceNoisely| |constructor| |ops| |lops| temp1 |opt| |a| 
+(defun |trace1| (arg)
+ (prog (|$traceNoisely| constructor |ops| |lops| temp1 opt a 
         |oldL| |newOptions| |domain| |traceList| |optionList| |domainList| 
         |opList| |y| |varList| |argument|)
   (declare (special |$traceNoisely|))
@@ -6780,96 +6936,96 @@ This reports the traced functions
         ((or (spadlet |ops| (|hasOption| |$options| '|ops|))
              (spadlet |lops| (|hasOption| |$options| '|local|)))
           (cond
-           ((null |l|) (|throwKeyedMsg| 's2it0019 nil))
+           ((null arg) (|throwKeyedMsg| 's2it0019 nil))
            (t
-             (spadlet |constructor|
+             (spadlet constructor
               (|unabbrev|
                (cond
-                ((atom |l|) |l|)
-                ((null (cdr |l|))
+                ((atom arg) arg)
+                ((null (cdr arg))
                   (cond
-                   ((atom (car |l|)) (car |l|))
-                   (t (car (car |l|)))))
+                   ((atom (car arg)) (car arg))
+                   (t (car (car arg)))))
                 (t nil))))
              (cond
-              ((null (|isFunctor| |constructor|))
+              ((null (|isFunctor| constructor))
                 (|throwKeyedMsg| 's2it0020 nil))
               (t
                 (cond (|ops| (spadlet |ops| (|getTraceOption| |ops|)) nil))
                 (cond 
                  (|lops|
                   (spadlet |lops| (cdr (|getTraceOption| |lops|)))
-                  (|untraceDomainLocalOps| |constructor| |lops|))
+                  (|untraceDomainLocalOps| constructor |lops|))
                  (t nil)))))))
         ((and (qslessp 1 (|#| |$options|))
               (null (|hasOption| |$options| '|nonquietly|)))
           (|throwKeyedMsg| 's2it0021 nil))
-        (t (|untrace| |l|))))
+        (t (|untrace| arg))))
       ((|hasOption| |$options| '|stats|)
         (cond
          ((qslessp 1 (|#| |$options|))
           (|throwKeyedMsg| 's2it0001 (cons ")trace ... )stats" nil)))
          (t
            (spadlet temp1 (car |$options|))
-           (spadlet |opt| (cdr temp1))
+           (spadlet opt (cdr temp1))
            (cond
-            ((null |opt|)
+            ((null opt)
               (|centerAndHighlight| "Traced function execution times" 78 '-)
               (|ptimers|)
               (say " ")
               (|centerAndHighlight| "Traced function execution counts" 78 '-)
               (|pcounters|))
             (t
-              (|selectOptionLC| (car |opt|) '(|reset|) '|optionError|)
+              (|selectOptionLC| (car opt) '(|reset|) '|optionError|)
               (|resetSpacers|)
               (|resetTimers|)
               (|resetCounters|)
               (|throwKeyedMsg| 's2it0002 nil))))))
-      ((spadlet |a| (|hasOption| |$options| '|restore|))
+      ((spadlet a (|hasOption| |$options| '|restore|))
         (cond
          ((null (spadlet |oldL| |$lastUntraced|)) nil)
          (t
-           (spadlet |newOptions| (|delete| |a| |$options|))
+           (spadlet |newOptions| (|delete| a |$options|))
            (cond
-            ((null |l|) (|trace1| |oldL|))
+            ((null arg) (|trace1| |oldL|))
             (t
-             (do ((t0 |l| (cdr t0)) (|x|l nil))
-                 ((or (atom t0) (progn (setq |x| (car t0)) nil)) nil)
+             (do ((t0 arg (cdr t0)) (xl nil))
+                 ((or (atom t0) (progn (setq x (car t0)) nil)) nil)
               (seq
                (exit
                 (cond
-                 ((and (pairp |x|)
+                 ((and (pairp x)
                        (progn
-                        (spadlet |domain| (qcar |x|))
-                        (spadlet |opList| (qcdr |x|))
+                        (spadlet |domain| (qcar x))
+                        (spadlet |opList| (qcdr x))
                         t)
                        (vecp |domain|))
                    (|sayKeyedMsg| 's2it0003 (cons (|devaluate| |domain|) nil)))
                  (t
                    (spadlet |$options|
-                    (append |newOptions| (lassoc |x| |$optionAlist|)))
-                   (|trace1| (list |x|))))))))))))
-      ((null |l|) nil)
-      ((and (pairp |l|) (eq (qcdr |l|) nil) (eq (qcar |l|) '?)) (|?t|))
+                    (append |newOptions| (lassoc x |$optionAlist|)))
+                   (|trace1| (list x))))))))))))
+      ((null arg) nil)
+      ((and (pairp arg) (eq (qcdr arg) nil) (eq (qcar arg) '?)) (|?t|))
       (t
        (spadlet |traceList|
         (or
          (prog (t1)
           (spadlet t1 nil)
           (return
-           (do ((t2 |l| (cdr t2)) (|x| nil))
+           (do ((t2 arg (cdr t2)) (x nil))
                ((or (atom t2) 
-                    (progn (setq |x| (car t2)) nil))
+                    (progn (setq x (car t2)) nil))
                 (nreverse0 t1))
             (seq
              (exit
-              (setq t1 (cons (|transTraceItem| |x|) t1)))))))
+              (setq t1 (cons (|transTraceItem| x) t1)))))))
          (return nil)))
-       (do ((t3 |traceList| (cdr t3)) (|x| nil))
-           ((or (atom t3) (progn (setq |x| (car t3)) nil)) nil)
+       (do ((t3 |traceList| (cdr t3)) (x nil))
+           ((or (atom t3) (progn (setq x (car t3)) nil)) nil)
          (seq
           (exit 
-           (spadlet |$optionAlist| (addassoc |x| |$options| |$optionAlist|)))))
+           (spadlet |$optionAlist| (addassoc x |$options| |$optionAlist|)))))
        (spadlet |optionList| (|getTraceOptions| |$options|))
        (spadlet |argument|
         (cond
@@ -6931,7 +7087,7 @@ This reports the traced functions
 
 <<defun getTraceOptions>>=
 (defun |getTraceOptions| (|options|)
- (prog (|$traceErrorStack| |optionList| temp1 |key| |parms|)
+ (prog (|$traceErrorStack| |optionList| temp1 key |parms|)
   (declare (special |$traceErrorStack|))
   (return
    (seq
@@ -6941,19 +7097,19 @@ This reports the traced functions
       (prog (t0) 
        (spadlet t0 nil)
        (return
-        (do ((t1 |options| (cdr t1)) (|x| nil))
-            ((or (atom t1) (progn (setq |x| (car t1)) nil)) (nreverse0 t0))
+        (do ((t1 |options| (cdr t1)) (x nil))
+            ((or (atom t1) (progn (setq x (car t1)) nil)) (nreverse0 t0))
          (seq
           (exit
-           (setq t0 (cons (|getTraceOption| |x|) t0))))))))
+           (setq t0 (cons (|getTraceOption| x) t0))))))))
      (cond
       (|$traceErrorStack|
        (cond
         ((null (cdr |$traceErrorStack|))
           (spadlet temp1 (car |$traceErrorStack|))
-          (spadlet |key| (car temp1))
+          (spadlet key (car temp1))
           (spadlet |parms| (cadr temp1))
-          (|throwKeyedMsg| |key| (cons "" |parms|)))
+          (|throwKeyedMsg| key (cons "" |parms|)))
         (t
           (|throwListOfKeyedMsgs| 's2it0017
            (cons (|#| |$traceErrorStack|) nil)
@@ -7000,22 +7156,22 @@ This reports the traced functions
 
 <<defun getMapSig>>=
 (defun |getMapSig| (|mapName| |subName|)
- (PROG (|lmms| |sig|)
-  (RETURN
-   (SEQ
-    (COND
-     ((SPADLET |lmms| (|get| |mapName| '|localModemap| |$InteractiveFrame|))
-      (EXIT
-       (SEQ
-        (DO ((t0 |lmms| (CDR t0)) (|mm| nil) (t1 nil |sig|))
-            ((OR (ATOM t0) (PROGN (SETQ |mm| (CAR t0)) nil) t1) nil)
-         (SEQ
-          (EXIT
-           (COND 
-            ((BOOT-EQUAL (CADR |mm|) |subName|)
-              (EXIT 
-               (SPADLET |sig| (CDAR |mm|))))))))
-        (EXIT |sig|))))))))) 
+ (prog (|lmms| |sig|)
+  (return
+   (seq
+    (cond
+     ((spadlet |lmms| (|get| |mapName| '|localModemap| |$InteractiveFrame|))
+      (exit
+       (seq
+        (do ((t0 |lmms| (cdr t0)) (|mm| nil) (t1 nil |sig|))
+            ((or (atom t0) (progn (setq |mm| (car t0)) nil) t1) nil)
+         (seq
+          (exit
+           (cond 
+            ((boot-equal (cadr |mm|) |subName|)
+              (exit 
+               (spadlet |sig| (cdar |mm|))))))))
+        (exit |sig|))))))))) 
 
 @
 
@@ -7072,37 +7228,37 @@ This reports the traced functions
 \end{verbatim}
 
 <<defun getTraceOption,hn>>=
-(defun |getTraceOption,hn| (|x|)
+(defun |getTraceOption,hn| (x)
  (prog (|g|)
   (return
    (seq
-    (if (and (atom |x|) (null (upper-case-p (elt (stringimage |x|) 0))))
+    (if (and (atom x) (null (upper-case-p (elt (stringimage x) 0))))
      (exit
       (seq
-       (if (|isDomainOrPackage| (eval |x|)) (exit |x|))
+       (if (|isDomainOrPackage| (eval x)) (exit x))
        (exit 
         (|stackTraceOptionError|
-         (cons 's2it0013 (cons (cons |x| nil) nil)))))))
-    (if (spadlet |g| (|domainToGenvar| |x|)) (exit |g|))
+         (cons 's2it0013 (cons (cons x nil) nil)))))))
+    (if (spadlet |g| (|domainToGenvar| x)) (exit |g|))
     (exit
-     (|stackTraceOptionError| (cons 's2it0013 (cons (cons |x| nil) nil)))))))) 
+     (|stackTraceOptionError| (cons 's2it0013 (cons (cons x nil) nil)))))))) 
 
 @
 
 <<defun getTraceOption>>=
-(defun |getTraceOption| (|x|)
- (prog (|l| |opts| |key| |a| |n|)
+(defun |getTraceOption| (arg)
+ (prog (|l| |opts| key a |n|)
   (return
    (seq
     (progn
-     (spadlet |key| (car |x|))
-     (spadlet |l| (cdr |x|))
-     (spadlet |key|
-       (|selectOptionLC| |key| |$traceOptionList| '|traceOptionError|))
-     (spadlet |x| (cons |key| |l|))
+     (spadlet key (car arg))
+     (spadlet |l| (cdr arg))
+     (spadlet key
+       (|selectOptionLC| key |$traceOptionList| '|traceOptionError|))
+     (spadlet arg (cons key |l|))
      (cond
-      ((memq |key| '(|nonquietly| |timer| |nt|)) |x|)
-      ((boot-equal |key| '|break|)
+      ((memq key '(|nonquietly| |timer| |nt|)) arg)
+      ((boot-equal key '|break|)
        (cond
         ((null |l|) (cons '|break| (cons '|before| nil)))
         (t
@@ -7131,62 +7287,62 @@ This reports the traced functions
               (cons '|break| |opts|))
            (t
             (|stackTraceOptionError| (cons 's2it0008 (cons nil nil))))))))
-      ((boot-equal |key| '|restore|)
+      ((boot-equal key '|restore|)
        (cond
-        ((null |l|) |x|)
+        ((null |l|) arg)
         (t 
          (|stackTraceOptionError| 
           (cons 's2it0009 
-           (cons (cons (strconc ")" (|object2String| |key|)) nil) nil))))))
-      ((boot-equal |key| '|only|) (cons '|only| (|transOnlyOption| |l|)))
-      ((boot-equal |key| '|within|)
+           (cons (cons (strconc ")" (|object2String| key)) nil) nil))))))
+      ((boot-equal key '|only|) (cons '|only| (|transOnlyOption| |l|)))
+      ((boot-equal key '|within|)
         (cond
          ((and (pairp |l|) 
                (eq (qcdr |l|) nil)
-               (progn (spadlet |a| (qcar |l|)) t)
-               (identp |a|))
-           |x|)
+               (progn (spadlet a (qcar |l|)) t)
+               (identp a))
+           arg)
          (t 
            (|stackTraceOptionError| 
             (cons 's2it0010 (cons (cons ")within" nil) nil))))))
-      ((memq |key| '(|cond| |before| |after|))
-        (spadlet |key| 
+      ((memq key '(|cond| |before| |after|))
+        (spadlet key 
          (cond 
-          ((boot-equal |key| '|cond|) '|when|)
-          (t |key|)))
+          ((boot-equal key '|cond|) '|when|)
+          (t key)))
         (cond
          ((and (pairp |l|) 
                (eq (qcdr |l|) nil)
-               (progn (spadlet |a| (qcar |l|)) t))
-            (cons |key| |l|))
+               (progn (spadlet a (qcar |l|)) t))
+            (cons key |l|))
          (t 
           (|stackTraceOptionError|
            (cons 's2it0011
             (cons
              (cons (strconc ")"
-              (|object2String| |key|)) nil) nil))))))
-      ((boot-equal |key| '|depth|)
+              (|object2String| key)) nil) nil))))))
+      ((boot-equal key '|depth|)
         (cond 
          ((and (pairp |l|) 
                (eq (qcdr |l|) nil)
                (progn (spadlet |n| (qcar |l|)) t)
                (fixp |n|))
-           |x|)
+           arg)
          (t 
           (|stackTraceOptionError| 
            (cons 's2it0012 (cons (cons ")depth" nil) nil))))))
-      ((boot-equal |key| '|count|)
+      ((boot-equal key '|count|)
         (cond 
          ((or (null |l|) 
               (and (pairp |l|) 
                    (eq (qcdr |l|) nil)
                    (progn (spadlet |n| (qcar |l|)) t)
                    (fixp |n|)))
-            |x|)
+            arg)
          (t 
           (|stackTraceOptionError|
             (cons 's2it0012 (cons (cons ")count" nil) nil))))))
-      ((boot-equal |key| '|of|)
+      ((boot-equal key '|of|)
         (cons '|of|
          (prog (t5)
           (spadlet t5 nil)
@@ -7196,37 +7352,37 @@ This reports the traced functions
             (seq
              (exit
               (setq t5 (cons (|getTraceOption,hn| |y|) t5)))))))))
-      ((memq |key| '(|local| |ops| |vars|))
+      ((memq key '(|local| |ops| |vars|))
         (cond
          ((or (null |l|)
               (and (pairp |l|) (eq (qcdr |l|) nil) (eq (qcar |l|) '|all|)))
-           (cons |key| '|all|))
-         ((|isListOfIdentifiersOrStrings| |l|) |x|)
+           (cons key '|all|))
+         ((|isListOfIdentifiersOrStrings| |l|) arg)
          (t
            (|stackTraceOptionError|
             (cons 's2it0015
              (cons
-              (cons (strconc ")" (|object2String| |key|)) nil) nil))))))
-      ((boot-equal |key| '|varbreak|)
+              (cons (strconc ")" (|object2String| key)) nil) nil))))))
+      ((boot-equal key '|varbreak|)
         (cond
          ((or (null |l|) 
               (and (pairp |l|) (eq (qcdr |l|) nil) (eq (qcar |l|) '|all|)))
            (cons '|varbreak| '|all|))
-         ((|isListOfIdentifiers| |l|) |x|)
+         ((|isListOfIdentifiers| |l|) arg)
          (t
            (|stackTraceOptionError|
             (cons 's2it0016
              (cons
-              (cons (strconc ")" (|object2String| |key|)) nil) nil))))))
-      ((boot-equal |key| '|mathprint|)
+              (cons (strconc ")" (|object2String| key)) nil) nil))))))
+      ((boot-equal key '|mathprint|)
         (cond
-         ((null |l|) |x|)
+         ((null |l|) arg)
          (t
            (|stackTraceOptionError|
             (cons 's2it0009
              (cons
-              (cons (strconc ")" (|object2String| |key|)) nil) nil))))))
-      (|key| (|throwKeyedMsg| 's2it0005 (CONS |key| nil))))))))) 
+              (cons (strconc ")" (|object2String| key)) nil) nil))))))
+      (key (|throwKeyedMsg| 's2it0005 (CONS key nil))))))))) 
 
 @
 
@@ -7238,12 +7394,12 @@ This reports the traced functions
 \end{verbatim}
 
 <<defun traceOptionError>>=
-(defun |traceOptionError| (|opt| |keys|)
+(defun |traceOptionError| (opt |keys|)
  (cond
   ((null |keys|)
-    (|stackTraceOptionError| (cons 's2it0007 (cons (cons |opt| nil) nil))))
+    (|stackTraceOptionError| (cons 's2it0007 (cons (cons opt nil) nil))))
   (t
-   (|commandAmbiguityError| '|trace option| |opt| |keys|)))) 
+   (|commandAmbiguityError| '|trace option| opt |keys|)))) 
 
 @
 
@@ -7407,12 +7563,12 @@ This reports the traced functions
 \end{verbatim}
 
 <<defun transOnlyOption>>=
-(defun |transOnlyOption| (|l|)
+(defun |transOnlyOption| (arg)
  (prog (|y| |n|)
   (return
    (cond
-    ((and (pairp |l|) 
-          (progn (spadlet |n| (qcar |l|)) (spadlet |y| (qcdr |l|)) t))
+    ((and (pairp arg) 
+          (progn (spadlet |n| (qcar arg)) (spadlet |y| (qcdr arg)) t))
       (cond
        ((fixp |n|)
          (cons |n| (|transOnlyOption| |y|)))
@@ -7442,7 +7598,7 @@ This reports the traced functions
 
 <<defun removeOption>>=
 (defun |removeOption| (|op| |options|)
- (prog (|opt|)
+ (prog (opt)
   (return
    (seq
     (prog (t0)
@@ -7451,12 +7607,12 @@ This reports the traced functions
       (do ((t1 |options| (cdr t1)) (|optEntry| nil))
           ((or (atom t1)
                (progn (setq |optEntry| (car t1)) nil)
-               (progn (progn (spadlet |opt| (CAR |optEntry|)) |optEntry|) nil))
+               (progn (progn (spadlet opt (CAR |optEntry|)) |optEntry|) nil))
         (nreverse0 t0))
        (seq
         (exit
          (cond
-          ((nequal |opt| |op|) (setq t0 (cons |optEntry| t0))))))))))))) 
+          ((nequal opt |op|) (setq t0 (cons |optEntry| t0))))))))))))) 
 
 @
 
@@ -7471,14 +7627,14 @@ This reports the traced functions
 \end{verbatim}
 
 <<defun domainToGenvar>>=
-(defun |domainToGenvar| (|x|)
+(defun |domainToGenvar| (arg)
  (prog (|$doNotAddEmptyModeIfTrue| |y| |g|)
   (declare (special |$doNotAddEmptyModeIfTrue|))
   (return
    (progn
     (spadlet |$doNotAddEmptyModeIfTrue| t)
     (cond
-     ((and (spadlet |y| (|unabbrevAndLoad| |x|))
+     ((and (spadlet |y| (|unabbrevAndLoad| arg))
            (boot-equal (getdatabase (|opOf| |y|) 'constructorkind) '|domain|))
        (progn
         (spadlet |g| (|genDomainTraceName| |y|))
@@ -7523,17 +7679,17 @@ This reports the traced functions
 \end{verbatim}
 
 <<defun untrace>>=
-(defun |untrace| (|l|)
+(defun |untrace| (arg)
  (prog (|untraceList|)
   (return
    (seq
     (progn
-     (spadlet |$lastUntraced| (cond ((null |l|) (copy /tracenames)) (t |l|)))
+     (spadlet |$lastUntraced| (cond ((null arg) (copy /tracenames)) (t arg)))
      (spadlet |untraceList|
       (prog (t0)
        (spadlet t0 nil)
        (return
-        (do ((t1 |l| (cdr t1)) (|x| nil))
+        (do ((t1 arg (cdr t1)) (|x| nil))
             ((or (atom t1) (progn (setq |x| (car t1)) nil)) (nreverse0 t0))
          (seq
           (exit
@@ -7658,13 +7814,13 @@ This reports the traced functions
                 (t2 |args| (cdr t2))
                 (|arg| nil)
                 (t3 (cdr (lassoc |subName| |$tracedMapSignatures|)) (cdr t3))
-                (|type| nil))
+                (type nil))
                ((or (atom t1)
                     (progn (setq |name| (car t1)) nil)
                     (atom t2)
                     (progn (setq |arg| (car t2)) nil)
                     (atom t3)
-                    (progn (setq |type| (car t3)) nil)) 
+                    (progn (setq type (car t3)) nil)) 
                   (nreverse0 t0))
              (seq
               (exit 
@@ -7674,7 +7830,7 @@ This reports the traced functions
                   (cons |name| 
                    (cons (|objValUnwrap|
                      (|coerceInteractive|
-                      (|objNewWrap| |arg| |type|) |$OutputForm|))
+                      (|objNewWrap| |arg| type) |$OutputForm|))
                         nil)))
                      t0))))))))))
      ((spadsysnamep (pname |name|)) (reverse (cdr (reverse |args|))))
@@ -7710,13 +7866,13 @@ This reports the traced functions
             (t2 |args| (cdr t2))
             (|arg| nil)
             (t3 (cdr |$tracedSpadModemap|) (cdr t3))
-            (|type| nil))
+            (type nil))
            ((or (atom t1)
                 (progn (setq |name| (car t1)) nil)
                 (atom t2)
                 (progn (setq |arg| (car t2)) nil)
                 (atom t3)
-                (progn (setq |type| (car t3)) nil))
+                (progn (setq type (car t3)) nil))
              (nreverse0 t0))
          (seq
           (exit
@@ -7726,7 +7882,7 @@ This reports the traced functions
               (cons |name|
                (cons (|objValUnwrap|
                  (|coerceInteractive| 
-                  (|objNewWrap| |arg| |type|)
+                  (|objNewWrap| |arg| type)
                   |$OutputForm|)) nil)))
               t0)))))))))))) 
 
@@ -7819,14 +7975,14 @@ This reports the traced functions
 \end{verbatim}
 
 <<defun isListOfIdentifiers>>=
-(defun |isListOfIdentifiers| (|l|)
+(defun |isListOfIdentifiers| (arg)
  (prog () 
   (return
    (seq
     (prog (t0)
      (spadlet t0 t)
      (return
-      (do ((t1 nil (null t0)) (t2 |l| (cdr t2)) (|x| nil))
+      (do ((t1 nil (null t0)) (t2 arg (cdr t2)) (|x| nil))
           ((or t1 (atom t2) (progn (setq |x| (car t2)) nil)) t0)
        (seq
         (exit
@@ -7840,14 +7996,14 @@ This reports the traced functions
 \end{verbatim}
 
 <<defun isListOfIdentifiersOrStrings>>=
-(defun |isListOfIdentifiersOrStrings| (|l|)
+(defun |isListOfIdentifiersOrStrings| (arg)
  (prog () 
   (return
    (seq
     (prog (t0)
      (spadlet t0 t)
      (return
-      (do ((t1 nil (null t0)) (t2 |l| (cdr t2)) (|x| nil))
+      (do ((t1 nil (null t0)) (t2 arg (cdr t2)) (|x| nil))
           ((or t1 (atom t2) (progn (setq |x| (car t2)) nil)) t0)
        (seq
         (exit
@@ -7867,14 +8023,14 @@ This reports the traced functions
 \end{verbatim}
 
 <<defun getMapSubNames>>=
-(defun |getMapSubNames| (|l|)
+(defun |getMapSubNames| (arg)
  (prog (|lmm| |subs|)
   (return
    (seq
     (progn
      (spadlet |subs| nil)
      (seq
-      (do ((t0 |l| (cdr t0)) (|mapName| nil))
+      (do ((t0 arg (cdr t0)) (|mapName| nil))
           ((or (atom t0) (progn (setq |mapName| (CAR t0)) nil)) nil)
        (seq
         (exit
@@ -8027,13 +8183,13 @@ This reports the traced functions
 \end{verbatim}
 
 <<defun augmentTraceNames>>=
-(defun |augmentTraceNames| (|l| |mapSubNames|)
+(defun |augmentTraceNames| (arg |mapSubNames|)
  (prog (|mml| |res|)
   (return
    (seq
     (progn
      (spadlet |res| nil)
-     (do ((t0 |l| (cdr t0)) (|traceName| nil))
+     (do ((t0 arg (cdr t0)) (|traceName| nil))
          ((or (atom t0) (progn (setq |traceName| (car t0)) nil)) nil)
       (seq
        (exit
@@ -8535,13 +8691,13 @@ This reports the traced functions
         (prog (t0)
          (spadlet t0 nil)
          (return
-          (do ((t1 |options| (cdr t1)) (|opt| nil))
-              ((or (atom t1) (progn (setq |opt| (car t1)) nil)) (nreverse0 t0))
+          (do ((t1 |options| (cdr t1)) (opt nil))
+              ((or (atom t1) (progn (setq opt (car t1)) nil)) (nreverse0 t0))
            (seq
             (exit
              (cond 
-              ((null (and (pairp |opt|) (eq (qcar |opt|) 'local)))
-                (setq t0 (cons |opt| t0))))))))))))
+              ((null (and (pairp opt) (eq (qcar opt) 'local)))
+                (setq t0 (cons opt t0))))))))))))
      (cond 
       ((and |listOfLocalOps| (null (|getOption| 'ops |options|))) nil)
       (t
@@ -8944,19 +9100,19 @@ This reports the traced functions
 \end{verbatim}
 
 <<defun hasPair>>=
-(defun |hasPair| (|key| |l|)
- (prog (tmp1 |a|)
+(defun |hasPair| (key arg)
+ (prog (tmp1 a)
   (return 
    (cond
-    ((atom |l|) nil)
-    ((and (pairp |l|)
+    ((atom arg) nil)
+    ((and (pairp arg)
           (progn
-           (spadlet tmp1 (qcar |l|))
+           (spadlet tmp1 (qcar arg))
            (and (pairp tmp1)
-                (equal (qcar tmp1) |key|)
-                (progn (spadlet |a| (qcdr tmp1)) t))))
-       |a|)
-    (t (|hasPair| |key| (cdr |l|))))))) 
+                (equal (qcar tmp1) key)
+                (progn (spadlet a (qcdr tmp1)) t))))
+       a)
+    (t (|hasPair| key (cdr arg))))))) 
 
 @
 
@@ -9058,7 +9214,7 @@ This reports the traced functions
 \end{verbatim}
 
 <<defun orderBySlotNumber>>=
-(defun |orderBySlotNumber| (|l|)
+(defun |orderBySlotNumber| (arg)
  (prog (|n|)
   (return 
    (seq
@@ -9067,7 +9223,7 @@ This reports the traced functions
       (prog (t0)
        (spadlet t0 nil)
        (return
-        (do ((t1 |l| (cdr t1)) (|x| nil))
+        (do ((t1 arg (cdr t1)) (|x| nil))
             ((or (atom t1)
                  (progn (setq |x| (car t1)) nil)
                  (progn (progn (spadlet |n| (caddr |x|)) |x|) nil))
@@ -10662,21 +10818,21 @@ whatSpad2Cmd l ==
 
 \subsection{defun whatSpad2Cmd}
 <<defun whatSpad2Cmd>>=
-(defun |whatSpad2Cmd| (|l|)
- (prog (|$e| |key0| |key| |args|)
+(defun |whatSpad2Cmd| (arg)
+ (prog (|$e| |key0| key |args|)
   (declare (special |$e|))
   (return
    (seq
     (progn
      (spadlet |$e| |$EmptyEnvironment|)
      (cond
-      ((null |l|) (|reportWhatOptions|))
+      ((null arg) (|reportWhatOptions|))
       (t
-        (spadlet |key0| (car |l|))
-        (spadlet |args| (cdr |l|))
-        (spadlet |key| (|selectOptionLC| |key0| |$whatOptions| nil))
+        (spadlet |key0| (car arg))
+        (spadlet |args| (cdr arg))
+        (spadlet key (|selectOptionLC| |key0| |$whatOptions| nil))
         (cond
-         ((null |key|) (|sayKeyedMsg| 's2iz0043 nil))
+         ((null key) (|sayKeyedMsg| 's2iz0043 nil))
          (t
           (spadlet |args|
            (prog (t0)
@@ -10691,25 +10847,25 @@ whatSpad2Cmd l ==
                  (setq t0 (cons (|whatSpad2Cmd,fixpat| |p|) t0))))))))
           (seq
            (cond
-            ((boot-equal |key| '|things|)
-              (do ((t2 |$whatOptions| (cdr t2)) (|opt| nil))
-                  ((or (atom t2) (progn (setq |opt| (CAR t2)) nil)) nil)
+            ((boot-equal key '|things|)
+              (do ((t2 |$whatOptions| (cdr t2)) (opt nil))
+                  ((or (atom t2) (progn (setq opt (CAR t2)) nil)) nil)
                (seq
                 (exit
                  (cond
-                  ((null (memq |opt| '(|things|)))
-                    (exit (|whatSpad2Cmd| (cons |opt| |args|)))))))))
-            ((boot-equal |key| '|categories|)
+                  ((null (memq opt '(|things|)))
+                    (exit (|whatSpad2Cmd| (cons opt |args|)))))))))
+            ((boot-equal key '|categories|)
               (|filterAndFormatConstructors| '|category| "Categories" |args|))
-            ((boot-equal |key| '|commands|) (|whatCommands| |args|))
-            ((boot-equal |key| '|domains|)
+            ((boot-equal key '|commands|) (|whatCommands| |args|))
+            ((boot-equal key '|domains|)
               (|filterAndFormatConstructors| '|domain| "Domains" |args|))
-            ((boot-equal |key| '|operations|)
+            ((boot-equal key '|operations|)
                (|apropos| |args|))
-            ((boot-equal |key| '|packages|)
+            ((boot-equal key '|packages|)
               (|filterAndFormatConstructors| '|package| "Packages" |args|))
             (t
-             (cond ((boot-equal |key| '|synonyms|)
+             (cond ((boot-equal key '|synonyms|)
                       (|printSynonyms| |args|))))))))))))))) 
 
 @
@@ -10815,20 +10971,20 @@ apropos l ==
 \end{verbatim}
 
 <<defun apropos>>=
-(defun |apropos| (|l|)
+(defun |apropos| (arg)
  (prog (|ops|)
   (return
    (seq
     (progn
      (spadlet |ops|
       (cond 
-       ((null |l|) (|allOperations|))
+       ((null arg) (|allOperations|))
        (t
          (|filterListOfStrings|
           (prog (t0)
            (spadlet t0 nil)
            (return
-            (do ((t1 |l| (cdr t1)) (|p| nil))
+            (do ((t1 arg (cdr t1)) (|p| nil))
                 ((or (atom t1) (progn (setq |p| (car t1)) nil))
                   (nreverse0 t0))
             (seq (exit (setq t0 (cons (downcase (stringimage |p|)) t0)))))))
@@ -10897,7 +11053,7 @@ workfilesSpad2Cmd args ==
 \end{verbatim}
 <<defun workfilesSpad2Cmd>>=
 (defun |workfilesSpad2Cmd| (|args|)
- (prog (|deleteFlag| |type| |flist| |type1| |fl|)
+ (prog (|deleteFlag| type |flist| |type1| |fl|)
   (return
    (seq
     (cond 
@@ -10907,16 +11063,16 @@ workfilesSpad2Cmd args ==
        (do ((t0 |$options| (cdr t0)) (t1 nil))
            ((or (atom t0)
                 (progn (setq t1 (car t0)) nil)
-                (progn (progn (spadlet |type| (car t1)) t1) nil))
+                (progn (progn (spadlet type (car t1)) t1) nil))
              nil)
         (seq
          (exit
           (progn 
            (spadlet |type1|
-            (|selectOptionLC| |type| '(|boot| |lisp| |meta| |delete|) nil))
+            (|selectOptionLC| type '(|boot| |lisp| |meta| |delete|) nil))
            (cond
             ((null |type1|)
-              (|throwKeyedMsg| 's2iz0048 (cons |type| nil)))
+              (|throwKeyedMsg| 's2iz0048 (cons type nil)))
             ((boot-equal |type1| '|delete|)
               (spadlet |deleteFlag| t)))))))
        (do ((t2 |$options| (cdr t2)) (t3 nil))
@@ -10924,7 +11080,7 @@ workfilesSpad2Cmd args ==
             (progn (setq t3 (CAR t2)) nil)
             (progn
              (progn 
-              (spadlet |type| (car t3))
+              (spadlet type (car t3))
               (spadlet |flist| (cdr t3)) t3)
              nil))
             nil)
@@ -10932,7 +11088,7 @@ workfilesSpad2Cmd args ==
         (exit
          (progn
           (spadlet |type1|
-           (|selectOptionLC| |type| '(|boot| |lisp| |meta| |delete|) nil))
+           (|selectOptionLC| type '(|boot| |lisp| |meta| |delete|) nil))
           (cond
            ((boot-equal |type1| '|delete|) nil)
            (t
@@ -10979,8 +11135,8 @@ workfilesSpad2Cmd args ==
 zsystemdevelopment l == zsystemDevelopmentSpad2Cmd l
 \end{verbatim}
 <<defun zsystemdevelopment>>=
-(defun |zsystemdevelopment| (|l|)
- (|zsystemDevelopmentSpad2Cmd| |l|)) 
+(defun |zsystemdevelopment| (arg)
+ (|zsystemDevelopmentSpad2Cmd| arg)) 
 
 @
 
@@ -10989,8 +11145,8 @@ zsystemdevelopment l == zsystemDevelopmentSpad2Cmd l
 zsystemDevelopmentSpad2Cmd l == zsystemdevelopment1 (l,$InteractiveMode)
 \end{verbatim}
 <<defun zsystemDevelopmentSpad2Cmd>>=
-(defun |zsystemDevelopmentSpad2Cmd| (|l|)
- (|zsystemdevelopment1| |l| |$InteractiveMode|)) 
+(defun |zsystemDevelopmentSpad2Cmd| (arg)
+ (|zsystemdevelopment1| arg |$InteractiveMode|)) 
 
 @
 
@@ -11035,8 +11191,8 @@ zsystemdevelopment1(l,im) ==
       :bright '"c ct e ec ect cls pause update patch compare record"]
 \end{verbatim}
 <<defun zsystemdevelopment1>>=
-(defun |zsystemdevelopment1| (|l| |im|)
- (prog (|$InteractiveMode| |fromopt| |opt| |optargs| |newopt| |opt1|
+(defun |zsystemdevelopment1| (arg |im|)
+ (prog (|$InteractiveMode| |fromopt| opt |optargs| |newopt| |opt1|
         |conStream| |upf| |fun|)
   (declare (special |$InteractiveMode|))
   (return
@@ -11049,7 +11205,7 @@ zsystemdevelopment1(l,im) ==
               (progn (setq t1 (car t0)) nil)
               (progn
                (progn
-                (spadlet |opt| (CAR t1))
+                (spadlet opt (CAR t1))
                 (spadlet |optargs| (CDR t1))
                 t1)
                nil))
@@ -11057,7 +11213,7 @@ zsystemdevelopment1(l,im) ==
       (seq
        (exit
         (progn
-         (spadlet |opt1| (|selectOptionLC| |opt| '(|from|) nil))
+         (spadlet |opt1| (|selectOptionLC| opt '(|from|) nil))
          (cond
           ((boot-equal |opt1| '|from|)
             (spadlet |fromopt| (cons (cons 'from |optargs|) nil))))))))
@@ -11066,7 +11222,7 @@ zsystemdevelopment1(l,im) ==
               (progn (setq t3 (car t2)) nil)
               (progn
                (progn
-                (spadlet |opt| (car t3))
+                (spadlet opt (car t3))
                 (spadlet |optargs| (cdr t3))
                 t3)
                nil))
@@ -11074,38 +11230,38 @@ zsystemdevelopment1(l,im) ==
       (seq
        (exit
         (progn
-         (cond ((null |optargs|) (spadlet |optargs| |l|)))
+         (cond ((null |optargs|) (spadlet |optargs| arg)))
          (spadlet |newopt| (append |optargs| |fromopt|))
-         (spadlet |opt1| (|selectOptionLC| |opt| '(|from|) nil))
+         (spadlet |opt1| (|selectOptionLC| opt '(|from|) nil))
          (cond
           ((boot-equal |opt1| '|from|)
             nil)
-          ((boot-equal |opt| '|c|)
+          ((boot-equal opt '|c|)
             (|/D,1| |newopt| (/COMP) nil nil))
-          ((boot-equal |opt| '|d|)
+          ((boot-equal opt '|d|)
             (|/D,1| |newopt| 'define nil nil))
-          ((boot-equal |opt| '|dt|)
+          ((boot-equal opt '|dt|)
             (|/D,1| |newopt| 'define nil t))
-          ((boot-equal |opt| '|ct|)
+          ((boot-equal opt '|ct|)
             (|/D,1| |newopt| (/COMP) nil t))
-          ((boot-equal |opt| '|ctl|)
+          ((boot-equal opt '|ctl|)
             (|/D,1| |newopt| (/COMP) nil 'tracelet))
-          ((boot-equal |opt| '|ec|)
+          ((boot-equal opt '|ec|)
             (|/D,1| |newopt| (/COMP) t nil))
-          ((boot-equal |opt| '|ect|)
+          ((boot-equal opt '|ect|)
             (|/D,1| |newopt| (/COMP) t t))
-          ((boot-equal |opt| '|e|)
+          ((boot-equal opt '|e|)
             (|/D,1| |newopt| nil t nil))
-          ((boot-equal |opt| '|version|)
+          ((boot-equal opt '|version|)
             (|version|))
-          ((boot-equal |opt| '|pause|)
+          ((boot-equal opt '|pause|)
             (spadlet |conStream|
               (defiostream '((device . console) (qual . v)) 120 0))
             (next |conStream|)
             (shut |conStream|))
           ((or 
-              (boot-equal |opt| '|update|)
-              (boot-equal |opt| '|patch|))
+              (boot-equal opt '|update|)
+              (boot-equal opt '|patch|))
             (spadlet |$InteractiveMode| nil)
             (spadlet |upf|
              (cons
@@ -11115,7 +11271,7 @@ zsystemdevelopment1(l,im) ==
                (cons (or (kaddr |optargs|) '*) nil))))
             (spadlet |fun|
              (cond
-              ((boot-equal |opt| '|patch|) '/update-lib-1)
+              ((boot-equal opt '|patch|) '/update-lib-1)
               (t '/update-1)))
             (catch 'filenam (funcall |fun| |upf|))
             (|sayMessage| "   Update/patch is completed."))
@@ -11123,13 +11279,13 @@ zsystemdevelopment1(l,im) ==
            (|sayBrightly|
             (cons
              "   An argument is required for"
-             (|bright| |opt|))))
+             (|bright| opt))))
           (t
            (|sayMessage|
             (cons
              "   Unknown option:"
              (append
-              (|bright| |opt|)
+              (|bright| opt)
               (cons '|    | (cons '|%l| (cons "   Available options are"
                  (|bright|
                    "c ct e ec ect cls pause update patch compare record")
@@ -11256,6 +11412,8 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 (in-package "BOOT")
 <<initvars>>
 
+<<defun abbreviations>>
+<<defun abbreviationsSpad2Cmd>>
 <<defun addNewInterpreterFrame>>
 <<defun addTraceItem>>
 <<defun apropos>>
@@ -11350,6 +11508,7 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun letPrint>>
 <<defun letPrint2>>
 <<defun letPrint3>>
+<<defun listConstructorAbbreviations>>
 <<defun loadExposureGroupData>>
 
 <<defmacro funfind>>
diff --git a/changelog b/changelog
index a9ffdb8..21aee6c 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,7 @@
+20090308 tpd src/axiom-website/patches.html 20090308.01.tpd.patch
+20090308 tpd src/interp/i-syscmd.boot move abbreviation to bookvol5
+20090308 tpd books/bookvol5 add abbreviation, include roots
+20090308 tpd books/bookvol0 add )include documentation
 20090307 tpd src/axiom-website/patches.html 20090307.01.tpd.patch
 20090307 tpd src/interp/debugsys.lisp stop loading trace.clisp
 20090307 tpd src/interp/Makefile remove trace.boot
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index 3f6e161..5552b92 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -991,5 +991,7 @@ bookvol5 add user level command roots<br/>
 bookvol10.3 add Grabmeier/Waldek fixes to Float<br/>
 <a href="patches/20090307.01.tpd.patch">20090307.01.tpd.patch</a>
 bookvol5 add trace root<br/>
+<a href="patches/20090308.01.tpd.patch">20090308.01.tpd.patch</a>
+bookvol5 add include, abbreviation roots<br/>
  </body>
 </html>
diff --git a/src/interp/i-syscmd.boot.pamphlet b/src/interp/i-syscmd.boot.pamphlet
index 997c527..dfcf93c 100644
--- a/src/interp/i-syscmd.boot.pamphlet
+++ b/src/interp/i-syscmd.boot.pamphlet
@@ -151,7 +151,7 @@ SETANDFILEQ($clearOptions, '( _
 SETANDFILEQ($countAssoc,'( (cache countCache) ))
 
 --% Top level system command
-
+-- (mapcar #'car $systemCommands)
 initializeSystemCommands() ==
   l := $systemCommands
   $SYSCOMMANDS := NIL
@@ -270,48 +270,6 @@ getSystemCommandLine() ==
 
 ------------ start of commands ------------------------------------------
 
---% )abbreviations
-
-abbreviations l == abbreviationsSpad2Cmd l
-
-abbreviationsSpad2Cmd l ==
-  null l => helpSpad2Cmd '(abbreviations)
-  abopts := '(query domain category package remove)
-
-  quiet := nil
-  for [opt] in $options repeat
-    opt := selectOptionLC(opt,'(quiet),'optionError)
-    opt = 'quiet => quiet := true
-
-  l is [opt,:al] =>
-    key := opOf CAR al
-    type := selectOptionLC(opt,abopts,'optionError)
-    type is 'query =>
-      null al => listConstructorAbbreviations()
-      constructor := abbreviation?(key) => abbQuery(constructor)
-      abbQuery(key)
-    type is 'remove =>
-      DELDATABASE(key,'ABBREVIATION)
-    ODDP SIZE al => sayKeyedMsg("S2IZ0002",[type])
-    repeat
-      null al => return 'fromLoop
-      [a,b,:al] := al
-      mkUserConstructorAbbreviation(b,a,type)
-      SETDATABASE(b,'ABBREVIATION,a)
-      SETDATABASE(b,'CONSTRUCTORKIND,type)
-    null quiet =>
-      sayKeyedMsg("S2IZ0001",[a,type,opOf b])
-      nil
-  nil
-
-listConstructorAbbreviations() ==
-  x := UPCASE queryUserKeyedMsg("S2IZ0056",NIL)
-  MEMQ(STRING2ID_-N(x,1),'(Y YES)) =>
-    whatSpad2Cmd '(categories)
-    whatSpad2Cmd '(domains)
-    whatSpad2Cmd '(packages)
-  sayKeyedMsg("S2IZ0057",NIL)
-
 --% )clear
 
 clear l == clearSpad2Cmd l




From MAILER-DAEMON Sun Mar 08 14:57:24 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LgOBg-0002fH-JS
	for mharc-axiom-developer@gnu.org; Sun, 08 Mar 2009 14:57:24 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LgOBf-0002ey-EI
	for axiom-developer@nongnu.org; Sun, 08 Mar 2009 14:57:23 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LgOBe-0002ei-0Y
	for axiom-developer@nongnu.org; Sun, 08 Mar 2009 14:57:23 -0400
Received: from [199.232.76.173] (port=53932 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LgOBd-0002ec-RG
	for axiom-developer@nongnu.org; Sun, 08 Mar 2009 14:57:21 -0400
Received: from mx-8.zoominternet.net ([24.154.1.27]:33453
	helo=cm-2.zoominternet.net)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LgOBd-0001xG-Gf
	for axiom-developer@nongnu.org; Sun, 08 Mar 2009 14:57:21 -0400
X-SpamGroup: 2000
X-CM-Cat: Undefined:Undefined
X-CNFS-Analysis: v=1.0 c=1 a=9rZUY6H0CbYA:10 a=XfeEPuNNjv4A:10
	a=E8rTNAPPKTgA:10 a=9x1qJYSYWOoMgoVr+WVG7Q==:17
	a=1_5UbWxpz-3Ejcn0jw8A:9 a=Ps20b_rQV4zQ2iy0sRiK64a70yMA:4
	a=8b0TY1xhFYQA:10
X-CM-Score: 0
X-Scanned-by: Cloudmark Authority Engine
Received: from [24.154.1.47] ([24.154.1.47:49025] helo=pop-4.zoominternet.net)
	by mx-8.zoominternet.net (envelope-from <daly@axiom-developer.org>)
	(ecelerity 2.2.2.30 r(24168)) with ESMTP
	id 95/F8-26653-D0514B94; Sun, 08 Mar 2009 14:57:17 -0400
Received: (qmail 17806 invoked from network); 8 Mar 2009 18:57:17 -0000
Received: from unknown (HELO localhost.localdomain) ([72.23.19.139])
	(envelope-sender <daly@axiom-developer.org>)
	by pop-4.zoominternet.net (qmail-ldap-1.03) with SMTP
	for <daly@axiom-developer.org>; 8 Mar 2009 18:57:17 -0000
Received: (from root@localhost)
	by localhost.localdomain (8.11.6/8.11.6) id n28Ji7216081;
	Sun, 8 Mar 2009 14:44:07 -0500
Date: Sun, 8 Mar 2009 14:44:07 -0500
Message-Id: <200903081944.n28Ji7216081@localhost.localdomain>
From: root <daly@axiom-developer.org>
To: camm@maguirefamily.org
In-reply-to: <87iqmy1fyd.fsf@maguirefamily.org> (message from Camm Maguire on
	Wed, 25 Feb 2009 14:20:26 -0500)
Subject: Re: [Axiom-developer] Re: Debian axiom build failures
References: <200812170459.mBH4xOd17234@localhost.localdomain>
	<87eiyd8na4.fsf@maguirefamily.org>
	<200902051354.n15Dsb221922@localhost.localdomain>
	<87iqn41rbp.fsf@maguirefamily.org>
	<200902220708.n1M78vt15122@localhost.localdomain>
	<87vdr1ate8.fsf_-_@maguirefamily.org>
	<200902232250.n1NMoBR23993@localhost.localdomain>
	<87skm32x6x.fsf_-_@maguirefamily.org>
	<200902250355.n1P3tQm25134@localhost.localdomain>
	<87iqmy1fyd.fsf@maguirefamily.org>
X-detected-operating-system: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: axiom-developer@nongnu.org
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
Reply-To: daly@axiom-developer.org
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sun, 08 Mar 2009 18:57:23 -0000

Camm,

Did you ever get a chance to try

   make clean
   make NOISE=

and store the log somewhere? The NOISE= option keeps the build
process from throwing away standard output so we can see what
might be failing.

Tim



From MAILER-DAEMON Mon Mar 09 16:22:48 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Lglzs-0003zI-FS
	for mharc-axiom-developer@gnu.org; Mon, 09 Mar 2009 16:22:48 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Lglzp-0003v8-Nb
	for axiom-developer@nongnu.org; Mon, 09 Mar 2009 16:22:45 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Lglzk-0003nU-UM
	for axiom-developer@nongnu.org; Mon, 09 Mar 2009 16:22:44 -0400
Received: from [199.232.76.173] (port=50062 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Lglzk-0003n5-Cc
	for axiom-developer@nongnu.org; Mon, 09 Mar 2009 16:22:40 -0400
Received: from mx20.gnu.org ([199.232.41.8]:3000)
	by monty-python.gnu.org with esmtps (TLS-1.0:RSA_AES_256_CBC_SHA1:32)
	(Exim 4.60) (envelope-from <daly@axiom-developer.org>)
	id 1Lglzj-0000c6-ST
	for axiom-developer@nongnu.org; Mon, 09 Mar 2009 16:22:40 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]
	helo=axiom-developer.org) by mx20.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LgPdx-00025u-3E
	for axiom-developer@nongnu.org; Sun, 08 Mar 2009 16:30:41 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n28KSaug015084;
	Sun, 8 Mar 2009 14:28:37 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n28KSame015075;
	Sun, 8 Mar 2009 14:28:36 -0600
Date: Sun, 8 Mar 2009 14:28:36 -0600
Message-Id: <200903082028.n28KSame015075@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by mx20.gnu.org: Linux 2.6? (barebone, rare!)
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6,
	seldom 2.4 (older, 4)
Cc: 
Subject: [Axiom-developer] 20090308.02.tpd.patch (bookvol5 add clear root)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 09 Mar 2009 20:22:47 -0000

Move the )clear code from i-syscmd.boot to bookvol5

================================================================
diff --git a/books/bookvol5.pamphlet b/books/bookvol5.pamphlet
index ba91b7b..8f4470a 100644
--- a/books/bookvol5.pamphlet
+++ b/books/bookvol5.pamphlet
@@ -1623,6 +1623,360 @@ system function and constructor caches.
 \fnref{frame}, and
 \fnref{undo}
 
+\subsection{defun clear}
+<<defun clear>>=
+(defun |clear| (l)
+ (|clearSpad2Cmd| l)) 
+
+@
+
+\subsection{defun clearSpad2Cmd}
+\begin{verbatim}
+;clearSpad2Cmd l ==
+;  -- new version which changes the environment and updates history
+;  $clearExcept: local := nil
+;  if $options then $clearExcept :=
+;    "and"/[selectOptionLC(opt,'(except),'optionError) =
+;             'except for [opt,:.] in $options]
+;  null l =>
+;    optList:= "append"/[ ['%l,'"       ",x] for x in $clearOptions]
+;    sayKeyedMsg("S2IZ0010",[optList])
+;  arg := selectOptionLC(first l,'(all completely scaches),NIL)
+;  arg = 'all          => clearCmdAll()
+;  arg = 'completely   => clearCmdCompletely()
+;  arg = 'scaches      => clearCmdSortedCaches()
+;  $clearExcept => clearCmdExcept(l)
+;  clearCmdParts(l)
+;  updateCurrentInterpreterFrame()
+\end{verbatim}
+
+<<defun clearSpad2Cmd>>=
+(defun |clearSpad2Cmd| (|l|)
+ (prog (|$clearExcept| |opt| |optList| |arg|)
+  (declare (special |$clearExcept|))
+  (return
+   (seq
+    (progn
+     (spadlet |$clearExcept| nil)
+     (cond 
+      (|$options|
+       (spadlet |$clearExcept|
+        (prog (t0)
+         (spadlet t0 t)
+         (return
+          (do ((t1 nil (null t0))
+               (t2 |$options| (cdr t2))
+               (t3 nil))
+              ((or t1 
+                   (atom t2)
+                   (progn (setq t3 (car t2)) nil)
+                   (progn (progn (spadlet |opt| (car t3)) t3) nil))
+                 t0)
+           (seq 
+            (exit 
+             (setq t0
+              (and t0 
+                   (boot-equal
+                    (|selectOptionLC| |opt| '(|except|) '|optionError|)
+                    '|except|)))))))))))
+     (cond
+      ((null |l|)
+        (spadlet |optList|
+         (prog (t4)
+          (spadlet t4 nil)
+          (return
+           (do ((t5 |$clearOptions| (cdr t5)) (|x| nil))
+               ((or (atom t5) (progn (setq |x| (car t5)) nil)) t4)
+            (seq
+             (exit
+              (setq t4 
+               (append t4 (cons '|%l| (cons "       " (cons |x| nil)))))))))))
+        (|sayKeyedMsg| 's2iz0010 (cons |optList| nil)))
+      (t
+        (spadlet |arg|
+         (|selectOptionLC| (car |l|) '(|all| |completely| |scaches|) nil))
+        (cond
+         ((boot-equal |arg| '|all|) (|clearCmdAll|))
+         ((boot-equal |arg| '|completely|) (|clearCmdCompletely|))
+         ((boot-equal |arg| '|scaches|) (|clearCmdSortedCaches|))
+         (|$clearExcept| (|clearCmdExcept| |l|))
+         (t
+          (|clearCmdParts| |l|) (|updateCurrentInterpreterFrame|)))))))))) 
+
+@
+
+\subsection{defun clearCmdSortedCaches}
+\begin{verbatim}
+;clearCmdSortedCaches() ==
+;  $lookupDefaults: local := false
+;  for [.,.,:domain] in HGET($ConstructorCache,'SortedCache) repeat
+;    pair := compiledLookupCheck('clearCache,[$Void],domain)
+;    SPADCALL pair
+\end{verbatim}
+
+<<defun clearCmdSortedCaches>>=
+(defun |clearCmdSortedCaches| ()
+ (prog (|$lookupDefaults| |domain| |pair|)
+  (declare (special |$lookupDefaults|))
+  (return
+   (seq 
+    (progn 
+     (spadlet |$lookupDefaults| nil)
+     (do ((t0 (hget |$ConstructorCache| '|SortedCache|) (cdr t0)) 
+          (t1 nil))
+         ((or (atom t0) 
+              (progn (setq t1 (car t0)) nil)
+              (progn (progn (spadlet |domain| (cddr t1)) t1) nil))
+            nil)
+      (seq
+       (exit
+        (progn
+         (spadlet |pair|
+          (|compiledLookupCheck| '|clearCache| (cons |$Void| nil) |domain|))
+         (spadcall |pair|)))))))))) 
+
+@
+
+\subsection{defun clearCmdCompletely}
+\begin{verbatim}
+;clearCmdCompletely() ==
+;  clearCmdAll()
+;  $localExposureData := COPY_-SEQ $localExposureDataDefault
+;  $xdatabase := NIL
+;  $CatOfCatDatabase  := NIL
+;  $DomOfCatDatabase  := NIL
+;  $JoinOfCatDatabase := NIL
+;  $JoinOfDomDatabase := NIL
+;  $attributeDb := NIL
+;  $functionTable := NIL
+;  sayKeyedMsg("S2IZ0013",NIL)
+;  clearClams()
+;  clearConstructorCaches()
+;  $existingFiles := MAKE_-HASHTABLE 'UEQUAL
+;  sayKeyedMsg("S2IZ0014",NIL)
+;  RECLAIM()
+;  sayKeyedMsg("S2IZ0015",NIL)
+;  NIL
+\end{verbatim}
+
+<<defun clearCmdCompletely>>=
+(defun |clearCmdCompletely| ()
+ (progn (|clearCmdAll|)
+  (spadlet |$localExposureData| (copy-seq |$localExposureDataDefault|))
+  (spadlet |$xdatabase| nil)
+  (spadlet |$CatOfCatDatabase| nil)
+  (spadlet |$DomOfCatDatabase| nil)
+  (spadlet |$JoinOfCatDatabase| nil)
+  (spadlet |$JoinOfDomDatabase| nil)
+  (spadlet |$attributeDb| nil)
+  (spadlet |$functionTable| nil)
+  (|sayKeyedMsg| 's2iz0013 nil)
+  (|clearClams|)
+  (|clearConstructorCaches|)
+  (spadlet |$existingFiles| (make-hashtable 'UEQUAL))
+  (|sayKeyedMsg| 's2iz0014 nil)
+  (reclaim)
+  (|sayKeyedMsg| 's2iz0015 nil)
+  nil)) 
+
+@
+
+\subsection{defun clearCmdAll}
+\begin{verbatim}
+;clearCmdAll() ==
+;  clearCmdSortedCaches()
+;  ------undo special variables------
+;  $frameRecord := nil
+;  $previousBindings := nil
+;  $variableNumberAlist := nil
+;  untraceMapSubNames _/TRACENAMES
+;  $InteractiveFrame := LIST LIST NIL
+;  resetInCoreHist()
+;  if $useInternalHistoryTable
+;    then $internalHistoryTable := NIL
+;    else deleteFile histFileName()
+;  $IOindex := 1
+;  updateCurrentInterpreterFrame()
+;  $currentLine := '")clear all"    --restored 3/94; needed for undo (RDJ)
+;  clearMacroTable()
+;  if $frameMessages then sayKeyedMsg("S2IZ0011",[$interpreterFrameName])
+;  else sayKeyedMsg("S2IZ0012",NIL)
+\end{verbatim}
+
+<<defun clearCmdAll>>=
+(defun |clearCmdAll| ()
+ (progn
+  (|clearCmdSortedCaches|)
+  (spadlet |$frameRecord| nil)
+  (spadlet |$previousBindings| nil)
+  (spadlet |$variableNumberAlist| nil)
+  (|untraceMapSubNames| /tracenames)
+  (spadlet |$InteractiveFrame| (list (list nil)))
+  (|resetInCoreHist|)
+  (cond
+   (|$useInternalHistoryTable| (spadlet |$internalHistoryTable| nil))
+   (t (|deleteFile| (|histFileName|))))
+  (spadlet |$IOindex| 1)
+  (|updateCurrentInterpreterFrame|)
+  (spadlet |$currentLine| ")clear all")
+  (|clearMacroTable|)
+  (cond 
+   (|$frameMessages|
+     (|sayKeyedMsg| 's2iz0011 (cons |$interpreterFrameName| nil)))
+   (t (|sayKeyedMsg| 's2iz0012 nil))))) 
+
+@
+
+\subsection{defun clearCmdExcept}
+\begin{verbatim}
+;clearCmdExcept(l is [opt,:vl]) ==
+;  --clears elements of vl of all options EXCEPT opt
+;  for option in $clearOptions |
+;    ^stringPrefix?(object2String opt,object2String option)
+;      repeat clearCmdParts [option,:vl]
+\end{verbatim}
+
+<<defun clearCmdExcept>>=
+(defun |clearCmdExcept| (arg)
+ (prog (opt vl)
+  (return
+   (seq
+    (progn
+     (spadlet opt (car arg))
+     (spadlet vl (cdr arg))
+     (do ((t0 |$clearOptions| (cdr t0)) (option nil))
+         ((or (atom t0) (progn (setq option (car t0)) nil)) nil)
+      (seq
+       (exit
+        (cond
+         ((null 
+           (|stringPrefix?| 
+            (|object2String| opt) 
+            (|object2String| option)))
+           (|clearCmdParts| (cons option vl)))))))))))) 
+
+@
+
+\subsection{defun clearCmdParts}
+\begin{verbatim}
+;clearCmdParts(l is [opt,:vl]) ==
+;  -- clears the bindings indicated by opt of all variables in vl
+;  option:= selectOptionLC(opt,$clearOptions,'optionError)
+;  option:= INTERN PNAME option
+;  -- the option can be plural but the key in the alist is sometimes
+;  -- singular
+;  option :=
+;    option = 'types =>  'mode
+;    option = 'modes =>  'mode
+;    option = 'values => 'value
+;    option
+;  null vl => sayKeyedMsg("S2IZ0055",NIL)
+;  pmacs := getParserMacroNames()
+;  imacs := getInterpMacroNames()
+;  if vl='(all) then
+;    vl := ASSOCLEFT CAAR $InteractiveFrame
+;    vl := REMDUP(append(vl, pmacs))
+;  $e : local := $InteractiveFrame
+;  for x in vl repeat
+;    clearDependencies(x,true)
+;    if option='properties and x in pmacs then clearParserMacro(x)
+;    if option='properties and x in imacs and ^(x in pmacs) then
+;        sayMessage ['"   You cannot clear the definition of the system-defined macro ",
+;            fixObjectForPrinting x,"."]
+;    p1 := ASSOC(x,CAAR $InteractiveFrame) =>
+;      option='properties =>
+;        if isMap x then
+;          (lm := get(x,'localModemap,$InteractiveFrame)) =>
+;            PAIRP lm => untraceMapSubNames [CADAR lm]
+;          NIL
+;        for p2 in CDR p1 repeat
+;          prop:= CAR p2
+;          recordOldValue(x,prop,CDR p2)
+;          recordNewValue(x,prop,NIL)
+;        SETF(CAAR $InteractiveFrame,deleteAssoc(x,CAAR $InteractiveFrame))
+;      p2:= ASSOC(option,CDR p1) =>
+;        recordOldValue(x,option,CDR p2)
+;        recordNewValue(x,option,NIL)
+;        RPLACD(p2,NIL)
+;  nil
+\end{verbatim}
+
+<<defun clearCmdParts>>=
+(defun |clearCmdParts| (arg)
+ (prog (|$e| |opt| |option| |pmacs| |imacs| |vl| |p1| |lm| |prop| |p2|)
+  (declare (special |$e|))
+  (return
+   (seq
+    (progn
+     (spadlet |opt| (car arg))
+     (spadlet |vl| (cdr arg))
+     (spadlet |option| (|selectOptionLC| |opt| |$clearOptions| '|optionError|))
+     (spadlet |option| (intern (pname |option|)))
+     (spadlet |option|
+      (cond 
+       ((boot-equal |option| '|types|) '|mode|)
+       ((boot-equal |option| '|modes|) '|mode|)
+       ((boot-equal |option| '|values|) '|value|)
+       (t |option|)))
+     (cond
+      ((null |vl|) (|sayKeyedMsg| 's2iz0055 nil))
+      (t
+       (spadlet |pmacs| (|getParserMacroNames|))
+       (spadlet |imacs| (|getInterpMacroNames|))
+       (cond
+        ((boot-equal |vl| '(|all|))
+         (spadlet |vl| (assocleft (caar |$InteractiveFrame|)))
+         (spadlet |vl| (remdup (append |vl| |pmacs|)))))
+       (spadlet |$e| |$InteractiveFrame|)
+       (do ((t0 |vl| (cdr t0)) (|x| nil))
+           ((or (atom t0) (progn (setq |x| (car t0)) nil)) nil)
+        (seq
+         (exit
+          (progn
+           (|clearDependencies| |x| t)
+           (cond
+            ((and (boot-equal |option| '|properties|) (|member| |x| |pmacs|))
+              (|clearParserMacro| |x|)))
+           (cond 
+            ((and (boot-equal |option| '|properties|) 
+                  (|member| |x| |imacs|)
+                  (null (|member| |x| |pmacs|)))
+             (|sayMessage| (cons 
+              "   You cannot clear the definition of the system-defined macro "
+               (cons (|fixObjectForPrinting| |x|) 
+                     (cons (intern "." "BOOT") nil))))))
+           (cond
+            ((spadlet |p1| (|assoc| |x| (caar |$InteractiveFrame|)))
+             (cond
+              ((boot-equal |option| '|properties|)
+               (cond
+                ((|isMap| |x|)
+                 (seq
+                  (cond
+                   ((spadlet |lm| 
+                     (|get| |x| '|localModemap| |$InteractiveFrame|))
+                    (cond
+                     ((pairp |lm|)
+                     (exit (|untraceMapSubNames| (cons (cadar |lm|) nil))))))
+                   (t nil)))))
+               (do ((t1 (cdr |p1|) (cdr t1)) (|p2| nil))
+                   ((or (atom t1) (progn (setq |p2| (car t1)) nil)) nil)
+                (seq
+                 (exit
+                  (progn
+                   (spadlet |prop| (car |p2|))
+                   (|recordOldValue| |x| |prop| (cdr |p2|))
+                   (|recordNewValue| |x| |prop| nil)))))
+               (setf (caar |$InteractiveFrame|)
+                (|deleteAssoc| |x| (caar |$InteractiveFrame|))))
+              ((spadlet |p2| (|assoc| |option| (cdr |p1|)))
+               (|recordOldValue| |x| |option| (cdr |p2|))
+               (|recordNewValue| |x| |option| nil)
+               (rplacd |p2| nil)))))))))
+       nil))))))) 
+
+@
+
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{close}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@@ -11427,6 +11781,13 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun changeToNamedInterpreterFrame>>
 <<defun charDigitVal>>
 <<defun cleanupLine>>
+<<defun clear>>
+<<defun clearCmdAll>>
+<<defun clearCmdCompletely>>
+<<defun clearCmdExcept>>
+<<defun clearCmdParts>>
+<<defun clearCmdSortedCaches>>
+<<defun clearSpad2Cmd>>
 <<defun clearFrame>>
 <<defun closeInterpreterFrame>>
 <<defun compileBoot>>
diff --git a/changelog b/changelog
index 21aee6c..13496a6 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,6 @@
+20090408 tpd src/axiom-website/patches.html 20090308.02.tpd.patch
+20090308 tpd src/interp/i-syscmd.boot move clear to bookvol5
+20090308 tpd books/bookvol5 add )clear root
 20090308 tpd src/axiom-website/patches.html 20090308.01.tpd.patch
 20090308 tpd src/interp/i-syscmd.boot move abbreviation to bookvol5
 20090308 tpd books/bookvol5 add abbreviation, include roots
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index 5552b92..1d7f8eb 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -993,5 +993,7 @@ bookvol10.3 add Grabmeier/Waldek fixes to Float<br/>
 bookvol5 add trace root<br/>
 <a href="patches/20090308.01.tpd.patch">20090308.01.tpd.patch</a>
 bookvol5 add include, abbreviation roots<br/>
+<a href="patches/20090308.02.tpd.patch">20090308.02.tpd.patch</a>
+bookvol5 add clear root<br/>
  </body>
 </html>
diff --git a/src/interp/i-syscmd.boot.pamphlet b/src/interp/i-syscmd.boot.pamphlet
index dfcf93c..771c0ae 100644
--- a/src/interp/i-syscmd.boot.pamphlet
+++ b/src/interp/i-syscmd.boot.pamphlet
@@ -270,122 +270,6 @@ getSystemCommandLine() ==
 
 ------------ start of commands ------------------------------------------
 
---% )clear
-
-clear l == clearSpad2Cmd l
-
-clearSpad2Cmd l ==
-  -- new version which changes the environment and updates history
-  $clearExcept: local := nil
-  if $options then $clearExcept :=
-    "and"/[selectOptionLC(opt,'(except),'optionError) =
-             'except for [opt,:.] in $options]
-  null l =>
-    optList:= "append"/[['%l,'"       ",x] for x in $clearOptions]
-    sayKeyedMsg("S2IZ0010",[optList])
-  arg := selectOptionLC(first l,'(all completely scaches),NIL)
-  arg = 'all          => clearCmdAll()
-  arg = 'completely   => clearCmdCompletely()
-  arg = 'scaches      => clearCmdSortedCaches()
-  $clearExcept => clearCmdExcept(l)
-  clearCmdParts(l)
-  updateCurrentInterpreterFrame()
-
-clearCmdSortedCaches() ==
-  $lookupDefaults: local := false
-  for [.,.,:domain] in HGET($ConstructorCache,'SortedCache) repeat
-    pair := compiledLookupCheck('clearCache,[$Void],domain)
-    SPADCALL pair
-
-clearCmdCompletely() ==
-  clearCmdAll()
-  $localExposureData := COPY_-SEQ $localExposureDataDefault
-  $xdatabase := NIL
-  $CatOfCatDatabase  := NIL
-  $DomOfCatDatabase  := NIL
-  $JoinOfCatDatabase := NIL
-  $JoinOfDomDatabase := NIL
-  $attributeDb := NIL
-  $functionTable := NIL
-  sayKeyedMsg("S2IZ0013",NIL)
-  clearClams()
-  clearConstructorCaches()
-  $existingFiles := MAKE_-HASHTABLE 'UEQUAL
-  sayKeyedMsg("S2IZ0014",NIL)
-  RECLAIM()
-  sayKeyedMsg("S2IZ0015",NIL)
-  NIL
-
-clearCmdAll() ==
-  clearCmdSortedCaches()
-  ------undo special variables------
-  $frameRecord := nil
-  $previousBindings := nil
-  $variableNumberAlist := nil
-  untraceMapSubNames _/TRACENAMES
-  $InteractiveFrame := LIST LIST NIL
-  resetInCoreHist()
-  if $useInternalHistoryTable
-    then $internalHistoryTable := NIL
-    else deleteFile histFileName()
-  $IOindex := 1
-  updateCurrentInterpreterFrame()
-  $currentLine := '")clear all"    --restored 3/94; needed for undo (RDJ)
-  clearMacroTable()
-  if $frameMessages then sayKeyedMsg("S2IZ0011",[$interpreterFrameName])
-  else sayKeyedMsg("S2IZ0012",NIL)
-
-clearCmdExcept(l is [opt,:vl]) ==
-  --clears elements of vl of all options EXCEPT opt
-  for option in $clearOptions |
-    ^stringPrefix?(object2String opt,object2String option)
-      repeat clearCmdParts [option,:vl]
-
-clearCmdParts(l is [opt,:vl]) ==
-  -- clears the bindings indicated by opt of all variables in vl
-
-  option:= selectOptionLC(opt,$clearOptions,'optionError)
-  option:= INTERN PNAME option
-
-  -- the option can be plural but the key in the alist is sometimes
-  -- singular
-
-  option :=
-    option = 'types =>  'mode
-    option = 'modes =>  'mode
-    option = 'values => 'value
-    option
-
-  null vl => sayKeyedMsg("S2IZ0055",NIL)
-  pmacs := getParserMacroNames()
-  imacs := getInterpMacroNames()
-  if vl='(all) then
-    vl := ASSOCLEFT CAAR $InteractiveFrame
-    vl := REMDUP(append(vl, pmacs))
-  $e : local := $InteractiveFrame
-  for x in vl repeat
-    clearDependencies(x,true)
-    if option='properties and x in pmacs then clearParserMacro(x)
-    if option='properties and x in imacs and ^(x in pmacs) then
-        sayMessage ['"   You cannot clear the definition of the system-defined macro ",
-            fixObjectForPrinting x,"."]
-    p1 := ASSOC(x,CAAR $InteractiveFrame) =>
-      option='properties =>
-        if isMap x then
-          (lm := get(x,'localModemap,$InteractiveFrame)) =>
-            PAIRP lm => untraceMapSubNames [CADAR lm]
-          NIL
-        for p2 in CDR p1 repeat
-          prop:= CAR p2
-          recordOldValue(x,prop,CDR p2)
-          recordNewValue(x,prop,NIL)
-        SETF(CAAR $InteractiveFrame,deleteAssoc(x,CAAR $InteractiveFrame))
-      p2:= ASSOC(option,CDR p1) =>
-        recordOldValue(x,option,CDR p2)
-        recordNewValue(x,option,NIL)
-        RPLACD(p2,NIL)
-  nil
-
 --% )close
 
 queryClients () ==



From MAILER-DAEMON Mon Mar 09 16:39:58 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LgmGT-00061m-Q2
	for mharc-axiom-developer@gnu.org; Mon, 09 Mar 2009 16:39:57 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LgmGQ-0005zy-Ti
	for axiom-developer@nongnu.org; Mon, 09 Mar 2009 16:39:55 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LgmGI-0005vn-35
	for axiom-developer@nongnu.org; Mon, 09 Mar 2009 16:39:53 -0400
Received: from [199.232.76.173] (port=44783 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LgmGH-0005vk-Ud
	for axiom-developer@nongnu.org; Mon, 09 Mar 2009 16:39:46 -0400
Received: from mx20.gnu.org ([199.232.41.8]:2813)
	by monty-python.gnu.org with esmtps (TLS-1.0:RSA_AES_256_CBC_SHA1:32)
	(Exim 4.60) (envelope-from <daly@axiom-developer.org>)
	id 1Lgls4-0007sV-Bn
	for axiom-developer@nongnu.org; Mon, 09 Mar 2009 16:14:46 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]
	helo=axiom-developer.org) by mx20.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LgW8F-0002j3-4l
	for axiom-developer@nongnu.org; Sun, 08 Mar 2009 23:26:23 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n293OMug027780;
	Sun, 8 Mar 2009 21:24:22 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n293OJ6O027774;
	Sun, 8 Mar 2009 21:24:19 -0600
Date: Sun, 8 Mar 2009 21:24:19 -0600
Message-Id: <200903090324.n293OJ6O027774@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by mx20.gnu.org: Linux 2.6? (barebone, rare!)
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6,
	seldom 2.4 (older, 4)
Cc: 
Subject: [Axiom-developer] 20090308.03.tpd.patch (bookvol5 move summary,
	copyright, help roots)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 09 Mar 2009 20:39:55 -0000

Move more roots into book volume 5 with rewrites from boot to lisp.

=======================================================================
diff --git a/books/bookvol5.pamphlet b/books/bookvol5.pamphlet
index 8f4470a..f1a64a2 100644
--- a/books/bookvol5.pamphlet
+++ b/books/bookvol5.pamphlet
@@ -1990,9 +1990,9 @@ system function and constructor caches.
 \end{list}
 \par\noindent{\bf Command Description:}
 
-This command is used to close down interpreter client processes.
-Such processes are started by HyperDoc to run Axiom examples
-when you click on their text. When you have finished examining or modifying the
+This command is used to close down interpreter client processes.  Such
+processes are started by HyperDoc to run Axiom examples when you click
+on their text. When you have finished examining or modifying the
 example and you do not want the extra window around anymore, issue
 \begin{verbatim}
 )close
@@ -2000,9 +2000,8 @@ example and you do not want the extra window around anymore, issue
 to the Axiom prompt in the window.
 
 If you try to close down the last remaining interpreter client
-process, Axiom will offer to close down the entire Axiom
-session and return you to the operating system by displaying something
-like
+process, Axiom will offer to close down the entire Axiom session and
+return you to the operating system by displaying something like
 \begin{verbatim}
    This is the last AXIOM session. Do you want to kill AXIOM?
 \end{verbatim}
@@ -2017,6 +2016,92 @@ the entire Axiom session.
 \fnref{quit} and 
 \fnref{pquit}
 
+\subsection{defun queryClients}
+Returns the number of active scratchpad clients
+<<defun queryClients>>=
+(defun |queryClients| ()
+ (progn
+  (|sockSendInt| |$SessionManager| |$QueryClients|)
+  (|sockGetInt| |$SessionManager|))) 
+
+@
+
+\section{defun close}
+\begin{verbatim}
+;close args ==
+;  $saturn =>
+;    sayErrorly('"Obsolete system command", _
+;      ['" The )close  system command is obsolete in this version of AXIOM.",
+;       '" Please use Close from the File menu instead."])
+;  quiet:local:= false
+;  null $SpadServer =>
+;    throwKeyedMsg('"S2IZ0071", [])
+;  numClients := queryClients()
+;  numClients > 1 =>
+;    sockSendInt($SessionManager, $CloseClient)
+;    sockSendInt($SessionManager, $currentFrameNum)
+;    closeInterpreterFrame(NIL)
+;  for [opt,:.] in $options repeat
+;    fullopt := selectOptionLC(opt, '(quiet), 'optionError)
+;    fullopt = 'quiet   =>
+;           quiet:=true
+;  quiet =>
+;    sockSendInt($SessionManager, $CloseClient)
+;    sockSendInt($SessionManager, $currentFrameNum)
+;    closeInterpreterFrame(NIL)
+;  x := UPCASE queryUserKeyedMsg('"S2IZ0072", nil)
+;  MEMQ(STRING2ID_-N(x,1), '(YES Y)) =>
+;    BYE()
+;  nil
+\end{verbatim}
+
+<<defun close>>=
+(defun |close| (args)
+ (prog (numClients opt fullopt quiet x)
+  (return
+   (seq
+    (cond
+     (|$saturn|
+      (|sayErrorly| "Obsolete system command" (cons 
+       " The )close  system command is obsolete in this version of AXIOM."
+       (cons " Please use Close from the File menu instead." nil))))
+     (t
+      (spadlet quiet nil)
+      (cond
+       ((null |$SpadServer|) (|throwKeyedMsg| 's2iz0071 nil))
+       (t
+        (spadlet numClients (|queryClients|))
+        (cond
+         ((> numClients 1)
+           (|sockSendInt| |$SessionManager| |$CloseClient|)
+           (|sockSendInt| |$SessionManager| |$currentFrameNum|)
+           (|closeInterpreterFrame| NIL))
+         (t
+          (do ((t0 |$options| (cdr t0)) (t1 nil))
+              ((or (atom t0) 
+                   (progn (setq t1 (car t0)) nil)
+                   (progn (progn (spadlet opt (car t1)) t1) nil))
+                 nil)
+           (seq
+            (exit
+             (progn
+              (spadlet fullopt
+                (|selectOptionLC| opt '(|quiet|) '|optionError|))
+              (cond ((boot-equal fullopt '|quiet|)
+               (spadlet quiet t)))))))
+          (cond
+           (quiet
+            (|sockSendInt| |$SessionManager| |$CloseClient|)
+            (|sockSendInt| |$SessionManager| |$currentFrameNum|)
+            (|closeInterpreterFrame| NIL))
+           (t
+            (spadlet x (upcase (|queryUserKeyedMsg| 's2iz0072 nil)))
+            (cond
+             ((memq (string2id-n x 1) '(yes y)) (bye))
+             (t nil)))))))))))))) 
+
+@
+
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{compiler}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@@ -2331,14 +2416,722 @@ The value of the {\tt )set break} variable then controls what happens.
 {\tt )edit}, and 
 {\tt )library}
 
+\subsection{defun compiler}
+\begin{verbatim}
+;compiler args ==
+;    $newConlist: local := nil    --reset by compDefineLisplib and astran
+;    null args and null $options and null _/EDITFILE => helpSpad2Cmd '(compiler)
+;    if null args then args := [_/EDITFILE]
+;    -- first see if the user has explicitly specified the compiler
+;    -- to use.
+;    optlist := '(new old translate constructor)
+;    haveNew := nil
+;    haveOld := nil
+;    for opt in $options while ^(haveNew and haveOld) repeat
+;        [optname,:optargs] := opt
+;        fullopt := selectOptionLC(optname,optlist,nil)
+;        fullopt = 'new => haveNew := true
+;        fullopt = 'translate => haveOld := true
+;        fullopt = 'constructor => haveOld := true
+;        fullopt = 'old => haveOld := true
+;    haveNew and haveOld => throwKeyedMsg("S2IZ0081", nil)
+;    af  := pathname args
+;    aft := pathnameType af
+;-- Whats this for? MCD/PAB 21-9-95
+;--    if haveNew and (null(aft) or (aft = '"")) then
+;--        af := pathname [af, '"as"]
+;--        aft = '"as"
+;--    if haveOld and (null(aft) or (aft = '"")) then
+;--        af := pathname [af, '"spad"]
+;--        aft = '"spad"
+;    haveNew or (aft = '"as")   =>
+;        not (af1 := $FINDFILE (af, '(as))) =>
+;            throwKeyedMsg("S2IL0003",[NAMESTRING af])
+;        compileAsharpCmd [af1]
+;    haveOld or (aft = '"spad") =>
+;        not (af1 := $FINDFILE (af, '(spad))) =>
+;            throwKeyedMsg("S2IL0003",[NAMESTRING af])
+;        compileSpad2Cmd  [af1]
+;    aft = '"lsp"   =>
+;        not (af1 := $FINDFILE (af, '(lsp))) =>
+;            throwKeyedMsg("S2IL0003",[NAMESTRING af])
+;        compileAsharpLispCmd [af1]
+;    aft = '"nrlib"  =>
+;        not (af1 := $FINDFILE (af, '(nrlib))) =>
+;            throwKeyedMsg("S2IL0003",[NAMESTRING af])
+;        compileSpadLispCmd [af1]
+;    aft = '"ao"   =>
+;        not (af1 := $FINDFILE (af, '(ao))) =>
+;            throwKeyedMsg("S2IL0003",[NAMESTRING af])
+;        compileAsharpCmd [af1]
+;    aft = '"al"   =>    -- archive library of .ao files
+;        not (af1 := $FINDFILE (af, '(al))) =>
+;            throwKeyedMsg("S2IL0003",[NAMESTRING af])
+;        compileAsharpArchiveCmd [af1]
+;    -- see if we something with the appropriate file extension
+;    -- lying around
+;    af1 := $FINDFILE (af, '(as spad ao asy))
+;    af1 and pathnameType(af1) = '"as"   => compileAsharpCmd [af1]
+;    af1 and pathnameType(af1) = '"ao"  => compileAsharpCmd [af1]
+;    af1 and pathnameType(af1) = '"spad" => compileSpad2Cmd  [af1]
+;    af1 and pathnameType(af1) = '"asy"  => compileAsharpArchiveCmd [af1]
+;    -- maybe /EDITFILE has some stuff that can help us
+;    ef := pathname _/EDITFILE
+;    ef := mergePathnames(af,ef)
+;    ef = af => throwKeyedMsg("S2IZ0039", nil)
+;    af := ef
+;    pathnameType(af) = '"as"   => compileAsharpCmd args
+;    pathnameType(af) = '"ao"  => compileAsharpCmd args
+;    pathnameType(af) = '"spad" => compileSpad2Cmd  args
+;    -- see if we something with the appropriate file extension
+;    -- lying around
+;    af1 := $FINDFILE (af, '(as spad ao asy))
+;    af1 and pathnameType(af1) = '"as"   => compileAsharpCmd [af1]
+;    af1 and pathnameType(af1) = '"ao"  => compileAsharpCmd [af1]
+;    af1 and pathnameType(af1) = '"spad" => compileSpad2Cmd  [af1]
+;    af1 and pathnameType(af1) = '"asy"  => compileAsharpArchiveCmd [af1]
+;    throwKeyedMsg("S2IZ0039", nil)
+\end{verbatim}
+
+<<defun compiler>>=
+(defun |compiler| (args)
+ (prog (|$newConlist| optlist optname optargs fullopt havenew haveold 
+        aft ef af af1)
+  (declare (special |$newConlist|))
+  (return
+   (seq
+    (progn
+     (spadlet |$newConlist| nil)
+     (cond
+      ((and (null args) (null |$options|) (null /editfile))
+        (|helpSpad2Cmd| '(|compiler|)))
+      (t
+       (cond ((null args) (spadlet args (cons /editfile nil))))
+       (spadlet optlist '(|new| |old| |translate| |constructor|))
+       (spadlet havenew nil)
+       (spadlet haveold nil)
+       (do ((t0 |$options| (CDR t0)) (|opt| NIL))
+           ((or (atom t0) 
+                (progn (setq |opt| (car t0)) nil)
+                (null (null (and havenew haveold))))
+             nil)
+        (seq
+         (exit
+          (progn
+           (spadlet optname (car |opt|))
+           (spadlet optargs (cdr |opt|))
+           (spadlet fullopt (|selectOptionLC| optname optlist nil))
+           (cond
+            ((boot-equal fullopt '|new|) (spadlet havenew t))
+            ((boot-equal fullopt '|translate|) (spadlet haveold t))
+            ((boot-equal fullopt '|constructor|) (spadlet haveold t))
+            ((boot-equal fullopt '|old|) (spadlet haveold t)))))))
+       (cond
+        ((and havenew haveold) (|throwKeyedMsg| 's2iz0081 nil))
+        (t
+         (spadlet af (|pathname| args))
+         (spadlet aft (|pathnameType| af))
+         (cond
+          ((or havenew (boot-equal aft "as"))
+           (cond
+            ((null (spadlet af1 ($findfile af '(|as|))))
+             (|throwKeyedMsg| 's2il0003 (cons (namestring af) nil)))
+            (t
+             (|compileAsharpCmd| (cons af1 nil)))))
+          ((or haveold (boot-equal aft "spad"))
+           (cond
+            ((null (spadlet af1 ($findfile af '(|spad|))))
+              (|throwKeyedMsg| 's2il0003 (cons (namestring af) nil)))
+            (t
+              (|compileSpad2Cmd| (cons af1 nil)))))
+          ((boot-equal aft "lsp")
+           (cond
+            ((null (spadlet af1 ($findfile af '(|lsp|))))
+             (|throwKeyedMsg| 's2il0003 (cons (namestring af) nil)))
+            (t
+             (|compileAsharpLispCmd| (CONS af1 NIL)))))
+          ((boot-equal aft "nrlib")
+           (cond
+            ((null (spadlet af1 ($findfile af '(|nrlib|))))
+             (|throwKeyedMsg| 'S2IL0003 (cons (namestring af) nil)))
+            (t
+             (|compileSpadLispCmd| (cons af1 nil)))))
+          ((boot-equal aft "ao")
+           (cond
+            ((null (spadlet af1 ($findfile af '(|ao|))))
+             (|throwKeyedMsg| 's2il0003 (cons (namestring af) nil)))
+            (t (|compileAsharpCmd| (cons af1 nil)))))
+          ((boot-equal aft "al")
+           (cond
+            ((null (spadlet af1 ($findfile af '(|al|))))
+             (|throwKeyedMsg| 's2il0003 (cons (namestring af) nil)))
+            (t (|compileAsharpArchiveCmd| (cons af1 nil)))))
+          (t
+           (spadlet af1 ($findfile af '(|as| |spad| |ao| |asy|)))
+           (cond
+            ((and af1 (boot-equal (|pathnameType| af1) "as"))
+             (|compileAsharpCmd| (CONS af1 NIL)))
+            ((and af1 (boot-equal (|pathnameType| af1) "ao"))
+             (|compileAsharpCmd| (CONS af1 NIL)))
+            ((and af1 (boot-equal (|pathnameType| af1) "spad"))
+             (|compileSpad2Cmd| (CONS af1 NIL)))
+            ((and af1 (boot-equal (|pathnameType| af1) "asy"))
+             (|compileAsharpArchiveCmd| (CONS af1 NIL)))
+            (t
+             (spadlet ef (|pathname| /editfile))
+             (spadlet ef (|mergePathnames| af ef))
+             (cond
+              ((boot-equal ef af) (|throwKeyedMsg| 's2iz0039 nil))
+              (t
+               (spadlet af ef)
+               (cond
+                ((boot-equal (|pathnameType| af) "as")
+                 (|compileAsharpCmd| args))
+                ((boot-equal (|pathnameType| af) "ao")
+                 (|compileAsharpCmd| args))
+                ((boot-equal (|pathnameType| af) "spad")
+                 (|compileSpad2Cmd| args))
+                (t
+                 (spadlet af1 ($findfile af '(|as| |spad| |ao| |asy|)))
+                 (cond
+                  ((and af1 (boot-equal (|pathnameType| af1) "as"))
+                    (|compileAsharpCmd| (CONS af1 NIL)))
+                  ((and af1 (boot-equal (|pathnameType| af1) "ao"))
+                    (|compileAsharpCmd| (CONS af1 NIL)))
+                  ((and af1 (boot-equal (|pathnameType| af1) "spad"))
+                    (|compileSpad2Cmd| (CONS af1 NIL)))
+                  ((and af1 (boot-equal (|pathnameType| af1) "asy"))
+                   (|compileAsharpArchiveCmd| (CONS af1 NIL)))
+                  (t (|throwKeyedMsg| 's2iz0039 nil)))))))))))))))))))) 
+
+@
+
+\subsection{defun compileAsharpCmd} 
+<<defun compileAsharpCmd>>=
+(defun |compileAsharpCmd| (args)
+  (|compileAsharpCmd1| args)
+  (|terminateSystemCommand|)
+  (|spadPrompt|))
+
+@
+
+\subsection{defun compileAsharpCmd1}
+\begin{verbatim}
+;compileAsharpCmd1 args ==
+;    -- Assume we entered from the "compiler" function, so args ^= nil
+;    -- and is a file with file extension .as or .ao
+;    path := pathname args
+;    pathType := pathnameType path
+;    (pathType ^= '"as") and (pathType ^= '"ao") => throwKeyedMsg("S2IZ0083", nil)
+;    ^PROBE_-FILE path => throwKeyedMsg("S2IL0003",[namestring args])
+;    SETQ(_/EDITFILE, path)
+;    updateSourceFiles path
+;    optList :=  '( _
+;      new _
+;      old _
+;      translate _
+;      onlyargs _
+;      moreargs _
+;      quiet _
+;      nolispcompile _
+;      noquiet _
+;      library _
+;      nolibrary _
+;        )
+;    beQuiet := false         -- be verbose here
+;    doLibrary  := true       -- so a )library after compilation
+;    doCompileLisp := true    -- do compile generated lisp code
+;    moreArgs := NIL
+;    onlyArgs := NIL
+;    for opt in $options repeat
+;        [optname,:optargs] := opt
+;        fullopt := selectOptionLC(optname,optList,nil)
+;        fullopt = 'new       => nil
+;        fullopt = 'old       => error "Internal error: compileAsharpCmd got )old"
+;        fullopt = 'translate => error "Internal error: compileAsharpCmd got )translate"
+;        fullopt = 'quiet     => beQuiet := true
+;        fullopt = 'noquiet   => beQuiet := false
+;        fullopt = 'nolispcompile   => doCompileLisp := false
+;        fullopt = 'moreargs  => moreArgs := optargs
+;        fullopt = 'onlyargs  => onlyArgs := optargs
+;        fullopt = 'library   => doLibrary  := true
+;        fullopt = 'nolibrary => doLibrary  := false
+;        throwKeyedMsg("S2IZ0036",[STRCONC('")",object2String optname)])
+;    tempArgs :=
+;        pathType = '"ao" =>
+;            -- want to strip out -Fao
+;            (p := STRPOS('"-Fao", $asharpCmdlineFlags, 0, NIL)) =>
+;                p = 0 => SUBSTRING($asharpCmdlineFlags, 5, NIL)
+;                STRCONC(SUBSTRING($asharpCmdlineFlags, 0, p), '" ",
+;                    SUBSTRING($asharpCmdlineFlags, p+5, NIL))
+;            $asharpCmdlineFlags
+;        $asharpCmdlineFlags
+;    asharpArgs :=
+;        onlyArgs =>
+;            s := ""
+;            for a in onlyArgs repeat
+;                s := STRCONC(s, '" ", object2String a)
+;            s
+;        moreArgs =>
+;            s := tempArgs
+;            for a in moreArgs repeat
+;                s := STRCONC(s, '" ", object2String a)
+;            s
+;        tempArgs
+;    if ^beQuiet then sayKeyedMsg("S2IZ0038A",[namestring args, asharpArgs])
+;    command :=
+;     STRCONC(STRCONC(GETENV('"ALDORROOT"),'"/bin/"),_
+;               "aldor ", asharpArgs, '" ", namestring args)
+;    rc := OBEY command
+;    if (rc = 0) and doCompileLisp then
+;        lsp := fnameMake('".", pathnameName args, '"lsp")
+;        if fnameReadable?(lsp) then
+;            if ^beQuiet then sayKeyedMsg("S2IZ0089", [namestring lsp])
+;            compileFileQuietly(lsp)
+;        else
+;            sayKeyedMsg("S2IL0003", [namestring lsp])
+;    if rc = 0 and doLibrary then
+;        -- do we need to worry about where the compilation output went?
+;        if ^beQuiet then sayKeyedMsg("S2IZ0090", [ pathnameName path ])
+;        withAsharpCmd [ pathnameName path ]
+;    else if ^beQuiet then
+;        sayKeyedMsg("S2IZ0084", nil)
+;    extendLocalLibdb $newConlist
+\end{verbatim}
+
+<<defun compileAsharpCmd1>>=
+(defun |compileAsharpCmd1| (args)
+ (prog (path pathtype optlist optname optargs fullopt bequiet docompilelisp 
+        moreargs onlyargs dolibrary p tempargs s asharpargs command rc lsp)
+   (return
+    (seq
+     (progn
+      (spadlet path (|pathname| args))
+      (spadlet pathtype (|pathnameType| path))
+      (cond
+      ((and (nequal pathtype "as") (nequal pathtype "ao"))
+        (|throwKeyedMsg| 's2iz0083 nil))
+      ((null (probe-file path))
+        (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil)))
+      (t
+       (setq /editfile path)
+       (|updateSourceFiles| path)
+       (spadlet optlist
+        '(|new| |old| |translate| |onlyargs| |moreargs| |quiet| 
+          |nolispcompile| |noquiet| |library| |nolibrary|))
+       (spadlet bequiet nil)
+       (spadlet dolibrary t)
+       (spadlet docompilelisp t)
+       (spadlet moreargs nil)
+       (spadlet onlyargs nil)
+       (do ((t0 |$options| (cdr t0)) (|opt| nil))
+           ((or (atom t0) (progn (setq |opt| (car t0)) nil)) nil)
+        (seq
+         (exit
+          (progn
+           (spadlet optname (car |opt|))
+           (spadlet optargs (cdr |opt|))
+           (spadlet fullopt (|selectOptionLC| optname optlist nil))
+           (cond
+            ((boot-equal fullopt '|new|) nil)
+            ((boot-equal fullopt '|old|)
+             (|error| '|Internal error: compileAsharpCmd got )old|))
+            ((boot-equal fullopt '|translate|)
+             (|error| '|Internal error: compileAsharpCmd got )translate|))
+            ((boot-equal fullopt '|quiet|) (spadlet bequiet t))
+            ((boot-equal fullopt '|noquiet|) (spadlet bequiet nil))
+            ((boot-equal fullopt '|nolispcompile|) 
+              (spadlet docompilelisp nil))
+            ((boot-equal fullopt '|moreargs|) (spadlet moreargs optargs))
+            ((boot-equal fullopt '|onlyargs|) (spadlet onlyargs optargs))
+            ((boot-equal fullopt '|library|) (spadlet dolibrary t))
+            ((boot-equal fullopt '|nolibrary|) (spadlet dolibrary nil))
+            (t 
+             (|throwKeyedMsg| 's2iz0036
+              (cons (strconc ")" (|object2String| optname)) nil))))))))
+       (spadlet tempargs
+        (cond
+         ((boot-equal pathtype "ao")
+          (cond
+           ((spadlet p (strpos "-Fao" |$asharpCmdlineFlags| 0 nil))
+            (cond
+             ((eql p 0) (substring |$asharpCmdlineFlags| 5 nil))
+             (t
+              (strconc (substring |$asharpCmdlineFlags| 0 p) 
+                " " (substring |$asharpCmdlineFlags| (plus p 5) nil)))))
+           (t |$asharpCmdlineFlags|)))
+         (t |$asharpCmdlineFlags|)))
+       (spadlet asharpargs
+        (cond
+         (onlyargs
+          (spadlet s '||)
+          (do ((t1 onlyargs (cdr t1)) (|a| nil))
+              ((or (atom t1) (progn (setq |a| (car t1)) nil)) nil)
+           (seq
+            (exit
+             (spadlet s (strconc s " " (|object2String| |a|))))))
+          s)
+         (moreargs
+          (spadlet s tempargs)
+          (do ((t2 moreargs (cdr t2)) (|a| nil))
+              ((or (atom t2) (progn (setq |a| (car t2)) nil)) nil)
+           (seq
+            (exit
+             (spadlet s (strconc s " " (|object2String| |a|))))))
+          s)
+         (t tempargs)))
+       (cond ((null bequiet)
+        (|sayKeyedMsg| 's2iz0038a 
+         (cons (|namestring| args) (cons asharpargs nil)))))
+       (spadlet command
+        (strconc
+         (strconc (getenv "ALDORROOT") "/bin/")
+         '|aldor | asharpargs " " (|namestring| args)))
+       (spadlet rc (obey command))
+       (cond
+        ((and (eql rc 0) docompilelisp)
+          (spadlet lsp (|fnameMake| "." (|pathnameName| args) "lsp"))
+          (cond
+           ((|fnameReadable?| lsp)
+            (cond
+             ((null bequiet)
+              (|sayKeyedMsg| 's2iz0089 (cons (|namestring| lsp) nil))))
+            (|compileFileQuietly| lsp))
+           (t (|sayKeyedMsg| 's2il0003 (cons (|namestring| lsp) nil))))))
+       (cond
+        ((and (eql rc 0) dolibrary)
+         (cond
+          ((null bequiet)
+            (|sayKeyedMsg| 's2iz0090 (cons (|pathnameName| path) nil))))
+         (|withAsharpCmd| (cons (|pathnameName| path) nil)))
+        ((null bequiet) (|sayKeyedMsg| 's2iz0084 nil))
+        (t nil))
+       (|extendLocalLibdb| |$newConlist|)))))))) 
+
+@
+
+\subsection{defun compileAsharpArchiveCmd}
+\begin{verbatim}
+;compileAsharpArchiveCmd args ==
+;    -- Assume we entered from the "compiler" function, so args ^= nil
+;    -- and is a file with file extension .al. We also assume that
+;    -- the name is fully qualified.
+;    path := pathname args
+;    ^PROBE_-FILE path => throwKeyedMsg("S2IL0003",[namestring args])
+;    -- here is the plan:
+;    --   1. extract the file name and try to make a directory based
+;    --      on that name.
+;    --   2. cd to that directory and ar x the .al file
+;    --   3. for each .ao file that shows up, compile it
+;    --   4. delete the generated .ao files
+;    -- First try to make the directory in the current directory
+;    dir  := fnameMake('".", pathnameName path, '"axldir")
+;    exists := PROBE_-FILE dir
+;    isDir := directoryp namestring dir
+;    exists and isDir ^= 1=>
+;        throwKeyedMsg("S2IL0027",[namestring dir, namestring args])
+;    if isDir ^= 1 then
+;        cmd  := STRCONC('"mkdir ", namestring dir)
+;        rc   := OBEY cmd
+;        rc ^= 0 => throwKeyedMsg("S2IL0027",[namestring dir, namestring args])
+;    curDir := $CURRENT_-DIRECTORY
+;    -- cd to that directory and try to unarchive the .al file
+;    cd [ object2Identifier namestring dir ]
+;    cmd := STRCONC( '"ar x ", namestring path )
+;    rc := OBEY cmd
+;    rc ^= 0 =>
+;        cd [ object2Identifier namestring curDir ]
+;        throwKeyedMsg("S2IL0028",[namestring dir, namestring args])
+;    -- Look for .ao files
+;    asos := DIRECTORY '"*.ao"
+;    null asos =>
+;        cd [ object2Identifier namestring curDir ]
+;        throwKeyedMsg("S2IL0029",[namestring dir, namestring args])
+;    -- Compile the .ao files
+;    for aso in asos repeat
+;        compileAsharpCmd1 [ namestring aso ]
+;    -- Reset the current directory
+;    cd [ object2Identifier namestring curDir ]
+;    terminateSystemCommand()
+;    spadPrompt()
+\end{verbatim}
+
+<<defun compileAsharpArchiveCmd>>=
+(defun |compileAsharpArchiveCmd| (args)
+ (prog (path dir exists isdir curdir cmd rc asos)
+  (return
+   (seq
+    (progn 
+     (spadlet path (|pathname| args))
+     (cond
+      ((null (probe-file path))
+       (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil)))
+      (t
+       (spadlet dir (|fnameMake| "." (|pathnameName| path) "axldir"))
+       (spadlet exists (probe-file dir))
+       (spadlet isdir (|directoryp| (|namestring| dir)))
+       (cond
+        ((and exists (nequal isdir 1))
+          (|throwKeyedMsg| 's2il0027
+           (cons (|namestring| dir) (cons (|namestring| args) nil))))
+        (t
+         (cond
+          ((nequal isdir 1)
+           (spadlet cmd (strconc "mkdir " (|namestring| dir)))
+           (spadlet rc (obey cmd))
+           (cond
+            ((nequal rc 0)
+             (|throwKeyedMsg| 's2il0027 
+              (cons (|namestring| dir) (cons (|namestring| args) nil)))))))
+         (spadlet curdir $current-directory)
+         (|cd| (cons (|object2Identifier| (|namestring| dir)) nil))
+         (spadlet cmd (strconc "ar x " (|namestring| path)))
+         (spadlet rc (obey cmd))
+         (cond
+          ((nequal rc 0)
+           (|cd| (cons (|object2Identifier| (|namestring| curdir)) nil))
+           (|throwKeyedMsg| 's2il0028
+            (cons (|namestring| dir) (cons (|namestring| args) nil))))
+          (t
+           (spadlet asos (directory (makestring "*.ao")))
+           (cond
+            ((null asos)
+             (|cd| (cons (|object2Identifier| (|namestring| curdir)) nil))
+             (|throwKeyedMsg| 's2il0029
+              (cons (|namestring| dir) (cons (|namestring| args) nil))))
+            (t
+             (do ((t0 asos (cdr t0)) (|aso| nil))
+                 ((or (atom t0) (progn (setq |aso| (car t0)) nil)) nil)
+              (seq
+               (exit
+                (|compileAsharpCmd1| (cons (|namestring| |aso|) nil)))))
+             (|cd| (CONS (|object2Identifier| (|namestring| curdir)) NIL))
+             (|terminateSystemCommand|)
+             (|spadPrompt|)))))))))))))) 
+
+@
+
+\subsection{defun compileAsharpLispCmd}
+\begin{verbatim}
+;compileAsharpLispCmd args ==
+;    -- Assume we entered from the "compiler" function, so args ^= nil
+;    -- and is a file with file extension .lsp
+;    path := pathname args
+;    ^PROBE_-FILE path => throwKeyedMsg("S2IL0003",[namestring args])
+;    optList :=  '( _
+;      quiet _
+;      noquiet _
+;      library _
+;      nolibrary _
+;        )
+;    beQuiet := false         -- be verbose here
+;    doLibrary  := true       -- so a )library after compilation
+;    for opt in $options repeat
+;        [optname,:optargs] := opt
+;        fullopt := selectOptionLC(optname,optList,nil)
+;        fullopt = 'quiet     => beQuiet := true
+;        fullopt = 'noquiet   => beQuiet := false
+;        fullopt = 'library   => doLibrary  := true
+;        fullopt = 'nolibrary => doLibrary  := false
+;        throwKeyedMsg("S2IZ0036",[STRCONC('")",object2String optname)])
+;    lsp := fnameMake(pathnameDirectory path, pathnameName path, pathnameType path)
+;    if fnameReadable?(lsp) then
+;        if ^beQuiet then sayKeyedMsg("S2IZ0089", [namestring lsp])
+;        compileFileQuietly(lsp)
+;    else
+;        sayKeyedMsg("S2IL0003", [namestring lsp])
+;    if doLibrary then
+;        -- do we need to worry about where the compilation output went?
+;        if ^beQuiet then sayKeyedMsg("S2IZ0090", [ pathnameName path ])
+;        withAsharpCmd [ pathnameName path ]
+;    else if ^beQuiet then
+;        sayKeyedMsg("S2IZ0084", nil)
+;    terminateSystemCommand()
+;    spadPrompt()
+\end{verbatim}
+
+<<defun compileAsharpLispCmd>>=
+(defun |compileAsharpLispCmd| (args)
+ (prog (path optlist optname optargs fullopt bequiet 
+        dolibrary lsp)
+  (return 
+   (seq 
+    (progn 
+     (spadlet path (|pathname| args))
+     (cond
+      ((null (probe-file path)) 
+         (|throwKeyedMsg| 's2il0003 (CONS (|namestring| args) NIL)))
+      (t
+       (spadlet optlist '(|quiet| |noquiet| |library| |nolibrary|))
+       (spadlet bequiet nil)
+       (spadlet dolibrary t)
+       (do ((t0 |$options| (cdr t0)) (|opt| nil))
+           ((or (atom t0) (progn (setq |opt| (car t0)) nil)) nil)
+        (seq
+         (exit
+          (progn
+           (spadlet optname (car |opt|))
+           (spadlet optargs (cdr |opt|))
+           (spadlet fullopt (|selectOptionLC| optname optlist nil))
+           (cond
+            ((boot-equal fullopt '|quiet|) (spadlet bequiet t))
+            ((boot-equal fullopt '|noquiet|) (spadlet bequiet nil))
+            ((boot-equal fullopt '|library|) (spadlet dolibrary t))
+            ((boot-equal fullopt '|nolibrary|) (spadlet dolibrary nil))
+            (t
+             (|throwKeyedMsg| 's2iz0036 
+              (cons (strconc ")" (|object2String| optname)) nil))))))))
+       (spadlet lsp
+        (|fnameMake|
+         (|pathnameDirectory| path)
+         (|pathnameName| path)
+         (|pathnameType| path)))
+       (cond
+        ((|fnameReadable?| lsp)
+         (cond
+          ((null bequiet)
+            (|sayKeyedMsg| 's2iz0089 (cons (|namestring| lsp) NIL))))
+         (|compileFileQuietly| lsp))
+        (t (|sayKeyedMsg| 's2il0003 (cons (|namestring| lsp) nil))))
+       (cond
+        (dolibrary
+         (cond
+          ((null bequiet) 
+           (|sayKeyedMsg| 's2iz0090 (cons (|pathnameName| path) nil))))
+         (|withAsharpCmd| (CONS (|pathnameName| path) NIL)))
+        ((null bequiet) (|sayKeyedMsg| 's2iz0084 nil))
+        (t nil))
+       (|terminateSystemCommand|)
+       (|spadPrompt|)))))))) 
+
+@
+
+\subsection{defun compileSpadLispCmd}
+\begin{verbatim}
+;compileSpadLispCmd args ==
+;    -- Assume we entered from the "compiler" function, so args ^= nil
+;    -- and is a file with file extension .nrlib
+;    path := pathname fnameMake(first args, '"code", '"lsp")
+;    ^PROBE_-FILE path => throwKeyedMsg("S2IL0003",[namestring args])
+;    optList :=  '( _
+;      quiet _
+;      noquiet _
+;      library _
+;      nolibrary _
+;        )
+;    beQuiet := false         -- be verbose here
+;    doLibrary  := true       -- so a )library after compilation
+;    for opt in $options repeat
+;        [optname,:optargs] := opt
+;        fullopt := selectOptionLC(optname,optList,nil)
+;        fullopt = 'quiet     => beQuiet := true
+;        fullopt = 'noquiet   => beQuiet := false
+;        fullopt = 'library   => doLibrary  := true
+;        fullopt = 'nolibrary => doLibrary  := false
+;        throwKeyedMsg("S2IZ0036",[STRCONC('")",object2String optname)])
+;    lsp := fnameMake(pathnameDirectory path, pathnameName path, pathnameType path)
+;    if fnameReadable?(lsp) then
+;        if ^beQuiet then sayKeyedMsg("S2IZ0089", [namestring lsp])
+;        --compileFileQuietly(lsp)
+;        RECOMPILE_-LIB_-FILE_-IF_-NECESSARY lsp
+;    else
+;        sayKeyedMsg("S2IL0003", [namestring lsp])
+;    if doLibrary then
+;        -- do we need to worry about where the compilation output went?
+;        if ^beQuiet then sayKeyedMsg("S2IZ0090", [ pathnameName path ])
+;        LOCALDATABASE([ pathnameName first args ],[])
+;    else if ^beQuiet then
+;        sayKeyedMsg("S2IZ0084", nil)
+;    terminateSystemCommand()
+;    spadPrompt()
+\end{verbatim}
+
+<<defun compileSpadLispCmd>>=
+(defun |compileSpadLispCmd| (args)
+ (prog (path optlist optname optargs fullopt beQuiet dolibrary lsp)
+  (return
+   (seq
+    (progn
+     (spadlet path (|pathname| (|fnameMake| (car args) "code" "lsp")))
+     (cond
+      ((null (probe-file path))
+        (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil)))
+      (t
+       (spadlet optlist '(|quiet| |noquiet| |library| |nolibrary|))
+       (spadlet beQuiet nil)
+       (spadlet dolibrary t)
+       (do ((t0 |$options| (cdr t0)) (|opt| nil))
+           ((or (atom t0) (progn (setq |opt| (car t0)) nil)) nil)
+        (seq
+         (exit
+          (progn
+           (spadlet optname (car |opt|))
+           (spadlet optargs (cdr |opt|))
+           (spadlet fullopt (|selectOptionLC| optname optlist nil))
+           (cond
+            ((boot-equal fullopt '|quiet|) (spadlet beQuiet t))
+            ((boot-equal fullopt '|noquiet|) (spadlet beQuiet nil))
+            ((boot-equal fullopt '|library|) (spadlet dolibrary t))
+            ((boot-equal fullopt '|nolibrary|) (spadlet dolibrary nil))
+            (t
+             (|throwKeyedMsg| 's2iz0036
+              (cons (strconc ")" (|object2String| optname)) nil))))))))
+       (spadlet lsp
+        (|fnameMake|
+         (|pathnameDirectory| path)
+         (|pathnameName| path)
+         (|pathnameType| path)))
+       (cond
+        ((|fnameReadable?| lsp)
+         (cond
+          ((null beQuiet)
+           (|sayKeyedMsg| 's2iz0089 (cons (|namestring| lsp) nil))))
+          (recompile-lib-file-if-necessary lsp))
+        (t
+         (|sayKeyedMsg| 's2il0003 (cons (|namestring| lsp) nil))))
+       (cond
+        (dolibrary
+         (cond
+          ((null beQuiet)
+            (|sayKeyedMsg| 's2iz0090 (cons (|pathnameName| path) nil))))
+          (localdatabase (cons (|pathnameName| (car args)) nil) nil))
+        ((null beQuiet) (|sayKeyedMsg| 's2iz0084 nil))
+        (t nil))
+       (|terminateSystemCommand|)
+       (|spadPrompt|)))))))) 
+
+@
+
+\subsection{defun withAsharpCmd}
+<<defun withAsharpCmd>>=
+(defun |withAsharpCmd| (args)
+ (let (|$options|)
+  (declare (special |$options|))
+  (localdatabase args |$options|)))
+
+@
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{copyright}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
+\subsection{defun copyright}
+<<defun copyright>>=
+(defun |copyright| ()
+ (obey (strconc "cat " (|getEnv| "AXIOM") "/lib/copyright")))
+
+@
+
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{credits}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
+\subsection{defun credits}
+<<defun credits>>=
+(defun |credits| ()
+ (mapcar #'(lambda (x) (princ x) (terpri)) credits))
+
+@
+
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{display}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@@ -3718,6 +4511,94 @@ and in HyperDoc.
 In HyperDoc, choose the {\bf Commands} item from the
 {\bf Reference} menu.
 
+\subsection{defun help}
+<<defun help>>=
+(defun |help| (l)
+ (|helpSpad2Cmd| l)) 
+
+@
+
+\subsection{defun helpSpad2Cmd}
+<<defun helpSpad2Cmd>>=
+(defun |helpSpad2Cmd| (|args|)
+ (unless (|newHelpSpad2Cmd| |args|)
+  (|sayKeyedMsg| 's2iz0025 (cons |args| nil))))
+
+@
+
+\subsection{defun newHelpSpad2Cmd}
+\begin{verbatim}
+;newHelpSpad2Cmd args ==
+;  if null args then args := ["?"]
+;  # args > 1 =>
+;    sayKeyedMsg("S2IZ0026",NIL)
+;    true
+;  sarg := PNAME first args
+;  if sarg = '"?" then args := ['help]
+;  else if sarg = '"%" then args := ['history]
+;       else if sarg = '"%%" then args := ['history]
+;  arg := selectOptionLC(first args,$SYSCOMMANDS,nil)
+;  if null arg then arg := first args
+;  if arg = 'compiler then arg := 'compile
+;  -- see if new help file exists
+;  narg := PNAME arg
+;  null (helpFile := MAKE_-INPUT_-FILENAME [narg,'HELPSPAD,'_*]) => NIL
+;  $useFullScreenHelp =>
+;    OBEY STRCONC('"$AXIOM/lib/SPADEDIT ",namestring helpFile)
+;    true
+;  filestream := MAKE_-INSTREAM(helpFile)
+;  repeat
+;    line := read_-line(filestream,false)
+;    NULL line =>
+;      SHUT filestream
+;      return true
+;    SAY line
+;  true
+\end{verbatim}
+
+<<defun newHelpSpad2Cmd>>=
+(defun |newHelpSpad2Cmd| (|args|)
+ (prog (|sarg| |arg| |narg| |helpFile| |filestream| |line|)
+  (return
+   (seq
+    (progn
+     (cond ((null |args|) (spadlet |args| (cons '? nil))))
+     (cond
+      ((> (|#| |args|) 1) (|sayKeyedMsg| 's2iz0026 nil) t)
+      (t
+       (spadlet |sarg| (pname (car |args|)))
+       (cond
+        ((boot-equal |sarg| "?") (spadlet |args| (cons '|help| nil)))
+        ((boot-equal |sarg| "%") (spadlet |args| (cons '|history| nil)))
+        ((boot-equal |sarg| "%%") (spadlet |args| (cons '|history| nil)))
+        (t nil))
+       (spadlet |arg| (|selectOptionLC| (car |args|) $syscommands nil))
+       (cond ((null |arg|) (spadlet |arg| (car |args|))))
+       (cond ((boot-equal |arg| '|compiler|) (spadlet |arg| '|compile|)))
+       (spadlet |narg| (pname |arg|))
+       (cond
+        ((null 
+          (spadlet |helpFile| 
+           (make-input-filename 
+            (cons |narg| (cons 'helpspad (cons '* nil))))))
+          nil)
+        (|$useFullScreenHelp|
+         (obey (strconc "$AXIOM/lib/SPADEDIT " (|namestring| |helpFile|))) t)
+        (t
+         (spadlet |filestream| (make-instream |helpFile|))
+         (do ()
+             (nil nil)
+          (seq
+           (exit
+            (progn
+             (spadlet |line| (|read-line| |filestream| nil))
+             (cond
+              ((null |line|) (shut |filestream|) (return t))
+              (t (say |line|)))))))
+         t))))))))) 
+
+@
+
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{history}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@@ -6748,6 +7629,13 @@ Axiom or is the directory you specified using the
 \cmdhead{summary}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
+\subsection{defun summary}
+<<defun summary>>=
+(defun |summary| (l)
+ (obey (strconc "cat " (|getEnv| "AXIOM") "/lib/summary")))
+
+@
+
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{synonym}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@@ -8043,11 +8931,11 @@ This reports the traced functions
       (prog (t0)
        (spadlet t0 nil)
        (return
-        (do ((t1 arg (cdr t1)) (|x| nil))
-            ((or (atom t1) (progn (setq |x| (car t1)) nil)) (nreverse0 t0))
+        (do ((t1 arg (cdr t1)) (x nil))
+            ((or (atom t1) (progn (setq x (car t1)) nil)) (nreverse0 t0))
          (seq
           (exit
-           (setq t0 (cons (|transTraceItem| |x|) t0))))))))
+           (setq t0 (cons (|transTraceItem| x) t0))))))))
      (|/UNTRACE,0|
       (prog (t2)
        (spadlet t2 nil)
@@ -8086,33 +8974,33 @@ This reports the traced functions
 \end{verbatim}
 
 <<defun transTraceItem>>=
-(defun |transTraceItem| (|x|)
+(defun |transTraceItem| (x)
  (prog (|$doNotAddEmptyModeIfTrue| |value| |y|)
   (declare (special |$doNotAddEmptyModeIfTrue|))
   (return
    (progn
     (spadlet |$doNotAddEmptyModeIfTrue| t)
     (cond
-     ((atom |x|)
+     ((atom x)
        (cond
-        ((and (spadlet |value| (|get| |x| '|value| |$InteractiveFrame|))
+        ((and (spadlet |value| (|get| x '|value| |$InteractiveFrame|))
               (|member| (|objMode| |value|)
                 '((|Mode|) (|Domain|) (|SubDomain| (|Domain|)))))
-          (spadlet |x| (|objVal| |value|))
+          (spadlet x (|objVal| |value|))
           (cond 
-           ((spadlet |y| (|domainToGenvar| |x|)) |y|)
-           (t |x|)))
-        ((upper-case-p (elt (stringimage |x|) 0))
-          (spadlet |y| (|unabbrev| |x|))
+           ((spadlet |y| (|domainToGenvar| x)) |y|)
+           (t x)))
+        ((upper-case-p (elt (stringimage x) 0))
+          (spadlet |y| (|unabbrev| x))
           (cond
            ((|constructor?| |y|) |y|)
            ((and (pairp |y|) (|constructor?| (car |y|))) (car |y|))
-           ((spadlet |y| (|domainToGenvar| |x|)) |y|)
-           (t |x|)))
-        (t |x|)))
-     ((vecp (car |x|)) (|transTraceItem| (|devaluate| (car |x|))))
-     ((spadlet |y| (|domainToGenvar| |x|)) |y|)
-     (t (|throwKeyedMsg| 's2it0018 (cons |x| nil)))))))) 
+           ((spadlet |y| (|domainToGenvar| x)) |y|)
+           (t x)))
+        (t x)))
+     ((vecp (car x)) (|transTraceItem| (|devaluate| (car x))))
+     ((spadlet |y| (|domainToGenvar| x)) |y|)
+     (t (|throwKeyedMsg| 's2it0018 (cons x nil)))))))) 
 
 @
 
@@ -8148,7 +9036,7 @@ This reports the traced functions
 \end{verbatim}
 
 <<defun coerceTraceArgs2E>>=
-(defun |coerceTraceArgs2E| (|traceName| |subName| |args|)
+(defun |coerceTraceArgs2E| (|traceName| |subName| args)
  (prog (|name|)
   (return
    (seq
@@ -8156,7 +9044,7 @@ This reports the traced functions
      ((memq (spadlet |name| |subName|) |$mathTraceList|)
        (cond
         ((spadsysnamep (pname |name|))
-          (|coerceSpadArgs2E| (reverse (cdr (reverse |args|)))))
+          (|coerceSpadArgs2E| (reverse (cdr (reverse args)))))
         (t
          (prog (t0)
           (spadlet t0 nil)
@@ -8165,7 +9053,7 @@ This reports the traced functions
                       |arg9| |arg10| |arg11| |arg12| |arg13| |arg14| |arg15| 
                       |arg16| |arg17| |arg18| |arg19|) (cdr t1))
                 (|name| nil)
-                (t2 |args| (cdr t2))
+                (t2 args (cdr t2))
                 (|arg| nil)
                 (t3 (cdr (lassoc |subName| |$tracedMapSignatures|)) (cdr t3))
                 (type nil))
@@ -8187,8 +9075,8 @@ This reports the traced functions
                       (|objNewWrap| |arg| type) |$OutputForm|))
                         nil)))
                      t0))))))))))
-     ((spadsysnamep (pname |name|)) (reverse (cdr (reverse |args|))))
-     (t |args|)))))) 
+     ((spadsysnamep (pname |name|)) (reverse (cdr (reverse args))))
+     (t args)))))) 
 
 @
 
@@ -8203,7 +9091,7 @@ This reports the traced functions
 \end{verbatim}
 
 <<defun coerceSpadArgs2E>>=
-(defun |coerceSpadArgs2E| (|args|)
+(defun |coerceSpadArgs2E| (args)
  (prog (|$streamCount|)
   (declare (special |$streamCount|))
   (return
@@ -8217,7 +9105,7 @@ This reports the traced functions
                   |arg9| |arg10| |arg11| |arg12| |arg13| |arg14| |arg15| 
                   |arg16| |arg17| |arg18| |arg19|) (cdr t1))
             (|name| nil)
-            (t2 |args| (cdr t2))
+            (t2 args (cdr t2))
             (|arg| nil)
             (t3 (cdr |$tracedSpadModemap|) (cdr t3))
             (type nil))
@@ -8253,12 +9141,12 @@ This reports the traced functions
 
 <<defun subTypes>>=
 (defun |subTypes| (|mm| |sublist|)
- (prog (|s|)
+ (prog (s)
   (return
    (seq
     (cond
      ((atom |mm|) 
-       (cond ((spadlet |s| (lassoc |mm| |sublist|)) |s|) (t |mm|)))
+       (cond ((spadlet s (lassoc |mm| |sublist|)) s) (t |mm|)))
      (t
       (prog (t0)
        (spadlet t0 nil)
@@ -8336,11 +9224,11 @@ This reports the traced functions
     (prog (t0)
      (spadlet t0 t)
      (return
-      (do ((t1 nil (null t0)) (t2 arg (cdr t2)) (|x| nil))
-          ((or t1 (atom t2) (progn (setq |x| (car t2)) nil)) t0)
+      (do ((t1 nil (null t0)) (t2 arg (cdr t2)) (x nil))
+          ((or t1 (atom t2) (progn (setq x (car t2)) nil)) t0)
        (seq
         (exit
-         (setq t0 (and t0 (identp |x|)))))))))))) 
+         (setq t0 (and t0 (identp x)))))))))))) 
 
 @
 
@@ -8357,11 +9245,11 @@ This reports the traced functions
     (prog (t0)
      (spadlet t0 t)
      (return
-      (do ((t1 nil (null t0)) (t2 arg (cdr t2)) (|x| nil))
-          ((or t1 (atom t2) (progn (setq |x| (car t2)) nil)) t0)
+      (do ((t1 nil (null t0)) (t2 arg (cdr t2)) (x nil))
+          ((or t1 (atom t2) (progn (setq x (car t2)) nil)) t0)
        (seq
         (exit
-         (setq t0 (and t0 (or (identp |x|) (stringp |x|))))))))))))) 
+         (setq t0 (and t0 (or (identp x) (stringp x))))))))))))) 
 
 @
 
@@ -8459,12 +9347,12 @@ This reports the traced functions
 \end{verbatim}
 
 <<defun lassocSub>>=
-(defun |lassocSub| (|x| |subs|)
+(defun |lassocSub| (x |subs|)
  (prog (|y|) 
   (return 
    (cond 
-    ((spadlet |y| (lassq |x| |subs|)) |y|)
-    (t |x|))))) 
+    ((spadlet |y| (lassq x |subs|)) |y|)
+    (t x))))) 
 
 @
 
@@ -8476,12 +9364,12 @@ This reports the traced functions
 \end{verbatim}
 
 <<defun rassocSub>>=
-(defun |rassocSub| (|x| |subs|)
+(defun |rassocSub| (x |subs|)
  (prog (|y|)
   (return
    (cond
-    ((spadlet |y| (|rassoc| |x| |subs|)) |y|)
-    (t |x|))))) 
+    ((spadlet |y| (|rassoc| x |subs|)) |y|)
+    (t x))))) 
 
 @
 
@@ -8751,30 +9639,30 @@ This reports the traced functions
 \end{verbatim}
 
 <<defun spadTrace,g>>=
-(defun |spadTrace,g| (|x|)
+(defun |spadTrace,g| (x)
  (seq
-  (if (stringp |x|) (exit (intern |x|)))
-  (exit |x|))) 
+  (if (stringp x) (exit (intern x)))
+  (exit x))) 
 
 @
 
 <<defun spadTrace,isTraceable>>=
-(defun |spadTrace,isTraceable| (|x| |domain|)
+(defun |spadTrace,isTraceable| (x |domain|)
  (prog (|n| |functionSlot|)
   (return
    (seq
     (progn
-     (spadlet |n| (caddr |x|))
-     |x|
+     (spadlet |n| (caddr x))
+     x
      (seq
       (if (atom (elt |domain| |n|)) (exit nil))
       (spadlet |functionSlot| (car (elt |domain| |n|)))
       (if (gensymp |functionSlot|) 
-       (exit (seq (|reportSpadTrace| '|Already Traced| |x|) (exit nil))))
+       (exit (seq (|reportSpadTrace| '|Already Traced| x) (exit nil))))
       (if (null (bpiname |functionSlot|))
        (exit
         (seq
-         (|reportSpadTrace| '|No function for| |x|)
+         (|reportSpadTrace| '|No function for| x)
          (exit nil))))
       (exit t))))))) 
 
@@ -8804,11 +9692,11 @@ This reports the traced functions
        (prog (t0)
         (spadlet t0 nil)
         (return
-         (do ((t1 (|getOption| 'ops |options|) (cdr t1)) (|x| nil))
-             ((or (atom t1) (progn (setq |x| (car t1)) nil)) (nreverse0 t0))
+         (do ((t1 (|getOption| 'ops |options|) (cdr t1)) (x nil))
+             ((or (atom t1) (progn (setq x (car t1)) nil)) (nreverse0 t0))
           (seq
            (exit
-            (setq t0 (cons (|spadTrace,g| |x|) t0))))))))
+            (setq t0 (cons (|spadTrace,g| x) t0))))))))
       (cond
        ((spadlet |listOfVariables| (|getOption| 'vars |options|))
          (spadlet |options| (|removeOption| 'vars |options|))))
@@ -8901,20 +9789,20 @@ This reports the traced functions
        (prog (t10)
         (spadlet t10 nil)
         (return
-         (do ((t11 |sigSlotNumberAlist| (cdr t11)) (|x| nil))
-             ((or (atom t11) (progn (setq |x| (car t11)) nil)) (nreverse0 t10))
+         (do ((t11 |sigSlotNumberAlist| (cdr t11)) (x nil))
+             ((or (atom t11) (progn (setq x (car t11)) nil)) (nreverse0 t10))
           (seq
            (exit
-            (cond ((cdddr |x|) (setq t10 (cons |x| t10))))))))))
+            (cond ((cdddr x) (setq t10 (cons x t10))))))))))
       (cond
        (|$reportSpadTrace|
         (cond (|$traceNoisely| (|printDashedLine|)))
         (do ((t12 (|orderBySlotNumber| |sigSlotNumberAlist|) (cdr t12))
-             (|x| nil))
+             (x nil))
             ((or (atom t12)
-                 (progn (setq |x| (car t12)) nil))
+                 (progn (setq x (car t12)) nil))
                 nil)
-             (seq (exit (|reportSpadTrace| 'tracing |x|))))))
+             (seq (exit (|reportSpadTrace| 'tracing x))))))
       (cond (|$letAssoc| (setletprintflag t)))
       (cond 
        (|currentEntry|
@@ -9078,7 +9966,7 @@ This reports the traced functions
         (cons 'lambda
          (cons 
           (cons '&rest
-           (cons '|args| nil))
+           (cons 'args nil))
           (cons
            (cons 'prog
             (cons
@@ -9088,7 +9976,7 @@ This reports the traced functions
                (cons '|domain|
                 (cons
                  (cons 'apply (cons |domainConstructor|
-                  (cons '|args| nil))) nil)))
+                  (cons 'args nil))) nil)))
               (cons
                (cons '|spadTrace|
                 (cons '|domain|
@@ -9236,7 +10124,7 @@ This reports the traced functions
 \end{verbatim}
 
 <<defun letPrint>>=
-(defun |letPrint| (|x| |val| |currentFunction|)
+(defun |letPrint| (x |val| |currentFunction|)
  (prog (|y|)
   (return
    (progn
@@ -9246,24 +10134,24 @@ This reports the traced functions
                  (spadlet |y| (lassoc '|all| |$letAssoc|))))
      (cond
       ((and (or (boot-equal |y| '|all|)
-                 (memq |x| |y|))
+                 (memq x |y|))
             (null 
-             (or (is_genvar |x|) (|isSharpVarWithNum| |x|) (gensymp |x|))))
-        (|sayBrightlyNT| (append (|bright| |x|) (cons '|: | nil)))
+             (or (is_genvar x) (|isSharpVarWithNum| x) (gensymp x))))
+        (|sayBrightlyNT| (append (|bright| x) (cons '|: | nil)))
         (prin0 (|shortenForPrinting| |val|))
         (terpri)))
      (cond
       ((and (spadlet |y| (|hasPair| 'break |y|))
             (or (boot-equal |y| '|all|)
-                (and (memq |x| |y|)
-                     (null (memq (elt (pname |x|) 0) '($ |#|)))
-                     (null (gensymp |x|)))))
+                (and (memq x |y|)
+                     (null (memq (elt (pname x) 0) '($ |#|)))
+                     (null (gensymp x)))))
        (|break|
         (append 
          (|bright| |currentFunction|)
          (cons "breaks after"
           (append
-           (|bright| |x|)
+           (|bright| x)
            (cons ":= " (cons (|shortenForPrinting| |val|) nil)))))))
       (t nil))))
     |val|)))) 
@@ -9293,7 +10181,7 @@ This reports the traced functions
 \end{verbatim}
 
 <<defun letPrint2>>=
-(defun |letPrint2| (|x| |printform| |currentFunction|)
+(defun |letPrint2| (x |printform| |currentFunction|)
  (prog (|$BreakMode| |flag| |y|)
   (declare (special |$BreakMode|))
   (return
@@ -9305,12 +10193,12 @@ This reports the traced functions
                (spadlet |y| (lassoc '|all| |$letAssoc|))))
       (cond
        ((and
-          (or (boot-equal |y| '|all|) (memq |x| |y|))
-          (null (or (is_genvar |x|) (|isSharpVarWithNum| |x|) (gensymp |x|))))
+          (or (boot-equal |y| '|all|) (memq x |y|))
+          (null (or (is_genvar x) (|isSharpVarWithNum| x) (gensymp x))))
          (spadlet |$BreakMode| '|letPrint2|)
          (spadlet |flag| nil)
          (catch '|letPrint2| 
-          (|mathprint| (cons '= (cons |x| (cons |printform| nil)))) |flag|)
+          (|mathprint| (cons '= (cons x (cons |printform| nil)))) |flag|)
          (cond 
           ((boot-equal |flag| '|letPrint2|) (|print| |printform|))
           (t nil))))
@@ -9319,16 +10207,16 @@ This reports the traced functions
          (spadlet |y| (|hasPair| 'break |y|))
          (or (boot-equal |y| '|all|)
              (and 
-              (memq |x| |y|)
-              (null (memq (elt (pname |x|) 0) '($ |#|)))
-              (null (gensymp |x|)))))
+              (memq x |y|)
+              (null (memq (elt (pname x) 0) '($ |#|)))
+              (null (gensymp x)))))
         (|break|
          (append
           (|bright| |currentFunction|)
           (cons "breaks after" 
-           (append (|bright| |x|) (cons '|:= | (cons |printform| nil)))))))
+           (append (|bright| x) (cons '|:= | (cons |printform| nil)))))))
        (t nil))))
-    |x|)))) 
+    x)))) 
 
 @
 
@@ -9355,7 +10243,7 @@ This reports the traced functions
 \end{verbatim}
 
 <<defun letPrint3>>=
-(defun |letPrint3| (|x| |xval| |printfn| |currentFunction|)
+(defun |letPrint3| (x |xval| |printfn| |currentFunction|)
  (prog (|$BreakMode| |flag| |y|)
   (declare (special |$BreakMode|))
   (return
@@ -9367,13 +10255,13 @@ This reports the traced functions
            (spadlet |y| (lassoc '|all| |$letAssoc|))))
        (cond
         ((and
-           (or (boot-equal |y| '|all|) (memq |x| |y|))
-           (null (or (is_genvar |x|) (|isSharpVarWithNum| |x|) (gensymp |x|))))
+           (or (boot-equal |y| '|all|) (memq x |y|))
+           (null (or (is_genvar x) (|isSharpVarWithNum| x) (gensymp x))))
           (spadlet |$BreakMode| '|letPrint2|)
           (spadlet |flag| nil)
           (catch '|letPrint2|
            (|mathprint|
-            (cons '= (cons |x| (cons (spadcall |xval| |printfn|) nil))))
+            (cons '= (cons x (cons (spadcall |xval| |printfn|) nil))))
            |flag|)
           (cond
            ((boot-equal |flag| '|letPrint2|) (|print| |xval|))
@@ -9384,16 +10272,16 @@ This reports the traced functions
           (or
            (boot-equal |y| '|all|)
            (and
-            (memq |x| |y|)
-            (null (memq (elt (pname |x|) 0) '($ |#|)))
-            (null (gensymp |x|)))))
+            (memq x |y|)
+            (null (memq (elt (pname x) 0) '($ |#|)))
+            (null (gensymp x)))))
           (|break|
            (append
             (|bright| |currentFunction|)
             (cons "breaks after"
-             (append (|bright| |x|) (cons ":= " (cons |xval| nil)))))))
+             (append (|bright| x) (cons ":= " (cons |xval| nil)))))))
         (t nil))))
-    |x|)))) 
+    x)))) 
 
 @
 \subsection{defun getAliasIfTracedMapParameter}
@@ -9406,20 +10294,20 @@ This reports the traced functions
 \end{verbatim}
 
 <<defun getAliasIfTracedMapParameter>>=
-(defun |getAliasIfTracedMapParameter| (|x| |currentFunction|)
+(defun |getAliasIfTracedMapParameter| (x |currentFunction|)
  (prog (|aliasList|)
   (return
    (seq
     (cond
-     ((|isSharpVarWithNum| |x|)
+     ((|isSharpVarWithNum| x)
        (cond
         ((spadlet |aliasList|
            (|get| |currentFunction| '|alias| |$InteractiveFrame|))
          (exit
           (elt |aliasList|
            (spaddifference
-            (string2pint-n (substring (pname |x|) 1 nil) 1) 1))))))
-     (t |x|)))))) 
+            (string2pint-n (substring (pname x) 1 nil) 1) 1))))))
+     (t x)))))) 
 
 @
 
@@ -9577,14 +10465,14 @@ This reports the traced functions
       (prog (t0)
        (spadlet t0 nil)
        (return
-        (do ((t1 arg (cdr t1)) (|x| nil))
+        (do ((t1 arg (cdr t1)) (x nil))
             ((or (atom t1)
-                 (progn (setq |x| (car t1)) nil)
-                 (progn (progn (spadlet |n| (caddr |x|)) |x|) nil))
+                 (progn (setq x (car t1)) nil)
+                 (progn (progn (spadlet |n| (caddr x)) x) nil))
                (nreverse0 t0))
          (seq
           (exit
-           (setq t0 (cons (cons |n| |x|) t0))))))))))))) 
+           (setq t0 (cons (cons |n| x) t0))))))))))))) 
 
 @
 
@@ -9607,17 +10495,17 @@ This reports the traced functions
     (cond
      ((null /tracenames) "   Nothing is traced.")
      (t
-       (do ((t0 /tracenames (cdr t0)) (|x| nil))
-           ((or (atom t0) (progn (setq |x| (car t0)) nil)) nil)
+       (do ((t0 /tracenames (cdr t0)) (x nil))
+           ((or (atom t0) (progn (setq x (car t0)) nil)) nil)
         (seq
          (exit
           (cond
-           ((and (pairp |x|) 
-                 (progn (spadlet |d| (qcar |x|)) t)
+           ((and (pairp x) 
+                 (progn (spadlet |d| (qcar x)) t)
                  (|isDomainOrPackage| |d|))
               (spadlet |domainList| (cons (|devaluate| |d|) |domainList|)))
            (t 
-            (spadlet |functionList| (cons |x| |functionList|)))))))
+            (spadlet |functionList| (cons x |functionList|)))))))
        (append |functionList|
         (append |domainList| (cons '|traced| nil))))))))) 
 
@@ -9633,14 +10521,14 @@ This reports the traced functions
 \end{verbatim}
 
 <<defun spadReply,printName>>=
-(defun |spadReply,printName| (|x|)
+(defun |spadReply,printName| (x)
  (prog (|d|)
   (return
    (seq
-    (if (and (and (pairp |x|) (progn (spadlet |d| (qcar |x|)) t))
+    (if (and (and (pairp x) (progn (spadlet |d| (qcar x)) t))
              (|isDomainOrPackage| |d|))
        (exit (|devaluate| |d|)))
-     (exit |x|))))) 
+     (exit x))))) 
 
 @
 
@@ -9652,11 +10540,11 @@ This reports the traced functions
     (prog (t0)
      (spadlet t0 nil)
      (return
-       (do ((t1 /tracenames (cdr t1)) (|x| nil))
-           ((or (atom t1) (progn (setq |x| (car t1)) nil)) (nreverse0 t0))
+       (do ((t1 /tracenames (cdr t1)) (x nil))
+           ((or (atom t1) (progn (setq x (car t1)) nil)) (nreverse0 t0))
         (seq
          (exit
-          (setq t0 (cons (|spadReply,printName| |x|) t0))))))))))) 
+          (setq t0 (cons (|spadReply,printName| x) t0))))))))))) 
 
 @
 
@@ -9743,11 +10631,11 @@ This reports the traced functions
          (prog (t1) 
           (spadlet t1 nil)
           (return
-           (do ((t2 |sigSlotNumberAlist| (cdr t2)) (|x| nil))
-               ((or (atom t2) (progn (setq |x| (car t2)) nil)) (nreverse0 t1))
+           (do ((t2 |sigSlotNumberAlist| (cdr t2)) (x nil))
+               ((or (atom t2) (progn (setq x (car t2)) nil)) (nreverse0 t1))
              (seq
               (exit
-               (cond ((cdddr |x|) (setq t1 (cons |x| t1))))))))))
+               (cond ((cdddr x) (setq t1 (cons x t1))))))))))
         (cond 
          (|newSigSlotNumberAlist| 
           (rplac (cdr |pair|) |newSigSlotNumberAlist|))
@@ -9766,15 +10654,15 @@ This reports the traced functions
 \end{verbatim}
 
 <<defun prTraceNames,fn>>=
-(defun |prTraceNames,fn| (|x|)
+(defun |prTraceNames,fn| (x)
  (prog (|d| |t|)
   (return
    (seq
-    (if (and (and (pairp |x|) 
-                  (progn (spadlet |d| (qcar |x|)) (spadlet |t| (qcdr |x|)) t))
+    (if (and (and (pairp x) 
+                  (progn (spadlet |d| (qcar x)) (spadlet |t| (qcdr x)) t))
               (|isDomainOrPackage| |d|))
       (exit (cons (|devaluate| |d|) |t|)))
-    (exit |x|))))) 
+    (exit x))))) 
 
 @
 
@@ -9782,11 +10670,11 @@ This reports the traced functions
 (defun |prTraceNames| ()
  (seq
   (progn
-   (do ((t0 /tracenames (cdr t0)) (|x| nil))
-       ((or (atom t0) (progn (setq |x| (car t0)) nil)) nil)
+   (do ((t0 /tracenames (cdr t0)) (x nil))
+       ((or (atom t0) (progn (setq x (car t0)) nil)) nil)
     (seq
      (exit
-      (print (|prTraceNames,fn| |x|))))) nil))) 
+      (print (|prTraceNames,fn| x))))) nil))) 
 
 @
 
@@ -9850,33 +10738,33 @@ This reports the traced functions
       ((null /tracenames) (|sayMessage| "   Nothing is traced now."))
       (t
         (|sayBrightly| " ")
-        (do ((t0 /tracenames (cdr t0)) (|x| nil))
-             ((or (atom t0) (progn (setq |x| (car t0)) nil)) nil)
+        (do ((t0 /tracenames (cdr t0)) (x nil))
+             ((or (atom t0) (progn (setq x (car t0)) nil)) nil)
          (seq
           (exit
            (cond
-            ((and (pairp |x|) 
-                  (progn (spadlet |d| (qcar |x|)) t) (|isDomainOrPackage| |d|))
+            ((and (pairp x) 
+                  (progn (spadlet |d| (qcar x)) t) (|isDomainOrPackage| |d|))
                (|addTraceItem| |d|))
-            ((atom |x|)
+            ((atom x)
                (cond
-                ((|isFunctor| |x|) (|addTraceItem| |x|))
-                ((is_genvar |x|) (|addTraceItem| (EVAL |x|)))
-                (t (spadlet |functionList| (CONS |x| |functionList|)))))
+                ((|isFunctor| x) (|addTraceItem| x))
+                ((is_genvar x) (|addTraceItem| (EVAL x)))
+                (t (spadlet |functionList| (CONS x |functionList|)))))
             (t (|userError| "bad argument to trace"))))))
         (spadlet |functionList|
           (prog (t1)
            (spadlet t1 nil)
            (return
-            (do ((t2 |functionList| (cdr t2)) (|x| nil))
-                ((or (atom t2) (progn (setq |x| (car t2)) nil)) t1)
+            (do ((t2 |functionList| (cdr t2)) (x nil))
+                ((or (atom t2) (progn (setq x (car t2)) nil)) t1)
               (seq
                (exit
                 (cond 
-                 ((null (|isSubForRedundantMapName| |x|))
+                 ((null (|isSubForRedundantMapName| x))
                    (setq t1 
                     (append t1 
-                     (cons (|rassocSub| |x| |$mapSubNameAlist|)
+                     (cons (|rassocSub| x |$mapSubNameAlist|)
                            (cons " " nil))))))))))))
        (cond 
         (|functionList| 
@@ -9897,12 +10785,12 @@ This reports the traced functions
            (prog (t3)
             (spadlet t3 nil)
             (return
-             (do ((t4 (cdr |$domains|) (cdr t4)) (|x| nil))
-                 ((or (atom t4) (progn (setq |x| (car t4)) nil)) t3)
+             (do ((t4 (cdr |$domains|) (cdr t4)) (x nil))
+                 ((or (atom t4) (progn (setq x (car t4)) nil)) t3)
               (seq
                (exit
                 (setq t3
-                 (append t3 (|concat| "," " " (|prefix2String| |x|)))))))))))
+                 (append t3 (|concat| "," " " (|prefix2String| x)))))))))))
          (cond 
           ((atom |displayList|)
            (spadlet |displayList| (cons |displayList| nil))))
@@ -9916,12 +10804,12 @@ This reports the traced functions
             (prog (t5)
              (spadlet t5 nil)
              (return
-              (do ((t6 (cdr |$packages|) (cdr t6)) (|x| nil))
-                  ((or (atom t6) (progn (setq |x| (car t6)) nil)) t5)
+              (do ((t6 (cdr |$packages|) (cdr t6)) (x nil))
+                  ((or (atom t6) (progn (setq x (car t6)) nil)) t5)
                (seq
                 (exit
                  (setq t5
-                  (append t5 (|concat| '|, | (|prefix2String| |x|)))))))))))
+                  (append t5 (|concat| '|, | (|prefix2String| x)))))))))))
           (cond ((atom |displayList|)
               (spadlet |displayList| (cons |displayList| nil))))
           (|sayBrightly| "   Packages traced: ")
@@ -9934,12 +10822,12 @@ This reports the traced functions
            (prog (t7)
             (spadlet t7 nil)
              (return 
-              (do ((t8 (cdr |$constructors|) (cdr t8)) (|x| nil))
-                  ((or (atom t8) (progn (setq |x| (car t8)) nil)) t7)
+              (do ((t8 (cdr |$constructors|) (cdr t8)) (x nil))
+                  ((or (atom t8) (progn (setq x (car t8)) nil)) t7)
                (seq
                 (exit
                  (setq t7
-                 (append t7 (|concat| '|, | (|abbreviate| |x|)))))))))))
+                 (append t7 (|concat| '|, | (|abbreviate| x)))))))))))
          (cond ((atom |displayList|)
             (spadlet |displayList| (CONS |displayList| nil))))
          (|sayBrightly| "   Parameterized constructors traced:")
@@ -9987,34 +10875,34 @@ This reports the traced functions
 
 <<defun ?t>>=
 (defun |?t| ()
- (prog (|llm| |x| |d| |l| |suffix|)
+ (prog (|llm| x |d| |l| |suffix|)
   (return
    (seq
     (cond
      ((null /tracenames) (|sayMSG| (|bright| "nothing is traced")))
      (t
-      (do ((t0 /tracenames (cdr t0)) (|x| nil))
-          ((or (atom t0) (progn (setq |x| (car t0)) nil)) nil)
+      (do ((t0 /tracenames (cdr t0)) (x nil))
+          ((or (atom t0) (progn (setq x (car t0)) nil)) nil)
        (seq
         (exit
          (cond
-          ((and (atom |x|) (null (is_genvar |x|)))
+          ((and (atom x) (null (is_genvar x)))
            (progn
             (cond
-             ((spadlet |llm| (|get| |x| '|localModemap| |$InteractiveFrame|))
-               (spadlet |x| (list (cadar |llm|)))))
+             ((spadlet |llm| (|get| x '|localModemap| |$InteractiveFrame|))
+               (spadlet x (list (cadar |llm|)))))
             (|sayMSG|
              (cons "Function"
               (append
-               (|bright| (|rassocSub| |x| |$mapSubNameAlist|))
+               (|bright| (|rassocSub| x |$mapSubNameAlist|))
                (cons "traced" nil))))))))))
-      (do ((t1 /tracenames (cdr t1)) (|x| nil))
-          ((or (atom t1) (progn (setq |x| (car t1)) nil)) nil)
+      (do ((t1 /tracenames (cdr t1)) (x nil))
+          ((or (atom t1) (progn (setq x (car t1)) nil)) nil)
        (seq
         (exit
          (cond
-          ((and (pairp |x|) 
-                (progn (spadlet |d| (qcar |x|)) (spadlet |l| (qcdr |x|)) t)
+          ((and (pairp x) 
+                (progn (spadlet |d| (qcar x)) (spadlet |l| (qcdr x)) t)
                 (|isDomainOrPackage| |d|))
            (progn
             (spadlet |suffix| (cond ((|isDomain| |d|) "domain") (t "package")))
@@ -10025,11 +10913,11 @@ This reports the traced functions
                 (cons (|devaluate| |d|) 
                  (cons '|%d| 
                   (cons ":" nil)))))))
-            (do ((t2 (|orderBySlotNumber| |l|) (cdr t2)) (|x| nil))
-                ((or (atom t2) (progn (setq |x| (car t2)) nil)) nil)
+            (do ((t2 (|orderBySlotNumber| |l|) (cdr t2)) (x nil))
+                ((or (atom t2) (progn (setq x (car t2)) nil)) nil)
               (seq
                (exit
-                (|reportSpadTrace| '|   | (TAKE 4 |x|)))))
+                (|reportSpadTrace| '|   | (TAKE 4 x)))))
             (terpri))))))))))))) 
 
 @
@@ -11160,20 +12048,20 @@ whatSpad2Cmd l ==
 
 \subsection{defun whatSpad2Cmd,fixpat}
 <<defun whatSpad2Cmd,fixpat>>=
-(defun |whatSpad2Cmd,fixpat| (|x|)
+(defun |whatSpad2Cmd,fixpat| (x)
  (prog (|x'|)
   (return
    (seq
-    (if (and (pairp |x|) (progn (spadlet |x'| (qcar |x|)) t))
+    (if (and (pairp x) (progn (spadlet |x'| (qcar x)) t))
       (exit (downcase |x'|)))
-    (exit (downcase |x|)))))) 
+    (exit (downcase x)))))) 
 
 @
 
 \subsection{defun whatSpad2Cmd}
 <<defun whatSpad2Cmd>>=
 (defun |whatSpad2Cmd| (arg)
- (prog (|$e| |key0| key |args|)
+ (prog (|$e| |key0| key args)
   (declare (special |$e|))
   (return
    (seq
@@ -11183,22 +12071,22 @@ whatSpad2Cmd l ==
       ((null arg) (|reportWhatOptions|))
       (t
         (spadlet |key0| (car arg))
-        (spadlet |args| (cdr arg))
+        (spadlet args (cdr arg))
         (spadlet key (|selectOptionLC| |key0| |$whatOptions| nil))
         (cond
          ((null key) (|sayKeyedMsg| 's2iz0043 nil))
          (t
-          (spadlet |args|
+          (spadlet args
            (prog (t0)
             (spadlet t0 nil)
             (return
-              (do ((t1 |args| (cdr t1)) (|p| nil))
+              (do ((t1 args (cdr t1)) (p nil))
                   ((or (atom t1)
-                       (progn (setq |p| (car t1)) nil))
+                       (progn (setq p (car t1)) nil))
                  (nreverse0 t0))
                (seq
                 (exit
-                 (setq t0 (cons (|whatSpad2Cmd,fixpat| |p|) t0))))))))
+                 (setq t0 (cons (|whatSpad2Cmd,fixpat| p) t0))))))))
           (seq
            (cond
             ((boot-equal key '|things|)
@@ -11208,19 +12096,19 @@ whatSpad2Cmd l ==
                 (exit
                  (cond
                   ((null (memq opt '(|things|)))
-                    (exit (|whatSpad2Cmd| (cons opt |args|)))))))))
+                    (exit (|whatSpad2Cmd| (cons opt args)))))))))
             ((boot-equal key '|categories|)
-              (|filterAndFormatConstructors| '|category| "Categories" |args|))
-            ((boot-equal key '|commands|) (|whatCommands| |args|))
+              (|filterAndFormatConstructors| '|category| "Categories" args))
+            ((boot-equal key '|commands|) (|whatCommands| args))
             ((boot-equal key '|domains|)
-              (|filterAndFormatConstructors| '|domain| "Domains" |args|))
+              (|filterAndFormatConstructors| '|domain| "Domains" args))
             ((boot-equal key '|operations|)
-               (|apropos| |args|))
+               (|apropos| args))
             ((boot-equal key '|packages|)
-              (|filterAndFormatConstructors| '|package| "Packages" |args|))
+              (|filterAndFormatConstructors| '|package| "Packages" args))
             (t
              (cond ((boot-equal key '|synonyms|)
-                      (|printSynonyms| |args|))))))))))))))) 
+                      (|printSynonyms| args))))))))))))))) 
 
 @
 
@@ -11338,10 +12226,10 @@ apropos l ==
           (prog (t0)
            (spadlet t0 nil)
            (return
-            (do ((t1 arg (cdr t1)) (|p| nil))
-                ((or (atom t1) (progn (setq |p| (car t1)) nil))
+            (do ((t1 arg (cdr t1)) (p nil))
+                ((or (atom t1) (progn (setq p (car t1)) nil))
                   (nreverse0 t0))
-            (seq (exit (setq t0 (cons (downcase (stringimage |p|)) t0)))))))
+            (seq (exit (setq t0 (cons (downcase (stringimage p)) t0)))))))
           (|allOperations|)))))
      (cond
       (|ops|
@@ -11406,12 +12294,12 @@ workfilesSpad2Cmd args ==
   for fl in $sourceFiles repeat sayBrightly ["   " ,namestring fl]
 \end{verbatim}
 <<defun workfilesSpad2Cmd>>=
-(defun |workfilesSpad2Cmd| (|args|)
+(defun |workfilesSpad2Cmd| (args)
  (prog (|deleteFlag| type |flist| |type1| |fl|)
   (return
    (seq
     (cond 
-     (|args| (|throwKeyedMsg| 's2iz0047 nil))
+     (args (|throwKeyedMsg| 's2iz0047 nil))
      (t
        (spadlet |deleteFlag| nil)
        (do ((t0 |$options| (cdr t0)) (t1 nil))
@@ -11546,7 +12434,7 @@ zsystemdevelopment1(l,im) ==
 \end{verbatim}
 <<defun zsystemdevelopment1>>=
 (defun |zsystemdevelopment1| (arg |im|)
- (prog (|$InteractiveMode| |fromopt| opt |optargs| |newopt| |opt1|
+ (prog (|$InteractiveMode| |fromopt| opt optargs |newopt| |opt1|
         |conStream| |upf| |fun|)
   (declare (special |$InteractiveMode|))
   (return
@@ -11560,7 +12448,7 @@ zsystemdevelopment1(l,im) ==
               (progn
                (progn
                 (spadlet opt (CAR t1))
-                (spadlet |optargs| (CDR t1))
+                (spadlet optargs (CDR t1))
                 t1)
                nil))
            nil)
@@ -11570,22 +12458,22 @@ zsystemdevelopment1(l,im) ==
          (spadlet |opt1| (|selectOptionLC| opt '(|from|) nil))
          (cond
           ((boot-equal |opt1| '|from|)
-            (spadlet |fromopt| (cons (cons 'from |optargs|) nil))))))))
+            (spadlet |fromopt| (cons (cons 'from optargs) nil))))))))
      (do ((t2 |$options| (cdr t2)) (t3 nil))
          ((or (atom t2)
               (progn (setq t3 (car t2)) nil)
               (progn
                (progn
                 (spadlet opt (car t3))
-                (spadlet |optargs| (cdr t3))
+                (spadlet optargs (cdr t3))
                 t3)
                nil))
           nil)
       (seq
        (exit
         (progn
-         (cond ((null |optargs|) (spadlet |optargs| arg)))
-         (spadlet |newopt| (append |optargs| |fromopt|))
+         (cond ((null optargs) (spadlet optargs arg)))
+         (spadlet |newopt| (append optargs |fromopt|))
          (spadlet |opt1| (|selectOptionLC| opt '(|from|) nil))
          (cond
           ((boot-equal |opt1| '|from|)
@@ -11619,17 +12507,17 @@ zsystemdevelopment1(l,im) ==
             (spadlet |$InteractiveMode| nil)
             (spadlet |upf|
              (cons
-              (or (kar |optargs|) /version)
+              (or (kar optargs) /version)
               (cons
-               (or (kadr |optargs|) /wsname)
-               (cons (or (kaddr |optargs|) '*) nil))))
+               (or (kadr optargs) /wsname)
+               (cons (or (kaddr optargs) '*) nil))))
             (spadlet |fun|
              (cond
               ((boot-equal opt '|patch|) '/update-lib-1)
               (t '/update-1)))
             (catch 'filenam (funcall |fun| |upf|))
             (|sayMessage| "   Update/patch is completed."))
-          ((null |optargs|)
+          ((null optargs)
            (|sayBrightly|
             (cons
              "   An argument is required for"
@@ -11789,13 +12677,20 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun clearCmdSortedCaches>>
 <<defun clearSpad2Cmd>>
 <<defun clearFrame>>
+<<defun close>>
 <<defun closeInterpreterFrame>>
+<<defun compileAsharpCmd>>
+<<defun compileAsharpCmd1>>
+<<defun compileAsharpArchiveCmd>>
 <<defun compileBoot>>
+<<defun compiler>>
+<<defun compileSpadLispCmd>>
 <<defun coerceSpadArgs2E>>
 <<defun coerceSpadFunValue2E>>
 <<defun coerceTraceArgs2E>>
 <<defun coerceTraceFunValue2E>>
 <<defun createCurrentInterpreterFrame>>
+<<defun credits>>
 
 <<defun dewritify>>
 <<defun dewritify,dewritifyInner>>
@@ -11908,6 +12803,8 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun ptimers>>
 <<defun putHist>>
 
+<<defun queryClients>>
+
 <<defun rassocSub>>
 <<defun readHiFi>>
 <<defun reclaim>>
@@ -11961,6 +12858,7 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun statisticsInitialization>>
 <<defun stupidIsSpadFunction>>
 <<defun subTypes>>
+<<defun summary>>
 
 <<defun ?t>>
 <<defun trace>>
@@ -12000,6 +12898,7 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun whatSpad2Cmd>>
 <<defun whatSpad2Cmd,fixpat>>
 <<defun with>>
+<<defun withAsharpCmd>>
 <<defun workfiles>>
 <<defun workfilesSpad2Cmd>>
 <<defun writify>>
diff --git a/changelog b/changelog
index 13496a6..244900f 100644
--- a/changelog
+++ b/changelog
@@ -1,4 +1,8 @@
-20090408 tpd src/axiom-website/patches.html 20090308.02.tpd.patch
+20090308 tpd src/axiom-website/patches.html 20090308.03.tpd.patch
+20090308 tpd src/input/unittest1.input unit test commands
+20090308 tpd src/interp/i-syscmd.boot move commands to bookvol5
+20090308 tpd books/bookvol5 move summary, copyright, help roots
+20090308 tpd src/axiom-website/patches.html 20090308.02.tpd.patch
 20090308 tpd src/interp/i-syscmd.boot move clear to bookvol5
 20090308 tpd books/bookvol5 add )clear root
 20090308 tpd src/axiom-website/patches.html 20090308.01.tpd.patch
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index 1d7f8eb..80e328c 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -995,5 +995,7 @@ bookvol5 add trace root<br/>
 bookvol5 add include, abbreviation roots<br/>
 <a href="patches/20090308.02.tpd.patch">20090308.02.tpd.patch</a>
 bookvol5 add clear root<br/>
+<a href="patches/20090308.03.tpd.patch">20090308.03.tpd.patch</a>
+bookvol5 add summary, copyright, help roots<br/>
  </body>
 </html>
diff --git a/src/input/unittest1.input.pamphlet b/src/input/unittest1.input.pamphlet
index c5c9bd3..ac70ef0 100644
--- a/src/input/unittest1.input.pamphlet
+++ b/src/input/unittest1.input.pamphlet
@@ -21,7 +21,7 @@ Unit test the user level commands
 The )with command is the same as the )library command and really
 should be a synonym.
 <<*>>= 
---S 1
+--S 1 0f 28
 )with API
 --R   )library cannot find the file API.
 --E 1
@@ -30,7 +30,7 @@ should be a synonym.
 
 The )apropos command is the same as a )what command
 <<*>>= 
---S 2
+--S 2 0f 28
 )apropos matrix
 --R 
 --R
@@ -103,7 +103,7 @@ The )apropos command is the same as a )what command
 --R
 --E 2
 
---S 3
+--S 3 0f 28
 )what categories set
 --R 
 --R------------------------------- Categories --------------------------------
@@ -122,7 +122,7 @@ The )apropos command is the same as a )what command
 --R TSETCAT  TriangularSetCategory
 --E 3
 
---S 4
+--S 4 0f 28
 )what commands set
 --R 
 --R--------------- System Commands for User Level: development ---------------
@@ -134,7 +134,7 @@ The )apropos command is the same as a )what command
 --R 
 --E 4
 
---S 5
+--S 5 0f 28
 )what domains set
 --R 
 --R--------------------------------- Domains ---------------------------------
@@ -157,7 +157,7 @@ The )apropos command is the same as a )what command
 --R WUTSET   WuWenTsunTriangularSet
 --E 5
 
---S 6
+--S 6 0f 28
 )what operations set
 --R 
 --R
@@ -262,7 +262,7 @@ The )apropos command is the same as a )what command
 --R      setAttributeButtonStep 
 --E 6
 
---S 7
+--S 7 0f 28
 )what packages set
 --R 
 --R-------------------------------- Packages ---------------------------------
@@ -279,7 +279,7 @@ The )apropos command is the same as a )what command
 --R SRDCMPK  SquareFreeRegularSetDecompositionPackage
 --E 7
 
---S 8
+--S 8 0f 28
 )what synonym set
 --R 
 --R------------------------- System Command Synonyms -------------------------
@@ -289,7 +289,7 @@ The )apropos command is the same as a )what command
 --R
 --E 8
 
---S 9
+--S 9 0f 28
 )what things set
 --R 
 --R
@@ -450,7 +450,7 @@ The )apropos command is the same as a )what command
 --R
 --E 9
 
---S 10
+--S 10 0f 28
 )apropos set
 --R
 --ROperations whose names satisfy the above pattern(s):
@@ -609,7 +609,7 @@ The )apropos command is the same as a )what command
 --R
 --E 10
 
---S 11
+--S 11 0f 28
 )prompt
 --R---------------------------- The prompt Option ----------------------------
 --R
@@ -627,13 +627,13 @@ The )apropos command is the same as a )what command
 --R
 --E 11
 
---S 12
+--S 12 0f 28
 )version
 --R 
 --IValue = "Saturday February 21, 2009 at 17:59:27 "
 --E 12
 
---S 13
+--S 13 0f 28
 )zsys )from )c
 --R 
 --R 
@@ -644,7 +644,7 @@ The )apropos command is the same as a )what command
 --R
 --E 13
 
---S 14
+--S 14 0f 28
 )zsys )from )d
 --R 
 --R 
@@ -655,7 +655,7 @@ The )apropos command is the same as a )what command
 --R
 --E 14
 
---S 15
+--S 15 0f 28
 )zsys )from )dt
 --R 
 --R 
@@ -666,7 +666,7 @@ The )apropos command is the same as a )what command
 --R
 --E 15
 
---S 16
+--S 16 0f 28
 )zsys )from )ct
 --R 
 --R 
@@ -677,7 +677,7 @@ The )apropos command is the same as a )what command
 --R
 --E 16
 
---S 17
+--S 17 0f 28
 )zsys )from )ctl
 --R 
 --R 
@@ -688,7 +688,7 @@ The )apropos command is the same as a )what command
 --R
 --E 17
 
---S 18
+--S 18 0f 28
 )zsys )from )ec
 --R 
 --R 
@@ -699,7 +699,7 @@ The )apropos command is the same as a )what command
 --R
 --E 18
 
---S 19
+--S 19 0f 28
 )zsys )from )ect
 --R 
 --R 
@@ -710,7 +710,7 @@ The )apropos command is the same as a )what command
 --R
 --E 19
 
---S 20
+--S 20 0f 28
 )zsys )from )e
 --R 
 --R 
@@ -721,12 +721,12 @@ The )apropos command is the same as a )what command
 --R
 --E 20
 
---S 21
+--S 21 0f 28
 )zsys )from )version
 --R 
 --E 21
 
---S 22
+--S 22 0f 28
 )zsys )from )update
 --R 
 --R 
@@ -737,7 +737,7 @@ The )apropos command is the same as a )what command
 --R
 --E 22
 
---S 23
+--S 23 0f 28
 )zsys )from )patch
 --R 
 --R 
@@ -748,7 +748,7 @@ The )apropos command is the same as a )what command
 --R
 --E 23
 
---S 24
+--S 24 0f 28
 )zsys )from )there 1
 --R 
 --R
@@ -757,18 +757,134 @@ The )apropos command is the same as a )what command
 --R
 --E 24
 
---S 25
+--S 25 0f 28
 )zsys )from )compare
 --R 
 --R   An argument is required for compare 
 --E 25
 
---S 26
+--S 26 0f 28
 )zsys )from )record
 --R 
 --R   An argument is required for record 
 --E 26
 
+--S 27 0f 28
+)summary
+ )credits      : list the people who have contributed to Axiom
+
+ )help <command> gives more information
+ )quit         : exit AXIOM 
+
+ )abbreviation : query, set and remove abbreviations for constructors
+ )cd           : set working directory
+ )clear        : remove declarations, definitions or values
+ )close        : throw away an interpreter client and workspace
+ )compile      : invoke constructor compiler
+ )display      : display Library operations and objects in your workspace
+ )edit         : edit a file
+ )frame        : manage interpreter workspaces
+ )history      : manage aspects of interactive session
+ )library      : introduce new constructors 
+ )lisp         : evaluate a LISP expression
+ )read         : execute AXIOM commands from a file
+ )savesystem   : save LISP image to a file
+ )set          : view and set system variables
+ )show         : show constructor information
+ )spool        : log input and output to a file
+ )synonym      : define an abbreviation for system commands
+ )system       : issue shell commands
+ )trace        : trace execution of functions
+ )undo         : restore workspace to earlier state
+ )what         : search for various things by name
+
+--E 27
+
+--S 28 0f 28
+)credits
+An alphabetical listing of contributors to AXIOM:
+Cyril Alberga          Roy Adler              Christian Aistleitner
+Richard Anderson       George Andrews         S.J. Atkins
+Henry Baker            Stephen Balzac         Yurij Baransky
+David R. Barton        Gerald Baumgartner     Gilbert Baumslag
+Jay Belanger           David Bindel           Fred Blair
+Vladimir Bondarenko    Mark Botch
+Alexandre Bouyer       Peter A. Broadbery     Martin Brock
+Manuel Bronstein       Stephen Buchwald       Florian Bundschuh
+Luanne Burns           William Burge
+Quentin Carpent        Robert Caviness        Bruce Char
+Ondrej Certik          Cheekai Chin           David V. Chudnovsky
+Gregory V. Chudnovsky  Josh Cohen             Christophe Conil
+Don Coppersmith        George Corliss         Robert Corless
+Gary Cornell           Meino Cramer           Claire Di Crescenzo
+David Cyganski
+Timothy Daly Sr.       Timothy Daly Jr.       James H. Davenport
+Didier Deshommes       Michael Dewar
+Jean Della Dora        Gabriel Dos Reis       Claire DiCrescendo
+Sam Dooley             Lionel Ducos           Martin Dunstan
+Brian Dupee            Dominique Duval
+Robert Edwards         Heow Eide-Goodman      Lars Erickson
+Richard Fateman        Bertfried Fauser       Stuart Feldman
+Brian Ford             Albrecht Fortenbacher  George Frances
+Constantine Frangos    Timothy Freeman        Korrinn Fu
+Marc Gaetano           Rudiger Gebauer        Kathy Gerber
+Patricia Gianni        Samantha Goldrich      Holger Gollan
+Teresa Gomez-Diaz      Laureano Gonzalez-Vega Stephen Gortler
+Johannes Grabmeier     Matt Grayson           Klaus Ebbe Grue
+James Griesmer         Vladimir Grinberg      Oswald Gschnitzer
+Jocelyn Guidry
+Steve Hague            Satoshi Hamaguchi      Mike Hansen
+Richard Harke          Vilya Harvey           Martin Hassner
+Arthur S. Hathaway     Dan Hatton             Waldek Hebisch
+Karl Hegbloom          Ralf Hemmecke          Henderson
+Antoine Hersen         Gernot Hueber
+Pietro Iglio
+Alejandro Jakubi       Richard Jenks
+Kai Kaminski           Grant Keady            Tony Kennedy
+Paul Kosinski          Klaus Kusche           Bernhard Kutzler
+Tim Lahey              Larry Lambe            Franz Lehner
+Frederic Lehobey       Michel Levaud          Howard Levy
+Liu Xiaojun            Rudiger Loos           Michael Lucks
+Richard Luczak
+Camm Maguire           Francois Maltey        Alasdair McAndrew
+Bob McElrath           Michael McGettrick     Ian Meikle
+David Mentre           Victor S. Miller       Gerard Milmeister
+Mohammed Mobarak       H. Michael Moeller     Michael Monagan
+Marc Moreno-Maza       Scott Morrison         Joel Moses
+Mark Murray
+William Naylor         C. Andrew Neff         John Nelder
+Godfrey Nolan          Arthur Norman          Jinzhong Niu
+Michael O'Connor       Summat Oemrawsingh     Kostas Oikonomou
+Humberto Ortiz-Zuazaga
+Julian A. Padget       Bill Page              Susan Pelzel
+Michel Petitot         Didier Pinchon         Ayal Pinkus
+Jose Alfredo Portes
+Claude Quitte
+Arthur C. Ralfs        Norman Ramsey          Anatoly Raportirenko
+Michael Richardson     Renaud Rioboo          Jean Rivlin
+Nicolas Robidoux       Simon Robinson         Raymond Rogers
+Michael Rothstein      Martin Rubey
+Philip Santas          Alfred Scheerhorn      William Schelter
+Gerhard Schneider      Martin Schoenert       Marshall Schor
+Frithjof Schulze       Fritz Schwarz          Nick Simicich
+William Sit            Elena Smirnova         Jonathan Steinbach
+Fabio Stumbo           Christine Sundaresan   Robert Sutor
+Moss E. Sweedler       Eugene Surowitz
+Max Tegmark            James Thatcher         Balbir Thomas
+Mike Thomas            Dylan Thurston         Barry Trager
+Themos T. Tsikas
+Gregory Vanuxem
+Bernhard Wall          Stephen Watt           Jaap Weel
+Juergen Weiss          M. Weller              Mark Wegman
+James Wen              Thorsten Werther       Michael Wester
+John M. Wiley          Berhard Will           Clifton J. Williamson
+Stephen Wilson         Shmuel Winograd        Robert Wisbauer
+Sandra Wityak          Waldemar Wiwianka      Knut Wolf
+Clifford Yapp          David Yun
+Vadim Zhytnikov        Richard Zippel         Evelyn Zoernack
+Bruno Zuercher         Dan Zwillinger
+--E 28
+
 )spool
 )lisp (bye)
  
diff --git a/src/interp/i-syscmd.boot.pamphlet b/src/interp/i-syscmd.boot.pamphlet
index 771c0ae..4597564 100644
--- a/src/interp/i-syscmd.boot.pamphlet
+++ b/src/interp/i-syscmd.boot.pamphlet
@@ -270,408 +270,6 @@ getSystemCommandLine() ==
 
 ------------ start of commands ------------------------------------------
 
---% )close
-
-queryClients () ==
-  -- Returns the number of active scratchpad clients
-  sockSendInt($SessionManager, $QueryClients)
-  sockGetInt $SessionManager
-
-
-close args ==
-  $saturn => 
-    sayErrorly('"Obsolete system command", _
-      ['" The )close  system command is obsolete in this version of AXIOM.",
-       '" Please use Close from the File menu instead."])
-  quiet:local:= false
-  null $SpadServer =>
-    throwKeyedMsg('"S2IZ0071", [])
-  numClients := queryClients()
-  numClients > 1 =>
-    sockSendInt($SessionManager, $CloseClient)
-    sockSendInt($SessionManager, $currentFrameNum)
-    closeInterpreterFrame(NIL)
-  for [opt,:.] in $options repeat
-    fullopt := selectOptionLC(opt, '(quiet), 'optionError)
-    fullopt = 'quiet   =>
-           quiet:=true
-  quiet =>
-    sockSendInt($SessionManager, $CloseClient)
-    sockSendInt($SessionManager, $currentFrameNum)
-    closeInterpreterFrame(NIL)
-  x := UPCASE queryUserKeyedMsg('"S2IZ0072", nil)
-  MEMQ(STRING2ID_-N(x,1), '(YES Y)) =>
-    BYE()
-  nil
-
---% )constructor
-
-constructor args ==
-  sayMessage '"   Not implemented yet."
-  NIL
-
---% )compiler
-
-compiler args ==
-    $newConlist: local := nil    --reset by compDefineLisplib and astran
-    null args and null $options and null _/EDITFILE => helpSpad2Cmd '(compiler)
-    if null args then args := [_/EDITFILE]
-
-    -- first see if the user has explicitly specified the compiler
-    -- to use.
-
-    optlist := '(new old translate constructor)
-    haveNew := nil
-    haveOld := nil
-    for opt in $options while ^(haveNew and haveOld) repeat
-        [optname,:optargs] := opt
-        fullopt := selectOptionLC(optname,optlist,nil)
-        fullopt = 'new => haveNew := true
-        fullopt = 'translate => haveOld := true
-        fullopt = 'constructor => haveOld := true
-        fullopt = 'old => haveOld := true
-
-    haveNew and haveOld => throwKeyedMsg("S2IZ0081", nil)
-
-    af  := pathname args
-    aft := pathnameType af
--- Whats this for? MCD/PAB 21-9-95
---    if haveNew and (null(aft) or (aft = '"")) then
---        af := pathname [af, '"as"]
---        aft = '"as"
---    if haveOld and (null(aft) or (aft = '"")) then
---        af := pathname [af, '"spad"]
---        aft = '"spad"
-
-    haveNew or (aft = '"as")   =>
-        not (af1 := $FINDFILE (af, '(as))) =>
-            throwKeyedMsg("S2IL0003",[NAMESTRING af])
-        compileAsharpCmd [af1]
-    haveOld or (aft = '"spad") =>
-        not (af1 := $FINDFILE (af, '(spad))) =>
-            throwKeyedMsg("S2IL0003",[NAMESTRING af])
-        compileSpad2Cmd  [af1]
-    aft = '"lsp"   =>
-        not (af1 := $FINDFILE (af, '(lsp))) =>
-            throwKeyedMsg("S2IL0003",[NAMESTRING af])
-        compileAsharpLispCmd [af1]
-    aft = '"nrlib"  =>
-        not (af1 := $FINDFILE (af, '(nrlib))) =>
-            throwKeyedMsg("S2IL0003",[NAMESTRING af])
-        compileSpadLispCmd [af1]
-    aft = '"ao"   =>
-        not (af1 := $FINDFILE (af, '(ao))) =>
-            throwKeyedMsg("S2IL0003",[NAMESTRING af])
-        compileAsharpCmd [af1]
-    aft = '"al"   =>    -- archive library of .ao files
-        not (af1 := $FINDFILE (af, '(al))) =>
-            throwKeyedMsg("S2IL0003",[NAMESTRING af])
-        compileAsharpArchiveCmd [af1]
-
-    -- see if we something with the appropriate file extension
-    -- lying around
-
-    af1 := $FINDFILE (af, '(as spad ao asy))
-
-    af1 and pathnameType(af1) = '"as"   => compileAsharpCmd [af1]
-    af1 and pathnameType(af1) = '"ao"  => compileAsharpCmd [af1]
-    af1 and pathnameType(af1) = '"spad" => compileSpad2Cmd  [af1]
-    af1 and pathnameType(af1) = '"asy"  => compileAsharpArchiveCmd [af1]
-
-    -- maybe /EDITFILE has some stuff that can help us
-    ef := pathname _/EDITFILE
-    ef := mergePathnames(af,ef)
-
-    ef = af => throwKeyedMsg("S2IZ0039", nil)
-    af := ef
-
-    pathnameType(af) = '"as"   => compileAsharpCmd args
-    pathnameType(af) = '"ao"  => compileAsharpCmd args
-    pathnameType(af) = '"spad" => compileSpad2Cmd  args
-
-    -- see if we something with the appropriate file extension
-    -- lying around
-    af1 := $FINDFILE (af, '(as spad ao asy))
-
-    af1 and pathnameType(af1) = '"as"   => compileAsharpCmd [af1]
-    af1 and pathnameType(af1) = '"ao"  => compileAsharpCmd [af1]
-    af1 and pathnameType(af1) = '"spad" => compileSpad2Cmd  [af1]
-    af1 and pathnameType(af1) = '"asy"  => compileAsharpArchiveCmd [af1]
-
-    throwKeyedMsg("S2IZ0039", nil)
-
-compileAsharpCmd args ==
-    compileAsharpCmd1 args
-    terminateSystemCommand()
-    spadPrompt()
-
-compileAsharpCmd1 args ==
-    -- Assume we entered from the "compiler" function, so args ^= nil
-    -- and is a file with file extension .as or .ao
-
-    path := pathname args
-    pathType := pathnameType path
-    (pathType ^= '"as") and (pathType ^= '"ao") => throwKeyedMsg("S2IZ0083", nil)
-    ^PROBE_-FILE path => throwKeyedMsg("S2IL0003",[namestring args])
-
-    SETQ(_/EDITFILE, path)
-    updateSourceFiles path
-
-    optList :=  '( _
-      new _
-      old _
-      translate _
-      onlyargs _
-      moreargs _
-      quiet _
-      nolispcompile _
-      noquiet _
-      library _
-      nolibrary _
-        )
-
-    beQuiet := false         -- be verbose here
-    doLibrary  := true       -- so a )library after compilation
-    doCompileLisp := true    -- do compile generated lisp code
-
-    moreArgs := NIL
-    onlyArgs := NIL
-
-    for opt in $options repeat
-        [optname,:optargs] := opt
-        fullopt := selectOptionLC(optname,optList,nil)
-
-        fullopt = 'new       => nil
-        fullopt = 'old       => error "Internal error: compileAsharpCmd got )old"
-        fullopt = 'translate => error "Internal error: compileAsharpCmd got )translate"
-
-        fullopt = 'quiet     => beQuiet := true
-        fullopt = 'noquiet   => beQuiet := false
-
-        fullopt = 'nolispcompile   => doCompileLisp := false
-
-        fullopt = 'moreargs  => moreArgs := optargs
-        fullopt = 'onlyargs  => onlyArgs := optargs
-
-        fullopt = 'library   => doLibrary  := true
-        fullopt = 'nolibrary => doLibrary  := false
-
-        throwKeyedMsg("S2IZ0036",[STRCONC('")",object2String optname)])
-
-    tempArgs :=
-        pathType = '"ao" =>
-            -- want to strip out -Fao
-            (p := STRPOS('"-Fao", $asharpCmdlineFlags, 0, NIL)) =>
-                p = 0 => SUBSTRING($asharpCmdlineFlags, 5, NIL)
-                STRCONC(SUBSTRING($asharpCmdlineFlags, 0, p), '" ",
-                    SUBSTRING($asharpCmdlineFlags, p+5, NIL))
-            $asharpCmdlineFlags
-        $asharpCmdlineFlags
-
-    asharpArgs :=
-        onlyArgs =>
-            s := ""
-            for a in onlyArgs repeat
-                s := STRCONC(s, '" ", object2String a)
-            s
-        moreArgs =>
-            s := tempArgs
-            for a in moreArgs repeat
-                s := STRCONC(s, '" ", object2String a)
-            s
-        tempArgs
-
-    if ^beQuiet then sayKeyedMsg("S2IZ0038A",[namestring args, asharpArgs])
-
-    command :=
-<<remove TRUENAME>>
-    rc := OBEY command
-
-    if (rc = 0) and doCompileLisp then
-        lsp := fnameMake('".", pathnameName args, '"lsp")
-        if fnameReadable?(lsp) then
-            if ^beQuiet then sayKeyedMsg("S2IZ0089", [namestring lsp])
-            compileFileQuietly(lsp)
-        else
-            sayKeyedMsg("S2IL0003", [namestring lsp])
-
-    if rc = 0 and doLibrary then
-        -- do we need to worry about where the compilation output went?
-        if ^beQuiet then sayKeyedMsg("S2IZ0090", [ pathnameName path ])
-        withAsharpCmd [ pathnameName path ]
-    else if ^beQuiet then
-        sayKeyedMsg("S2IZ0084", nil)
-
-    extendLocalLibdb $newConlist
-
-compileAsharpArchiveCmd args ==
-    -- Assume we entered from the "compiler" function, so args ^= nil
-    -- and is a file with file extension .al. We also assume that
-    -- the name is fully qualified.
-
-    path := pathname args
-    ^PROBE_-FILE path => throwKeyedMsg("S2IL0003",[namestring args])
-
-    -- here is the plan:
-    --   1. extract the file name and try to make a directory based
-    --      on that name.
-    --   2. cd to that directory and ar x the .al file
-    --   3. for each .ao file that shows up, compile it
-    --   4. delete the generated .ao files
-
-    -- First try to make the directory in the current directory
-
-    dir  := fnameMake('".", pathnameName path, '"axldir")
-    exists := PROBE_-FILE dir
-    isDir := directoryp namestring dir
-    exists and isDir ^= 1=>
-        throwKeyedMsg("S2IL0027",[namestring dir, namestring args])
-
-    if isDir ^= 1 then
-        cmd  := STRCONC('"mkdir ", namestring dir)
-        rc   := OBEY cmd
-        rc ^= 0 => throwKeyedMsg("S2IL0027",[namestring dir, namestring args])
-
-    curDir := $CURRENT_-DIRECTORY
-
-    -- cd to that directory and try to unarchive the .al file
-
-    cd [ object2Identifier namestring dir ]
-
-    cmd := STRCONC( '"ar x ", namestring path )
-    rc := OBEY cmd
-    rc ^= 0 =>
-        cd [ object2Identifier namestring curDir ]
-        throwKeyedMsg("S2IL0028",[namestring dir, namestring args])
-
-    -- Look for .ao files
-
-    asos := DIRECTORY '"*.ao"
-    null asos =>
-        cd [ object2Identifier namestring curDir ]
-        throwKeyedMsg("S2IL0029",[namestring dir, namestring args])
-
-    -- Compile the .ao files
-
-    for aso in asos repeat
-        compileAsharpCmd1 [ namestring aso ]
-
-    -- Reset the current directory
-
-    cd [ object2Identifier namestring curDir ]
-
-    terminateSystemCommand()
-    spadPrompt()
-
-compileAsharpLispCmd args ==
-    -- Assume we entered from the "compiler" function, so args ^= nil
-    -- and is a file with file extension .lsp
-
-    path := pathname args
-    ^PROBE_-FILE path => throwKeyedMsg("S2IL0003",[namestring args])
-
-    optList :=  '( _
-      quiet _
-      noquiet _
-      library _
-      nolibrary _
-        )
-
-    beQuiet := false         -- be verbose here
-    doLibrary  := true       -- so a )library after compilation
-
-    for opt in $options repeat
-        [optname,:optargs] := opt
-        fullopt := selectOptionLC(optname,optList,nil)
-
-        fullopt = 'quiet     => beQuiet := true
-        fullopt = 'noquiet   => beQuiet := false
-
-        fullopt = 'library   => doLibrary  := true
-        fullopt = 'nolibrary => doLibrary  := false
-
-        throwKeyedMsg("S2IZ0036",[STRCONC('")",object2String optname)])
-
-    lsp := fnameMake(pathnameDirectory path, pathnameName path, pathnameType path)
-    if fnameReadable?(lsp) then
-        if ^beQuiet then sayKeyedMsg("S2IZ0089", [namestring lsp])
-        compileFileQuietly(lsp)
-    else
-        sayKeyedMsg("S2IL0003", [namestring lsp])
-
-    if doLibrary then
-        -- do we need to worry about where the compilation output went?
-        if ^beQuiet then sayKeyedMsg("S2IZ0090", [ pathnameName path ])
-        withAsharpCmd [ pathnameName path ]
-    else if ^beQuiet then
-        sayKeyedMsg("S2IZ0084", nil)
-    terminateSystemCommand()
-    spadPrompt()
-
-compileSpadLispCmd args ==
-    -- Assume we entered from the "compiler" function, so args ^= nil
-    -- and is a file with file extension .nrlib
-
-    path := pathname fnameMake(first args, '"code", '"lsp")
-    ^PROBE_-FILE path => throwKeyedMsg("S2IL0003",[namestring args])
-
-    optList :=  '( _
-      quiet _
-      noquiet _
-      library _
-      nolibrary _
-        )
-
-    beQuiet := false         -- be verbose here
-    doLibrary  := true       -- so a )library after compilation
-
-    for opt in $options repeat
-        [optname,:optargs] := opt
-        fullopt := selectOptionLC(optname,optList,nil)
-
-        fullopt = 'quiet     => beQuiet := true
-        fullopt = 'noquiet   => beQuiet := false
-
-        fullopt = 'library   => doLibrary  := true
-        fullopt = 'nolibrary => doLibrary  := false
-
-        throwKeyedMsg("S2IZ0036",[STRCONC('")",object2String optname)])
-
-    lsp := fnameMake(pathnameDirectory path, pathnameName path, pathnameType path)
-    if fnameReadable?(lsp) then
-        if ^beQuiet then sayKeyedMsg("S2IZ0089", [namestring lsp])
-        --compileFileQuietly(lsp)
-        RECOMPILE_-LIB_-FILE_-IF_-NECESSARY lsp
-    else
-        sayKeyedMsg("S2IL0003", [namestring lsp])
-
-    if doLibrary then
-        -- do we need to worry about where the compilation output went?
-        if ^beQuiet then sayKeyedMsg("S2IZ0090", [ pathnameName path ])
-        LOCALDATABASE([ pathnameName first args ],[])
-    else if ^beQuiet then
-        sayKeyedMsg("S2IZ0084", nil)
-    terminateSystemCommand()
-    spadPrompt()
-
-withAsharpCmd args ==
-    $options: local := nil
-    LOCALDATABASE(args, $options)
-
---% )copyright -- display copyright notice
-
-summary l ==
- OBEY STRCONC ('"cat ",getEnv('"AXIOM"),'"/lib/summary")
-copyright () ==
- OBEY STRCONC ('"cat ",getEnv('"AXIOM"),'"/lib/copyright")
-
---% )credits -- display credit list
-
-credits() ==
- for i in CREDITS repeat
-  PRINC(i)
-  TERPRI()
-
 --% )display
 
 getParserMacroNames() ==
@@ -886,48 +484,6 @@ editSpad2Cmd l ==
   updateSourceFiles l
   rc
 
---% )help
-
-help l == helpSpad2Cmd l
-
-helpSpad2Cmd args ==
-  -- try to use new stuff first
-  if newHelpSpad2Cmd(args) then return nil
-
-  sayKeyedMsg("S2IZ0025",[args])
-  nil
-
-newHelpSpad2Cmd args ==
-  if null args then args := ["?"]
-  # args > 1 =>
-    sayKeyedMsg("S2IZ0026",NIL)
-    true
-  sarg := PNAME first args
-  if sarg = '"?" then args := ['help]
-  else if sarg = '"%" then args := ['history]
-       else if sarg = '"%%" then args := ['history]
-  arg := selectOptionLC(first args,$SYSCOMMANDS,nil)
-  if null arg then arg := first args
-  if arg = 'compiler then arg := 'compile
-
-  -- see if new help file exists
-
-  narg := PNAME arg
-  null (helpFile := MAKE_-INPUT_-FILENAME [narg,'HELPSPAD,'_*]) => NIL
-
-  $useFullScreenHelp =>
-    OBEY STRCONC('"$AXIOM/lib/SPADEDIT ",namestring helpFile)
-    true
-
-  filestream := MAKE_-INSTREAM(helpFile)
-  repeat
-    line := read_-line(filestream,false)
-    NULL line =>
-      SHUT filestream
-      return true
-    SAY line
-  true
-
 --% )load
 
 load args == loadSpad2Cmd args



From MAILER-DAEMON Tue Mar 10 21:28:43 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LhDFS-0004jz-T6
	for mharc-axiom-developer@gnu.org; Tue, 10 Mar 2009 21:28:42 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LhDFQ-0004jt-6I
	for axiom-developer@nongnu.org; Tue, 10 Mar 2009 21:28:40 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LhDFO-0004jh-Ev
	for axiom-developer@nongnu.org; Tue, 10 Mar 2009 21:28:38 -0400
Received: from [199.232.76.173] (port=59278 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LhDFO-0004je-9W
	for axiom-developer@nongnu.org; Tue, 10 Mar 2009 21:28:38 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:59291
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LhDFN-0004se-MB
	for axiom-developer@nongnu.org; Tue, 10 Mar 2009 21:28:38 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n2B1SVug009699;
	Tue, 10 Mar 2009 19:28:31 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n2B1STAM009693;
	Tue, 10 Mar 2009 19:28:29 -0600
Date: Tue, 10 Mar 2009 19:28:29 -0600
Message-Id: <200903110128.n2B1STAM009693@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090310.01.tpd.patch (bookvol10.4 add summary,
	credits to API)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Wed, 11 Mar 2009 01:28:40 -0000

The system commmands summary() and credits() were added to the 
ApplicationProgramInterface (API) package.

I am restructuring the system so that top level internal functions can
be accessed directly by the algebra. These functions will appear in the
API package. These two functions are test cases the general mechanism.

Additionally, a related, outstanding bug 7179 was fixed.

========================================================================
diff --git a/books/bookvol10.4.pamphlet b/books/bookvol10.4.pamphlet
index 33d51d4..68dc386 100644
--- a/books/bookvol10.4.pamphlet
+++ b/books/bookvol10.4.pamphlet
@@ -3648,7 +3648,7 @@ AnyFunctions1(S:Type): with
 )set message test on
 )set message auto off
 )clear all
---S 1 of 3
+--S 1 of 5
 getDomains 'Collection
 --R
 --R   (1)
@@ -3663,7 +3663,7 @@ getDomains 'Collection
 --R                                                             Type: Set Symbol
 --E 1
 
---S 2 of 3
+--S 2 of 5
 difference(getDomains 'IndexedAggregate,getDomains 'Collection)
 --R
 --R   (2)
@@ -3673,17 +3673,115 @@ difference(getDomains 'IndexedAggregate,getDomains 'Collection)
 --R                                                             Type: Set Symbol
 --E 2
 
---S 3 of 3
-)show ApplicationProgramInterface
+--S 3 of 5
+credits()
+--RAn alphabetical listing of contributors to AXIOM:
+--RCyril Alberga          Roy Adler              Christian Aistleitner
+--RRichard Anderson       George Andrews         S.J. Atkins
+--RHenry Baker            Stephen Balzac         Yurij Baransky
+--RDavid R. Barton        Gerald Baumgartner     Gilbert Baumslag
+--RJay Belanger           David Bindel           Fred Blair
+--RVladimir Bondarenko    Mark Botch
+--RAlexandre Bouyer       Peter A. Broadbery     Martin Brock
+--RManuel Bronstein       Stephen Buchwald       Florian Bundschuh
+--RLuanne Burns           William Burge
+--RQuentin Carpent        Robert Caviness        Bruce Char
+--ROndrej Certik          Cheekai Chin           David V. Chudnovsky
+--RGregory V. Chudnovsky  Josh Cohen             Christophe Conil
+--RDon Coppersmith        George Corliss         Robert Corless
+--RGary Cornell           Meino Cramer           Claire Di Crescenzo
+--RDavid Cyganski
+--RTimothy Daly Sr.       Timothy Daly Jr.       James H. Davenport
+--RDidier Deshommes       Michael Dewar
+--RJean Della Dora        Gabriel Dos Reis       Claire DiCrescendo
+--RSam Dooley             Lionel Ducos           Martin Dunstan
+--RBrian Dupee            Dominique Duval
+--RRobert Edwards         Heow Eide-Goodman      Lars Erickson
+--RRichard Fateman        Bertfried Fauser       Stuart Feldman
+--RBrian Ford             Albrecht Fortenbacher  George Frances
+--RConstantine Frangos    Timothy Freeman        Korrinn Fu
+--RMarc Gaetano           Rudiger Gebauer        Kathy Gerber
+--RPatricia Gianni        Samantha Goldrich      Holger Gollan
+--RTeresa Gomez-Diaz      Laureano Gonzalez-Vega Stephen Gortler
+--RJohannes Grabmeier     Matt Grayson           Klaus Ebbe Grue
+--RJames Griesmer         Vladimir Grinberg      Oswald Gschnitzer
+--RJocelyn Guidry
+--RSteve Hague            Satoshi Hamaguchi      Mike Hansen
+--RRichard Harke          Vilya Harvey           Martin Hassner
+--RArthur S. Hathaway     Dan Hatton             Waldek Hebisch
+--RKarl Hegbloom          Ralf Hemmecke          Henderson
+--RAntoine Hersen         Gernot Hueber
+--RPietro Iglio
+--RAlejandro Jakubi       Richard Jenks
+--RKai Kaminski           Grant Keady            Tony Kennedy
+--RPaul Kosinski          Klaus Kusche           Bernhard Kutzler
+--RTim Lahey              Larry Lambe            Franz Lehner
+--RFrederic Lehobey       Michel Levaud          Howard Levy
+--RLiu Xiaojun            Rudiger Loos           Michael Lucks
+--RRichard Luczak
+--RCamm Maguire           Francois Maltey        Alasdair McAndrew
+--RBob McElrath           Michael McGettrick     Ian Meikle
+--RDavid Mentre           Victor S. Miller       Gerard Milmeister
+--RMohammed Mobarak       H. Michael Moeller     Michael Monagan
+--RMarc Moreno-Maza       Scott Morrison         Joel Moses
+--RMark Murray
+--RWilliam Naylor         C. Andrew Neff         John Nelder
+--RGodfrey Nolan          Arthur Norman          Jinzhong Niu
+--RMichael O'Connor       Summat Oemrawsingh     Kostas Oikonomou
+--RHumberto Ortiz-Zuazaga
+--RJulian A. Padget       Bill Page              Susan Pelzel
+--RMichel Petitot         Didier Pinchon         Ayal Pinkus
+--RJose Alfredo Portes
+--RClaude Quitte
+--RArthur C. Ralfs        Norman Ramsey          Anatoly Raportirenko
+--RMichael Richardson     Renaud Rioboo          Jean Rivlin
+--RNicolas Robidoux       Simon Robinson         Raymond Rogers
+--RMichael Rothstein      Martin Rubey
+--RPhilip Santas          Alfred Scheerhorn      William Schelter
+--RGerhard Schneider      Martin Schoenert       Marshall Schor
+--RFrithjof Schulze       Fritz Schwarz          Nick Simicich
+--RWilliam Sit            Elena Smirnova         Jonathan Steinbach
+--RFabio Stumbo           Christine Sundaresan   Robert Sutor
+--RMoss E. Sweedler       Eugene Surowitz
+--RMax Tegmark            James Thatcher         Balbir Thomas
+--RMike Thomas            Dylan Thurston         Barry Trager
+--RThemos T. Tsikas
+--RGregory Vanuxem
+--RBernhard Wall          Stephen Watt           Jaap Weel
+--RJuergen Weiss          M. Weller              Mark Wegman
+--RJames Wen              Thorsten Werther       Michael Wester
+--RJohn M. Wiley          Berhard Will           Clifton J. Williamson
+--RStephen Wilson         Shmuel Winograd        Robert Wisbauer
+--RSandra Wityak          Waldemar Wiwianka      Knut Wolf
+--RClifford Yapp          David Yun
+--RVadim Zhytnikov        Richard Zippel         Evelyn Zoernack
+--RBruno Zuercher         Dan Zwillinger
+--R                                                                   Type: Void
+--E 3
+
+@
+The summary command simply types out the contents of the file
+\$AXIOM/lib/summary so no output is captured in the spool file.
+<<ApplicationProgramInterface.input>>=
+--S 4 of 5
+summary()
+--R 
+--R                                                                   Type: Void
+--E 4
+
+--S 5 of 5
+)show API
 --R ApplicationProgramInterface  is a package constructor
 --R Abbreviation for ApplicationProgramInterface is API 
 --R This constructor is exposed in this frame.
 --R Issue )edit bookvol10.4.spad.pamphlet to see algebra source code for API 
 --R
 --R------------------------------- Operations --------------------------------
---R getDomains : Symbol -> Set Symbol    
+--R credits : () -> Void                  getDomains : Symbol -> Set Symbol
+--R summary : () -> Void                 
 --R
---E 3
+--E 5
+
 )spool
 )lisp (bye)
 @
@@ -3720,6 +3818,11 @@ This can be used to form the set-difference of two categories:
     SplitHomogeneousDirectProduct}
                                                              Type: Set Symbol
 
+The credits function prints a list of the people who have contributed
+to the development of Axiom. This is equivalent to the )credits command.
+
+The summary function prints a short list of useful console commands.
+
 @
 \pagehead{ApplicationProgramInterface}{API}
 \pagepic{ps/v104applicationprograminterface.ps}{API}{1.00}
@@ -3738,15 +3841,27 @@ This can be used to form the set-difference of two categories:
 ApplicationProgramInterface(): Exports == Implementation where
   Exports ==> with
     getDomains : Symbol -> Set Symbol
-      ++ getDomains takes a category and returns the list of domains
+      ++ The getDomains(s) takes a category and returns the list of domains
       ++ that have that category
       ++
       ++X getDomains 'IndexedAggregate
+    credits : () -> Void
+      ++ credits() prints a list of people who contributed to Axiom
+      ++
+      ++X credits()
+    summary : () -> Void
+      ++ summary() prints a short list of useful console commands
+      ++
+      ++X summary()
   Implementation ==> add
     getDomains(cat:Symbol):Set(Symbol) == 
       set [symbol car first destruct a _
         for a in (destruct domainsOf(cat,NIL$Lisp)$Lisp)::List(SExpression)]
 
+    credits() == ( credits()$Lisp ; void() )
+
+    summary() == ( summary()$Lisp ; void() )
+
 @
 <<API.dotabb>>=
 "API" [color="#FF4488",href="bookvol10.4.pdf#nameddest=APPRULE"]
diff --git a/changelog b/changelog
index 244900f..d83478a 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,6 @@
+20090310 tpd src/axiom-website/patches.html 20090310.01.tpd.patch
+20090310 tpd src/interp/daase.lisp fix bug 7179 spurious )abbrev failure
+20090310 tpd books/bookvol10.4 add credits, summary to API package
 20090308 tpd src/axiom-website/patches.html 20090308.03.tpd.patch
 20090308 tpd src/input/unittest1.input unit test commands
 20090308 tpd src/interp/i-syscmd.boot move commands to bookvol5
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index 80e328c..ff6e7a9 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -997,5 +997,7 @@ bookvol5 add include, abbreviation roots<br/>
 bookvol5 add clear root<br/>
 <a href="patches/20090308.03.tpd.patch">20090308.03.tpd.patch</a>
 bookvol5 add summary, copyright, help roots<br/>
+<a href="patches/20090310.01.tpd.patch">20090310.01.tpd.patch</a>
+bookvol10.4 add credits, summary to API package<br/>
  </body>
 </html>
diff --git a/src/interp/daase.lisp.pamphlet b/src/interp/daase.lisp.pamphlet
index c9498a3..ab1cfcb 100644
--- a/src/interp/daase.lisp.pamphlet
+++ b/src/interp/daase.lisp.pamphlet
@@ -1141,7 +1141,7 @@ database.
       (do ((ln (read-line f nil eof) (read-line f nil eof))
            (line 0 (incf line)))
           ((eq ln eof))
-     (when (search ")abb" ln)
+     (when (and (setq mark (search ")abb" ln)) (= mark 0))
        (setq mark (position #\space ln :from-end t))
        (setq name (intern (string-trim '(#\space) (subseq ln mark))))
        (cond



From MAILER-DAEMON Wed Mar 11 09:18:46 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LhOKc-0004Hu-GY
	for mharc-axiom-developer@gnu.org; Wed, 11 Mar 2009 09:18:46 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LhOKb-0004Ho-B9
	for axiom-developer@nongnu.org; Wed, 11 Mar 2009 09:18:45 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LhOKZ-0004HR-6l
	for axiom-developer@nongnu.org; Wed, 11 Mar 2009 09:18:44 -0400
Received: from [199.232.76.173] (port=45945 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LhOKZ-0004HM-3F
	for axiom-developer@nongnu.org; Wed, 11 Mar 2009 09:18:43 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:47051
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LhOKZ-0003L9-2m
	for axiom-developer@nongnu.org; Wed, 11 Mar 2009 09:18:43 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n2BDIfug013762;
	Wed, 11 Mar 2009 07:18:41 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n2BDId35013751;
	Wed, 11 Mar 2009 07:18:39 -0600
Date: Wed, 11 Mar 2009 07:18:39 -0600
Message-Id: <200903111318.n2BDId35013751@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090311.01.tpd.patch (bookvol5 move quit,
	pquit roots)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Wed, 11 Mar 2009 13:18:45 -0000

The quit and pquit commands were moved from i-syscmd.boot to bookvol5

=====================================================================
diff --git a/books/bookvol5.pamphlet b/books/bookvol5.pamphlet
index f1a64a2..a85da3d 100644
--- a/books/bookvol5.pamphlet
+++ b/books/bookvol5.pamphlet
@@ -7340,6 +7340,21 @@ will be displayed and, indeed, Axiom would still be running.
 \fnref{quit}, and
 \fnref{system}
 
+\subsection{defun pquit}
+<<defun pquit>>=
+(defun |pquit| () (|pquitSpad2Cmd|)) 
+
+@
+
+\subsection{defun pquitSpad2Cmd}
+<<defun pquitSpad2Cmd>>=
+(defun |pquitSpad2Cmd| ()
+ (let ((|$quitCommandType| '|protected|))
+  (declare (special |$quitCommandType|))
+  (|quitSpad2Cmd|)))
+
+@
+
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{quit}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@@ -7391,6 +7406,31 @@ executed when you press, say, a function key.
 \fnref{pquit}, and
 \fnref{system}
 
+\subsection{defun quit}
+<<defun quit>>=
+(defun |quit| () (|quitSpad2Cmd|))
+
+@
+\subsection{defun quitSpad2Cmd}
+<<defun quitSpad2Cmd>>=
+(defun |quitSpad2Cmd| ()
+ (if (eq |$quitCommandType| '|protected|)
+  (let (x)
+   (setq x (upcase (|queryUserKeyedMsg| 's2iz0031 nil)))
+   (when (memq (string2id-n x 1) '(y yes)) (|leaveScratchpad|))
+   (|sayKeyedMsg| 's2iz0032 nil)
+   (tersyscommand))
+   (|leaveScratchpad|)))
+
+
+@
+
+\subsection{defun leaveScratchpad}
+<<defun leaveScratchpad>>=
+(defun |leaveScratchpad| () (bye)) 
+
+@
+
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{read}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@@ -12776,6 +12816,8 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun isListOfIdentifiers>>
 <<defun isListOfIdentifiersOrStrings>>
 
+<<defun leaveScratchpad>>
+
 <<defun make-absolute-filename>>
 <<defun makeHistFileName>>
 <<defun makeInitialModemapFrame>>
@@ -12796,6 +12838,8 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun orderBySlotNumber>>
 
 <<defun pcounters>>
+<<defun pquit>>
+<<defun pquitSpad2Cmd>>
 <<defun previousInterpreterFrame>>
 <<defun prTraceNames>>
 <<defun prTraceNames,fn>>
@@ -12804,6 +12848,8 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun putHist>>
 
 <<defun queryClients>>
+<<defun quit>>
+<<defun quitSpad2Cmd>>
 
 <<defun rassocSub>>
 <<defun readHiFi>>
diff --git a/changelog b/changelog
index d83478a..9c57f29 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,6 @@
+20090311 tpd src/axiom-website/patches.html 20090311.01.tpd.patch
+20090311 tpd books/bookvol5 move quit, pquit roots
+20090311 tpd src/interp/i-syscmd.boot move quit, pquit roots
 20090310 tpd src/axiom-website/patches.html 20090310.01.tpd.patch
 20090310 tpd src/interp/daase.lisp fix bug 7179 spurious )abbrev failure
 20090310 tpd books/bookvol10.4 add credits, summary to API package
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index ff6e7a9..ad4f219 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -999,5 +999,7 @@ bookvol5 add clear root<br/>
 bookvol5 add summary, copyright, help roots<br/>
 <a href="patches/20090310.01.tpd.patch">20090310.01.tpd.patch</a>
 bookvol10.4 add credits, summary to API package<br/>
+<a href="patches/20090311.01.tpd.patch">20090311.01.tpd.patch</a>
+bookvol5 add quit, pquit roots<br/>
  </body>
 </html>
diff --git a/src/interp/i-syscmd.boot.pamphlet b/src/interp/i-syscmd.boot.pamphlet
index 4597564..19de874 100644
--- a/src/interp/i-syscmd.boot.pamphlet
+++ b/src/interp/i-syscmd.boot.pamphlet
@@ -538,33 +538,6 @@ reportCount () ==
   SAY " "
   sayBrightly [:bright " stream",fillerSpaces(29,'".")," ",$streamCount]
 
---% )quit
-
-pquit() == pquitSpad2Cmd()
-
-pquitSpad2Cmd() ==
-  $saturn =>
-    sayErrorly('"Obsolete system command", _
-      ['" The )pquit system command is obsolete in this version of AXIOM.",
-       '" Please select Exit from the File Menu instead."])
-  $quitCommandType :local := 'protected
-  quitSpad2Cmd()
-
-quit() == quitSpad2Cmd()
-
-quitSpad2Cmd() ==
-  $saturn =>
-    sayErrorly('"Obsolete system command", _
-      ['" The )quit system command is obsolete in this version of AXIOM.",
-       '" Please select Exit from the File Menu instead."])
-  $quitCommandType ^= 'protected => leaveScratchpad()
-  x := UPCASE queryUserKeyedMsg("S2IZ0031",NIL)
-  MEMQ(STRING2ID_-N(x,1),'(Y YES)) => leaveScratchpad()
-  sayKeyedMsg("S2IZ0032",NIL)
-  TERSYSCOMMAND ()
-
-leaveScratchpad () == BYE()
-
 --% )read
 
 read l == readSpad2Cmd l



From MAILER-DAEMON Mon Mar 16 05:43:10 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Lj9Li-0002NX-8n
	for mharc-axiom-developer@gnu.org; Mon, 16 Mar 2009 05:43:10 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Lj9Lg-0002Mb-7c
	for axiom-developer@nongnu.org; Mon, 16 Mar 2009 05:43:08 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Lj9Lb-0002L4-RF
	for axiom-developer@nongnu.org; Mon, 16 Mar 2009 05:43:07 -0400
Received: from [199.232.76.173] (port=48867 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Lj9Lb-0002Kn-Jo
	for axiom-developer@nongnu.org; Mon, 16 Mar 2009 05:43:03 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:59179
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1Lj9La-0001CK-E5
	for axiom-developer@nongnu.org; Mon, 16 Mar 2009 05:43:03 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n2G9gwug004717;
	Mon, 16 Mar 2009 03:42:58 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n2G9guHa004714;
	Mon, 16 Mar 2009 03:42:56 -0600
Date: Mon, 16 Mar 2009 03:42:56 -0600
Message-Id: <200903160942.n2G9guHa004714@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090315.01.tpd.patch (bookvol5 collect set
	support code)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 16 Mar 2009 09:43:08 -0000

The )set tree data structure has supporting functions for initialization.
These functions were collected into bookvol5, rewritten from boot to lisp,
and documented.

=======================================================================
diff --git a/books/bookvol5.pamphlet b/books/bookvol5.pamphlet
index 13ea50b..056019a 100644
--- a/books/bookvol5.pamphlet
+++ b/books/bookvol5.pamphlet
@@ -7594,11 +7594,197 @@ userlevel  operation access level of system user      development
 
 Variables with current values of ... have further sub-options. 
 For example, issue )set  system to see what the options are 
-for system. 
-For more information, issue )help set .
+for system. For more information, issue )help set .
+
+\end{verbatim}
+\section{)set list functions}
+\subsection{defun initializeSetVariables}
+The argument settree is initially the \verb|$setOption| variable.
+The fourth element is a union-style switch symbol.
+The fifth element is usually a variable to set.
+The sixth element is a subtree to recurse for the TREE switch.
+The seventh element is usually the default value. For more detailed
+explanations see the list structure section \ref{Theliststructure}.
+<<defun initializeSetVariables>>=
+(defun |initializeSetVariables| (settree) 
+ (dolist (setdata settree)
+  (case (fourth setdata)
+   (FUNCTION
+      (if (|functionp| (fifth setdata))
+        (funcall (fifth setdata) '|%initialize%|))
+        (|sayMSG| "   Function not implemented."))
+   (INTEGER (set (fifth setdata) (seventh setdata)))
+   (STRING  (set (fifth setdata) (seventh setdata)))
+   (LITERALS
+       (set (fifth setdata) (|translateYesNo2TrueFalse| (seventh setdata))))
+   (TREE  (|initializeSetVariables| (sixth setdata))))))
+
+@
+
+\subsection{defun resetWorkspaceVariables}
+<<defun resetWorkspaceVariables>>=
+(defun |resetWorkspaceVariables| () 
+  (setq /countlist nil)
+  (setq /editfile nil)
+  (setq /sourcefiles nil)
+  (setq |$sourceFiles| nil)
+  (setq /pretty nil)
+  (setq /spacelist nil)
+  (setq /timerlist nil)
+  (setq |$existingFiles| (make-hashtable 'uequal))
+  (setq |$functionTable| nil)
+  (setq $boot nil)
+  (setq |$compileMapFlag| nil)
+  (setq |$echoLineStack| nil)
+  (setq |$operationNameList| nil)
+  (setq |$slamFlag| nil)
+  (setq |$CommandSynonymAlist| (copy |$InitialCommandSynonymAlist|))
+  (setq |$UserAbbreviationsAlist| nil)
+  (setq |$msgAlist| nil)
+  (setq |$msgDatabase| nil)
+  (setq |$msgDatabaseName| nil)
+  (setq |$dependeeClosureAlist| nil)
+  (setq |$IOindex| 1)
+  (setq |$coerceIntByMapCounter| 0)
+  (setq |$e| (cons (cons nil nil) nil))
+  (setq |$env| (cons (cons nil nil) nil))
+  (|initializeSetVariables| |$setOptions|)) 
 
-\end{verbatim}
-\subsection{The list structure}
+@
+
+\subsection{defun displaySetOptionInformation}
+<<defun displaySetOptionInformation>>=
+(defun |displaySetOptionInformation| (arg setdata)
+ (let (current)
+  (cond
+   ((eq (fourth setdata) 'tree)
+    (|displaySetVariableSettings| (sixth setdata) (first setdata)))
+   (t 
+    (|centerAndHighlight|
+     (strconc "The " (|object2String| arg) " Option")
+      $linelength (|specialChar| '|hbar|))
+    (|sayBrightly|
+     `(|%l| ,@(|bright| "Description:") ,(second setdata)))
+    (case (fourth setdata)
+     (FUNCTION
+      (terpri)
+      (cond 
+       ((|functionp| (fifth setdata))
+         (funcall (fifth setdata) '|%describe%|))
+       (t (|sayMSG| "   Function not implemented."))))
+     (INTEGER
+      (|sayMessage| 
+        `(" The" ,@(|bright| arg) "option" 
+          " may be followed by an integer in the range" 
+          ,@(|bright| (ELT (sixth setdata) 0)) "to" 
+          |%l| ,@(|bright| (ELT (sixth setdata) 1)) "inclusive." 
+          " The current setting is" ,@(|bright| (|eval| (fifth setdata))))))
+     (STRING
+      (|sayMessage| 
+        `(" The" ,@(|bright| arg) "option" 
+          " is followed by a string enclosed in double quote marks." 
+          '|%l| " The current setting is" 
+          ,@(|bright| (list '|"| (|eval| (fifth setdata)) '|"|)))))
+     (LITERALS
+       (|sayMessage|
+        `(" The" ,@(|bright| arg) "option"
+              " may be followed by any one of the following:"))
+       (setq current 
+        (|translateTrueFalse2YesNo| (|eval| (fifth setdata))))
+       (dolist (name (sixth setdata))
+         (if (boot-equal name current)
+           (|sayBrightly| `( " ->" ,@(|bright| (|object2String| name))))
+           (|sayBrightly| (list "    " (|object2String| name)))))
+       (|sayMessage| " The current setting is indicated.")))))))
+
+@
+
+\subsection{defun displaySetVariableSettings}
+<<defun displaySetVariableSettings>>=
+(defun |displaySetVariableSettings| (settree label)
+ (let (setoption st opt subtree subname)
+  (cond
+   ((eq label '||) (setq label ")set"))
+   (t (setq label (strconc "  " (|object2String| label) " "))))
+  (|centerAndHighlight|
+    (strconc "Current Values of" label " Variables") $linelength '| |)
+  (terpri)
+  (|sayBrightly| 
+   (list "Variable     " "Description                                "
+         "Current Value" ))
+  (say (|fillerSpaces| $linelength (|specialChar| '|hbar|)))
+  (setq subtree nil)
+  (dolist (setdata settree)
+   (when (|satisfiesUserLevel| (third setdata))
+     (setq setoption (|object2String| (first setdata)))
+     (setq setoption
+      (strconc setoption
+       (|fillerSpaces| (spaddifference 13 (|#| setoption)) " ")
+       (second setdata)))
+     (setq setoption
+      (strconc setoption
+       (|fillerSpaces| (spaddifference 55 (|#| setoption)) " ")))
+     (setq st (fourth setdata))
+     (case (fourth setdata)
+      (FUNCTION
+       (setq opt
+        (if (|functionp| (fifth setdata))
+         (funcall (fifth setdata) '|%display%|)
+         "unimplemented"))
+       (cond
+        ((pairp opt)
+         (setq opt
+          (do ((t2 opt (cdr t2)) t1 (|o| nil))
+              ((or (atom t2) (progn (setq |o| (car t2)) nil)) t1)
+           (setq t1 (append t1 (cons |o| (cons " " nil))))))))
+       (|sayBrightly| (|concat| setoption '|%b| opt '|%d|)))
+      (STRING
+       (setq opt (|object2String| (|eval| (fifth setdata))))
+       (|sayBrightly| `(,setoption ,@(|bright| opt))))
+      (INTEGER
+       (setq opt (|object2String| (|eval| (fifth setdata))))
+       (|sayBrightly| `(,setoption ,@(|bright| opt))))
+      (LITERALS
+       (setq opt (|object2String| 
+             (|translateTrueFalse2YesNo| (|eval| (fifth setdata)))))
+       (|sayBrightly| `(,setoption ,@(|bright| opt))))
+      (TREE
+         (|sayBrightly| `(,setoption ,@(|bright| "...")))
+         (setq subtree t)
+         (setq subname (|object2String| (first setdata)))))))
+  (terpri)
+  (when subtree
+     (|sayBrightly|
+      `("Variables with current values of" ,@(|bright| "...")
+            "have further sub-options. For example,"))
+     (|sayBrightly|
+      `("issue" ,@(|bright| ")set ") ,subname
+        " to see what the options are for" ,@(|bright| subname) "."
+        |%l| "For more information, issue" ,@(|bright| ")help set") ".")))))
+
+@
+
+\subsection{defun translateYesNo2TrueFalse}
+<<defun translateYesNo2TrueFalse>>=
+(defun |translateYesNo2TrueFalse| (x)
+ (cond
+  ((|member| x '(|yes| |on|)) t)
+  ((|member| x '(|no| |off|)) nil)
+  (t x))) 
+
+@
+
+\subsection{defun translateTrueFalse2YesNo}
+<<defun translateTrueFalse2YesNo>>=
+(defun |translateTrueFalse2YesNo| (x)
+ (cond
+  ((eq x t) '|on|)
+  ((null x) '|off|)
+  (t x))) 
+
+@
+\section{The list structure}
+\label{Theliststructure}
 The structure of each list item consists of 7 items.  Consider this 
 example:
 \begin{verbatim}
@@ -7621,9 +7807,7 @@ the user would see "operation access level of system user".
 accepted. There are three levels: interpreter, compiler, development.
 These commands are restricted to keep the user from causing damage.
 \item {\bf 4} {\sl Type} a symbol, one of {\bf FUNCTION}, {\bf INTEGER},
-{\bf STRING}, {\bf LITERALS}, {\bf FILENAME} or {\bf TREE}. See the function
-{\bf initializeSetVariables} in the file
-{\bf setvars.boot.pamphlet\cite{2}}.
+{\bf STRING}, {\bf LITERALS}, {\bf FILENAME} or {\bf TREE}. 
 \item {\bf 5} {\sl Var} 
 \begin{list}{}
 \item FUNCTION is the function to call
@@ -7721,6 +7905,46 @@ args         arguments for compiling AXIOM code
        |htSetOutputLibrary|
 	)
 @
+\subsection{defun setOutputLibrary}
+<<defun setOutputLibrary>>=
+(defun |setOutputLibrary| (arg)
+ (let (fn)
+   (cond
+    ((eq arg '|%initialize%|) (setq |$outputLibraryName| nil))
+    ((eq arg '|%display%|) (or |$outputLibraryName| "user.lib"))
+    ((or (null arg) (eq arg '|%describe%|) (eq (car arg) '?) (/= (|#| arg) 1))
+     (|describeOutputLibraryArgs|))
+    (t
+     (when (filep (setq fn (stringimage (car arg))))
+       (setq fn (truename fn)))
+     (|openOutputLibrary| (setq |$outputLibraryName| fn))))))
+
+@
+
+\subsection{defun describeOutputLibraryArgs}
+<<defun describeOutputLibraryArgs>>=
+(defun |describeOutputLibraryArgs| ()
+ (|sayBrightly| (list
+  '|%b| ")set compiler output library"
+  '|%d| "is used to tell the compiler where to place"
+  '|%l| "compiled code generated by the library compiler.  By default it goes"
+  '|%l| "in a file called"
+  '|%b| "user.lib"
+  '|%d| "in the current directory.")))
+
+@
+
+\subsection{defun openOutputLibrary}
+The input-libraries and output-library are now truename based.
+<<defun openOutputLibrary>>=
+(defun |openOutputLibrary| (lib)
+ (declare (special output-library input-libraries))
+  (|dropInputLibrary| lib)
+  (setq output-library (truename lib))
+  (push output-library input-libraries))
+
+@
+
 \subsection{input}
 \begin{verbatim}
 ---------------------- The input Option -----------------------
@@ -7742,6 +7966,71 @@ args         arguments for compiling AXIOM code
        NIL
        |htSetInputLibrary|)
 @
+
+\subsection{defun setInputLibrary}
+The input-libraries is now maintained as a list of truenames.
+<<defun setInputLibrary>>=
+(defun |setInputLibrary| (arg)
+ (declare (special input-libraries))
+ (let (tmp1 filename act)
+  (cond
+   ((eq arg '|%initialize%|) t)
+   ((eq arg '|%display%|) (mapcar #'namestring input-libraries))
+   ((or (null arg) (eq arg '|%describe%|) (eq (car arg) '?))
+    (|describeInputLibraryArgs|))
+   ((and (pairp arg)
+         (progn
+          (setq act (qcar arg))
+          (setq tmp1 (qcdr arg))
+          (and (pairp tmp1)
+               (eq (qcdr tmp1) nil)
+               (progn (setq filename (qcar tmp1)) t)))
+         (setq act (|selectOptionLC| act '(|add| |drop|) nil)))
+    (cond
+     ((eq act '|add|)
+      (|addInputLibrary| (truename (stringimage filename))))
+     ((eq act '|drop|)
+      (|dropInputLibrary| (truename (stringimage filename))))))
+   (t (|setInputLibrary| nil)))))
+
+@
+
+\subsection{defun describeInputLibraryArgs}
+<<defun describeInputLibraryArgs>>=
+(defun |describeInputLibraryArgs| ()
+ (|sayBrightly| (list
+  '|%b| ")set compiler input add library"
+  '|%d| "is used to tell AXIOM to add"
+  '|%b| "library"
+  '|%d| "to"
+  '|%l| "the front of the path used to find compile code."
+  '|%l|
+  '|%b| ")set compiler input drop library"
+  '|%d| "is used to tell AXIOM to remove"
+  '|%b| "library"
+  '|%d|
+  '|%l| "from this path.")))
+
+@
+
+\subsection{defun addInputLibrary}
+The input-libraries variable is now maintained as a list of truenames.
+<<defun addInputLibrary>>=
+(defun |addInputLibrary| (lib)
+ (declare (special input-libraries))
+  (|dropInputLibrary| lib)
+  (push (truename lib) input-libraries))
+
+@
+
+\subsection{defun dropInputLibrary}
+<<defun dropInputLibrary>>=
+(defun |dropInputLibrary| (lib) 
+ (declare (special input-libraries))
+ (setq input-libraries (delete (truename lib) input-libraries :test #'equal)))
+
+@
+
 \subsection{args}
 \begin{verbatim}
 ----------------------- The args Option -----------------------
@@ -7770,6 +8059,37 @@ args         arguments for compiling AXIOM code
           "-O -Fasy -Fao -Flsp -laxiom -Mno-AXL__W__WillObsolete -DAxiom -Y $AXIOM/algebra"))
        NIL)
 @
+
+\subsection{defun setAsharpArgs}
+<<defun setAsharpArgs>>=
+(defun |setAsharpArgs| (arg)
+ (cond
+  ((eq arg '|%initialize%|)
+   (setq |$asharpCmdlineFlags|
+    "-O -Fasy -Fao -Flsp -laxiom -Mno-AXL_W_WillObsolete -DAxiom -Y $AXIOM/algebra"))
+  ((eq arg '|%display%|) |$asharpCmdlineFlags|)
+  ((or (null arg) (eq arg '|%describe%|) (eq (car arg) '?))
+   (|describeAsharpArgs|))
+  (t (setq |$asharpCmdlineFlags| (car arg))))) 
+
+@
+
+\subsection{defun describeAsharpArgs}
+<<defun describeAsharpArgs>>=
+(defun |describeAsharpArgs| () 
+ (|sayBrightly| (list
+  '|%b| ")set compiler args "
+  '|%d| "is used to tell AXIOM how to invoke the library compiler "
+  '|%l| " when compiling code for AXIOM."
+  '|%l| " The args option is followed by a string enclosed in double quotes."
+  '|%l|
+  '|%l| " The current setting is"
+  '|%l|
+  '|%b| "\"" |$asharpCmdlineFlags| "\""
+  '|%d|)))
+
+@
+
 \section{expose}
 \begin{verbatim}
 ---------------------- The expose Option ----------------------
@@ -9978,6 +10298,12 @@ prettyprint  prettyprint BOOT func's as they compile    off
 
 @
 
+<<postvars>>=
+(eval-when (eval load)
+ (|initializeSetVariables| |$setOptions|)
+
+@
+
 \section{Set code}
 
 \subsection{defun set}
@@ -10027,49 +10353,49 @@ which gets called with \verb|%describe%|
      (|selectOption| (downcase (car l)) |$setOptionNames| '|optionError|))
     (setq setdata (cons arg (lassoc arg settree)))
     (cond
-     ((null (|satisfiesUserLevel| (elt setdata 2)))
+     ((null (|satisfiesUserLevel| (third setdata)))
       (|sayKeyedMsg| 's2iz0007 (list |$UserLevel| "set option" nil)))
      ((eql 1 (|#| l)) (|displaySetOptionInformation| arg setdata))
      (t
-      (setq st (elt setdata 3))
-      (cond
-       ((eq st 'function)
+      (setq st (fourth setdata))
+      (case (fourth setdata)
+       (FUNCTION
         (setq setfunarg
          (if (eq (elt l 1) 'default) 
           '|%initialize%|
           (kdr l)))
-        (if (|functionp| (elt setdata 4))
-          (funcall (elt setdata 4) setfunarg)
+        (if (|functionp| (fifth setdata))
+          (funcall (fifth setdata) setfunarg)
           (|sayMSG| "   Function not implemented."))
         (when |$displaySetValue|
          (|displaySetOptionInformation| arg setdata))
         NIL)
-       ((eq st 'string)
+       (STRING
         (setq arg2 (elt l 1))
         (cond
-         ((eq arg2 'default) (set (elt setdata 4) (elt setdata 6)))
-         (arg2 (set (elt setdata 4) arg2))
+         ((eq arg2 'default) (set (fifth setdata) (seventh setdata)))
+         (arg2 (set (fifth setdata) arg2))
          (t nil))
         (when (or |$displaySetValue| (null arg2))
          (|displaySetOptionInformation| arg setdata))
         NIL)
-       ((eq st 'integer)
+       (INTEGER
         (setq arg2
          (progn
           (setq num (elt l 1))
           (cond
            ((and (fixp num)
-                 (>= num (elt (elt setdata 5) 0))
-                 (or (null (setq upperlimit (elt (elt setdata 5) 1)))
+                 (>= num (elt (sixth setdata) 0))
+                 (or (null (setq upperlimit (elt (sixth setdata) 1)))
                      (<= num upperlimit)))
             num)
            (t
             (|selectOption| 
              (elt l 1)
-             (cons '|default| (elt setdata 5)) nil)))))
+             (cons '|default| (sixth setdata)) nil)))))
         (cond
-         ((eq arg2 'default) (set (elt setdata 4) (elt setdata 6)))
-         (arg2 (set (elt setdata 4) arg2))
+         ((eq arg2 'default) (set (fifth setdata) (seventh setdata)))
+         (arg2 (set (fifth setdata) arg2))
          (t nil))
         (cond
          ((or |$displaySetValue| (null arg2))
@@ -10080,22 +10406,22 @@ which gets called with \verb|%describe%|
            `(" Your value" ,@(|bright| (|object2String| (elt l 1)))
              "is not among the valid choices.")))
          (t nil)))
-       ((eq st 'literals)
+       (LITERALS
         (cond
          ((setq arg2
           (|selectOption| (elt l 1) 
-           (cons '|default| (elt setdata 5)) nil))
+           (cons '|default| (sixth setdata)) nil))
           (cond
            ((eq arg2 'default)
-            (set (elt setdata 4) 
-              (|translateYesNo2TrueFalse| (elt setdata 6))))
+            (set (fifth setdata) 
+              (|translateYesNo2TrueFalse| (seventh setdata))))
            (t
             (cond ((eq arg2 '|nobreak|) (use-fast-links t)))
             (cond 
              ((eq arg2 '|fastlinks|)
               (use-fast-links nil)
               (setq arg2 '|break|)))
-            (set (elt setdata 4) (|translateYesNo2TrueFalse| arg2))))))
+            (set (fifth setdata) (|translateYesNo2TrueFalse| arg2))))))
         (when (or |$displaySetValue| (null arg2))
           (|displaySetOptionInformation| arg setdata))
         (cond
@@ -10105,7 +10431,7 @@ which gets called with \verb|%describe%|
             (append (|bright| (|object2String| (elt l 1)))
              (cons "is not among the valid choices." nil)))))
          (t nil)))
-       ((eq st 'tree) (|set1| (kdr l) (elt setdata 5)) nil)
+       (TREE (|set1| (kdr l) (sixth setdata)) nil)
        (t 
         (|sayMessage|
          `("Cannot handle set tree node type" ,@(|bright| st) |yet|))
@@ -10113,79 +10439,6 @@ which gets called with \verb|%describe%|
 
 @
 
-\subsection{defun displaySetOptionInformation}
-<<defun displaySetOptionInformation>>=
-(defun |displaySetOptionInformation| (arg setdata)
- (let (st current)
-  (setq st (elt setdata 3))
-  (cond
-   ((eq st 'tree)
-    (|displaySetVariableSettings| (elt setdata 5) (elt setdata 0)))
-   (t 
-    (|centerAndHighlight|
-     (strconc "The " (|object2String| arg) " Option")
-      $linelength (|specialChar| '|hbar|))
-    (|sayBrightly|
-     `(|%l| ,@(|bright| "Description:") ,(elt setdata 1)))
-    (cond
-     ((eq st 'function)
-      (terpri)
-      (cond 
-       ((|functionp| (elt setdata 4))
-         (funcall (elt setdata 4) '|%describe%|))
-       (t (|sayMSG| "   Function not implemented."))))
-     ((eq st 'integer)
-      (|sayMessage| 
-        `(" The" ,@(|bright| arg) "option" 
-          " may be followed by an integer in the range" 
-          ,@(|bright| (ELT (ELT setdata 5) 0)) "to" 
-          |%l| ,@(|bright| (ELT (ELT setdata 5) 1)) "inclusive." 
-          " The current setting is" ,@(|bright| (|eval| (elt setdata 4))))))
-     ((eq st 'string)
-      (|sayMessage| 
-        `(" The" ,@(|bright| arg) "option" 
-          " is followed by a string enclosed in double quote marks." 
-          '|%l| " The current setting is" 
-          ,@(|bright| (list '|"| (|eval| (elt setdata 4)) '|"|)))))
-     ((eq st 'literals)
-       (|sayMessage|
-        `(" The" ,@(|bright| arg) "option"
-              " may be followed by any one of the following:"))
-       (setq current 
-        (|translateTrueFalse2YesNo| (|eval| (elt setdata 4))))
-       (do ((t0 (elt setdata 5) (cdr t0)) (|name| nil))
-           ((or (atom t0) (progn (setq |name| (car t0)) nil)) nil)
-        (seq
-         (exit
-          (cond
-           ((boot-equal |name| current)
-            (|sayBrightly| 
-             `( " ->" ,@(|bright| (|object2String| |name|)))))
-           (t
-            (|sayBrightly| (list "    " (|object2String| |name|))))))))
-       (|sayMessage| " The current setting is indicated.")))))))
-
-@
-
-\subsection{defun translateYesNo2TrueFalse}
-<<defun translateYesNo2TrueFalse>>=
-(defun |translateYesNo2TrueFalse| (x)
- (cond
-  ((|member| x '(|yes| |on|)) t)
-  ((|member| x '(|no| |off|)) nil)
-  (t x))) 
-
-@
-
-\subsection{defun translateTrueFalse2YesNo}
-<<defun translateTrueFalse2YesNo>>=
-(defun |translateTrueFalse2YesNo| (x)
- (cond
-  ((eq x t) '|on|)
-  ((null x) '|off|)
-  (t x))) 
-
-@
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{show}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@@ -15314,6 +15567,7 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 
 <<defun abbreviations>>
 <<defun abbreviationsSpad2Cmd>>
+<<defun addInputLibrary>>
 <<defun addNewInterpreterFrame>>
 <<defun addTraceItem>>
 <<defun apropos>>
@@ -15352,6 +15606,9 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun createCurrentInterpreterFrame>>
 <<defun credits>>
 
+<<defun describeAsharpArgs>>
+<<defun describeInputLibraryArgs>>
+<<defun describeOutputLibraryArgs>>
 <<defun dewritify>>
 <<defun dewritify,dewritifyInner>>
 <<defun dewritify,is?>>
@@ -15362,8 +15619,10 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun displayMacros>>
 <<defun displayOperations>>
 <<defun displaySetOptionInformation>>
+<<defun displaySetVariableSettings>>
 <<defun displaySpad2Cmd>>
 <<defun domainToGenvar>>
+<<defun dropInputLibrary>>
 
 <<defun emptyInterpreterFrame>>
 
@@ -15415,6 +15674,7 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun initHist>>
 <<defun initHistList>>
 <<defun initializeInterpreterFrameRing>>
+<<defun initializeSetVariables>>
 <<defun init-memory-config>>
 <<defun initroot>>
 <<defun intloop>>
@@ -15453,6 +15713,7 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun nextInterpreterFrame>>
 
 <<defun oldHistFileName>>
+<<defun openOutputLibrary>>
 <<defun openserver>>
 <<defun orderBySlotNumber>>
 
@@ -15488,6 +15749,7 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun resetInCoreHist>>
 <<defun resetSpacers>>
 <<defun resetTimers>>
+<<defun resetWorkspaceVariables>>
 <<defun restart>>
 <<defun restoreHistory>>
 <<defun runspad>>
@@ -15499,9 +15761,12 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun ScanOrPairVec>>
 <<defun set>>
 <<defun set1>>
+<<defun setAsharpArgs>>
 <<defun setCurrentLine>>
 <<defun setHistoryCore>>
+<<defun setInputLibrary>>
 <<defun setIOindex>>
+<<defun setOutputLibrary>>
 <<defun set-restart-hook>>
 <<defun shortenForPrinting>>
 <<defun showHistory>>
diff --git a/changelog b/changelog
index 5bccecf..1f1e54b 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,11 @@
+20090315 tpd src/axiom-website/patches.html 20090315.01.tpd.patch
+20090315 tpd src/interp/setvars.boot remove set and library handling 
+20090315 tpd src/interp/daase.lisp fix input-libraries
+20090315 tpd src/interp/bootfuns.lisp remove initializeSetVariables
+20090315 tpd src/input/setcmd.input update set tests
+20090315 tpd src/input/cmds.input update cmd tests
+20090315 tpd books/bookvol5 collect set support functions
+20090315 tpd src/interp/daase.lisp remove open-library calls
 20090314 tpd src/axiom-website/patches.html 20090314.01.tpd.patch
 20090314 tpd books/bookvol5 document )set, include root code
 20090314 tpd src/input/Makefile add cmds, setcmd unit tests
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index f477e09..fcaf084 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -1003,5 +1003,7 @@ bookvol10.4 add credits, summary to API package<br/>
 bookvol5 add quit, pquit roots<br/>
 <a href="patches/20090314.01.tpd.patch">20090314.01.tpd.patch</a>
 bookvol5 document )set, include root code<br/>
+<a href="patches/20090315.01.tpd.patch">20090315.01.tpd.patch</a>
+bookvol5 document collect set support functions<br/>
  </body>
 </html>
diff --git a/src/input/cmds.input.pamphlet b/src/input/cmds.input.pamphlet
index 4051b0c..ba7844d 100644
--- a/src/input/cmds.input.pamphlet
+++ b/src/input/cmds.input.pamphlet
@@ -834,6 +834,103 @@
 --R ZDSOLVE  ZeroDimensionalSolvePackage  ZLINDEP  IntegerLinearDependence
 --E 15
 
+@
+This exercises setOutputLibrary, setInputLibrary, and setAsharpArgs
+<<*>>=
+--S 16
+)set compiler
+--R                  Current Values of  compiler  Variables                   
+--R
+--RVariable     Description                                Current Value
+--R-----------------------------------------------------------------------------
+--Routput       library in which to place compiled code     
+--Rinput        controls libraries from which to load compiled code  
+--Rargs         arguments for compiling AXIOM code         -O -Fasy -Fao -Flsp -laxiom -Mno-AXL_W_WillObsolete -DAxiom -Y $AXIOM/algebra 
+--R
+--E 16
+
+@
+This exercises setInputLibrary, describeInputLibraryArgs
+<<*>>=
+--S 17
+)set compiler input
+--R---------------------------- The input Option -----------------------------
+--R
+--R Description: controls libraries from which to load compiled code
+--R
+--R )set compiler input add library is used to tell AXIOM to add library to
+--Rthe front of the path which determines where compiled code is loaded from.
+--R )set compiler input drop library is used to tell AXIOM to remove library 
+--Rfrom this path.
+--E 17
+
+--S
+)set compiler input add
+--R )set compiler input add library is used to tell AXIOM to add library to
+--Rthe front of the path which determines where compiled code is loaded from.
+--R )set compiler input drop library is used to tell AXIOM to remove library 
+--Rfrom this path.
+--E
+
+--S 
+)set compiler input add foo
+--R 
+--R   >> System error:
+--R   OPEN-LIBRARY is invalid as a function.
+--R
+--E
+
+@
+This exercises setOutputLibrary
+<<*>>=
+--S 18
+)set compiler output
+--R---------------------------- The output Option ----------------------------
+--R
+--R Description: library in which to place compiled code
+--R
+--R )set compiler output library is used to tell the compiler where to place
+--Rcompiled code generated by the library compiler.  By default it goes
+--Rin a file called user.lib in the current directory.
+--E 18
+
+@
+This exercises setAsharpArgs
+<<*>>=
+--S 19
+)set compiler args
+--R----------------------------- The args Option -----------------------------
+--R
+--R Description: arguments for compiling AXIOM code
+--R
+--R )set compiler args  is used to tell AXIOM how to invoke the library compiler 
+--R when compiling code for AXIOM.
+--R The args option is followed by a string enclosed in double quotes.
+--R
+--R The current setting is
+--R "-O -Fasy -Fao -Flsp -laxiom -Mno-AXL_W_WillObsolete -DAxiom -Y $AXIOM/algebra" 
+--E 19
+
+This exercises setAsharpArgs
+<<*>>=
+--S 20
+)set compiler args "-TPD"
+--E 20
+
+--S 21
+)set compiler args
+--R----------------------------- The args Option -----------------------------
+--R
+--R Description: arguments for compiling AXIOM code
+--R
+--R )set compiler args  is used to tell AXIOM how to invoke the library compiler 
+--R when compiling code for AXIOM.
+--R The args option is followed by a string enclosed in double quotes.
+--R
+--R The current setting is
+--R "-TPD" 
+--E 21
+
 
 )spool 
 )lisp (bye)
diff --git a/src/input/setcmd.input.pamphlet b/src/input/setcmd.input.pamphlet
index cc01582..399bca1 100644
--- a/src/input/setcmd.input.pamphlet
+++ b/src/input/setcmd.input.pamphlet
@@ -39,7 +39,7 @@
 --R
 --RVariable     Description                                Current Value
 --R-----------------------------------------------------------------------------
---Routput       library in which to place compiled code     
+--Routput       library in which to place compiled code    user.lib 
 --Rinput        controls libraries from which to load compiled code  
 --Rargs         arguments for compiling AXIOM code         -O -Fasy -Fao -Flsp -laxiom -Mno-AXL_W_WillObsolete -DAxiom -Y $AXIOM/algebra 
 --R
@@ -51,7 +51,7 @@
 --R
 --RVariable     Description                                Current Value
 --R-----------------------------------------------------------------------------
---Routput       library in which to place compiled code     
+--Routput       library in which to place compiled code    user.lib 
 --Rinput        controls libraries from which to load compiled code  
 --Rargs         arguments for compiling AXIOM code         -O -Fasy -Fao -Flsp -laxiom -Mno-AXL_W_WillObsolete -DAxiom -Y $AXIOM/algebra 
 --R
@@ -64,17 +64,21 @@
 --R Description: controls libraries from which to load compiled code
 --R
 --R )set compiler input add library is used to tell AXIOM to add library to
---Rthe front of the path which determines where compiled code is loaded from.
+--Rthe front of the path used to find compile code.
 --R )set compiler input drop library is used to tell AXIOM to remove library 
 --Rfrom this path.
 --E 4
 
 --S 5 of 86
 )set compiler output
+--R 
 --R---------------------------- The output Option ----------------------------
 --R
 --R Description: library in which to place compiled code
 --R
+--R )set compiler output library is used to tell the compiler where to place
+--Rcompiled code generated by the library compiler.  By default it goes
+--Rin a file called user.lib in the current directory.
 --E 5
 
 --S 6 of 86
diff --git a/src/interp/bootfuns.lisp.pamphlet b/src/interp/bootfuns.lisp.pamphlet
index 6b57dfe..e94b453 100644
--- a/src/interp/bootfuns.lisp.pamphlet
+++ b/src/interp/bootfuns.lisp.pamphlet
@@ -81,7 +81,6 @@ which will walk the structure $Y$ looking for this constant.
      (defparameter ,p ,val ,where)
      (export '(,p) "BOOT")))
 
-(def-boot-fun |initializeSetVariables| (arg) "early temp def")
 (def-boot-fun |updateSourceFiles| (x) "temp def")
 #-:CCL
 (def-boot-val |$timerTicksPerSecond| INTERNAL-TIME-UNITS-PER-SECOND
diff --git a/src/interp/daase.lisp.pamphlet b/src/interp/daase.lisp.pamphlet
index ab1cfcb..4ea1fe5 100644
--- a/src/interp/daase.lisp.pamphlet
+++ b/src/interp/daase.lisp.pamphlet
@@ -949,7 +949,7 @@ database.
   ;; Open the library
   (let (lib)
     (if (filep (setq lib (make-pathname :name object :type "lib")) )
-        (setq input-libraries (cons (open-library (truename lib)) input-libraries))))
+        (setq input-libraries (cons (truename lib) input-libraries))))
    (set-file-getter object)  ; sets the autoload property for G-object
    (dolist (domain asy)
      (setq key (first domain))
@@ -1099,7 +1099,7 @@ database.
  #+:CCL
   (let (lib)
     (if (filep (setq lib (make-pathname :name object :type "lib")) )
-        (setq input-libraries (cons (open-library (truename lib)) input-libraries)))
+        (setq input-libraries (cons (truename lib) input-libraries)))
     (|unloadOneConstructor| (get abbrev 'abbreviationfor) abbrev) )
   (|sayKeyedMsg| 'S2IU0001 (list key object))))))
 
diff --git a/src/interp/setvars.boot.pamphlet b/src/interp/setvars.boot.pamphlet
index d75cde4..a69b40d 100644
--- a/src/interp/setvars.boot.pamphlet
+++ b/src/interp/setvars.boot.pamphlet
@@ -41,220 +41,7 @@ its arguments, such as describeSetOutputFortran.
 \section{Top level set functions}
 The {\bf set} function in this file handles the top level {\bf )set}
 command line functions.
-<<toplevelsetfunctions>>=
-<<initializeSetVariables>>
-<<resetWorkspaceVariables>>
-<<displaySetVariableSettings>>
-@
-\section{initializeSetVariables}
-<<initializeSetVariables>>=
-initializeSetVariables (setTree) ==
-  -- this function passes through the table of set variable information
-  -- and initializes the variables to their default definitions.
-  for setData in setTree repeat
-    st := setData.setType
-    st = 'FUNCTION =>
-      -- here setVar is really the name of a function to call
-      if functionp(setData.setVar)
-        then FUNCALL( setData.setVar,"%initialize%")
-        else sayMSG '"   Function not implemented."
-    st = 'INTEGER  =>
-      SET(setData.setVar, setData.setDef)
-    st = 'STRING  =>
-      SET(setData.setVar, setData.setDef)
-    st = 'LITERALS =>
-      SET(setData.setVar, translateYesNo2TrueFalse setData.setDef)
-    st = 'TREE =>
-      initializeSetVariables(setData.setLeaf)
-
-@
-\subsection{resetWorkspaceVariables}
-<<resetWorkspaceVariables>>=
-resetWorkspaceVariables () ==
-  -- this replaces def in DEBUG LISP
-  -- this function resets many workspace variables to their default
-  -- values. Some things are reset by start and not reset by restart.
-  SETQ(_/COUNTLIST                  , NIL)
-  SETQ(_/EDITFILE                   , NIL)
-  SETQ(_/SOURCEFILES                , NIL)
-  SETQ($sourceFiles                 , NIL)
-  SETQ(_/PRETTY                     , NIL)
-  SETQ(_/SPACELIST                  , NIL)
-  SETQ(_/TIMERLIST                  , NIL)
-  SETQ($existingFiles               , MAKE_-HASHTABLE 'UEQUAL)
-  SETQ($functionTable               , NIL)
-  SETQ($BOOT                        , NIL)
-  SETQ($compileMapFlag              , NIL)
-  SETQ($echoLineStack               , NIL)
-  SETQ($operationNameList           , NIL)
-  SETQ($slamFlag                    , NIL)
-  SETQ($CommandSynonymAlist         , COPY($InitialCommandSynonymAlist))
-  SETQ($UserAbbreviationsAlist      , NIL)
-  SETQ($msgAlist                    , NIL)
-  SETQ($msgDatabase                 , NIL)
-  SETQ($msgDatabaseName             , NIL)
-  SETQ($dependeeClosureAlist        , NIL)
-  SETQ($IOindex                     , 1  )
-  SETQ($coerceIntByMapCounter       , 0  )
-  SETQ($e                           , [[NIL]])
-  SETQ($env                         , [[NIL]])
-
-  -- many variables set by the following
-
-  initializeSetVariables($setOptions)
-
-@
-
-\subsection{displaySetVariableSettings}
-<<displaySetVariableSettings>>=
-displaySetVariableSettings(setTree,label) ==
-  if label = "" then label := '")set"
-    else label := STRCONC('" ",object2String label,'" ")
-  centerAndHighlight(STRCONC('"Current Values of ",label,
-    '" Variables"),$LINELENGTH," ")
-  TERPRI()
-  sayBrightly ["Variable     ",
-               "Description                                ",
-                 "Current Value"]
-  SAY fillerSpaces($LINELENGTH,specialChar 'hbar)
-  subtree := nil
-  for setData in setTree repeat
-    null satisfiesUserLevel setData.setLevel => nil
-    setOption := object2String setData.setName
-    setOption := STRCONC(setOption,fillerSpaces(13-#setOption,'" "),
-                         setData.setLabel)
-    setOption := STRCONC(setOption,fillerSpaces(55-#setOption,'" "))
-    st := setData.setType
-    st = 'FUNCTION =>
-      opt :=
-        functionp(setData.setVar) => FUNCALL( setData.setVar,"%display%")
-        '"unimplemented"
-      if PAIRP opt then opt := [:[o,'" "] for o in opt]
-      sayBrightly concat(setOption,'%b,opt,'%d)
-    st = 'STRING   =>
-      opt := object2String eval setData.setVar
-      sayBrightly [setOption,:bright opt]
-    st = 'INTEGER  =>
-      opt := object2String eval setData.setVar
-      sayBrightly [setOption,:bright opt]
-    st = 'LITERALS =>
-      opt := object2String translateTrueFalse2YesNo eval setData.setVar
-      sayBrightly [setOption,:bright opt]
-    st = 'TREE     =>
-      sayBrightly [setOption,:bright '"..."]
-      subtree := true
-      subname := object2String setData.setName
-  TERPRI()
-  subtree =>
-    sayBrightly ['"Variables with current values of",:bright '"...",
-      '"have further sub-options. For example,"]
-    sayBrightly ['"issue",:bright '")set ",subname,
-      '" to see what the options are for",:bright subname,'".",'%l,
-        '"For more information, issue",:bright '")help set",'"."]
-
-@
-\section{compiler}
-See the section compiler in setvart.boot.pamphlet\cite{1}.
-\begin{verbatim}
-                  Current Values of  compiler  Variables                   
-
-Variable     Description                           Current Value
------------------------------------------------------------------
-output       library in which to place compiled code     
-input        controls libraries from which to load compiled code  
-args         arguments for compiling AXIOM code         
-             -O -Fasy -Fao -Flsp -laxiom -Mno-AXL_W_WillObsolete 
-             -DAxiom -Y $AXIOM/algebra 
-
-\end{verbatim}
-<<compilerCode>>=
-<<setAsharpArgs>>
-<<describeAsharpArgs>>
-<<setInputLibrary>>
-<<setOutputLibrary>>
-<<describeOutputLibraryArgs>>
-<<describeInputLibraryArgs>>
-@
-\subsection{setAsharpArgs}
-<<setAsharpArgs>>=
-setAsharpArgs arg ==
-  arg = "%initialize%" =>
-    $asharpCmdlineFlags := '"-O -Fasy -Fao -Flsp -laxiom -Mno-AXL__W__WillObsolete -DAxiom -Y $AXIOM/algebra"
-  arg = "%display%" =>
-    $asharpCmdlineFlags
-  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
-    describeAsharpArgs()
-  $asharpCmdlineFlags := first(arg)
-
-@
-\subsection{describeAsharpArgs}
-<<describeAsharpArgs>>=
-describeAsharpArgs() ==
-  sayBrightly LIST (
-   '%b,'")set compiler args ",'%d,_
-   '"is used to tell AXIOM how to invoke the library compiler ",'%l,_
-   '" when compiling code for AXIOM.",'%l,_
-   '" The args option is followed by a string enclosed in double quotes.",'%l,'%l,_
-   '" The current setting is",'%l,'%b,'"_"",$asharpCmdlineFlags,'"_"",'%d)
 
-@
-\subsection{setInputLibrary}
-<<setInputLibrary>>=
-setInputLibrary arg ==
-  arg = "%initialize%" =>
-   true
-  arg = "%display%" =>
-   [LIBRARY_-NAME(u) for u in INPUT_-LIBRARIES]
-  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
-    describeInputLibraryArgs()
-  arg is [act, filename] and (act := selectOptionLC(act,'(add drop),nil)) =>
-    act = 'add => addInputLibrary TRUENAME STRINGIMAGE filename
-    act = 'drop => dropInputLibrary TRUENAME STRINGIMAGE filename
-  setInputLibrary NIL
-
-@
-\subsection{setOutputLibrary}
-<<setOutputLibrary>>=
-setOutputLibrary arg ==
-  -- Hack to avoid initialising libraries in KCL:
-  not $cclSystem => false
-  arg = "%initialize%" =>
-    $outputLibraryName := nil
-  arg = "%display%" =>
-    $outputLibraryName or '"user.lib" 
-  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
-    describeOutputLibraryArgs()
-  not ONEP(#arg) => setOutputLibrary nil
-  -- If the file already exists then use the complete pathname to help
-  -- keep track of it in the case the user issues )cd commands.
-  if FILEP (fn := STRINGIMAGE first arg) then fn := TRUENAME fn
-  openOutputLibrary($outputLibraryName := fn)
-
-@
-\subsection{describeOutputLibraryArgs}
-<<describeOutputLibraryArgs>>=
-describeOutputLibraryArgs() ==
-  sayBrightly LIST (
-   '%b,'")set compiler output library",'%d,_
-   '"is used to tell the compiler where to place", '%l,_
-   '"compiled code generated by the library compiler.  By default it goes",'%l,_
-   '"in a file called",'%b, '"user.lib", '%d, '"in the current directory." 
-    )
-
-@
-\subsection{describeInputLibraryArgs}
-<<describeInputLibraryArgs>>=
-describeInputLibraryArgs() ==
-  sayBrightly LIST (
-   '%b,'")set compiler input add library",'%d,_
-   '"is used to tell AXIOM to add", '%b, '"library", '%d, '"to",'%l,
-   '"the front of the path which determines where compiled code is loaded from.",_
-   '%l, '%b,'")set compiler input drop library",'%d,_
-   '"is used to tell AXIOM to remove", '%b, '"library", '%d, '%l,_
-   '"from this path."
-    )
-
-@
 \section{expose}
 See the section expose in setvart.boot.pamphlet\cite{1}
 \begin{verbatim}
@@ -1775,8 +1562,6 @@ describeSetStreamsCalculate() == sayKeyedMsg("S2IV0001",[$streamCount])
 @
 <<*>>=
 <<license>>
-<<toplevelsetfunctions>>
-<<compilerCode>>
 <<exposeCode>>
 <<fortrancallingCode>>
 <<functionsCode>>
@@ -1797,362 +1582,6 @@ describeSetStreamsCalculate() == sayKeyedMsg("S2IV0001",[$streamCount])
 
 (IN-PACKAGE "BOOT" )
 
-(DEFUN |initializeSetVariables| (|setTree|) 
- (PROG (|st|) 
-  (RETURN 
-   (SEQ 
-    (DO ((#0=#:G2723 |setTree| (CDR #0#)) (|setData| NIL)) 
-     ((OR (ATOM #0#) (PROGN (SETQ |setData| (CAR #0#)) NIL)) NIL)
-     (SEQ 
-      (EXIT 
-       (PROGN 
-        (SPADLET |st| (ELT |setData| 3))
-        (COND 
-         ((BOOT-EQUAL |st| (QUOTE FUNCTION))
-          (COND 
-           ((|functionp| (ELT |setData| 4))
-             (FUNCALL (ELT |setData| 4) (QUOTE |%initialize%|)))
-           ((QUOTE T) (|sayMSG| (MAKESTRING "   Function not implemented.")))))
-         ((BOOT-EQUAL |st| (QUOTE INTEGER))
-           (SET (ELT |setData| 4) (ELT |setData| 6)))
-         ((BOOT-EQUAL |st| (QUOTE STRING))
-           (SET (ELT |setData| 4) (ELT |setData| 6)))
-         ((BOOT-EQUAL |st| (QUOTE LITERALS))
-           (SET (ELT |setData| 4) 
-            (|translateYesNo2TrueFalse| (ELT |setData| 6))))
-         ((BOOT-EQUAL |st| (QUOTE TREE))
-            (|initializeSetVariables| (ELT |setData| 5)))))))))))) 
-
-
-(DEFUN |resetWorkspaceVariables| NIL 
- (PROGN 
-  (SETQ /COUNTLIST NIL)
-  (SETQ /EDITFILE NIL)
-  (SETQ /SOURCEFILES NIL)
-  (SETQ |$sourceFiles| NIL)
-  (SETQ /PRETTY NIL)
-  (SETQ /SPACELIST NIL)
-  (SETQ /TIMERLIST NIL)
-  (SETQ |$existingFiles| (MAKE-HASHTABLE (QUOTE UEQUAL)))
-  (SETQ |$functionTable| NIL)
-  (SETQ $BOOT NIL)
-  (SETQ |$compileMapFlag| NIL)
-  (SETQ |$echoLineStack| NIL)
-  (SETQ |$operationNameList| NIL)
-  (SETQ |$slamFlag| NIL)
-  (SETQ |$CommandSynonymAlist| (COPY |$InitialCommandSynonymAlist|))
-  (SETQ |$UserAbbreviationsAlist| NIL)
-  (SETQ |$msgAlist| NIL)
-  (SETQ |$msgDatabase| NIL)
-  (SETQ |$msgDatabaseName| NIL)
-  (SETQ |$dependeeClosureAlist| NIL)
-  (SETQ |$IOindex| 1)
-  (SETQ |$coerceIntByMapCounter| 0)
-  (SETQ |$e| (CONS (CONS NIL NIL) NIL))
-  (SETQ |$env| (CONS (CONS NIL NIL) NIL))
-  (|initializeSetVariables| |$setOptions|))) 
-
-(DEFUN |translateYesNo2TrueFalse| (|x|)
- (COND
-  ((|member| |x| (QUOTE (|yes| |on|))) (QUOTE T))
-  ((|member| |x| (QUOTE (|no| |off|))) NIL)
-  ((QUOTE T) |x|))) 
-
-(DEFUN |translateTrueFalse2YesNo| (|x|)
- (COND
-  ((BOOT-EQUAL |x| (QUOTE T)) (QUOTE |on|))
-  ((NULL |x|) (QUOTE |off|))
-  ((QUOTE T) |x|))) 
-
-(DEFUN |set| (|l|) (|set1| |l| |$setOptions|)) 
-
-(DEFUN |set1| (|l| |setTree|)
- (PROG (|$setOptionNames| |arg| |setData| |st| |setfunarg| |num|
-        |upperlimit| |arg2|)
-  (DECLARE (SPECIAL |$setOptionNames|))
-   (RETURN 
-    (SEQ 
-     (COND 
-      ((NULL |l|) (|displaySetVariableSettings| |setTree| (QUOTE ||)))
-      ((QUOTE T) 
-        (SPADLET |$setOptionNames| 
-         (PROG (#0=#:G2762) 
-          (SPADLET #0# NIL)
-          (RETURN
-           (DO
-            ((#1=#:G2767 |setTree| (CDR #1#)) (|x| NIL))
-             ((OR (ATOM #1#) (PROGN (SETQ |x| (CAR #1#)) NIL)) (NREVERSE0 #0#))
-             (SEQ (EXIT (SETQ #0# (CONS (ELT |x| 0) #0#))))))))
-        (SPADLET |arg| 
-         (|selectOption| (DOWNCASE (CAR |l|)) 
-            |$setOptionNames| (QUOTE |optionError|)))
-        (SPADLET |setData| (CONS |arg| (LASSOC |arg| |setTree|)))
-        (COND
-         ((NULL (|satisfiesUserLevel| (ELT |setData| 2)))
-           (|sayKeyedMsg| (QUOTE S2IZ0007) 
-            (CONS |$UserLevel| (CONS (MAKESTRING "set option") NIL))))
-         ((EQL 1 (|#| |l|)) (|displaySetOptionInformation| |arg| |setData|))
-         ((QUOTE T)
-           (SPADLET |st| (ELT |setData| 3))
-           (COND
-            ((BOOT-EQUAL |st| (QUOTE FUNCTION))
-              (SPADLET |setfunarg| 
-               (COND 
-                ((BOOT-EQUAL (ELT |l| 1) (QUOTE DEFAULT))
-                   (QUOTE |%initialize%|))
-                ((QUOTE T) (KDR |l|))))
-              (COND
-               ((|functionp| (ELT |setData| 4))
-                 (FUNCALL (ELT |setData| 4) |setfunarg|))
-               ((QUOTE T)
-                 (|sayMSG| (MAKESTRING "   Function not implemented."))))
-              (COND 
-               (|$displaySetValue| 
-                (|displaySetOptionInformation| |arg| |setData|)))
-              NIL)
-            ((BOOT-EQUAL |st| (QUOTE STRING))
-              (SPADLET |arg2| (ELT |l| 1))
-              (COND 
-               ((BOOT-EQUAL |arg2| (QUOTE DEFAULT))
-                 (SET (ELT |setData| 4) (ELT |setData| 6)))
-               (|arg2| (SET (ELT |setData| 4) |arg2|)) ((QUOTE T) NIL))
-              (COND 
-               ((OR |$displaySetValue| (NULL |arg2|))
-                 (|displaySetOptionInformation| |arg| |setData|)))
-               NIL)
-            ((BOOT-EQUAL |st| (QUOTE INTEGER))
-              (SPADLET |arg2| 
-               (PROGN 
-                (SPADLET |num| (ELT |l| 1))
-                (COND 
-                 ((AND 
-                   (FIXP |num|)
-                   (>= |num| (ELT (ELT |setData| 5) 0))
-                   (OR 
-                    (NULL (SPADLET |upperlimit| (ELT (ELT |setData| 5) 1)))
-                    (<= |num| |upperlimit|)))
-                     |num|)
-                 ((QUOTE T) 
-                   (|selectOption| (ELT |l| 1) 
-                    (CONS (QUOTE |default|) (ELT |setData| 5)) NIL)))))
-              (COND 
-               ((BOOT-EQUAL |arg2| (QUOTE DEFAULT))
-                 (SET (ELT |setData| 4) (ELT |setData| 6)))
-               (|arg2| (SET (ELT |setData| 4) |arg2|))
-               ((QUOTE T) NIL))
-              (COND
-               ((OR |$displaySetValue| (NULL |arg2|))
-                 (|displaySetOptionInformation| |arg| |setData|)))
-              (COND 
-               ((NULL |arg2|)
-                 (|sayMessage| 
-                  (CONS 
-                   (MAKESTRING " Your value") 
-                   (APPEND 
-                    (|bright| (|object2String| (ELT |l| 1)))
-                    (CONS 
-                     (MAKESTRING "is not among the valid choices.")
-                     NIL)))))
-               ((QUOTE T) NIL)))
-            ((BOOT-EQUAL |st| (QUOTE LITERALS))
-              (COND
-               ((SPADLET |arg2| 
-                 (|selectOption| (ELT |l| 1) 
-                   (CONS (QUOTE |default|) (ELT |setData| 5)) NIL))
-                 (COND 
-                  ((BOOT-EQUAL |arg2| (QUOTE DEFAULT))
-                    (SET (ELT |setData| 4) 
-                     (|translateYesNo2TrueFalse| (ELT |setData| 6))))
-                  ((QUOTE T) 
-                    (COND 
-                     ((BOOT-EQUAL |arg2| (QUOTE |nobreak|))
-                       (USE-FAST-LINKS (QUOTE T))))
-                    (COND 
-                     ((BOOT-EQUAL |arg2| (QUOTE |fastlinks|))
-                       (USE-FAST-LINKS (QUOTE NIL))
-                       (SPADLET |arg2| (QUOTE |break|))))
-                    (SET (ELT |setData| 4) 
-                      (|translateYesNo2TrueFalse| |arg2|))))))
-              (COND 
-               ((OR |$displaySetValue| (NULL |arg2|))
-                 (|displaySetOptionInformation| |arg| |setData|)))
-              (COND 
-               ((NULL |arg2|) 
-                 (|sayMessage| 
-                  (CONS 
-                   (MAKESTRING " Your value")
-                   (APPEND 
-                    (|bright| (|object2String| (ELT |l| 1)))
-                    (CONS 
-                     (MAKESTRING "is not among the valid choices.") 
-                     NIL)))))
-               ((QUOTE T) NIL)))
-            ((BOOT-EQUAL |st| (QUOTE TREE))
-              (|set1| (KDR |l|) (ELT |setData| 5))
-              NIL)
-            ((QUOTE T)
-              (|sayMessage|
-               (CONS 
-                (MAKESTRING "Cannot handle set tree node type")
-                (APPEND 
-                 (|bright| |st|)
-                 (CONS (QUOTE |yet|) NIL))))
-               NIL)))))))))) 
-
-;displaySetOptionInformation(arg,setData) ==
-;  st := setData.setType
-;  -- if the option is a sub-tree, show the full menu
-;  st = 'TREE =>
-;    displaySetVariableSettings(setData.setLeaf,setData.setName)
-;  -- otherwise we want to show the current setting
-;  centerAndHighlight (STRCONC('"The ",object2String arg,'" Option"),
-;                      $LINELENGTH,specialChar 'hbar)
-;  sayBrightly ['%l,:bright '"Description:",setData.setLabel]
-;  st = 'FUNCTION =>
-;    TERPRI()
-;    if functionp(setData.setVar)
-;      then FUNCALL(setData.setVar,"%describe%")
-;      else sayMSG '"   Function not implemented."
-;  st = 'INTEGER  =>
-;    sayMessage ['" The",:bright arg,'"option",
-;      '" may be followed by an integer in the range",
-;       :bright (setData.setLeaf).0,'"to",'%l,
-;        :bright (setData.setLeaf).1,'"inclusive.",
-;         '" The current setting is",:bright eval setData.setVar]
-;  st = 'STRING  =>
-;    sayMessage ['" The",:bright arg,'"option",
-;      '" is followed by a string enclosed in double quote marks.", '%l,
-;         '" The current setting is",:bright ["_"",eval setData.setVar, "_""]]
-;  st = 'LITERALS =>
-;    sayMessage ['" The",:bright arg,'"option",
-;      '" may be followed by any one of the following:"]
-;    current := translateTrueFalse2YesNo eval setData.setVar
-;    for name in setData.setLeaf repeat
-;      if name = current
-;        then sayBrightly ['" ->",:bright object2String name]
-;        else sayBrightly ['"    ",object2String name]
-;    sayMessage '" The current setting is indicated within the list."
-;    if (setData.setLeaf = '(yes no on off)) or
-;      (setData.setLeaf = '(yes no on off long)) then
-;       sayMessage [:bright '"yes",'"and",:bright '"no",
-;        '"have the same effect as",:bright '"on",'"and",:bright '"off",
-;          '"respectively."]
-
-(DEFUN |displaySetOptionInformation| (|arg| |setData|) (PROG (|st| |current|) (RETURN (SEQ (PROGN (SPADLET |st| (ELT |setData| 3)) (COND ((BOOT-EQUAL |st| (QUOTE TREE)) (|displaySetVariableSettings| (ELT |setData| 5) (ELT |setData| 0))) ((QUOTE T) (|centerAndHighlight| (STRCONC (MAKESTRING "The ") (|object2String| |arg|) (MAKESTRING " Option")) $LINELENGTH (|specialChar| (QUOTE |hbar|))) (|sayBrightly| (CONS (QUOTE |%l|) (APPEND (|bright| (MAKESTRING "Description:")) (CONS (ELT |setData| 1) NIL)))) (COND ((BOOT-EQUAL |st| (QUOTE FUNCTION)) (TERPRI) (COND ((|functionp| (ELT |setData| 4)) (FUNCALL (ELT |setData| 4) (QUOTE |%describe%|))) ((QUOTE T) (|sayMSG| (MAKESTRING "   Function not implemented."))))) ((BOOT-EQUAL |st| (QUOTE INTEGER)) (|sayMessage| (CONS (MAKESTRING " The") (APPEND (|bright| |arg|) (CONS (MAKESTRING "option") (CONS (MAKESTRING " may be followed by an integer in the range") (APPEND (|bright| (ELT (ELT |setData| 5) 0)) (CONS (MAKESTRING "to") (CONS (QUOTE !
|%l|) (APPEND (|bright| (ELT (ELT |setData| 5) 1)) (CONS (MAKESTRING "inclusive.") (CONS (MAKESTRING " The current setting is") (|bright| (|eval| (ELT |setData| 4))))))))))))))) ((BOOT-EQUAL |st| (QUOTE STRING)) (|sayMessage| (CONS (MAKESTRING " The") (APPEND (|bright| |arg|) (CONS (MAKESTRING "option") (CONS (MAKESTRING " is followed by a string enclosed in double quote marks.") (CONS (QUOTE |%l|) (CONS (MAKESTRING " The current setting is") (|bright| (CONS (QUOTE |"|) (CONS (|eval| (ELT |setData| 4)) (CONS (QUOTE |"|) NIL)))))))))))) ((BOOT-EQUAL |st| (QUOTE LITERALS)) (PROGN (|sayMessage| (CONS (MAKESTRING " The") (APPEND (|bright| |arg|) (CONS (MAKESTRING "option") (CONS (MAKESTRING " may be followed by any one of the following:") NIL))))) (SPADLET |current| (|translateTrueFalse2YesNo| (|eval| (ELT |setData| 4)))) (DO ((#0=#:G2796 (ELT |setData| 5) (CDR #0#)) (|name| NIL)) ((OR (ATOM #0#) (PROGN (SETQ |name| (CAR #0#)) NIL)) NIL) (SEQ (EXIT (COND ((BOOT-EQUAL |name| |cur!
rent|) (|sayBrightly| (CONS (MAKESTRING " ->") (|bright| (|ob!
ject2String| |name|))))) ((QUOTE T) (|sayBrightly| (CONS (MAKESTRING "    ") (CONS (|object2String| |name|) NIL)))))))) (|sayMessage| (MAKESTRING " The current setting is indicated within the list.")) (COND ((OR (BOOT-EQUAL (ELT |setData| 5) (QUOTE (|yes| |no| |on| |off|))) (BOOT-EQUAL (ELT |setData| 5) (QUOTE (|yes| |no| |on| |off| |long|)))) (|sayMessage| (APPEND (|bright| (MAKESTRING "yes")) (CONS (MAKESTRING "and") (APPEND (|bright| (MAKESTRING "no")) (CONS (MAKESTRING "have the same effect as") (APPEND (|bright| (MAKESTRING "on")) (CONS (MAKESTRING "and") (APPEND (|bright| (MAKESTRING "off")) (CONS (MAKESTRING "respectively.") NIL)))))))))) ((QUOTE T) NIL)))))))))))) 
-;displaySetVariableSettings(setTree,label) ==
-;  if label = "" then label := '")set"
-;    else label := STRCONC('" ",object2String label,'" ")
-;  centerAndHighlight(STRCONC('"Current Values of ",label,
-;    '" Variables"),$LINELENGTH," ")
-;  TERPRI()
-;  sayBrightly ["Variable     ",
-;               "Description                                ",
-;                 "Current Value"]
-;  SAY fillerSpaces($LINELENGTH,specialChar 'hbar)
-;  subtree := nil
-;  for setData in setTree repeat
-;    null satisfiesUserLevel setData.setLevel => nil
-;    setOption := object2String setData.setName
-;    setOption := STRCONC(setOption,fillerSpaces(13-#setOption,'" "),
-;                         setData.setLabel)
-;    setOption := STRCONC(setOption,fillerSpaces(55-#setOption,'" "))
-;    st := setData.setType
-;    st = 'FUNCTION =>
-;      opt :=
-;        functionp(setData.setVar) => FUNCALL( setData.setVar,"%display%")
-;        '"unimplemented"
-;      if PAIRP opt then opt := [:[o,'" "] for o in opt]
-;      sayBrightly concat(setOption,'%b,opt,'%d)
-;    st = 'STRING   =>
-;      opt := object2String eval setData.setVar
-;      sayBrightly [setOption,:bright opt]
-;    st = 'INTEGER  =>
-;      opt := object2String eval setData.setVar
-;      sayBrightly [setOption,:bright opt]
-;    st = 'LITERALS =>
-;      opt := object2String translateTrueFalse2YesNo eval setData.setVar
-;      sayBrightly [setOption,:bright opt]
-;    st = 'TREE     =>
-;      sayBrightly [setOption,:bright '"..."]
-;      subtree := true
-;      subname := object2String setData.setName
-;  TERPRI()
-;  subtree =>
-;    sayBrightly ['"Variables with current values of",:bright '"...",
-;      '"have further sub-options. For example,"]
-;    sayBrightly ['"issue",:bright '")set ",subname,
-;      '" to see what the options are for",:bright subname,'".",'%l,
-;        '"For more information, issue",:bright '")help set",'"."]
-
-(DEFUN |displaySetVariableSettings| (|setTree| |label|) (PROG (|setOption| |st| |opt| |subtree| |subname|) (RETURN (SEQ (PROGN (COND ((BOOT-EQUAL |label| (QUOTE ||)) (SPADLET |label| (MAKESTRING ")set"))) ((QUOTE T) (SPADLET |label| (STRCONC (MAKESTRING " ") (|object2String| |label|) (MAKESTRING " "))))) (|centerAndHighlight| (STRCONC (MAKESTRING "Current Values of ") |label| (MAKESTRING " Variables")) $LINELENGTH (QUOTE | |)) (TERPRI) (|sayBrightly| (CONS (MAKESTRING "Variable     ") (CONS (MAKESTRING "Description                                ") (CONS (MAKESTRING "Current Value") NIL)))) (SAY (|fillerSpaces| $LINELENGTH (|specialChar| (QUOTE |hbar|)))) (SPADLET |subtree| NIL) (DO ((#0=#:G2822 |setTree| (CDR #0#)) (|setData| NIL)) ((OR (ATOM #0#) (PROGN (SETQ |setData| (CAR #0#)) NIL)) NIL) (SEQ (EXIT (COND ((NULL (|satisfiesUserLevel| (ELT |setData| 2))) NIL) ((QUOTE T) (SPADLET |setOption| (|object2String| (ELT |setData| 0))) (SPADLET |setOption| (STRCONC |setOption| (|!
fillerSpaces| (SPADDIFFERENCE 13 (|#| |setOption|)) (MAKESTRING " ")) (ELT |setData| 1))) (SPADLET |setOption| (STRCONC |setOption| (|fillerSpaces| (SPADDIFFERENCE 55 (|#| |setOption|)) (MAKESTRING " ")))) (SPADLET |st| (ELT |setData| 3)) (COND ((BOOT-EQUAL |st| (QUOTE FUNCTION)) (SPADLET |opt| (COND ((|functionp| (ELT |setData| 4)) (FUNCALL (ELT |setData| 4) (QUOTE |%display%|))) ((QUOTE T) (MAKESTRING "unimplemented")))) (COND ((PAIRP |opt|) (SPADLET |opt| (PROG (#1=#:G2828) (SPADLET #1# NIL) (RETURN (DO ((#2=#:G2833 |opt| (CDR #2#)) (|o| NIL)) ((OR (ATOM #2#) (PROGN (SETQ |o| (CAR #2#)) NIL)) #1#) (SEQ (EXIT (SETQ #1# (APPEND #1# (CONS |o| (CONS (MAKESTRING " ") NIL)))))))))))) (|sayBrightly| (|concat| |setOption| (QUOTE |%b|) |opt| (QUOTE |%d|)))) ((BOOT-EQUAL |st| (QUOTE STRING)) (SPADLET |opt| (|object2String| (|eval| (ELT |setData| 4)))) (|sayBrightly| (CONS |setOption| (|bright| |opt|)))) ((BOOT-EQUAL |st| (QUOTE INTEGER)) (SPADLET |opt| (|object2String| (|eval| (ELT!
 |setData| 4)))) (|sayBrightly| (CONS |setOption| (|bright| |!
opt|)))) ((BOOT-EQUAL |st| (QUOTE LITERALS)) (SPADLET |opt| (|object2String| (|translateTrueFalse2YesNo| (|eval| (ELT |setData| 4))))) (|sayBrightly| (CONS |setOption| (|bright| |opt|)))) ((BOOT-EQUAL |st| (QUOTE TREE)) (PROGN (|sayBrightly| (CONS |setOption| (|bright| (MAKESTRING "...")))) (SPADLET |subtree| (QUOTE T)) (SPADLET |subname| (|object2String| (ELT |setData| 0))))))))))) (TERPRI) (COND (|subtree| (PROGN (|sayBrightly| (CONS (MAKESTRING "Variables with current values of") (APPEND (|bright| (MAKESTRING "...")) (CONS (MAKESTRING "have further sub-options. For example,") NIL)))) (|sayBrightly| (CONS (MAKESTRING "issue") (APPEND (|bright| (MAKESTRING ")set ")) (CONS |subname| (CONS (MAKESTRING " to see what the options are for") (APPEND (|bright| |subname|) (CONS (MAKESTRING ".") (CONS (QUOTE |%l|) (CONS (MAKESTRING "For more information, issue") (APPEND (|bright| (MAKESTRING ")help set")) (CONS (MAKESTRING ".") NIL))))))))))))))))))) 
-;setAsharpArgs arg ==
-;  arg = "%initialize%" =>
-;    $asharpCmdlineFlags := '"-O -Fasy -Fao -Flsp -laxiom -Mno-AXL__W__WillObsolete -DAxiom -Y $AXIOM/algebra"
-;  arg = "%display%" =>
-;    $asharpCmdlineFlags
-;  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
-;    describeAsharpArgs()
-;  $asharpCmdlineFlags := first(arg)
-
-(DEFUN |setAsharpArgs| (|arg|) (COND ((BOOT-EQUAL |arg| (QUOTE |%initialize%|)) (SPADLET |$asharpCmdlineFlags| (MAKESTRING "-O -Fasy -Fao -Flsp -laxiom -Mno-AXL_W_WillObsolete -DAxiom -Y $AXIOM/algebra"))) ((BOOT-EQUAL |arg| (QUOTE |%display%|)) |$asharpCmdlineFlags|) ((OR (NULL |arg|) (BOOT-EQUAL |arg| (QUOTE |%describe%|)) (BOOT-EQUAL (CAR |arg|) (QUOTE ?))) (|describeAsharpArgs|)) ((QUOTE T) (SPADLET |$asharpCmdlineFlags| (CAR |arg|))))) 
-;describeAsharpArgs() ==
-;  sayBrightly LIST (
-;   '%b,'")set compiler args ",'%d,_
-;   '"is used to tell AXIOM how to invoke the library compiler ",'%l,_
-;   '" when compiling code for AXIOM.",'%l,_
-;   '" The args option is followed by a string enclosed in double quotes.",'%l,'%l,_
-;   '" The current setting is",'%l,'%b,'"_"",$asharpCmdlineFlags,'"_"",'%d)
-
-(DEFUN |describeAsharpArgs| NIL (|sayBrightly| (LIST (QUOTE |%b|) (MAKESTRING ")set compiler args ") (QUOTE |%d|) (MAKESTRING "is used to tell AXIOM how to invoke the library compiler ") (QUOTE |%l|) (MAKESTRING " when compiling code for AXIOM.") (QUOTE |%l|) (MAKESTRING " The args option is followed by a string enclosed in double quotes.") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING " The current setting is") (QUOTE |%l|) (QUOTE |%b|) (MAKESTRING "\"") |$asharpCmdlineFlags| (MAKESTRING "\"") (QUOTE |%d|)))) 
-;setInputLibrary arg ==
-;  arg = "%initialize%" =>
-;   true
-;  arg = "%display%" =>
-;   [LIBRARY_-NAME(u) for u in INPUT_-LIBRARIES]
-;  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
-;    describeInputLibraryArgs()
-;  arg is [act, filename] and (act := selectOptionLC(act,'(add drop),nil)) =>
-;    act = 'add => addInputLibrary TRUENAME STRINGIMAGE filename
-;    act = 'drop => dropInputLibrary TRUENAME STRINGIMAGE filename
-;  setInputLibrary NIL
-
-(DEFUN |setInputLibrary| (|arg|) (PROG (|ISTMP#1| |filename| |act|) (RETURN (SEQ (COND ((BOOT-EQUAL |arg| (QUOTE |%initialize%|)) (QUOTE T)) ((BOOT-EQUAL |arg| (QUOTE |%display%|)) (PROG (#0=#:G2881) (SPADLET #0# NIL) (RETURN (DO ((#1=#:G2886 INPUT-LIBRARIES (CDR #1#)) (|u| NIL)) ((OR (ATOM #1#) (PROGN (SETQ |u| (CAR #1#)) NIL)) (NREVERSE0 #0#)) (SEQ (EXIT (SETQ #0# (CONS (LIBRARY-NAME |u|) #0#)))))))) ((OR (NULL |arg|) (BOOT-EQUAL |arg| (QUOTE |%describe%|)) (BOOT-EQUAL (CAR |arg|) (QUOTE ?))) (|describeInputLibraryArgs|)) ((AND (PAIRP |arg|) (PROGN (SPADLET |act| (QCAR |arg|)) (SPADLET |ISTMP#1| (QCDR |arg|)) (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL) (PROGN (SPADLET |filename| (QCAR |ISTMP#1|)) (QUOTE T)))) (SPADLET |act| (|selectOptionLC| |act| (QUOTE (|add| |drop|)) NIL))) (COND ((BOOT-EQUAL |act| (QUOTE |add|)) (|addInputLibrary| (TRUENAME (STRINGIMAGE |filename|)))) ((BOOT-EQUAL |act| (QUOTE |drop|)) (|dropInputLibrary| (TRUENAME (STRINGIMAGE |filename|)))))) (!
(QUOTE T) (|setInputLibrary| NIL))))))) 
-;setOutputLibrary arg ==
-;  -- Hack to avoid initialising libraries in KCL:
-;  not $cclSystem => false
-;  arg = "%initialize%" =>
-;    $outputLibraryName := nil
-;  arg = "%display%" =>
-;    $outputLibraryName or '"user.lib"
-;  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
-;    describeOutputLibraryArgs()
-;  not ONEP(#arg) => setOutputLibrary nil
-;  -- If the file already exists then use the complete pathname to help
-;  -- keep track of it in the case the user issues )cd commands.
-;  if FILEP (fn := STRINGIMAGE first arg) then fn := TRUENAME fn
-;  openOutputLibrary($outputLibraryName := fn)
-
-(DEFUN |setOutputLibrary| (|arg|) (PROG (|fn|) (RETURN (COND ((NULL |$cclSystem|) NIL) ((BOOT-EQUAL |arg| (QUOTE |%initialize%|)) (SPADLET |$outputLibraryName| NIL)) ((BOOT-EQUAL |arg| (QUOTE |%display%|)) (OR |$outputLibraryName| (MAKESTRING "user.lib"))) ((OR (NULL |arg|) (BOOT-EQUAL |arg| (QUOTE |%describe%|)) (BOOT-EQUAL (CAR |arg|) (QUOTE ?))) (|describeOutputLibraryArgs|)) ((NULL (ONEP (|#| |arg|))) (|setOutputLibrary| NIL)) ((QUOTE T) (COND ((FILEP (SPADLET |fn| (STRINGIMAGE (CAR |arg|)))) (SPADLET |fn| (TRUENAME |fn|)))) (|openOutputLibrary| (SPADLET |$outputLibraryName| |fn|))))))) 
-;describeOutputLibraryArgs() ==
-;  sayBrightly LIST (
-;   '%b,'")set compiler output library",'%d,_
-;   '"is used to tell the compiler where to place", '%l,_
-;   '"compiled code generated by the library compiler.  By default it goes",'%l,_
-;   '"in a file called",'%b, '"user.lib", '%d, '"in the current directory."
-;    )
-
-(DEFUN |describeOutputLibraryArgs| NIL (|sayBrightly| (LIST (QUOTE |%b|) (MAKESTRING ")set compiler output library") (QUOTE |%d|) (MAKESTRING "is used to tell the compiler where to place") (QUOTE |%l|) (MAKESTRING "compiled code generated by the library compiler.  By default it goes") (QUOTE |%l|) (MAKESTRING "in a file called") (QUOTE |%b|) (MAKESTRING "user.lib") (QUOTE |%d|) (MAKESTRING "in the current directory.")))) 
-;describeInputLibraryArgs() ==
-;  sayBrightly LIST (
-;   '%b,'")set compiler input add library",'%d,_
-;   '"is used to tell AXIOM to add", '%b, '"library", '%d, '"to",'%l,
-;   '"the front of the path which determines where compiled code is loaded from.",_
-;   '%l, '%b,'")set compiler input drop library",'%d,_
-;   '"is used to tell AXIOM to remove", '%b, '"library", '%d, '%l,_
-;   '"from this path."
-;    )
-
-(DEFUN |describeInputLibraryArgs| NIL (|sayBrightly| (LIST (QUOTE |%b|) (MAKESTRING ")set compiler input add library") (QUOTE |%d|) (MAKESTRING "is used to tell AXIOM to add") (QUOTE |%b|) (MAKESTRING "library") (QUOTE |%d|) (MAKESTRING "to") (QUOTE |%l|) (MAKESTRING "the front of the path which determines where compiled code is loaded from.") (QUOTE |%l|) (QUOTE |%b|) (MAKESTRING ")set compiler input drop library") (QUOTE |%d|) (MAKESTRING "is used to tell AXIOM to remove") (QUOTE |%b|) (MAKESTRING "library") (QUOTE |%d|) (QUOTE |%l|) (MAKESTRING "from this path.")))) 
 ;setExpose arg ==
 ;  arg = "%initialize%" => loadExposureGroupData()
 ;  arg = "%display%" => '"..."



From MAILER-DAEMON Tue Mar 17 03:50:04 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LjU3m-0007X8-Qr
	for mharc-axiom-developer@gnu.org; Tue, 17 Mar 2009 03:50:03 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LjU3k-0007Wm-JJ
	for axiom-developer@nongnu.org; Tue, 17 Mar 2009 03:50:00 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LjU3g-0007Wa-30
	for axiom-developer@nongnu.org; Tue, 17 Mar 2009 03:50:00 -0400
Received: from [199.232.76.173] (port=58868 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LjU3f-0007WX-S3
	for axiom-developer@nongnu.org; Tue, 17 Mar 2009 03:49:55 -0400
Received: from mx-7.zoominternet.net ([24.154.1.26]:40227
	helo=cm-1.zoominternet.net)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LjU3f-00054h-GU
	for axiom-developer@nongnu.org; Tue, 17 Mar 2009 03:49:55 -0400
X-SpamGroup: 2000
X-CM-Cat: Undefined:Undefined
X-CNFS-Analysis: v=1.0 c=1 a=E8rTNAPPKTgA:10 a=9x1qJYSYWOoMgoVr+WVG7Q==:17
	a=fdFGLi-6AAAA:8 a=W9YMB6JZAAAA:8 a=79fIqliO9H69FWvl-skA:9
	a=ujqfGIaLQScOW4NSZen1fFohjlAA:4 a=MxZ3bB5I4kYA:10
X-CM-Score: 0
X-Scanned-by: Cloudmark Authority Engine
Received: from [24.154.1.45] ([24.154.1.45:54874] helo=pop-2.zoominternet.net)
	by mx-7.zoominternet.net (envelope-from <daly@axiom-developer.org>)
	(ecelerity 2.2.2.30 r(24168)) with ESMTP
	id B3/FD-10174-6615FB94; Tue, 17 Mar 2009 03:29:42 -0400
Received: (qmail 22353 invoked from network); 17 Mar 2009 07:29:45 -0000
Received: from unknown (HELO localhost.localdomain) ([72.23.19.139])
	(envelope-sender <daly@axiom-developer.org>)
	by pop-2.zoominternet.net (qmail-ldap-1.03) with SMTP
	for <daly@axiom-developer.org>; 17 Mar 2009 07:29:45 -0000
Received: (from root@localhost)
	by localhost.localdomain (8.11.6/8.11.6) id n2H7ab529789;
	Tue, 17 Mar 2009 02:36:37 -0500
Date: Tue, 17 Mar 2009 02:36:37 -0500
Message-Id: <200903170736.n2H7ab529789@localhost.localdomain>
From: root <daly@axiom-developer.org>
To: Peter.Horn@localhost.localdomain (horn@mathematik.uni-kassel.de),
	Dan.Roozemond@localhost.localdomain (d.a.roozemond@tue.nl), Om@openmath.org
X-detected-operating-system: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: axiom-developer@nongnu.org
Subject: [Axiom-developer] OpenMath and Axiom
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
Reply-To: daly@axiom-developer.org
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Tue, 17 Mar 2009 07:50:01 -0000

> You may have heard about the SCIEnce project (Symbolic Computation
> Infrastructure for Europe, http://www.symbolic-computation.org/ ).
> Recent activities in that project include the development and
> implementation of a protocol called ``Symbolic Computation Software
> Composability Protocol'', abbreviated SCSCP. The protocol aims to
> provide unified communication between different CASes or different
> instances of one CAS, on one or more computers, clusters, and even
> grids. The protocol is XML-based; in particular, the protocol messages
> are in the OpenMath language. At the moment of writing the protocol has
> reached version 1.3 and both client and server implementations exist in
> GAP, KANT, Maple, and MuPAD.
> 
> Peter Horn and myself have made a Java-library for OpenMath and SCSCP.
> We have now officially released the first version, non-surprisingly
> numbered 1.0.0. It is available for download from:
> 
> http://java.symcomp.org/
> 
> where you can also find (some) documentation and a screencast: A
> movie-version of a presentation we recently gave on this subject.
> 
> The OpenMath library (org.symcomp.openmath) supports OpenMath 2 XML,
> OpenMath 2 Binary, Popcorn, en LaTeX export. It is easily extensible and
> is packed with convenience-methods for assembling and analyzing
> object-trees.
> 
> The SCSCP library (org.symcomp.scscp) makes it easy to create both
> client and server applications, and contains helpful examples. Moreover,
> it is fully SCSCP 1.3-compliant.
> 
> Spread the word!

How is this related to the previous OpenMath work?
Axiom has OpenMath code. Can I expect that to work?

Tim Daly
Axiom Lead Developer




From MAILER-DAEMON Tue Mar 17 09:04:50 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LjYyQ-00068b-8f
	for mharc-axiom-developer@gnu.org; Tue, 17 Mar 2009 09:04:50 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LjYyN-00065U-Et
	for axiom-developer@nongnu.org; Tue, 17 Mar 2009 09:04:47 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LjYyI-00062k-GE
	for axiom-developer@nongnu.org; Tue, 17 Mar 2009 09:04:46 -0400
Received: from [199.232.76.173] (port=45419 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LjYyI-00062h-Aj
	for axiom-developer@nongnu.org; Tue, 17 Mar 2009 09:04:42 -0400
Received: from mx-8.zoominternet.net ([24.154.1.27]:56014
	helo=cm-2.zoominternet.net)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LjYyH-0000HA-Q3
	for axiom-developer@nongnu.org; Tue, 17 Mar 2009 09:04:41 -0400
X-SpamGroup: 2000
X-CM-Cat: Undefined:Undefined
X-CNFS-Analysis: v=1.0 c=1 a=E8rTNAPPKTgA:10 a=9x1qJYSYWOoMgoVr+WVG7Q==:17
	a=fdFGLi-6AAAA:8 a=W9YMB6JZAAAA:8 a=79fIqliO9H69FWvl-skA:9
	a=mrmz5Dj_VruVBWgN0esVX85YYyEA:4 a=MxZ3bB5I4kYA:10
X-CM-Score: 0
X-Scanned-by: Cloudmark Authority Engine
Received: from [24.154.1.47] ([24.154.1.47:45159] helo=pop-4.zoominternet.net)
	by mx-8.zoominternet.net (envelope-from <daly@axiom-developer.org>)
	(ecelerity 2.2.2.30 r(24168)) with ESMTP
	id 59/9D-04759-BDF9FB94; Tue, 17 Mar 2009 09:04:27 -0400
Received: (qmail 19148 invoked from network); 17 Mar 2009 13:04:30 -0000
Received: from unknown (HELO localhost.localdomain) ([72.23.19.139])
	(envelope-sender <daly@axiom-developer.org>)
	by pop-4.zoominternet.net (qmail-ldap-1.03) with SMTP
	for <daly@axiom-developer.org>; 17 Mar 2009 13:04:30 -0000
Received: (from root@localhost)
	by localhost.localdomain (8.11.6/8.11.6) id n2HDq6O30249;
	Tue, 17 Mar 2009 08:52:06 -0500
Date: Tue, 17 Mar 2009 08:52:06 -0500
Message-Id: <200903171352.n2HDq6O30249@localhost.localdomain>
From: root <daly@axiom-developer.org>
To: Peter Horn <horn@mathematik.uni-kassel.de>,
	Dan Roozemond <d.a.roozemond@tue.nl>, Om@openmath.org
X-detected-operating-system: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: axiom-developer@nongnu.org
Subject: [Axiom-developer] OpenMath and Axiom (resend)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
Reply-To: daly@axiom-developer.org
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Tue, 17 Mar 2009 13:04:47 -0000

> You may have heard about the SCIEnce project (Symbolic Computation
> Infrastructure for Europe, http://www.symbolic-computation.org/ ).
> Recent activities in that project include the development and
> implementation of a protocol called ``Symbolic Computation Software
> Composability Protocol'', abbreviated SCSCP. The protocol aims to
> provide unified communication between different CASes or different
> instances of one CAS, on one or more computers, clusters, and even
> grids. The protocol is XML-based; in particular, the protocol messages
> are in the OpenMath language. At the moment of writing the protocol has
> reached version 1.3 and both client and server implementations exist in
> GAP, KANT, Maple, and MuPAD.
> 
> Peter Horn and myself have made a Java-library for OpenMath and SCSCP.
> We have now officially released the first version, non-surprisingly
> numbered 1.0.0. It is available for download from:
> 
> http://java.symcomp.org/
> 
> where you can also find (some) documentation and a screencast: A
> movie-version of a presentation we recently gave on this subject.
> 
> The OpenMath library (org.symcomp.openmath) supports OpenMath 2 XML,
> OpenMath 2 Binary, Popcorn, en LaTeX export. It is easily extensible and
> is packed with convenience-methods for assembling and analyzing
> object-trees.
> 
> The SCSCP library (org.symcomp.scscp) makes it easy to create both
> client and server applications, and contains helpful examples. Moreover,
> it is fully SCSCP 1.3-compliant.
> 
> Spread the word!

How is this related to the previous OpenMath work?
Axiom has OpenMath code. Can I expect that to work?

Tim Daly
Axiom Lead Developer




From MAILER-DAEMON Tue Mar 17 14:59:30 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LjeVe-00072h-Aw
	for mharc-axiom-developer@gnu.org; Tue, 17 Mar 2009 14:59:30 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LjeVc-00071x-0O
	for axiom-developer@nongnu.org; Tue, 17 Mar 2009 14:59:28 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LjeVX-00070m-4J
	for axiom-developer@nongnu.org; Tue, 17 Mar 2009 14:59:27 -0400
Received: from [199.232.76.173] (port=57581 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LjeVW-00070f-Qq
	for axiom-developer@nongnu.org; Tue, 17 Mar 2009 14:59:22 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:47396
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LjeVW-0006rv-Dx
	for axiom-developer@nongnu.org; Tue, 17 Mar 2009 14:59:22 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n2HIxKug002777;
	Tue, 17 Mar 2009 12:59:20 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n2HIxKdB002767;
	Tue, 17 Mar 2009 12:59:20 -0600
Date: Tue, 17 Mar 2009 12:59:20 -0600
Message-Id: <200903171859.n2HIxKdB002767@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090316.01.tpd.patch (bookvol5 add )expose,
	)set break resume)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Tue, 17 Mar 2009 18:59:28 -0000

The )expose code roots were moved to bookvol5.

In addition, certain tests were exiting early and thus not giving any
indication of failing. This is fixed with the )set break resume added.

The patch is too large to post. See
http://axiom-developer.org/axiom-website/patches.html#latest

Tim



From MAILER-DAEMON Tue Mar 17 21:44:51 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Ljkpv-0002dp-OY
	for mharc-axiom-developer@gnu.org; Tue, 17 Mar 2009 21:44:51 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Ljkpt-0002df-4O
	for axiom-developer@nongnu.org; Tue, 17 Mar 2009 21:44:49 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Ljkpo-0002cw-1R
	for axiom-developer@nongnu.org; Tue, 17 Mar 2009 21:44:48 -0400
Received: from [199.232.76.173] (port=34419 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Ljkpn-0002cs-Sp
	for axiom-developer@nongnu.org; Tue, 17 Mar 2009 21:44:43 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:39374
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1Ljkpn-0001Yv-D0
	for axiom-developer@nongnu.org; Tue, 17 Mar 2009 21:44:43 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n2I1idug031344;
	Tue, 17 Mar 2009 19:44:39 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n2I1idk8031341;
	Tue, 17 Mar 2009 19:44:39 -0600
Date: Tue, 17 Mar 2009 19:44:39 -0600
Message-Id: <200903180144.n2I1idk8031341@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090316.02.tpd.patch (sockio.lisp restore
	sock-send-int)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Wed, 18 Mar 2009 01:44:49 -0000

sock-send-int is used in a macro in the algebra
so these functions were restored.

input files were updated
========================================================================
diff --git a/changelog b/changelog
index 63cc00a..bb5312c 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,11 @@
+20090316 tpd src/axiom-website/patches.html 20090316.02.tpd.patch
+20090316 tpd src/interp/sockio.lisp restore sock-send-int
+20090316 tpd src/input/setcmd.input fix minor breakage
+20090316 tpd src/input/knot2.input fix minor breakage
+20090316 tpd src/input/is.input fix minor breakage
+20090316 tpd src/input/ifthenelse.input fix minor breakage
+20090316 tpd src/input/ico.input fix minor breakage
+20090316 tpd src/input/grpthry.input fix minor breakage
 20090316 tpd src/axiom-website/patches.html 20090316.01.tpd.patch
 20090316 tpd src/input/wester.input add )set break resume
 20090316 tpd src/input/void.input add )set break resume
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index 2c8ff7d..372d908 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -1007,5 +1007,7 @@ bookvol5 document )set, include root code<br/>
 bookvol5 document collect set support functions<br/>
 <a href="patches/20090316.01.tpd.patch">20090316.01.tpd.patch</a>
 bookvol5 add )expose, add )set break resume<br/>
+<a href="patches/20090316.02.tpd.patch">20090316.02.tpd.patch</a>
+sockio.lisp restore sock-send-int<br/>
  </body>
 </html>
diff --git a/src/input/grpthry.input.pamphlet b/src/input/grpthry.input.pamphlet
index d0fd173..7568226 100644
--- a/src/input/grpthry.input.pamphlet
+++ b/src/input/grpthry.input.pamphlet
@@ -122,7 +122,7 @@ member? ( y , g2 )
 --R PermutationGroup S: SetCategory  is a domain constructor
 --R Abbreviation for PermutationGroup is PERMGRP 
 --R This constructor is exposed in this frame.
---R Issue )edit permgrps.spad.pamphlet to see algebra source code for PERMGRP 
+--R Issue )edit bookvol10.3.spad.pamphlet to see algebra source code for PERMGRP 
 --R
 --R------------------------------- Operations --------------------------------
 --R ?<? : (%,%) -> Boolean                ?<=? : (%,%) -> Boolean
diff --git a/src/input/ico.input.pamphlet b/src/input/ico.input.pamphlet
index aaacf79..c842a9a 100644
--- a/src/input/ico.input.pamphlet
+++ b/src/input/ico.input.pamphlet
@@ -585,13 +585,9 @@ polygon(space,[p10,p11,p6])
 makeViewport3D(space,title=="Icosahedron")
 --R 
 --R   Transmitting data...
---R 
---RDaly Bug
---R   >> System error:
---R   SOCK-SEND-INT is invalid as a function.
---R
---R   Continuing to read the file...
 --R
+--R   (64)  ThreeDimensionalViewport: "Icosahedron"
+--R                                               Type: ThreeDimensionalViewport
 --E 65
 
 )spool 
diff --git a/src/input/ifthenelse.input.pamphlet b/src/input/ifthenelse.input.pamphlet
index 6dd5024..03d2c7d 100644
--- a/src/input/ifthenelse.input.pamphlet
+++ b/src/input/ifthenelse.input.pamphlet
@@ -105,21 +105,21 @@ for i in 2..2 repeat
     then output("positive") 
     else output("nonpositive")
 --R 
---R  Line  47: --R 
---R  Line  48: --R   positive
---R  Line  49: --R                                                                   Type: Void
---R  Line  50: --E 5
---R  Line  51: 
---R  Line  52: --S 6 of 20
---R  Line  53: for i in 2..2 repeat
---R  Line  54:   if i>0 
+--R  Line  48: --R 
+--R  Line  49: --R   positive
+--R  Line  50: --R                                                                   Type: Void
+--R  Line  51: --E 5
+--R  Line  52: 
+--R  Line  53: --S 6 of 20
+--R  Line  54: for i in 2..2 repeat
+--R  Line  55:   if i>0 
 --R           ..A
 --R  Error  A: (from #\A and on) Ignored from here
---R  Line  55:     then output("positive") 
+--R  Line  56:     then output("positive") 
 --R           ....A
 --R  Error  A: Improper syntax.
 --R  Error  A: (from #\A up to ) Ignored.
---R  Line  56:     else output("nonpositive")
+--R  Line  57:     else output("nonpositive")
 --R           ....A........................B
 --R  Error  A: Improper syntax.
 --R  Error  A: (from #\A up to #\B) Ignored.
@@ -145,20 +145,20 @@ for i in 2..2 repeat
     output(i)
     else output("nonpositive")
 --R 
---R  Line  83: --R 
---R  Line  84: --R
---R  Line  85: --R   (6)  2
---R  Line  86: --R                                                        Type: PositiveInteger
---R  Line  87: --E 7
---R  Line  88: 
---R  Line  89: --S 8 of 20
---R  Line  90: for i in 2..2 repeat
---R  Line  91:   if i>0 then
---R  Line  92:     output(i)
---R  Line  93:     output("positive") 
---R  Line  94:   else
---R  Line  95:     output(i)
---R  Line  96:     else output("nonpositive")
+--R  Line  84: --R 
+--R  Line  85: --R
+--R  Line  86: --R   (6)  2
+--R  Line  87: --R                                                        Type: PositiveInteger
+--R  Line  88: --E 7
+--R  Line  89: 
+--R  Line  90: --S 8 of 20
+--R  Line  91: for i in 2..2 repeat
+--R  Line  92:   if i>0 then
+--R  Line  93:     output(i)
+--R  Line  94:     output("positive") 
+--R  Line  95:   else
+--R  Line  96:     output(i)
+--R  Line  97:     else output("nonpositive")
 --R           ....A
 --R  Error  A: (from #\A up to ) Ignored.
 --R  Error  A: Improper syntax.
diff --git a/src/input/is.input.pamphlet b/src/input/is.input.pamphlet
index 0845db2..6ec0785 100644
--- a/src/input/is.input.pamphlet
+++ b/src/input/is.input.pamphlet
@@ -44,7 +44,7 @@ f: INT -> INT
 --E 1
 
 --S 2 of 5
- f n ==
+f n ==
    not empty?(u := Is(n, 2*m%)) => integer eval(m%, u)
    3 * n + 1
 --R 
@@ -71,10 +71,10 @@ for every n
 --S 4 of 5
 s := g 27
 --R 
---R   Compiling function f with type Integer -> Integer 
 --R   Compiling function g with type Integer -> Stream Integer 
+--R   Compiling function f with type Integer -> Integer 
 --R
---R   (3)  [27,82,41,124,62,31,94,47,142,71,...]
+--R   (4)  [27,82,41,124,62,31,94,47,142,71,...]
 --R                                                         Type: Stream Integer
 --E 4
 
@@ -82,7 +82,7 @@ s := g 27
 extend(s, 150)
 --R 
 --R
---R   (4)
+--R   (5)
 --R   [27, 82, 41, 124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242,
 --R    121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350,
 --R    175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167,
diff --git a/src/input/knot2.input.pamphlet b/src/input/knot2.input.pamphlet
index 5df3e80..5ece9fc 100644
--- a/src/input/knot2.input.pamphlet
+++ b/src/input/knot2.input.pamphlet
@@ -23,7 +23,7 @@
 @
 This is the color function, nothing elaborate for now
 <<*>>=
---S 1 of 8
+--S 1 of 7
 f(x:SF):SF == x
 --R 
 --R   Function declaration f : DoubleFloat -> DoubleFloat has been added 
@@ -37,7 +37,7 @@ Only p/q is really used, but p and q correspond to
 the factors in the notes deriving these knotty things    
 see the notes for detail...too involved to explain here  
 <<*>>=
---S 2 of 8
+--S 2 of 7
 [p,q] := [3,5]
 --R 
 --R
@@ -45,7 +45,7 @@ see the notes for detail...too involved to explain here
 --R                                                   Type: List PositiveInteger
 --E 2
 
---S 3 of 8
+--S 3 of 7
 PQ    := p/q
 --R 
 --R
@@ -55,7 +55,7 @@ PQ    := p/q
 --R                                                       Type: Fraction Integer
 --E 3
 
---S 4 of 8
+--S 4 of 7
 l := lcm(p, q) quo p
 --R 
 --R
@@ -63,7 +63,7 @@ l := lcm(p, q) quo p
 --R                                                        Type: PositiveInteger
 --E 4
 
---S 5 of 8
+--S 5 of 7
 maxRange := (odd? l => l * %pi; 2 * l * %pi)  
 --R 
 --R
@@ -71,7 +71,7 @@ maxRange := (odd? l => l * %pi; 2 * l * %pi)
 --R                                                                     Type: Pi
 --E 5
 
---S 6 of 8
+--S 6 of 7
 theRange := 0..maxRange
 --R 
 --R
@@ -86,7 +86,7 @@ knot:TUBE := tubePlot(sin t * cos(PQ*t),cos t * cos(PQ*t),cos t * sin(PQ*t),
                       f, theRange, 0.1::SF, 6, "open" )
 \end{verbatim}
 <<*>>=
---S 7 of 8
+--S 7 of 7
 v:=draw(curve(sin t * cos(PQ*t),cos t * cos(PQ*t),cos t * sin(PQ*t)), _
         t=theRange, tubeRadius==0.1)
 --R 
@@ -94,24 +94,19 @@ v:=draw(curve(sin t * cos(PQ*t),cos t * cos(PQ*t),cos t * sin(PQ*t)), _
 --I   Compiling function %D with type DoubleFloat -> DoubleFloat 
 --I   Compiling function %F with type DoubleFloat -> DoubleFloat 
 --R   Transmitting data...
---R 
---RDaly Bug
---R   >> System error:
---R   SOCK-SEND-INT is invalid as a function.
---R
---R   Continuing to read the file...
 --R
+--R   (7)  ThreeDimensionalViewport: "DCOS((3*t)/5)*DSIN(t)"
+--R                                               Type: ThreeDimensionalViewport
 --E 7
 
 @
 close the viewport
 \begin{verbatim}
 makeViewport3D(knot, concat ["knot",p::String,q::String])$VIEW3D
+close(v)
 \end{verbatim}
 <<*>>=
---S 8 of 8
-close(v)
---E 8
+
 )spool 
 )lisp (bye)
  
diff --git a/src/input/setcmd.input.pamphlet b/src/input/setcmd.input.pamphlet
index 0a10e25..9592801 100644
--- a/src/input/setcmd.input.pamphlet
+++ b/src/input/setcmd.input.pamphlet
@@ -24,10 +24,10 @@
 --R
 --R The breakmode option may be followed by any one of the following:
 --R
---R -> nobreak 
+--R    nobreak
 --R    break
 --R    query
---R    resume
+--R -> resume 
 --R    fastlinks
 --R
 --R The current setting is indicated.
diff --git a/src/interp/sockio.lisp.pamphlet b/src/interp/sockio.lisp.pamphlet
index f03492e..2eb437e 100644
--- a/src/interp/sockio.lisp.pamphlet
+++ b/src/interp/sockio.lisp.pamphlet
@@ -113,11 +113,35 @@ resolve the problem
   (defentry NANQ () (double "NANQ"))
   )
 
+(defun open-server (name)
+  (open_server name))
+(defun sock-get-int (type)
+  (sock_get_int type))
+(defun sock-send-int (type val)
+  (sock_send_int type val))
+(defun sock-get-string (type buf buf-len)
+  (sock_get_string_buf type buf buf-len))
+(defun sock-send-string (type str)
+  (sock_send_string_len type str (length str)))
+(defun sock-get-float (type)
+  (sock_get_float type))
+(defun sock-send-float (type val)
+  (sock_send_float type val))
+(defun sock-send-wakeup (type)
+  (sock_send_wakeup type))
+(defun server-switch ()
+  (server_switch))
+(defun sock-send-signal (type signal)
+  (sock_send_signal type signal))
+(defun print-line (str)
+  (print_line str))
 (defun |plusInfinity| () (plus_infinity))
 (defun |minusInfinity| () (minus_infinity))
 
 ;; Macros for use in Boot
 
+(defun |openServer| (name)
+  (open_server name))
 (defun |sockGetInt| (type)
   (sock_get_int type))
 (defun |sockSendInt| (type val)



From MAILER-DAEMON Wed Mar 18 02:17:26 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Ljp5i-000225-43
	for mharc-axiom-developer@gnu.org; Wed, 18 Mar 2009 02:17:26 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Ljp5h-000220-2S
	for axiom-developer@nongnu.org; Wed, 18 Mar 2009 02:17:25 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Ljp5c-00021c-Ur
	for axiom-developer@nongnu.org; Wed, 18 Mar 2009 02:17:24 -0400
Received: from [199.232.76.173] (port=49787 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Ljp5c-00021Z-Nl
	for axiom-developer@nongnu.org; Wed, 18 Mar 2009 02:17:20 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:59700
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1Ljp5b-0007Sx-Sa
	for axiom-developer@nongnu.org; Wed, 18 Mar 2009 02:17:20 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n2I6HHug014838;
	Wed, 18 Mar 2009 00:17:17 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n2I6HHOd014835;
	Wed, 18 Mar 2009 00:17:17 -0600
Date: Wed, 18 Mar 2009 00:17:17 -0600
Message-Id: <200903180617.n2I6HHOd014835@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090317.01.tpd.patch (bookvol5 rewrite generated
	lisp)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Wed, 18 Mar 2009 06:17:25 -0000

Machine generated code is not idiomatic lisp.
Rewrite and refactor the code.

=======================================================================
diff --git a/books/bookvol5.pamphlet b/books/bookvol5.pamphlet
index 6c47b62..1b42dec 100644
--- a/books/bookvol5.pamphlet
+++ b/books/bookvol5.pamphlet
@@ -1686,57 +1686,50 @@ system function and constructor caches.
 \end{verbatim}
 
 <<defun clearSpad2Cmd>>=
-(defun |clearSpad2Cmd| (|l|)
- (prog (|$clearExcept| |opt| |optList| |arg|)
-  (declare (special |$clearExcept|))
-  (return
-   (seq
-    (progn
-     (setq |$clearExcept| nil)
-     (cond 
-      (|$options|
-       (setq |$clearExcept|
-        (prog (t0)
-         (setq t0 t)
-         (return
-          (do ((t1 nil (null t0))
-               (t2 |$options| (cdr t2))
-               (t3 nil))
-              ((or t1 
-                   (atom t2)
-                   (progn (setq t3 (car t2)) nil)
-                   (progn (progn (setq |opt| (car t3)) t3) nil))
-                 t0)
-           (seq 
-            (exit 
-             (setq t0
-              (and t0 
-                   (eq
-                    (|selectOptionLC| |opt| '(|except|) '|optionError|)
-                    '|except|)))))))))))
+(defun |clearSpad2Cmd| (l)
+  (let (|$clearExcept| |opt| |optList| |arg|)
+  (declare (special |$clearExcept| |$options| |$clearOptions|))
+  (setq |$clearExcept| nil)
+  (cond 
+   (|$options|
+    (setq |$clearExcept|
+     (prog (t0)
+      (setq t0 t)
+      (return
+       (do ((t1 nil (null t0))
+            (t2 |$options| (cdr t2))
+            (t3 nil))
+           ((or t1 
+                (atom t2)
+                (progn (setq t3 (car t2)) nil)
+                (progn (progn (setq |opt| (car t3)) t3) nil))
+              t0)
+        (setq t0
+         (and t0 
+              (eq
+               (|selectOptionLC| |opt| '(|except|) '|optionError|)
+               '|except|)))))))))
+  (cond
+   ((null l)
+     (setq |optList|
+      (prog (t4)
+       (setq t4 nil)
+       (return
+        (do ((t5 |$clearOptions| (cdr t5)) (x nil))
+            ((or (atom t5) (progn (setq x (car t5)) nil)) t4)
+         (setq t4 (append t4 `(|%l| "       " ,x)))))))
+     (|sayKeyedMsg| 's2iz0010 (cons |optList| nil)))
+   (t
+     (setq |arg|
+      (|selectOptionLC| (car l) '(|all| |completely| |scaches|) nil))
      (cond
-      ((null |l|)
-        (setq |optList|
-         (prog (t4)
-          (setq t4 nil)
-          (return
-           (do ((t5 |$clearOptions| (cdr t5)) (|x| nil))
-               ((or (atom t5) (progn (setq |x| (car t5)) nil)) t4)
-            (seq
-             (exit
-              (setq t4 
-               (append t4 (cons '|%l| (cons "       " (cons |x| nil)))))))))))
-        (|sayKeyedMsg| 's2iz0010 (cons |optList| nil)))
-      (t
-        (setq |arg|
-         (|selectOptionLC| (car |l|) '(|all| |completely| |scaches|) nil))
-        (cond
-         ((eq |arg| '|all|) (|clearCmdAll|))
-         ((eq |arg| '|completely|) (|clearCmdCompletely|))
-         ((eq |arg| '|scaches|) (|clearCmdSortedCaches|))
-         (|$clearExcept| (|clearCmdExcept| |l|))
-         (t
-          (|clearCmdParts| |l|) (|updateCurrentInterpreterFrame|)))))))))) 
+      ((eq |arg| '|all|)        (|clearCmdAll|))
+      ((eq |arg| '|completely|) (|clearCmdCompletely|))
+      ((eq |arg| '|scaches|)    (|clearCmdSortedCaches|))
+      (|$clearExcept|           (|clearCmdExcept| l))
+      (t 
+       (|clearCmdParts| l)
+       (|updateCurrentInterpreterFrame|))))))) 
 
 @
 
@@ -1751,24 +1744,18 @@ system function and constructor caches.
 
 <<defun clearCmdSortedCaches>>=
 (defun |clearCmdSortedCaches| ()
- (prog (|$lookupDefaults| |domain| |pair|)
-  (declare (special |$lookupDefaults|))
-  (return
-   (seq 
-    (progn 
-     (setq |$lookupDefaults| nil)
-     (do ((t0 (hget |$ConstructorCache| '|SortedCache|) (cdr t0)) 
-          (t1 nil))
-         ((or (atom t0) 
-              (progn (setq t1 (car t0)) nil)
-              (progn (progn (setq |domain| (cddr t1)) t1) nil))
-            nil)
-      (seq
-       (exit
-        (progn
-         (setq |pair|
-          (|compiledLookupCheck| '|clearCache| (cons |$Void| nil) |domain|))
-         (spadcall |pair|)))))))))) 
+ (let (|$lookupDefaults| domain pair)
+  (declare (special |$lookupDefaults| |$Void| |$ConstructorCache|))
+  (do ((t0 (hget |$ConstructorCache| '|SortedCache|) (cdr t0)) 
+       (t1 nil))
+      ((or (atom t0) 
+           (progn
+            (setq t1 (car t0)) 
+            (setq domain (cddr t1))
+            nil))
+         nil)
+    (setq pair (|compiledLookupCheck| '|clearCache| (list |$Void|) domain))
+    (spadcall pair))))
 
 @
 
@@ -1796,7 +1783,10 @@ system function and constructor caches.
 
 <<defun clearCmdCompletely>>=
 (defun |clearCmdCompletely| ()
- (progn (|clearCmdAll|)
+  (declare (special |$localExposureData| |$xdatabase| |$CatOfCatDatabase|
+    |$DomOfCatDatabase| |$JoinOfCatDatabase| |$JoinOfDomDatabase| 
+    |$attributeDb| |$functionTable| |$existingFiles|))
+  (|clearCmdAll|)
   (setq |$localExposureData| (copy-seq |$localExposureDataDefault|))
   (setq |$xdatabase| nil)
   (setq |$CatOfCatDatabase| nil)
@@ -1811,8 +1801,7 @@ system function and constructor caches.
   (setq |$existingFiles| (make-hashtable 'UEQUAL))
   (|sayKeyedMsg| 's2iz0014 nil)
   (reclaim)
-  (|sayKeyedMsg| 's2iz0015 nil)
-  nil)) 
+  (|sayKeyedMsg| 's2iz0015 nil))
 
 @
 
@@ -1840,7 +1829,9 @@ system function and constructor caches.
 
 <<defun clearCmdAll>>=
 (defun |clearCmdAll| ()
- (progn
+  (declare (special |$frameRecord| |$previousBindings| |$variableNumberAlist|
+     |$InteractiveFrame| |$useInternalHistoryTable| |$internalHistoryTable|
+     |$frameMessages| |$interpreterFrameName| |$currentLine|))
   (|clearCmdSortedCaches|)
   (setq |$frameRecord| nil)
   (setq |$previousBindings| nil)
@@ -1848,47 +1839,28 @@ system function and constructor caches.
   (|untraceMapSubNames| /tracenames)
   (setq |$InteractiveFrame| (list (list nil)))
   (|resetInCoreHist|)
-  (cond
-   (|$useInternalHistoryTable| (setq |$internalHistoryTable| nil))
-   (t (|deleteFile| (|histFileName|))))
+  (when |$useInternalHistoryTable| 
+    (setq |$internalHistoryTable| nil)
+   (|deleteFile| (|histFileName|)))
   (setq |$IOindex| 1)
   (|updateCurrentInterpreterFrame|)
   (setq |$currentLine| ")clear all")
   (|clearMacroTable|)
-  (cond 
-   (|$frameMessages|
-     (|sayKeyedMsg| 's2iz0011 (cons |$interpreterFrameName| nil)))
-   (t (|sayKeyedMsg| 's2iz0012 nil))))) 
+  (when |$frameMessages|
+    (|sayKeyedMsg| 's2iz0011 (list |$interpreterFrameName|))
+    (|sayKeyedMsg| 's2iz0012 nil)))
 
 @
 
 \defun{clearCmdExcept}
-\begin{verbatim}
-;clearCmdExcept(l is [opt,:vl]) ==
-;  --clears elements of vl of all options EXCEPT opt
-;  for option in $clearOptions |
-;    ^stringPrefix?(object2String opt,object2String option)
-;      repeat clearCmdParts [option,:vl]
-\end{verbatim}
-
+Clear all the options except the argument.
 <<defun clearCmdExcept>>=
 (defun |clearCmdExcept| (arg)
- (prog (opt vl)
-  (return
-   (seq
-    (progn
-     (setq opt (car arg))
-     (setq vl (cdr arg))
-     (do ((t0 |$clearOptions| (cdr t0)) (option nil))
-         ((or (atom t0) (progn (setq option (car t0)) nil)) nil)
-      (seq
-       (exit
-        (cond
-         ((null 
-           (|stringPrefix?| 
-            (|object2String| opt) 
-            (|object2String| option)))
-           (|clearCmdParts| (cons option vl)))))))))))) 
+ (let ((opt (car arg)) (vl (cdr arg)))
+ (declare (special |$clearOptions|))
+  (dolist (option |$clearOptions|)
+   (unless (|stringPrefix?| (|object2String| opt) (|object2String| option))
+    (|clearCmdParts| (cons option vl))))))
 
 @
 
@@ -1938,77 +1910,63 @@ system function and constructor caches.
 
 <<defun clearCmdParts>>=
 (defun |clearCmdParts| (arg)
- (prog (|$e| |opt| |option| |pmacs| |imacs| |vl| |p1| |lm| |prop| |p2|)
-  (declare (special |$e|))
-  (return
-   (seq
-    (progn
-     (setq |opt| (car arg))
-     (setq |vl| (cdr arg))
-     (setq |option| (|selectOptionLC| |opt| |$clearOptions| '|optionError|))
-     (setq |option| (intern (pname |option|)))
-     (setq |option|
-      (cond 
-       ((eq |option| '|types|) '|mode|)
-       ((eq |option| '|modes|) '|mode|)
-       ((eq |option| '|values|) '|value|)
-       (t |option|)))
-     (cond
-      ((null |vl|) (|sayKeyedMsg| 's2iz0055 nil))
-      (t
-       (setq |pmacs| (|getParserMacroNames|))
-       (setq |imacs| (|getInterpMacroNames|))
-       (cond
-        ((boot-equal |vl| '(|all|))
-         (setq |vl| (assocleft (caar |$InteractiveFrame|)))
-         (setq |vl| (remdup (append |vl| |pmacs|)))))
-       (setq |$e| |$InteractiveFrame|)
-       (do ((t0 |vl| (cdr t0)) (|x| nil))
-           ((or (atom t0) (progn (setq |x| (car t0)) nil)) nil)
-        (seq
-         (exit
-          (progn
-           (|clearDependencies| |x| t)
-           (cond
-            ((and (eq |option| '|properties|) (|member| |x| |pmacs|))
-              (|clearParserMacro| |x|)))
-           (cond 
-            ((and (eq |option| '|properties|) 
-                  (|member| |x| |imacs|)
-                  (null (|member| |x| |pmacs|)))
-             (|sayMessage| (cons 
-              "   You cannot clear the definition of the system-defined macro "
-               (cons (|fixObjectForPrinting| |x|) 
-                     (cons (intern "." "BOOT") nil))))))
-           (cond
-            ((setq |p1| (|assoc| |x| (caar |$InteractiveFrame|)))
+ (let (|$e| (opt (car arg)) option pmacs imacs (vl (cdr arg)) p1 lm prop p2)
+ (declare (special |$e| |$InteractiveFrame| |$clearOptions|))
+  (setq option (|selectOptionLC| opt |$clearOptions| '|optionError|))
+  (setq option (intern (pname option)))
+  (setq option
+   (case option
+    (|types| '|mode|)
+    (|modes| '|mode|)
+    (|values| '|value|)
+    (t option)))
+  (if (null vl)
+   (|sayKeyedMsg| 's2iz0055 nil)
+   (progn
+    (setq pmacs (|getParserMacroNames|))
+    (setq imacs (|getInterpMacroNames|))
+    (cond
+     ((boot-equal vl '(|all|))
+      (setq vl (assocleft (caar |$InteractiveFrame|)))
+      (setq vl (remdup (append vl pmacs)))))
+    (setq |$e| |$InteractiveFrame|)
+    (do ((t0 vl (cdr t0)) (x nil))
+        ((or (atom t0) (progn (setq x (car t0)) nil)) nil)
+      (|clearDependencies| x t)
+      (when (and (eq option '|properties|) (|member| x pmacs))
+        (|clearParserMacro| x))
+      (when (and (eq option '|properties|) 
+                 (|member| x imacs)
+                 (null (|member| x pmacs)))
+        (|sayMessage| (cons 
+         "   You cannot clear the definition of the system-defined macro "
+          (cons (|fixObjectForPrinting| x) 
+                (cons (intern "." "BOOT") nil)))))
+      (cond
+       ((setq p1 (|assoc| x (caar |$InteractiveFrame|)))
+        (cond
+         ((eq option '|properties|)
+          (cond
+           ((|isMap| x)
+            (seq
              (cond
-              ((eq |option| '|properties|)
+              ((setq lm 
+                (|get| x '|localModemap| |$InteractiveFrame|))
                (cond
-                ((|isMap| |x|)
-                 (seq
-                  (cond
-                   ((setq |lm| 
-                     (|get| |x| '|localModemap| |$InteractiveFrame|))
-                    (cond
-                     ((pairp |lm|)
-                     (exit (|untraceMapSubNames| (cons (cadar |lm|) nil))))))
-                   (t nil)))))
-               (do ((t1 (cdr |p1|) (cdr t1)) (|p2| nil))
-                   ((or (atom t1) (progn (setq |p2| (car t1)) nil)) nil)
-                (seq
-                 (exit
-                  (progn
-                   (setq |prop| (car |p2|))
-                   (|recordOldValue| |x| |prop| (cdr |p2|))
-                   (|recordNewValue| |x| |prop| nil)))))
-               (setf (caar |$InteractiveFrame|)
-                (|deleteAssoc| |x| (caar |$InteractiveFrame|))))
-              ((setq |p2| (|assoc| |option| (cdr |p1|)))
-               (|recordOldValue| |x| |option| (cdr |p2|))
-               (|recordNewValue| |x| |option| nil)
-               (rplacd |p2| nil)))))))))
-       nil))))))) 
+                ((pairp lm)
+                (exit (|untraceMapSubNames| (cons (cadar lm) nil))))))
+              (t nil)))))
+          (dolist (p2 (cdr p1))
+            (setq prop (car p2))
+            (|recordOldValue| x prop (cdr p2))
+            (|recordNewValue| x prop nil))
+          (setf (caar |$InteractiveFrame|)
+           (|deleteAssoc| x (caar |$InteractiveFrame|))))
+         ((setq p2 (|assoc| option (cdr p1)))
+          (|recordOldValue| x option (cdr p2))
+          (|recordNewValue| x option nil)
+          (rplacd p2 nil))))))
+    nil))))
 
 @
 
@@ -2055,9 +2013,9 @@ the entire Axiom session.
 Returns the number of active scratchpad clients
 <<defun queryClients>>=
 (defun |queryClients| ()
- (progn
+  (declare (special |$SessionManager| |$QueryClients|))
   (|sockSendInt| |$SessionManager| |$QueryClients|)
-  (|sockGetInt| |$SessionManager|))) 
+  (|sockGetInt| |$SessionManager|)) 
 
 @
 
@@ -2092,48 +2050,34 @@ Returns the number of active scratchpad clients
 
 <<defun close>>=
 (defun |close| (args)
- (prog (numClients opt fullopt quiet x)
-  (return
-   (seq
+ (let (numClients opt fullopt quiet x)
+ (declare (special |$SpadServer| |$SessionManager| |$CloseClient|
+     |$currentFrameNum| |$options|))
+  (if (null |$SpadServer|) 
+   (|throwKeyedMsg| 's2iz0071 nil))
+   (progn
+    (setq numClients (|queryClients|))
     (cond
-     (|$saturn|
-      (|sayErrorly| "Obsolete system command" (cons 
-       " The )close  system command is obsolete in this version of AXIOM."
-       (cons " Please use Close from the File menu instead." nil))))
+     ((> numClients 1)
+       (|sockSendInt| |$SessionManager| |$CloseClient|)
+       (|sockSendInt| |$SessionManager| |$currentFrameNum|)
+       (|closeInterpreterFrame| nil))
      (t
-      (setq quiet nil)
+      (do ((t0 |$options| (cdr t0)) (t1 nil))
+          ((or (atom t0) 
+               (progn (setq t1 (car t0)) nil)
+               (progn (progn (setq opt (car t1)) t1) nil))
+             nil)
+       (setq fullopt (|selectOptionLC| opt '(|quiet|) '|optionError|))
+       (unless quiet (setq quiet (eq fullopt '|quiet|))))
       (cond
-       ((null |$SpadServer|) (|throwKeyedMsg| 's2iz0071 nil))
+       (quiet
+        (|sockSendInt| |$SessionManager| |$CloseClient|)
+        (|sockSendInt| |$SessionManager| |$currentFrameNum|)
+        (|closeInterpreterFrame| nil))
        (t
-        (setq numClients (|queryClients|))
-        (cond
-         ((> numClients 1)
-           (|sockSendInt| |$SessionManager| |$CloseClient|)
-           (|sockSendInt| |$SessionManager| |$currentFrameNum|)
-           (|closeInterpreterFrame| NIL))
-         (t
-          (do ((t0 |$options| (cdr t0)) (t1 nil))
-              ((or (atom t0) 
-                   (progn (setq t1 (car t0)) nil)
-                   (progn (progn (setq opt (car t1)) t1) nil))
-                 nil)
-           (seq
-            (exit
-             (progn
-              (setq fullopt
-                (|selectOptionLC| opt '(|quiet|) '|optionError|))
-              (cond ((eq fullopt '|quiet|)
-               (setq quiet t)))))))
-          (cond
-           (quiet
-            (|sockSendInt| |$SessionManager| |$CloseClient|)
-            (|sockSendInt| |$SessionManager| |$currentFrameNum|)
-            (|closeInterpreterFrame| NIL))
-           (t
-            (setq x (upcase (|queryUserKeyedMsg| 's2iz0072 nil)))
-            (cond
-             ((memq (string2id-n x 1) '(yes y)) (bye))
-             (t nil)))))))))))))) 
+        (setq x (upcase (|queryUserKeyedMsg| 's2iz0072 nil)))
+        (when (memq (string2id-n x 1) '(yes y)) (bye)))))))))
 
 @
 
@@ -2530,114 +2474,97 @@ The value of the {\tt )set break} variable then controls what happens.
 
 <<defun compiler>>=
 (defun |compiler| (args)
- (prog (|$newConlist| optlist optname optargs fullopt havenew haveold 
-        aft ef af af1)
-  (declare (special |$newConlist|))
-  (return
-   (seq
-    (progn
-     (setq |$newConlist| nil)
-     (cond
-      ((and (null args) (null |$options|) (null /editfile))
-        (|helpSpad2Cmd| '(|compiler|)))
-      (t
-       (cond ((null args) (setq args (cons /editfile nil))))
-       (setq optlist '(|new| |old| |translate| |constructor|))
-       (setq havenew nil)
-       (setq haveold nil)
-       (do ((t0 |$options| (CDR t0)) (|opt| NIL))
-           ((or (atom t0) 
-                (progn (setq |opt| (car t0)) nil)
-                (null (null (and havenew haveold))))
-             nil)
-        (seq
-         (exit
-          (progn
-           (setq optname (car |opt|))
-           (setq optargs (cdr |opt|))
-           (setq fullopt (|selectOptionLC| optname optlist nil))
-           (cond
-            ((eq fullopt '|new|) (setq havenew t))
-            ((eq fullopt '|translate|) (setq haveold t))
-            ((eq fullopt '|constructor|) (setq haveold t))
-            ((eq fullopt '|old|) (setq haveold t)))))))
-       (cond
-        ((and havenew haveold) (|throwKeyedMsg| 's2iz0081 nil))
-        (t
-         (setq af (|pathname| args))
-         (setq aft (|pathnameType| af))
-         (cond
-          ((or havenew (string= aft "as"))
-           (cond
-            ((null (setq af1 ($findfile af '(|as|))))
-             (|throwKeyedMsg| 's2il0003 (cons (namestring af) nil)))
-            (t
-             (|compileAsharpCmd| (cons af1 nil)))))
-          ((or haveold (string= aft "spad"))
-           (cond
-            ((null (setq af1 ($findfile af '(|spad|))))
-              (|throwKeyedMsg| 's2il0003 (cons (namestring af) nil)))
-            (t
-              (|compileSpad2Cmd| (cons af1 nil)))))
-          ((string= aft "lsp")
-           (cond
-            ((null (setq af1 ($findfile af '(|lsp|))))
-             (|throwKeyedMsg| 's2il0003 (cons (namestring af) nil)))
-            (t
-             (|compileAsharpLispCmd| (CONS af1 NIL)))))
-          ((string= aft "nrlib")
-           (cond
-            ((null (setq af1 ($findfile af '(|nrlib|))))
-             (|throwKeyedMsg| 'S2IL0003 (cons (namestring af) nil)))
-            (t
-             (|compileSpadLispCmd| (cons af1 nil)))))
-          ((string= aft "ao")
-           (cond
-            ((null (setq af1 ($findfile af '(|ao|))))
-             (|throwKeyedMsg| 's2il0003 (cons (namestring af) nil)))
-            (t (|compileAsharpCmd| (cons af1 nil)))))
-          ((string= aft "al")
-           (cond
-            ((null (setq af1 ($findfile af '(|al|))))
-             (|throwKeyedMsg| 's2il0003 (cons (namestring af) nil)))
-            (t (|compileAsharpArchiveCmd| (cons af1 nil)))))
-          (t
-           (setq af1 ($findfile af '(|as| |spad| |ao| |asy|)))
-           (cond
-            ((and af1 (string= (|pathnameType| af1) "as"))
-             (|compileAsharpCmd| (CONS af1 NIL)))
-            ((and af1 (string= (|pathnameType| af1) "ao"))
-             (|compileAsharpCmd| (CONS af1 NIL)))
-            ((and af1 (string= (|pathnameType| af1) "spad"))
-             (|compileSpad2Cmd| (CONS af1 NIL)))
-            ((and af1 (string= (|pathnameType| af1) "asy"))
-             (|compileAsharpArchiveCmd| (CONS af1 NIL)))
-            (t
-             (setq ef (|pathname| /editfile))
-             (setq ef (|mergePathnames| af ef))
-             (cond
-              ((boot-equal ef af) (|throwKeyedMsg| 's2iz0039 nil))
-              (t
-               (setq af ef)
-               (cond
-                ((string= (|pathnameType| af) "as")
-                 (|compileAsharpCmd| args))
-                ((string= (|pathnameType| af) "ao")
-                 (|compileAsharpCmd| args))
-                ((string= (|pathnameType| af) "spad")
-                 (|compileSpad2Cmd| args))
-                (t
-                 (setq af1 ($findfile af '(|as| |spad| |ao| |asy|)))
-                 (cond
-                  ((and af1 (string= (|pathnameType| af1) "as"))
-                    (|compileAsharpCmd| (CONS af1 NIL)))
-                  ((and af1 (string= (|pathnameType| af1) "ao"))
-                    (|compileAsharpCmd| (CONS af1 NIL)))
-                  ((and af1 (string= (|pathnameType| af1) "spad"))
-                    (|compileSpad2Cmd| (CONS af1 NIL)))
-                  ((and af1 (string= (|pathnameType| af1) "asy"))
-                   (|compileAsharpArchiveCmd| (CONS af1 NIL)))
-                  (t (|throwKeyedMsg| 's2iz0039 nil)))))))))))))))))))) 
+ (let (|$newConlist| optlist optname optargs havenew haveold aft ef af af1)
+  (declare (special |$newConlist| |$options|))
+  (setq |$newConlist| nil)
+  (cond
+   ((and (null args) (null |$options|) (null /editfile))
+     (|helpSpad2Cmd| '(|compiler|)))
+   (t
+    (cond ((null args) (setq args (cons /editfile nil))))
+    (setq optlist '(|new| |old| |translate| |constructor|))
+    (setq havenew nil)
+    (setq haveold nil)
+    (do ((t0 |$options| (cdr t0)) (opt nil))
+        ((or (atom t0) 
+             (progn (setq opt (car t0)) nil)
+             (null (null (and havenew haveold))))
+          nil)
+     (setq optname (car opt))
+     (setq optargs (cdr opt))
+     (case (|selectOptionLC| optname optlist nil)
+      (|new|         (setq havenew t))
+      (|translate|   (setq haveold t))
+      (|constructor| (setq haveold t))
+      (|old|         (setq haveold t))))
+    (cond
+     ((and havenew haveold) 
+      (|throwKeyedMsg| 's2iz0081 nil))
+     (t
+      (setq af (|pathname| args))
+      (setq aft (|pathnameType| af))
+      (cond
+       ((or havenew (string= aft "as"))
+        (if (null (setq af1 ($findfile af '(|as|))))
+          (|throwKeyedMsg| 's2il0003 (cons (namestring af) nil))
+          (|compileAsharpCmd| (cons af1 nil))))
+       ((or haveold (string= aft "spad"))
+        (if (null (setq af1 ($findfile af '(|spad|))))
+           (|throwKeyedMsg| 's2il0003 (cons (namestring af) nil))
+           (|compileSpad2Cmd| (cons af1 nil))))
+       ((string= aft "lsp")
+        (if (null (setq af1 ($findfile af '(|lsp|))))
+          (|throwKeyedMsg| 's2il0003 (cons (namestring af) nil))
+          (|compileAsharpLispCmd| (cons af1 nil))))
+       ((string= aft "nrlib")
+        (if (null (setq af1 ($findfile af '(|nrlib|))))
+          (|throwKeyedMsg| 'S2IL0003 (cons (namestring af) nil))
+          (|compileSpadLispCmd| (cons af1 nil))))
+       ((string= aft "ao")
+        (if (null (setq af1 ($findfile af '(|ao|))))
+          (|throwKeyedMsg| 's2il0003 (cons (namestring af) nil))
+         (|compileAsharpCmd| (cons af1 nil))))
+       ((string= aft "al")
+        (if (null (setq af1 ($findfile af '(|al|))))
+          (|throwKeyedMsg| 's2il0003 (cons (namestring af) nil))
+          (|compileAsharpArchiveCmd| (cons af1 nil))))
+       (t
+        (setq af1 ($findfile af '(|as| |spad| |ao| |asy|)))
+        (cond
+         ((and af1 (string= (|pathnameType| af1) "as"))
+          (|compileAsharpCmd| (cons af1 nil)))
+         ((and af1 (string= (|pathnameType| af1) "ao"))
+          (|compileAsharpCmd| (cons af1 nil)))
+         ((and af1 (string= (|pathnameType| af1) "spad"))
+          (|compileSpad2Cmd| (cons af1 nil)))
+         ((and af1 (string= (|pathnameType| af1) "asy"))
+          (|compileAsharpArchiveCmd| (cons af1 nil)))
+         (t
+          (setq ef (|pathname| /editfile))
+          (setq ef (|mergePathnames| af ef))
+          (cond
+           ((boot-equal ef af) (|throwKeyedMsg| 's2iz0039 nil))
+           (t
+            (setq af ef)
+            (cond
+             ((string= (|pathnameType| af) "as")
+              (|compileAsharpCmd| args))
+             ((string= (|pathnameType| af) "ao")
+              (|compileAsharpCmd| args))
+             ((string= (|pathnameType| af) "spad")
+              (|compileSpad2Cmd| args))
+             (t
+              (setq af1 ($findfile af '(|as| |spad| |ao| |asy|)))
+              (cond
+               ((and af1 (string= (|pathnameType| af1) "as"))
+                 (|compileAsharpCmd| (CONS af1 NIL)))
+               ((and af1 (string= (|pathnameType| af1) "ao"))
+                 (|compileAsharpCmd| (CONS af1 NIL)))
+               ((and af1 (string= (|pathnameType| af1) "spad"))
+                 (|compileSpad2Cmd| (CONS af1 NIL)))
+               ((and af1 (string= (|pathnameType| af1) "asy"))
+                (|compileAsharpArchiveCmd| (cons af1 nil)))
+               (t (|throwKeyedMsg| 's2iz0039 nil)))))))))))))))))
 
 @
 
@@ -2736,112 +2663,97 @@ The value of the {\tt )set break} variable then controls what happens.
 
 <<defun compileAsharpCmd1>>=
 (defun |compileAsharpCmd1| (args)
- (prog (path pathtype optlist optname optargs fullopt bequiet docompilelisp 
+ (let (path pathtype optlist optname optargs bequiet docompilelisp 
         moreargs onlyargs dolibrary p tempargs s asharpargs command rc lsp)
-   (return
-    (seq
-     (progn
-      (setq path (|pathname| args))
-      (setq pathtype (|pathnameType| path))
-      (cond
-      ((and (nequal pathtype "as") (nequal pathtype "ao"))
-        (|throwKeyedMsg| 's2iz0083 nil))
-      ((null (probe-file path))
-        (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil)))
-      (t
-       (setq /editfile path)
-       (|updateSourceFiles| path)
-       (setq optlist
-        '(|new| |old| |translate| |onlyargs| |moreargs| |quiet| 
-          |nolispcompile| |noquiet| |library| |nolibrary|))
-       (setq bequiet nil)
-       (setq dolibrary t)
-       (setq docompilelisp t)
-       (setq moreargs nil)
-       (setq onlyargs nil)
-       (do ((t0 |$options| (cdr t0)) (|opt| nil))
-           ((or (atom t0) (progn (setq |opt| (car t0)) nil)) nil)
+   (declare (special |$options| |$asharpCmdlineFlags||$newConlist|))
+   (setq path (|pathname| args))
+   (setq pathtype (|pathnameType| path))
+   (cond
+   ((and (nequal pathtype "as") (nequal pathtype "ao"))
+     (|throwKeyedMsg| 's2iz0083 nil))
+   ((null (probe-file path))
+     (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil)))
+   (t
+    (setq /editfile path)
+    (|updateSourceFiles| path)
+    (setq optlist
+     '(|new| |old| |translate| |onlyargs| |moreargs| |quiet| 
+       |nolispcompile| |noquiet| |library| |nolibrary|))
+    (setq bequiet nil)
+    (setq dolibrary t)
+    (setq docompilelisp t)
+    (setq moreargs nil)
+    (setq onlyargs nil)
+    (dolist (opt |$options|)
+      (setq optname (car opt))
+      (setq optargs (cdr opt))
+      (case (|selectOptionLC| optname optlist nil)
+       (|new| nil)
+       (|old| (|error| '|Internal error: compileAsharpCmd got )old|))
+       (|translate|
+        (|error| '|Internal error: compileAsharpCmd got )translate|))
+       (|quiet|         (setq bequiet t))
+       (|noquiet|       (setq bequiet nil))
+       (|nolispcompile| (setq docompilelisp nil))
+       (|moreargs|      (setq moreargs optargs))
+       (|onlyargs|      (setq onlyargs optargs))
+       (|library|       (setq dolibrary t))
+       (|nolibrary|     (setq dolibrary nil))
+       (t 
+        (|throwKeyedMsg| 's2iz0036
+         (cons (strconc ")" (|object2String| optname)) nil)))))
+    (setq tempargs
+     (if (string= pathtype "ao")
+       (if (setq p (strpos "-Fao" |$asharpCmdlineFlags| 0 nil))
+         (if (eql p 0) 
+          (substring |$asharpCmdlineFlags| 5 nil)
+          (strconc (substring |$asharpCmdlineFlags| 0 p) 
+             " " (substring |$asharpCmdlineFlags| (plus p 5) nil)))
+         |$asharpCmdlineFlags|)
+       |$asharpCmdlineFlags|))
+    (setq asharpargs
+     (cond
+      (onlyargs
+       (setq s '||)
+       (do ((t1 onlyargs (cdr t1)) (|a| nil))
+           ((or (atom t1) (progn (setq |a| (car t1)) nil)) nil)
         (seq
          (exit
-          (progn
-           (setq optname (car |opt|))
-           (setq optargs (cdr |opt|))
-           (setq fullopt (|selectOptionLC| optname optlist nil))
-           (cond
-            ((eq fullopt '|new|) nil)
-            ((eq fullopt '|old|)
-             (|error| '|Internal error: compileAsharpCmd got )old|))
-            ((eq fullopt '|translate|)
-             (|error| '|Internal error: compileAsharpCmd got )translate|))
-            ((eq fullopt '|quiet|) (setq bequiet t))
-            ((eq fullopt '|noquiet|) (setq bequiet nil))
-            ((eq fullopt '|nolispcompile|) 
-              (setq docompilelisp nil))
-            ((eq fullopt '|moreargs|) (setq moreargs optargs))
-            ((eq fullopt '|onlyargs|) (setq onlyargs optargs))
-            ((eq fullopt '|library|) (setq dolibrary t))
-            ((eq fullopt '|nolibrary|) (setq dolibrary nil))
-            (t 
-             (|throwKeyedMsg| 's2iz0036
-              (cons (strconc ")" (|object2String| optname)) nil))))))))
-       (setq tempargs
-        (cond
-         ((string= pathtype "ao")
-          (cond
-           ((setq p (strpos "-Fao" |$asharpCmdlineFlags| 0 nil))
-            (cond
-             ((eql p 0) (substring |$asharpCmdlineFlags| 5 nil))
-             (t
-              (strconc (substring |$asharpCmdlineFlags| 0 p) 
-                " " (substring |$asharpCmdlineFlags| (plus p 5) nil)))))
-           (t |$asharpCmdlineFlags|)))
-         (t |$asharpCmdlineFlags|)))
-       (setq asharpargs
-        (cond
-         (onlyargs
-          (setq s '||)
-          (do ((t1 onlyargs (cdr t1)) (|a| nil))
-              ((or (atom t1) (progn (setq |a| (car t1)) nil)) nil)
-           (seq
-            (exit
-             (setq s (strconc s " " (|object2String| |a|))))))
-          s)
-         (moreargs
-          (setq s tempargs)
-          (do ((t2 moreargs (cdr t2)) (|a| nil))
-              ((or (atom t2) (progn (setq |a| (car t2)) nil)) nil)
-           (seq
-            (exit
-             (setq s (strconc s " " (|object2String| |a|))))))
-          s)
-         (t tempargs)))
-       (cond ((null bequiet)
-        (|sayKeyedMsg| 's2iz0038a 
-         (cons (|namestring| args) (cons asharpargs nil)))))
-       (setq command
-        (strconc
-         (strconc (getenv "ALDORROOT") "/bin/")
-         '|aldor | asharpargs " " (|namestring| args)))
-       (setq rc (obey command))
-       (cond
-        ((and (eql rc 0) docompilelisp)
-          (setq lsp (|fnameMake| "." (|pathnameName| args) "lsp"))
-          (cond
-           ((|fnameReadable?| lsp)
-            (cond
-             ((null bequiet)
-              (|sayKeyedMsg| 's2iz0089 (cons (|namestring| lsp) nil))))
-            (|compileFileQuietly| lsp))
-           (t (|sayKeyedMsg| 's2il0003 (cons (|namestring| lsp) nil))))))
+          (setq s (strconc s " " (|object2String| |a|))))))
+       s)
+      (moreargs
+       (setq s tempargs)
+       (do ((t2 moreargs (cdr t2)) (|a| nil))
+           ((or (atom t2) (progn (setq |a| (car t2)) nil)) nil)
+        (seq
+         (exit
+          (setq s (strconc s " " (|object2String| |a|))))))
+       s)
+      (t tempargs)))
+    (unless bequiet
+     (|sayKeyedMsg| 's2iz0038a  (list (|namestring| args) asharpargs )))
+    (setq command
+     (strconc
+      (strconc (getenv "ALDORROOT") "/bin/")
+      '|aldor | asharpargs " " (|namestring| args)))
+    (setq rc (obey command))
+    (cond
+     ((and (eql rc 0) docompilelisp)
+       (setq lsp (|fnameMake| "." (|pathnameName| args) "lsp"))
        (cond
-        ((and (eql rc 0) dolibrary)
-         (cond
-          ((null bequiet)
-            (|sayKeyedMsg| 's2iz0090 (cons (|pathnameName| path) nil))))
-         (|withAsharpCmd| (cons (|pathnameName| path) nil)))
-        ((null bequiet) (|sayKeyedMsg| 's2iz0084 nil))
-        (t nil))
-       (|extendLocalLibdb| |$newConlist|)))))))) 
+        ((|fnameReadable?| lsp)
+         (unless  bequiet
+           (|sayKeyedMsg| 's2iz0089 (cons (|namestring| lsp) nil)))
+         (|compileFileQuietly| lsp))
+        (t (|sayKeyedMsg| 's2il0003 (cons (|namestring| lsp) nil))))))
+    (cond
+     ((and (eql rc 0) dolibrary)
+      (unless bequiet
+         (|sayKeyedMsg| 's2iz0090 (cons (|pathnameName| path) nil)))
+      (|withAsharpCmd| (cons (|pathnameName| path) nil)))
+     ((null bequiet) (|sayKeyedMsg| 's2iz0084 nil))
+     (t nil))
+    (|extendLocalLibdb| |$newConlist|)))))
 
 @
 
@@ -2893,56 +2805,46 @@ The value of the {\tt )set break} variable then controls what happens.
 
 <<defun compileAsharpArchiveCmd>>=
 (defun |compileAsharpArchiveCmd| (args)
- (prog (path dir exists isdir curdir cmd rc asos)
-  (return
-   (seq
-    (progn 
-     (setq path (|pathname| args))
-     (cond
-      ((null (probe-file path))
-       (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil)))
-      (t
-       (setq dir (|fnameMake| "." (|pathnameName| path) "axldir"))
-       (setq exists (probe-file dir))
-       (setq isdir (|directoryp| (|namestring| dir)))
-       (cond
-        ((and exists (nequal isdir 1))
-          (|throwKeyedMsg| 's2il0027
+ (let (path dir exists isdir curdir cmd rc asos)
+  (declare (special $current-directory))
+  (setq path (|pathname| args))
+  (if (null (probe-file path))
+   (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil))
+   (progn
+    (setq dir (|fnameMake| "." (|pathnameName| path) "axldir"))
+    (setq exists (probe-file dir))
+    (setq isdir (|directoryp| (|namestring| dir)))
+    (if (and exists (nequal isdir 1))
+     (|throwKeyedMsg| 's2il0027 (list (|namestring| dir) (|namestring| args)))
+     (progn
+      (when (nequal isdir 1)
+        (setq cmd (strconc "mkdir " (|namestring| dir)))
+        (setq rc (obey cmd))
+        (when (nequal rc 0)
+          (|throwKeyedMsg| 's2il0027 
+           (list (|namestring| dir) (|namestring| args)))))
+      (setq curdir $current-directory)
+      (|cd| (cons (|object2Identifier| (|namestring| dir)) nil))
+      (setq cmd (strconc "ar x " (|namestring| path)))
+      (setq rc (obey cmd))
+      (cond
+       ((nequal rc 0)
+        (|cd| (cons (|object2Identifier| (|namestring| curdir)) nil))
+        (|throwKeyedMsg| 's2il0028
+         (cons (|namestring| dir) (cons (|namestring| args) nil))))
+       (t
+        (setq asos (directory (makestring "*.ao")))
+        (cond
+         ((null asos)
+          (|cd| (cons (|object2Identifier| (|namestring| curdir)) nil))
+          (|throwKeyedMsg| 's2il0029
            (cons (|namestring| dir) (cons (|namestring| args) nil))))
-        (t
-         (cond
-          ((nequal isdir 1)
-           (setq cmd (strconc "mkdir " (|namestring| dir)))
-           (setq rc (obey cmd))
-           (cond
-            ((nequal rc 0)
-             (|throwKeyedMsg| 's2il0027 
-              (cons (|namestring| dir) (cons (|namestring| args) nil)))))))
-         (setq curdir $current-directory)
-         (|cd| (cons (|object2Identifier| (|namestring| dir)) nil))
-         (setq cmd (strconc "ar x " (|namestring| path)))
-         (setq rc (obey cmd))
-         (cond
-          ((nequal rc 0)
-           (|cd| (cons (|object2Identifier| (|namestring| curdir)) nil))
-           (|throwKeyedMsg| 's2il0028
-            (cons (|namestring| dir) (cons (|namestring| args) nil))))
-          (t
-           (setq asos (directory (makestring "*.ao")))
-           (cond
-            ((null asos)
-             (|cd| (cons (|object2Identifier| (|namestring| curdir)) nil))
-             (|throwKeyedMsg| 's2il0029
-              (cons (|namestring| dir) (cons (|namestring| args) nil))))
-            (t
-             (do ((t0 asos (cdr t0)) (|aso| nil))
-                 ((or (atom t0) (progn (setq |aso| (car t0)) nil)) nil)
-              (seq
-               (exit
-                (|compileAsharpCmd1| (cons (|namestring| |aso|) nil)))))
-             (|cd| (CONS (|object2Identifier| (|namestring| curdir)) NIL))
-             (|terminateSystemCommand|)
-             (|spadPrompt|)))))))))))))) 
+         (t
+          (dolist (aso asos)
+             (|compileAsharpCmd1| (list (|namestring| |aso|))))
+          (|cd| (list (|object2Identifier| (|namestring| curdir))))
+          (|terminateSystemCommand|)
+          (|spadPrompt|)))))))))))
 
 @
 
@@ -2987,57 +2889,46 @@ The value of the {\tt )set break} variable then controls what happens.
 
 <<defun compileAsharpLispCmd>>=
 (defun |compileAsharpLispCmd| (args)
- (prog (path optlist optname optargs fullopt bequiet 
-        dolibrary lsp)
-  (return 
-   (seq 
-    (progn 
-     (setq path (|pathname| args))
-     (cond
-      ((null (probe-file path)) 
-         (|throwKeyedMsg| 's2il0003 (CONS (|namestring| args) NIL)))
-      (t
-       (setq optlist '(|quiet| |noquiet| |library| |nolibrary|))
-       (setq bequiet nil)
-       (setq dolibrary t)
-       (do ((t0 |$options| (cdr t0)) (|opt| nil))
-           ((or (atom t0) (progn (setq |opt| (car t0)) nil)) nil)
-        (seq
-         (exit
-          (progn
-           (setq optname (car |opt|))
-           (setq optargs (cdr |opt|))
-           (setq fullopt (|selectOptionLC| optname optlist nil))
-           (cond
-            ((eq fullopt '|quiet|) (setq bequiet t))
-            ((eq fullopt '|noquiet|) (setq bequiet nil))
-            ((eq fullopt '|library|) (setq dolibrary t))
-            ((eq fullopt '|nolibrary|) (setq dolibrary nil))
-            (t
-             (|throwKeyedMsg| 's2iz0036 
-              (cons (strconc ")" (|object2String| optname)) nil))))))))
-       (setq lsp
-        (|fnameMake|
-         (|pathnameDirectory| path)
-         (|pathnameName| path)
-         (|pathnameType| path)))
-       (cond
-        ((|fnameReadable?| lsp)
-         (cond
-          ((null bequiet)
-            (|sayKeyedMsg| 's2iz0089 (cons (|namestring| lsp) NIL))))
-         (|compileFileQuietly| lsp))
-        (t (|sayKeyedMsg| 's2il0003 (cons (|namestring| lsp) nil))))
-       (cond
-        (dolibrary
-         (cond
-          ((null bequiet) 
-           (|sayKeyedMsg| 's2iz0090 (cons (|pathnameName| path) nil))))
-         (|withAsharpCmd| (CONS (|pathnameName| path) NIL)))
-        ((null bequiet) (|sayKeyedMsg| 's2iz0084 nil))
-        (t nil))
-       (|terminateSystemCommand|)
-       (|spadPrompt|)))))))) 
+ (let (path optlist optname optargs bequiet dolibrary lsp)
+  (setq path (|pathname| args))
+  (cond
+   ((null (probe-file path)) 
+      (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil)))
+   (t
+    (setq optlist '(|quiet| |noquiet| |library| |nolibrary|))
+    (setq bequiet nil)
+    (setq dolibrary t)
+    (dolist (opt |$options|)
+      (setq optname (car opt))
+      (setq optargs (cdr opt))
+      (case (|selectOptionLC| optname optlist nil)
+        (|quiet|     (setq bequiet t))
+        (|noquiet|   (setq bequiet nil))
+        (|library|   (setq dolibrary t))
+        (|nolibrary| (setq dolibrary nil))
+        (t
+          (|throwKeyedMsg| 's2iz0036 
+           (list (strconc ")" (|object2String| optname)))))))
+    (setq lsp
+     (|fnameMake|
+      (|pathnameDirectory| path)
+      (|pathnameName| path)
+      (|pathnameType| path)))
+    (cond
+     ((|fnameReadable?| lsp)
+      (unless bequiet
+         (|sayKeyedMsg| 's2iz0089 (cons (|namestring| lsp) NIL)))
+      (|compileFileQuietly| lsp))
+     (t (|sayKeyedMsg| 's2il0003 (cons (|namestring| lsp) nil))))
+    (cond
+     (dolibrary
+      (unless  bequiet
+        (|sayKeyedMsg| 's2iz0090 (cons (|pathnameName| path) nil)))
+      (|withAsharpCmd| (cons (|pathnameName| path) nil)))
+     ((null bequiet) (|sayKeyedMsg| 's2iz0084 nil))
+     (t nil))
+    (|terminateSystemCommand|)
+    (|spadPrompt|)))))
 
 @
 
@@ -3083,57 +2974,46 @@ The value of the {\tt )set break} variable then controls what happens.
 
 <<defun compileSpadLispCmd>>=
 (defun |compileSpadLispCmd| (args)
- (prog (path optlist optname optargs fullopt beQuiet dolibrary lsp)
-  (return
-   (seq
-    (progn
-     (setq path (|pathname| (|fnameMake| (car args) "code" "lsp")))
-     (cond
-      ((null (probe-file path))
-        (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil)))
-      (t
-       (setq optlist '(|quiet| |noquiet| |library| |nolibrary|))
-       (setq beQuiet nil)
-       (setq dolibrary t)
-       (do ((t0 |$options| (cdr t0)) (|opt| nil))
-           ((or (atom t0) (progn (setq |opt| (car t0)) nil)) nil)
-        (seq
-         (exit
-          (progn
-           (setq optname (car |opt|))
-           (setq optargs (cdr |opt|))
-           (setq fullopt (|selectOptionLC| optname optlist nil))
-           (cond
-            ((eq fullopt '|quiet|) (setq beQuiet t))
-            ((eq fullopt '|noquiet|) (setq beQuiet nil))
-            ((eq fullopt '|library|) (setq dolibrary t))
-            ((eq fullopt '|nolibrary|) (setq dolibrary nil))
-            (t
-             (|throwKeyedMsg| 's2iz0036
-              (cons (strconc ")" (|object2String| optname)) nil))))))))
-       (setq lsp
-        (|fnameMake|
-         (|pathnameDirectory| path)
-         (|pathnameName| path)
-         (|pathnameType| path)))
-       (cond
-        ((|fnameReadable?| lsp)
-         (cond
-          ((null beQuiet)
-           (|sayKeyedMsg| 's2iz0089 (cons (|namestring| lsp) nil))))
-          (recompile-lib-file-if-necessary lsp))
-        (t
-         (|sayKeyedMsg| 's2il0003 (cons (|namestring| lsp) nil))))
-       (cond
-        (dolibrary
-         (cond
-          ((null beQuiet)
-            (|sayKeyedMsg| 's2iz0090 (cons (|pathnameName| path) nil))))
-          (localdatabase (cons (|pathnameName| (car args)) nil) nil))
-        ((null beQuiet) (|sayKeyedMsg| 's2iz0084 nil))
-        (t nil))
-       (|terminateSystemCommand|)
-       (|spadPrompt|)))))))) 
+ (let (path optlist optname optargs beQuiet dolibrary lsp)
+  (declare (special |$options|))
+  (setq path (|pathname| (|fnameMake| (car args) "code" "lsp")))
+  (cond
+   ((null (probe-file path))
+     (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil)))
+   (t
+    (setq optlist '(|quiet| |noquiet| |library| |nolibrary|))
+    (setq beQuiet nil)
+    (setq dolibrary t)
+    (dolist (opt |$options|)
+      (setq optname (car opt))
+      (setq optargs (cdr opt))
+      (case (|selectOptionLC| optname optlist nil)
+         (|quiet|     (setq beQuiet t))
+         (|noquiet|   (setq beQuiet nil))
+         (|library|   (setq dolibrary t))
+         (|nolibrary| (setq dolibrary nil))
+         (t
+          (|throwKeyedMsg| 's2iz0036
+           (list (strconc ")" (|object2String| optname)))))))
+    (setq lsp
+     (|fnameMake|
+      (|pathnameDirectory| path)
+      (|pathnameName| path)
+      (|pathnameType| path)))
+    (cond
+     ((|fnameReadable?| lsp)
+      (unless beQuiet (|sayKeyedMsg| 's2iz0089 (list (|namestring| lsp))))
+       (recompile-lib-file-if-necessary lsp))
+     (t
+      (|sayKeyedMsg| 's2il0003 (list (|namestring| lsp)))))
+    (cond
+     (dolibrary
+      (unless beQuiet (|sayKeyedMsg| 's2iz0090 (list (|pathnameName| path))))
+      (localdatabase (list (|pathnameName| (car args))) nil))
+     ((null beQuiet) (|sayKeyedMsg| 's2iz0084 nil))
+     (t nil))
+    (|terminateSystemCommand|)
+    (|spadPrompt|)))))
 
 @
 
@@ -3301,9 +3181,9 @@ to construct a list of strings for the sayMessage function
 and tell the user what options are available.
 <<defun displaySpad2Cmd>>=
 (defun displaySpad2Cmd (l)
- (declare (special |$e|))
  (let ((|$e| |$EmptyEnvironment|) (opt (car l)) (vl (cdr l)) 
        option optList msg)
+  (declare (special |$e| |$EmptyEnvironment| |$displayOptions|))
   (if (and (pairp l) (not (eq opt '?)))
    (progn
     (setq option (|selectOptionLC| opt |$displayOptions| '|optionError|))
diff --git a/changelog b/changelog
index bb5312c..5c3e7c9 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,5 @@
+20090317 tpd src/axiom-website/patches.html 20090317.01.tpd.patch
+20090317 tpd books/bookvol5 rewrite generated lisp into readable form
 20090316 tpd src/axiom-website/patches.html 20090316.02.tpd.patch
 20090316 tpd src/interp/sockio.lisp restore sock-send-int
 20090316 tpd src/input/setcmd.input fix minor breakage
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index 372d908..74c25dd 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -1009,5 +1009,7 @@ bookvol5 document collect set support functions<br/>
 bookvol5 add )expose, add )set break resume<br/>
 <a href="patches/20090316.02.tpd.patch">20090316.02.tpd.patch</a>
 sockio.lisp restore sock-send-int<br/>
+<a href="patches/20090317.01.tpd.patch">20090317.01.tpd.patch</a>
+bookvol5 rewrite generated lisp into readable form<br/>
  </body>
 </html>



From MAILER-DAEMON Fri Mar 20 13:01:44 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Lki6J-0002kl-RK
	for mharc-axiom-developer@gnu.org; Fri, 20 Mar 2009 13:01:43 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Lki6G-0002fP-H8
	for axiom-developer@nongnu.org; Fri, 20 Mar 2009 13:01:40 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Lki6B-0002Y9-4R
	for axiom-developer@nongnu.org; Fri, 20 Mar 2009 13:01:39 -0400
Received: from [199.232.76.173] (port=50762 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Lki6A-0002Xv-RC
	for axiom-developer@nongnu.org; Fri, 20 Mar 2009 13:01:34 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:38570
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1Lki67-0006jU-E1
	for axiom-developer@nongnu.org; Fri, 20 Mar 2009 13:01:34 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n2KH1Mug006111;
	Fri, 20 Mar 2009 11:01:22 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n2KH1KsL006101;
	Fri, 20 Mar 2009 11:01:20 -0600
Date: Fri, 20 Mar 2009 11:01:20 -0600
Message-Id: <200903201701.n2KH1KsL006101@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090319.01.tpd.patch (bookvol5 move top level
	command handling)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Fri, 20 Mar 2009 17:01:41 -0000

More of the top level command machinery was moved into book volume 5.
======================================================================
diff --git a/books/bookvol5.pamphlet b/books/bookvol5.pamphlet
index 1b42dec..2875b50 100644
--- a/books/bookvol5.pamphlet
+++ b/books/bookvol5.pamphlet
@@ -511,38 +511,31 @@ has the default function \verb|InterpExecuteSpadSystemCommand|.
 Thus, when a system command is entered this function is called.
 <<defun SpadInterpretStream>>=
 (defun |SpadInterpretStream| (str source interactive?) 
- (prog (|$promptMsg| |$shoeReadLineFunction| |$systemCommandFunction| 
-        |$ncMsgList| |$erMsgToss| |$lastPos| |$inclAssertions| 
-        |$okToExecuteMachineCode| |$newcompErrorCount| |$newcompMode| 
-        |$libQuiet| |$fn|)
+ (let (|$promptMsg| |$shoeReadLineFunction| |$systemCommandFunction| 
+       |$ncMsgList| |$erMsgToss| |$lastPos| |$inclAssertions| 
+       |$okToExecuteMachineCode| |$newcompErrorCount| |$newcompMode| 
+       |$libQuiet| |$fn|)
   (declare (special |$promptMsg| |$shoeReadLineFunction| 
             |$systemCommandFunction| |$ncMsgList| |$erMsgToss| |$lastPos| 
             |$inclAssertions| |$okToExecuteMachineCode| |$newcompErrorCount| 
             |$newcompMode| |$libQuiet| |$fn| |$nopos|))
-   (return 
-    (progn 
-     (setq |$fn| source) 
-     (setq |$libQuiet| (null interactive?)) 
-     (setq |$newcompMode| nil) 
-     (setq |$newcompErrorCount| 0) 
-     (setq |$okToExecuteMachineCode| t) 
-     (setq |$inclAssertions| (list 'aix '|CommonLisp|)) 
-     (setq |$lastPos| |$nopos|) 
-     (setq |$erMsgToss| nil) 
-     (setq |$ncMsgList| nil) 
-     (setq |$systemCommandFunction| #'|InterpExecuteSpadSystemCommand|) 
-     (setq |$shoeReadLineFunction| #'|serverReadLine|) 
-     (setq |$promptMsg| 'S2CTP023) 
-     (cond 
-      (interactive? 
-       (progn 
-        (princ (mkprompt)) 
-        (|intloopReadConsole| "" str) 
-        nil))
-      (t 
-       (progn 
-        (|intloopInclude| source 0) 
-        nil)))))))
+  (setq |$fn| source) 
+  (setq |$libQuiet| (null interactive?)) 
+  (setq |$newcompMode| nil) 
+  (setq |$newcompErrorCount| 0) 
+  (setq |$okToExecuteMachineCode| t) 
+  (setq |$inclAssertions| (list 'aix '|CommonLisp|)) 
+  (setq |$lastPos| |$nopos|) 
+  (setq |$erMsgToss| nil) 
+  (setq |$ncMsgList| nil) 
+  (setq |$systemCommandFunction| #'|InterpExecuteSpadSystemCommand|) 
+  (setq |$shoeReadLineFunction| #'|serverReadLine|) 
+  (setq |$promptMsg| 'S2CTP023) 
+  (if interactive? 
+   (progn 
+     (princ (mkprompt)) 
+     (|intloopReadConsole| "" str))
+   (|intloopInclude| source 0))))
 
 @
 \section{The Read-Eval-Print Loop}
@@ -855,9 +848,12 @@ See:\\
 \item The \fnref{zsystemdevelopment} command
 \end{itemize}
 
+\defdollar{systemCommands}
 <<initvars>>=
 (defvar |$systemCommands| nil)
 
+@
+<<postvars>>=
 (eval-when (eval load)
  (setq |$systemCommands|
  '(
@@ -901,12 +897,16 @@ See:\\
 
 @
 
-\defdollar{SYSCOMMANDS}
+\defdollar{syscommands}
 This table is used to look up a symbol to see if it might be a command.
 <<initvars>>=
-(defvar $SYSCOMMANDS nil)
+(defvar $syscommands nil)
+
+@
+
+<<postvars>>=
 (eval-when (eval load)
- (setq $SYSCOMMANDS (mapcar #'car |$systemCommands|)))
+ (setq $syscommands (mapcar #'car |$systemCommands|)))
 
 @
 \defdollar{noParseCommands}
@@ -930,6 +930,68 @@ all kinds of input that will not be acceptable to the interpreter.
     )))
 
 @
+\defun{handleNoParseCommands}
+The system commands given by the global variable
+\verb|$noParseCommands| require essentially no preprocessing/parsing
+of their arguments. Here we dispatch the functions which implement
+these commands.
+
+There are four standard commands which receive arguments
+\begin{itemize}
+\item boot
+\item lisp
+\item synonym 
+\item system
+\end{itemize}
+
+There are five standard commands
+which do not receive arguments -- 
+\begin{itemize}
+\item quit
+\item fin
+\item pquit
+\item credits
+\item copyright
+\end{itemize}
+
+As these commands do not necessarily
+exhaust those mentioned in \verb|$noParseCommands|, we provide a
+generic dispatch based on two conventions: commands which do not
+require an argument name themselves, those which do have their names
+prefixed by ``np''. This makes it possible to dynamically define
+new system commands provided you handle the argument parsing.
+
+<<defun handleNoParseCommands>>=
+(defun |handleNoParseCommands| (unab string)
+ (let (spaceindex funname)
+  (setq string (|stripSpaces| string))
+  (setq spaceindex (search " " string))
+  (cond
+   ((eq unab '|lisp|)
+    (if spaceindex
+     (|nplisp| (|stripLisp| string))
+     (|sayKeyedMsg| 's2iv0005 nil)))
+   ((eq unab '|boot|)
+    (if spaceindex
+     (|npboot| (subseq string (1+ spaceindex)))
+     (|sayKeyedMsg| 's2iv0005 nil)))
+   ((eq unab '|system|)
+    (if spaceindex
+      (|npsystem| unab string)
+      (|sayKeyedMsg| 's2iv0005 nil)))
+   ((eq unab '|synonym|)
+    (if spaceindex
+     (|npsynonym| unab (subseq string (1+ spaceindex)))
+     (|npsynonym| unab "")))
+   ((null spaceindex)
+    (funcall unab))
+   ((|member| unab '(|quit| |fin| |pquit| |credits| |copyright|))
+    (|sayKeyedMsg| 's2iv0005 nil))
+   (t
+    (setq funname (intern (concat "np" (string unab))))
+    (funcall funname (subseq string (1+ spaceindex)))))))
+
+@
 \defdollar{tokenCommands}
 This is a list of the commands that expect the interpreter to parse
 their arguments. Thus the history command expects that Axiom will have
@@ -1033,6 +1095,10 @@ above initial list of synonyms. The user synonyms that are added
 during a session are pushed onto this list for later lookup.
 <<initvars>>=
 (defvar |$CommandSynonymAlist| nil)
+
+@
+
+<<postvars>>=
 (eval-when (eval load)
  (setq |$CommandSynonymAlist| (copy-alist |$InitialCommandSynonymAlist|)))
 
@@ -1061,6 +1127,7 @@ for processing \verb|)read| of input files.
      n))))
 
 @
+
 \defun{ncloopPrefix?}
 If we find the prefix string in the whole string starting at position zero
 we return the remainder of the string without the leading prefix.
@@ -1070,6 +1137,37 @@ we return the remainder of the string without the leading prefix.
   (subseq whole (length prefix))))
 
 @
+
+\defun{selectOptionLC}
+<<defun selectOptionLC>>=
+(defun |selectOptionLC| (x l errorFunction)
+ (|selectOption| (downcase (|object2Identifier| x)) l errorFunction)) 
+
+@
+
+\defun{selectOption}
+<<defun selectOption>>=
+(defun |selectOption| (x l errorfunction)
+ (let (u y)
+  (cond
+   ((|member| x l) x)
+   ((null (identp x))
+    (cond
+     (errorfunction (funcall errorfunction x u))
+     (t nil)))
+   (t
+    (setq u
+     (let (t0)
+       (do ((t1 l (CDR t1)) (y NIL))
+           ((or (atom t1) (progn (setq y (car t1)) nil)) (nreverse0 t0))
+          (if (|stringPrefix?| (pname x) (pname y))
+             (setq t0 (cons y t0))))))
+    (cond
+     ((and (pairp u) (eq (qcdr u) nil) (progn (setq y (qcar u)) t)) y)
+     (errorfunction (funcall errorfunction x u))
+     (t nil))))))
+
+@
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{abbreviations}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@@ -1167,36 +1265,6 @@ constructor name {\tt VectorFunctions2} from the system:
 
 @
 \defun{abbreviationsSpad2Cmd}
-\begin{verbatim}
-;abbreviationsSpad2Cmd l ==
-;  null l => helpSpad2Cmd '(abbreviations)
-;  abopts := '(query domain category package remove)
-;  quiet := nil
-;  for [opt] in $options repeat
-;    opt := selectOptionLC(opt,'(quiet),'optionError)
-;    opt = 'quiet => quiet := true
-;  l is [opt,:al] =>
-;    key := opOf CAR al
-;    type := selectOptionLC(opt,abopts,'optionError)
-;    type is 'query =>
-;      null al => listConstructorAbbreviations()
-;      constructor := abbreviation?(key) => abbQuery(constructor)
-;      abbQuery(key)
-;    type is 'remove =>
-;      DELDATABASE(key,'ABBREVIATION)
-;    ODDP SIZE al => sayKeyedMsg("S2IZ0002",[type])
-;    repeat
-;      null al => return 'fromLoop
-;      [a,b,:al] := al
-;      mkUserConstructorAbbreviation(b,a,type)
-;      SETDATABASE(b,'ABBREVIATION,a)
-;      SETDATABASE(b,'CONSTRUCTORKIND,type)
-;    null quiet =>
-;      sayKeyedMsg("S2IZ0001",[a,type,opOf b])
-;      nil
-;  nil
-\end{verbatim}
-
 <<defun abbreviationsSpad2Cmd>>=
 (defun |abbreviationsSpad2Cmd| (arg)
  (let (abopts quiet opt key type constructor t2 a b al)
@@ -1211,22 +1279,16 @@ constructor name {\tt VectorFunctions2} from the system:
              (progn (setq t1 (car t0)) nil)
              (progn (progn (setq opt (car t1)) t1) nil))
           nil)
-     (seq
-      (exit
-       (progn
-        (setq opt
-         (|selectOptionLC| opt '(|quiet|) '|optionError|))
-        (cond ((eq opt '|quiet|)
-          (setq quiet t)))))))
-    (cond
-     ((and (pairp arg) 
+      (setq opt (|selectOptionLC| opt '(|quiet|) '|optionError|))
+      (when (eq opt '|quiet|) (setq quiet t)))
+    (when
+     (and (pairp arg) 
            (progn 
             (setq opt (qcar arg))
             (setq al (qcdr arg))
             t))
        (setq key (|opOf| (car al)))
-       (setq type
-         (|selectOptionLC| opt abopts '|optionError|))
+       (setq type (|selectOptionLC| opt abopts '|optionError|))
        (cond
         ((eq type '|query|)
          (cond 
@@ -1237,7 +1299,7 @@ constructor name {\tt VectorFunctions2} from the system:
         ((eq type '|remove|)
          (deldatabase key 'abbreviation))
         ((oddp (size al))
-         (|sayKeyedMsg| 's2iz0002 (cons type nil)))
+         (|sayKeyedMsg| 's2iz0002 (list type)))
         (t
          (do () (nil nil)
           (seq 
@@ -1252,11 +1314,8 @@ constructor name {\tt VectorFunctions2} from the system:
                (|mkUserConstructorAbbreviation| b a type)
                (setdatabase b 'abbreviation a)
                (setdatabase b 'constructorkind type))))))
-         (cond ((null quiet)
-          (progn
-           (|sayKeyedMsg| 's2iz0001
-             (cons a (cons type (cons (|opOf| b) nil)))) nil))))))
-     (t nil))))))
+         (unless quiet
+           (|sayKeyedMsg| 's2iz0001 (list a type (|opOf| b)))))))))))
 
 @
 
@@ -1658,6 +1717,12 @@ system function and constructor caches.
 \fnref{frame}, and
 \fnref{undo}
 
+\defdollar{clearOptions}
+<<initvars>>=
+(defvar |$clearOptions| '(|modes| |operations| |properties| |types| |values|))
+
+@
+
 \defun{clear}
 <<defun clear>>=
 (defun |clear| (l)
@@ -1687,9 +1752,8 @@ system function and constructor caches.
 
 <<defun clearSpad2Cmd>>=
 (defun |clearSpad2Cmd| (l)
-  (let (|$clearExcept| |opt| |optList| |arg|)
+  (let (|$clearExcept| opt optlist arg)
   (declare (special |$clearExcept| |$options| |$clearOptions|))
-  (setq |$clearExcept| nil)
   (cond 
    (|$options|
     (setq |$clearExcept|
@@ -1702,31 +1766,31 @@ system function and constructor caches.
            ((or t1 
                 (atom t2)
                 (progn (setq t3 (car t2)) nil)
-                (progn (progn (setq |opt| (car t3)) t3) nil))
+                (progn (progn (setq opt (car t3)) t3) nil))
               t0)
         (setq t0
          (and t0 
               (eq
-               (|selectOptionLC| |opt| '(|except|) '|optionError|)
+               (|selectOptionLC| opt '(|except|) '|optionError|)
                '|except|)))))))))
   (cond
    ((null l)
-     (setq |optList|
+     (setq optlist
       (prog (t4)
        (setq t4 nil)
        (return
         (do ((t5 |$clearOptions| (cdr t5)) (x nil))
             ((or (atom t5) (progn (setq x (car t5)) nil)) t4)
          (setq t4 (append t4 `(|%l| "       " ,x)))))))
-     (|sayKeyedMsg| 's2iz0010 (cons |optList| nil)))
+     (|sayKeyedMsg| 's2iz0010 (list optlist)))
    (t
-     (setq |arg|
+     (setq arg
       (|selectOptionLC| (car l) '(|all| |completely| |scaches|) nil))
      (cond
-      ((eq |arg| '|all|)        (|clearCmdAll|))
-      ((eq |arg| '|completely|) (|clearCmdCompletely|))
-      ((eq |arg| '|scaches|)    (|clearCmdSortedCaches|))
-      (|$clearExcept|           (|clearCmdExcept| l))
+      ((eq arg '|all|)        (|clearCmdAll|))
+      ((eq arg '|completely|) (|clearCmdCompletely|))
+      ((eq arg '|scaches|)    (|clearCmdSortedCaches|))
+      (|$clearExcept|         (|clearCmdExcept| l))
       (t 
        (|clearCmdParts| l)
        (|updateCurrentInterpreterFrame|))))))) 
@@ -3174,7 +3238,8 @@ All of the other options are just subcases.
 
 There is a slight mismatch between the \$displayOptions list of
 symbols and the options this command accepts so we have a cond
-branch to clean up the option variable.
+branch to clean up the option variable. This allows for the options
+to be plural.
 
 If we fall all the way thru we use the \$displayOptions list
 to construct a list of strings for the sayMessage function
@@ -3213,6 +3278,20 @@ and tell the user what options are available.
       (format nil "~%  or abbreviations thereof"))))))
 
 @
+
+\defun{abbQuery}
+<<defun abbQuery>>=
+(defun |abbQuery| (x)
+ (let (abb)
+  (cond
+   ((setq abb (getdatabase x 'abbreviation))
+    (|sayKeyedMsg| 's2iz0001 (list abb (getdatabase x 'constructorkind) x)))
+   ((setq abb (getdatabase x 'constructor))
+    (|sayKeyedMsg| 's2iz0001 (list x (getdatabase abb 'constructorkind) abb)))
+   (t
+     (|sayKeyedMsg| 's2iz0003 (list x))))))
+
+@
 \defun{displayOperations}
 This function takes a list of operation names. If the list is null
 we query the user to see if they want all operations printed. Otherwise
@@ -3479,6 +3558,38 @@ calls {\tt emacs} to edit the file.
 \fnref{compiler}, and
 \fnref{read}
 
+\defun{edit}
+<<defun edit>>=
+(defun |edit| (l) (|editSpad2Cmd| l)) 
+
+@
+
+\defun{editSpad2Cmd}
+<<defun editSpad2Cmd>>=
+(defun |editSpad2Cmd| (l)
+ (let (olddir filetypes ll rc)
+    (setq l (cond ((null l) /editfile) (t (car l))))
+    (setq l (|pathname| l))
+    (setq olddir (|pathnameDirectory| l))
+    (setq filetypes
+     (cond 
+      ((|pathnameType| l) (list (|pathnameType| l)))
+      ((eq |$UserLevel| '|interpreter|) '("input" "INPUT" "spad" "SPAD"))
+      ((eq |$UserLevel| '|compiler|) '("input" "INPUT" "spad" "SPAD"))
+      (t '("input" "INPUT" "spad" "SPAD" "boot" "BOOT" 
+           "lisp" "LISP" "meta" "META"))))
+    (setq ll
+     (cond
+      ((string= olddir "")
+        (|pathname| ($findfile (|pathnameName| l) filetypes)))
+      (t l)))
+    (setq l (|pathname| ll))
+    (setq /editfile l)
+    (setq rc (|editFile| l))
+    (|updateSourceFiles| l)
+    rc))
+
+@
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{fin}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@@ -7496,7 +7607,7 @@ explanations see the list structure section \ref{Theliststructure}.
  (dolist (setdata settree)
   (case (fourth setdata)
    (FUNCTION
-      (if (|functionp| (fifth setdata))
+      (if (functionp (fifth setdata))
         (funcall (fifth setdata) '|%initialize%|))
         (|sayMSG| "   Function not implemented."))
    (INTEGER (set (fifth setdata) (seventh setdata)))
@@ -7554,7 +7665,7 @@ explanations see the list structure section \ref{Theliststructure}.
     (case (fourth setdata)
      (FUNCTION
       (terpri)
-      (if (|functionp| (fifth setdata))
+      (if (functionp (fifth setdata))
         (funcall (fifth setdata) '|%describe%|)
         (|sayMSG| "   Function not implemented.")))
      (INTEGER
@@ -7612,7 +7723,7 @@ explanations see the list structure section \ref{Theliststructure}.
      (case (fourth setdata)
       (FUNCTION
        (setq opt
-        (if (|functionp| (fifth setdata))
+        (if (functionp (fifth setdata))
          (funcall (fifth setdata) '|%display%|)
          "unimplemented"))
        (cond
@@ -8706,6 +8817,57 @@ linker       linker arguments (e.g. libraries to search) -lxlf
            "/tmp/"))
          NIL)
 @
+
+\defun{setFortTmpDir}
+<<defun setFortTmpDir>>=
+(defun |setFortTmpDir| (arg)
+ (let (mode)
+   (cond
+    ((eq arg '|%initialize%|) (setq |$fortranTmpDir| "/tmp/"))
+    ((eq arg '|%display%|)
+     (if (stringp |$fortranTmpDir|)
+      |$fortranTmpDir|
+      (pname |$fortranTmpDir|)))
+    ((or (null arg) (eq arg '|%describe%|) (eq (car arg) '?))
+     (|describeSetFortTmpDir|))
+    ((null (setq mode (|validateOutputDirectory| arg)))
+     (|sayBrightly| 
+      `(" Sorry, but your argument(s)" ,@(|bright| arg) 
+            "is(are) not valid." |%l|))
+      (|describeSetFortTmpDir|))
+    (t (setq |$fortranTmpDir| mode)))))
+
+@
+
+\defun{validateOutputDirectory}
+<<defun validateOutputDirectory>>=
+(defun |validateOutputDirectory| (x)
+ (let ((dirname (car x)))
+  (when (and (pathname-directory dirname) (null (probe-file dirname)))
+   dirname)))
+
+@
+
+\defun{describeSetFortTmpDir}
+<<defun describeSetFortTmpDir>>=
+(defun |describeSetFortTmpDir| ()
+ (|sayBrightly| (list
+  '|%b| ")set fortran calling tempfile"
+  '|%d| " is used to tell AXIOM where"
+  '|%l| " to place intermediate FORTRAN data files . This must be the "
+  '|%l| " name of a valid existing directory to which you have permission "
+  '|%l| " to write (including the final slash)."
+  '|%l|
+  '|%l| " Syntax:"
+  '|%l| "   )set fortran calling tempfile DIRECTORYNAME"
+  '|%l|
+  '|%l| " The current setting is"
+  '|%b| |$fortranTmpDir|
+  '|%d|)))
+
+@
+
+
 \subsubsection{directory}
 \begin{verbatim}
 -------------------- The directory Option ---------------------
@@ -8735,6 +8897,47 @@ linker       linker arguments (e.g. libraries to search) -lxlf
            "./"))
          NIL)
 @
+
+\defun{setFortDir}
+<<defun setFortDir>>=
+(defun |setFortDir| (arg)
+ (declare (special |$fortranDirectory|))
+ (let (mode)
+   (COND
+    ((eq arg '|%initialize%|) (setq |$fortranDirectory| "./"))
+    ((eq arg '|%display%|)
+     (if (stringp |$fortranDirectory|) 
+      |$fortranDirectory|
+      (pname |$fortranDirectory|)))
+    ((or (null arg) (eq arg '|%describe%|) (eq (car arg) '?))
+      (|describeSetFortDir|))
+    ((null (setq mode (|validateOutputDirectory| arg)))
+     (|sayBrightly|
+      `(" Sorry, but your argument(s)" ,@(|bright| arg) 
+        "is(are) not valid." |%l|))
+     (|describeSetFortDir|))
+    (t (setq |$fortranDirectory| mode)))))
+
+@
+\defun{describeSetFortDir}
+<<defun describeSetFortDir>>=
+(defun |describeSetFortDir| ()
+ (declare (special |$fortranDirectory|))
+ (|sayBrightly| (list
+  '|%b| ")set fortran calling directory"
+  '|%d| " is used to tell AXIOM where"
+  '|%l| " to place generated FORTRAN files. This must be the name "
+  '|%l| " of a valid existing directory to which you have permission "
+  '|%l| " to write (including the final slash)."
+  '|%l|
+  '|%l| " Syntax:"
+  '|%l| "   )set fortran calling directory DIRECTORYNAME"
+  '|%l|
+  '|%l| " The current setting is"
+  '|%b| |$fortranDirectory|
+  '|%d|)))
+
+@
 \subsubsection{linker}
 \begin{verbatim}
 ---------------------- The linker Option ----------------------
@@ -8766,6 +8969,45 @@ linker       linker arguments (e.g. libraries to search) -lxlf
          NIL
          )
 @
+
+\defun{setLinkerArgs}
+<<defun setLinkerArgs>>=
+(defun |setLinkerArgs| (arg)
+ (declare (special |$fortranLibraries|))
+ (cond
+  ((eq arg '|%initialize%|) (setq |$fortranLibraries| "-lxlf"))
+  ((eq arg '|%display%|) (|object2String| |$fortranLibraries|))
+  ((or (null arg) (eq arg '|%describe%|) (eq (car arg) '?))
+    (|describeSetLinkerArgs|))
+  ((and (listp arg) (stringp (car arg)))
+    (setq |$fortranLibraries| (car arg)))
+  (t (|describeSetLinkerArgs|)))) 
+
+@
+
+\defun{describeSetLinkerArgs}
+<<defun describeSetLinkerArgs>>=
+(defun |describeSetLinkerArgs| ()
+ (declare (special |$fortranLibraries|))
+ (|sayBrightly| (list
+  '|%b| ")set fortran calling linkerargs"
+  '|%d| " is used to pass arguments to the linker"
+  '|%l| " when using "
+  '|%b| "mkFort"
+  '|%d| " to create functions which call Fortran code."
+  '|%l| " For example, it might give a list of libraries to be searched,"
+  '|%l| " and their locations."
+  '|%l| " The string is passed verbatim, so must be the correct syntax for"
+  '|%l| " the particular linker being used."
+  '|%l|
+  '|%l| " Example: )set fortran calling linker \"-lxlf\""
+  '|%l|
+  '|%l| " The current setting is"
+  '|%b| |$fortranLibraries|
+  '|%d|)))
+
+@
+
 \section{kernel}
 \begin{verbatim}
               Current Values of  kernel  Variables                    
@@ -10436,7 +10678,7 @@ prettyprint  prettyprint BOOT func's as they compile    off
 
 <<postvars>>=
 (eval-when (eval load)
- (|initializeSetVariables| |$setOptions|)
+ (|initializeSetVariables| |$setOptions|))
 
 @
 
@@ -10480,11 +10722,11 @@ which gets called with \verb|%describe%|
    ((null l) (|displaySetVariableSettings| settree '||))
    (t
     (setq |$setOptionNames|
-      (do ((t1 settree (cdr t1)) t0 (|x| nil))
-          ((or (atom t1) (progn (setq |x| (car t1)) nil)) (nreverse0 t0))
+      (do ((t1 settree (cdr t1)) t0 (x nil))
+          ((or (atom t1) (progn (setq x (car t1)) nil)) (nreverse0 t0))
        (seq
         (exit 
-         (setq t0 (cons (elt |x| 0) t0))))))
+         (setq t0 (cons (elt x 0) t0))))))
     (setq arg 
      (|selectOption| (downcase (car l)) |$setOptionNames| '|optionError|))
     (setq setdata (cons arg (lassoc arg settree)))
@@ -10500,7 +10742,7 @@ which gets called with \verb|%describe%|
          (if (eq (elt l 1) 'default) 
           '|%initialize%|
           (kdr l)))
-        (if (|functionp| (fifth setdata))
+        (if (functionp (fifth setdata))
           (funcall (fifth setdata) setfunarg)
           (|sayMSG| "   Function not implemented."))
         (when |$displaySetValue|
@@ -11208,7 +11450,7 @@ This reports the traced functions
 (defun |trace1| (arg)
  (prog (|$traceNoisely| constructor |ops| |lops| temp1 opt a 
         |oldL| |newOptions| |domain| |traceList| |optionList| |domainList| 
-        |opList| |y| |varList| |argument|)
+        |opList| y |varList| |argument|)
   (declare (special |$traceNoisely|))
   (return
    (seq
@@ -11327,8 +11569,8 @@ This reports the traced functions
                 (t nil)))
               (setq |varList|
                (cond
-                ((setq |y| (lassoc '|vars| |optionList|))
-                  (list (cons '|vars| |y|)))
+                ((setq y (lassoc '|vars| |optionList|))
+                  (list (cons '|vars| y)))
                 (t nil)))
               (append |domainList| (append |opList| |varList|)))))
          (|optionList| (append |traceList| |optionList|))
@@ -11534,59 +11776,59 @@ This reports the traced functions
 
 <<defun getTraceOption>>=
 (defun |getTraceOption| (arg)
- (prog (|l| |opts| key a |n|)
+ (prog (l |opts| key a |n|)
   (return
    (seq
     (progn
      (setq key (car arg))
-     (setq |l| (cdr arg))
+     (setq l (cdr arg))
      (setq key
        (|selectOptionLC| key |$traceOptionList| '|traceOptionError|))
-     (setq arg (cons key |l|))
+     (setq arg (cons key l))
      (cond
       ((memq key '(|nonquietly| |timer| |nt|)) arg)
       ((eq key '|break|)
        (cond
-        ((null |l|) (cons '|break| (cons '|before| nil)))
+        ((null l) (cons '|break| (cons '|before| nil)))
         (t
           (setq |opts|
            (prog (t0)
             (setq t0 nil)
             (return
-             (do ((t1 |l| (cdr t1)) (|y| nil))
+             (do ((t1 l (cdr t1)) (y nil))
                  ((or (atom t1)
-                      (progn (setq |y| (car t1)) nil))
+                      (progn (setq y (car t1)) nil))
                     (nreverse0 t0))
               (seq 
                (exit 
                 (setq t0 
                  (cons 
-                  (|selectOptionLC| |y| '(|before| |after|) nil) t0))))))))
+                  (|selectOptionLC| y '(|before| |after|) nil) t0))))))))
           (cond
            ((prog (t2)
              (setq t2 t)
              (return 
-              (do ((t3 nil (null t2)) (t4 |opts| (cdr t4)) (|y| nil))
-                  ((or t3 (atom t4) (progn (setq |y| (car t4)) nil)) t2)
+              (do ((t3 nil (null t2)) (t4 |opts| (cdr t4)) (y nil))
+                  ((or t3 (atom t4) (progn (setq y (car t4)) nil)) t2)
                  (seq
                   (exit
-                   (setq t2 (and t2 (identp |y|))))))))
+                   (setq t2 (and t2 (identp y))))))))
               (cons '|break| |opts|))
            (t
             (|stackTraceOptionError| (cons 's2it0008 (cons nil nil))))))))
       ((eq key '|restore|)
        (cond
-        ((null |l|) arg)
+        ((null l) arg)
         (t 
          (|stackTraceOptionError| 
           (cons 's2it0009 
            (cons (cons (strconc ")" (|object2String| key)) nil) nil))))))
-      ((eq key '|only|) (cons '|only| (|transOnlyOption| |l|)))
+      ((eq key '|only|) (cons '|only| (|transOnlyOption| l)))
       ((eq key '|within|)
         (cond
-         ((and (pairp |l|) 
-               (eq (qcdr |l|) nil)
-               (progn (setq a (qcar |l|)) t)
+         ((and (pairp l) 
+               (eq (qcdr l) nil)
+               (progn (setq a (qcar l)) t)
                (identp a))
            arg)
          (t 
@@ -11598,10 +11840,10 @@ This reports the traced functions
           ((eq key '|cond|) '|when|)
           (t key)))
         (cond
-         ((and (pairp |l|) 
-               (eq (qcdr |l|) nil)
-               (progn (setq a (qcar |l|)) t))
-            (cons key |l|))
+         ((and (pairp l) 
+               (eq (qcdr l) nil)
+               (progn (setq a (qcar l)) t))
+            (cons key l))
          (t 
           (|stackTraceOptionError|
            (cons 's2it0011
@@ -11610,9 +11852,9 @@ This reports the traced functions
               (|object2String| key)) nil) nil))))))
       ((eq key '|depth|)
         (cond 
-         ((and (pairp |l|) 
-               (eq (qcdr |l|) nil)
-               (progn (setq |n| (qcar |l|)) t)
+         ((and (pairp l) 
+               (eq (qcdr l) nil)
+               (progn (setq |n| (qcar l)) t)
                (fixp |n|))
            arg)
          (t 
@@ -11620,10 +11862,10 @@ This reports the traced functions
            (cons 's2it0012 (cons (cons ")depth" nil) nil))))))
       ((eq key '|count|)
         (cond 
-         ((or (null |l|) 
-              (and (pairp |l|) 
-                   (eq (qcdr |l|) nil)
-                   (progn (setq |n| (qcar |l|)) t)
+         ((or (null l) 
+              (and (pairp l) 
+                   (eq (qcdr l) nil)
+                   (progn (setq |n| (qcar l)) t)
                    (fixp |n|)))
             arg)
          (t 
@@ -11634,17 +11876,17 @@ This reports the traced functions
          (prog (t5)
           (setq t5 nil)
           (return
-           (do ((t6 |l| (cdr t6)) (|y| nil))
-               ((or (atom t6) (progn (setq |y| (car t6)) nil)) (nreverse0 t5))
+           (do ((t6 l (cdr t6)) (y nil))
+               ((or (atom t6) (progn (setq y (car t6)) nil)) (nreverse0 t5))
             (seq
              (exit
-              (setq t5 (cons (|getTraceOption,hn| |y|) t5)))))))))
+              (setq t5 (cons (|getTraceOption,hn| y) t5)))))))))
       ((memq key '(|local| |ops| |vars|))
         (cond
-         ((or (null |l|)
-              (and (pairp |l|) (eq (qcdr |l|) nil) (eq (qcar |l|) '|all|)))
+         ((or (null l)
+              (and (pairp l) (eq (qcdr l) nil) (eq (qcar l) '|all|)))
            (cons key '|all|))
-         ((|isListOfIdentifiersOrStrings| |l|) arg)
+         ((|isListOfIdentifiersOrStrings| l) arg)
          (t
            (|stackTraceOptionError|
             (cons 's2it0015
@@ -11652,10 +11894,10 @@ This reports the traced functions
               (cons (strconc ")" (|object2String| key)) nil) nil))))))
       ((eq key '|varbreak|)
         (cond
-         ((or (null |l|) 
-              (and (pairp |l|) (eq (qcdr |l|) nil) (eq (qcar |l|) '|all|)))
+         ((or (null l) 
+              (and (pairp l) (eq (qcdr l) nil) (eq (qcar l) '|all|)))
            (cons '|varbreak| '|all|))
-         ((|isListOfIdentifiers| |l|) arg)
+         ((|isListOfIdentifiers| l) arg)
          (t
            (|stackTraceOptionError|
             (cons 's2it0016
@@ -11663,7 +11905,7 @@ This reports the traced functions
               (cons (strconc ")" (|object2String| key)) nil) nil))))))
       ((eq key '|mathprint|)
         (cond
-         ((null |l|) arg)
+         ((null l) arg)
          (t
            (|stackTraceOptionError|
             (cons 's2it0009
@@ -11851,20 +12093,20 @@ This reports the traced functions
 
 <<defun transOnlyOption>>=
 (defun |transOnlyOption| (arg)
- (prog (|y| |n|)
+ (prog (y |n|)
   (return
    (cond
     ((and (pairp arg) 
-          (progn (setq |n| (qcar arg)) (setq |y| (qcdr arg)) t))
+          (progn (setq |n| (qcar arg)) (setq y (qcdr arg)) t))
       (cond
        ((fixp |n|)
-         (cons |n| (|transOnlyOption| |y|)))
+         (cons |n| (|transOnlyOption| y)))
        ((memq (setq |n| (upcase |n|)) '(V A C))
-         (cons |n| (|transOnlyOption| |y|)))
+         (cons |n| (|transOnlyOption| y)))
        (t 
          (|stackTraceOptionError|
            (cons 's2it0006 (cons (cons |n| nil) nil)))
-         (|transOnlyOption| |y|))))
+         (|transOnlyOption| y))))
     (t nil))))) 
 
 @
@@ -11915,17 +12157,17 @@ This reports the traced functions
 
 <<defun domainToGenvar>>=
 (defun |domainToGenvar| (arg)
- (prog (|$doNotAddEmptyModeIfTrue| |y| |g|)
+ (prog (|$doNotAddEmptyModeIfTrue| y |g|)
   (declare (special |$doNotAddEmptyModeIfTrue|))
   (return
    (progn
     (setq |$doNotAddEmptyModeIfTrue| t)
     (cond
-     ((and (setq |y| (|unabbrevAndLoad| arg))
-           (eq (getdatabase (|opOf| |y|) 'constructorkind) '|domain|))
+     ((and (setq y (|unabbrevAndLoad| arg))
+           (eq (getdatabase (|opOf| y) 'constructorkind) '|domain|))
        (progn
-        (setq |g| (|genDomainTraceName| |y|))
-        (set |g| (|evalDomain| |y|)) |g|))))))) 
+        (setq |g| (|genDomainTraceName| y))
+        (set |g| (|evalDomain| y)) |g|))))))) 
 
 @
 
@@ -12020,7 +12262,7 @@ This reports the traced functions
 
 <<defun transTraceItem>>=
 (defun |transTraceItem| (x)
- (prog (|$doNotAddEmptyModeIfTrue| |value| |y|)
+ (prog (|$doNotAddEmptyModeIfTrue| |value| y)
   (declare (special |$doNotAddEmptyModeIfTrue|))
   (return
    (progn
@@ -12033,18 +12275,18 @@ This reports the traced functions
                 '((|Mode|) (|Domain|) (|SubDomain| (|Domain|)))))
           (setq x (|objVal| |value|))
           (cond 
-           ((setq |y| (|domainToGenvar| x)) |y|)
+           ((setq y (|domainToGenvar| x)) y)
            (t x)))
         ((upper-case-p (elt (stringimage x) 0))
-          (setq |y| (|unabbrev| x))
+          (setq y (|unabbrev| x))
           (cond
-           ((|constructor?| |y|) |y|)
-           ((and (pairp |y|) (|constructor?| (car |y|))) (car |y|))
-           ((setq |y| (|domainToGenvar| x)) |y|)
+           ((|constructor?| y) y)
+           ((and (pairp y) (|constructor?| (car y))) (car y))
+           ((setq y (|domainToGenvar| x)) y)
            (t x)))
         (t x)))
      ((vecp (car x)) (|transTraceItem| (|devaluate| (car x))))
-     ((setq |y| (|domainToGenvar| x)) |y|)
+     ((setq y (|domainToGenvar| x)) y)
      (t (|throwKeyedMsg| 's2it0018 (cons x nil)))))))) 
 
 @
@@ -12217,16 +12459,16 @@ This reports the traced functions
 
 <<defun coerceTraceFunValue2E>>=
 (defun |coerceTraceFunValue2E| (|traceName| |subName| |value|)
- (prog (name |u|)
+ (prog (name u)
   (return
    (cond
     ((memq (setq name |subName|) |$mathTraceList|)
       (cond
        ((spadsysnamep (pname |traceName|)) (|coerceSpadFunValue2E| |value|))
-       ((setq |u| (lassoc |subName| |$tracedMapSignatures|))
+       ((setq u (lassoc |subName| |$tracedMapSignatures|))
          (|objValUnwrap|
           (|coerceInteractive|
-           (|objNewWrap| |value| (CAR |u|))
+           (|objNewWrap| |value| (CAR u))
              |$OutputForm|)))
        (t |value|)))
     (t |value|))))) 
@@ -12393,10 +12635,10 @@ This reports the traced functions
 
 <<defun lassocSub>>=
 (defun |lassocSub| (x |subs|)
- (prog (|y|) 
+ (prog (y) 
   (return 
    (cond 
-    ((setq |y| (lassq x |subs|)) |y|)
+    ((setq y (lassq x |subs|)) y)
     (t x))))) 
 
 @
@@ -12410,10 +12652,10 @@ This reports the traced functions
 
 <<defun rassocSub>>=
 (defun |rassocSub| (x |subs|)
- (prog (|y|)
+ (prog (y)
   (return
    (cond
-    ((setq |y| (|rassoc| x |subs|)) |y|)
+    ((setq y (|rassoc| x |subs|)) y)
     (t x))))) 
 
 @
@@ -12576,16 +12818,16 @@ This reports the traced functions
      (prog (t0)
       (setq t0 nil)
       (return
-       (do ((t1 ops (cdr t1)) (|u| nil))
-           ((or (atom t1) (progn (setq |u| (car t1)) nil)) (nreverse0 t0))
+       (do ((t1 ops (cdr t1)) (u nil))
+           ((or (atom t1) (progn (setq u (car t1)) nil)) (nreverse0 t0))
         (seq
          (exit
           (cond
-           ((and (pairp |u|)
+           ((and (pairp u)
                  (progn
-                  (setq tmp1 (qcar |u|))
+                  (setq tmp1 (qcar u))
                   (and (pairp tmp1) (equal (qcar tmp1) opname))))
-             (setq t0 (cons |u| t0)))))))))))))) 
+             (setq t0 (cons u t0)))))))))))))) 
 
 @
 
@@ -13171,25 +13413,25 @@ This reports the traced functions
 
 <<defun letPrint>>=
 (defun |letPrint| (x |val| |currentFunction|)
- (prog (|y|)
+ (prog (y)
   (return
    (progn
     (cond ((and |$letAssoc| 
                 (or
-                 (setq |y| (lassoc |currentFunction| |$letAssoc|))
-                 (setq |y| (lassoc '|all| |$letAssoc|))))
+                 (setq y (lassoc |currentFunction| |$letAssoc|))
+                 (setq y (lassoc '|all| |$letAssoc|))))
      (cond
-      ((and (or (eq |y| '|all|)
-                 (memq x |y|))
+      ((and (or (eq y '|all|)
+                 (memq x y))
             (null 
              (or (is_genvar x) (|isSharpVarWithNum| x) (gensymp x))))
         (|sayBrightlyNT| (append (|bright| x) (cons '|: | nil)))
         (prin0 (|shortenForPrinting| |val|))
         (terpri)))
      (cond
-      ((and (setq |y| (|hasPair| 'break |y|))
-            (or (eq |y| '|all|)
-                (and (memq x |y|)
+      ((and (setq y (|hasPair| 'break y))
+            (or (eq y '|all|)
+                (and (memq x y)
                      (null (memq (elt (pname x) 0) '($ |#|)))
                      (null (gensymp x)))))
        (|break|
@@ -13228,18 +13470,18 @@ This reports the traced functions
 
 <<defun letPrint2>>=
 (defun |letPrint2| (x |printform| |currentFunction|)
- (prog (|$BreakMode| |flag| |y|)
+ (prog (|$BreakMode| |flag| y)
   (declare (special |$BreakMode|))
   (return
    (progn
     (setq |$BreakMode| nil)
     (cond
      ((and |$letAssoc| 
-           (or (setq |y| (lassoc |currentFunction| |$letAssoc|))
-               (setq |y| (lassoc '|all| |$letAssoc|))))
+           (or (setq y (lassoc |currentFunction| |$letAssoc|))
+               (setq y (lassoc '|all| |$letAssoc|))))
       (cond
        ((and
-          (or (eq |y| '|all|) (memq x |y|))
+          (or (eq y '|all|) (memq x y))
           (null (or (is_genvar x) (|isSharpVarWithNum| x) (gensymp x))))
          (setq |$BreakMode| '|letPrint2|)
          (setq |flag| nil)
@@ -13250,10 +13492,10 @@ This reports the traced functions
           (t nil))))
       (cond 
        ((and 
-         (setq |y| (|hasPair| 'break |y|))
-         (or (eq |y| '|all|)
+         (setq y (|hasPair| 'break y))
+         (or (eq y '|all|)
              (and 
-              (memq x |y|)
+              (memq x y)
               (null (memq (elt (pname x) 0) '($ |#|)))
               (null (gensymp x)))))
         (|break|
@@ -13290,18 +13532,18 @@ This reports the traced functions
 
 <<defun letPrint3>>=
 (defun |letPrint3| (x |xval| |printfn| |currentFunction|)
- (prog (|$BreakMode| |flag| |y|)
+ (prog (|$BreakMode| |flag| y)
   (declare (special |$BreakMode|))
   (return
    (progn
     (setq |$BreakMode| nil)
     (cond
      ((and |$letAssoc| 
-       (or (setq |y| (lassoc |currentFunction| |$letAssoc|))
-           (setq |y| (lassoc '|all| |$letAssoc|))))
+       (or (setq y (lassoc |currentFunction| |$letAssoc|))
+           (setq y (lassoc '|all| |$letAssoc|))))
        (cond
         ((and
-           (or (eq |y| '|all|) (memq x |y|))
+           (or (eq y '|all|) (memq x y))
            (null (or (is_genvar x) (|isSharpVarWithNum| x) (gensymp x))))
           (setq |$BreakMode| '|letPrint2|)
           (setq |flag| nil)
@@ -13314,11 +13556,11 @@ This reports the traced functions
            (t nil))))
        (cond
         ((and
-          (setq |y| (|hasPair| 'break |y|))
+          (setq y (|hasPair| 'break y))
           (or
-           (eq |y| '|all|)
+           (eq y '|all|)
            (and
-            (memq x |y|)
+            (memq x y)
             (null (memq (elt (pname x) 0) '($ |#|)))
             (null (gensymp x)))))
           (|break|
@@ -13461,7 +13703,7 @@ This reports the traced functions
 
 <<defun reportSpadTrace>>=
 (defun |reportSpadTrace| (|header| t0)
- (prog (|op| |sig| |n| |t| |msg| |namePart| |y| |tracePart|)
+ (prog (|op| |sig| |n| |t| |msg| |namePart| y |tracePart|)
   (return 
    (progn
     (setq |op| (car t0))
@@ -13485,11 +13727,11 @@ This reports the traced functions
       (setq |namePart| nil)
       (setq |tracePart|
        (cond
-        ((and (pairp |t|) (progn (setq |y| (qcar |t|)) t) (null (null |y|)))
+        ((and (pairp |t|) (progn (setq y (qcar |t|)) t) (null (null y)))
           (cond
-           ((eq |y| '|all|)
+           ((eq y '|all|)
              (cons '|%b| (cons '|all| (cons '|%d| (cons '|vars| nil)))))
-           (t (cons '| vars: | (cons |y| nil)))))
+           (t (cons '| vars: | (cons y nil)))))
         (t nil)))
       (|sayBrightly| (append |msg| (append |namePart| |tracePart|))))))))) 
 
@@ -13921,7 +14163,7 @@ This reports the traced functions
 
 <<defun ?t>>=
 (defun |?t| ()
- (prog (|llm| x |d| |l| |suffix|)
+ (prog (|llm| x |d| l |suffix|)
   (return
    (seq
     (cond
@@ -13948,7 +14190,7 @@ This reports the traced functions
         (exit
          (cond
           ((and (pairp x) 
-                (progn (setq |d| (qcar x)) (setq |l| (qcdr x)) t)
+                (progn (setq |d| (qcar x)) (setq l (qcdr x)) t)
                 (|isDomainOrPackage| |d|))
            (progn
             (setq |suffix| (cond ((|isDomain| |d|) "domain") (t "package")))
@@ -13959,7 +14201,7 @@ This reports the traced functions
                 (cons (|devaluate| |d|) 
                  (cons '|%d| 
                   (cons ":" nil)))))))
-            (do ((t2 (|orderBySlotNumber| |l|) (cdr t2)) (x nil))
+            (do ((t2 (|orderBySlotNumber| l) (cdr t2)) (x nil))
                 ((or (atom t2) (progn (setq x (car t2)) nil)) nil)
               (seq
                (exit
@@ -13990,7 +14232,7 @@ This reports the traced functions
 
 <<defun tracelet>>=
 (defun |tracelet| (|fn| |vars|)
- (prog ($traceletflag |$QuickLet| |l|)
+ (prog ($traceletflag |$QuickLet| l)
   (declare (special $traceletflag |$QuickLet|))
   (return
    (progn
@@ -14006,7 +14248,7 @@ This reports the traced functions
        (setq |vars|
          (cond
           ((eq |vars| '|all|) '|all|)
-          ((setq |l| (lassoc |fn| |$letAssoc|)) (|union| |vars| |l|))
+          ((setq l (lassoc |fn| |$letAssoc|)) (|union| |vars| l))
           (t |vars|)))
        (setq |$letAssoc| (cons (cons |fn| |vars|) |$letAssoc|))
        (cond (|$letAssoc| (setletprintflag t)))
@@ -14357,13 +14599,13 @@ recordFrame(systemNormal) ==
                 (prog (tmp2)
                  (setq tmp2 nil)
                  (return
-                  (do ((tmp3 (cdr x) (cdr tmp3)) (|y| nil))
+                  (do ((tmp3 (cdr x) (cdr tmp3)) (y nil))
                       ((or (atom tmp3) 
-                           (progn (setq |y| (car tmp3)) nil))
+                           (progn (setq y (car tmp3)) nil))
                         (nreverse0 tmp2))
                    (seq
                     (exit
-                     (setq tmp2 (cons (cons (car |y|) (cdr |y|)) tmp2))))))))
+                     (setq tmp2 (cons (cons (car y) (cdr y)) tmp2))))))))
                 tmp0))))))))
        (car |$frameRecord|))))))) 
 
@@ -15053,6 +15295,13 @@ The command synonym  {\tt )apropos} is equivalent to
 \fnref{set}, and
 \fnref{show}
 
+\defdollar{whatOptions}
+<<initvars>>=
+(defvar |$whatOptions| '(|operations| |categories| |domains| |packages| 
+                         |commands| |synonyms| |things|))
+
+@
+
 \defun{what}
 \begin{verbatim}
 what l == whatSpad2Cmd l
@@ -15175,17 +15424,17 @@ filterAndFormatConstructors(constrType,label,patterns) ==
 
 <<defun filterAndFormatConstructors>>=
 (defun |filterAndFormatConstructors| (|constrType| |label| |patterns|)
- (prog (|l|)
+ (prog (l)
   (return
    (progn (|centerAndHighlight| |label| $linelength 
            (|specialChar| '|hbar|))
-    (setq |l|
+    (setq l
      (|filterListOfStringsWithFn| |patterns|
        (|whatConstructors| |constrType|)
        (|function| cdr)))
     (cond (|patterns|
      (cond
-      ((null |l|)
+      ((null l)
        (|sayMessage|
         (cons "   No "
          (cons |label|
@@ -15204,7 +15453,7 @@ filterAndFormatConstructors(constrType,label,patterns) ==
              (cons '|%b|
               (append (|blankList| |patterns|)
                (cons '|%d| nil))))))))))))
-    (cond (|l| (|pp2Cols| |l|)))))))
+    (cond (l (|pp2Cols| l)))))))
 
 @ 
 
@@ -15695,13 +15944,131 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 
 @
 
+\chapter{Special Lisp Functions}
+
+\defmacro{identp}
+<<defmacro identp>>=
+(defmacro identp (x) 
+ (if (atom x)
+  `(and ,x (symbolp ,x))
+   (let ((xx (gensym)))
+    `(let ((,xx ,x))
+      (and ,xx (symbolp ,xx))))))
+
+@
+
+\defun{concat}
+<<defun concat>>=
+(defun concat (a b &rest l)
+ (if (bit-vector-p a)
+   (if l 
+     (apply #'concatenate 'bit-vector a b l)
+     (concatenate 'bit-vector a b))
+   (if l 
+     (apply #'system:string-concatenate a b l)
+     (system:string-concatenate a b))))
+
+@
+
+\defun{functionp}
+<<defun functionp>>=
+(defun |functionp| (fn)
+ (if (identp fn)
+  (and (fboundp fn) (not (macro-function fn)))
+  (functionp fn)))
+
+@
+
+;; --------------------> NEW DEFINITION (override in msgdb.boot.pamphlet)
+\defun{brightprint}
+<<defun brightprint>>=
+(defun brightprint (x)
+ (messageprint x))
+
+@
+ 
+;; --------------------> NEW DEFINITION (override in msgdb.boot.pamphlet)
+\defun{brightprint-0}
+<<defun brightprint-0>>=
+(defun brightprint-0 (x)
+ (messageprint-1 x))
+ 
+@
+
+\defun{member}
+<<defun member>>=
+(defun |member| (item sequence)
+ (cond
+   ((symbolp item) (member item sequence :test #'eq))
+   ((stringp item) (member item sequence :test #'equal))
+   ((and (atom item) (not (arrayp item))) (member item sequence))
+   (t (member item sequence :test #'equalp))))
+
+@
+
+\defun{messageprint}
+<<defun messageprint>>=
+(defun messageprint (x)
+ (mapc #'messageprint-1 x))
+ 
+@
+
+\defun{messageprint-1}
+<<defun messageprint-1>>=
+(defun messageprint-1 (x)
+ (cond
+  ((or (eq x '|%l|) (equal x "%l")) (terpri))
+  ((stringp x) (princ x))
+  ((identp x) (princ x))
+  ((atom x) (princ x))
+  ((princ "(") 
+   (messageprint-1 (car x))
+   (messageprint-2 (cdr x))
+   (princ ")"))))
+
+@
+
+\defun{messageprint-2}
+<<defun messageprint-2>>=
+(defun messageprint-2 (x)
+  (if (atom x)
+   (unless x (progn (princ " . ") (messageprint-1 x)))
+   (progn (princ " ") (messageprint-1 (car x)) (messageprint-2 (cdr x)))))
+
+@
+ 
+\defun{sayBrightly1}
+<<defun sayBrightly1>>=
+(defun sayBrightly1 (x *standard-output*)
+  (if (atom x)
+   (progn (brightprint-0 x) (terpri) (force-output))
+   (progn (brightprint   x) (terpri) (force-output))))
+
+@
+ 
+\defdollar{algebraOutputStream}
+<<initvars>>=
+(defvar |$algebraOutputStream| *standard-output*)
+ 
+@
+
+\defun{sayMSG}
+<<defun sayMSG>>=
+(defun |sayMSG| (x)
+ (declare (special |$algebraOutputStream|))
+ (when x (sayBrightly1 x |$algebraOutputStream|)))
+
+@
+ 
 \chapter{The Interpreter}
 <<Interpreter>>=
 (in-package "BOOT")
 <<initvars>>
 
 <<defmacro funfind>>
+<<defmacro identp>>
 
+<<defun abbQuery>>
 <<defun abbreviations>>
 <<defun abbreviationsSpad2Cmd>>
 <<defun addInputLibrary>>
@@ -15712,6 +16079,8 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 
 <<defun break>>
 <<defun breaklet>>
+<<defun brightprint>>
+<<defun brightprint-0>>
 <<defun browse>>
 
 <<defun changeHistListLen>>
@@ -15739,6 +16108,7 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun compileBoot>>
 <<defun compiler>>
 <<defun compileSpadLispCmd>>
+<<defun concat>>
 <<defun copyright>>
 <<defun createCurrentInterpreterFrame>>
 <<defun credits>>
@@ -15746,6 +16116,9 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun describeAsharpArgs>>
 <<defun describeInputLibraryArgs>>
 <<defun describeOutputLibraryArgs>>
+<<defun describeSetFortDir>>
+<<defun describeSetFortTmpDir>>
+<<defun describeSetLinkerArgs>>
 <<defun dewritify>>
 <<defun dewritify,dewritifyInner>>
 <<defun dewritify,is?>>
@@ -15764,6 +16137,8 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun domainToGenvar>>
 <<defun dropInputLibrary>>
 
+<<defun edit>>
+<<defun editSpad2Cmd>>
 <<defun emptyInterpreterFrame>>
 
 <<defun fetchOutput>>
@@ -15784,6 +16159,7 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun frameName>>
 <<defun frameNames>>
 <<defun frameSpad2Cmd>>
+<<defun functionp>>
 <<defun funfind,LAM>>
 
 <<defun genDomainTraceName>>
@@ -15799,6 +16175,7 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun getTraceOption,hn>>
 <<defun getTraceOptions>>
 
+<<defun handleNoParseCommands>>
 <<defun hasPair>>
 <<defun help>>
 <<defun helpSpad2Cmd>>
@@ -15840,6 +16217,10 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun makeHistFileName>>
 <<defun makeInitialModemapFrame>>
 <<defun mapLetPrint>>
+<<defun member>>
+<<defun messageprint>>
+<<defun messageprint-1>>
+<<defun messageprint-2>>
 
 <<defun ncIntLoop>>
 <<defun ncloopCommand>>
@@ -15897,8 +16278,12 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun safeWritify>>
 <<defun saveHistory>>
 <<defun saveMapSig>>
+<<defun sayBrightly1>>
 <<defun sayExample>>
+<<defun sayMSG>>
 <<defun ScanOrPairVec>>
+<<defun selectOption>>
+<<defun selectOptionLC>>
 <<defun set>>
 <<defun set1>>
 <<defun setAsharpArgs>>
@@ -15910,8 +16295,11 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun setExposeDrop>>
 <<defun setExposeDropConstr>>
 <<defun setExposeDropGroup>>
+<<defun setFortDir>>
+<<defun setFortTmpDir>>
 <<defun setHistoryCore>>
 <<defun setInputLibrary>>
+<<defun setLinkerArgs>>
 <<defun setIOindex>>
 <<defun setOutputLibrary>>
 <<defun set-restart-hook>>
@@ -15974,6 +16362,8 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun updateHist>>
 <<defun updateInCoreHist>>
 
+<<defun validateOutputDirectory>>
+
 <<defun what>>
 <<defun whatConstructors>>
 <<defun whatSpad2Cmd>>
@@ -15995,6 +16385,8 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun zsystemdevelopment1>>
 <<defun zsystemDevelopmentSpad2Cmd>>
 
+<<postvars>>
+
 @
 \chapter{The Global Variables}
 \section{Star Global Variables}
diff --git a/changelog b/changelog
index 5c3e7c9..4f0404f 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,13 @@
+20090319 tpd src/axiom-website/patches.html 20090319.01.tpd.patch
+20090319 tpd src/interp/vmlisp.lisp move top level cmd handling
+20090319 tpd src/interp/setvars.boot move top level cmd handling
+20090319 tpd src/interp/macros.lisp move top level cmd handling
+20090319 tpd src/interp/intint.lisp move top level cmd handling
+20090319 tpd src/interp/i-syscmd.boot move top level cmd handling
+20090319 tpd src/interp/g-cndata.boot move top level cmd handling
+20090319 tpd src/interp/bootfuns.lisp move top level cmd handling
+20090319 tpd src/input/unittest1.input move top level cmd handling
+20090319 tpd books/bookvol5 move top level cmd handling
 20090317 tpd src/axiom-website/patches.html 20090317.01.tpd.patch
 20090317 tpd books/bookvol5 rewrite generated lisp into readable form
 20090316 tpd src/axiom-website/patches.html 20090316.02.tpd.patch
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index 74c25dd..acb665a 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -1011,5 +1011,7 @@ bookvol5 add )expose, add )set break resume<br/>
 sockio.lisp restore sock-send-int<br/>
 <a href="patches/20090317.01.tpd.patch">20090317.01.tpd.patch</a>
 bookvol5 rewrite generated lisp into readable form<br/>
+<a href="patches/20090319.01.tpd.patch">20090319.01.tpd.patch</a>
+bookvol5 move top level command handling<br/>
  </body>
 </html>
diff --git a/src/input/unittest1.input.pamphlet b/src/input/unittest1.input.pamphlet
index de5d841..c5d0dfa 100644
--- a/src/input/unittest1.input.pamphlet
+++ b/src/input/unittest1.input.pamphlet
@@ -17,12 +17,12 @@ Unit test the user level commands
 )set mes auto off
 )clear all
 
---S 1 of 47
+--S 1 of 70
 )with API
 --R   )library cannot find the file API.
 --E 1
 
---S 2 of 47
+--S 2 of 70
 )apropos matrix
 --R
 --ROperations whose names satisfy the above pattern(s):
@@ -93,7 +93,7 @@ Unit test the user level commands
 --R
 --E 2
 
---S 3 of 47
+--S 3 of 70
 )what categories set
 --R 
 --R------------------------------- Categories --------------------------------
@@ -112,7 +112,7 @@ Unit test the user level commands
 --R TSETCAT  TriangularSetCategory
 --E 3
 
---S 4 of 47
+--S 4 of 70
 )what commands set
 --R 
 --R--------------- System Commands for User Level: development ---------------
@@ -124,7 +124,7 @@ Unit test the user level commands
 --R 
 --E 4
 
---S 5 of 47
+--S 5 of 70
 )what domains set
 --R 
 --R--------------------------------- Domains ---------------------------------
@@ -147,7 +147,7 @@ Unit test the user level commands
 --R WUTSET   WuWenTsunTriangularSet
 --E 5
 
---S 6 of 47
+--S 6 of 70
 )what operations set
 --R 
 --R
@@ -251,7 +251,7 @@ Unit test the user level commands
 --R      issue the command )display op ruleset 
 --E 6
 
---S 7 of 47
+--S 7 of 70
 )what packages set
 --R 
 --R-------------------------------- Packages ---------------------------------
@@ -268,7 +268,7 @@ Unit test the user level commands
 --R SRDCMPK  SquareFreeRegularSetDecompositionPackage
 --E 7
 
---S 8 of 47
+--S 8 of 70
 )what synonym set
 --R 
 --R------------------------- System Command Synonyms -------------------------
@@ -278,7 +278,7 @@ Unit test the user level commands
 --R
 --E 8
 
---S 9 of 47
+--S 9 of 70
 )what things set
 --R 
 --R
@@ -438,7 +438,7 @@ Unit test the user level commands
 --R
 --E 9
 
---S 10 of 47
+--S 10 of 70
 )apropos set
 --R 
 --R
@@ -598,7 +598,7 @@ Unit test the user level commands
 --R
 --E 10
 
---S 11 of 47
+--S 11 of 70
 )prompt
 --R---------------------------- The prompt Option ----------------------------
 --R
@@ -616,13 +616,13 @@ Unit test the user level commands
 --R
 --E 11
 
---S 12 of 47
+--S 12 of 70
 )version
 --R 
 --IValue = "Saturday February 21, 2009 at 17:59:27 "
 --E 12
 
---S 13 of 47
+--S 13 of 70
 )zsys )from )c
 --R 
 --R 
@@ -633,7 +633,7 @@ Unit test the user level commands
 --R
 --E 13
 
---S 14 of 47
+--S 14 of 70
 )zsys )from )d
 --R 
 --R 
@@ -644,7 +644,7 @@ Unit test the user level commands
 --R
 --E 14
 
---S 15 of 47
+--S 15 of 70
 )zsys )from )dt
 --R 
 --R 
@@ -655,7 +655,7 @@ Unit test the user level commands
 --R
 --E 15
 
---S 16 of 47
+--S 16 of 70
 )zsys )from )ct
 --R 
 --R 
@@ -666,7 +666,7 @@ Unit test the user level commands
 --R
 --E 16
 
---S 17 of 47
+--S 17 of 70
 )zsys )from )ctl
 --R 
 --R 
@@ -677,7 +677,7 @@ Unit test the user level commands
 --R
 --E 17
 
---S 18 of 47
+--S 18 of 70
 )zsys )from )ec
 --R 
 --R 
@@ -688,7 +688,7 @@ Unit test the user level commands
 --R
 --E 18
 
---S 19 of 47
+--S 19 of 70
 )zsys )from )ect
 --R 
 --R 
@@ -699,7 +699,7 @@ Unit test the user level commands
 --R
 --E 19
 
---S 20 of 47
+--S 20 of 70
 )zsys )from )e
 --R 
 --R 
@@ -710,12 +710,12 @@ Unit test the user level commands
 --R
 --E 20
 
---S 21 of 47
+--S 21 of 70
 )zsys )from )version
 --R 
 --E 21
 
---S 22 of 47
+--S 22 of 70
 )zsys )from )update
 --R 
 --R 
@@ -726,7 +726,7 @@ Unit test the user level commands
 --R
 --E 22
 
---S 23 of 47
+--S 23 of 70
 )zsys )from )patch
 --R 
 --R 
@@ -737,7 +737,7 @@ Unit test the user level commands
 --R
 --E 23
 
---S 24 of 47
+--S 24 of 70
 )zsys )from )there 1
 --R 
 --R
@@ -746,24 +746,24 @@ Unit test the user level commands
 --R
 --E 24
 
---S 25 of 47
+--S 25 of 70
 )zsys )from )compare
 --R 
 --R   An argument is required for compare 
 --E 25
 
---S 26 of 47
+--S 26 of 70
 )zsys )from )record
 --R 
 --R   An argument is required for record 
 --E 26
 
---S 27 of 47
+--S 27 of 70
 )summary
 --R 
 --E 27
 
---S 28 of 47
+--S 28 of 70
 --R)credits
 --RAn alphabetical listing of contributors to AXIOM:
 --RCyril Alberga          Roy Adler              Christian Aistleitner
@@ -848,7 +848,7 @@ Unit test the user level commands
 --RBruno Zuercher         Dan Zwillinger
 --E 28
 
---S 29 of 47
+--S 29 of 70
 )set expose
 --R---------------------------- The expose Option ----------------------------
 --R
@@ -879,7 +879,7 @@ Unit test the user level commands
 --R      for more information.
 --E 29
 
---S 30 of 47
+--S 30 of 70
 )set expose add
 --R----------------------------- The add Option ------------------------------
 --R   The following groups are explicitly exposed in the current frame 
@@ -903,7 +903,7 @@ Unit test the user level commands
 --R      for more information.
 --E 30
 
---S 31 of 47
+--S 31 of 70
 )set expose drop
 --R----------------------------- The drop Option -----------------------------
 --R   The following constructors are explicitly hidden in the current 
@@ -920,7 +920,7 @@ Unit test the user level commands
 --R      for more information.
 --E 31
 
---S 32 of 47
+--S 32 of 70
 )set expose add group
 --R---------------------------- The group Option -----------------------------
 --R   The following groups are explicitly exposed in the current frame 
@@ -941,7 +941,7 @@ Unit test the user level commands
 --Rdefaults      
 --E 32
 
---S 33 of 47
+--S 33 of 70
 )set expose add constructor
 --R------------------------- The constructor Option --------------------------
 --R   The following constructors are explicitly exposed in the current 
@@ -949,7 +949,7 @@ Unit test the user level commands
 --R               there are no explicitly exposed constructors                
 --E 33
 
---S 34 of 47
+--S 34 of 70
 )set expose drop group
 --R---------------------------- The group Option -----------------------------
 --R   When followed by one or more exposure group names, this option 
@@ -964,7 +964,7 @@ Unit test the user level commands
 --R                                   anna                                    
 --E 34
 
---S 35 of 47
+--S 35 of 70
 )set expose drop constructor
 --R------------------------- The constructor Option --------------------------
 --R   When followed by one or more constructor names, this option allows 
@@ -979,7 +979,7 @@ Unit test the user level commands
 --R                there are no explicitly hidden constructors                
 --E 35
 
---S 36 of 47
+--S 36 of 70
 )show SQMATRIX
 --R SquareMatrix(ndim: NonNegativeInteger,R: Ring)  is a domain constructor
 --R Abbreviation for SquareMatrix is SQMATRIX 
@@ -1078,12 +1078,12 @@ Unit test the user level commands
 --R
 --E 36
 
---S 37 of 47
+--S 37 of 70
 )set expose add constructor SQMATRIX
 --I   SquareMatrix is now explicitly exposed in frame frame0 
 --E 37
 
---S 38 of 47
+--S 38 of 70
 )show SQMATRIX
 --R SquareMatrix(ndim: NonNegativeInteger,R: Ring)  is a domain constructor
 --R Abbreviation for SquareMatrix is SQMATRIX 
@@ -1182,7 +1182,7 @@ Unit test the user level commands
 --R
 --E 38
 
---S 39 of 47
+--S 39 of 70
 )set expose add
 --R----------------------------- The add Option ------------------------------
 --R   The following groups are explicitly exposed in the current frame 
@@ -1206,12 +1206,12 @@ Unit test the user level commands
 --R      for more information.
 --E 39
 
---S 40 of 47
+--S 40 of 70
 )set expose drop constructor SQMATRIX
 --I   SquareMatrix is now explicitly hidden in frame frame0 
 --E 40
 
---S 41 of 47
+--S 41 of 70
 )show SQMATRIX
 --R SquareMatrix(ndim: NonNegativeInteger,R: Ring)  is a domain constructor
 --R Abbreviation for SquareMatrix is SQMATRIX 
@@ -1310,7 +1310,7 @@ Unit test the user level commands
 --R
 --E 41
 
---S 42 of 47
+--S 42 of 70
 )set expose
 --R---------------------------- The expose Option ----------------------------
 --R
@@ -1341,12 +1341,12 @@ Unit test the user level commands
 --R      for more information.
 --E 42
 
---S 43 of 47
+--S 43 of 70
 )set expose drop group anna
 --I   anna is no longer an exposure group for frame frame0 
 --E 43
 
---S 44 of 47
+--S 44 of 70
 )set expose
 --R---------------------------- The expose Option ----------------------------
 --R
@@ -1376,7 +1376,7 @@ Unit test the user level commands
 --R      for more information.
 --E 44
 
---S 45 of 47
+--S 45 of 70
 )set expose add group
 --R---------------------------- The group Option -----------------------------
 --R   The following groups are explicitly exposed in the current frame 
@@ -1396,12 +1396,12 @@ Unit test the user level commands
 --Rdefaults      
 --E 45
 
---S 46 of 47
+--S 46 of 70
 )set expose add group anna
 --I   anna is now an exposure group for frame frame0 
 --E 46
 
---S 47 of 47
+--S 47 of 70
 )set expose
 --R---------------------------- The expose Option ----------------------------
 --R
@@ -1432,6 +1432,301 @@ Unit test the user level commands
 --R      for more information.
 --E 47
 
+--S 48 of 70
+)display
+
+  )display keyword arguments are
+     abbreviations
+     all
+     macros
+     modes
+     names
+     operations
+     properties
+     types
+     values
+  or abbreviations thereof
+
+--E 48
+
+--S 49 of 70
+)display abb
+   You have requested that all abbreviations be displayed. As there are
+      several hundred abbreviations, please confirm your request by 
+      typing y or yes and then pressing Enter :
+n
+   Since you did not respond with y or yes the list of abbreviations 
+      will not be displayed.
+--E 49
+
+--S 50 of 70
+)display all
+Properties of %e :
+   This is a system-defined macro.
+   macro %e () == exp(1)
+Properties of %i :
+   This is a system-defined macro.
+   macro %i () == complex(0,1)
+Properties of %infinity :
+   This is a system-defined macro.
+   macro %infinity () == infinity()
+Properties of %minusInfinity :
+   This is a system-defined macro.
+   macro %minusInfinity () == minusInfinity()
+Properties of %pi :
+   This is a system-defined macro.
+   macro %pi () == pi()
+Properties of %plusInfinity :
+   This is a system-defined macro.
+   macro %plusInfinity () == plusInfinity()
+Properties of SF :
+   This is a system-defined macro.
+   macro SF () == DoubleFloat()
+--E 50
+
+--S 51 of 70
+)display macros
+
+System-defined macros:
+   macro %e () == exp(1)
+   macro %i () == complex(0,1)
+   macro %infinity () == infinity()
+   macro %minusInfinity () == minusInfinity()
+   macro %pi () == pi()
+   macro %plusInfinity () == plusInfinity()
+   macro SF () == DoubleFloat()
+--E 51
+
+--S 52 of 70
+)display modes
+   Type of value of %e:  (none)
+   Type of value of %i:  (none)
+   Type of value of %infinity:  (none)
+   Type of value of %minusInfinity:  (none)
+   Type of value of %pi:  (none)
+   Type of value of %plusInfinity:  (none)
+   Type of value of SF:  (none)
+--E 52
+
+--S 53 of 70
+)display names
+
+Names of User-Defined Objects in the Workspace:
+
+   * None *
+
+Names of System-Defined Objects in the Workspace:
+
+%e                %i                %infinity         %minusInfinity    
+%pi               %plusInfinity     SF                
+--E 53
+
+--S 54 of 70
+)display operations
+   You have requested that all information about all AXIOM operations 
+      (functions) be displayed. As there are several hundred 
+      operations, please confirm your request by typing y or yes and 
+      then pressing Enter :
+n
+   Since you did not respond with y or yes the list of operations will 
+      not be displayed.
+--E 54
+
+--S 55 of 70
+)display properties
+Properties of %e :
+   This is a system-defined macro.
+   macro %e () == exp(1)
+Properties of %i :
+   This is a system-defined macro.
+   macro %i () == complex(0,1)
+Properties of %infinity :
+   This is a system-defined macro.
+   macro %infinity () == infinity()
+Properties of %minusInfinity :
+   This is a system-defined macro.
+   macro %minusInfinity () == minusInfinity()
+Properties of %pi :
+   This is a system-defined macro.
+   macro %pi () == pi()
+Properties of %plusInfinity :
+   This is a system-defined macro.
+   macro %plusInfinity () == plusInfinity()
+Properties of SF :
+   This is a system-defined macro.
+   macro SF () == DoubleFloat()
+--E 55
+
+--S 56 of 70
+)display types
+   Type of value of %e:  (none)
+   Type of value of %i:  (none)
+   Type of value of %infinity:  (none)
+   Type of value of %minusInfinity:  (none)
+   Type of value of %pi:  (none)
+   Type of value of %plusInfinity:  (none)
+   Type of value of SF:  (none)
+--E 56
+
+--S 57 of 70
+)display values
+   Value of %e:  (none)
+   Value of %i:  (none)
+   Value of %infinity:  (none)
+   Value of %minusInfinity:  (none)
+   Value of %pi:  (none)
+   Value of %plusInfinity:  (none)
+   Value of SF:  (none)
+--E 57
+
+--S 58 of 70
+)display abb DHMATRIX
+   DHMATRIX abbreviates domain DenavitHartenbergMatrix 
+--E 58
+
+--S 59 of 70
+)display abb DenavitHartenbergMatrix
+   DHMATRIX abbreviates domain DenavitHartenbergMatrix 
+--E 59
+
+--S 60 of 70
+)display operations rotatex
+
+There is one exposed function called rotatex :
+   [1] D1 -> DenavitHartenbergMatrix D1 from DenavitHartenbergMatrix D1
+            if D1 has Join(Field,TranscendentalFunctionCategory)
+
+Examples of rotatex from DenavitHartenbergMatrix
+
+--E 60
+
+--S 61 of 70
+)set fortran calling
+                   Current Values of  calling  Variables                   
+
+Variable     Description                                Current Value
+-----------------------------------------------------------------------------
+tempfile     set location of temporary data files       /tmp/ 
+directory    set location of generated FORTRAN files    ./ 
+linker       linker arguments (e.g. libraries to search) -lxlf 
+
+--E 61
+
+--S 62 of 70
+)set fortran calling tempfile
+--------------------------- The tempfile Option ---------------------------
+
+ Description: set location of temporary data files
+
+ )set fortran calling tempfile  is used to tell AXIOM where
+ to place intermediate FORTRAN data files . This must be the 
+ name of a valid existing directory to which you have permission 
+ to write (including the final slash).
+
+ Syntax:
+   )set fortran calling tempfile DIRECTORYNAME
+
+ The current setting is /tmp/ 
+--E 62
+
+--S 63 of 70
+)set fortran calling tempfile /home/daly
+--E 63
+
+--S 64 of 70
+)set fortran calling tempfile
+--------------------------- The tempfile Option ---------------------------
+
+ Description: set location of temporary data files
+
+ )set fortran calling tempfile  is used to tell AXIOM where
+ to place intermediate FORTRAN data files . This must be the 
+ name of a valid existing directory to which you have permission 
+ to write (including the final slash).
+
+ Syntax:
+   )set fortran calling tempfile DIRECTORYNAME
+
+ The current setting is /home/daly/ 
+--E 64
+
+--S 65 of 70
+)set fortran calling directory
+-------------------------- The directory Option ---------------------------
+
+ Description: set location of generated FORTRAN files
+
+ )set fortran calling directory  is used to tell AXIOM where
+ to place generated FORTRAN files. This must be the name 
+ of a valid existing directory to which you have permission 
+ to write (including the final slash).
+
+ Syntax:
+   )set fortran calling directory DIRECTORYNAME
+
+ The current setting is ./ 
+--E 65
+
+--S 66 of 70
+)set fortran calling directory /home/daly/
+--E 66
+
+--S 67 of 70
+)set fortran calling directory
+-------------------------- The directory Option ---------------------------
+
+ Description: set location of generated FORTRAN files
+
+ )set fortran calling directory  is used to tell AXIOM where
+ to place generated FORTRAN files. This must be the name 
+ of a valid existing directory to which you have permission 
+ to write (including the final slash).
+
+ Syntax:
+   )set fortran calling directory DIRECTORYNAME
+
+ The current setting is /home/daly/
+--E 67
+
+--S 68 of 70
+)set fortran calling linker
+---------------------------- The linker Option ----------------------------
+
+ Description: linker arguments (e.g. libraries to search)
+
+ )set fortran calling linkerargs  is used to pass arguments to the linker
+ when using  mkFort  to create functions which call Fortran code.
+ For example, it might give a list of libraries to be searched,
+ and their locations.
+ The string is passed verbatim, so must be the correct syntax for
+ the particular linker being used.
+
+ Example: )set fortran calling linker "-lxlf"
+
+ The current setting is -lxlf 
+--E 68
+
+--S 69 of 70
+)set fortran calling linker "-TPD"
+--E 69
+
+--S 70 of 70
+)set fortran calling linker
+---------------------------- The linker Option ----------------------------
+
+ Description: linker arguments (e.g. libraries to search)
+
+ )set fortran calling linkerargs  is used to pass arguments to the linker
+ when using  mkFort  to create functions which call Fortran code.
+ For example, it might give a list of libraries to be searched,
+ and their locations.
+ The string is passed verbatim, so must be the correct syntax for
+ the particular linker being used.
+
+ Example: )set fortran calling linker "-lxlf"
+
+ The current setting is -TPD 
+--E 70
 )spool
 )lisp (bye)
  
diff --git a/src/interp/bootfuns.lisp.pamphlet b/src/interp/bootfuns.lisp.pamphlet
index e94b453..654856c 100644
--- a/src/interp/bootfuns.lisp.pamphlet
+++ b/src/interp/bootfuns.lisp.pamphlet
@@ -85,9 +85,6 @@ which will walk the structure $Y$ looking for this constant.
 #-:CCL
 (def-boot-val |$timerTicksPerSecond| INTERNAL-TIME-UNITS-PER-SECOND
     "for TEMPUS-FUGIT and $TOTAL-ELAPSED-TIME")
-#+:CCL
-(def-boot-val |$timerTicksPerSecond| 1000
-    "for TEMPUS-FUGIT and $TOTAL-ELAPSED-TIME")
 (def-boot-val $boxString
   (concatenate 'string (list (code-char #x1d) (code-char #xe2)))
   "this string of 2 chars displays as a box")
@@ -391,7 +388,6 @@ for primitive domains.	Also used by putInLocalDomainReferences and optCal.")
 (def-boot-var |$suffix|				    "???")
 (def-boot-val |$Symbol| '(|Symbol|)		    "???")
 (def-boot-val |$SymbolOpt| '(|Symbol| . OPT)	    "???")
-;(def-boot-var |$systemCommands|			    "Interpreter>System.boot")
 (def-boot-val |$systemCreation| (currenttime)	    "???")
 (def-boot-val |$systemLastChanged|
 	  |$systemCreation|			"???")
@@ -459,9 +455,7 @@ for primitive domains.	Also used by putInLocalDomainReferences and optCal.")
   (if (memq u '(|%display%| |%describe%|)) 
         (if |$printLoadMsgs| "on" "off")
         (seq 
-          (setq |$printLoadMsgs| (and (listp u) (equal (car u) '|on|)))
-#+:CCL    (verbos (if |$printLoadMsgs| 2 0))
-)))
+          (setq |$printLoadMsgs| (and (listp u) (equal (car u) '|on|))))))
 
 @
 \eject
diff --git a/src/interp/g-cndata.boot.pamphlet b/src/interp/g-cndata.boot.pamphlet
index 7e09df9..4469086 100644
--- a/src/interp/g-cndata.boot.pamphlet
+++ b/src/interp/g-cndata.boot.pamphlet
@@ -126,11 +126,6 @@ mkUserConstructorAbbreviation(c,a,type) ==
   installConstructor(c,type)
   setAutoLoadProperty(c)
  
-abbQuery(x) ==
-  abb := GETDATABASE(x,'ABBREVIATION) =>
-   sayKeyedMsg("S2IZ0001",[abb,GETDATABASE(x,'CONSTRUCTORKIND),x])
-  sayKeyedMsg("S2IZ0003",[x])
- 
 installConstructor(cname,type) ==
   (entry := getCDTEntry(cname,true)) => entry
   item := [cname,GETDATABASE(cname,'ABBREVIATION),nil]
diff --git a/src/interp/i-syscmd.boot.pamphlet b/src/interp/i-syscmd.boot.pamphlet
index 19de874..a73b79d 100644
--- a/src/interp/i-syscmd.boot.pamphlet
+++ b/src/interp/i-syscmd.boot.pamphlet
@@ -9,82 +9,6 @@
 \eject
 \tableofcontents
 \eject
-\begin{verbatim}
-This file contains the BOOT code for the Axiom system command
-and synonym processing facility.  The code for )trace is in the file
-TRACE BOOT.  The list of system commands is $SYSCOMMANDS which is
-initialized in SETQ LISP.
-
-\end{verbatim}
-\section{Filenames change}
-It appears that probe-file is now case-sensitive. In order to get around
-this we include the file extensions in both upper and lower case in the
-search lists. Lower case names are preferred.
-
-\section{handleNoParseCommands}
-The system commands given by the global variable
-[[|$noParseCommands|]]\cite{1} require essentially no
-preprocessing/parsing of their arguments. Here we dispatch the
-functions which implement these commands.
-
-There are four standard commands which receive arguments -- [[lisp]],
-[[synonym]], [[system]] and [[boot]]. There are five standard commands
-which do not receive arguments -- [[quit]], [[fin]], [[pquit]],
-[[credits]] and [[copyright]]. As these commands do not necessarily
-exhaust those mentioned in [[|$noParseCommands|]], we provide a
-generic dispatch based on two conventions: commands which do not
-require an argument name themselves, those which do have their names
-prefixed by [[np]].
-
-<<handleNoParseCommands>>=
-handleNoParseCommands(unab, string) ==
-  string := stripSpaces string
-  spaceIndex := SEARCH('" ", string)
-  unab = "lisp" =>
-    if (null spaceIndex) then
-      sayKeyedMsg("S2IV0005", NIL)
-      nil
-    else nplisp(stripLisp string)
-  unab = "boot" =>
-    if (null spaceIndex) then
-      sayKeyedMsg("S2IV0005", NIL)
-      nil
-    else npboot(SUBSEQ(string, spaceIndex+1))
-  unab = "system" =>
-    if (null spaceIndex) then
-      sayKeyedMsg("S2IV0005", NIL)
-      nil
-    else npsystem(unab, string)
-  unab = "synonym" =>
-    npsynonym(unab, (null spaceIndex => '""; SUBSEQ(string, spaceIndex+1)))
-  null spaceIndex =>
-    FUNCALL unab
-  MEMBER(unab, '( quit     _
-                  fin      _
-		  pquit    _
-		  credits  _
-		  copyright )) => 
-    sayKeyedMsg("S2IV0005", NIL)
-    nil
-  funName := INTERN CONCAT('"np",STRING unab)
-  FUNCALL(funName, SUBSEQ(string, spaceIndex+1))
-
-@
-\section{TRUENAME change}
-This change was made to make the open source Axiom work with the 
-new aldor compiler.z
-This used to read:
-\begin{verbatim}
-     STRCONC(TRUENAME(STRCONC(GETENV('"AXIOM"),'"/compiler/bin/")),"axiomxl ", asharpArgs, '" ", namestring args)
-\end{verbatim}
-but now reads:
-<<remove TRUENAME>>=
-     STRCONC(STRCONC(GETENV('"ALDORROOT"),'"/bin/"),_
-               "aldor ", asharpArgs, '" ", namestring args)
-@
-Notice that we've introduced the [[ALDORROOT]] shell variable.
-This will have to be pushed down from the top level Makefile.
-
 \section{License}
 <<license>>=
 -- Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
@@ -130,24 +54,6 @@ SETANDFILEQ($compileRecurrence,true)
 SETANDFILEQ($errorReportLevel,'warning)
 SETANDFILEQ($sourceFileTypes,'(INPUT SPAD BOOT LISP LISP370 META))
 
-SETANDFILEQ($whatOptions, '( _
-    operations _
-    categories _
-    domains _
-    packages _
-    commands _
-    synonyms _
-    things _
-    ))
-
-SETANDFILEQ($clearOptions, '( _
-  modes _
-  operations _
-  properties _
-  types _
-  values  _
-  ))
-
 SETANDFILEQ($countAssoc,'( (cache countCache) ))
 
 --% Top level system command
@@ -211,19 +117,6 @@ hasOption(al,opt) ==
     stringPrefix?(PNAME CAR pair,optPname) => found := pair
   found
 
-selectOptionLC(x,l,errorFunction) ==
-  selectOption(DOWNCASE object2Identifier x,l,errorFunction)
-
-selectOption(x,l,errorFunction) ==
-  MEMBER(x,l) => x                   --exact spellings are always OK
-  null IDENTP x =>
-    errorFunction => FUNCALL(errorFunction,x,u)
-    nil
-  u := [y for y in l | stringPrefix?(PNAME x,PNAME y)]
-  u is [y] => y
-  errorFunction => FUNCALL(errorFunction,x,u)
-  nil
-
 terminateSystemCommand() == TERSYSCOMMAND()
 
 commandUserLevelError(x,u) == userLevelErrorMessage("command",x,u)
@@ -460,30 +353,6 @@ displayValue($op,u,omitVariableNameIfTrue) ==
     outputFormat(expr,objMode(u))]
   NIL
 
---% )edit
-
-edit l == editSpad2Cmd l
-
-editSpad2Cmd l ==
-  l:= 
-    null l => _/EDITFILE
-    CAR l
-  l := pathname l
-  oldDir := pathnameDirectory l
-  fileTypes :=
-    pathnameType l => [pathnameType l]
-    $UserLevel = 'interpreter => '("input" "INPUT" "spad" "SPAD")
-    $UserLevel = 'compiler    => '("input" "INPUT" "spad" "SPAD")
-    '("input" "INPUT" "spad" "SPAD" "boot" "BOOT" "lisp" "LISP" "meta" "META")
-  ll := 
-       oldDir = '"" => pathname $FINDFILE (pathnameName l, fileTypes)
-       l
-  l := pathname ll
-  SETQ(_/EDITFILE,l)
-  rc := editFile l
-  updateSourceFiles l
-  rc
-
 --% )load
 
 load args == loadSpad2Cmd args
@@ -960,8 +829,6 @@ doSystemCommand string ==
         nil
    nil
 
-<<handleNoParseCommands>>
-
 npboot str ==
   sex := string2BootTree str
   FORMAT(true, '"~&~S~%", sex)
diff --git a/src/interp/intint.lisp.pamphlet b/src/interp/intint.lisp.pamphlet
index a4e29f5..c3973f8 100644
--- a/src/interp/intint.lisp.pamphlet
+++ b/src/interp/intint.lisp.pamphlet
@@ -48,104 +48,68 @@
 
 (in-package "BOOT")
 
+(eval-when (eval load)
+  (setq |$useNewParser| T))
+
+(defun |rePackageTran| (sex package)
+ (let (*package*)
+  (declare (special *package*))
+  (setq *package* (find-package (string package)))
+  (|packageTran| sex)))
+
+(defun |packageTran| (sex)
+ (prog () 
+  (return
+   (cond
+    ((symbolp sex)
+     (cond
+      ((eq *package* (symbol-package sex)) sex)
+      (t (intern (string sex)))))
+    ((consp sex)
+      (rplaca sex (|packageTran| (car sex)))
+      (rplacd sex (|packageTran| (cdr sex)))
+      sex)
+    (t sex)))))
+
+(defun |zeroOneTran| (sex)
+ (nsubst '|$EmptyMode| '? sex))
+
 (defun |intSayKeyedMsg| (key args)
   (|sayKeyedMsg| (|packageTran| key) (|packageTran| args)))
 
-;;(defun |intMakeFloat| (int frac len exp)
-;;  (MAKE-FLOAT int frac len exp))
-
-;;(defun |intSystemCommand| (command)
-;;  (catch 'SPAD_READER
-;;    (|systemCommand| (|packageTran| command))))
-
-;;(defun |intUnAbbreviateKeyword| (keyword)
-;;  (|unAbbreviateKeyword| (|packageTran| keyword)))
-
 (defun |intProcessSynonyms| (str)
   (let ((LINE str))
     (declare (special LINE))
     (|processSynonyms|)
     LINE))
 
-;; (defun |intNoParseCommands| ()
-;;   |$noParseCommands|)
-
-;;(defun |intTokenCommands| ()
-;; |$tokenCommands|)
-
 (defun |intInterpretPform| (pf)
   (|processInteractive| (|zeroOneTran| (|packageTran| (|pf2Sex| pf))) pf))
 
-;;(defun |intSpadThrow| ()
-;;  (|spadThrow|))
-
-;;(defun |intMKPROMPT| (should? step)
-;;  (if should? (PRINC (MKPROMPT))))
-
 (defvar |$intCoerceFailure| '|coerceFailure|)
 (defvar |$intTopLevel| '|top_level|)
 (defvar |$intSpadReader| 'SPAD_READER)
 (defvar |$intRestart| '|restart|)
 
-;;(defun |intString2BootTree| (str)
-;;  (|string2BootTree| str))
-
-;;(defun |intPackageTran| (sex)
-;;  (|packageTran| sex))
-
-;;(defvar |$SessionManager| |$SessionManager|)
-;;(defvar |$EndOfOutput| |$EndOfOutput|)
-
-;;(defun |intServerReadLine| (foo)
-;;  (|serverReadLine| foo))
-
-;; (defun |intProcessSynonym| (str)
-;;   (|npProcessSynonym| str))
-
 (defun |SpadInterpretFile| (fn)
       (|SpadInterpretStream| 1 fn nil) )
 
 (defun |intNewFloat| ()
   (list '|Float|))
 
-;; (defun |intDoSystemCommand| (string)
-;;   (|doSystemCommand| string))
-
 (defun |intSetNeedToSignalSessionManager| ()
   (setq |$NeedToSignalSessionManager| T))
 
-;; (defun |intKeyedSystemError| (msg args)
-;;   (|keyedSystemError| msg args))
-
-;;#-:CCL
-;;(defun |stashInputLines| (l)
-;;  (|stashInputLines| l))
-
-;;(defun |setCurrentLine| (s)
-;;  (setq |$currentLine| s))
-
 (defun |intnplisp| (s)
  (setq |$currentLine| s)
  (|nplisp| |$currentLine|))
 
-;; (defun |intResetStackLimits| () (|resetStackLimits|))
-
 (defun |intSetQuiet| ()
   (setq |$QuietCommand| T))
 
 (defun |intUnsetQuiet| ()
   (setq |$QuietCommand| NIL))
 
-;; (defun |expandTabs| (s)
-;;   (expand-tabs s))
-
-;; #-:CCL
-;; (defun |leaveScratchpad| ()
-;;   (|leaveScratchpad|))
-
-;;(defun |readingFile?| ()
-;;  |$ReadingFile|)
-
 @
 \eject
 \begin{thebibliography}{99}
diff --git a/src/interp/macros.lisp.pamphlet b/src/interp/macros.lisp.pamphlet
index 117408c..3b06048 100644
--- a/src/interp/macros.lisp.pamphlet
+++ b/src/interp/macros.lisp.pamphlet
@@ -149,8 +149,6 @@ ends up being [[CONTAINED |$EmptyMode| Y]].
 (defmacro |function| (name) `(FUNCTION ,name))
 (defmacro |dispatchFunction| (name) `(FUNCTION ,name))
  
-(defun |functionp| (fn)
-   (if (identp fn) (and (fboundp fn) (not (macro-function fn))) (functionp fn)))
 (defun |macrop| (fn) (and (identp fn) (macro-function fn)))
  
 ; 6 PREDICATES
@@ -1261,22 +1259,12 @@ LP  (COND ((NULL X)
 (defun sayBrightlyNT1 (X *standard-output*)
   (if (ATOM X) (BRIGHTPRINT-0 X) (BRIGHTPRINT X)))
  
-(defun sayBrightly1 (X *standard-output*)
-    (if (ATOM X)
-	(progn (BRIGHTPRINT-0 X) (TERPRI) (force-output))
-      (progn (BRIGHTPRINT X) (TERPRI) (force-output))))
- 
-(defvar |$algebraOutputStream| *standard-output*)
- 
 (defun |saySpadMsg| (X)
   (if (NULL X) NIL (sayBrightly1 X |$algebraOutputStream|)))
  
 (defun |sayALGEBRA| (X) "Prints on Algebra output stream."
   (if (NULL X) NIL (sayBrightly1 X |$algebraOutputStream|)))
  
-(defun |sayMSG| (X)
-  (if (NULL X) NIL (sayBrightly1 X |$algebraOutputStream|)))
- 
 (defun |sayMSGNT| (X)
   (if (NULL X) NIL (sayBrightlyNT1 X |$algebraOutputStream|)))
  
@@ -1307,29 +1295,8 @@ LP  (COND ((NULL X)
  
 ;; the following are redefined in MSGDB BOOT
  
-;; --------------------> NEW DEFINITION (override in msgdb.boot.pamphlet)
-(DEFUN BRIGHTPRINT (X) (MESSAGEPRINT X))
- 
-;; --------------------> NEW DEFINITION (override in msgdb.boot.pamphlet)
-(DEFUN BRIGHTPRINT-0 (x) (MESSAGEPRINT-1 X))
- 
 (defun SAY (&rest x) (progn (MESSAGEPRINT X) (TERPRI)))
  
-(DEFUN MESSAGEPRINT (X) (mapc #'messageprint-1 X))
- 
-(DEFUN MESSAGEPRINT-1 (X)
-  (COND ((OR (EQ X '|%l|) (EQUAL X "%l")) (TERPRI))
-        ((STRINGP X) (PRINC X))
-        ((IDENTP X) (PRINC X))
-        ((ATOM X) (PRINC X))
-        ((PRINC "(") (MESSAGEPRINT-1 (CAR X))
-	 (MESSAGEPRINT-2 (CDR X)) (PRINC ")"))))
- 
-(DEFUN MESSAGEPRINT-2 (X)
-  (if (ATOM X)
-      (if (NULL X) NIL (progn (PRINC " . ") (MESSAGEPRINT-1 X)))
-      (progn (PRINC " ") (MESSAGEPRINT-1 (CAR X)) (MESSAGEPRINT-2 (CDR X)))))
- 
 (DEFUN BLANKS (N &optional (stream *standard-output*)) "Print N blanks."
     (do ((i 1 (the fixnum(1+ i))))
 	((> i N))(declare (fixnum i n)) (princ " " stream)))
diff --git a/src/interp/setvars.boot.pamphlet b/src/interp/setvars.boot.pamphlet
index f5e8b35..6d2e935 100644
--- a/src/interp/setvars.boot.pamphlet
+++ b/src/interp/setvars.boot.pamphlet
@@ -74,140 +74,6 @@ See the section expose in setvart.boot.pamphlet\cite{1}
    for more information.
 \end{verbatim}
 
-\section{fortran calling}
-See the section calling in servart.boot.pamphlet.
-\begin{verbatim}
-              Current Values of  calling  Variables                   
-
-Variable     Description                           Current Value
------------------------------------------------------------------
-tempfile     set location of temporary data files       /tmp/ 
-directory    set location of generated FORTRAN files    ./ 
-linker       linker arguments (e.g. libraries to search) -lxlf 
-
-\end{verbatim}
-<<fortrancallingCode>>=
-<<setFortTmpDir>>
-<<validateOutputDirectory>>
-<<describeSetFortTmpDir>>
-<<setFortDir>>
-<<describeSetFortDir>>
-<<setLinkerArgs>>
-<<describeSetLinkerArgs>>
-@
-\subsection{setFortTmpDir}
-<<setFortTmpDir>>=
-setFortTmpDir arg ==
-
-  arg = "%initialize%" =>
-    $fortranTmpDir := '"/tmp/"
-
-  arg = "%display%" =>
-    STRINGP $fortranTmpDir => $fortranTmpDir
-    PNAME $fortranTmpDir
-
-  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
-    describeSetFortTmpDir()
-
-  -- try to figure out what the argument is
-
-  -- VM code - must be an accessed disk mode [mode]
-  not (mode := validateOutputDirectory arg) =>
-    sayBrightly ['" Sorry, but your argument(s)",:bright arg,
-      '"is(are) not valid.",'%l]
-    describeSetFortTmpDir()
-  $fortranTmpDir := mode
-
-@
-\subsection{validateOutputDirectory}
-<<validateOutputDirectory>>=
-validateOutputDirectory x ==
-  AND(PATHNAME_-DIRECTORY(PROBE_-FILE(CAR(x))), NOT PATHNAME_-NAME  (PROBE_-FILE(CAR(x)))) =>
-    CAR(x)
-  NIL
-
-@
-\subsection{describeSetFortTmpDir}
-<<describeSetFortTmpDir>>=
-describeSetFortTmpDir() ==
-  sayBrightly LIST (
-   '%b,'")set fortran calling tempfile",'%d,_
-   '" is used to tell AXIOM where",'%l,_
-   '" to place intermediate FORTRAN data files . This must be the ",'%l,_
-   '" name of a valid existing directory to which you have permission ",'%l,_
-   '" to write (including the final slash).",'%l,'%l,_
-   '" Syntax:",'%l,_
-   '"   )set fortran calling tempfile DIRECTORYNAME",'%l,'%l,_
-   '" The current setting is",'%b,$fortranTmpDir,'%d)
-
-@
-\subsection{setFortDir}
-<<setFortDir>>=
-setFortDir arg ==
-  arg = "%initialize%" =>
-    $fortranDirectory := '"./"
-
-  arg = "%display%" =>
-    STRINGP $fortranDirectory => $fortranDirectory
-    PNAME $fortranDirectory
-
-  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
-    describeSetFortDir()
-
-  -- try to figure out what the argument is
-
-  -- VM code - must be an accessed disk mode [mode]
-  not (mode := validateOutputDirectory arg) =>
-    sayBrightly ['" Sorry, but your argument(s)",:bright arg,
-      '"is(are) not valid.",'%l]
-    describeSetFortDir()
-  $fortranDirectory := mode
-
-@
-\subsection{describeSetFortDir}
-<<describeSetFortDir>>=
-describeSetFortDir() ==
-  sayBrightly LIST (
-   '%b,'")set fortran calling directory",'%d,_
-   '" is used to tell AXIOM where",'%l,_
-   '" to place generated FORTRAN files. This must be the name ",'%l,_
-   '" of a valid existing directory to which you have permission ",'%l,_
-   '" to write (including the final slash).",'%l,'%l,_
-   '" Syntax:",'%l,_
-   '"   )set fortran calling directory DIRECTORYNAME",'%l,'%l,_
-   '" The current setting is",'%b,$fortranDirectory,'%d)
-
-@
-\subsection{setLinkerArgs}
-<<setLinkerArgs>>=
-setLinkerArgs arg ==
-
-  arg = "%initialize%" =>
-    $fortranLibraries := '"-lxlf"
-  arg = "%display%" => object2String $fortranLibraries
-  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
-    describeSetLinkerArgs()
-  LISTP(arg) and STRINGP(first arg) => 
-    $fortranLibraries := first(arg)
-  describeSetLinkerArgs()
-
-@
-\subsection{describeSetLinkerArgs}
-<<describeSetLinkerArgs>>=
-describeSetLinkerArgs() ==
-  sayBrightly LIST (
-   '%b,'")set fortran calling linkerargs",'%d,_
-   '" is used to pass arguments to the linker",'%l,_
-   '" when using ",'%b,'"mkFort",'%d,_
-   '" to create functions which call Fortran code.",'%l,_
-   '" For example, it might give a list of libraries to be searched,",'%l,_
-   '" and their locations.",'%l,_
-   '" The string is passed verbatim, so must be the correct syntax for",'%l,_
-   '" the particular linker being used.",'%l,'%l,_
-   '" Example: )set fortran calling linker _"-lxlf_"",'%l,'%l,_
-   '" The current setting is",'%b,$fortranLibraries,'%d)
-
-@
 \section{functions}
 See the section functions in setvart.boot.pamphlet\cite{1}
 \begin{verbatim}
@@ -1377,7 +1243,6 @@ describeSetStreamsCalculate() == sayKeyedMsg("S2IV0001",[$streamCount])
 @
 <<*>>=
 <<license>>
-<<fortrancallingCode>>
 <<functionsCode>>
 <<historyCode>>
 <<kernelCode>>
@@ -1396,95 +1261,6 @@ describeSetStreamsCalculate() == sayKeyedMsg("S2IV0001",[$streamCount])
 
 (IN-PACKAGE "BOOT" )
 
-;setFortTmpDir arg ==
-;  arg = "%initialize%" =>
-;    $fortranTmpDir := '"/tmp/"
-;  arg = "%display%" =>
-;    STRINGP $fortranTmpDir => $fortranTmpDir
-;    PNAME $fortranTmpDir
-;  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
-;    describeSetFortTmpDir()
-;  -- try to figure out what the argument is
-;  -- VM code - must be an accessed disk mode [mode]
-;  not (mode := validateOutputDirectory arg) =>
-;    sayBrightly ['" Sorry, but your argument(s)",:bright arg,
-;      '"is(are) not valid.",'%l]
-;    describeSetFortTmpDir()
-;  $fortranTmpDir := mode
-
-(DEFUN |setFortTmpDir| (|arg|) (PROG (|mode|) (RETURN (COND ((BOOT-EQUAL |arg| (QUOTE |%initialize%|)) (SPADLET |$fortranTmpDir| (MAKESTRING "/tmp/"))) ((BOOT-EQUAL |arg| (QUOTE |%display%|)) (COND ((STRINGP |$fortranTmpDir|) |$fortranTmpDir|) ((QUOTE T) (PNAME |$fortranTmpDir|)))) ((OR (NULL |arg|) (BOOT-EQUAL |arg| (QUOTE |%describe%|)) (BOOT-EQUAL (CAR |arg|) (QUOTE ?))) (|describeSetFortTmpDir|)) ((NULL (SPADLET |mode| (|validateOutputDirectory| |arg|))) (|sayBrightly| (CONS (MAKESTRING " Sorry, but your argument(s)") (APPEND (|bright| |arg|) (CONS (MAKESTRING "is(are) not valid.") (CONS (QUOTE |%l|) NIL))))) (|describeSetFortTmpDir|)) ((QUOTE T) (SPADLET |$fortranTmpDir| |mode|)))))) 
-;validateOutputDirectory x ==
-;  AND(PATHNAME_-DIRECTORY(PROBE_-FILE(CAR(x))), NOT PATHNAME_-NAME  (PROBE_-FILE(CAR(x)))) =>
-;    CAR(x)
-;  NIL
-
-(DEFUN |validateOutputDirectory| (|x|) (COND ((AND (PATHNAME-DIRECTORY (PROBE-FILE (CAR |x|))) (NULL (PATHNAME-NAME (PROBE-FILE (CAR |x|))))) (CAR |x|)) ((QUOTE T) NIL))) 
-;describeSetFortTmpDir() ==
-;  sayBrightly LIST (
-;   '%b,'")set fortran calling tempfile",'%d,_
-;   '" is used to tell AXIOM where",'%l,_
-;   '" to place intermediate FORTRAN data files . This must be the ",'%l,_
-;   '" name of a valid existing directory to which you have permission ",'%l,_
-;   '" to write (including the final slash).",'%l,'%l,_
-;   '" Syntax:",'%l,_
-;   '"   )set fortran calling tempfile DIRECTORYNAME",'%l,'%l,_
-;   '" The current setting is",'%b,$fortranTmpDir,'%d)
-
-(DEFUN |describeSetFortTmpDir| NIL (|sayBrightly| (LIST (QUOTE |%b|) (MAKESTRING ")set fortran calling tempfile") (QUOTE |%d|) (MAKESTRING " is used to tell AXIOM where") (QUOTE |%l|) (MAKESTRING " to place intermediate FORTRAN data files . This must be the ") (QUOTE |%l|) (MAKESTRING " name of a valid existing directory to which you have permission ") (QUOTE |%l|) (MAKESTRING " to write (including the final slash).") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING " Syntax:") (QUOTE |%l|) (MAKESTRING "   )set fortran calling tempfile DIRECTORYNAME") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING " The current setting is") (QUOTE |%b|) |$fortranTmpDir| (QUOTE |%d|)))) 
-;setFortDir arg ==
-;  arg = "%initialize%" =>
-;    $fortranDirectory := '"./"
-;  arg = "%display%" =>
-;    STRINGP $fortranDirectory => $fortranDirectory
-;    PNAME $fortranDirectory
-;  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
-;    describeSetFortDir()
-;  -- try to figure out what the argument is
-;  -- VM code - must be an accessed disk mode [mode]
-;  not (mode := validateOutputDirectory arg) =>
-;    sayBrightly ['" Sorry, but your argument(s)",:bright arg,
-;      '"is(are) not valid.",'%l]
-;    describeSetFortDir()
-;  $fortranDirectory := mode
-
-(DEFUN |setFortDir| (|arg|) (PROG (|mode|) (RETURN (COND ((BOOT-EQUAL |arg| (QUOTE |%initialize%|)) (SPADLET |$fortranDirectory| (MAKESTRING "./"))) ((BOOT-EQUAL |arg| (QUOTE |%display%|)) (COND ((STRINGP |$fortranDirectory|) |$fortranDirectory|) ((QUOTE T) (PNAME |$fortranDirectory|)))) ((OR (NULL |arg|) (BOOT-EQUAL |arg| (QUOTE |%describe%|)) (BOOT-EQUAL (CAR |arg|) (QUOTE ?))) (|describeSetFortDir|)) ((NULL (SPADLET |mode| (|validateOutputDirectory| |arg|))) (|sayBrightly| (CONS (MAKESTRING " Sorry, but your argument(s)") (APPEND (|bright| |arg|) (CONS (MAKESTRING "is(are) not valid.") (CONS (QUOTE |%l|) NIL))))) (|describeSetFortDir|)) ((QUOTE T) (SPADLET |$fortranDirectory| |mode|)))))) 
-;describeSetFortDir() ==
-;  sayBrightly LIST (
-;   '%b,'")set fortran calling directory",'%d,_
-;   '" is used to tell AXIOM where",'%l,_
-;   '" to place generated FORTRAN files. This must be the name ",'%l,_
-;   '" of a valid existing directory to which you have permission ",'%l,_
-;   '" to write (including the final slash).",'%l,'%l,_
-;   '" Syntax:",'%l,_
-;   '"   )set fortran calling directory DIRECTORYNAME",'%l,'%l,_
-;   '" The current setting is",'%b,$fortranDirectory,'%d)
-
-(DEFUN |describeSetFortDir| NIL (|sayBrightly| (LIST (QUOTE |%b|) (MAKESTRING ")set fortran calling directory") (QUOTE |%d|) (MAKESTRING " is used to tell AXIOM where") (QUOTE |%l|) (MAKESTRING " to place generated FORTRAN files. This must be the name ") (QUOTE |%l|) (MAKESTRING " of a valid existing directory to which you have permission ") (QUOTE |%l|) (MAKESTRING " to write (including the final slash).") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING " Syntax:") (QUOTE |%l|) (MAKESTRING "   )set fortran calling directory DIRECTORYNAME") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING " The current setting is") (QUOTE |%b|) |$fortranDirectory| (QUOTE |%d|)))) 
-;setLinkerArgs arg ==
-;  arg = "%initialize%" =>
-;    $fortranLibraries := '"-lxlf"
-;  arg = "%display%" => object2String $fortranLibraries
-;  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
-;    describeSetLinkerArgs()
-;  LISTP(arg) and STRINGP(first arg) =>
-;    $fortranLibraries := first(arg)
-;  describeSetLinkerArgs()
-
-(DEFUN |setLinkerArgs| (|arg|) (COND ((BOOT-EQUAL |arg| (QUOTE |%initialize%|)) (SPADLET |$fortranLibraries| (MAKESTRING "-lxlf"))) ((BOOT-EQUAL |arg| (QUOTE |%display%|)) (|object2String| |$fortranLibraries|)) ((OR (NULL |arg|) (BOOT-EQUAL |arg| (QUOTE |%describe%|)) (BOOT-EQUAL (CAR |arg|) (QUOTE ?))) (|describeSetLinkerArgs|)) ((AND (LISTP |arg|) (STRINGP (CAR |arg|))) (SPADLET |$fortranLibraries| (CAR |arg|))) ((QUOTE T) (|describeSetLinkerArgs|)))) 
-;describeSetLinkerArgs() ==
-;  sayBrightly LIST (
-;   '%b,'")set fortran calling linkerargs",'%d,_
-;   '" is used to pass arguments to the linker",'%l,_
-;   '" when using ",'%b,'"mkFort",'%d,_
-;   '" to create functions which call Fortran code.",'%l,_
-;   '" For example, it might give a list of libraries to be searched,",'%l,_
-;   '" and their locations.",'%l,_
-;   '" The string is passed verbatim, so must be the correct syntax for",'%l,_
-;   '" the particular linker being used.",'%l,'%l,_
-;   '" Example: )set fortran calling linker _"-lxlf_"",'%l,'%l,_
-;   '" The current setting is",'%b,$fortranLibraries,'%d)
-
-(DEFUN |describeSetLinkerArgs| NIL (|sayBrightly| (LIST (QUOTE |%b|) (MAKESTRING ")set fortran calling linkerargs") (QUOTE |%d|) (MAKESTRING " is used to pass arguments to the linker") (QUOTE |%l|) (MAKESTRING " when using ") (QUOTE |%b|) (MAKESTRING "mkFort") (QUOTE |%d|) (MAKESTRING " to create functions which call Fortran code.") (QUOTE |%l|) (MAKESTRING " For example, it might give a list of libraries to be searched,") (QUOTE |%l|) (MAKESTRING " and their locations.") (QUOTE |%l|) (MAKESTRING " The string is passed verbatim, so must be the correct syntax for") (QUOTE |%l|) (MAKESTRING " the particular linker being used.") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING " Example: )set fortran calling linker \"-lxlf\"") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING " The current setting is") (QUOTE |%b|) |$fortranLibraries| (QUOTE |%d|)))) 
 ;setFunctionsCache arg ==
 ;  $options : local := NIL
 ;  arg = "%initialize%" =>
diff --git a/src/interp/vmlisp.lisp.pamphlet b/src/interp/vmlisp.lisp.pamphlet
index 2478e04..9ee26d5 100644
--- a/src/interp/vmlisp.lisp.pamphlet
+++ b/src/interp/vmlisp.lisp.pamphlet
@@ -343,13 +343,6 @@ the calculation by repeated divisions using the radix itself.
 (defmacro |idChar?| (x)
  `(or (alphanumericp ,x) (member ,x '(#\? #\% #\' #\!) :test #'char=)))
  
-(defmacro identp (x) 
- (if (atom x)
-  `(and ,x (symbolp ,x))
-   (let ((xx (gensym)))
-    `(let ((,xx ,x))
-      (and ,xx (symbolp ,xx))))))
-
 (defmacro ifcar (x)
   (if (atom x)
       `(and (consp ,x) (qcar ,x))
@@ -1055,11 +1048,6 @@ the calculation by repeated divisions using the radix itself.
 
 (defun QSREMAINDER (a b) (the fixnum (rem (the fixnum a) (the fixnum b))))
 
-
-;(defun IFCAR (x) (if (consp x) (car (the cons x))))
-
-;(defun IFCDR (x) (if (consp x) (cdr (the cons x))))
-
 ; 13.3 Updating
 
 
@@ -1077,20 +1065,6 @@ the calculation by repeated divisions using the radix itself.
 
 (defun VEC2LIST (vec) (coerce vec 'list))
 
-; note default test for union, intersection and set-difference is eql
-;; following are defined so as to preserve ordering in union.lisp
-;;(defun SETDIFFERENCE (l1 l2) (set-difference l1 l2 :test #'equalp))
-;;(defun SETDIFFERENCEQ (l1 l2) (set-difference l1 l2 :test #'eq))
-;;(defun |union| (l1 l2) (union l1 l2 :test #'equalp))
-;;(defun UNIONQ (l1 l2) (union l1 l2 :test #'eq))
-;;(defun |intersection| (l1 l2) (intersection l1 l2 :test #'equalp))
-;;(defun INTERSECTIONQ (l1 l2) (intersection l1 l2 :test #'eq))
-(defun |member| (item sequence)
-   (cond ((symbolp item) (member item sequence :test #'eq))
-	 ((stringp item) (member item sequence :test #'equal))
-	 ((and (atom item) (not (arrayp item))) (member item sequence))
-	 (T (member item sequence :test #'equalp))))
-
 (defun |remove| (list item &optional (count 1))
   (if (integerp count)
       (remove item list :count count :test #'equalp)
@@ -1103,14 +1077,10 @@ the calculation by repeated divisions using the radix itself.
 
 ; 14.2 Accessing
 
-;(define-function 'lastnode #'last)
-;(define-function 'lastpair #'last)
 (defun |last| (x) (car (lastpair x)))
 
 ; 14.3 Searching
 
-#+:CCL (DEFMACRO |assoc| (X Y) `(ASSOC** ,X ,Y))
-#-:CCL
 (DEFUN |assoc| (X Y)
   "Return the pair associated with key X in association list Y."
   ; ignores non-nil list terminators
@@ -1226,29 +1196,10 @@ can be restored.
 
 ; 17.1 Creation
 
-
-#-AKCL
-(defun concat (a b &rest l)
-   (let ((type (cond ((bit-vector-p a) 'bit-vector) (t 'string))))
-      (cond ((eq type 'string)
-	     (setq a (string a) b (string b))
-             (if l (setq l (mapcar #'string l)))))
-      (if l (apply #'concatenate type a b l)
-	(concatenate type a b))) )
-#+AKCL
-(defun concat (a b &rest l)
-  (if (bit-vector-p a)
-      (if l (apply #'concatenate 'bit-vector a b l)
-	(concatenate 'bit-vector a b))
-    (if l (apply #'system:string-concatenate a b l)
-      (system:string-concatenate a b))))
-
 (define-function 'strconc #'concat)
 
 (defun make-cvec (sint) (make-array sint :fill-pointer 0 :element-type 'string-char))
 
-;(define-function 'CVECP #'stringp)
-
 (define-function 'getstr #'make-cvec)
 
 (defun make-full-cvec (sint &optional (char #\space))



From MAILER-DAEMON Mon Mar 23 06:20:21 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LlhGX-00039U-6X
	for mharc-axiom-developer@gnu.org; Mon, 23 Mar 2009 06:20:21 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LlhGU-00038l-O6
	for axiom-developer@nongnu.org; Mon, 23 Mar 2009 06:20:18 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LlhGP-00037v-Gm
	for axiom-developer@nongnu.org; Mon, 23 Mar 2009 06:20:17 -0400
Received: from [199.232.76.173] (port=34674 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LlhGP-00037s-D1
	for axiom-developer@nongnu.org; Mon, 23 Mar 2009 06:20:13 -0400
Received: from mx-7.zoominternet.net ([24.154.1.26]:36054
	helo=cm-1.zoominternet.net)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LlhGO-0006ic-TN
	for axiom-developer@nongnu.org; Mon, 23 Mar 2009 06:20:13 -0400
X-SpamGroup: 2000
X-CM-Cat: Undefined:Undefined
X-CNFS-Analysis: v=1.0 c=1 a=A11uN4vBTRAA:10 a=qTzPt3dRJ1IA:10
	a=E8rTNAPPKTgA:10 a=9x1qJYSYWOoMgoVr+WVG7Q==:17
	a=ckR6x46zAAAA:8 a=o83nqyVRAAAA:8 a=DIuwlW7QAAAA:8
	a=HaDKusHuAAAA:8 a=l47wEaH3Px8lc9JANb8A:9
	a=54FSZnsbwu-QAjm2geMA:7 a=JvoGs6nMlaf1104Z1hwS8oRTEMIA:4
	a=c06vB5MgL9cA:10 a=kzNTxXjCp2fEa4_e:21 a=qVpdfGQOFnG7DLgT:21
X-CM-Score: 0
X-Scanned-by: Cloudmark Authority Engine
Received: from [24.154.1.44] ([24.154.1.44:43155] helo=pop-1.zoominternet.net)
	by mx-7.zoominternet.net (envelope-from <daly@axiom-developer.org>)
	(ecelerity 2.2.2.30 r(24168)) with ESMTP
	id F2/7A-23446-F4267C94; Mon, 23 Mar 2009 06:19:59 -0400
Received: (qmail 9473 invoked from network); 23 Mar 2009 10:20:02 -0000
Received: from unknown (HELO localhost.localdomain) ([72.23.19.139])
	(envelope-sender <daly@axiom-developer.org>)
	by pop-1.zoominternet.net (qmail-ldap-1.03) with SMTP
	for <axiom-developer@nongnu.org>; 23 Mar 2009 10:20:02 -0000
Received: (from root@localhost)
	by localhost.localdomain (8.11.6/8.11.6) id n2NB87I09473;
	Mon, 23 Mar 2009 06:08:07 -0500
Date: Mon, 23 Mar 2009 06:08:07 -0500
Message-Id: <200903231108.n2NB87I09473@localhost.localdomain>
From: root <daly@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: Genre and OS details not
	recognized.
Subject: [Axiom-developer] 1st CFP - SYNASC 2009 - 11th International
	Symposium on Symbolic and Numeric Algorithms for Scientific
	Computing, Timisoara, Romania, 26-29, Sep, 2009
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
Reply-To: daly@axiom-developer.org
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 23 Mar 2009 10:20:19 -0000


From: synasc09@info.uvt.ro
To: synasc09@info.uvt.ro
Subject: 1st CFP - SYNASC 2009 - 11th International Symposium on Symbolic and Numeric Algorithms for Scientific Computing, Timisoara, Romania, 26-29, Sep, 2009
Date: Mon, 23 Mar 2009 12:06:47 +0200 (EET)

[Please post - apologies for multiple copies.]

First Call for Papers
- ---------------------
SYNASC 2009

11th International Symposium on
Symbolic and Numeric Algorithms for Scientific Computing
September 26-29, 2009, Timisoara, Romania
http://synasc09.info.uvt.ro/

Aim:
- ---
SYNASC aims to stimulate the interaction between the two scientific communities of symbolic and numeric computing, with the purpose of exhibiting interesting applications of these areas both in theory and in practice.  The choice of this topic is motivated by the belief of the organizers that  the dialogue  between the two communities is very necessary in order to make significant progress in  making the computer a truly intelligent aid for mathematicians and engineers.

Important dates:
- ---------------

20 April 2009        :  Special sessions / Workshops / Tutorials proposals
20 May 2009          :  Papers submission
15 August 2009       :  Notification of acceptance
01 September 2009    :  Registration
15 September 2009    :  Revised paper according the reviews
26-29 September 2009 :  Symposium period
30 November 2009     :  Final papers for post-proceedings

Topics of interests:
- -------------------

    * Symbolic Computation
        + computer algebra;
        + symbolic techniques applied to numerics;
        + hybrid symbolic and numeric algorithms.
        + numerics and symbolics for geometry;
        + programming with constraints, narrowing;

    * Logic and programming
        + automatic reasoning;
        + formal system verification;
        + formal verification and synthesis
        + software quality assessment;
        + static analysis;
        + timing analysis.

    * Artificial Intelligence
        + hard computational problem solving;
        + intelligent systems (front-ends) for scientific computing;
        + agent-based complex systems modeling and development;
        + knowledge and data intensive systems
        + soft computing;
        + recommender systems for scientific computing;
        + data mining; web mining;
        + information retrieval.

    * Numerical computing
        + iterative approximation of fixed points;
        + solving systems of nonlinear equations;
        + numerical and symbolic algorithms for differential equations;
        + numerical and symbolic algorithms for optimization;
        + parallel algorithms for numeric computing;
        + scientific visualization and image processing.

    * Parallel computing
        + parallel, distributed and web computing for symbolics and numerics;
        + grid middleware and applications;
        + agent-based grid computing;
        + grid services;
        + workflow management.

This list is not intended to be exhaustive.

Publication:
- ------------
The research papers accepted for the conference will be collected as 
post-proceedings published by IEEE Computer Society Press (ISI Proceedings). 
(For previous proceedings see 
http://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=4438060)


Honorary Chairs:
- ---------------
    * Bruno Buchberger,  Johannes Kepler University, Linz
    * Stefan Maruster, West University of Timisoara, Romania

Steering Committee:
    * Tetsuo Ida, University of Tsukuba, Japan
    * Tudor Jebelean, Johannes Kepler University, Austria
    * Viorel Negru, West University of Timisoara, Romania
    * Dana Petcu, West University of Timisoara, Romania
    * Stephen Watt, University of Western Ontario, Canada
    * Daniela Zaharie, West University of Timisoara, Romania

General chair:
    * Viorel Negru, West University of Timisoara, Romania

Program Chair:
    * Stephen Watt, University of Western Ontario, Canada

Sessions chairs:
    * Symbolic computation
        + Tetsuo Ida, University of Tsukuba, Japan
        + Dongming Wang, Universite Pierre et Marie Curie, France
    * Logic and programming
        + Tudor Jebelean, Johannes Kepler University, Austria
        + Jens Knoop, Vienna University of Technology, Austria
    * Artificial Intelligence
        + Ajith Abraham, Norwegian University of Science and Technology, Norway
        + Daniela Zaharie, West University of Timisoara, Romania
    * Numerical computing
        + Vasile Berinde, North University of Baia Mare, Romania
        + Stefan Maruster, West University of Timisoara, Romania
    * Parallel and distributed computing
        + Dana Petcu, West University of Timisoara, Romania
        + Wolfgang Schreiner, Johannes Kepler University, Austria


Submission:
- -----------
Papers (IEEE conference style), must be submitted electronically through http://www.easychair.org/conferences/?conf=synasc2009.

We invite submissions in the form of:
    * full research papers, (up to 8 pages).
         Accepted research papers will be presented at the conference
         and will be also published in the proceedings.
    * informal presentations (up to 4 pages).
         Accepted informal presentations will be presented at the
         conference but will not be published in the proceedings.

We also invite proposals for:
    * special sessions
    * satellite workshops

Proposals are invited for special sessions on any topic relevant to the conference. Special sessions are intended to stimulate in-depth  discussions in special areas and they are fully integrated into the main conference. The research papers and the informal presentations submitted and accepted for the special sessions follow the same rules as the papers submitted to the regular sessions. It is expected that the organizers of the special sessions appoint their own chairs and program committee, which will be integrated in the conference programme committee and will be supervised by the conference programme chair and by the general chair.

Proposals for satellite workshops are also invited. The scientific programme of the satellite workshops is entirely organized by the respective workshops. The main conference provides the infrastructure (registration, handling the finance, room and coffee breaks, etc). Authors contributing to a workshop would be required to register for the symposium.

Proposal for tutorials are also invited. Tutorials provide fundamental exposure to topics ranging from introductory through intermediate to advanced. The number and the duration of the tutorials will be decided by the tutorial chair under the supervision of the general chair. Depending on the number and the quality of the proposals for tutorials, they may be organized as a SYNASC Autumn School.

- -- 
SYNASC 2009
West University of Timisoara
Dept. of Computer Science
Bd. V. Parvan 4, 300223 Timisoara, Romania
tel: + (40) 256 592155
fax: + (40) 256 592316
e-mail: synasc09.info.uvt.ro
------- End of forwarded message -------



From MAILER-DAEMON Tue Mar 24 11:20:53 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Lm8Qv-0007f2-OQ
	for mharc-axiom-developer@gnu.org; Tue, 24 Mar 2009 11:20:53 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Lm8Qs-0007cc-5C
	for axiom-developer@nongnu.org; Tue, 24 Mar 2009 11:20:50 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Lm8Qo-0007ZD-0u
	for axiom-developer@nongnu.org; Tue, 24 Mar 2009 11:20:49 -0400
Received: from [199.232.76.173] (port=59144 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Lm8Qn-0007Z8-Pq
	for axiom-developer@nongnu.org; Tue, 24 Mar 2009 11:20:45 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:47087
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1Lm8Qn-0000Lm-IU
	for axiom-developer@nongnu.org; Tue, 24 Mar 2009 11:20:45 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n2OFKgug031451;
	Tue, 24 Mar 2009 09:20:43 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n2OFKb7A031421;
	Tue, 24 Mar 2009 09:20:37 -0600
Date: Tue, 24 Mar 2009 09:20:37 -0600
Message-Id: <200903241520.n2OFKb7A031421@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090323.01.tpd.patch (bookvol5 finish move of
	command handling)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Tue, 24 Mar 2009 15:20:50 -0000

All of the root code for handling commands has been rewritten from boot
and added to bookvol5. The next phase involves tree-shaking the called
routines and moving them into the document.

Two new regression test files were added, setcmd and unittest1.

Tim



From MAILER-DAEMON Wed Mar 25 06:31:53 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LmQOn-0003hY-Gc
	for mharc-axiom-developer@gnu.org; Wed, 25 Mar 2009 06:31:53 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LmQOl-0003ft-VK
	for axiom-developer@nongnu.org; Wed, 25 Mar 2009 06:31:52 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LmQOh-0003bV-8Z
	for axiom-developer@nongnu.org; Wed, 25 Mar 2009 06:31:51 -0400
Received: from [199.232.76.173] (port=48400 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LmQOf-0003b8-ST
	for axiom-developer@nongnu.org; Wed, 25 Mar 2009 06:31:45 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:39540
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LmQOf-0007pA-BI
	for axiom-developer@nongnu.org; Wed, 25 Mar 2009 06:31:45 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n2PAVhug003270;
	Wed, 25 Mar 2009 04:31:44 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n2PAVgeD003267;
	Wed, 25 Mar 2009 04:31:42 -0600
Date: Wed, 25 Mar 2009 04:31:42 -0600
Message-Id: <200903251031.n2PAVgeD003267@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: Sergio Polini <sp_rm_it@yahoo.it>
Subject: [Axiom-developer] March 2009 release
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Wed, 25 Mar 2009 10:31:52 -0000

The git, github, arch, and sourceforge cvs servers now contain the
March 2009 release sources. 

Binary files will be available at:
   http://axiom-developer.org/axiom-website/download.html
as I get them compiled.

Attached are the release notes:

========================================================================
There were two major changes in this release.

First is the completion of the first phase of Book Volume 10.4: Axiom
Packages, which collects all of the packages into one document. The
side effect is to remove almost all of the remaining algebra files
leaving src/algebra nearly empty.

Second is the start of Book Volume 5: Axiom Interpreter which will
consolidate all of the interpreter functions and document them in
book form. A side effect of this consolidation will be the ultimate
removal of all boot code, with the further side effect of removing
bootsys from the build step and boot translation time.

While consolidating the interpreter code a parallel effort will be
ongoing to build Book Volume 9: Axiom Compiler. The idea is to split
the compiler code from the interpreter code so the compiler can be
documented and upgraded.

Book Volume 0: Axiom Jenks book
  Add )include documentation

    The original book did not document the )include command. This is
    now documented.

  Add UnivariateSkewPolynomial

    This domain was added to the domain examples 

Book Volume 4: Axiom Developers Guide
  Hyperdoc

    A Hyperdoc tutorial on making new pages was written

    A tutorial on spadhelp was added

Book Volume 5: Axiom Interpreter
  Command Handling
    
    The top level commands that start with open parenthesis are all
    kept in the $setOptions data structure. This structure was documented.
    Each command has a handler routine which was integrated with the
    structure in the proper place. 

  New latex macros

    The \defun and \defmacro macros were added to ensure that
    there is a uniform handling of subsections and cross references
    for all functions and macros.

    The \defdollar macro was added to handle $foo variables in
    both index and cross reference.

    The \cmdhead macro was added to provide uniform handling of
    each of the top level commands in the $setOptions data structure

  Unit testing

    To ensure that changes did not break behavior two new regression
    test routines were added, unittest1 and setcmd. These test the
    top level command behavior.

  Trace functions added

    The trace.boot code was added. 

Book Volume 7: Axiom Hyperdoc
  Documentation

    Add Scott Morrison's original hypertex plan notes

Book Volume 10.1: Axiom Algebra Theory
  Documentation

    Add tutorial chapter on Singular Value Decomposition

Book Volume 10.3 Axiom Domains
  Algebra fixes

    Johannes Grabmeier fixed the outputFixed behavior in Float.

    A regression test chunk was added to the Float domain.

    UnivariateSkewPolynomial was documented. A regression test,
    help file, and examples were added.

    Heap was documented. A regression test, help file, and 
    examples were added.

    Dequeue was documented. A regression test, help file, and 
    examples were added.

    Queue was documented. A regression test, help file, and 
    examples were added.

    ArrayStack was documented. A regression test, help file, and 
    examples were added.

    Stack was documented. A regression test, help file, and 
    examples were added.

    NottinghamGroup was added, including regression and help files.
    Originally written by Martin Rubey.

  Regression tests

    The )sys rm now uses the -f flag to force deletion on all
    regression test files

Book Volume 10.4 Axiom Packages
  New Algebra

    All packages were moved into this volume. Almost all of the
    remaining algebra files were deleted.

    ApplicationProgramInterface (API) was added. It exposes the
    Axiom internal functions at the algebra level.

    UnivariateSkewPolynomial now has help, input, and examples

  Documentation

    The nag man pages were added to the related domain documentation

    Export lists were added for all packages.

  Regression tests

    The )sys rm now uses the -f flag to force deletion on all regression
    test files.

Boot to Lisp rewrite
  Deleted boot files

    setvars.boot is gone. The code has been rewritten and added to
    book volume 5. The code was rewritten and/or reformatted. All
    compile-time warnings were eliminated.

    setvart.boot is gone. The code has been rewritten and added to
    book volume 5. The code was rewritten and/or reformatted. All
    compile-time warnings were eliminated.

    trace.boot is gone. The code has been rewritten and added to
    book volume 5. The code was rewritten and/or reformatted. All 
    compile-time warnings were eliminated.

Regression test 
  cleanup
    )set break resume

     A subtle bug in regression testing caused by early exit of a
     test left some of the regression tests reporting success when
     there should have been failure. This was fixed by adding a
     )set break resume command to allow Axiom to continue the testing
     in the presence of an internal fault.

  new

     setcmd.input was added to regression test changes to the )set
     top level command
   
     unittest1.input was added to regresstion test other top level
     commands

     dop.input was added to unit test )d op example output

     frame.input was added to unit test frame handling

  removed

     bags.input was distributed among the algebra regression test
     files and bags.input was removed.

Bug fixes

  Bug 7183. The library handling code was repaired. Functions which do
  not exist were removed (e.g. input-libraries). The element values of
  the data structure are now pathnames.

  Bug 7182. )set mes auto did not indicate the current value. 

  Bug 7180: )set compiler input add foo triggers a call to open-library
  which was a CCL function and no longer implemented. The elements of
  the data structure were changed.  

  Bug 7179. Suprious sensitivity to )abb in documentation caused
  breakage because this was assumed to be an )abbreviation command.

  Bug 7178. Missing function inspect in ArrayStack

  Bug 7177. Missing function map! in ArrayStack

  Bug 7176. Missing function parts in ArrayStack

  Bug 7175. Missing function map in ArrayStack

  Bug 7174. Missing function map! in Stack

  Bug 7173. Missing function parts in Stack

  Bug 7172. map was missing from Stack(Integer)

  Bug 7170: )d op output failure due to X in algebra comments. The X
  symbol is now a marker for )d op examples and the use of X in comments
  is ambiguous.

  Bug 7141: )cd relative does not work

Interpreter (src/interp)
  Documentation

    document mmCost calculation

Help files
  Documentation

    The help file list is now dynamically generated from the algebra
    books.

readme
  Quote

    Add Doron Zeilberger quote about builders of CA systems.

Website
  Download

    Add fedora10 as a supported platform

    Add vector as a supported platform

Lisp 
  New patch

    read-char-no-hang was changed by Camm to ignore newlines but 
    Axiom's browser needs them to be recognized. A patch was added
    to back out Camm's change.




From MAILER-DAEMON Wed Mar 25 08:44:16 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LmSSu-0001Dq-Ee
	for mharc-axiom-developer@gnu.org; Wed, 25 Mar 2009 08:44:16 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LmSSr-0001At-Cw
	for axiom-developer@nongnu.org; Wed, 25 Mar 2009 08:44:13 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LmSSq-00018m-6P
	for axiom-developer@nongnu.org; Wed, 25 Mar 2009 08:44:12 -0400
Received: from [199.232.76.173] (port=43973 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LmSSo-000189-MF
	for axiom-developer@nongnu.org; Wed, 25 Mar 2009 08:44:10 -0400
Received: from yw-out-1718.google.com ([74.125.46.154]:14302)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <bill.page@newsynthesis.org>) id 1LmSSo-0000lw-9l
	for axiom-developer@nongnu.org; Wed, 25 Mar 2009 08:44:10 -0400
Received: by yw-out-1718.google.com with SMTP id 9so2399ywk.82
	for <axiom-developer@nongnu.org>; Wed, 25 Mar 2009 05:44:08 -0700 (PDT)
MIME-Version: 1.0
Received: by 10.150.156.20 with SMTP id d20mr17065357ybe.102.1237985047990; 
	Wed, 25 Mar 2009 05:44:07 -0700 (PDT)
Date: Wed, 25 Mar 2009 08:44:07 -0400
Message-ID: <fbcd16d40903250544t4e55c1f0v2fb937d19e86ea5c@mail.gmail.com>
From: Bill Page <bill.page@newsynthesis.org>
To: Axiom-Developer <axiom-developer@nongnu.org>, 
	open-axiom-devel <open-axiom-devel@lists.sourceforge.net>, 
	fricas-devel <fricas-devel@googlegroups.com>
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6 (newer, 2)
Cc: 
Subject: [Axiom-developer] Comparison of Spad, Boot,
	Reduce and Common Lisp for numerical computation
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Wed, 25 Mar 2009 12:44:14 -0000

Dear panAxiom Developers,

On the Axiom-Wiki website at

http://axiom-wiki.newsynthesis.org/SandBoxFisher

Mark Clements writes:

"How useful are the different CAS languages for implementing numerical
routines? Prompted by a comparison of R and C for implementing
Fisher's exact test for 2x2 tables
(http://fluff.info/blog/arch/00000172.htm), I thought that it would be
interesting to implement this particular test in Spad, Boot, Reduce
and Common Lisp (see below). Each set of code was required to
implement a univariate root finder and the hypergeometric distribution
to calculate the p-value under different alternatives, together with
the 95% confidence interval and the maximum likelihood estimator for
the odds ratio. The reference implementation is R, ...

As a caveat: I have little experience with these programs. Any changes
or improvements to the programs would be welcomed."

Thank you, Mark! I think this is a great contribution.

Of course any comparison like is inevitably biased by the previous
experience and skill of the programmer. I think Mark has done a pretty
good job of the coding but there are some obvious improvements and/or
changes in style that could be made. Besides Mark's original goal, I
think there are several ways in which a comparison like this might be
useful to others, not the least of which is to serve as a way of
learning more about the alternative of using of Boot and Lisp in
panAxiom. If you have some time available, I hope you will take Mark
up on his invitation to suggest changes or improvements to his
programs.

Regards,
Bill Page.



From MAILER-DAEMON Thu Mar 26 03:24:50 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LmjxJ-0001gA-QO
	for mharc-axiom-developer@gnu.org; Thu, 26 Mar 2009 03:24:49 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LmjxI-0001eu-77
	for axiom-developer@nongnu.org; Thu, 26 Mar 2009 03:24:48 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LmjxD-0001ZZ-Ml
	for axiom-developer@nongnu.org; Thu, 26 Mar 2009 03:24:47 -0400
Received: from [199.232.76.173] (port=44219 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LmjxC-0001Z9-Uq
	for axiom-developer@nongnu.org; Thu, 26 Mar 2009 03:24:43 -0400
Received: from mx20.gnu.org ([199.232.41.8]:13882)
	by monty-python.gnu.org with esmtps (TLS-1.0:RSA_AES_256_CBC_SHA1:32)
	(Exim 4.60) (envelope-from <daly@axiom-developer.org>)
	id 1LmjxC-0003g8-AK
	for axiom-developer@nongnu.org; Thu, 26 Mar 2009 03:24:42 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]
	helo=axiom-developer.org) by mx20.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LmjxB-0003Kb-8Q
	for axiom-developer@nongnu.org; Thu, 26 Mar 2009 03:24:41 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n2Q7Ocug020506;
	Thu, 26 Mar 2009 01:24:38 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n2Q7OcRO020497;
	Thu, 26 Mar 2009 01:24:38 -0600
Date: Thu, 26 Mar 2009 01:24:38 -0600
Message-Id: <200903260724.n2Q7OcRO020497@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by mx20.gnu.org: Linux 2.6? (barebone, rare!)
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6,
	seldom 2.4 (older, 4)
Cc: 
Subject: [Axiom-developer] 20090325.01.tpd.patch (download.html add March
	2009 column)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Thu, 26 Mar 2009 07:24:48 -0000

There is a new column in the download list for March 2009 binaries.
The first binary (fedora10) and the corresponding sources are available.

=======================================================================
diff --git a/changelog b/changelog
index f3f1d2c..922d05e 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,5 @@
+20090325 tpd src/axiom-website/patches.html 20090325.01.tpd.patch
+20090325 tpd src/axiom-website/download.html add March 2009 column
 20090324 tpd src/axiom-website/patches.html 20090324.01.tpd.patch
 20090324 tpd src/axiom-website/releasenotes.html add March release notes
 20090324 tpd src/axiom-website/patches.html move the patch frontier
diff --git a/src/axiom-website/download.html b/src/axiom-website/download.html
index c4daad7..c73df94 100644
--- a/src/axiom-website/download.html
+++ b/src/axiom-website/download.html
@@ -166,6 +166,11 @@
        Jan 2009
       </font>
      </td>
+     <td align="center">
+      <font face="Helvetica, Arial, sans-serif" size="+1">
+       Mar 2009
+      </font>
+     </td>
     </tr>
 
     <tr>
@@ -218,6 +223,10 @@
       <a href="downloads/axiom-debian-jan2009-bin.tgz">bin</a>
       </font>
      </td>
+     <td align="center">
+      <font face="Helvetica, Arial, sans-serif" size="+1">
+      </font>
+     </td>
     </tr>
 
     <tr>
@@ -261,6 +270,10 @@
       <a href="downloads/axiom-nov2008-src.tgz">src</a>
       </font>
      </td>
+     <td align="center">
+      <font face="Helvetica, Arial, sans-serif" size="+1">
+      </font>
+     </td>
     </tr>
 
     <tr>
@@ -298,6 +311,10 @@
       <font face="Helvetica, Arial, sans-serif" size="+1">
       </font>
      </td>
+     <td align="center">
+      <font face="Helvetica, Arial, sans-serif" size="+1">
+      </font>
+     </td>
     </tr>
 
     <tr>
@@ -348,6 +365,10 @@
       <a href="downloads/axiom-fedora5-nov2008-bin.tgz">bin</a>
       </font>
      </td>
+     <td align="center">
+      <font face="Helvetica, Arial, sans-serif" size="+1">
+      </font>
+     </td>
     </tr>
 
     <tr>
@@ -404,6 +425,10 @@
       <a href="downloads/axiom-fedora6-jan2009-bin.tgz">bin</a>
       </font>
      </td>
+     <td align="center">
+      <font face="Helvetica, Arial, sans-serif" size="+1">
+      </font>
+     </td>
     </tr>
 
     <tr>
@@ -458,6 +483,10 @@
       <a href="downloads/axiom-fedora7-jan2009-bin.tgz">bin</a>
       </font>
      </td>
+     <td align="center">
+      <font face="Helvetica, Arial, sans-serif" size="+1">
+      </font>
+     </td>
     </tr>
 
     <tr>
@@ -514,6 +543,10 @@
       <a href="downloads/axiom-fedora8-jan2009-bin.tgz">bin</a>
       </font>
      </td>
+     <td align="center">
+      <font face="Helvetica, Arial, sans-serif" size="+1">
+      </font>
+     </td>
     </tr>
 
     <tr>
@@ -555,6 +588,10 @@
       <a href="downloads/axiom-nov2008-src.tgz">src</a>
       </font>
      </td>
+     <td align="center">
+      <font face="Helvetica, Arial, sans-serif" size="+1">
+      </font>
+     </td>
     </tr>
 
     <tr>
@@ -605,6 +642,10 @@
       <a href="downloads/axiom-fedora9-jan2009-bin.tgz">bin</a>
       </font>
      </td>
+     <td align="center">
+      <font face="Helvetica, Arial, sans-serif" size="+1">
+      </font>
+     </td>
     </tr>
 
 
@@ -648,6 +689,12 @@
       <a href="downloads/axiom-fedora10-jan2009-bin.tgz">bin</a>
       </font>
      </td>
+     <td align="center">
+      <font face="Helvetica, Arial, sans-serif" size="+1">
+      <a href="downloads/axiom-mar2009-src.tgz">src</a>
+      <a href="downloads/axiom-fedora10-mar2009-bin.tgz">bin</a>
+      </font>
+     </td>
     </tr>
 
     <tr>
@@ -688,6 +735,10 @@
       <font face="Helvetica, Arial, sans-serif" size="+1">
       </font>
      </td>
+     <td align="center">
+      <font face="Helvetica, Arial, sans-serif" size="+1">
+      </font>
+     </td>
     </tr>
 
     <tr>
@@ -741,6 +792,10 @@
       <a href="downloads/axiom-opensuse-jan2009-bin.tgz">bin</a>
       </font>
      </td>
+     <td align="center">
+      <font face="Helvetica, Arial, sans-serif" size="+1">
+      </font>
+     </td>
     </tr>
 
     <tr>
@@ -795,6 +850,10 @@
       <a href="downloads/axiom-redhat72-jan2009-bin.tgz">bin</a>
       </font>
      </td>
+     <td align="center">
+      <font face="Helvetica, Arial, sans-serif" size="+1">
+      </font>
+     </td>
     </tr>
 
     <tr>
@@ -849,6 +908,10 @@
       <a href="downloads/axiom-redhat9-jan2009-bin.tgz">bin</a>
       </font>
      </td>
+     <td align="center">
+      <font face="Helvetica, Arial, sans-serif" size="+1">
+      </font>
+     </td>
     </tr>
 
     <tr>
@@ -903,6 +966,10 @@
       <a href="downloads/axiom-ubuntu-jan2009-bin.tgz">bin</a>
       </font>
      </td>
+     <td align="center">
+      <font face="Helvetica, Arial, sans-serif" size="+1">
+      </font>
+     </td>
     </tr>
 
     <tr>
@@ -947,6 +1014,10 @@
       <a href="downloads/axiom-ubuntu64-jan2009-bin.tgz">bin</a>
       </font>
      </td>
+     <td align="center">
+      <font face="Helvetica, Arial, sans-serif" size="+1">
+      </font>
+     </td>
     </tr>
 
     <tr>
@@ -990,6 +1061,10 @@
       <a href="downloads/axiom-vector-jan2009-bin.tgz">bin</a>
       </font>
      </td>
+     <td align="center">
+      <font face="Helvetica, Arial, sans-serif" size="+1">
+      </font>
+     </td>
     </tr>
    </tbody>
   </table>
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index 0106d43..c0b1068 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -1024,5 +1024,7 @@ March 2009 release<br/>
 <a name="latest"/>
 In process, not yet released<br/><br/>
   <hr>
+<a href="patches/20090325.01.tpd.patch">20090325.01.tpd.patch</a>
+download.html add March 2009 column, add fedora10 binary<br/>
  </body>
 </html>



From MAILER-DAEMON Thu Mar 26 03:56:36 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LmkS4-0006sH-Cq
	for mharc-axiom-developer@gnu.org; Thu, 26 Mar 2009 03:56:36 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LmkS2-0006rz-Ie
	for axiom-developer@nongnu.org; Thu, 26 Mar 2009 03:56:34 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LmkRy-0006rm-R3
	for axiom-developer@nongnu.org; Thu, 26 Mar 2009 03:56:34 -0400
Received: from [199.232.76.173] (port=56794 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43)
	id 1LmkRy-0006rj-LZ; Thu, 26 Mar 2009 03:56:30 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:36629
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>)
	id 1LmkRx-0008IK-QF; Thu, 26 Mar 2009 03:56:30 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n2Q7uOug031851;
	Thu, 26 Mar 2009 01:56:26 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n2Q7uN3o031845;
	Thu, 26 Mar 2009 01:56:23 -0600
Date: Thu, 26 Mar 2009 01:56:23 -0600
Message-Id: <200903260756.n2Q7uN3o031845@axiom-developer.org>
To: "Simon Blomberg" <s.blomberg1@uq.edu.au>
X-detected-operating-system: by monty-python.gnu.org: Error: This connection
	is not (no longer?) in the cache.
Cc: axiom-developer@nongnu.org, axiom-mail@nongnu.org
Subject: [Axiom-developer] Programming with the Tree domain
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Thu, 26 Mar 2009 07:56:34 -0000

If you are using the latest March 2009 sources (See
  http://axiom-developer.org/axiom-website/download.html

you'll find that there are several sources of information about trees.

First, there is the actual Tree domain (attached below)

which is contained in Book Volume 10.3: Axiom Algebra Domains (See
  http://axiom-developer.org/axiom-website/bookvol10.3.pdf



Second, if you look at the tree domain sources below you will see
various functions that are available. You will also see lines that
begin with --X which are examples of using each function.  These
examples will show up if you display the operation, such as:

  )display op cyclic?




Third, Book Volume 0: Axiom Jenks and Sutor (See:
  http://axiom-developer.org/axiom-website/documentation.html
  http://axiom-developer.org/axiom-website/bookvol0.pdf

has a few references to the tree domain (e.g. p93). See
  BalancedBinaryTree (BBTREE) in section 9.2 of volume 0 and
  BinarySearchTree (BSTREE) in section 9.4 of volume 0.




Fourth, in a running Axiom there are several "tree" domains which you 
can find by typing:

  )apropos tree
  


Fifth, there is domain specific information you can get with:

  )show BalancedBinaryTree
  )show BinarySearchTree
  )show Tree

You can get some help on these by typing:

  )help BalancedBinaryTree
  )help BinarySearchTree

or you can use their abbreviations:

  )help BBTREE
  )help BSTREE



Sixth, in the $AXIOM/doc/src/input directory there is a .dvi
file for bbtree, bstree, and tree:

 xdvi $AXIOM/doc/src/input/bbtree.input.dvi 
 xdvi $AXIOM/doc/src/input/bstree.input.dvi 
 xdvi $AXIOM/doc/src/input/tree.input.dvi 



Seventh, if you start Axiom and use Hyperdoc you can do:

  Reference -> Examples -> BalancedBinaryTree 
  Reference -> Examples -> BinarySearchTree



and finally, the corresponding input files can be read into Axiom using:

  )read /home/simon/axiom/mnt/fedora10/input/bbtree.input
  )read /home/simon/axiom/mnt/fedora10/input/bstree.input
  )read /home/simon/axiom/mnt/fedora10/input/tree.input


Feel free to post further questions.

Tim

======================================================================
 tree.spad
======================================================================
)abbrev domain TREE Tree
++ Author:W. H. Burge
++ Date Created:17 Feb 1992
++ Date Last Updated:
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description: \spadtype{Tree(S)} is a basic domains of tree structures.
++ Each tree is either empty or else is a {\it node} consisting of a value and
++ a list of (sub)trees.
Tree(S: SetCategory): T==C where
 T== RecursiveAggregate(S) with
     finiteAggregate
     shallowlyMutable
     tree: (S,List %) -> %
       ++ tree(nd,ls) creates a tree with value nd, and children ls.
       ++
       ++X t1:=tree [1,2,3,4]
       ++X tree(5,[t1])

     tree: List S -> %
       ++ tree(ls) creates a tree from a list of elements of s. 
       ++
       ++X tree [1,2,3,4]

     tree: S -> %
       ++ tree(nd) creates a tree with value nd, and no children
       ++
       ++X tree 6

     cyclic?: % -> Boolean
       ++ cyclic?(t) tests if t is a cyclic tree.
       ++
       ++X t1:=tree [1,2,3,4]
       ++X cyclic? t1

     cyclicCopy: % -> %
       ++ cyclicCopy(l) makes a copy of a (possibly) cyclic tree l.
       ++
       ++X t1:=tree [1,2,3,4]
       ++X cyclicCopy t1

     cyclicEntries:    % -> List %
       ++ cyclicEntries(t) returns a list of top-level cycles in tree t.
       ++
       ++X t1:=tree [1,2,3,4]
       ++X cyclicEntries t1

     cyclicEqual?: (%, %) -> Boolean
       ++ cyclicEqual?(t1, t2) tests of two cyclic trees have 
       ++ the same structure.
       ++
       ++X t1:=tree [1,2,3,4]
       ++X t2:=tree [1,2,3,4]
       ++X cyclicEqual?(t1,t2)

     cyclicParents: % -> List %
       ++ cyclicParents(t) returns a list of cycles that are parents of t.
       ++
       ++X t1:=tree [1,2,3,4]
       ++X cyclicParents t1

 C== add
    cycleTreeMax ==> 5

    Rep := Union(node:Record(value: S, args: List %),empty:"empty")
    t:%
    br:%
    s: S
    ls: List S
    empty? t == t case empty
    empty()  == ["empty"]
    children t == 
      t case empty => error "cannot take the children of an empty tree" 
      (t.node.args)@List(%)
    setchildren_!(t,lt) == 
      t case empty => error "cannot set children of an empty tree"
      (t.node.args:=lt;t pretend %)
    setvalue_!(t,s) == 
      t case empty => error "cannot set value of an empty tree"
      (t.node.value:=s;s)
    count(n, t) == 
      t case empty => 0
      i := +/[count(n, c) for c in children t]
      value t = n => i + 1
      i
    count(fn: S -> Boolean, t: %): NonNegativeInteger ==
      t case empty => 0
      i := +/[count(fn, c) for c in children t]
      fn value t => i + 1
      i
    map(fn, t) == 
      t case empty => t
      tree(fn value t,[map(fn, c) for c in children t])
    map_!(fn, t) == 
      t case empty => t
      setvalue_!(t, fn value t)
      for c in children t repeat map_!(fn, c)
    tree(s,lt) == [[s,lt]]
    tree(s) == [[s,[]]]
    tree(ls) ==
      empty? ls => empty()
      tree(first ls, [tree s for s in rest ls])
    value t ==
      t case empty => error "cannot take the value of an empty tree" 
      t.node.value
    child?(t1,t2) == 
      empty? t2 => false
      "or"/[t1 = t for t in children t2]
    distance1(t1: %, t2: %): Integer ==
      t1 = t2 => 0
      t2 case empty => -1
      u := [n for t in children t2 | (n := distance1(t1,t)) >= 0]
      #u > 0 => 1 + "min"/u 
      -1 
    distance(t1,t2) == 
      n := distance1(t1, t2)
      n >= 0 => n
      distance1(t2, t1)
    node?(t1, t2) ==
      t1 = t2 => true
      t case empty => false
      "or"/[node?(t1, t) for t in children t2]
    leaf? t == 
      t case empty => false
      empty? children t
    leaves t == 
      t case empty => empty()
      leaf? t => [value t]
      "append"/[leaves c for c in children t]
    less? (t, n) == # t < n
    more?(t, n) == # t > n
    nodes t ==       ---buggy
      t case empty => empty()
      nl := [nodes c for c in children t]
      nl = empty() => [t]
      cons(t,"append"/nl)
    size? (t, n) == # t = n
    any?(fn, t) ==  ---bug fixed
      t case empty => false
      fn value t or "or"/[any?(fn, c) for c in children t]
    every?(fn, t) == 
      t case empty => true
      fn value t and "and"/[every?(fn, c) for c in children t]
    member?(n, t) == 
      t case empty => false
      n = value t or "or"/[member?(n, c) for c in children t]
    members t == parts t
    parts t == --buggy?
      t case empty => empty()
      u := [parts c for c in children t]
      u = empty() => [value t]
      cons(value t,"append"/u)
 
    ---Functions that guard against cycles: =, #, copy-------------

    -----> =   
    equal?: (%, %, %, %, Integer) -> Boolean

    t1 = t2 == equal?(t1, t2, t1, t2, 0) 

    equal?(t1, t2, ot1, ot2, k) ==
      k = cycleTreeMax and (cyclic? ot1 or cyclic? ot2) => 
        error "use cyclicEqual? to test equality on cyclic trees"
      t1 case empty => t2 case empty
      t2 case empty => false
      value t1 = value t2 and (c1 := children t1) = (c2 := children t2) and
        "and"/[equal?(x,y,ot1, ot2,k + 1) for x in c1 for y in c2]

    -----> #
    treeCount: (%, %, NonNegativeInteger) -> NonNegativeInteger    
    # t == treeCount(t, t, 0)
    treeCount(t, origTree, k) ==
      k = cycleTreeMax and cyclic? origTree => 
        error "# is not defined on cyclic trees"
      t case empty => 0
      1 + +/[treeCount(c, origTree, k + 1) for c in children t]
 
    -----> copy
    copy1: (%, %, Integer) -> %
    copy t == copy1(t, t, 0)
    copy1(t, origTree, k) == 
      k = cycleTreeMax and cyclic? origTree => 
        error "use cyclicCopy to copy a cyclic tree"
      t case empty  => t
      empty? children t => tree value t
      tree(value t, [copy1(x, origTree, k + 1) for x in children t])
      
    -----------Functions that allow cycles---------------
    --local utility functions:
    eqUnion: (List %, List %) -> List %
    eqMember?: (%, List %) -> Boolean
    eqMemberIndex: (%, List %, Integer) -> Integer
    lastNode: List % -> List %
    insert: (%, List %) -> List %

    -----> coerce to OutputForm
    if S has SetCategory then
      multipleOverbar: (OutputForm, Integer, List %) -> OutputForm
      coerce1: (%, List %, List %) -> OutputForm

      coerce(t:%): OutputForm == coerce1(t, empty()$(List %), cyclicParents t)

      coerce1(t,parents, pl) ==
        t case empty => empty()@List(S)::OutputForm
        eqMember?(t, parents) => 
          multipleOverbar((".")::OutputForm,eqMemberIndex(t, pl,0),pl)
        empty? children t => value t::OutputForm
        nodeForm := (value t)::OutputForm
        if (k := eqMemberIndex(t, pl, 0)) > 0 then
           nodeForm := multipleOverbar(nodeForm, k, pl)
        prefix(nodeForm, 
          [coerce1(br,cons(t,parents),pl) for br in children t])

      multipleOverbar(x, k, pl) ==
        k < 1 => x
        #pl = 1 => overbar x
        s : String := "abcdefghijklmnopqrstuvwxyz"
        c := s.(1 + ((k - 1) rem 26))
        overlabel(c::OutputForm, x)
 
    -----> cyclic?
    cyclic2?: (%, List %) -> Boolean

    cyclic? t == cyclic2?(t, empty()$(List %))

    cyclic2?(x,parents) ==  
      empty? x => false
      eqMember?(x, parents) => true
      for y in children x repeat
        cyclic2?(y,cons(x, parents)) => return true
      false
 
    -----> cyclicCopy
    cyclicCopy2: (%, List %) -> %
    copyCycle2: (%, List %) -> %
    copyCycle4: (%, %, %, List %) -> %

    cyclicCopy(t) == cyclicCopy2(t, cyclicEntries t)

    cyclicCopy2(t, cycles) ==
      eqMember?(t, cycles) => return copyCycle2(t, cycles)
      tree(value t, [cyclicCopy2(c, cycles) for c in children t])
   
    copyCycle2(cycle, cycleList) == 
      newCycle := tree(value cycle, nil)
      setchildren!(newCycle,
        [copyCycle4(c,cycle,newCycle, cycleList) for c in children cycle])
      newCycle

    copyCycle4(t, cycle, newCycle, cycleList) == 
      empty? cycle => empty()
      eq?(t, cycle) => newCycle
      eqMember?(t, cycleList) => copyCycle2(t, cycleList)
      tree(value t,
           [copyCycle4(c, cycle, newCycle, cycleList) for c in children t])

    -----> cyclicEntries
    cyclicEntries3: (%, List %, List %) -> List %

    cyclicEntries(t) == cyclicEntries3(t, empty()$(List %), empty()$(List %))

    cyclicEntries3(t, parents, cl) ==
      empty? t => cl
      eqMember?(t, parents) => insert(t, cl)
      parents := cons(t, parents)
      for y in children t repeat
        cl := cyclicEntries3(t, parents, cl)
      cl
   
    -----> cyclicEqual?
    cyclicEqual4?: (%, %, List %, List %) -> Boolean

    cyclicEqual?(t1, t2) ==
      cp1 := cyclicParents t1
      cp2 := cyclicParents t2
      #cp1 ^= #cp2 or null cp1 => t1 = t2
      cyclicEqual4?(t1, t2, cp1, cp2)

    cyclicEqual4?(t1, t2, cp1, cp2) == 
      t1 case empty => t2 case empty
      t2 case empty => false
      0 ^= (k := eqMemberIndex(t1, cp1, 0)) => eq?(t2, cp2 . k)
      value t1 = value t2 and 
        "and"/[cyclicEqual4?(x,y,cp1,cp2) 
                 for x in children t1 for y in children t2]

    -----> cyclicParents t
    cyclicParents3: (%, List %, List %) -> List %

    cyclicParents t == cyclicParents3(t, empty()$(List %), empty()$(List %))

    cyclicParents3(x, parents, pl) ==
      empty? x => pl
      eqMember?(x, parents) => 
        cycleMembers := [y for y in parents while not eq?(x,y)]
        eqUnion(cons(x, cycleMembers), pl)
      parents := cons(x, parents)
      for y in children x repeat 
        pl := cyclicParents3(y, parents, pl)
      pl

    insert(x, l) ==
      eqMember?(x, l) => l
      cons(x, l)

    lastNode l ==
      empty? l => error "empty tree has no last node"
      while not empty? rest l repeat l := rest l
      l

    eqMember?(y,l) ==
      for x in l repeat eq?(x,y) => return true
      false

    eqMemberIndex(x, l, k) ==
      null l => k
      k := k + 1
      eq?(x, first l) => k
      eqMemberIndex(x, rest l, k)

    eqUnion(u, v) ==
      null u => v
      x := first u
      newV :=
        eqMember?(x, v) => v
        cons(x, v)
      eqUnion(rest u, newV)

@



From MAILER-DAEMON Thu Mar 26 18:41:33 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LmyGT-0000h7-Jx
	for mharc-axiom-developer@gnu.org; Thu, 26 Mar 2009 18:41:33 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LmyGS-0000fc-4s
	for axiom-developer@nongnu.org; Thu, 26 Mar 2009 18:41:32 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LmyGM-0000Zh-UI
	for axiom-developer@nongnu.org; Thu, 26 Mar 2009 18:41:31 -0400
Received: from [199.232.76.173] (port=35410 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LmyGM-0000ZV-Oe
	for axiom-developer@nongnu.org; Thu, 26 Mar 2009 18:41:26 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:55027
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LmyGL-0006A7-D4
	for axiom-developer@nongnu.org; Thu, 26 Mar 2009 18:41:26 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n2QMfNug019677;
	Thu, 26 Mar 2009 16:41:23 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n2QMfNmx019670;
	Thu, 26 Mar 2009 16:41:23 -0600
Date: Thu, 26 Mar 2009 16:41:23 -0600
Message-Id: <200903262241.n2QMfNmx019670@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090326.01.tpd.patch (bookvol4: Finding
	Signature)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Thu, 26 Mar 2009 22:41:32 -0000

This post captures, documents, and expands upon the technique used
by Waldek to find anonymous function signatues. The new section was
added to Book Volume 4: Axiom Developers Guide. The Axiom and Fricas
code seem to differ considerably for this function, which is odd.
======================================================================
diff --git a/books/bookvol4.pamphlet b/books/bookvol4.pamphlet
index d06e4c3..a16e645 100644
--- a/books/bookvol4.pamphlet
+++ b/books/bookvol4.pamphlet
@@ -3553,6 +3553,254 @@ occur in algebra code. This section walks thru a small problem and
 illustrates some techniques that can be used to find bugs. The 
 point of this exercise is to show a few techniques, not to show a
 general method.
+\subsection{Finding Anonymous Function Signatures}
+This is a technique, adapted from Waldek Hebisch, 
+for asking the interpreter to reveal the actual
+function that will be called in a given circumstance. Here we have a
+function tanint from the domain ElementaryIntegration. 
+\begin{verbatim}
+     tanint(f, x, k) ==
+       eta' := differentiate(eta := first argument k, x)
+       r1  := tanintegrate(univariate(f, k), differentiate(#1,
+               differentiate(#1, x), monomial(eta', 2) + eta'::UP),
+                 rischDEsys(#1, 2 * eta, #2, #3, x, lflimitedint(#1, x, #2),
+                    lfextendedint(#1, x, #2)))
+       map(multivariate(#1, k), r1.answer) + lfintegrate(r1.a0, x)
+\end{verbatim}
+
+We would like to know the type signature of the first argument to the 
+inner call to the differentiate function:
+\begin{verbatim}
+               differentiate(#1, x), monomial(eta', 2) + eta'::UP),
+\end{verbatim}
+
+We see that differentiate is called with \verb|#1|, which is Axiom's
+notation for an anonymous function. How can we determine the signature?
+
+Axiom has a second notation for anonymous functions using the 
+\verb|+->| notation. This notation allows you to explicitly specify
+type information. In the above code, we would like to replace the
+\verb|#1| variable with the \verb|+->| and explicit type information.
+
+The first step is to look at the output of the Spad compiler. 
+The abbreviation for ElementaryIntegration can be found from the 
+interpreter by:
+\begin{verbatim}
+  )show ElementaryIntegration
+    Abbreviation for ElementaryIntegration is INTEF 
+\end{verbatim}
+
+So the compiler output is in the int/algebra/INTEF.nrlib/code.lsp file.
+
+There we see the definition of the lisp tanint function. Notice that the
+\verb|$| is a hidden, internal fourth argument to an Axiom three argument
+function. This is the vector of the current domain containing slots where
+we can look up information, called the domain vector.
+
+\begin{verbatim}
+(DEFUN |INTEF;tanint| (|f| |x| |k| $)
+ (PROG (|eta| |eta'| |r1|)
+  (RETURN
+   (SEQ
+    (LETT |eta'|
+     (SPADCALL
+       (LETT |eta|
+        (|SPADfirst|
+          (SPADCALL |k| (QREFELT $ 18)))
+          |INTEF;tanint|)
+       |x|
+       (QREFELT $ 19))
+     |INTEF;tanint|)
+    (LETT |r1|
+     (SPADCALL
+       (SPADCALL |f| |k| (QREFELT $ 22))
+       (CONS (FUNCTION |INTEF;tanint!1|) (VECTOR |eta'| |x| $))
+       (CONS (FUNCTION |INTEF;tanint!4|) (VECTOR |x| $ |eta|))
+       (QREFELT $ 50))
+     |INTEF;tanint|)
+    (EXIT
+     (SPADCALL
+      (SPADCALL 
+        (CONS 
+          (FUNCTION |INTEF;tanint!5|)
+          (VECTOR $ |k|))
+        (QCAR |r1|)
+        (QREFELT $ 57))
+      (SPADCALL (QCDR |r1|) |x| (QREFELT $ 58))
+      (QREFELT $ 59))))))) 
+\end{verbatim}
+
+The assignment line for \verb|eta'| is:
+\begin{verbatim}
+       eta' := differentiate(eta := first argument k, x)
+\end{verbatim}
+which is implemented by the code:
+\begin{verbatim}
+    (LETT |eta'|
+     (SPADCALL
+       (LETT |eta|
+        (|SPADfirst|
+          (SPADCALL |k| (QREFELT $ 18)))
+          |INTEF;tanint|)
+       |x|
+       (QREFELT $ 19))
+     |INTEF;tanint|)
+\end{verbatim}
+from which we see that the inner differentiate is slot 19 in
+the domain vector. Every domain has an associated domain vector
+which contains references to other functions from other domains,
+among other things. The QREFELT function takes the domain vector
+\verb|$| and slot number and does a "quick array reference". The
+return value is a pair, the car of which is a function to call. 
+The SPADCALL macro uses the last argument, in this case the result 
+of \verb|(QREFELT $ 19)| to find the function to call.
+
+The function from slot 19 can be found with:
+\begin{verbatim}
+)lisp (setq $dalymode t)
+(setf *print-circle* t)
+(setf *print-array* nil)
+(setf dv (|ElementaryIntegration| (|Integer|) (|Expression| (|Integer|))))
+(|replaceGoGetSlot| (cdr (aref dv 19)))
+Value = (#<compiled-function |FS-;differentiate;SSS;99|> . #<vector 090cbccc>)
+\end{verbatim}
+
+The call of \verb|(setq $dalymode t)| changes the Axiom top level
+loop to interpret any input that begins with an open parenthesis to
+be interpreted as a lisp s-expression rather than Axiom input. This
+saves typing \verb|)lisp| in front of every lisp expression. Be sure
+to do a \verb|(setq $dalymode nil)| when you are finished.
+
+The *print-circle* needs to be true because the domain vector contains
+circular references to itself and we need to make sure that we check for
+this during printing so the print is not infinite.
+
+The *print-array* needs to be nil so that the arrays just print some
+identifying information rather than the detailed array contents.
+
+The \verb|(setf dv ...| uses the Lisp internal names for the domains.
+In Axiom, the names of types are case-sensitive symbols. These are
+represented in lisp surrounded by vertical bars because lisp is not
+case sensitive. The dv variable is essentially being set to the Axiom
+equivalent of:
+\begin{verbatim}
+  dv:=ElementaryIntegration(Integer,Expression(Integer))
+\end{verbatim}
+except we do this in lisp. The end result is that dv will contain the
+domain vector for the newly constructed domain. From the lisp code
+
+Consider the call of the form:
+\begin{verbatim}
+  (SPADCALL A B '(C . D))
+\end{verbatim}
+
+The SPADCALL macro takes a set of arguments, the last of which is 
+a pair where C is the function to call and D is the domain vector. 
+So if we do:
+\begin{verbatim}
+(macroexpand-1 '(spadcall a b '(c . d)))
+Value =
+  (LET ((#0=#:G1417 (QUOTE (C . D))))
+   (THE (VALUES T) (FUNCALL (CAR #0#) A B (CDR #0#))))
+\end{verbatim}
+Note that \verb|#0| is a "pointer", in this case to the list '(c)
+and \verb|#0#| is a use of that pointer. This is done to make sure that
+you reference the exact cons cell of the argument.
+
+In Axiom compiler output
+\begin{verbatim}
+  (SPADCALL eta k (QREFELT $ 19))
+\end{verbatim}
+approximately translates to
+\begin{verbatim}
+  (FUNCALL (CAR (QREFELT $ 19)) eta k (CDR (QREFELT $ 19)))
+\end{verbatim}
+which calls the function from the domain slot 19 on the value
+assigned to eta and the variable k and the domain. 
+Thus, the full expansion becomes
+\begin{verbatim}
+  (FUNCALL #<compiled-function |FS-;differentiate;SSS;99|>
+    eta k #<vector 090cbccc>)
+\end{verbatim}
+
+From this we can see a reference to \verb|FS-;differentiate;SSS;99|
+which is the internal name of the differentiate function from the 
+\verb|FS-| category.
+
+Note that FunctionSpace is a category. When categories contain
+implementation code the compiler generates 2 nrlibs. The Axiom convention for
+categorical implementation of code using a trailing ``-'' so the actual
+code for \verb|FS-;differentiate;SSS;99| lives in 
+int/algebra/FS-.nrlib/code.lsp
+
+We can see that the differentiate function is coming from the category
+\begin{verbatim}
+)show FS
+ FunctionSpace R: OrderedSet  is a category constructor
+ Abbreviation for FunctionSpace is FS 
+
+ ....
+
+ differentiate : (%,Symbol) -> % if R has RING
+ differentiate : (%,List Symbol) -> % if R has RING
+ differentiate : (%,Symbol,NonNegativeInteger) -> % if R has RING
+ differentiate : (%,List Symbol,List NonNegativeInteger) -> % if R has RING
+\end{verbatim}
+
+From the above signatures we know there is only one differentiate that
+is a two argument form so the call 
+\begin{verbatim}
+               differentiate(#1, x), monomial(eta', 2) + eta'::UP),
+\end{verbatim}
+must be the first instance.
+
+From the sources (bookvol10.4) we see that the tanint function has 
+the signature:
+\begin{verbatim}
+    tanint      : (F, SE, K) -> IR
+\end{verbatim}
+and that 
+\begin{verbatim}
+  SE  ==> Symbol
+  F : Join(AlgebraicallyClosedField, TranscendentalFunctionCategory,
+           FunctionSpace R)
+  K   ==> Kernel F
+\end{verbatim}
+
+The differentiate function takes something of type F and a Symbol
+and returns something of type F. If we write this as an anonymous
+function it becomes:
+\begin{verbatim}
+   (x2 : F) : F +-> differentiate(x2, x)
+\end{verbatim}
+
+Thus, we can rewrite the differentiate call as:
+\begin{verbatim}
+               differentiate(#1, x), monomial(eta', 2) + eta'::UP),
+\end{verbatim}
+as
+\begin{verbatim}
+                   (x2 : F) : F +-> differentiate(x2, x),
+                   monomial(eta', 2) + eta'::UP),
+\end{verbatim}
+
+
+Continuing in this way we can fully rewrite the assignments as:
+\begin{verbatim}
+       r1  := tanintegrate(univariate(f, k),
+                (x1 : UP) : UP +-> differentiate(x1,
+                   (x2 : F) : F +-> differentiate(x2, x),
+                   monomial(eta', 2) + eta'::UP),
+                (x6 : Integer, x2 : F, x3 : F) : Union(List F, "failed") +->
+                   rischDEsys(x6, 2 * eta, x2, x3, x,
+                     (x4 : F, x5 : List F) : U3 +-> lflimitedint(x4, x, x5),
+                     (x4 : F, x5 : F) : U2 +-> lfextendedint(x4, x, x5)))
+       map((x1 : RF) : F +-> multivariate(x1, k), r1.answer) + _
+             lfintegrate(r1.a0, x)
+\end{verbatim}
+
+Note that rischDEsys is tricky, because rischDEsys returns only List F,
+but tanintegrate expects union. 
 \subsection{The example bug}
 Axiom can generate TeX output by typing:
 \begin{verbatim}
diff --git a/changelog b/changelog
index 922d05e..92ae214 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,5 @@
+20090326 tpd src/axiom-website/patches.html 20090326.01.tpd.patch
+20090326 tpd books/bookvol4 Finding Anonymous Function Signatures
 20090325 tpd src/axiom-website/patches.html 20090325.01.tpd.patch
 20090325 tpd src/axiom-website/download.html add March 2009 column
 20090324 tpd src/axiom-website/patches.html 20090324.01.tpd.patch
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index c0b1068..9d8fe52 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -1026,5 +1026,7 @@ In process, not yet released<br/><br/>
   <hr>
 <a href="patches/20090325.01.tpd.patch">20090325.01.tpd.patch</a>
 download.html add March 2009 column, add fedora10 binary<br/>
+<a href="patches/20090326.01.tpd.patch">20090326.01.tpd.patch</a>
+bookvol4 Finding Anonymous Function Signatures<br/>
  </body>
 </html>



From MAILER-DAEMON Fri Mar 27 13:04:59 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LnFUJ-0006FS-Bp
	for mharc-axiom-developer@gnu.org; Fri, 27 Mar 2009 13:04:59 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LnFUH-0006C9-9D
	for axiom-developer@nongnu.org; Fri, 27 Mar 2009 13:04:57 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LnFUC-00061Y-3p
	for axiom-developer@nongnu.org; Fri, 27 Mar 2009 13:04:56 -0400
Received: from [199.232.76.173] (port=45407 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LnFUB-00061I-Su
	for axiom-developer@nongnu.org; Fri, 27 Mar 2009 13:04:51 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:57280
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LnFUB-00019f-AW
	for axiom-developer@nongnu.org; Fri, 27 Mar 2009 13:04:51 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n2RH4aug008117;
	Fri, 27 Mar 2009 11:04:36 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n2RH4Zbl008114;
	Fri, 27 Mar 2009 11:04:35 -0600
Date: Fri, 27 Mar 2009 11:04:35 -0600
Message-Id: <200903271704.n2RH4Zbl008114@axiom-developer.org>
To: "Alex Plotnick" <plotnick@cs.brandeis.edu>, heow@alphageeksinc.com
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: axiom-developer@nongnu.org
Subject: [Axiom-developer] (no subject)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Fri, 27 Mar 2009 17:04:57 -0000

Alex, Heow,

This is a piece of code that extracts source code from a literate file.
The literate file is assumed to be latex. There are two type of syntax
used in Axiom. One is the standard noweb syntax:

  <<thechunkname>>=    -- define the chunkname
  @                    -- end the chunkname
  <<thechunkname>>     -- use the chunkname

The other is a latex syntax:

  \begin{chunk}{thechunkname}  ==> 'define thechunkname
  \end{chunk}                  ==> 'end nil
  \chunk{thechunkname}         ==> 'refer thechunkname

This code will extract a chunk using either syntax:

  (tangle "clweb.pamphlet" "<<*>>")  <== noweb syntax
  (tangle "clweb.pamphlet "*")       <== latex syntax (default)




Axiom is in the process of transitioning from using noweb syntax to
using latex syntax. There are several reasons for this transition.

First, using latex syntax means that the source files (called pamphlets
in Axiom) are now pure latex so there is no need for a "weave" program.
This eliminates one step in the build chain.

Second, using lisp code rather than noweb means that Axiom can read
and understand its own source files without a system call to noweb.

Third, I can extend the system in any way that is useful such as
supporting "inlined" chunks. The noweb code does not seem to allow
me to use chunks in code:

  (defun standardfn <<standardargs>> 
    .... )

but I can easily write a latex macro such as 

  (defun standardfn \inline{standardargs}
    .... )

which latex will properly expand and which my tangle code will
properly expand.

So the upshot is that by using lisp code rather than noweb I can
eliminate a subsystem, eliminate build steps, eliminate system calls
from lisp, distribute standard latex files as sources, and make the
system dynamically extensible with lisp.

Tim


===============================================================
;;; This program will extract the source code from a literate file

;;; The *chunkhash* variable will hold the hash table of chunks.

(defvar *chunkhash* nil)

;  (tangle "clweb.pamphlet" "<<*>>")  <== noweb syntax
;  (tangle "clweb.pamphlet "*")       <== latex syntax (default)

;;; tangle takes the name of a file and the chunk to expand
;;; 
(defun tangle (filename topchunk)
  (setq *chunkhash* (make-hash-table :test #'equal))
  (hashchunks (gcl-read-file filename))
  (expand topchunk))

;;; gcl-read-file
;;;
;;; This would be read-sequence in ansi common lisp. Here we read
;;; a line, push it onto a stack and then reverse the stack. The
;;; net effect is a list of strings, one per line of the file.

(defun gcl-read-file (streamname)
 (let (result)
  (with-open-file (stream (open streamname))
   (do (line eof)
      ((eq line 'done) (nreverse result))
    (multiple-value-setq (line eof) (read-line stream nil 'done)) 
    (unless (eq line 'done) (push line result))))))

;;; hashchunks gathers the chunks and puts them in the hash table
;;;
;;; if we find the chunk syntax and it is a
;;;   define ==> parse the chunkname and start gathering lines onto a stack
;;;   end    ==> push the completed list of lines into a stack of chunks
;;;              already in the hash table
;;;   otherwise ==> if we are gathering, push the line onto the stack

;;; a hash table entry is a list of lists such as
;;; (("6" "5") ("4" "3") ("2" "1"))
;;; each of the sublists is a set of lines in reverse (stack) order
;;; each sublist is a single chunk of lines. 
;;; there is a new sublist for each reuse of the same chunkname

(defun hashchunks (lines)
 (let (type name chunkname oldchunks chunk gather)
  (dolist (line lines)
   (multiple-value-setq (type name) (ischunk-latex line))
   (cond
    ((eq type 'define)
      (setq chunkname name)
      (setq gather t))
    ((eq type 'end)
      ;(format t "name= ~a chunk=~s~%" chunkname chunk)
      (setq oldchunks (gethash chunkname *chunkhash*))
      (setf (gethash chunkname *chunkhash*) (push chunk oldchunks))
      (setq gather nil)
      (setq chunk nil))
     (gather 
      (push line chunk))))))

;;; expand will recursively expand chunks in the hash table
;;; 
;;; latex chunk names are just the chunkname itself e.g. chunkname
;;; noweb chunk names include the delimiters, e.g: <<chunkname>>

;;; a hash table entry is a list of lists such as
;;; (("6" "5") ("4" "3") ("2" "1"))
;;; so to process the chunk we reverse the main list and
;;; for each sublist we reverse the sublist and process the lines

;;; if a chunk name reference is encountered in a line we call expand
;;; recursively to expand the inner chunkname.

(defun expand (chunk)
 (let ((chunklist (gethash chunk *chunkhash*)) type name)
  (dolist (chunk (reverse chunklist))
   (dolist (line (reverse chunk))
    (multiple-value-setq (type name) (ischunk-latex line))
    (if (eq type 'refer) 
      (expand name)
      (format t "~a~%" line))))))

;;; There is a built-in assumption (in the ischunk-* functions)
;;; that the chunks occur on separate lines and that the indentation
;;; of the chunk reference has no meaning.
;;;
;;; ischunk-latex  recognizes chunk names in latex convention
;;;
;;; There are 3 cases to recognize:
;;;  \begin{chunk}{thechunkname}  ==> 'define thechunkname
;;;  \end{chunk}                  ==> 'end nil
;;;  \chunk{thechunkname}         ==> 'refer thechunkname

(defun ischunk-latex (line)
 (let ((len (length line)) 
       (mark (search "chunk" line))
       (point 0)
       name preline postline)
  (when mark
   (cond
    ((setq mark (search "\\begin{chunk}{" line)) ; recognize define
      (setq point (position #\} line :start (+ mark 14)))
      (cond
       ((null point) (values nil nil))
       ((= point 0)  (values nil nil))
       (t
         (setq name (subseq line (+ mark 14) point)) 
         ;(print (list 'define name))
         (values 'define name))))
    ((setq mark (search "\end{chunk}" line))     ; recognize end
       ;(print (list 'end nil))
       (values 'end nil))
    ((setq mark (search "\chunk{" line))         ; recognize reference
      (setq point (position #\} line :start (+ mark 6)))
      (cond
       ((null point) (values nil nil))
       ((= point 0)  (values nil nil))
       (t
         (setq name (subseq line (+ mark 6) point)) 
         ;(print (list 'refer name))
         (values 'refer name))))
    (t (values nil nil))))))
  
;;; ischunk-noweb recognizes chunk names using the noweb convention
;;;
;;; There are 3 cases to recognize:
;;;  <<thechunkname>>=  ==> 'define thechunkname
;;;  @                  ==> 'end nil
;;;  <<thechunkname>>   ==> 'refer thechunkname

(defun ischunk-noweb (line)
 (let ((len (length line)) (mark (position #\> line)) (point 0))
  (cond
   ((and mark                    ; recognize define
         (> len (+ mark 2))
         (char= #\< (schar line 0))
         (char= #\< (schar line 1))
         (char= #\> (schar line (+ mark 1)))
         (char= #\= (schar line (+ mark 2))))
     ;(print (list 'define (subseq line 0 (+ mark 2))))
     (values 'define (subseq line 0 (+ mark 2))))
   ((and mark                    ; recognize reference
         (> len (+ mark 1))
         (char= #\> (schar line (+ mark 1))))
     (setq point (position #\< line))
     (if
      (and point
           (< point (- mark 2))
           (char= #\< (schar line (+ point 1))))
        (values 'refer (subseq line point (+ mark 2)))
        (values 'noise nil)))
    ((and (> len 0)                ; end chunk
          (char= #\@ (schar line 0)))
      (values 'end nil))
    (t (values nil nil)))))
  
;;; show is a trivial debugging utility. it dumps the hashtable
(defun show ()
 (maphash
   #'(lambda (key value) 
      (format t "~a=~% ~a~%~%~%" key value)) *chunkhash*))
 




From MAILER-DAEMON Fri Mar 27 13:44:47 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LnG6p-0003Dc-C1
	for mharc-axiom-developer@gnu.org; Fri, 27 Mar 2009 13:44:47 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LnG6n-0003B8-5t
	for axiom-developer@nongnu.org; Fri, 27 Mar 2009 13:44:45 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LnG6i-00037L-C4
	for axiom-developer@nongnu.org; Fri, 27 Mar 2009 13:44:44 -0400
Received: from [199.232.76.173] (port=39513 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LnG6i-00037E-6E
	for axiom-developer@nongnu.org; Fri, 27 Mar 2009 13:44:40 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:34406
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LnG6h-0001Tr-Ne
	for axiom-developer@nongnu.org; Fri, 27 Mar 2009 13:44:39 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n2RHiTug017903;
	Fri, 27 Mar 2009 11:44:30 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n2RHiQgU017874;
	Fri, 27 Mar 2009 11:44:26 -0600
Date: Fri, 27 Mar 2009 11:44:26 -0600
Message-Id: <200903271744.n2RHiQgU017874@axiom-developer.org>
To: "Alex Plotnick" <plotnick@cs.brandeis.edu>, heow@alphageeksinc.com
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: axiom-developer@nongnu.org
Subject: [Axiom-developer] (no subject)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Fri, 27 Mar 2009 17:44:45 -0000

Alex, Heow,

When I got the source code of Axiom from NAG I was getting back code
I had written at IBM 15 years earlier. I found the source code hard
to understand even though I strive to write dirt simple code. 

In addition, the algebra implementation code was completely divorced
from the supporting research or theory and, in most cases, did not even 
have regression tests or examples.

While struggling with this code I spent some time trying to understand
why it was so hard to get to know the system. I grant that Axiom is
quite large (about 1 million things-of-code) but it has a limited domain.

Two things opened my eyes. First, I spent time reading Knuth and his
comments on literate programming. Second, I found the book 
"Lisp in Small Pieces" by Christian Queinnec. This book show that it
is possible to fully explain a very complex piece of software in a
readable fashion.

The ultimate realization was that in order to survive, to allow people
to maintain, to understand, and to extend Axiom the system needed to
be literate.

I initially restructured Axiom to use a latex-based file format
combined with noweb (Norman Ramsey) to create pamphlet files. This was
marginally effective but ultimately proved to be "thinking in the small".
The pamphlet idea is too weak to be useful.

Axiom is now in the process of becoming fully literate. 

All of the code is being organized into books. There are currently
18 volumes, 9 of which already contain their full subsystems, 
organized as follows:

Volume 0: Axiom Jenks and Sutor
   This is the reconstructed Jenks and Sutor volume.

Volume 1: Axiom Tutorial
   This is the tutorial volume ISBN 1-411-66587-X.
   Hardcopy is available from Amazon.com or Lulu.com

Volume 2: Axiom Users Guide
   This is a more detailed explanation with current information
   for Axiom users.

Volume 3: Axiom Programmers Guide
   This is information about the language and algebra hierarchy
   for Spad language programmers.

Volume 4: Axiom Developers Guide
   This is a collection of useful information for developers.

Volume 5: Axiom Interpreter
   This is the source code and explanation for the interpreter.

Volume 6: Axiom Command
   This covers the axiom commands, sman, and some other system
   related issues.

Volume 7: Axiom Hyperdoc
   This is the source and explanation of the X11 hyperdoc subsystem.

Volume 7.1: Axiom Hyperdoc Pages
   This is the source and pages for Hyperdoc.

Volume 8: Axiom Graphics
   This is the source and explanation of the X11 graphics subsystem.

Volume 9: Axiom Compiler
   This is the source and explanation of the spad compiler.

Volume 10: Axiom Algebra Implementation
   This is a multi-volume set covering the algebra. The first
   volume deals with implementation issues.

Volume 10.1: Axiom Algebra Theory
   This volume gives background theory for various algebra topics.

Volume 10.2: Axiom Algebra Categories
   This is the source code for all of the categories.

Volume 10.3: Axiom Algebra Domains
   This is the source code for all of the domains.

Volume 10.4: Axiom Algebra Packages
   This is the source code for all of the packages.

Volume 11: Axiom Browser
   This is the source and explanation of the new Firefox browser
   front end.

Volume 12: Axiom Crystal
   This is the design documents and internals for the crystal interface.






Ulitmately each of these books will contain more words than source
code. The "golden standard" I am trying to achieve is the level that
is found in Queinnec's book. 

You should be able to sit down with a particular volume and read it
like a story. You should be able to sit down and read the theory 
behind a particular domain as well as implementation details, category
constraints, and performance issues. 

This is an ongoing process since these are living documents. 

Axiom stands in an interesting spot in history as one of the first
full fruits of the collision of mathematics and computer science. It is
important that future generations can read, understand, maintain, and
modify this work. If this effort succeeds then Axiom will live.

Tim



From MAILER-DAEMON Fri Mar 27 14:15:02 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LnGa6-0001K8-Jr
	for mharc-axiom-developer@gnu.org; Fri, 27 Mar 2009 14:15:02 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LnGa5-0001Jy-9D
	for axiom-developer@nongnu.org; Fri, 27 Mar 2009 14:15:01 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LnGa0-0001II-7y
	for axiom-developer@nongnu.org; Fri, 27 Mar 2009 14:15:00 -0400
Received: from [199.232.76.173] (port=55541 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LnGa0-0001IF-48
	for axiom-developer@nongnu.org; Fri, 27 Mar 2009 14:14:56 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:55129
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LnGZz-00084i-9D
	for axiom-developer@nongnu.org; Fri, 27 Mar 2009 14:14:55 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n2RICxug025012;
	Fri, 27 Mar 2009 12:12:59 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n2RICwl9025008;
	Fri, 27 Mar 2009 12:12:58 -0600
Date: Fri, 27 Mar 2009 12:12:58 -0600
Message-Id: <200903271812.n2RICwl9025008@axiom-developer.org>
To: "Alex Plotnick" <plotnick@cs.brandeis.edu>, heow@alphageeksinc.com
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: axiom-developer@nongnu.org
Subject: [Axiom-developer] (no subject)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Fri, 27 Mar 2009 18:15:01 -0000

Alex, Heow,

Axiom is implemented mostly in Common Lisp. The original system had
code which was in C (hyperdoc and graphics). It also had 2 layers of
pre-lisp languages, Meta and Boot. 

Meta was used to specify syntax. I rewrote that code and Meta is no
longer part of the system, simplifying the build process.

Boot is "syntactic sugar" on top of lisp. It is a "paren-less lisp"
with indentation-based syntax like python. Boot is implemented in
boot so there is a bootstrap step (hence the name). I am in the
process of removing this pseudo-language as it:
 * unnecessarily complicates the build (bootstrap)
 * foils the use of lisp tools like macros
 * does not support structures, clos, and other machinery
 * perpetuates MACLISP and VMLisp historical semantics
 * is an obscure language with no known users  

In the near term (probably by the end of the year) Axiom will be
all common lisp, except for hyperdoc and graphics. 

Hyperdoc and graphics are being reimplemented using a firefox front
end and javascript. Most of the static content of hyperdoc is now in
xhtml. The remaining effort involves writing ajax pages for dynamic
help content and canvas-based graphics. Both are in-plan. So by
Christmas 2010 Axiom will be a common lisp program with a firefox
front end in javascript/xhtml/mathml in fully literate structure.

Following that goal, Axiom needs to recover the numeric library
capabilities. The NAG libraries are not free so they need to be
replaced. I have been rewriting the BLAS, LAPACK, and GMP sources into
literate form and will eventually add an additional numeric volume to
the Axiom bookshelf.




The time for a transition to literate programming is perfect from an
historical perspective because we are beginning to see a trend toward
open and free research literature. MIT, Harvard, NIH, and other agencies
are beginning to understand that science needs to be free. This means
that we can finally bring the research and the implementations back
together in one document.



If we can create fully literate documents that contain the research
and the implementation then we can begin to think about "drag and drop"
mathematics. You should be able to attend a talk where the speaker
posts the URL for the paper. You should be able to drag that paper
onto a running Axiom and have it "just work", including installing and
using the documentation. Thus, while the talk is in progress you should
be able to use the software to execute examples. See:

  http://daly.axiom-developer.org/doyen

Tim









From MAILER-DAEMON Fri Mar 27 17:53:36 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LnJzc-0003gU-Ev
	for mharc-axiom-developer@gnu.org; Fri, 27 Mar 2009 17:53:36 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LnJzZ-0003aU-QY
	for axiom-developer@nongnu.org; Fri, 27 Mar 2009 17:53:33 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LnJzV-0003Qi-Tt
	for axiom-developer@nongnu.org; Fri, 27 Mar 2009 17:53:33 -0400
Received: from [199.232.76.173] (port=40710 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LnJzV-0003QT-Q5
	for axiom-developer@nongnu.org; Fri, 27 Mar 2009 17:53:29 -0400
Received: from s123.n226.vds2000.com ([64.6.226.123]:53106
	helo=alphageeksinc.com) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <heow@alphageeksinc.com>) id 1LnJzV-0007Q8-08
	for axiom-developer@nongnu.org; Fri, 27 Mar 2009 17:53:29 -0400
Received: (qmail 17786 invoked from network); 27 Mar 2009 14:50:28 -0400
Received: from colo-69-31-43-106.pilosoft.com (HELO ?127.0.0.1?) (69.31.43.106)
	by alphageeksinc.com with SMTP; 27 Mar 2009 14:50:28 -0400
Message-ID: <49CD2022.7080504@alphageeksinc.com>
Date: Fri, 27 Mar 2009 14:51:14 -0400
From: heow <heow@alphageeksinc.com>
User-Agent: Thunderbird 2.0.0.9 (X11/20071031)
MIME-Version: 1.0
To: daly@axiom-developer.org
References: <200903271812.n2RICwl9025008@axiom-developer.org>
In-Reply-To: <200903271812.n2RICwl9025008@axiom-developer.org>
Content-Type: text/plain; charset=ISO-8859-1; format=flowed
Content-Transfer-Encoding: 7bit
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6,
	seldom 2.4 (older, 4)
X-Greylist: delayed 4824 seconds by postgrey-1.27 at monty-python;
	Fri, 27 Mar 2009 17:53:26 EDT
Cc: Alex Plotnick <plotnick@cs.brandeis.edu>, axiom-developer@nongnu.org
Subject: [Axiom-developer] Re: 
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Fri, 27 Mar 2009 21:53:34 -0000


Tim,

Although I'll have to re-read this a few more times in order to fully 
grock it...  Wow.

This is the highest compliment I can give as I'm old and jaded and over 
the years fewer and fewer things ever impress me.

You get and fully deserve my wow^N

- h

P.S.  Welcome to the board of the ALU, I'm very happy that you're 
aboard.  Although we're getting there, don't be shy as things need a bit 
of a shakeup.


daly@axiom-developer.org wrote:
> Alex, Heow,
> 
> Axiom is implemented mostly in Common Lisp. The original system had
> code which was in C (hyperdoc and graphics). It also had 2 layers of
> pre-lisp languages, Meta and Boot. 
> 
> Meta was used to specify syntax. I rewrote that code and Meta is no
> longer part of the system, simplifying the build process.
> 
> Boot is "syntactic sugar" on top of lisp. It is a "paren-less lisp"
> with indentation-based syntax like python. Boot is implemented in
> boot so there is a bootstrap step (hence the name). I am in the
> process of removing this pseudo-language as it:
>  * unnecessarily complicates the build (bootstrap)
>  * foils the use of lisp tools like macros
>  * does not support structures, clos, and other machinery
>  * perpetuates MACLISP and VMLisp historical semantics
>  * is an obscure language with no known users  
> 
> In the near term (probably by the end of the year) Axiom will be
> all common lisp, except for hyperdoc and graphics. 
> 
> Hyperdoc and graphics are being reimplemented using a firefox front
> end and javascript. Most of the static content of hyperdoc is now in
> xhtml. The remaining effort involves writing ajax pages for dynamic
> help content and canvas-based graphics. Both are in-plan. So by
> Christmas 2010 Axiom will be a common lisp program with a firefox
> front end in javascript/xhtml/mathml in fully literate structure.
> 
> Following that goal, Axiom needs to recover the numeric library
> capabilities. The NAG libraries are not free so they need to be
> replaced. I have been rewriting the BLAS, LAPACK, and GMP sources into
> literate form and will eventually add an additional numeric volume to
> the Axiom bookshelf.
> 
> 
> 
> 
> The time for a transition to literate programming is perfect from an
> historical perspective because we are beginning to see a trend toward
> open and free research literature. MIT, Harvard, NIH, and other agencies
> are beginning to understand that science needs to be free. This means
> that we can finally bring the research and the implementations back
> together in one document.
> 
> 
> 
> If we can create fully literate documents that contain the research
> and the implementation then we can begin to think about "drag and drop"
> mathematics. You should be able to attend a talk where the speaker
> posts the URL for the paper. You should be able to drag that paper
> onto a running Axiom and have it "just work", including installing and
> using the documentation. Thus, while the talk is in progress you should
> be able to use the software to execute examples. See:
> 
>   http://daly.axiom-developer.org/doyen
> 
> Tim
> 
> 
> 
> 
> 
> 
> 




From MAILER-DAEMON Sat Mar 28 13:16:37 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Lnc96-00023o-Rj
	for mharc-axiom-developer@gnu.org; Sat, 28 Mar 2009 13:16:37 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Lnc94-00023Z-O7
	for axiom-developer@nongnu.org; Sat, 28 Mar 2009 13:16:34 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Lnc8w-00022q-FL
	for axiom-developer@nongnu.org; Sat, 28 Mar 2009 13:16:34 -0400
Received: from [199.232.76.173] (port=58638 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Lnc8w-00022n-Ay
	for axiom-developer@nongnu.org; Sat, 28 Mar 2009 13:16:26 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:59029
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1Lnc8v-0004Jl-3s
	for axiom-developer@nongnu.org; Sat, 28 Mar 2009 13:16:26 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n2SHGNug029704;
	Sat, 28 Mar 2009 11:16:23 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n2SHGNC8029701;
	Sat, 28 Mar 2009 11:16:23 -0600
Date: Sat, 28 Mar 2009 11:16:23 -0600
Message-Id: <200903281716.n2SHGNC8029701@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090327.01.tpd.patch (bookvol9 create compiler
	root)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sat, 28 Mar 2009 17:16:34 -0000

This is the first entry in Book Volume 9: Axiom Compiler

It moves the compiler root into that volume and adjusts the build
process to use bookvol9. From here we begin to tree-shake the code
into that volume.

====================================================================
diff --git a/books/bookvol5.pamphlet b/books/bookvol5.pamphlet
index 246a25b..cd1b36f 100644
--- a/books/bookvol5.pamphlet
+++ b/books/bookvol5.pamphlet
@@ -1244,7 +1244,7 @@ we return the remainder of the string without the leading prefix.
    (t
     (setq u
      (let (t0)
-       (do ((t1 l (CDR t1)) (y NIL))
+       (do ((t1 l (cdr t1)) (y nil))
            ((or (atom t1) (progn (setq y (car t1)) nil)) (nreverse0 t0))
           (if (|stringPrefix?| (pname x) (pname y))
              (setq t0 (cons y t0))))))
@@ -2498,11 +2498,11 @@ The value of the {\tt )set break} variable then controls what happens.
               (setq af1 ($findfile af '(|as| |spad| |ao| |asy|)))
               (cond
                ((and af1 (string= (|pathnameType| af1) "as"))
-                 (|compileAsharpCmd| (CONS af1 NIL)))
+                 (|compileAsharpCmd| (cons af1 nil)))
                ((and af1 (string= (|pathnameType| af1) "ao"))
-                 (|compileAsharpCmd| (CONS af1 NIL)))
+                 (|compileAsharpCmd| (cons af1 nil)))
                ((and af1 (string= (|pathnameType| af1) "spad"))
-                 (|compileSpad2Cmd| (CONS af1 NIL)))
+                 (|compileSpad2Cmd| (cons af1 nil)))
                ((and af1 (string= (|pathnameType| af1) "asy"))
                 (|compileAsharpArchiveCmd| (cons af1 nil)))
                (t (|throwKeyedMsg| 's2iz0039 nil)))))))))))))))))
@@ -2694,7 +2694,7 @@ The value of the {\tt )set break} variable then controls what happens.
     (cond
      ((|fnameReadable?| lsp)
       (unless bequiet
-         (|sayKeyedMsg| 's2iz0089 (cons (|namestring| lsp) NIL)))
+         (|sayKeyedMsg| 's2iz0089 (cons (|namestring| lsp) nil)))
       (|compileFileQuietly| lsp))
      (t (|sayKeyedMsg| 's2il0003 (cons (|namestring| lsp) nil))))
     (cond
@@ -2993,35 +2993,6 @@ displayed. If the answer is either Y or YES we return true else nil.
 @
 
 \defun{displayMacros}{displayMacros}
-;displayMacros names ==
-;  imacs := getInterpMacroNames()
-;  pmacs := getParserMacroNames()
-;  macros :=
-;     null names => APPEND (imacs, pmacs)
-;     names
-;  macros := REMDUP macros
-;  null macros => sayBrightly '"   There are no Axiom macros."
-;  -- first do user defined ones
-;  first := true
-;  for macro in macros repeat
-;    macro in pmacs =>
-;        if first then
-;            sayBrightly ['%l,'"User-defined macros:"]
-;            first := NIL
-;        displayParserMacro macro
-;    macro in imacs => 'iterate
-;    sayBrightly (["   ",'%b, macro, '%d, " is not a known Axiom macro."])
-;  -- now system ones
-;  first := true
-;  for macro in macros repeat
-;    macro in imacs =>
-;        macro in pmacs => 'iterate
-;        if first then
-;            sayBrightly ['%l,'"System-defined macros:"]
-;            first := NIL
-;        displayMacro macro
-;    macro in pmacs => 'iterate
-;  NIL
 <<defun displayMacros>>=
 (defun |displayMacros| (names)
  (let (imacs pmacs macros first)
@@ -11418,7 +11389,7 @@ This reports the traced functions
             (cons 's2it0009
              (cons
               (cons (strconc ")" (|object2String| key)) nil) nil))))))
-      (key (|throwKeyedMsg| 's2it0005 (CONS key nil))))))))) 
+      (key (|throwKeyedMsg| 's2it0005 (cons key nil))))))))) 
 
 @
 
@@ -12836,7 +12807,7 @@ to convert the data into type "Expression"
                (cond
                 ((|isFunctor| x) (|addTraceItem| x))
                 ((is_genvar x) (|addTraceItem| (EVAL x)))
-                (t (setq |functionList| (CONS x |functionList|)))))
+                (t (setq |functionList| (cons x |functionList|)))))
             (t (|userError| "bad argument to trace"))))))
         (setq |functionList|
           (prog (t1)
@@ -12915,7 +12886,7 @@ to convert the data into type "Expression"
                  (setq t7
                  (append t7 (|concat| '|, | (|abbreviate| x)))))))))))
          (cond ((atom |displayList|)
-            (setq |displayList| (CONS |displayList| nil))))
+            (setq |displayList| (cons |displayList| nil))))
          (|sayBrightly| "   Parameterized constructors traced:")
          (|sayBrightly| (|flowSegmentedMsg| |displayList| $linelength 6)))
         (t nil))))))))) 
@@ -15545,28 +15516,6 @@ The \verb|$undoFlag| is used in recordFrame to decide whether to do
 undo recording. It is initially set to T in initvars.
 This is part of the undo mechanism.
 
-\chapter{Makefile.bookvol5}
-<<*>>=
-LATEX=/usr/bin/latex
-LISP=${AXIOM}/obj/linux/bin/lisp
-TANGLE=/usr/local/bin/NOTANGLE
-WEAVE=/usr/local/bin/NOWEAVE -delay
-
-all: bookvol5
-	@echo 0 done
-
-bookvol5: bookvol5.pamphlet
-	@echo 1 extracting the bookvol5reter
-	${WEAVE} bookvol5.pamphlet >bookvol5.tex
-	${LATEX} bookvol5.tex
-	${LATEX} bookvol5.tex
-	${TANGLE} -R"Interpreter" bookvol5.pamphlet >bookvol5.lisp
-
-remake:	
-	@echo 2 rebuilding the makefile
-	@${TANGLE} bookvol5.pamphlet >Makefile.bookvol5
-
-@
 \eject
 \begin{thebibliography}{99}
 \bibitem{1} Daly, Timothy, "The Axiom Literate Documentation"\\
diff --git a/books/bookvol9.pamphlet b/books/bookvol9.pamphlet
index 5daa933..b539dd1 100644
--- a/books/bookvol9.pamphlet
+++ b/books/bookvol9.pamphlet
@@ -4,102 +4,46 @@
 \usepackage{makeidx}
 \makeindex
 \usepackage{graphicx}
-% struggle with latex figure-floating behavior
-\renewcommand\floatpagefraction{.9}
-\renewcommand\topfraction{.9}
-\renewcommand\bottomfraction{.9}
-\renewcommand\textfraction{.1}
-\setcounter{totalnumber}{50}
-\setcounter{topnumber}{50}
-\setcounter{bottomnumber}{50}
-
-
-%% spadgraph are the actual text that you type at the axiom prompt for draw
-\providecommand{\spadgraph}[1]%
-{\begin{flushleft}{\tt #1}\end{flushleft}\vskip .1cm }
-
-% spadfunFrom records the function name and domain in the index
-\providecommand{\spadfunFrom}[2]%
-{{\bf #1}\index{#1 @\begingroup \string\bf{} #1 \endgroup}\index{#2}}
-
-%% spadsig gives the standard -> notation for signatures
-\providecommand{\spadsig}[2]{{\sf #1 $\rightarrow$ #2}}
-
-% special meanings for math characters
-\providecommand{\N}{\mbox{\bbold N}}
-\providecommand{\Natural}{\mbox{\bbold N}}
-\providecommand{\Z}{\mbox{\bbold Z}}
-\providecommand{\Integer}{\mbox{\bbold Z}}
-\providecommand{\Rational}{\mbox{\bbold Q}}
-\providecommand{\Q}{\mbox{\bbold Q}}
-\providecommand{\Complex}{\mbox{\bbold C}}
-\providecommand{\C}{{\mathcal C}}
-\providecommand{\Real}{\mbox{\bbold R}}
-\providecommand{\F}{{\mathcal F}}
-\providecommand{\R}{{\mathcal R}}
-
-% draw a box around a text block
-\providecommand\boxed[2]{%
-\begin{center}
-\begin{tabular}{|c|}
-\hline
-\begin{minipage}{#1}
-\normalsize
-{#2}
-\end{minipage}\\
-\hline
-\end{tabular}
-\end{center}}
-
-\providecommand{\optArg}[1]{{{\tt [}{#1}{\tt ]}}}
-\providecommand{\argDef}[1]{{\tt ({#1})}}
-\providecommand{\funSyntax}[2]{{\bf #1}{\tt ({\small\it{#2}})}}
-\providecommand{\funArgs}[1]{{\tt ({\small\it {#1}})}\newline}
-\providecommand{\condata}[4]{{\bf #1} {\bf #2} {\bf #3} {\bf #4}}
-
-\def\glossaryTerm#1{{\bf #1}\index{#1}}
-\def\glossaryTermNoIndex#1{{\bf #1}}
-\def\glossarySyntaxTerm#1{{\tt #1}\index{#1}}
-\long\def\ourGloss#1#2{\par\pagebreak[3]{#1}\newline{#2}}
-\def\csch{\mathop{\rm csch}\nolimits}
-
-\def\erf{\mathop{\rm erf}\nolimits}
-
-\def\zag#1#2{
-  {{\hfill \left. {#1} \right|}
-   \over
-   {\left| {#2} \right. \hfill}
-  }
-}
-
-
-% these bitmaps are used by HyperDoc
-\newdimen\commentWidth 
-\commentWidth=11pc
-\newdimen\colGutterWidth 
-\colGutterWidth=1pc
-\newdimen\baseLeftSkip
-\baseLeftSkip=\commentWidth \advance\baseLeftSkip by \colGutterWidth
-
-\providecommand\ExitBitmap%
-{{\setlength{\unitlength}{0.01in}%
-\begin{picture}(50,16)(0,0)\special{psfile=ps/exit.ps}\end{picture}}}
-
-\providecommand\ReturnBitmap%
-{{\setlength{\unitlength}{0.01in}%
-\begin{picture}(50,16)(0,0)\special{psfile=ps/home.ps}\end{picture}}}
-
-\providecommand\HelpBitmap%
-{{\setlength{\unitlength}{0.01in}%
-\begin{picture}(50,16)(0,0)\special{psfile=ps/help.ps}\end{picture}}}
-
-\providecommand\UpBitmap%
-{{\setlength{\unitlength}{0.01in}%
-\begin{picture}(50,16)(0,0)\special{psfile=ps/up.ps}\end{picture}}}
-
-\providecommand{\tpd}[5]%
-{{\setlength{\unitlength}{0.01in}%
-\begin{picture}(#1,#2)(#3,#4)\special{psfile=#5}\end{picture}}}
+%%
+%% defun marks a function definition and adds it to the index
+%%
+\newcommand{\defun}[2]{% e.g. \defun{functionname}
+\subsection{defun #2}%
+\label{#1}%
+\index{#1}%
+\index{defun!#1}%
+\index{#1!defun}}
+
+%%
+%% defmacro marks a macro definition and adds it to the index
+%%
+\newcommand{\defmacro}[1]{% e.g. \defmacro{functionname}
+\subsection{defmacro {#1}}%
+\label{#1}%
+\index{#1}%
+\index{defmacro!#1}%
+\index{#1!defmacro}}
+
+%%
+%% defvar marks a var definition and adds it to the index
+%%
+\newcommand{\defvar}[1]{% e.g. \defvar{varname}
+\subsection{defvar \${#1}}%
+\label{#1}%
+\index{#1}%
+\index{defvar!#1}%
+\index{#1!defvar}}
+
+
+%%
+%% defdollar marks a var definition (with leading $) and adds it to the index
+%%
+\newcommand{\defdollar}[1]{% e.g. \defdollar{functionname}
+\subsection{defvar \${#1}}%
+\label{#1}%
+\index{\${#1}}%
+\index{defvar!\${#1}}%
+\index{\${#1}!defvar}}
 
 \begin{document}
 \begin{titlepage}
@@ -303,18 +247,402 @@ This book is actually a literate program\cite{2} and can contain
 executable source code. In particular, the Makefile for this book
 is part of the source of the book and is included below. Axiom 
 uses the ``noweb'' literate programming system by Norman Ramsey\cite{6}.
-<<*>>=
-PROJECT=bookvol9
-TANGLE=/usr/local/bin/NOTANGLE
-WEAVE=/usr/local/bin/NOWEAVE
-LATEX=/usr/bin/latex
-MAKEINDEX=/usr/bin/makeindex
-
-all: 
-	${WEAVE} -t8 -delay ${PROJECT}.pamphlet >${PROJECT}.tex
-	${LATEX} ${PROJECT}.tex 2>/dev/null 1>/dev/null
-	${MAKEINDEX} ${PROJECT}.idx
-	${LATEX} ${PROJECT}.tex 2>/dev/null 1>/dev/null
+\chapter{Compiler top level}
+\section{)compile}
+This is the implementation of the )compile command.
+
+You use this command to invoke the new Axiom library compiler or the
+old Axiom system compiler.  The {\tt )compile} system command is
+actually a combination of Axiom processing and a call to the Aldor
+compiler.  It is performing double-duty, acting as a front-end to both
+the Aldor compiler and the old Axiom system compiler.  (The old Axiom
+system compiler was written in Lisp and was an integral part of the
+Axiom environment.  The Aldor compiler is written in C and executed by
+the operating system when called from within Axiom.)
+
+\par\noindent{\bf User Level Required:} compiler
+
+\par\noindent{\bf Command Syntax:}
+
+\begin{list}{}
+\item {\tt )compile}
+\item {\tt )compile {\it fileName}}
+\item {\tt )compile {\it fileName}.spad}
+\item {\tt )compile {\it directory/fileName}.spad}
+\item {\tt )compile {\it fileName} )old}
+\item {\tt )compile {\it fileName} )translate}
+\item {\tt )compile {\it fileName} )quiet}
+\item {\tt )compile {\it fileName} )noquiet}
+\item {\tt )compile {\it fileName} )moreargs}
+\item {\tt )compile {\it fileName} )onlyargs}
+\item {\tt )compile {\it fileName} )break}
+\item {\tt )compile {\it fileName} )nobreak}
+\item {\tt )compile {\it fileName} )library}
+\item {\tt )compile {\it fileName} )nolibrary}
+\item {\tt )compile {\it fileName} )vartrace}
+\item {\tt )compile {\it fileName} )constructor} {\it nameOrAbbrev}
+\end{list}
+
+These command forms invoke the Aldor compiler.
+\begin{list}{}
+\item {\tt )compile {\it fileName}.as}
+\item {\tt )compile {\it directory/fileName}.as}
+\item {\tt )compile {\it fileName}.ao}
+\item {\tt )compile {\it directory/fileName}.ao}
+\item {\tt )compile {\it fileName}.al}
+\item {\tt )compile {\it directory/fileName}.al}
+\item {\tt )compile {\it fileName}.lsp}
+\item {\tt )compile {\it directory/fileName}.lsp}
+\item {\tt )compile {\it fileName} )new}
+\end{list}
+
+\par\noindent{\bf Command Description:}
+
+The first thing {\tt )compile} does is look for a source code
+filename among its arguments.
+Thus
+\begin{verbatim}
+)compile mycode.spad
+)compile /u/jones/mycode.spad
+)compile mycode
+\end{verbatim}
+all invoke {\tt )compiler} on the file {\tt
+/u/jones/mycode.spad} if the current Axiom working
+directory is {\tt /u/jones.} (Recall that you can set the
+working directory via the {\tt )cd} command. If you don't set it
+explicitly, it is the directory from which you started
+Axiom.)
+
+If you omit the file extension, the command looks to see if you have
+specified the {\tt )new} or {\tt )old} option.  If you have given one
+of these options, the corresponding compiler is used.
+
+The command first looks in the standard system directories for files
+with extension {\it .as, .ao} and {\it .al} and then files with
+extension {\it .spad}.  The first file found has the appropriate
+compiler invoked on it.  If the command cannot find a matching file,
+an error message is displayed and the command terminates.
+
+The first thing {\tt )compile} does is look for a source code
+filename among its arguments.
+Thus
+\begin{verbatim}
+)compile mycode.as
+)compile /u/jones/as/mycode.as
+)compile mycode
+\end{verbatim}
+all invoke {\tt )compiler} on the file {\tt
+/u/jones/as/mycode.as} if the current Axiom working
+directory is {\tt /u/jones/as.} (Recall that you can set the
+working directory via the {\tt )cd} command. If you don't set it
+explicitly, it is the directory from which you started
+Axiom.)
+
+This is frequently all you need to compile your file.
+
+This simple command:
+\begin{enumerate}
+\item Invokes the chosen compiler and produces Lisp output.
+\item Calls the Lisp compiler if the compilation was
+successful.
+\item Uses the {\tt )library} command to tell Axiom about
+the contents of your compiled file and arrange to have those
+contents loaded on demand.
+\end{enumerate}
+
+Should you not want the {\tt )library} command automatically
+invoked, call {\tt )compile} with the {\tt )nolibrary} option.
+For example,
+\begin{verbatim}
+)compile mycode )nolibrary
+\end{verbatim}
+
+By default, the {\tt )library} system command {\it exposes} all
+domains and categories it processes.
+This means that the Axiom intepreter will consider those
+domains and categories when it is trying to resolve a reference
+to a function.
+Sometimes domains and categories should not be exposed.
+For example, a domain may just be used privately by another
+domain and may not be meant for top-level use.
+The {\tt )library} command should still be used, though, so that
+the code will be loaded on demand.
+In this case, you should use the {\tt )nolibrary} option on {\tt
+)compile} and the {\tt )noexpose} option in the {\tt )library}
+command. For example,
+\begin{verbatim}
+)compile mycode )nolibrary
+)library mycode )noexpose
+\end{verbatim}
+
+Once you have established your own collection of compiled code,
+you may find it handy to use the {\tt )dir} option on the
+{\tt )library} command.
+This causes {\tt )library} to process all compiled code in the
+specified directory. For example,
+\begin{verbatim}
+)library )dir /u/jones/quantum
+\end{verbatim}
+You must give an explicit directory after {\tt )dir}, even if you
+want all compiled code in the current working directory
+processed, e.g.
+\begin{verbatim}
+)library )dir .
+\end{verbatim}
+
+\subsection{Spad compiler}
+This command compiles files with file extension {\tt .spad}
+with the old Axiom system compiler.  
+
+The {\tt )translate} option is used to invoke a special version of the
+old system compiler that will translate a {\it .spad} file to a {\it
+.as} file.  That is, the {\it .spad} file will be parsed and analyzed
+and a file using the new syntax will be created.
+
+By default, the {\it .as} file is created in the same directory as the
+{\it .spad} file. If that directory is not writable, the current
+directory is used. If the current directory is not writable, an error
+message is given and the command terminates.  Note that {\tt )translate} 
+implies the {\tt )old} option so the file extension can
+safely be omitted. If {\tt )translate} is given, all other options are
+ignored.  Please be aware that the translation is not necessarily one
+hundred percent complete or correct.  You should attempt to compile
+the output with the Aldor compiler and make any necessary corrections.
+
+You can compile category, domain, and package constructors contained
+in files with file extension {\it .spad}.  You can compile individual
+constructors or every constructor in a file.
+
+The full filename is remembered between invocations of this command and
+{\tt )edit} commands. The sequence of commands
+\begin{verbatim}
+)compile matrix.spad
+)edit
+)compile
+\end{verbatim}
+will call the compiler, edit, and then call the compiler again on the
+file {\bf matrix.spad.}  If you do not specify a {\it directory,} the
+working current directory is searched for the file.  If the file is
+not found, the standard system directories are searched.
+
+If you do not give any options, all constructors within a file are
+compiled.  Each constructor should have an {\tt )abbreviation} command
+in the file in which it is defined.  We suggest that you place the
+{\tt )abbreviation} commands at the top of the file in the order in
+which the constructors are defined.
+
+The {\tt )library} option causes directories containing the compiled
+code for each constructor to be created in the working current
+directory.  The name of such a directory consists of the constructor
+abbreviation and the {\bf .nrlib} file extension.  For example, the
+directory containing the compiled code for the {\tt MATRIX}
+constructor is called {\bf MATRIX.nrlib.}  The {\tt )nolibrary} option
+says that such files should not be created.  The default is 
+{\tt )library.}  Note that the semantics of {\tt )library} and 
+{\tt )nolibrary} for the new Aldor compiler and for the old system 
+compiler are completely different.
+
+The {\tt )vartrace} option causes the compiler to generate
+extra code for the constructor to support conditional tracing of
+variable assignments. (see 
+\ref{ugSysCmdtrace} on page~\pageref{ugSysCmdtrace}). Without
+this option, this code is suppressed and one cannot use
+the {\tt )vars} option for the trace command.
+
+The {\tt )constructor} option is used to
+specify a particular constructor to compile.
+All other constructors in the file are ignored.
+The constructor name or abbreviation follows {\tt )constructor.}
+Thus either
+\begin{verbatim}
+)compile matrix.spad )constructor RectangularMatrix
+\end{verbatim}
+or
+\begin{verbatim}
+)compile matrix.spad )constructor RMATRIX
+\end{verbatim}
+compiles  the {\tt RectangularMatrix} constructor
+defined in {\bf matrix.spad.}
+
+The {\tt )break} and {\tt )nobreak} options determine what
+the spad compiler does when it encounters an error.
+{\tt )break} is the default and it indicates that processing
+should stop at the first error.
+The value of the {\tt )set break} variable then controls what happens.
+
+\subsection{Aldor compiler}
+This command compiles files with file extensions {\it .as, .ao} and
+{\it .al} with the Aldor compiler. It also can compile files
+with file extension {\it .lsp}. These are assumed to be Lisp files
+genererated by the Aldor compiler.  
+
+The general description of Aldor command line arguments is in
+the Aldor documentation.
+The default options used by the {\tt )compile} command can be
+viewed and set using the {\tt )set compiler args} Axiom
+system command.
+The current defaults are
+\begin{verbatim}
+-O -Fasy -Fao -Flsp -laxiom -Mno-AXL_W_WillObsolete -DAxiom
+\end{verbatim}
+These options mean:
+\begin{itemize}
+\item {\tt -O}: perform all optimizations,
+\item {\tt -Fasy}: generate a {\tt .asy} file,
+\item {\tt -Fao}: generate a {\tt .ao} file,
+\item {\tt -Flsp}: generate a {\tt .lsp} (Lisp) file,
+\item {\tt -laxiom}: use the {\tt axiom} library {\tt libaxiom.al},
+\item {\tt -Mno-AXL\_W\_WillObsolete}: do not display messages
+about older generated files becoming obsolete, and
+\item {\tt -DAxiom}: define the global assertion {\tt Axiom} so that the
+Aldor libraries for generating stand-alone code
+are not accidentally used with Axiom.
+\end{itemize}
+
+To supplement these default arguments, use the {\tt )moreargs} option on
+{\tt )compile.}
+For example,
+\begin{verbatim}
+)compile mycode.as )moreargs "-v"
+\end{verbatim}
+uses the default arguments and appends the {\tt -v} (verbose)
+argument flag.
+The additional argument specification {\bf must be enclosed in
+double quotes.}
+
+To completely replace these default arguments for a particular
+use of {\tt )compile}, use the {\tt )onlyargs} option.
+For example,
+\begin{verbatim}
+)compile mycode.as )onlyargs "-v -O"
+\end{verbatim}
+only uses the {\tt -v} (verbose) and {\tt -O} (optimize)
+arguments.
+The argument specification {\bf must be enclosed in double quotes.}
+In this example, Lisp code is not produced and so the compilation
+output will not be available to Axiom.
+
+To completely replace the default arguments for all calls to {\tt
+)compile} within your Axiom session, use {\tt )set compiler args.}
+For example, to use the above arguments for all compilations, issue
+\begin{verbatim}
+)set compiler args "-v -O"
+\end{verbatim}
+Make sure you include the necessary {\tt -l} and {\tt -Y}
+arguments along with those needed for Lisp file creation.
+As above, {\bf the argument specification must be enclosed in double
+quotes.}
+
+The {\tt )compile} command works with several file extensions. We saw
+above what happens when it is invoked on a file with extension {\tt
+.as.} A {\tt .ao} file is a portable binary compiled version of a
+{\tt .as} file, and {\tt )compile} simply passes the {\tt .ao} file
+onto Aldor. The generated Lisp file is compiled and {\tt )library}
+is automatically called, just as if you had specified a {\tt .as} file.
+
+A {\tt .al} file is an archive file containing {\tt .ao} files. The
+archive is created (on Unix systems) with the {\tt ar} program. When
+{\tt )compile} is given a {\tt .al} file, it creates a directory whose
+name is based on that of the archive. For example, if you issue
+\begin{verbatim}
+)compile mylib.al
+\end{verbatim}
+the directory {\tt mylib.axldir} is created. All members of the
+archive are unarchived into the directory and {\tt )compile} is called
+on each {\tt .ao} file found. It is your responsibility to remove the
+directory and its contents, if you choose to do so.
+
+A {\tt .lsp} file is a Lisp source file, generated by Aldor
+when called with the {\tt -Flsp} option. When {\tt )compile} is used
+with a {\tt .lsp} file, the Lisp file is compiled and {\tt )library}
+is called. For Aldor, You must also have present a {\tt .asy}
+generated from the same source file.
+
+\defun{compileSpad2Cmd}{The Spad compiler top level function}
+This is the old compiler.
+Assume we entered from the "compiler" function, so args is 
+a file with file extension .spad.
+
+The \verb|$f| and \verb|$m| are compiler variables, probably function
+and mode.
+<<defun compileSpad2Cmd>>=
+(defun |compileSpad2Cmd| (args)
+ (let (|$newcompMode| |$ncConverse| |$newComp| |$scanIfTrue| 
+       |$compileOnlyCertainItems| |$f| |$m| |$QuickLet| |$QuickCode| 
+       |$sourceFileTypes| |$InteractiveMode| path optlist fun optname 
+       optargs fullopt translateoldtonew constructor)
+  (declare (special |$newcompMode| |$ncConverse| |$newComp| |$scanIfTrue| 
+       |$compileOnlyCertainItems| |$f| |$m| |$QuickLet| |$QuickCode| 
+       |$sourceFileTypes| |$InteractiveMode| /editfile |$options|
+       |$newConlist|)) 
+   (setq path (|pathname| args))
+   (cond
+    ((nequal (|pathnameType| path) "spad") (|throwKeyedMsg| 'S2IZ0082 nil))
+    ((null (probe-file path))
+     (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil)))
+    (t
+     (setq /editfile path)
+     (|updateSourceFiles| path)
+     (|sayKeyedMsg| 's2iz0038 (list (|namestring| args)))
+     (setq optlist '(|break| |constructor| |functions| |library| |lisp|
+         |new| |old| |nobreak| |nolibrary| |noquiet| |vartrace| |quiet|
+         |translate|))
+     (setq |$QuickLet| t)
+     (setq |$QuickCode| t)
+     (setq fun '(|rq| |lib|))
+     (setq |$sourceFileTypes| '("SPAD"))
+     (dolist (opt |$options|)
+      (setq optname (car opt))
+      (setq optargs (cdr opt))
+      (setq fullopt (|selectOptionLC| optname optlist nil))
+      (case fullopt
+       (|new| (|error| '|Internal error: compileSpad2Cmd got )new|))
+       (|old| nil)
+       (|translate| (setq translateoldtonew t))
+       (|library| (setelt fun 1 '|lib|))
+       (|nolibrary| (setelt fun 1 '|nolib|))
+       (|quiet| (when (nequal (elt fun 0) '|c|) (setelt fun 0 '|rq|)))
+       (|noquiet| (when (nequal (elt fun 0) '|c|) (setelt fun 0 '|rf|)))
+       (|nobreak| (setq |$scanIfTrue| t))
+       (|break| (setq |$scanIfTrue| nil))
+       (|vartrace| (setq |$QuickLet| nil))
+       (|lisp| (|throwKeyedMsg| 's2iz0036 (list ")lisp")))
+       (|functions|
+        (if (null optargs) 
+         (|throwKeyedMsg| 's2iz0037 (list ")functions"))
+         (setq |$compileOnlyCertainItems| optargs)))
+       (|constructor|
+        (if (null optargs)
+         (|throwKeyedMsg| 's2iz0037 (list ")constructor"))
+         (progn
+          (setelt fun 0 '|c|)
+          (setq constructor (mapcar #'|unabbrev| optargs)))))
+       (t
+        (|throwKeyedMsg| 's2iz0036 
+         (list (strconc ")" (|object2String| optname)))))))
+    (setq |$InteractiveMode| nil)
+    (cond
+     (translateoldtonew
+      (|oldParserAutoloadOnceTrigger|)
+      (|browserAutoloadOnceTrigger|)
+      (|spad2AsTranslatorAutoloadOnceTrigger|)
+      (|sayKeyedMsg| 's2iz0085 nil)
+      (|convertSpadToAsFile| path))
+     (|$compileOnlyCertainItems|
+      (if (null constructor)
+       (|sayKeyedMsg| 's2iz0040 nil)
+       (|compilerDoitWithScreenedLisplib| constructor fun)))
+     (t (|compilerDoit| constructor fun)))
+    (|extendLocalLibdb| |$newConlist|)
+    (|terminateSystemCommand|)
+    (|spadPrompt|)))))
+
+@
+\chapter{The Compiler}
+<<Compiler>>=
+(in-package "BOOT")
+
+<<defun compileSpad2Cmd>>
 
 @
 \eject
@@ -339,5 +667,6 @@ Literate Programming''\\
 \bibitem{7} Daly, Timothy, "The Axiom Literate Documentation"\\
 {\bf http://axiom.axiom-developer.org/axiom-website/documentation.html}
 \end{thebibliography}
+\chapter{Index}
 \printindex
 \end{document}
diff --git a/changelog b/changelog
index 92ae214..d2c57aa 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,10 @@
+20090327 tpd src/axiom-website/patches.html 20090327.01.tpd.patch
+20090327 tpd src/interp/util.lisp stop autoloading compiler root
+20090327 tpd src/interp/Makefile build bookvol9
+20090327 tpd src/Makefile copy bookvol9 to src/interp
+20090327 tpd books/bookvol9 create compiler root 
+20090327 tpd src/interp/compiler.boot move compiler root to bookvol9
+20090327 tpd books/bookvol5 move compiler root to bookvol9
 20090326 tpd src/axiom-website/patches.html 20090326.01.tpd.patch
 20090326 tpd books/bookvol4 Finding Anonymous Function Signatures
 20090325 tpd src/axiom-website/patches.html 20090325.01.tpd.patch
diff --git a/src/Makefile.pamphlet b/src/Makefile.pamphlet
index a48ac4b..3d60ea8 100644
--- a/src/Makefile.pamphlet
+++ b/src/Makefile.pamphlet
@@ -249,6 +249,10 @@ and {\bf interpsys}. Since these two images share a lot of
 files they are built in the interp subdirectory using the
 same Makefile.
 
+Book Volume 5 contains the interpreter.
+
+Book Volume 9 contains the compiler.
+
 <<interpdir>>=
 interpdir: ${SRC}/interp/Makefile
 	@echo 25 making ${SRC}/interp
@@ -260,6 +264,7 @@ interpdir: ${SRC}/interp/Makefile
 	@mkdir -p ${MNT}/${SYS}/doc/msgs
 	@mkdir -p ${MNT}/${SYS}/doc/src/interp
 	@cp ${SPD}/books/bookvol5.pamphlet interp
+	@cp ${SPD}/books/bookvol9.pamphlet interp
 	@(cd interp ; ${ENV} ${MAKE} )
 
 ${SRC}/interp/Makefile: ${SRC}/interp/Makefile.pamphlet
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index 9d8fe52..4ec4d96 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -1028,5 +1028,7 @@ In process, not yet released<br/><br/>
 download.html add March 2009 column, add fedora10 binary<br/>
 <a href="patches/20090326.01.tpd.patch">20090326.01.tpd.patch</a>
 bookvol4 Finding Anonymous Function Signatures<br/>
+<a href="patches/20090327.01.tpd.patch">20090327.01.tpd.patch</a>
+bookvol9 create compiler root<br/>
  </body>
 </html>
diff --git a/src/interp/Makefile.pamphlet b/src/interp/Makefile.pamphlet
index d0a819c..0f2f801 100644
--- a/src/interp/Makefile.pamphlet
+++ b/src/interp/Makefile.pamphlet
@@ -183,6 +183,7 @@ OBJS= ${OUT}/vmlisp.${O}      ${OUT}/hash.${O} \
       ${OUT}/i-code.${O}      ${OUT}/i-coerce.${O} \
       ${OUT}/i-coerfn.${O}    ${OUT}/i-eval.${O} \
       ${OUT}/i-funsel.${O}    ${OUT}/bookvol5.${O} \
+      ${OUT}/bookvol9.${O} \
       ${OUT}/i-intern.${O}    ${OUT}/i-map.${O} \
       ${OUT}/i-output.${O}    ${OUT}/i-resolv.${O} \
       ${OUT}/i-spec1.${O}    \
@@ -4368,32 +4369,34 @@ ${MID}/bookvol5.${LISP}: ${IN}/bookvol5.pamphlet
 	  ${TANGLE} -RInterpreter ${IN}/bookvol5.pamphlet >bookvol5.${LISP} )
 
 @
-The new bookvol5 now depends on some pictures in the src/doc/ps
-subdirectory so we have to extend the preconditions to include this.
-<<bookvol5.dvi (DOC from IN)>>=
-${DOC}/bookvol5.dvi: ${IN}/bookvol5.pamphlet  ${DOC}/ps
-	@echo 299 making ${DOC}/bookvol5.dvi from ${IN}/bookvol5.pamphlet
-	@(cd ${DOC} ; \
-	cp ${IN}/bookvol5.pamphlet ${DOC} ; \
-	${DOCUMENT} ${NOISE} bookvol5 ; \
-	rm -f ${DOC}/bookvol5.pamphlet ; \
-	rm -f ${DOC}/bookvol5.tex ; \
-	rm -f ${DOC}/bookvol5 )
+\subsection{bookvol9.lsp}
+<<bookvol9.o (OUT from MID)>>=
+${OUT}/bookvol9.${O}: ${MID}/bookvol9.${LISP}
+	@ echo 297 making ${OUT}/bookvol9.${O} from ${MID}/bookvol9.${LISP}
+	@ (cd ${MID} ; \
+	  if [ -z "${NOISE}" ] ; then \
+	   echo '(progn  (compile-file "${MID}/bookvol9.${LISP}"' \
+             ':output-file "${OUT}/bookvol9.${O}") (${BYE}))' | ${DEPSYS} ; \
+	  else \
+	   echo '(progn  (compile-file "${MID}/bookvol9.${LISP}"' \
+             ':output-file "${OUT}/bookvol9.${O}") (${BYE}))' | ${DEPSYS} \
+             >${TMP}/trace ; \
+	  fi )
 
 @
-<<bookvol5.dvi (BOOK from DOC)>>=
-${BOOK}/bookvol5.dvi: ${DOC}/bookvol5.dvi
-	@echo 299 making ${BOOK}/bookvol5.dvi from ${DOC}/bookvol5.dvi
-	@ cp ${DOC}/bookvol5.dvi ${BOOK}/bookvol5.dvi
+<<bookvol9.lsp (OUT from MID)>>=
+${OUT}/bookvol9.${LISP}: ${MID}/bookvol9.${LISP}
+	@ echo 133 making ${OUT}/bookvol9.${LISP} from ${MID}/bookvol9.${LISP}
+	@cp ${MID}/bookvol9.${LISP} ${OUT}/bookvol9.${LISP}
 
 @
-<<ps>>=
-${DOC}/ps: ${SRC}/doc/ps
-	@echo 299a making ${DOC}/ps from ${SRC}/doc/ps
-	@cp -pr ${SRC}/doc/ps ${DOC}
+<<bookvol9.lsp (MID from IN)>>=
+${MID}/bookvol9.${LISP}: ${IN}/bookvol9.pamphlet
+	@ echo 298 making ${MID}/bookvol9.${LISP} from ${IN}/bookvol9.pamphlet
+	@ (cd ${MID} ; \
+	  ${TANGLE} -RCompiler ${IN}/bookvol9.pamphlet >bookvol9.${LISP} )
 
 @
-
 \subsection{i-intern.boot}
 <<i-intern.o (OUT from MID)>>=
 ${OUT}/i-intern.${O}: ${MID}/i-intern.clisp 
@@ -8748,10 +8751,10 @@ clean:
 <<bookvol5.o (OUT from MID)>>
 <<bookvol5.lsp (OUT from MID)>>
 <<bookvol5.lsp (MID from IN)>>
-<<bookvol5.dvi (DOC from IN)>>
-<<bookvol5.dvi (BOOK from DOC)>>
 
-<<ps>>
+<<bookvol9.o (OUT from MID)>>
+<<bookvol9.lsp (OUT from MID)>>
+<<bookvol9.lsp (MID from IN)>>
 
 <<i-intern.o (OUT from MID)>>
 <<i-intern.clisp (MID from IN)>>
diff --git a/src/interp/compiler.boot.pamphlet b/src/interp/compiler.boot.pamphlet
index 4deb2b2..d1be1e7 100644
--- a/src/interp/compiler.boot.pamphlet
+++ b/src/interp/compiler.boot.pamphlet
@@ -1651,417 +1651,6 @@ modeEqualSubst(m1,m,e) ==
   nil
 
 @
-\section{)compile}
-This is the implementation of the )compile command.
-
-You use this command to invoke the new Axiom library compiler or the
-old Axiom system compiler.  The {\tt )compile} system command is
-actually a combination of Axiom processing and a call to the Aldor
-compiler.  It is performing double-duty, acting as a front-end to both
-the Aldor compiler and the old Axiom system compiler.  (The old Axiom
-system compiler was written in Lisp and was an integral part of the
-Axiom environment.  The Aldor compiler is written in C and executed by
-the operating system when called from within Axiom.)
-
-\par\noindent{\bf User Level Required:} compiler
-
-\par\noindent{\bf Command Syntax:}
-
-\begin{list}{}
-\item {\tt )compile}
-\item {\tt )compile {\it fileName}}
-\item {\tt )compile {\it fileName}.spad}
-\item {\tt )compile {\it directory/fileName}.spad}
-\item {\tt )compile {\it fileName} )old}
-\item {\tt )compile {\it fileName} )translate}
-\item {\tt )compile {\it fileName} )quiet}
-\item {\tt )compile {\it fileName} )noquiet}
-\item {\tt )compile {\it fileName} )moreargs}
-\item {\tt )compile {\it fileName} )onlyargs}
-\item {\tt )compile {\it fileName} )break}
-\item {\tt )compile {\it fileName} )nobreak}
-\item {\tt )compile {\it fileName} )library}
-\item {\tt )compile {\it fileName} )nolibrary}
-\item {\tt )compile {\it fileName} )vartrace}
-\item {\tt )compile {\it fileName} )constructor} {\it nameOrAbbrev}
-\end{list}
-
-These command forms invoke the Aldor compiler.
-\begin{list}{}
-\item {\tt )compile {\it fileName}.as}
-\item {\tt )compile {\it directory/fileName}.as}
-\item {\tt )compile {\it fileName}.ao}
-\item {\tt )compile {\it directory/fileName}.ao}
-\item {\tt )compile {\it fileName}.al}
-\item {\tt )compile {\it directory/fileName}.al}
-\item {\tt )compile {\it fileName}.lsp}
-\item {\tt )compile {\it directory/fileName}.lsp}
-\item {\tt )compile {\it fileName} )new}
-\end{list}
-
-\par\noindent{\bf Command Description:}
-
-The first thing {\tt )compile} does is look for a source code
-filename among its arguments.
-Thus
-\begin{verbatim}
-)compile mycode.spad
-)compile /u/jones/mycode.spad
-)compile mycode
-\end{verbatim}
-all invoke {\tt )compiler} on the file {\tt
-/u/jones/mycode.spad} if the current Axiom working
-directory is {\tt /u/jones.} (Recall that you can set the
-working directory via the {\tt )cd} command. If you don't set it
-explicitly, it is the directory from which you started
-Axiom.)
-
-If you omit the file extension, the command looks to see if you have
-specified the {\tt )new} or {\tt )old} option.  If you have given one
-of these options, the corresponding compiler is used.
-
-The command first looks in the standard system directories for files
-with extension {\it .as, .ao} and {\it .al} and then files with
-extension {\it .spad}.  The first file found has the appropriate
-compiler invoked on it.  If the command cannot find a matching file,
-an error message is displayed and the command terminates.
-
-The first thing {\tt )compile} does is look for a source code
-filename among its arguments.
-Thus
-\begin{verbatim}
-)compile mycode.as
-)compile /u/jones/as/mycode.as
-)compile mycode
-\end{verbatim}
-all invoke {\tt )compiler} on the file {\tt
-/u/jones/as/mycode.as} if the current Axiom working
-directory is {\tt /u/jones/as.} (Recall that you can set the
-working directory via the {\tt )cd} command. If you don't set it
-explicitly, it is the directory from which you started
-Axiom.)
-
-This is frequently all you need to compile your file.
-
-This simple command:
-\begin{enumerate}
-\item Invokes the chosen compiler and produces Lisp output.
-\item Calls the Lisp compiler if the compilation was
-successful.
-\item Uses the {\tt )library} command to tell Axiom about
-the contents of your compiled file and arrange to have those
-contents loaded on demand.
-\end{enumerate}
-
-Should you not want the {\tt )library} command automatically
-invoked, call {\tt )compile} with the {\tt )nolibrary} option.
-For example,
-\begin{verbatim}
-)compile mycode )nolibrary
-\end{verbatim}
-
-By default, the {\tt )library} system command {\it exposes} all
-domains and categories it processes.
-This means that the Axiom intepreter will consider those
-domains and categories when it is trying to resolve a reference
-to a function.
-Sometimes domains and categories should not be exposed.
-For example, a domain may just be used privately by another
-domain and may not be meant for top-level use.
-The {\tt )library} command should still be used, though, so that
-the code will be loaded on demand.
-In this case, you should use the {\tt )nolibrary} option on {\tt
-)compile} and the {\tt )noexpose} option in the {\tt )library}
-command. For example,
-\begin{verbatim}
-)compile mycode )nolibrary
-)library mycode )noexpose
-\end{verbatim}
-
-Once you have established your own collection of compiled code,
-you may find it handy to use the {\tt )dir} option on the
-{\tt )library} command.
-This causes {\tt )library} to process all compiled code in the
-specified directory. For example,
-\begin{verbatim}
-)library )dir /u/jones/quantum
-\end{verbatim}
-You must give an explicit directory after {\tt )dir}, even if you
-want all compiled code in the current working directory
-processed, e.g.
-\begin{verbatim}
-)library )dir .
-\end{verbatim}
-
-\subsection{Spad compiler}
-This command compiles files with file extension {\tt .spad}
-with the old Axiom system compiler.  
-
-The {\tt )translate} option is used to invoke a special version of the
-old system compiler that will translate a {\it .spad} file to a {\it
-.as} file.  That is, the {\it .spad} file will be parsed and analyzed
-and a file using the new syntax will be created.
-
-By default, the {\it .as} file is created in the same directory as the
-{\it .spad} file. If that directory is not writable, the current
-directory is used. If the current directory is not writable, an error
-message is given and the command terminates.  Note that {\tt )translate} 
-implies the {\tt )old} option so the file extension can
-safely be omitted. If {\tt )translate} is given, all other options are
-ignored.  Please be aware that the translation is not necessarily one
-hundred percent complete or correct.  You should attempt to compile
-the output with the Aldor compiler and make any necessary corrections.
-
-You can compile category, domain, and package constructors contained
-in files with file extension {\it .spad}.  You can compile individual
-constructors or every constructor in a file.
-
-The full filename is remembered between invocations of this command and
-{\tt )edit} commands. The sequence of commands
-\begin{verbatim}
-)compile matrix.spad
-)edit
-)compile
-\end{verbatim}
-will call the compiler, edit, and then call the compiler again on the
-file {\bf matrix.spad.}  If you do not specify a {\it directory,} the
-working current directory is searched for the file.  If the file is
-not found, the standard system directories are searched.
-
-If you do not give any options, all constructors within a file are
-compiled.  Each constructor should have an {\tt )abbreviation} command
-in the file in which it is defined.  We suggest that you place the
-{\tt )abbreviation} commands at the top of the file in the order in
-which the constructors are defined.
-
-The {\tt )library} option causes directories containing the compiled
-code for each constructor to be created in the working current
-directory.  The name of such a directory consists of the constructor
-abbreviation and the {\bf .nrlib} file extension.  For example, the
-directory containing the compiled code for the {\tt MATRIX}
-constructor is called {\bf MATRIX.nrlib.}  The {\tt )nolibrary} option
-says that such files should not be created.  The default is 
-{\tt )library.}  Note that the semantics of {\tt )library} and 
-{\tt )nolibrary} for the new Aldor compiler and for the old system 
-compiler are completely different.
-
-The {\tt )vartrace} option causes the compiler to generate
-extra code for the constructor to support conditional tracing of
-variable assignments. (see 
-\ref{ugSysCmdtrace} on page~\pageref{ugSysCmdtrace}). Without
-this option, this code is suppressed and one cannot use
-the {\tt )vars} option for the trace command.
-
-The {\tt )constructor} option is used to
-specify a particular constructor to compile.
-All other constructors in the file are ignored.
-The constructor name or abbreviation follows {\tt )constructor.}
-Thus either
-\begin{verbatim}
-)compile matrix.spad )constructor RectangularMatrix
-\end{verbatim}
-or
-\begin{verbatim}
-)compile matrix.spad )constructor RMATRIX
-\end{verbatim}
-compiles  the {\tt RectangularMatrix} constructor
-defined in {\bf matrix.spad.}
-
-The {\tt )break} and {\tt )nobreak} options determine what
-the spad compiler does when it encounters an error.
-{\tt )break} is the default and it indicates that processing
-should stop at the first error.
-The value of the {\tt )set break} variable then controls what happens.
-
-\subsection{Aldor compiler}
-This command compiles files with file extensions {\it .as, .ao} and
-{\it .al} with the Aldor compiler. It also can compile files
-with file extension {\it .lsp}. These are assumed to be Lisp files
-genererated by the Aldor compiler.  
-
-The general description of Aldor command line arguments is in
-the Aldor documentation.
-The default options used by the {\tt )compile} command can be
-viewed and set using the {\tt )set compiler args} Axiom
-system command.
-The current defaults are
-\begin{verbatim}
--O -Fasy -Fao -Flsp -laxiom -Mno-AXL_W_WillObsolete -DAxiom
-\end{verbatim}
-These options mean:
-\begin{itemize}
-\item {\tt -O}: perform all optimizations,
-\item {\tt -Fasy}: generate a {\tt .asy} file,
-\item {\tt -Fao}: generate a {\tt .ao} file,
-\item {\tt -Flsp}: generate a {\tt .lsp} (Lisp) file,
-\item {\tt -laxiom}: use the {\tt axiom} library {\tt libaxiom.al},
-\item {\tt -Mno-AXL\_W\_WillObsolete}: do not display messages
-about older generated files becoming obsolete, and
-\item {\tt -DAxiom}: define the global assertion {\tt Axiom} so that the
-Aldor libraries for generating stand-alone code
-are not accidentally used with Axiom.
-\end{itemize}
-
-To supplement these default arguments, use the {\tt )moreargs} option on
-{\tt )compile.}
-For example,
-\begin{verbatim}
-)compile mycode.as )moreargs "-v"
-\end{verbatim}
-uses the default arguments and appends the {\tt -v} (verbose)
-argument flag.
-The additional argument specification {\bf must be enclosed in
-double quotes.}
-
-To completely replace these default arguments for a particular
-use of {\tt )compile}, use the {\tt )onlyargs} option.
-For example,
-\begin{verbatim}
-)compile mycode.as )onlyargs "-v -O"
-\end{verbatim}
-only uses the {\tt -v} (verbose) and {\tt -O} (optimize)
-arguments.
-The argument specification {\bf must be enclosed in double quotes.}
-In this example, Lisp code is not produced and so the compilation
-output will not be available to Axiom.
-
-To completely replace the default arguments for all calls to {\tt
-)compile} within your Axiom session, use {\tt )set compiler args.}
-For example, to use the above arguments for all compilations, issue
-\begin{verbatim}
-)set compiler args "-v -O"
-\end{verbatim}
-Make sure you include the necessary {\tt -l} and {\tt -Y}
-arguments along with those needed for Lisp file creation.
-As above, {\bf the argument specification must be enclosed in double
-quotes.}
-
-The {\tt )compile} command works with several file extensions. We saw
-above what happens when it is invoked on a file with extension {\tt
-.as.} A {\tt .ao} file is a portable binary compiled version of a
-{\tt .as} file, and {\tt )compile} simply passes the {\tt .ao} file
-onto Aldor. The generated Lisp file is compiled and {\tt )library}
-is automatically called, just as if you had specified a {\tt .as} file.
-
-A {\tt .al} file is an archive file containing {\tt .ao} files. The
-archive is created (on Unix systems) with the {\tt ar} program. When
-{\tt )compile} is given a {\tt .al} file, it creates a directory whose
-name is based on that of the archive. For example, if you issue
-\begin{verbatim}
-)compile mylib.al
-\end{verbatim}
-the directory {\tt mylib.axldir} is created. All members of the
-archive are unarchived into the directory and {\tt )compile} is called
-on each {\tt .ao} file found. It is your responsibility to remove the
-directory and its contents, if you choose to do so.
-
-A {\tt .lsp} file is a Lisp source file, generated by Aldor
-when called with the {\tt -Flsp} option. When {\tt )compile} is used
-with a {\tt .lsp} file, the Lisp file is compiled and {\tt )library}
-is called. For Aldor, You must also have present a {\tt .asy}
-generated from the same source file.
-
-\subsection{compileSpad2Cmd}
-<<*>>=
-compileSpad2Cmd args ==
-    -- This is the old compiler
-    -- Assume we entered from the "compiler" function, so args ^= nil
-    -- and is a file with file extension .spad.
-
-    path := pathname args
-    pathnameType path ^= '"spad" => throwKeyedMsg("S2IZ0082", nil)
-    ^PROBE_-FILE path => throwKeyedMsg("S2IL0003",[namestring args])
-
-    SETQ(_/EDITFILE, path)
-    updateSourceFiles path
-    sayKeyedMsg("S2IZ0038",[namestring args])
-
-    optList :=  '( _
-      break _
-      constructor _
-      functions _
-      library _
-      lisp _
-      new _
-      old _
-      nobreak _
-      nolibrary _
-      noquiet _
-      vartrace _
-      quiet _
-      translate _
-        )
-
-    -- next three are for the OLD NEW compiler
-    -- should be unhooked
-
-    $newcompMode             : local := nil
-    $ncConverse              : local := nil
-    $newComp                 : local := nil
-
-    translateOldToNew        := nil
-
-    $scanIfTrue              : local := nil
-    $compileOnlyCertainItems : local := nil
-    $f                       : local := nil  -- compiler
-    $m                       : local := nil  --   variables
-
-    -- following are for )quick option for code generation
-    $QuickLet   : local := true
-    $QuickCode  : local := true
-
-    fun         := ['rq, 'lib]
-    constructor := nil
-    $sourceFileTypes : local := '("SPAD")
-
-    for opt in $options repeat
-        [optname,:optargs] := opt
-        fullopt := selectOptionLC(optname,optList,nil)
-
-        fullopt = 'new    => error "Internal error: compileSpad2Cmd got )new"
-        fullopt = 'old         => NIL     -- no opt
-        fullopt = 'translate   => translateOldToNew := true
-
-        fullopt = 'library     => fun.1 := 'lib
-        fullopt = 'nolibrary   => fun.1 := 'nolib
-
-        -- Ignore quiet/nonquiet if "constructor" is given.
-        fullopt = 'quiet       => if fun.0 ^= 'c then fun.0 := 'rq
-        fullopt = 'noquiet     => if fun.0 ^= 'c then fun.0 := 'rf
-        fullopt = 'nobreak     => $scanIfTrue := true
-        fullopt = 'break       => $scanIfTrue := nil
-        fullopt = 'vartrace      =>
-          $QuickLet  := false
-        fullopt = 'lisp        =>
-          throwKeyedMsg("S2IZ0036",['")lisp"])
-        fullopt = 'functions   =>
-            null optargs =>
-              throwKeyedMsg("S2IZ0037",['")functions"])
-            $compileOnlyCertainItems := optargs
-        fullopt = 'constructor =>
-            null optargs =>
-              throwKeyedMsg("S2IZ0037",['")constructor"])
-            fun.0       := 'c
-            constructor := [unabbrev o for o in optargs]
-        throwKeyedMsg("S2IZ0036",[STRCONC('")",object2String optname)])
-
-    $InteractiveMode : local := nil
-    if translateOldToNew then
-	oldParserAutoloadOnceTrigger()
-        browserAutoloadOnceTrigger()
-        spad2AsTranslatorAutoloadOnceTrigger()
-        sayKeyedMsg("S2IZ0085", nil)
-        convertSpadToAsFile path
-    else if $compileOnlyCertainItems then
-        null constructor => sayKeyedMsg("S2IZ0040",NIL)
-        compilerDoitWithScreenedLisplib(constructor, fun)
-    else
-        compilerDoit(constructor, fun)
-    extendLocalLibdb $newConlist
-    terminateSystemCommand()
-    spadPrompt()
-
-@
 \subsection{convertSpadToAsFile}
 <<*>>=
 convertSpadToAsFile path ==
diff --git a/src/interp/util.lisp.pamphlet b/src/interp/util.lisp.pamphlet
index a754b43..962138b 100644
--- a/src/interp/util.lisp.pamphlet
+++ b/src/interp/util.lisp.pamphlet
@@ -373,7 +373,7 @@ developers who write or modify algebra code.
       '(
 ;;      loadcompiler
 	|oldCompilerAutoloadOnceTrigger|
-	|compileSpad2Cmd|
+;;	|compileSpad2Cmd|
 	|convertSpadToAsFile|
 	|compilerDoit|
 	|compilerDoitWithScreenedLisplib|



From MAILER-DAEMON Mon Mar 30 06:08:30 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LoEPu-0007vA-MN
	for mharc-axiom-developer@gnu.org; Mon, 30 Mar 2009 06:08:30 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LoEPs-0007v0-D8
	for axiom-developer@nongnu.org; Mon, 30 Mar 2009 06:08:28 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LoEPf-0007kZ-36
	for axiom-developer@nongnu.org; Mon, 30 Mar 2009 06:08:28 -0400
Received: from [199.232.76.173] (port=60218 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LoEPe-0007kL-S0
	for axiom-developer@nongnu.org; Mon, 30 Mar 2009 06:08:14 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:59934
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LoEPb-0007vj-UC
	for axiom-developer@nongnu.org; Mon, 30 Mar 2009 06:08:14 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n2UA8Aug022197;
	Mon, 30 Mar 2009 04:08:10 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n2UA89U3022191;
	Mon, 30 Mar 2009 04:08:09 -0600
Date: Mon, 30 Mar 2009 04:08:09 -0600
Message-Id: <200903301008.n2UA89U3022191@axiom-developer.org>
To: axiom-developer@nongnu.org
MIME-version: 1.0
Content-type: text/plain; charset=iso-8859-1
Content-Transfer-Encoding: quoted-printable
X-MIME-Autoconverted: from 8bit to quoted-printable by axiom-developer.org id
	n2UA8Aug022197
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090329.01.tpd.patch (bookvol9 add compiler code)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 30 Mar 2009 10:08:28 -0000

Compiler code was moved from bookvol5 and comp.lisp into bookvol9.

In addition, unit testing for interpreter and compiler code is started.
There are now tests for all global variables in the interpreter code
that exist within bookvol5. This will be updated as code is collected.

There is a list of global variables, functions, catch and throw tags
for the interpreter and compiler code currently existing in their
respective books.=20

There will be unit test code for the individual interpreter and compiler
functions to ensure that nothing major breaks.

Tim
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
diff --git a/books/bookvol5.pamphlet b/books/bookvol5.pamphlet
index cd1b36f..1a1e53a 100644
--- a/books/bookvol5.pamphlet
+++ b/books/bookvol5.pamphlet
@@ -618,7 +618,7 @@ Thus, when a system command is entered this function =
is called.
   (setq |$ncMsgList| nil)=20
   (setq |$systemCommandFunction| #'|InterpExecuteSpadSystemCommand|)=20
   (setq |$shoeReadLineFunction| #'|serverReadLine|)=20
-  (setq |$promptMsg| 'S2CTP023)=20
+  (setq |$promptMsg| 's2ctp023)=20
   (if interactive?=20
    (progn=20
      (princ (mkprompt))=20
@@ -744,7 +744,7 @@ of the {\bf AXIOM} shell variable at build time) if w=
e can't.
=20
 Called from \fnref{restart}.
 <<defun initroot>>=3D
-(defun initroot (&optional (newroot (BOOT::|getEnv| "AXIOM")))
+(defun initroot (&optional (newroot (getenviron "AXIOM")))
   (declare (special $spadroot))
   (reroot (or newroot $spadroot (error "setenv AXIOM or (setq $spadroot)=
"))))
=20
@@ -776,6 +776,7 @@ Prefix a filename with the {\bf AXIOM} shell variable.
 \defun{makeInitialModemapFrame}{makeInitialModemapFrame}
 <<defun makeInitialModemapFrame>>=3D
 (defun |makeInitialModemapFrame| ()
+  (declare (special |$InitialModemapFrame|))=20
   (copy |$InitialModemapFrame|))=20
=20
 @
@@ -866,17 +867,14 @@ they result in a dotted pair if the input is not a =
cons. However,
 this is what the current code does so I won't change it.
 <<defun setCurrentLine>>=3D
 (defun |setCurrentLine| (s)
+ (declare (special |$currentLine|))
  (cond=20
-  ((null |$currentLine|)=20
-    (setq |$currentLine| s))
+  ((null |$currentLine|) (setq |$currentLine| s))
   ((and (stringp |$currentLine|) (stringp s))
     (setq |$currentLine| (list |$currentLine| s)))
-  ((not (consp |$currentLine|))
-    (setq |$currentLine| (cons |$currentLine| s)))
-  ((stringp s)
-    (rplacd (last |$currentLine|) (cons s nil)))
-  (t=20
-    (rplacd (last |$currentLine|) s)))
+  ((not (consp |$currentLine|)) (setq |$currentLine| (cons |$currentLine=
| s)))
+  ((stringp s) (rplacd (last |$currentLine|) (cons s nil)))
+  (t (rplacd (last |$currentLine|) s)))
  |$currentLine|)
=20
 @
@@ -1000,18 +998,12 @@ Certain functions, such as the lisp function need =
to be able to handle
 all kinds of input that will not be acceptable to the interpreter.=20
 <<initvars>>=3D
 (defvar |$noParseCommands| nil)
+
+@
+<<postvars>>=3D
 (eval-when (eval load)
- (setq |$noParseCommands|=20
- '( |boot|
-    |copyright|
-    |credits|
-    |fin|
-    |lisp|
-    |pquit|
-    |quit|
-    |suspend|
-    |synonym|
-    |system|
+ (setq |$noParseCommands|
+ '(|boot| |copyright| |credits| |fin| |lisp| |pquit| |quit| |synonym| |s=
ystem|
     )))
=20
 @
@@ -1084,6 +1076,10 @@ their arguments. Thus the history command expects =
that Axiom will have
 tokenized and validated the input before calling the history function.
 <<initvars>>=3D
 (defvar |$tokenCommands| nil)
+
+@
+
+<<postvars>>=3D
 (eval-when (eval load)
  (setq |$tokenCommands|
  '( |abbreviations|
@@ -1120,6 +1116,10 @@ Axiom can create ``synonyms'' for commands. We cre=
ate an initial table
 of synonyms which are in common use.
 <<initvars>>=3D
 (defvar |$InitialCommandSynonymAlist| nil)
+
+@
+
+<<postvars>>=3D
 (eval-when (eval load)
  (setq |$InitialCommandSynonymAlist|
    '(
@@ -1203,14 +1203,13 @@ the contents of a file inline in the input stream=
. This is useful
 for processing \verb|)read| of input files.
 <<defun ncloopCommand>>=3D
 (defun |ncloopCommand| (line n)
- (declare (special |$systemCommandFunction|))
  (let (a)
-  (cond
-   ((setq a (|ncloopPrefix?| ")include" line))
-     (|ncloopInclude1| a n))
-   (t
-     (funcall |$systemCommandFunction| line)
-     n))))
+ (declare (special |$systemCommandFunction|))
+  (if (setq a (|ncloopPrefix?| ")include" line))
+   (|ncloopInclude1| a n)
+   (progn
+    (funcall |$systemCommandFunction| line)
+    n))))
=20
 @
=20
@@ -1271,29 +1270,22 @@ we return the remainder of the string without the=
 leading prefix.
=20
 \par\noindent{\bf Command Description:}
=20
-This command is used to query, set and remove abbreviations for category=
,
-domain and package constructors.
-Every constructor must have a unique abbreviation.
-This abbreviation is part of the name of the subdirectory
-under which the components of the compiled constructor are
-stored.
-%% BEGIN OBSOLETE
-% It is this abbreviation that is used to bring compiled code into
-% Axiom with the {\tt )load} command.
-%% END OBSOLETE
-Furthermore, by issuing this command you
-let the system know what file to load automatically if you use a new
-constructor.
-Abbreviations must start with a letter and then be followed by
-up to seven letters or digits.
-Any letters appearing in the abbreviation must be in uppercase.
-
-When used with the {\tt query} argument,
-\index{abbreviation query}
-this command may be used to list the name
-associated with a  particular abbreviation or the  abbreviation for a
-constructor.
-If no abbreviation or name is given, the names and corresponding
+This command is used to query, set and remove abbreviations for
+category, domain and package constructors.  Every constructor must
+have a unique abbreviation.  This abbreviation is part of the name of
+the subdirectory under which the components of the compiled
+constructor are stored.
+
+Furthermore, by issuing this command you let the system know what file
+to load automatically if you use a new constructor.  Abbreviations
+must start with a letter and then be followed by up to seven letters
+or digits.  Any letters appearing in the abbreviation must be in
+uppercase.
+
+When used with the {\tt query} argument, \index{abbreviation query}
+this command may be used to list the name associated with a particular
+abbreviation or the abbreviation for a constructor.  If no
+abbreviation or name is given, the names and corresponding
 abbreviations for {\it all} constructors are listed.
=20
 The following shows the abbreviation for the constructor {\tt List}:
@@ -1322,23 +1314,20 @@ category, domain and package, respectively:
 )abbreviation category COMPCAT  ComplexCategory
 )abbreviation package  LIST2MAP ListToMap
 \end{verbatim}
-If the {\tt )quiet} option is used,
-no output is displayed from this command.
-You would normally only define an abbreviation in a library source file.
-If this command is issued for a constructor that has already been loaded=
, the
-constructor will be reloaded next time it is referenced.  In particular,=
 you
-can use this command to force the automatic reloading of constructors.
+If the {\tt )quiet} option is used, no output is displayed from this
+command.  You would normally only define an abbreviation in a library
+source file.  If this command is issued for a constructor that has
+already been loaded, the constructor will be reloaded next time it is
+referenced.  In particular, you can use this command to force the
+automatic reloading of constructors.
=20
 To remove an abbreviation, the {\tt remove} argument is used.
-\index{abbreviation remove}
-This is usually
-only used to correct a previous command that set an abbreviation for a
-constructor name.
-If, in fact, the abbreviation does exist, you are prompted
-for confirmation of the removal request.
-Either of the following commands
-will remove the abbreviation {\tt VECTOR2} and the
-constructor name {\tt VectorFunctions2} from the system:
+\index{abbreviation remove} This is usually only used to correct a
+previous command that set an abbreviation for a constructor name.  If,
+in fact, the abbreviation does exist, you are prompted for
+confirmation of the removal request.  Either of the following commands
+will remove the abbreviation {\tt VECTOR2} and the constructor name
+{\tt VectorFunctions2} from the system:
 \begin{verbatim}
 )abbreviation remove VECTOR2
 )abbreviation remove VectorFunctions2
@@ -1451,6 +1440,10 @@ obtained by translating the BOOT code.
 \section{Variables Used}
 \section{Functions}
=20
+This command is in the list of \verb|$noParseCommands|
+\ref{noParseCommands} which means that its arguments are passed
+verbatim. This will eventually result in a call to the function
+\verb|handleNoParseCommands| \ref{handleNoParseCommands}
=20
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{browse}
@@ -1737,10 +1730,9 @@ this has the same syntax as the operating system {=
\tt cd} command.
 \end{list}
 \par\noindent{\bf Command Description:}
=20
-This command is used to remove function and variable declarations, defin=
itions
-and values  from the workspace.
-To  empty the entire workspace  and reset the
-step counter to 1, issue
+This command is used to remove function and variable declarations,
+definitions and values from the workspace.  To empty the entire
+workspace and reset the step counter to 1, issue
 \begin{verbatim}
 )clear all
 \end{verbatim}
@@ -1818,6 +1810,8 @@ system function and constructor caches.
 @
=20
 \defun{clearSpad2Cmd}{clearSpad2Cmd}
+TPDHERE: Note that this function also seems to parse out )except
+)completely and )scaches which don't seem to be documented.
 <<defun clearSpad2Cmd>>=3D
 (defun |clearSpad2Cmd| (l)
   (let (|$clearExcept| opt optlist arg)
@@ -1902,7 +1896,7 @@ system function and constructor caches.
   (|sayKeyedMsg| 's2iz0013 nil)
   (|clearClams|)
   (|clearConstructorCaches|)
-  (setq |$existingFiles| (make-hashtable 'UEQUAL))
+  (setq |$existingFiles| (make-hashtable 'uequal))
   (|sayKeyedMsg| 's2iz0014 nil)
   (reclaim)
   (|sayKeyedMsg| 's2iz0015 nil))
@@ -2439,8 +2433,7 @@ The value of the {\tt )set break} variable then con=
trols what happens.
       (|constructor| (setq haveold t))
       (|old|         (setq haveold t))))
     (cond
-     ((and havenew haveold)=20
-      (|throwKeyedMsg| 's2iz0081 nil))
+     ((and havenew haveold) (|throwKeyedMsg| 's2iz0081 nil))
      (t
       (setq af (|pathname| args))
       (setq aft (|pathnameType| af))
@@ -2509,260 +2502,6 @@ The value of the {\tt )set break} variable then c=
ontrols what happens.
=20
 @
=20
-\defun{compileAsharpCmd}{compileAsharpCmd}
-<<defun compileAsharpCmd>>=3D
-(defun |compileAsharpCmd| (args)
-  (|compileAsharpCmd1| args)
-  (|terminateSystemCommand|)
-  (|spadPrompt|))
-
-@
-
-\defun{compileAsharpCmd1}{compileAsharpCmd1}
-<<defun compileAsharpCmd1>>=3D
-(defun |compileAsharpCmd1| (args)
- (let (path pathtype optlist optname optargs bequiet docompilelisp=20
-        moreargs onlyargs dolibrary p tempargs s asharpargs command rc l=
sp)
-   (declare (special |$options| |$asharpCmdlineFlags| |$newConlist|
-             /editfile))
-   (setq path (|pathname| args))
-   (setq pathtype (|pathnameType| path))
-   (cond
-   ((and (nequal pathtype "as") (nequal pathtype "ao"))
-     (|throwKeyedMsg| 's2iz0083 nil))
-   ((null (probe-file path))
-     (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil)))
-   (t
-    (setq /editfile path)
-    (|updateSourceFiles| path)
-    (setq optlist
-     '(|new| |old| |translate| |onlyargs| |moreargs| |quiet|=20
-       |nolispcompile| |noquiet| |library| |nolibrary|))
-    (setq bequiet nil)
-    (setq dolibrary t)
-    (setq docompilelisp t)
-    (setq moreargs nil)
-    (setq onlyargs nil)
-    (dolist (opt |$options|)
-      (setq optname (car opt))
-      (setq optargs (cdr opt))
-      (case (|selectOptionLC| optname optlist nil)
-       (|new| nil)
-       (|old| (|error| '|Internal error: compileAsharpCmd got )old|))
-       (|translate|
-        (|error| '|Internal error: compileAsharpCmd got )translate|))
-       (|quiet|         (setq bequiet t))
-       (|noquiet|       (setq bequiet nil))
-       (|nolispcompile| (setq docompilelisp nil))
-       (|moreargs|      (setq moreargs optargs))
-       (|onlyargs|      (setq onlyargs optargs))
-       (|library|       (setq dolibrary t))
-       (|nolibrary|     (setq dolibrary nil))
-       (t=20
-        (|throwKeyedMsg| 's2iz0036
-         (cons (strconc ")" (|object2String| optname)) nil)))))
-    (setq tempargs
-     (if (string=3D pathtype "ao")
-       (if (setq p (strpos "-Fao" |$asharpCmdlineFlags| 0 nil))
-         (if (eql p 0)=20
-          (substring |$asharpCmdlineFlags| 5 nil)
-          (strconc (substring |$asharpCmdlineFlags| 0 p)=20
-             " " (substring |$asharpCmdlineFlags| (plus p 5) nil)))
-         |$asharpCmdlineFlags|)
-       |$asharpCmdlineFlags|))
-    (setq asharpargs
-     (cond
-      (onlyargs
-       (setq s '||)
-       (do ((t1 onlyargs (cdr t1)) (|a| nil))
-           ((or (atom t1) (progn (setq |a| (car t1)) nil)) nil)
-        (seq
-         (exit
-          (setq s (strconc s " " (|object2String| |a|))))))
-       s)
-      (moreargs
-       (setq s tempargs)
-       (do ((t2 moreargs (cdr t2)) (|a| nil))
-           ((or (atom t2) (progn (setq |a| (car t2)) nil)) nil)
-        (seq
-         (exit
-          (setq s (strconc s " " (|object2String| |a|))))))
-       s)
-      (t tempargs)))
-    (unless bequiet
-     (|sayKeyedMsg| 's2iz0038a  (list (|namestring| args) asharpargs )))
-    (setq command
-     (strconc
-      (strconc (getenv "ALDORROOT") "/bin/")
-      '|aldor | asharpargs " " (|namestring| args)))
-    (setq rc (obey command))
-    (cond
-     ((and (eql rc 0) docompilelisp)
-       (setq lsp (|fnameMake| "." (|pathnameName| args) "lsp"))
-       (cond
-        ((|fnameReadable?| lsp)
-         (unless  bequiet
-           (|sayKeyedMsg| 's2iz0089 (cons (|namestring| lsp) nil)))
-         (|compileFileQuietly| lsp))
-        (t (|sayKeyedMsg| 's2il0003 (cons (|namestring| lsp) nil))))))
-    (cond
-     ((and (eql rc 0) dolibrary)
-      (unless bequiet
-         (|sayKeyedMsg| 's2iz0090 (cons (|pathnameName| path) nil)))
-      (|withAsharpCmd| (cons (|pathnameName| path) nil)))
-     ((null bequiet) (|sayKeyedMsg| 's2iz0084 nil))
-     (t nil))
-    (|extendLocalLibdb| |$newConlist|)))))
-
-@
-
-\defun{compileAsharpArchiveCmd}{compileAsharpArchiveCmd}
-<<defun compileAsharpArchiveCmd>>=3D
-(defun |compileAsharpArchiveCmd| (args)
- (let (path dir exists isdir curdir cmd rc asos)
-  (declare (special $current-directory))
-  (setq path (|pathname| args))
-  (if (null (probe-file path))
-   (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil))
-   (progn
-    (setq dir (|fnameMake| "." (|pathnameName| path) "axldir"))
-    (setq exists (probe-file dir))
-    (setq isdir (|directoryp| (|namestring| dir)))
-    (if (and exists (nequal isdir 1))
-     (|throwKeyedMsg| 's2il0027 (list (|namestring| dir) (|namestring| a=
rgs)))
-     (progn
-      (when (nequal isdir 1)
-        (setq cmd (strconc "mkdir " (|namestring| dir)))
-        (setq rc (obey cmd))
-        (when (nequal rc 0)
-          (|throwKeyedMsg| 's2il0027=20
-           (list (|namestring| dir) (|namestring| args)))))
-      (setq curdir $current-directory)
-      (|cd| (cons (|object2Identifier| (|namestring| dir)) nil))
-      (setq cmd (strconc "ar x " (|namestring| path)))
-      (setq rc (obey cmd))
-      (cond
-       ((nequal rc 0)
-        (|cd| (cons (|object2Identifier| (|namestring| curdir)) nil))
-        (|throwKeyedMsg| 's2il0028
-         (cons (|namestring| dir) (cons (|namestring| args) nil))))
-       (t
-        (setq asos (directory (makestring "*.ao")))
-        (if (null asos)
-         (progn
-          (|cd| (cons (|object2Identifier| (|namestring| curdir)) nil))
-          (|throwKeyedMsg| 's2il0029
-           (cons (|namestring| dir) (cons (|namestring| args) nil))))
-         (progn
-          (dolist (aso asos)
-             (|compileAsharpCmd1| (list (|namestring| aso))))
-          (|cd| (list (|object2Identifier| (|namestring| curdir))))
-          (|terminateSystemCommand|)
-          (|spadPrompt|)))))))))))
-
-@
-
-\defun{compileAsharpLispCmd}{compileAsharpLispCmd}
-<<defun compileAsharpLispCmd>>=3D
-(defun |compileAsharpLispCmd| (args)
- (let (path optlist optname optargs bequiet dolibrary lsp)
-  (declare (special |$options|))
-  (setq path (|pathname| args))
-  (cond
-   ((null (probe-file path))=20
-      (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil)))
-   (t
-    (setq optlist '(|quiet| |noquiet| |library| |nolibrary|))
-    (setq bequiet nil)
-    (setq dolibrary t)
-    (dolist (opt |$options|)
-      (setq optname (car opt))
-      (setq optargs (cdr opt))
-      (case (|selectOptionLC| optname optlist nil)
-        (|quiet|     (setq bequiet t))
-        (|noquiet|   (setq bequiet nil))
-        (|library|   (setq dolibrary t))
-        (|nolibrary| (setq dolibrary nil))
-        (t
-          (|throwKeyedMsg| 's2iz0036=20
-           (list (strconc ")" (|object2String| optname)))))))
-    (setq lsp
-     (|fnameMake|
-      (|pathnameDirectory| path)
-      (|pathnameName| path)
-      (|pathnameType| path)))
-    (cond
-     ((|fnameReadable?| lsp)
-      (unless bequiet
-         (|sayKeyedMsg| 's2iz0089 (cons (|namestring| lsp) nil)))
-      (|compileFileQuietly| lsp))
-     (t (|sayKeyedMsg| 's2il0003 (cons (|namestring| lsp) nil))))
-    (cond
-     (dolibrary
-      (unless  bequiet
-        (|sayKeyedMsg| 's2iz0090 (cons (|pathnameName| path) nil)))
-      (|withAsharpCmd| (cons (|pathnameName| path) nil)))
-     ((null bequiet) (|sayKeyedMsg| 's2iz0084 nil))
-     (t nil))
-    (|terminateSystemCommand|)
-    (|spadPrompt|)))))
-
-@
-
-\defun{compileSpadLispCmd}{compileSpadLispCmd}
-<<defun compileSpadLispCmd>>=3D
-(defun |compileSpadLispCmd| (args)
- (let (path optlist optname optargs beQuiet dolibrary lsp)
-  (declare (special |$options|))
-  (setq path (|pathname| (|fnameMake| (car args) "code" "lsp")))
-  (cond
-   ((null (probe-file path))
-     (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil)))
-   (t
-    (setq optlist '(|quiet| |noquiet| |library| |nolibrary|))
-    (setq beQuiet nil)
-    (setq dolibrary t)
-    (dolist (opt |$options|)
-      (setq optname (car opt))
-      (setq optargs (cdr opt))
-      (case (|selectOptionLC| optname optlist nil)
-         (|quiet|     (setq beQuiet t))
-         (|noquiet|   (setq beQuiet nil))
-         (|library|   (setq dolibrary t))
-         (|nolibrary| (setq dolibrary nil))
-         (t
-          (|throwKeyedMsg| 's2iz0036
-           (list (strconc ")" (|object2String| optname)))))))
-    (setq lsp
-     (|fnameMake|
-      (|pathnameDirectory| path)
-      (|pathnameName| path)
-      (|pathnameType| path)))
-    (cond
-     ((|fnameReadable?| lsp)
-      (unless beQuiet (|sayKeyedMsg| 's2iz0089 (list (|namestring| lsp))=
))
-       (recompile-lib-file-if-necessary lsp))
-     (t
-      (|sayKeyedMsg| 's2il0003 (list (|namestring| lsp)))))
-    (cond
-     (dolibrary
-      (unless beQuiet (|sayKeyedMsg| 's2iz0090 (list (|pathnameName| pat=
h))))
-      (localdatabase (list (|pathnameName| (car args))) nil))
-     ((null beQuiet) (|sayKeyedMsg| 's2iz0084 nil))
-     (t nil))
-    (|terminateSystemCommand|)
-    (|spadPrompt|)))))
-
-@
-
-\defun{withAsharpCmd}{withAsharpCmd}
-<<defun withAsharpCmd>>=3D
-(defun |withAsharpCmd| (args)
- (let (|$options|)
-  (declare (special |$options|))
-  (localdatabase args |$options|)))
-
-@
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{copyright}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@@ -2772,10 +2511,15 @@ The value of the {\tt )set break} variable then c=
ontrols what happens.
 \defun{copyright}{copyright}
 <<defun copyright>>=3D
 (defun |copyright| ()
- (obey (strconc "cat " (|getEnv| "AXIOM") "/lib/copyright")))
+ (obey (strconc "cat " (getenviron "AXIOM") "/lib/copyright")))
=20
 @
=20
+This command is in the list of \verb|$noParseCommands|
+\ref{noParseCommands} which means that its arguments are passed
+verbatim. This will eventually result in a call to the function
+\verb|handleNoParseCommands| \ref{handleNoParseCommands}
+
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{credits}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@@ -2790,6 +2534,11 @@ The value of the {\tt )set break} variable then co=
ntrols what happens.
=20
 @
=20
+This command is in the list of \verb|$noParseCommands|
+\ref{noParseCommands} which means that its arguments are passed
+verbatim. This will eventually result in a call to the function
+\verb|handleNoParseCommands| \ref{handleNoParseCommands}
+
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{display}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@@ -3266,6 +3015,11 @@ function call to Common Lisp.
 \section{Variables Used}
 \section{Functions}
=20
+This command is in the list of \verb|$noParseCommands|
+\ref{noParseCommands} which means that its arguments are passed
+verbatim. This will eventually result in a call to the function
+\verb|handleNoParseCommands| \ref{handleNoParseCommands}
+
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{frame}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@@ -4250,11 +4004,6 @@ environment to \verb|$HistList| and \verb|$HistRec=
ord|.
 (defvar |$historyDirectory| 'A        "vm/370 filename disk component")
=20
 @
-\defdollar{HiFiAccess}
-<<initvars>>=3D
-(defvar |$HiFiAccess| t               "t means turn on history mechanism=
")
-
-@
 \defdollar{useInternalHistoryTable}
 <<initvars>>=3D
 (defvar |$useInternalHistoryTable| t  "t means keep history in core")
@@ -4271,7 +4020,8 @@ environment to \verb|$HistList| and \verb|$HistReco=
rd|.
 \defun{oldHistFileName}{oldHistFileName}
 <<defun oldHistFileName>>=3D
 (defun |oldHistFileName| ()
- (|makeHistFileName| |$oldHistoryFileName|))=20
+ (declare (special |$oldHistoryFileName|))
+ (|makeHistFileName| |$oldHistoryFileName|))
=20
 @
 \defun{histFileName}{histFileName}
@@ -4286,26 +4036,24 @@ environment to \verb|$HistList| and \verb|$HistRe=
cord|.
 (defun |histInputFileName| (fn)
  (declare (special |$interpreterFrameName| |$historyDirectory|))
  (if (null fn)
-    (|makePathname| |$interpreterFrameName| 'input |$historyDirectory|)
-    (|makePathname| fn 'input |$historyDirectory|)))
+   (|makePathname| |$interpreterFrameName| 'input |$historyDirectory|)
+   (|makePathname| fn 'input |$historyDirectory|)))
 @
=20
 \defun{initHist}{initHist}
 <<defun initHist>>=3D
 (defun |initHist| ()
- (prog (oldFile newFile)
-  (return
-   (cond
-     (|$useInternalHistoryTable|=20
-       (|initHistList|))
-     (t
+ (let (oldFile newFile)
+ (declare (special |$useInternalHistoryTable| |$HiFiAccess|))
+   (if |$useInternalHistoryTable|=20
+     (|initHistList|)
+     (progn
        (setq oldFile (|oldHistFileName|))
        (setq newFile (|histFileName|))
        (|histFileErase| oldFile)
-       (when (make-input-filename newFile)
-        ($replace oldFile newFile))
+       (when (make-input-filename newFile) ($replace oldFile newFile))
        (setq |$HiFiAccess| t)
-       (|initHistList|))))))=20
+       (|initHistList|)))))
 =20
 @
 \defun{initHistList}{initHistList}
@@ -4329,7 +4077,7 @@ environment to \verb|$HistList| and \verb|$HistReco=
rd|.
 (defun |history| (l)=20
  (declare (special |$options|))
  (if (or l (null |$options|))=20
-  (|sayKeyedMsg| 'S2IH0006 nil) ; syntax error
+  (|sayKeyedMsg| 's2ih0006 nil) ; syntax error
   (|historySpad2Cmd|)))
=20
 @
@@ -4443,13 +4191,13 @@ file and then write the in-memory history to a ne=
w file
   (cond=20
    ((boot-equal inCore |$useInternalHistoryTable|)=20
      (if inCore=20
-        (|sayKeyedMsg| 'S2IH0030 nil) ; memory history already in use
-        (|sayKeyedMsg| 'S2IH0029 nil))) ; file history already in use
+        (|sayKeyedMsg| 's2ih0030 nil) ; memory history already in use
+        (|sayKeyedMsg| 's2ih0029 nil))) ; file history already in use
    ((null |$HiFiAccess|)=20
      (setq |$useInternalHistoryTable| inCore)=20
      (if inCore=20
-        (|sayKeyedMsg| 'S2IH0032 nil) ; use memory history
-        (|sayKeyedMsg| 'S2IH0031 nil))) ; use file history
+        (|sayKeyedMsg| 's2ih0032 nil) ; use memory history
+        (|sayKeyedMsg| 's2ih0031 nil))) ; use file history
    (inCore=20
      (setq |$internalHistoryTable| nil)=20
      (cond=20
@@ -4491,7 +4239,7 @@ file and then write the in-memory history to a new =
file
      (setq |$HiFiAccess| t)
      (setq |$internalHistoryTable| nil)
      (setq |$useInternalHistoryTable| nil)
-     (|sayKeyedMsg| 'S2IH0031 nil))))) ; use file history
+     (|sayKeyedMsg| 's2ih0031 nil))))) ; use file history
=20
 @
 \defdollar{underbar}
@@ -4505,10 +4253,10 @@ Also used in the output routines.
 <<defun writeInputLines>>=3D
 (defun |writeInputLines| (fn initial)=20
  (let (maxn breakChars vecl k svec done n lineList file inp)=20
- (declare (special underbar))
+ (declare (special underbar |$HiFiAccess| |$IOindex|))
   (cond=20
-   ((null |$HiFiAccess|) (|sayKeyedMsg| 'S2IH0013 nil)) ; history is not=
 on
-   ((null fn) (|throwKeyedMsg| 'S2IH0038 nil)) ; missing file name
+   ((null |$HiFiAccess|) (|sayKeyedMsg| 's2ih0013 nil)) ; history is not=
 on
+   ((null fn) (|throwKeyedMsg| 's2ih0038 nil)) ; missing file name
    (t=20
      (setq maxn 72)
      (setq breakChars (cons '| | (cons '+ nil)))
@@ -4525,7 +4273,7 @@ Also used in the output routines.
              (do ((|j| 1 (qsadd1 |j|)))
                  ((or (qsgreaterp |j| maxn) (null (null done))) nil)
                (setq k (spaddifference (plus 1 maxn) |j|))
-               (when (memq (ELT vec k) breakChars)
+               (when (memq (elt vec k) breakChars)
                  (setq svec (strconc (substring vec 0 (1+ k)) underbar))
                  (setq lineList (cons svec lineList))
                  (setq done t)
@@ -4544,8 +4292,8 @@ Also used in the output routines.
        (write-line x inp))
      (cond=20
       ((nequal fn '|redo|)=20
-        (|sayKeyedMsg| 'S2IH0014 ; edit this file to see input lines
-          (cons (|namestring| file) nil))))
+        (|sayKeyedMsg| 's2ih0014 ; edit this file to see input lines
+          (list (|namestring| file)))))
      (shut inp)
      nil))))
=20
@@ -4567,7 +4315,7 @@ Also used in the output routines.
  (let (dif l)=20
  (declare (special |$HistListLen| |$HistList| |$HistListAct|))
  (if (null (integerp n))=20
-   (|sayKeyedMsg| 'S2IH0015 (cons n nil)) ; only positive integers
+   (|sayKeyedMsg| 's2ih0015 (list n)) ; only positive integers
    (progn
      (setq dif (spaddifference n |$HistListLen|))
      (setq |$HistListLen| n)=20
@@ -4576,16 +4324,12 @@ Also used in the output routines.
       ((> dif 0)=20
         (do ((|i| 1 (qsadd1 |i|)))
             ((qsgreaterp |i| dif) nil)
-         (seq
-          (exit
-           (setq l (cons nil l))))))
+           (setq l (cons nil l))))
       ((minusp dif)
         (do ((tmp0 (spaddifference dif))=20
              (|i| 1 (qsadd1 |i|)))
             ((qsgreaterp |i| tmp0) nil)
-         (seq
-          (exit
-           (setq l (cdr l)))))
+           (setq l (cdr l)))
         (cond
          ((> |$HistListAct| n) (setq |$HistListAct| n))
          (t nil))))
@@ -4694,7 +4438,7 @@ Also used in the output routines.
          (setq p (assq '% vec))
          (setq p1 (assq '|value| (cdr p)))
          (cdr p1))))
-      (|sayKeyedMsg| 'S2IH0019 (cons n nil)))) ; no history file
+      (|sayKeyedMsg| 's2ih0019 (cons n nil)))) ; no history file
   (setq |$InteractiveFrame| (|putHist| '% '|value| val |$InteractiveFram=
e|))
   (|updateHist|)))
=20
@@ -4744,24 +4488,15 @@ Also used in the output routines.
              (rplacd p nil))))))))))
   (do ((|i| 1 (qsadd1 |i|)))
       ((qsgreaterp |i| n) nil)
-   (seq
-    (exit
-     (progn
-      (setq vec=20
-        (unwind-protect (cdr (|readHiFi| |i|)) (|disableHist|)))
-      (do ((tmp3 vec (cdr tmp3)) (p1 nil))
-          ((or (atom tmp3) (progn (setq p1 (car tmp3)) nil)) nil)
-       (seq
-        (exit
-         (progn
-          (setq x (car p1))
-          (do ((tmp4 (cdr p1) (cdr tmp4)) (p2 nil))
-              ((or (atom tmp4) (progn (setq p2 (car tmp4)) nil)) nil)
-           (seq
-            (exit
-             (setq |$InteractiveFrame|=20
-              (|putHist| x (car p2) (CDR p2) |$InteractiveFrame|)
-    ))))))))))))
+    (setq vec=20
+      (unwind-protect (cdr (|readHiFi| |i|)) (|disableHist|)))
+    (do ((tmp3 vec (cdr tmp3)) (p1 nil))
+        ((or (atom tmp3) (progn (setq p1 (car tmp3)) nil)) nil)
+     (setq x (car p1))
+     (do ((tmp4 (cdr p1) (cdr tmp4)) (p2 nil))
+         ((or (atom tmp4) (progn (setq p2 (car tmp4)) nil)) nil)
+      (setq |$InteractiveFrame|=20
+         (|putHist| x (car p2) (CDR p2) |$InteractiveFrame|)))))
   (setq val
    (and=20
     (setq p (assq '% vec))
@@ -4780,12 +4515,12 @@ Also used in the output routines.
  (setq |$seen| (make-hashtable 'eq))
  (cond=20
   ((null |$HiFiAccess|)=20
-    (|sayKeyedMsg| 'S2IH0016 nil)) ; the history file is not on
+    (|sayKeyedMsg| 's2ih0016 nil)) ; the history file is not on
   ((and (null |$useInternalHistoryTable|)=20
         (null (make-input-filename (|histFileName|))))
-    (|sayKeyedMsg| 'S2IH0022 nil)) ; no history saved yet
+    (|sayKeyedMsg| 's2ih0022 nil)) ; no history saved yet
   ((null fn)=20
-    (|throwKeyedMsg| 'S2IH0037 nil)) ; need to specify a history filenam=
e
+    (|throwKeyedMsg| 's2ih0037 nil)) ; need to specify a history filenam=
e
   (t=20
     (setq savefile (|makeHistFileName| fn))
     (setq inputfile (|histInputFileName| fn))
@@ -4809,10 +4544,10 @@ Also used in the output routines.
                nil)
         (setq val (spadrwrite0 (|object2Identifier| n) rec saveStr))
         (when (eq val '|writifyFailed|)
-         (|sayKeyedMsg| 'S2IH0035 ; can't save the value of step
-          (cons n (cons inputfile nil)))))
+         (|sayKeyedMsg| 's2ih0035 ; can't save the value of step
+          (list n inputfile))))
       (rshut saveStr))
-    (|sayKeyedMsg| 'S2IH0018 ; saved history file is
+    (|sayKeyedMsg| 's2ih0018 ; saved history file is
       (cons (|namestring| savefile) nil))
     nil))))
=20
@@ -4832,10 +4567,10 @@ Also used in the output routines.
           t)
          (identp fnq))
      (setq fnq fnq))
-   (t (|throwKeyedMsg| 'S2IH0023 (cons fnq nil)))) ; invalid filename
+   (t (|throwKeyedMsg| 's2ih0023 (cons fnq nil)))) ; invalid filename
  (setq restfile (|makeHistFileName| fnq))
  (if (null (make-input-filename restfile))
-  (|sayKeyedMsg| 'S2IH0024  ; file does not exist
+  (|sayKeyedMsg| 's2ih0024  ; file does not exist
        (cons (|namestring| restfile) nil))
   (progn=20
     (setq |$options| nil)
@@ -4898,93 +4633,67 @@ Also used in the output routines.
 \defun{showInput}{showInput}
 <<defun showInput>>=3D
 (defun |showInput| (mini maxi)
- (prog (vec l)
-  (return
-   (seq
-    (do ((|ind| mini (+ |ind| 1)))
-        ((> |ind| maxi) nil)
-     (seq
-      (exit
-       (progn
-        (setq vec (unwind-protect (|readHiFi| |ind|) (|disableHist|)))
-        (cond
-         ((> 10 |ind|) (tab 2))
-         ((> 100 |ind|) (tab 1))
-         (t nil))
-        (setq l (car vec))
-        (cond
-          ((stringp l)
-            (|sayMSG|=20
-             (cons=20
-              "   ["
-              (cons |ind|=20
-               (cons "] "
-                (cons (car vec) nil))))))
-          (t
-            (|sayMSG|
-             (cons "   ["
-              (cons |ind|
-               (cons "] " nil))))
-           (do ((tmp0 l (cdr tmp0)) (|ln| nil))
-               ((or (atom tmp0) (progn (setq |ln| (car tmp0)) nil)) nil)
-            (seq
-             (exit
-              (|sayMSG|
-               (cons "      " (cons |ln| nil))))))))))))))))=20
+ (let (vec l)
+  (do ((|ind| mini (+ |ind| 1)))
+      ((> |ind| maxi) nil)
+    (setq vec (unwind-protect (|readHiFi| |ind|) (|disableHist|)))
+    (cond
+     ((> 10 |ind|) (tab 2))
+     ((> 100 |ind|) (tab 1))
+     (t nil))
+    (setq l (car vec))
+    (if (stringp l)
+      (|sayMSG| (list "   [" |ind| "] " (car vec)))
+      (progn
+       (|sayMSG| (list "   [" |ind| "] "))
+       (do ((tmp0 l (cdr tmp0)) (|ln| nil))
+           ((or (atom tmp0) (progn (setq |ln| (car tmp0)) nil)) nil)
+         (|sayMSG| (list "      " |ln|))))))))
=20
 @
 \defun{showInOut}{showInOut}
 <<defun showInOut>>=3D
 (defun |showInOut| (mini maxi)
- (prog (vec Alist triple)
-  (return
-   (seq
-    (do ((ind mini (+ ind 1)))
-        ((> ind maxi) nil)
-     (seq
-      (exit
-       (progn
-        (setq vec (unwind-protect (|readHiFi| ind) (|disableHist|)))
-        (|sayMSG| (cons (car vec) nil))
-        (cond
-         ((setq Alist (assq '% (cdr vec)))
-          (progn
-           (setq triple (cdr (assq '|value| (cdr Alist))))
-           (setq |$IOindex| ind)
-           (|spadPrint|=20
-             (|objValUnwrap| triple) (|objMode| triple)))))))))))))=20
+ (let (vec Alist triple)
+  (do ((ind mini (+ ind 1)))
+      ((> ind maxi) nil)
+   (setq vec (unwind-protect (|readHiFi| ind) (|disableHist|)))
+   (|sayMSG| (cons (car vec) nil))
+   (cond
+    ((setq Alist (assq '% (cdr vec)))
+      (setq triple (cdr (assq '|value| (cdr Alist))))
+      (setq |$IOindex| ind)
+      (|spadPrint| (|objValUnwrap| triple) (|objMode| triple)))))))
=20
 @
 \defun{fetchOutput}{fetchOutput}
 <<defun fetchOutput>>=3D
 (defun |fetchOutput| (n)
- (prog (vec Alist val)
-  (return
-   (cond
-    ((and (boot-equal n (spaddifference 1))
-          (setq val (|getI| '% '|value|)))
-       val)
-    (|$HiFiAccess|
-     (setq n
-      (cond
-       ((minusp n) (plus |$IOindex| n))
-       (t n)))
+ (let (vec Alist val)
+  (cond
+   ((and (boot-equal n (spaddifference 1)) (setq val (|getI| '% '|value|=
)))
+     val)
+   (|$HiFiAccess|
+    (setq n
      (cond
-      ((>=3D n |$IOindex|)=20
-        (|throwKeyedMsg| 'S2IH0001 (cons n nil))) ; no step n yet
-      ((> 1 n)
-        (|throwKeyedMsg| 'S2IH0002 (cons n nil))) ; only nonzero steps
-      (t
-        (setq vec (unwind-protect (|readHiFi| n) (|disableHist|)))
-        (cond
-         ((setq Alist (assq '% (cdr vec)))
-           (cond
-             ((setq val (cdr (assq '|value| (cdr Alist))))
-               val)
-             (t
-               (|throwKeyedMsg| 'S2IH0003 (cons n nil))))) ; no step val=
ue
-         (t (|throwKeyedMsg| 'S2IH0003 (cons n nil))))))) ; no step valu=
e
-    (t (|throwKeyedMsg| 'S2IH0004 nil)))))) ; history not on
+      ((minusp n) (plus |$IOindex| n))
+      (t n)))
+    (cond
+     ((>=3D n |$IOindex|)=20
+       (|throwKeyedMsg| 'S2IH0001 (cons n nil))) ; no step n yet
+     ((> 1 n)
+       (|throwKeyedMsg| 's2ih0002 (cons n nil))) ; only nonzero steps
+     (t
+       (setq vec (unwind-protect (|readHiFi| n) (|disableHist|)))
+       (cond
+        ((setq Alist (assq '% (cdr vec)))
+          (cond
+            ((setq val (cdr (assq '|value| (cdr Alist))))
+              val)
+            (t
+              (|throwKeyedMsg| 's2ih0003 (cons n nil))))) ; no step valu=
e
+        (t (|throwKeyedMsg| 's2ih0003 (cons n nil))))))) ; no step value
+   (t (|throwKeyedMsg| 's2ih0004 nil))))) ; history not on
=20
 @
 \defun{readHiFi}{Read the history file using index n}
@@ -5046,29 +4755,24 @@ Also used in the output routines.
 \defun{writeHistModesAndValues}{writeHistModesAndValues}
 <<defun writeHistModesAndValues>>=3D
 (defun |writeHistModesAndValues| ()
- (prog (a x)
-  (return
-   (seq
-    (progn
-     (do ((tmp0 (caar |$InteractiveFrame|) (cdr tmp0)) (tmp1 nil))
-         ((or (atom tmp0)=20
-              (progn
-                (setq tmp1 (car tmp0))
-                nil)
-              (progn
-                (progn
-                  (setq a (car tmp1))
-                  tmp1)
-              nil))
-          nil)
-      (seq
-       (exit
-        (cond
-         ((setq x (|get| a '|value| |$InteractiveFrame|))
-           (|putHist| a '|value| x |$InteractiveFrame|))
-         ((setq x (|get| a '|mode| |$InteractiveFrame|))
-           (|putHist| a '|mode| x |$InteractiveFrame|))))))
-     nil)))))=20
+ (let (a x)
+ (declare (special |$InteractiveFrame|))
+  (do ((tmp0 (caar |$InteractiveFrame|) (cdr tmp0)) (tmp1 nil))
+      ((or (atom tmp0)=20
+           (progn
+             (setq tmp1 (car tmp0))
+             nil)
+           (progn
+             (progn
+               (setq a (car tmp1))
+               tmp1)
+           nil))
+       nil)
+     (cond
+      ((setq x (|get| a '|value| |$InteractiveFrame|))
+        (|putHist| a '|value| x |$InteractiveFrame|))
+      ((setq x (|get| a '|mode| |$InteractiveFrame|))
+        (|putHist| a '|mode| x |$InteractiveFrame|))))))
=20
 @
 \section{Lisplib output transformations}
@@ -5079,26 +4783,23 @@ These functions transform an object to a writable=
 form and back.
 \defun{SPADRWRITE0}{SPADRWRITE0}
 <<defun SPADRWRITE0>>=3D
 (defun spadrwrite0 (vec item stream)
- (prog (val)
-  (return
-   (progn
-    (setq val (|safeWritify| item))
-    (cond
-     ((eq val '|writifyFailed|) val)
-     (t (|rwrite| vec val stream) item))))))=20
+ (let (val)
+  (setq val (|safeWritify| item))
+  (if (eq val '|writifyFailed|)
+    val
+    (progn
+     (|rwrite| vec val stream)
+     item))))
=20
 @
 \defun{SPADRWRITE}{SPADRWRITE}
 <<defun SPADRWRITE>>=3D
 (defun spadrwrite (vec item stream)
- (prog (val)
-  (return
-   (progn
-    (setq val (spadrwrite0 vec item stream))
-    (cond
-     ((eq val '|writifyFailed|)
-        (|throwKeyedMsg| 'S2IH0036 nil)) ; cannot save value to file
-     (t item))))))
+ (let (val)
+  (setq val (spadrwrite0 vec item stream))
+  (if (eq val '|writifyFailed|)
+   (|throwKeyedMsg| 's2ih0036 nil) ; cannot save value to file
+   item)))
=20
 @
 \defun{SPADRREAD}{SPADRREAD}
@@ -5119,16 +4820,16 @@ These functions transform an object to a writable=
 form and back.
=20
 @
 \defun{writifyComplain}{writifyComplain}
-Create a full isomorphic object which can be saved in a lisplib.
-Note that {\tt dewritify(writify(x))}  preserves UEQUALity of hashtables.
-HASHTABLEs go both ways.
-READTABLEs cannot presently be transformed back.
+Create a full isomorphic object which can be saved in a lisplib.  Note
+that {\tt dewritify(writify(x))} preserves UEQUALity of hashtables.
+HASHTABLEs go both ways.  READTABLEs cannot presently be transformed
+back.
 <<defun writifyComplain>>=3D
 (defun |writifyComplain| (s)
  (declare (special |$writifyComplained|))
  (unless |$writifyComplained|
   (setq |$writifyComplained| t)
-  (|sayKeyedMsg| 'S2IH0027 (cons s nil)))) ; cannot save value
+  (|sayKeyedMsg| 's2ih0027 (list s)))) ; cannot save value
=20
 @
 \defun{safeWritify}{safeWritify}
@@ -5137,7 +4838,7 @@ READTABLEs cannot presently be transformed back.
  (catch '|writifyTag| (|writify| ob)))=20
=20
 @
-\defun{writify}{writify}
+\defun{writify,writifyInner}{writify,writifyInner}
 <<defun writify,writifyInner>>=3D
 (defun |writify,writifyInner| (ob)
  (prog (e name tmp1 tmp2 tmp3 x qcar qcdr d n keys nob)
@@ -5271,18 +4972,17 @@ READTABLEs cannot presently be transformed back.
     (exit ob)))))=20
=20
 @
+\defun{writify}{writify}
 <<defun writify>>=3D
 (defun |writify| (ob)
- (prog (|$seen| |$writifyComplained|)
-  (declare (special |$seen| |$writifyComplained|))
-   (return
-    (cond
-     ((null (|ScanOrPairVec| (|function| |unwritable?|) ob))
-       ob)
-     (t
-      (setq |$seen| (make-hashtable 'eq))
-      (setq |$writifyComplained| nil)
-      (|writify,writifyInner| ob))))))=20
+ (let (|$seen| |$writifyComplained|)
+ (declare (special |$seen| |$writifyComplained|))
+  (if (null (|ScanOrPairVec| (|function| |unwritable?|) ob))
+    ob
+    (progn
+     (setq |$seen| (make-hashtable 'eq))
+     (setq |$writifyComplained| nil)
+     (|writify,writifyInner| ob)))))
=20
 @
 \defun{spadClosure?}{spadClosure?}
@@ -5290,13 +4990,13 @@ READTABLEs cannot presently be transformed back.
 (defun |spadClosure?| (ob)
  (let (fun name vec)
   (setq fun (qcar ob))
-  (cond=20
-   ((null (setq name (bpiname fun))) nil)
-   (t
+  (if (null (setq name (bpiname fun)))
+   nil
+   (progn
      (setq vec (qcdr ob))
-     (cond
-      ((null (vecp vec)) nil)
-      (t name))))))
+     (if (null (vecp vec))=20
+      nil
+      name)))))
=20
 @
 \defun{dewritify,is?}{dewritify,is?}
@@ -5441,15 +5141,13 @@ READTABLEs cannot presently be transformed back.
 \defun{dewritify}{dewritify}
 <<defun dewritify>>=3D
 (defun |dewritify| (ob)
- (prog (|$seen|)
-  (declare (special |$seen|))
-   (return
-    (cond=20
-     ((null (|ScanOrPairVec| (|function| |dewritify,is?|) ob))
-       ob)
-     (t
-       (setq |$seen| (make-hashtable 'EQ))
-       (|dewritify,dewritifyInner| ob))))))=20
+ (let (|$seen|)
+ (declare (special |$seen|))
+   (if (null (|ScanOrPairVec| (|function| |dewritify,is?|) ob))
+    ob
+    (progn
+      (setq |$seen| (make-hashtable 'eq))
+      (|dewritify,dewritifyInner| ob)))))
=20
 @
=20
@@ -5476,18 +5174,18 @@ READTABLEs cannot presently be transformed back.
 <<defun ScanOrPairVec>>=3D
 (defun |ScanOrPairVec| (f ob)
  (let (|$seen|)=20
-  (declare (special |$seen|))=20
-   (setq |$seen| (make-hashtable 'eq))
-   (catch '|ScanOrPairVecAnswer| (|ScanOrPairVec,ScanOrInner| f ob))))
+ (declare (special |$seen|))=20
+  (setq |$seen| (make-hashtable 'eq))
+  (catch '|ScanOrPairVecAnswer| (|ScanOrPairVec,ScanOrInner| f ob))))
=20
 @
 \defun{gensymInt}{gensymInt}
 <<defun gensymInt>>=3D
 (defun |gensymInt| (g)=20
  (let (p n)
-  (cond=20
-   ((null (gensymp g)) (|error| "Need a GENSYM"))
-   (t
+  (if (null (gensymp g))=20
+   (|error| "Need a GENSYM")
+   (progn
      (setq p (pname g))
      (setq n 0)
      (do ((tmp0 (spaddifference (|#| p) 1)) (|i| 2 (qsadd1 |i|)))
@@ -5507,9 +5205,9 @@ READTABLEs cannot presently be transformed back.
    (if (char=3D c (elt digits |i|))
     (setq n |i|)
     nil))
-  (cond
-   ((minusp n) (|error| "Character is not a digit"))
-   (t n))))
+  (if (minusp n)=20
+   (|error| "Character is not a digit")
+   n)))
=20
 @
 \defun{histFileErase}{histFileErase}
@@ -5778,6 +5476,12 @@ command may be used to  drop out  of Axiom  into C=
ommon Lisp.
=20
 \section{Variables Used}
 \section{Functions}
+
+This command is in the list of \verb|$noParseCommands|
+\ref{noParseCommands} which means that its arguments are passed
+verbatim. This will eventually result in a call to the function
+\verb|handleNoParseCommands| \ref{handleNoParseCommands}
+
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{load}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@@ -5887,6 +5591,11 @@ will be displayed and, indeed, Axiom would still b=
e running.
=20
 @
=20
+This command is in the list of \verb|$noParseCommands|
+\ref{noParseCommands} which means that its arguments are passed
+verbatim. This will eventually result in a call to the function
+\verb|handleNoParseCommands| \ref{handleNoParseCommands}
+
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{quit}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@@ -5957,7 +5666,6 @@ executed when you press, say, a function key.
    (tersyscommand))
    (|leaveScratchpad|)))
=20
-
 @
=20
 \defun{leaveScratchpad}{leaveScratchpad}
@@ -5966,6 +5674,11 @@ executed when you press, say, a function key.
=20
 @
=20
+This command is in the list of \verb|$noParseCommands|
+\ref{noParseCommands} which means that its arguments are passed
+verbatim. This will eventually result in a call to the function
+\verb|handleNoParseCommands| \ref{handleNoParseCommands}
+
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{read}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@@ -6207,6 +5920,7 @@ explanations see the list structure section \ref{Th=
eliststructure}.
 <<defun displaySetOptionInformation>>=3D
 (defun |displaySetOptionInformation| (arg setdata)
  (let (current)
+ (declare (special $linelength))
   (cond
    ((eq (fourth setdata) 'tree)
     (|displaySetVariableSettings| (sixth setdata) (first setdata)))
@@ -6226,8 +5940,8 @@ explanations see the list structure section \ref{Th=
eliststructure}.
       (|sayMessage|=20
         `(" The" ,@(|bright| arg) "option"=20
           " may be followed by an integer in the range"=20
-          ,@(|bright| (ELT (sixth setdata) 0)) "to"=20
-          |%l| ,@(|bright| (ELT (sixth setdata) 1)) "inclusive."=20
+          ,@(|bright| (elt (sixth setdata) 0)) "to"=20
+          |%l| ,@(|bright| (elt (sixth setdata) 1)) "inclusive."=20
           " The current setting is" ,@(|bright| (|eval| (fifth setdata))=
))))
      (STRING
       (|sayMessage|=20
@@ -6253,6 +5967,7 @@ explanations see the list structure section \ref{Th=
eliststructure}.
 <<defun displaySetVariableSettings>>=3D
 (defun |displaySetVariableSettings| (settree label)
  (let (setoption opt subtree subname)
+ (declare (special $linelength))
   (if (eq label '||)=20
     (setq label ")set")
     (setq label (strconc "  " (|object2String| label) " ")))
@@ -6403,6 +6118,11 @@ These commands are restricted to keep the user fro=
m causing damage.
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{BreakMode}
+<<initvars>>=3D
+(defvar |$BreakMode| '|nobreak| "execute break processing on error")
+
+@
 <<breakmode>>=3D
   (|breakmode|
    "execute break processing on error"
@@ -6601,6 +6321,12 @@ The input-libraries variable is now maintained as =
a list of truenames.
  "-O -Fasy -Fao -Flsp -laxiom -Mno-AXL_W_WillObsolete=20
   -DAxiom -Y $AXIOM/algebra"=20
 \end{verbatim}
+\defdollar{asharpCmdlineFlags}
+<<initvars>>=3D
+(defvar |$asharpCmdlineFlags|=20
+  "-O -Fasy -Fao -Flsp -laxiom -Mno-AXL__W__WillObsolete -DAxiom -Y $AXI=
OM/algebra"
+  "arguments for compiling AXIOM code")
+@
 <<compilerargs>>=3D
       (|args|
        "arguments for compiling AXIOM code"
@@ -7089,11 +6815,11 @@ recurrence   specially compile recurrence relatio=
ns     on
 (defun |sayAllCacheCounts| ()
  (let (x n)
  (declare (special |$cacheCount| |$cacheAlist|))
-   (|sayCacheCount| NIL |$cacheCount|)
+   (|sayCacheCount| nil |$cacheCount|)
    (when |$cacheAlist|
-     (do ((t0 |$cacheAlist| (cdr t0)) (t1 NIL))
+     (do ((t0 |$cacheAlist| (cdr t0)) (t1 nil))
          ((or (atom t0)
-              (progn (setq t1 (car t0)) NIL)
+              (progn (setq t1 (car t0)) nil)
               (progn
                (progn (setq x (car t1)) (setq n (cdr t1)) t1)
                nil))=20
@@ -7145,6 +6871,12 @@ recurrence   specially compile recurrence relation=
s     on
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{compileDontDefineFunctions}
+<<initvars>>=3D
+(defvar |$compileDontDefineFunctions| t
+   "compile, don't just define function bodies")
+
+@
 <<functionscompile>>=3D
      (|compile|
       "compile, don't just define function bodies"
@@ -7169,6 +6901,11 @@ recurrence   specially compile recurrence relation=
s     on
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{compileRecurrence}
+<<initvars>>=3D
+(defvar |$compileRecurrence| t "specially compile recurrence relations")
+
+@
 <<functionsrecurrence>>=3D
      (|recurrence|
       "specially compile recurrence relations"
@@ -7238,6 +6975,11 @@ For more information, issue )help set .
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{fortInts2Floats}
+<<initvars>>=3D
+(defvar |$fortInts2Floats| t "where sensible, coerce integers to reals")
+
+@
 <<fortranints2floats>>=3D
      (|ints2floats|
       "where sensible, coerce integers to reals"
@@ -7257,6 +6999,11 @@ For more information, issue )help set .
  0 to inclusive. The current setting is 6=20
=20
 \end{verbatim}
+\defdollar{fortIndent}
+<<initvars>>=3D
+(defvar |$fortIndent| 6 "the number of characters indented")
+
+@
 <<fortranfortindent>>=3D
      (|fortindent|
       "the number of characters indented"
@@ -7276,6 +7023,11 @@ For more information, issue )help set .
  1 to inclusive. The current setting is 72=20
=20
 \end{verbatim}
+\defdollar{fortLength}
+<<initvars>>=3D
+(defvar |$fortLength| 72 "the number of characters on a line")
+
+@
 <<fortranfortlength>>=3D
      (|fortlength|
       "the number of characters on a line"
@@ -7300,6 +7052,11 @@ For more information, issue )help set .
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{printFortranDecs}
+<<initvars>>=3D
+(defvar |$printFortranDecs| t "print type and dimension lines")
+
+@
 <<fortrantypedecs>>=3D
      (|typedecs|
       "print type and dimension lines"
@@ -7327,6 +7084,11 @@ For more information, issue )help set .
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{defaultFortranType}
+<<initvars>>=3D
+(defvar |$defaultFortranType| 'real "default generic type for FORTRAN ob=
ject")
+
+@
 <<fortrandefaulttype>>=3D
      (|defaulttype|
       "default generic type for FORTRAN object"
@@ -7351,6 +7113,11 @@ For more information, issue )help set .
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{fortranPrecision}
+<<initvars>>=3D
+(defvar |$fortranPrecision| '|double| "precision of generated FORTRAN ob=
jects")
+
+@
 <<fortranprecision>>=3D
       (|precision|
       "precision of generated FORTRAN objects"
@@ -7375,6 +7142,12 @@ For more information, issue )help set .
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{useIntrinsicFunctions}
+<<initvars>>=3D
+(defvar |$useIntrinsicFunctions| nil
+   "whether to use INTRINSIC FORTRAN functions")
+
+@
 <<fortranintrinsic>>=3D
       (|intrinsic|
        "whether to use INTRINSIC FORTRAN functions"
@@ -7394,6 +7167,12 @@ For more information, issue )help set .
  0 to inclusive. The current setting is 1320=20
=20
 \end{verbatim}
+\defdollar{maximumFortranExpressionLength}
+<<initvars>>=3D
+(defvar |$maximumFortranExpressionLength| 1320
+  "character limit for FORTRAN expressions")
+
+@
 <<fortranexplength>>=3D
       (|explength|
        "character limit for FORTRAN expressions"
@@ -7417,6 +7196,11 @@ For more information, issue )help set .
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{fortranSegment}
+<<initvars>>=3D
+(defvar |$fortranSegment| t "split long FORTRAN expressions")
+
+@
 <<fortransegment>>=3D
       (|segment|
        "split long FORTRAN expressions"
@@ -7436,6 +7220,11 @@ For more information, issue )help set .
  0 to 2 inclusive. The current setting is 0=20
=20
 \end{verbatim}
+\defdollar{fortranOptimizationLevel}
+<<initvars>>=3D
+(defvar |$fortranOptimizationLevel| 0 "FORTRAN optimisation level")
+
+@
 <<fortranoptlevel>>=3D
       (|optlevel|
        "FORTRAN optimisation level"
@@ -7455,6 +7244,11 @@ For more information, issue )help set .
  0 to 1 inclusive. The current setting is 1=20
=20
 \end{verbatim}
+\defdollar{fortranArrayStartingIndex}
+<<initvars>>=3D
+(defvar |$fortranArrayStartingIndex| 1 "starting index for FORTRAN array=
s")
+
+@
 <<fortranstartindex>>=3D
       (|startindex|
        "starting index for FORTRAN arrays"
@@ -7504,6 +7298,11 @@ linker       linker arguments (e.g. libraries to s=
earch) -lxlf
=20
  The current setting is /tmp/=20
 \end{verbatim}
+\defdollar{fortranTmpDir}
+<<initvars>>=3D
+(defvar |$fortranTmpDir| "/tmp/" "set location of temporary data files")
+
+@
 <<callingtempfile>>=3D
         (|tempfile|
          "set location of temporary data files"
@@ -7586,6 +7385,11 @@ linker       linker arguments (e.g. libraries to s=
earch) -lxlf
=20
  The current setting is ./=20
 \end{verbatim}
+\defdollar{fortranDirectory}
+<<initvars>>=3D
+(defvar |$fortranDirectory| "./" "set location of generated FORTRAN file=
s")
+
+@
 <<callingdirectory>>=3D
         (|directory|
          "set location of generated FORTRAN files"
@@ -7657,6 +7461,12 @@ linker       linker arguments (e.g. libraries to s=
earch) -lxlf
=20
  The current setting is -lxlf=20
 \end{verbatim}
+\defdollar{fortranLibraries}
+<<initvars>>=3D
+(defvar |$fortranLibraries| "-lxlf"=20
+  "linker arguments (e.g. libraries to search)")
+
+@
 <<callinglinker>>=3D
         (|linker|
          "linker arguments (e.g. libraries to search)"
@@ -7879,6 +7689,11 @@ mathwidth    screen width for history output      =
      120
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{fullScreenSysVars}
+<<initvars>>=3D
+(defvar |$fullScreenSysVars| nil "use full screen for this facility")
+
+@
 <<hyperdocfullscreen>>=3D
      (|fullscreen|
       "use full screen for this facility"
@@ -7898,6 +7713,11 @@ mathwidth    screen width for history output      =
      120
  0 to inclusive. The current setting is 120=20
=20
 \end{verbatim}
+\defdollar{historyDisplayWidth}
+<<initvars>>=3D
+(defvar |$historyDisplayWidth| 120 "screen width for history output")
+
+@
 <<hyperdocmathwidth>>=3D
      (|mathwidth|
       "screen width for history output"
@@ -7941,6 +7761,11 @@ fullscreen   use fullscreen facility, if possible =
      off
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{useFullScreenHelp}
+<<initvars>>=3D
+(defvar |$useFullScreenHelp| nil "use fullscreen facility, if possible")
+
+@
 <<helpfullscreen>>=3D
     (|fullscreen|
      "use fullscreen facility, if possible"
@@ -7965,6 +7790,11 @@ fullscreen   use fullscreen facility, if possible =
      off
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{HiFiAccess}
+<<initvars>>=3D
+(defvar |$HiFiAccess| t "save workspace values in a history file")
+
+@
 <<history>>=3D
   (|history|
    "save workspace values in a history file"
@@ -8051,6 +7881,12 @@ naglink      show NAGLink messages                =
      on
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{printAnyIfTrue}
+<<initvars>>=3D
+(defvar |$printAnyIfTrue| t
+   "print the internal type of objects of domain Any")
+
+@
 <<messagesany>>=3D
      (|any|
       "print the internal type of objects of domain Any"
@@ -8067,6 +7903,11 @@ naglink      show NAGLink messages                =
      on
  Description: print file auto-load messages
=20
 \end{verbatim}
+\defdollar{printLoadMsgs}
+<<initvars>>=3D
+(defvar |$printLoadMsgs| t "print file auto-load messages")
+
+@
 <<messagesautoload>>=3D
      (|autoload|
       "print file auto-load messages"
@@ -8092,6 +7933,11 @@ naglink      show NAGLink messages                =
      on
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{reportBottomUpFlag}
+<<initvars>>=3D
+(defvar |$reportBottomUpFlag| nil "display bottom up modemap selection")
+
+@
 <<messagesbottomup>>=3D
      (|bottomup|
       "display bottom up modemap selection"
@@ -8116,6 +7962,11 @@ naglink      show NAGLink messages                =
      on
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{reportCoerceIfTrue}
+<<initvars>>=3D
+(defvar |$reportCoerceIfTrue| nil "display datatype coercion messages")
+
+@
 <<messagescoercion>>=3D
      (|coercion|
       "display datatype coercion messages"
@@ -8140,6 +7991,11 @@ naglink      show NAGLink messages                =
      on
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{displayDroppedMap}
+<<initvars>>=3D
+(defvar |$displayDroppedMap| nil "display old map defn when replaced")
+
+@
 <<messagesdropmap>>=3D
      (|dropmap|
       "display old map defn when replaced"
@@ -8164,6 +8020,11 @@ naglink      show NAGLink messages                =
      on
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{giveExposureWarning}
+<<initvars>>=3D
+(defvar |$giveExposureWarning| nil "warning for unexposed functions")
+
+@
 <<messagesexpose>>=3D
      (|expose|
       "warning for unexposed functions"
@@ -8188,6 +8049,11 @@ naglink      show NAGLink messages                =
      on
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{printMsgsToFile}
+<<initvars>>=3D
+(defvar |$printMsgsToFile| nil "print msgs also to SPADMSG LISTING")
+
+@
 <<messagesfile>>=3D
      (|file|
       "print msgs also to SPADMSG LISTING"
@@ -8211,6 +8077,11 @@ naglink      show NAGLink messages                =
      on
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{frameMessages}
+<<initvars>>=3D
+(defvar |$frameMessages| nil "display messages about frames")
+
+@
 <<messagesframe>>=3D
      (|frame|
       "display messages about frames"
@@ -8235,6 +8106,11 @@ naglink      show NAGLink messages                =
      on
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{highlightAllowed}
+<<initvars>>=3D
+(defvar |$highlightAllowed| nil "use highlighting in system messages")
+
+@
 <<messageshighlighting>>=3D
      (|highlighting|
       "use highlighting in system messages"
@@ -8259,6 +8135,11 @@ naglink      show NAGLink messages                =
      on
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{reportInstantiations}
+<<initvars>>=3D
+(defvar |$reportInstantiations| nil "present instantiation summary")
+
+@
 <<messagesinstant>>=3D
      (|instant|
       "present instantiation summary"
@@ -8283,6 +8164,11 @@ naglink      show NAGLink messages                =
      on
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{reportEachInstantiation|}
+<<initvars>>=3D
+(defvar |$reportEachInstantiation| nil "present instantiation info")
+
+@
 <<messagesinsteach>>=3D
      (|insteach|
       "present instantiation info"
@@ -8307,6 +8193,11 @@ naglink      show NAGLink messages                =
      on
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{reportInterpOnly}
+<<initvars>>=3D
+(defvar |$reportInterpOnly| t "say when function code is interpreted")
+
+@
 <<messagesinterponly>>=3D
      (|interponly|
       "say when function code is interpreted"
@@ -8331,6 +8222,11 @@ naglink      show NAGLink messages                =
      on
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{nagMessages}
+<<initvars>>=3D
+(defvar |$nagMessages| t "show NAGLink messages")
+
+@
 <<messagesnaglink>>=3D
      (|naglink|
       "show NAGLink messages"
@@ -8355,6 +8251,11 @@ naglink      show NAGLink messages                =
      on
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{displayMsgNumber}
+<<initvars>>=3D
+(defvar |$displayMsgNumber| nil "display message number with message")
+
+@
 <<messagesnumber>>=3D
      (|number|
       "display message number with message"
@@ -8381,6 +8282,11 @@ naglink      show NAGLink messages                =
      on
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{inputPromptType}
+<<initvars>>=3D
+(defvar |$inputPromptType| '|step| "set type of input prompt to display"=
)
+
+@
 <<messagesprompt>>=3D
      (|prompt|
       "set type of input prompt to display"
@@ -8405,6 +8311,13 @@ naglink      show NAGLink messages                =
      on
  The current setting is indicated.
=20
 \end{verbatim}
+
+TPDHERE: This is a duplicate of )set mes bot on because both use the
+\verb|$reportBottomUpFlag| flag
+\label{reportBottomUpFlag}
+\index{\$reportBottomUpFlag}
+\index{defvar!\$reportBottomUpFlag}
+\index{\$reportBottomUpFlag!defvar}
 <<messagesselection>>=3D
      (|selection|
       "display function selection msgs"
@@ -8428,6 +8341,11 @@ naglink      show NAGLink messages                =
      on
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{displaySetValue}
+<<initvars>>=3D
+(defvar |$displaySetValue| nil "show )set setting after assignment")
+
+@
 <<messagesset>>=3D
      (|set|
       "show )set setting after assignment"
@@ -8452,6 +8370,11 @@ naglink      show NAGLink messages                =
      on
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{displayStartMsgs}
+<<initvars>>=3D
+(defvar |$displayStartMsgs| t "display messages on start-up")
+
+@
 <<messagesstartup>>=3D
      (|startup|
       "display messages on start-up"
@@ -8476,6 +8399,12 @@ naglink      show NAGLink messages                =
      on
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{printStatisticsSummaryIfTrue}
+<<initvars>>=3D
+(defvar |$printStatisticsSummaryIfTrue| nil
+     "print statistics after computation")
+
+@
 <<messagessummary>>=3D
      (|summary|
       "print statistics after computation"
@@ -8500,6 +8429,11 @@ naglink      show NAGLink messages                =
      on
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{testingSystem}
+<<initvars>>=3D
+(defvar |$testingSystem| nil "print system testing header")
+
+@
 <<messagestesting>>=3D
      (|testing|
       "print system testing header"
@@ -8524,6 +8458,11 @@ naglink      show NAGLink messages                =
      on
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{printTimeIfTrue}
+<<initvars>>=3D
+(defvar |$printTimeIfTrue| nil "print timings after computation")
+
+@
 <<messagestime>>=3D
      (|time|
       "print timings after computation"
@@ -8547,6 +8486,11 @@ naglink      show NAGLink messages                =
      on
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{printTypeIfTrue}
+<<initvars>>=3D
+(defvar |$printTypeIfTrue| t "print type after computation")
+
+@
 <<messagestype>>=3D
      (|type|
       "print type after computation"
@@ -8570,6 +8514,11 @@ naglink      show NAGLink messages                =
      on
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{printVoidIfTrue}
+<<initvars>>=3D
+(defvar |$printVoidIfTrue| nil "print Void value when it occurs")
+
+@
 <<messagesvoid>>=3D
      (|void|
       "print Void value when it occurs"
@@ -8616,6 +8565,11 @@ double       enforce DOUBLE PRECISION ASPs        =
      on
=20
  The current setting is localhost=20
 \end{verbatim}
+\defdollar{nagHost}
+<<initvars>>=3D
+(defvar |$nagHost| "localhost" "internet address of host for NAGLink")
+
+@
 <<naglinkhost>>=3D
      (|host|
       "internet address of host for NAGLink"
@@ -8672,6 +8626,11 @@ double       enforce DOUBLE PRECISION ASPs        =
      on
=20
  The current setting is 1=20
 \end{verbatim}
+\defdollar{fortPersistence}
+<<initvars>>=3D
+(defvar |$fortPersistence| 1 "number of (fortran) functions to remember"=
)
+
+@
 <<naglinkpersistence>>=3D
      (|persistence|
       "number of (fortran) functions to remember"
@@ -8743,6 +8702,11 @@ double       enforce DOUBLE PRECISION ASPs        =
      on
  The current setting is indicated.
=20
 \end{verbatim}
+TPDHERE: this is the same as )set nag mes on
+\label{nagMessages}
+\index{\$nagMessages}
+\index{defvar!\$nagMessages}
+\index{\$nagMessages!defvar}
 <<naglinkmessages>>=3D
      (|messages|
       "show NAGLink messages"
@@ -8766,6 +8730,11 @@ double       enforce DOUBLE PRECISION ASPs        =
      on
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{nagEnforceDouble}
+<<initvars>>=3D
+(defvar |$nagEnforceDouble| t "enforce DOUBLE PRECISION ASPs")
+
+@
 <<naglinkdouble>>=3D
      (|double|
       "enforce DOUBLE PRECISION ASPs"
@@ -8830,6 +8799,11 @@ is defined within the output structure.
=20
  The current setting is indicated.
 \end{verbatim}
+\defdollar{abbreviateTypes}
+<<initvars>>=3D
+(defvar |$abbreviateTypes| nil "abbreviate type names")
+
+@
 <<outputabbreviate>>=3D
      (|abbreviate|
       "abbreviate type names"
@@ -8871,6 +8845,17 @@ The output is placed in the directory from which y=
ou invoked
 AXIOM or the one you set with the )cd system command.
 The current setting is:  On:CONSOLE=20
 \end{verbatim}
+\defdollar{algebraFormat}
+<<initvars>>=3D
+(defvar |$algebraFormat| t "display output in algebraic form")
+
+@
+\defdollar{algebraOutputFile}
+<<initvars>>=3D
+(defvar |$algebraOutputFile| "CONSOLE"=20
+  "where algebra printing goes (enter {\em console} or a pathname)?")
+
+@
 <<outputalgebra>>=3D
      (|algebra|
       "display output in algebraic form"
@@ -9134,6 +9119,17 @@ The output is placed in the directory from which y=
ou invoked
 AXIOM or the one you set with the )cd system command.
 The current setting is:  Off:CONSOLE=20
 \end{verbatim}
+\defdollar{fortranFormat}
+<<initvars>>=3D
+(defvar |$fortranFormat| nil "create output in FORTRAN format")
+
+@
+\defdollar{HiFiAccess}
+<<initvars>>=3D
+(defvar |$fortranOutputFile| "CONSOLE"=20
+   "where FORTRAN output goes (enter {\em console} or a a pathname)")
+
+@
 <<outputfortran>>=3D
      (|fortran|
       "create output in FORTRAN format"
@@ -9298,6 +9294,11 @@ The current setting is:  Off:CONSOLE
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{HiFiAccess}
+<<initvars>>=3D
+(defvar |$fractionDisplayType| '|vertical| "how fractions are formatted"=
)
+
+@
 <<outputfraction>>=3D
      (|fraction|
       "how fractions are formatted"
@@ -9317,6 +9318,11 @@ The current setting is:  Off:CONSOLE
  10 to 245 inclusive. The current setting is 77=20
=20
 \end{verbatim}
+\defdollar{linelength}
+<<initvars>>=3D
+(defvar $linelength 77 "line length of output displays")
+
+@
 <<outputlength>>=3D
      (|length|
       "line length of output displays"
@@ -9358,6 +9364,17 @@ The output is placed in the directory from which y=
ou invoked
 AXIOM or the one you set with the )cd system command.
 The current setting is:  Off:CONSOLE=20
 \end{verbatim}
+\defdollar{mathmlFormat}
+<<initvars>>=3D
+(defvar |$mathmlFormat| nil "create output in MathML format")
+
+@
+\defdollar{mathmlOutputFile}
+<<initvars>>=3D
+(defvar |$mathmlOutputFile| "CONSOLE"=20
+   "where MathML output goes (enter {\em console} or a pathname)")
+
+@
 <<outputmathml>>=3D
      (|mathml|
       "create output in MathML style"
@@ -9528,6 +9545,17 @@ The output is placed in the directory from which y=
ou invoked
 AXIOM or the one you set with the )cd system command.
 The current setting is:  Off:CONSOLE=20
 \end{verbatim}
+\defdollar{openMathFormat}
+<<initvars>>=3D
+(defvar |$openMathFormat| nil "create output in OpenMath format")
+
+@
+\defdollar{openMathOutputFile}
+<<initvars>>=3D
+(defvar |$openMathOutputFile| "CONSOLE"
+  "where TeX output goes (enter {\em console} or a pathname)")
+
+@
 <<outputopenmath>>=3D
      (|openmath|
       "create output in OpenMath style"
@@ -9699,6 +9727,17 @@ The output is placed in the directory from which y=
ou
 invoked AXIOM or the one you set with the )cd system command.
 The current setting is:  Off:CONSOLE=20
 \end{verbatim}
+\defdollar{formulaFormat}
+<<initvars>>=3D
+(defvar |$formulaFormat| nil "display output in SCRIPT format")
+
+@
+\defdollar{formulaOutputFile}
+<<initvars>>=3D
+(defvar |$formulaOutputFile| "CONSOLE"
+    "where script output goes (enter {\em console} or a a pathname)")
+
+@
 <<outputscript>>=3D
      (|script|
       "display output in SCRIPT formula format"
@@ -9851,6 +9890,11 @@ The current setting is:  Off:CONSOLE
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{linearFormatScripts}
+<<initvars>>=3D
+(defvar |$linearFormatScripts| nil "show subscripts,... linearly")
+
+@
 <<outputscripts>>=3D
      (|scripts|
       "show subscripts,... linearly"
@@ -9875,6 +9919,11 @@ The current setting is:  Off:CONSOLE
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{useEditorForShowOutput}
+<<initvars>>=3D
+(defvar |$useEditorForShowOutput| nil "view output of )show in editor")
+
+@
 <<outputshoweditor>>=3D
      (|showeditor|
       "view output of )show in editor"
@@ -9916,6 +9965,17 @@ The output is placed in the directory from which y=
ou invoked
 AXIOM or the one you set with the )cd system command.
 The current setting is:  Off:CONSOLE=20
 \end{verbatim}
+\defdollar{texFormat}
+<<initvars>>=3D
+(defvar |$texFormat| nil "create output in TeX format")
+
+@
+\defdollar{texOutputFile}
+<<initvars>>=3D
+(defvar |$texOutputFile| "CONSOLE"=20
+    "where TeX output goes (enter {\em console} or a pathname)")
+
+@
 <<outputtex>>=3D
      (|tex|
       "create output in TeX style"
@@ -10061,6 +10121,11 @@ The current setting is:  Off:CONSOLE
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{quitCommandType}
+<<initvars>>=3D
+(defvar |$quitCommandType| '|protected| "protected or unprotected quit")
+
+@
 <<quit>>=3D
   (|quit|
    "protected or unprotected quit"
@@ -10104,6 +10169,12 @@ showall      display all stream elements compute=
d       off
=20
       The current setting is 10 .
 \end{verbatim}
+\defdollar{streamCount}
+<<initvars>>=3D
+(defvar |$streamCount| 10=20
+    "number of initial stream elements you want calculated")
+
+@
 <<streamscalculate>>=3D
      (|calculate|
       "specify number of elements to calculate"
@@ -10162,6 +10233,11 @@ showall      display all stream elements compute=
d       off
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{streamsShowAll}
+<<initvars>>=3D
+(defvar |$streamsShowAll| nil "display all stream elements computed")
+
+@
 <<streamsshowall>>=3D
     (|showall|
      "display all stream elements computed"
@@ -10209,6 +10285,11 @@ prettyprint  prettyprint BOOT func's as they com=
pile    off
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{reportCompilation}
+<<initvars>>=3D
+(defvar |$reportCompilation| nil "show gen. LISP for functions when comp=
iled")
+
+@
 <<systemfunctioncode>>=3D
      (|functioncode|
       "show gen. LISP for functions when compiled"
@@ -10233,6 +10314,11 @@ prettyprint  prettyprint BOOT func's as they com=
pile    off
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{reportOptimization}
+<<initvars>>=3D
+(defvar |$reportOptimization| nil "show optimized LISP code")
+
+@
 <<systemoptimization>>=3D
      (|optimization|
       "show optimized LISP code"
@@ -10257,12 +10343,17 @@ prettyprint  prettyprint BOOT func's as they co=
mpile    off
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{prettyprint}
+<<initvars>>=3D
+(defvar $prettyprint t "prettyprint BOOT func's as they compile")
+
+@
 <<systemprettyprint>>=3D
      (|prettyprint|
       "prettyprint BOOT func's as they compile"
       |development|
       LITERALS
-      $PRETTYPRINT
+      $prettyprint
       (|on| |off|)
       |on|)
 @
@@ -10282,6 +10373,11 @@ prettyprint  prettyprint BOOT func's as they com=
pile    off
  The current setting is indicated.
=20
 \end{verbatim}
+\defdollar{UserLevel}
+<<initvars>>=3D
+(defvar |$UserLevel| '|development| "operation access level of system us=
er")
+
+@
 <<userlevel>>=3D
   (|userlevel|
    "operation access level of system user"
@@ -10563,7 +10659,7 @@ Axiom or is the directory you specified using the
 <<defun summary>>=3D
 (defun |summary| (l)
  (declare (ignore l))
- (obey (strconc "cat " (|getEnv| "AXIOM") "/lib/summary")))
+ (obey (strconc "cat " (getenviron "AXIOM") "/lib/summary")))
=20
 @
=20
@@ -10617,6 +10713,11 @@ To list, say, all synonyms that contain the subs=
tring
 \fnref{set} and
 \fnref{what}
=20
+This command is in the list of \verb|$noParseCommands|
+\ref{noParseCommands} which means that its arguments are passed
+verbatim. This will eventually result in a call to the function
+\verb|handleNoParseCommands| \ref{handleNoParseCommands}
+
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{system}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@@ -10660,6 +10761,11 @@ possible.
 \fnref{pquit}, and
 \fnref{quit}
=20
+This command is in the list of \verb|$noParseCommands|
+\ref{noParseCommands} which means that its arguments are passed
+verbatim. This will eventually result in a call to the function
+\verb|handleNoParseCommands| \ref{handleNoParseCommands}
+
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \cmdhead{trace}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@@ -11194,49 +11300,33 @@ This reports the traced functions
=20
 \defun{saveMapSig}{saveMapSig}
 <<defun saveMapSig>>=3D
-(defun |saveMapSig| (|funNames|)
- (prog (|map|)
-  (return
-   (seq
-    (do ((t0 |funNames| (cdr t0)) (|name| nil))
-        ((or (atom t0) (progn (setq |name| (car t0)) nil)) nil)
-     (seq
-      (exit
-       (cond
-        ((setq |map| (|rassoc| |name| |$mapSubNameAlist|))
-         (exit
-          (setq |$tracedMapSignatures|
-           (addassoc |name| (|getMapSig| |map| |name|)
-                     |$tracedMapSignatures|))))))))))))=20
+(defun |saveMapSig| (funnames)
+ (let (map)
+ (declare (special |$tracedMapSignatures| |$mapSubNameAlist|))
+  (dolist (name funnames)
+   (when (setq map (|rassoc| name |$mapSubNameAlist|))
+     (setq |$tracedMapSignatures|
+       (addassoc name (|getMapSig| map name) |$tracedMapSignatures|)))))=
)
=20
 @
=20
 \defun{getMapSig}{getMapSig}
 <<defun getMapSig>>=3D
-(defun |getMapSig| (|mapName| |subName|)
- (prog (|lmms| |sig|)
-  (return
-   (seq
-    (cond
-     ((setq |lmms| (|get| |mapName| '|localModemap| |$InteractiveFrame|)=
)
-      (exit
-       (seq
-        (do ((t0 |lmms| (cdr t0)) (|mm| nil) (t1 nil |sig|))
-            ((or (atom t0) (progn (setq |mm| (car t0)) nil) t1) nil)
-         (seq
-          (exit
-           (cond=20
-            ((boot-equal (cadr |mm|) |subName|)
-              (exit=20
-               (setq |sig| (cdar |mm|))))))))
-        (exit |sig|)))))))))=20
+(defun |getMapSig| (mapname subname)
+ (let (lmms sig)
+ (declare (special |$InteractiveFrame|))
+  (when (setq lmms (|get| mapname '|localModemap| |$InteractiveFrame|))
+    (do ((t0 lmms (cdr t0)) (|mm| nil) (t1 nil sig))
+        ((or (atom t0) (progn (setq |mm| (car t0)) nil) t1) nil)
+      (when (boot-equal (cadr |mm|) subname) (setq sig (cdar |mm|))))
+    sig)))
=20
 @
=20
 \defun{getTraceOption}{getTraceOption}
 <<defun getTraceOption,hn>>=3D
 (defun |getTraceOption,hn| (x)
- (prog (|g|)
+ (prog (g)
   (return
    (seq
     (if (and (atom x) (null (upper-case-p (elt (stringimage x) 0))))
@@ -11246,7 +11336,7 @@ This reports the traced functions
        (exit=20
         (|stackTraceOptionError|
          (cons 's2it0013 (cons (cons x nil) nil)))))))
-    (if (setq |g| (|domainToGenvar| x)) (exit |g|))
+    (if (setq g (|domainToGenvar| x)) (exit g))
     (exit
      (|stackTraceOptionError| (cons 's2it0013 (cons (cons x nil) nil))))=
))))=20
=20
@@ -11255,6 +11345,7 @@ This reports the traced functions
 <<defun getTraceOption>>=3D
 (defun |getTraceOption| (arg)
  (prog (l |opts| key a |n|)
+ (declare (special |$traceOptionList|))
   (return
    (seq
     (progn
@@ -11395,24 +11486,19 @@ This reports the traced functions
=20
 \defun{traceOptionError}{traceOptionError}
 <<defun traceOptionError>>=3D
-(defun |traceOptionError| (opt |keys|)
- (cond
-  ((null |keys|)
-    (|stackTraceOptionError| (cons 's2it0007 (cons (cons opt nil) nil)))=
)
-  (t
-   (|commandAmbiguityError| '|trace option| opt |keys|))))=20
+(defun |traceOptionError| (opt keys)
+ (if (null keys)
+  (|stackTraceOptionError| (cons 's2it0007 (cons (cons opt nil) nil)))
+  (|commandAmbiguityError| '|trace option| opt keys)))
=20
 @
=20
 \defun{resetTimers}{resetTimers}
 <<defun resetTimers>>=3D
 (defun |resetTimers| ()
- (seq
-  (do ((t0 /timerlist (cdr t0)) (|timer| nil))
-      ((or (atom t0) (progn (setq |timer| (car t0)) nil)) nil)
-   (seq
-    (exit
-     (set (intern (strconc |timer| ",TIMER")) 0))))))=20
+ (declare (special /timerlist))
+ (dolist (timer /timerlist)
+  (set (intern (strconc timer ",TIMER")) 0)))
=20
 @
=20
@@ -11427,12 +11513,9 @@ This reports the traced functions
 \defun{resetCounters}{resetCounters}
 <<defun resetCounters>>=3D
 (defun |resetCounters| ()
- (seq
-  (do ((t0 /countlist (cdr t0)) (|k| nil))
-      ((or (atom t0) (progn (setq |k| (car t0)) nil)) nil)
-    (seq
-     (exit
-      (set (intern (strconc |k| ",COUNT")) 0))))))=20
+ (declare (special /countlist))
+ (dolist (k /countlist)
+  (set (intern (strconc k ",COUNT")) 0)))
=20
 @
=20
@@ -11440,24 +11523,13 @@ This reports the traced functions
 <<defun ptimers>>=3D
 (defun |ptimers| ()
   (declare (special /timerlist |$timerTicksPerSecond|))
-  (cond
-   ((null /timerlist) (|sayBrightly| "   no functions are timed"))
-   (t
-    (do ((t0 /timerlist (cdr t0)) (|timer| nil))
-        ((or (atom t0) (progn (setq |timer| (car t0)) nil)) nil)
-     (seq
-      (exit
-       (|sayBrightly|
-        (cons "  "
-         (append
-          (|bright| |timer|)
-          (cons '|:|
-           (cons " "
-            (cons=20
-             (quotient
-              (eval (intern (strconc |timer| ",TIMER")))
-              (|float| |$timerTicksPerSecond|))
-             (cons " sec." nil)))))))))))))
+  (if (null /timerlist)=20
+   (|sayBrightly| "   no functions are timed")
+   (dolist (timer /timerlist)
+     (|sayBrightly|
+      `("  " ,@(|bright| timer) |:| " "
+         ,(quotient (eval (intern (strconc timer ",TIMER")))
+            (|float| |$timerTicksPerSecond|)) " sec.")))))
=20
 @
=20
@@ -11477,44 +11549,27 @@ This reports the traced functions
 \defun{pcounters}{pcounters}
 <<defun pcounters>>=3D
 (defun |pcounters| ()
- (seq
-  (cond
-   ((null /countlist) (|sayBrightly| "   no functions are being counted"=
))
-   (t
-    (do ((t0 /countlist (cdr t0)) (|k| nil))
-        ((or (atom t0) (progn (setq |k| (car t0)) nil)) nil)
-     (seq
-      (exit
-       (|sayBrightly|
-        (cons "  "
-         (append
-          (|bright| |k|)
-          (cons '|:|
-           (cons " "
-            (cons
-             (eval (intern (strconc |k| ",COUNT")))
-             (cons " times" nil))))))))))))))=20
+ (declare (special /countlist))
+ (if (null /countlist)=20
+   (|sayBrightly| "   no functions are being counted")
+   (dolist (k /countlist)
+     (|sayBrightly|
+      `("  " ,@(|bright| k) |:| " " ,(eval (intern (strconc k ",COUNT"))=
)
+        " times")))))
=20
 @
=20
 \defun{transOnlyOption}{transOnlyOption}
 <<defun transOnlyOption>>=3D
 (defun |transOnlyOption| (arg)
- (prog (y |n|)
-  (return
-   (cond
-    ((and (pairp arg)=20
-          (progn (setq |n| (qcar arg)) (setq y (qcdr arg)) t))
-      (cond
-       ((fixp |n|)
-         (cons |n| (|transOnlyOption| y)))
-       ((memq (setq |n| (upcase |n|)) '(V A C))
-         (cons |n| (|transOnlyOption| y)))
-       (t=20
-         (|stackTraceOptionError|
-           (cons 's2it0006 (cons (cons |n| nil) nil)))
-         (|transOnlyOption| y))))
-    (t nil)))))=20
+ (let (y n)
+  (when (and (pairp arg) (progn (setq n (qcar arg)) (setq y (qcdr arg)) =
t))
+    (cond
+     ((fixp n) (cons n (|transOnlyOption| y)))
+     ((memq (setq n (upcase n)) '(v a c)) (cons n (|transOnlyOption| y))=
)
+     (t=20
+        (|stackTraceOptionError| (cons 's2it0006 (list (list n))))
+        (|transOnlyOption| y))))))
=20
 @
=20
@@ -11529,39 +11584,29 @@ This reports the traced functions
=20
 \defun{removeOption}{removeOption}
 <<defun removeOption>>=3D
-(defun |removeOption| (|op| |options|)
- (prog (opt)
-  (return
-   (seq
-    (prog (t0)
-     (setq t0 nil)
-     (return
-      (do ((t1 |options| (cdr t1)) (|optEntry| nil))
-          ((or (atom t1)
-               (progn (setq |optEntry| (car t1)) nil)
-               (progn (progn (setq opt (CAR |optEntry|)) |optEntry|) nil=
))
-        (nreverse0 t0))
-       (seq
-        (exit
-         (cond
-          ((nequal opt |op|) (setq t0 (cons |optEntry| t0)))))))))))))=20
+(defun |removeOption| (op options)
+ (let (opt t0)
+  (do ((t1 options (cdr t1)) (optentry nil))
+      ((or (atom t1)
+           (progn (setq optentry (car t1)) nil)
+           (progn (progn (setq opt (car optentry)) optentry) nil))
+    (nreverse0 t0))
+  (when (nequal opt op) (setq t0 (cons optentry t0))))))
=20
 @
=20
 \defun{domainToGenvar}{domainToGenvar}
 <<defun domainToGenvar>>=3D
 (defun |domainToGenvar| (arg)
- (prog (|$doNotAddEmptyModeIfTrue| y |g|)
-  (declare (special |$doNotAddEmptyModeIfTrue|))
-  (return
-   (progn
-    (setq |$doNotAddEmptyModeIfTrue| t)
-    (cond
-     ((and (setq y (|unabbrevAndLoad| arg))
-           (eq (getdatabase (|opOf| y) 'constructorkind) '|domain|))
-       (progn
-        (setq |g| (|genDomainTraceName| y))
-        (set |g| (|evalDomain| y)) |g|)))))))=20
+ (let (|$doNotAddEmptyModeIfTrue| y g)
+ (declare (special |$doNotAddEmptyModeIfTrue|))
+  (setq |$doNotAddEmptyModeIfTrue| t)
+  (when
+   (and (setq y (|unabbrevAndLoad| arg))
+        (eq (getdatabase (|opOf| y) 'constructorkind) '|domain|))
+     (setq g (|genDomainTraceName| y))
+     (set g (|evalDomain| y))
+     g)))
=20
 @
=20
@@ -11570,9 +11615,9 @@ This reports the traced functions
 (defun |genDomainTraceName| (y)
  (let (u g)
  (declare (special |$domainTraceNameAssoc|))
-   (cond
-    ((setq u (lassoc y |$domainTraceNameAssoc|)) u)
-    (t
+   (if (setq u (lassoc y |$domainTraceNameAssoc|))=20
+    u
+    (progn
      (setq g (genvar))
      (setq |$domainTraceNameAssoc| (cons (cons y g) |$domainTraceNameAss=
oc|))
      g))))
@@ -11635,13 +11680,10 @@ This reports the traced functions
=20
 \defun{removeTracedMapSigs}{removeTracedMapSigs}
 <<defun removeTracedMapSigs>>=3D
-(defun |removeTracedMapSigs| (|untraceList|)
- (seq
-  (do ((t0 |untraceList| (cdr t0)) (|name| nil))
-      ((or (atom t0) (progn (setq |name| (car t0)) nil)) nil)
-   (seq
-    (exit
-     (remprop |name| |$tracedMapSignatures|))))))=20
+(defun |removeTracedMapSigs| (untraceList)
+ (declare (special |$tracedMapSignatures|))
+ (dolist (name untraceList)
+   (remprop name |$tracedMapSignatures|)))
=20
 @
=20
@@ -11686,7 +11728,7 @@ This reports the traced functions
 <<defun coerceSpadArgs2E>>=3D
 (defun |coerceSpadArgs2E| (args)
  (let ((|$streamCount| 0))
-  (declare (special |$streamCount| |$OutputForm|))
+  (declare (special |$streamCount| |$OutputForm| |$tracedSpadModemap|))
   (do ((t1 '(|arg1| |arg2| |arg3| |arg4| |arg5| |arg6| |arg7| |arg8|=20
              |arg9| |arg10| |arg11| |arg12| |arg13| |arg14| |arg15|=20
              |arg16| |arg17| |arg18| |arg19|) (cdr t1))
@@ -11742,7 +11784,7 @@ This reports the traced functions
 <<defun coerceTraceFunValue2E>>=3D
 (defun |coerceTraceFunValue2E| (tracename subname |value|)
  (let (name u)
- (declare (special |$tracedMapSignatures| |$OutputForm|))
+ (declare (special |$tracedMapSignatures| |$OutputForm| |$mathTraceList|=
))
    (if (memq (setq name subname) |$mathTraceList|)
     (cond
      ((spadsysnamep (pname tracename)) (|coerceSpadFunValue2E| |value|))
@@ -11804,115 +11846,93 @@ This reports the traced functions
 \defun{getMapSubNames}{getMapSubNames}
 <<defun getMapSubNames>>=3D
 (defun |getMapSubNames| (arg)
- (prog (|lmm| |subs|)
-  (return
-   (seq
-    (progn
-     (setq |subs| nil)
-     (seq
-      (do ((t0 arg (cdr t0)) (|mapName| nil))
-          ((or (atom t0) (progn (setq |mapName| (CAR t0)) nil)) nil)
-       (seq
-        (exit
-         (cond
-          ((setq |lmm|
-            (|get| |mapName| '|localModemap| |$InteractiveFrame|))
-           (exit
-            (setq |subs|
-             (append
-              (prog (t1)
-               (setq t1 nil)
-               (return
-                (do ((t2 |lmm| (cdr t2)) (|mm| nil))
-                    ((or (atom t2)
-                         (progn (setq |mm| (CAR t2)) nil)) (nreverse0 t1=
))
-                 (seq
-                  (exit
-                   (setq t1 (cons (cons |mapName| (cadr |mm|)) t1)))))))
-              |subs|))))))))
-      (|union| |subs|
-        (|getPreviousMapSubNames| (unionq /tracenames |$lastUntraced|)))=
))))))=20
+ (let (lmm subs)
+ (declare (special /tracenames |$lastUntraced| |$InteractiveFrame|))
+  (setq subs nil)
+  (dolist (mapname arg)
+   (when (setq lmm (|get| mapname '|localModemap| |$InteractiveFrame|))
+     (setq subs
+      (append
+        (do ((t2 lmm (cdr t2)) (t1 nil) (|mm| nil))
+            ((or (atom t2)
+                 (progn (setq |mm| (CAR t2)) nil)) (nreverse0 t1))
+           (setq t1 (cons (cons mapname (cadr |mm|)) t1)))
+       subs))))
+  (|union| subs
+    (|getPreviousMapSubNames| (unionq /tracenames |$lastUntraced|)))))
=20
 @
=20
 \defun{getPreviousMapSubNames}{getPreviousMapSubNames}
 <<defun getPreviousMapSubNames>>=3D
 (defun |getPreviousMapSubNames| (|traceNames|)
- (prog (|lmm| |subs|)
+ (prog (lmm subs)
   (return
    (seq
     (progn
-     (setq |subs| nil)
+     (setq subs nil)
      (seq
       (do ((t0 (assocleft (caar |$InteractiveFrame|)) (cdr t0))
-           (|mapName| nil))
-          ((or (atom t0) (progn (setq |mapName| (car t0)) nil)) nil)
+           (mapname nil))
+          ((or (atom t0) (progn (setq mapname (car t0)) nil)) nil)
        (seq
         (exit
          (cond
-          ((setq |lmm|
-             (|get| |mapName| '|localModemap| |$InteractiveFrame|))
+          ((setq lmm
+             (|get| mapname '|localModemap| |$InteractiveFrame|))
             (exit
              (cond
-              ((memq (cadar |lmm|) |traceNames|)
+              ((memq (cadar lmm) |traceNames|)
                (exit
-                (do ((t1 |lmm| (cdr t1)) (|mm| nil))
+                (do ((t1 lmm (cdr t1)) (|mm| nil))
                     ((or (atom t1) (progn (setq |mm| (car t1)) nil)) nil=
)
                  (seq
                   (exit
-                   (setq |subs|
-                    (cons (cons |mapName| (cadr |mm|)) |subs|)))))))))))=
)))
-      (exit |subs|)))))))=20
+                   (setq subs
+                    (cons (cons mapname (cadr |mm|)) subs))))))))))))))
+      (exit subs)))))))=20
=20
 @
=20
 \defun{lassocSub}{lassocSub}
 <<defun lassocSub>>=3D
-(defun |lassocSub| (x |subs|)
- (prog (y)=20
-  (return=20
-   (cond=20
-    ((setq y (lassq x |subs|)) y)
-    (t x)))))=20
+(defun |lassocSub| (x subs)
+ (let (y)=20
+  (if (setq y (lassq x subs))=20
+    y
+    x)))
=20
 @
=20
 \defun{rassocSub}{rassocSub}
 <<defun rassocSub>>=3D
-(defun |rassocSub| (x |subs|)
- (prog (y)
-  (return
-   (cond
-    ((setq y (|rassoc| x |subs|)) y)
-    (t x)))))=20
+(defun |rassocSub| (x subs)
+ (let (y)
+   (if (setq y (|rassoc| x subs))=20
+    y
+    x)))
=20
 @
=20
 \defun{isUncompiledMap}{isUncompiledMap}
 <<defun isUncompiledMap>>=3D
 (defun |isUncompiledMap| (x)
- (prog (y)
-  (return
-   (seq=20
-    (cond
-     ((setq y (|get| x '|value| |$InteractiveFrame|))
-       (exit
-        (and
-         (eq (caar y) 'map)
-         (null (|get| x '|localModemap| |$InteractiveFrame|))))))))))=20
+ (let (y)
+ (declare (special |$InteractiveFrame|))
+  (when (setq y (|get| x '|value| |$InteractiveFrame|))
+    (and
+      (eq (caar y) 'map)
+      (null (|get| x '|localModemap| |$InteractiveFrame|))))))
=20
 @
=20
 \defun{isInterpOnlyMap}{isInterpOnlyMap}
 <<defun isInterpOnlyMap>>=3D
 (defun |isInterpOnlyMap| (map)
- (prog (x)
-  (return
-   (seq
-    (cond
-     ((setq x (|get| map '|localModemap| |$InteractiveFrame|))
-      (exit
-       (eq (caaar x) '|interpOnly|))))))))=20
+ (let (x)
+ (declare (special |$InteractiveFrame|))
+  (when (setq x (|get| map '|localModemap| |$InteractiveFrame|))
+    (eq (caaar x) '|interpOnly|))))
=20
 @
=20
@@ -11942,43 +11962,26 @@ This reports the traced functions
 \defun{isSubForRedundantMapName}{isSubForRedundantMapName}
 <<defun isSubForRedundantMapName>>=3D
 (defun |isSubForRedundantMapName| (subname)
- (prog (|mapName| |tail|)
-  (return
-   (seq
-    (cond
-     ((setq |mapName| (|rassocSub| subname |$mapSubNameAlist|))
-       (exit
-        (cond
-         ((setq |tail|
-            (|member| (cons |mapName| subname) |$mapSubNameAlist|))
-           (exit
-            (memq |mapName| (cdr (assocleft |tail|)))))))))))))=20
+ (let (mapname tail)
+ (declare (special |$mapSubNameAlist|))
+  (when (setq mapname (|rassocSub| subname |$mapSubNameAlist|))
+    (when (setq tail (|member| (cons mapname subname) |$mapSubNameAlist|=
))
+      (memq mapname (cdr (assocleft tail)))))))
=20
 @
=20
 \defun{untraceMapSubNames}{untraceMapSubNames}
 <<defun untraceMapSubNames>>=3D
 (defun |untraceMapSubNames| (|traceNames|)
- (prog (|$mapSubNameAlist| |subs|)
-  (declare (special |$mapSubNameAlist|))
-  (return
-   (seq
-    (cond
-     ((null
-        (setq |$mapSubNameAlist| (|getPreviousMapSubNames| |traceNames|)=
))
-       nil)
-     (t
-      (do ((t0 (setq |subs| (assocright |$mapSubNameAlist|)) (CDR t0))
-           (name nil))
-          ((or (atom t0) (progn (setq name (car t0)) nil)) nil)
-       (seq
-        (exit
-         (cond
-          ((memq name /tracenames)
-           (progn
-            (|/UNTRACE,2| name nil)
-            (setq |$lastUntraced|
-             (setdifference |$lastUntraced| |subs|))))))))))))))=20
+ (let (|$mapSubNameAlist| subs)
+ (declare (special |$mapSubNameAlist| |$lastUntraced|))
+  (if
+   (null (setq |$mapSubNameAlist| (|getPreviousMapSubNames| |traceNames|=
)))
+   nil
+   (dolist (name (setq subs (assocright |$mapSubNameAlist|)))
+     (when (memq name /tracenames)
+       (|/UNTRACE,2| name nil)
+       (setq |$lastUntraced| (setdifference |$lastUntraced| subs)))))))
=20
 @
=20
@@ -12034,24 +12037,22 @@ This reports the traced functions
 \defun{spadTrace,g}{spadTrace,g}
 <<defun spadTrace,g>>=3D
 (defun |spadTrace,g| (x)
- (seq
-  (if (stringp x) (exit (intern x)))
-  (exit x)))=20
+  (if (stringp x) (intern x) x))
=20
 @
=20
 \defun{spadTrace,isTraceable}{spadTrace,isTraceable}
 <<defun spadTrace,isTraceable>>=3D
 (defun |spadTrace,isTraceable| (x |domain|)
- (prog (|n| |functionSlot|)
+ (prog (n |functionSlot|)
   (return
    (seq
     (progn
-     (setq |n| (caddr x))
+     (setq n (caddr x))
      x
      (seq
-      (if (atom (elt |domain| |n|)) (exit nil))
-      (setq |functionSlot| (car (elt |domain| |n|)))
+      (if (atom (elt |domain| n)) (exit nil))
+      (setq |functionSlot| (car (elt |domain| n)))
       (if (gensymp |functionSlot|)=20
        (exit (seq (|reportSpadTrace| '|Already Traced| x) (exit nil))))
       (if (null (bpiname |functionSlot|))
@@ -12065,149 +12066,147 @@ This reports the traced functions
=20
 \defun{spadTrace}{spadTrace}
 <<defun spadTrace>>=3D
-(defun |spadTrace| (|domain| |options|)
- (prog (|$tracedModemap| |listOfOperations| |listOfVariables|=20
-        |listOfBreakVars| |anyifTrue| |domainId| |currentEntry|=20
-        |currentAlist| |opStructureList| |sig| |kind| |triple| fn |op|=20
-        |mm| |n| |alias| tracename |sigSlotNumberAlist|)
- (declare (special |$tracedModemap|))
- (return
-  (seq
-   (progn
-    (setq |$fromSpadTrace| t)
-    (setq |$tracedModemap| nil)
-    (cond
-     ((and (pairp |domain|)
-           (refvecp (car |domain|))
-           (eql (elt (car |domain|) 0) 0))
-       (|aldorTrace| |domain| |options|))
-     ((null (|isDomainOrPackage| |domain|))
-       (|userError| "bad argument to trace"))
-     (t
-      (setq |listOfOperations|
-       (prog (t0)
-        (setq t0 nil)
-        (return
-         (do ((t1 (|getOption| 'ops |options|) (cdr t1)) (x nil))
-             ((or (atom t1) (progn (setq x (car t1)) nil)) (nreverse0 t0=
))
-          (seq
-           (exit
-            (setq t0 (cons (|spadTrace,g| x) t0))))))))
-      (cond
-       ((setq |listOfVariables| (|getOption| 'vars |options|))
-         (setq |options| (|removeOption| 'vars |options|))))
-      (cond
-       ((setq |listOfBreakVars| (|getOption| 'varbreak |options|))
-         (setq |options| (|removeOption| 'varbreak |options|))))
-      (setq |anyifTrue| (null |listOfOperations|))
-      (setq |domainId| (|opOf| (elt |domain| 0)))
-      (setq |currentEntry| (|assoc| |domain| /tracenames))
-      (setq |currentAlist| (kdr |currentEntry|))
-      (setq |opStructureList|=20
-       (|flattenOperationAlist| (|getOperationAlistFromLisplib| |domainI=
d|)))
-      (setq |sigSlotNumberAlist|
-       (prog (t2)
-        (setq t2 nil)
-        (return
-         (do ((t3 |opStructureList| (cdr t3)) (t4 nil))
-             ((or (atom t3)
-                  (progn (setq t4 (CAR t3)) nil)
-                  (progn
-                   (progn
-                    (setq |op| (car t4))
-                    (setq |sig| (cadr t4))
-                    (setq |n| (caddr t4))
-                    (setq |kind| (car (cddddr t4))) t4)
-                   nil))
-                (nreverse0 t2))
-          (seq
-           (exit
-            (cond
-             ((and (eq |kind| 'ELT)
-                   (or |anyifTrue| (memq |op| |listOfOperations|))
-                   (fixp |n|)
-                   (|spadTrace,isTraceable|
-                    (setq |triple|
-                     (cons |op| (cons |sig| (cons |n| nil)))) |domain|))
-                (setq t2 (cons |triple| t2))))))))))
-      (cond=20
-       (|listOfVariables|
-        (do ((t5 |sigSlotNumberAlist| (cdr t5)) (t6 nil))
-            ((or (atom t5)
-                 (progn (setq t6 (car t5)) nil)
-                 (progn (progn (setq |n| (caddr t6)) t6) nil))
-              nil)
-         (seq
-          (exit
-           (progn
-            (setq fn (car (elt |domain| |n|)))
-            (setq |$letAssoc|
-             (as-insert (bpiname fn) |listOfVariables| |$letAssoc|))))))=
))
-      (cond
-       (|listOfBreakVars|
-        (do ((t7 |sigSlotNumberAlist| (cdr t7)) (t8 nil))
-            ((or (atom t7)
-                 (progn (setq t8 (car t7)) nil)
-                 (progn (progn (setq |n| (caddr t8)) t8) nil))
-                nil)
-         (seq
-          (exit
-           (progn
-            (setq fn (car (elt |domain| |n|)))
-            (setq |$letAssoc|
-             (as-insert (bpiname fn)
-              (cons (cons 'break |listOfBreakVars|) nil) |$letAssoc|))))=
))))
-      (do ((t9 |sigSlotNumberAlist| (cdr t9)) (|pair| nil))
-          ((or (atom t9)
-               (progn (setq |pair| (car t9)) nil)
+(defun |spadTrace| (domain options)
+ (let (|$tracedModemap| listofoperations listofvariables=20
+        listofbreakvars anyiftrue domainid currententry=20
+        currentalist opstructurelist sig kind triple fn op=20
+        mm n alias tracename sigslotnumberalist)
+ (declare (special |$tracedModemap| /tracenames |$fromSpadTrace| |$letAs=
soc|
+    |$reportSpadTrace| |$traceNoisely|))
+ (setq |$fromSpadTrace| t)
+ (setq |$tracedModemap| nil)
+ (cond
+  ((and (pairp domain)
+        (refvecp (car domain))
+        (eql (elt (car domain) 0) 0))
+    (|aldorTrace| domain options))
+  ((null (|isDomainOrPackage| domain))
+    (|userError| "bad argument to trace"))
+  (t
+   (setq listofoperations
+    (prog (t0)
+     (setq t0 nil)
+     (return
+      (do ((t1 (|getOption| 'ops options) (cdr t1)) (x nil))
+          ((or (atom t1) (progn (setq x (car t1)) nil)) (nreverse0 t0))
+       (seq
+        (exit
+         (setq t0 (cons (|spadTrace,g| x) t0))))))))
+   (cond
+    ((setq listofvariables (|getOption| 'vars options))
+      (setq options (|removeOption| 'vars options))))
+   (cond
+    ((setq listofbreakvars (|getOption| 'varbreak options))
+      (setq options (|removeOption| 'varbreak options))))
+   (setq anyiftrue (null listofoperations))
+   (setq domainid (|opOf| (elt domain 0)))
+   (setq currententry (|assoc| domain /tracenames))
+   (setq currentalist (kdr currententry))
+   (setq opstructurelist=20
+    (|flattenOperationAlist| (|getOperationAlistFromLisplib| domainid)))
+   (setq sigslotnumberalist
+    (prog (t2)
+     (setq t2 nil)
+     (return
+      (do ((t3 opstructurelist (cdr t3)) (t4 nil))
+          ((or (atom t3)
+               (progn (setq t4 (CAR t3)) nil)
                (progn
                 (progn
-                 (setq |op| (car |pair|))
-                 (setq |mm| (cadr |pair|))
-                 (setq |n| (caddr |pair|))
-                 |pair|)
-                 nil))
-               nil)
+                 (setq op (car t4))
+                 (setq sig (cadr t4))
+                 (setq n (caddr t4))
+                 (setq kind (car (cddddr t4))) t4)
+                nil))
+             (nreverse0 t2))
        (seq
         (exit
-         (progn=20
-          (setq |alias| (|spadTraceAlias| |domainId| |op| |n|))
-          (setq |$tracedModemap|
-            (|subTypes| |mm| (|constructSubst| (elt |domain| 0))))
-          (setq tracename
-            (bpitrace (car (elt |domain| |n|)) |alias| |options|))
-          (nconc |pair|
-            (cons |listOfVariables|
-             (cons (car (elt |domain| |n|))
-              (cons tracename (cons |alias| nil)))))
-          (rplac (car (elt |domain| |n|)) tracename)))))
-      (setq |sigSlotNumberAlist|
-       (prog (t10)
-        (setq t10 nil)
-        (return
-         (do ((t11 |sigSlotNumberAlist| (cdr t11)) (x nil))
-             ((or (atom t11) (progn (setq x (car t11)) nil)) (nreverse0 =
t10))
-          (seq
-           (exit
-            (cond ((cdddr x) (setq t10 (cons x t10))))))))))
-      (cond
-       (|$reportSpadTrace|
-        (cond (|$traceNoisely| (|printDashedLine|)))
-        (do ((t12 (|orderBySlotNumber| |sigSlotNumberAlist|) (cdr t12))
-             (x nil))
-            ((or (atom t12)
-                 (progn (setq x (car t12)) nil))
-                nil)
-             (seq (exit (|reportSpadTrace| 'tracing x))))))
-      (cond (|$letAssoc| (setletprintflag t)))
-      (cond=20
-       (|currentEntry|
-        (rplac (cdr |currentEntry|)
-          (append |sigSlotNumberAlist| |currentAlist|)))
-       (t=20
-        (setq /tracenames
-         (cons (cons |domain| |sigSlotNumberAlist|) /tracenames))
-          (|spadReply|))))))))))=20
+         (cond
+          ((and (eq kind 'elt)
+                (or anyiftrue (memq op listofoperations))
+                (fixp n)
+                (|spadTrace,isTraceable|
+                 (setq triple
+                  (cons op (cons sig (cons n nil)))) domain))
+             (setq t2 (cons triple t2))))))))))
+   (cond=20
+    (listofvariables
+     (do ((t5 sigslotnumberalist (cdr t5)) (t6 nil))
+         ((or (atom t5)
+              (progn (setq t6 (car t5)) nil)
+              (progn (progn (setq n (caddr t6)) t6) nil))
+           nil)
+      (seq
+       (exit
+        (progn
+         (setq fn (car (elt domain n)))
+         (setq |$letAssoc|
+          (as-insert (bpiname fn) listofvariables |$letAssoc|))))))))
+   (cond
+    (listofbreakvars
+     (do ((t7 sigslotnumberalist (cdr t7)) (t8 nil))
+         ((or (atom t7)
+              (progn (setq t8 (car t7)) nil)
+              (progn (progn (setq n (caddr t8)) t8) nil))
+             nil)
+      (seq
+       (exit
+        (progn
+         (setq fn (car (elt domain n)))
+         (setq |$letAssoc|
+          (as-insert (bpiname fn)
+           (cons (cons 'break listofbreakvars) nil) |$letAssoc|))))))))
+   (do ((t9 sigslotnumberalist (cdr t9)) (|pair| nil))
+       ((or (atom t9)
+            (progn (setq |pair| (car t9)) nil)
+            (progn
+             (progn
+              (setq op (car |pair|))
+              (setq mm (cadr |pair|))
+              (setq n (caddr |pair|))
+              |pair|)
+              nil))
+            nil)
+    (seq
+     (exit
+      (progn=20
+       (setq alias (|spadTraceAlias| domainid op n))
+       (setq |$tracedModemap|
+         (|subTypes| mm (|constructSubst| (elt domain 0))))
+       (setq tracename
+         (bpitrace (car (elt domain n)) alias options))
+       (nconc |pair|
+         (cons listofvariables
+          (cons (car (elt domain n))
+           (cons tracename (cons alias nil)))))
+       (rplac (car (elt domain n)) tracename)))))
+   (setq sigslotnumberalist
+    (prog (t10)
+     (setq t10 nil)
+     (return
+      (do ((t11 sigslotnumberalist (cdr t11)) (x nil))
+          ((or (atom t11) (progn (setq x (car t11)) nil)) (nreverse0 t10=
))
+       (seq
+        (exit
+         (cond ((cdddr x) (setq t10 (cons x t10))))))))))
+   (cond
+    (|$reportSpadTrace|
+     (cond (|$traceNoisely| (|printDashedLine|)))
+     (do ((t12 (|orderBySlotNumber| sigslotnumberalist) (cdr t12))
+          (x nil))
+         ((or (atom t12)
+              (progn (setq x (car t12)) nil))
+             nil)
+          (seq (exit (|reportSpadTrace| 'tracing x))))))
+   (cond (|$letAssoc| (setletprintflag t)))
+   (cond=20
+    (currententry
+     (rplac (cdr currententry)
+       (append sigslotnumberalist currentalist)))
+    (t=20
+     (setq /tracenames
+      (cons (cons domain sigslotnumberalist) /tracenames))
+       (|spadReply|)))))))
=20
 @
=20
@@ -12229,16 +12228,17 @@ This reports the traced functions
=20
 \defun{traceDomainConstructor}{traceDomainConstructor}
 <<defun traceDomainConstructor>>=3D
-(defun |traceDomainConstructor| (|domainConstructor| |options|)
+(defun |traceDomainConstructor| (|domainConstructor| options)
  (prog (|listOfLocalOps| |argl| |domain| |innerDomainConstructor|)
+ (declare (special |$ConstructorCache|))
   (return
    (seq
     (progn
      (|loadFunctor| |domainConstructor|)
-     (setq |listOfLocalOps| (|getOption| 'local |options|))
+     (setq |listOfLocalOps| (|getOption| 'local options))
      (when |listOfLocalOps| (|traceDomainLocalOps|))
      (cond=20
-      ((and |listOfLocalOps| (null (|getOption| 'ops |options|))) nil)
+      ((and |listOfLocalOps| (null (|getOption| 'ops options))) nil)
       (t
        (do ((t2 (hget |$ConstructorCache| |domainConstructor|) (cdr t2))
             (t3 nil))
@@ -12252,7 +12252,7 @@ This reports the traced functions
                 nil)
          (seq
           (exit
-           (|spadTrace| |domain| |options|))))
+           (|spadTrace| |domain| options))))
        (setq /tracenames (cons |domainConstructor| /tracenames))
        (setq |innerDomainConstructor|
          (intern (strconc |domainConstructor| ";")))
@@ -12277,7 +12277,7 @@ This reports the traced functions
               (cons
                (cons '|spadTrace|
                 (cons '|domain|
-                 (cons (mkq |options|) nil)))
+                 (cons (mkq options) nil)))
                (cons (cons 'return (cons '|domain| nil)) nil)))))
            nil)))))))))))=20
=20
@@ -12285,16 +12285,16 @@ This reports the traced functions
=20
 \defun{untraceDomainConstructor}{untraceDomainConstructor}
 <<defun untraceDomainConstructor,keepTraced?>>=3D
-(defun |untraceDomainConstructor,keepTraced?| (|df| |domainConstructor|)
- (prog (|dc|)
+(defun |untraceDomainConstructor,keepTraced?| (df |domainConstructor|)
+ (prog (dc)
   (return
    (seq
     (if (and=20
          (and
-          (and (pairp |df|) (progn (setq |dc| (qcar |df|)) t))
-           (|isDomainOrPackage| |dc|))
-         (boot-equal (kar (|devaluate| |dc|)) |domainConstructor|))
-     (exit (seq (|/UNTRACE,0| (cons |dc| nil)) (exit nil))))
+          (and (pairp df) (progn (setq dc (qcar df)) t))
+           (|isDomainOrPackage| dc))
+         (boot-equal (kar (|devaluate| dc)) |domainConstructor|))
+     (exit (seq (|/UNTRACE,0| (cons dc nil)) (exit nil))))
     (exit t)))))=20
=20
 @
@@ -12302,6 +12302,7 @@ This reports the traced functions
 <<defun untraceDomainConstructor>>=3D
 (defun |untraceDomainConstructor| (|domainConstructor|)
  (prog (|innerDomainConstructor|)
+ (declare (special /tracenames))
   (return
    (seq
     (progn
@@ -12309,13 +12310,13 @@ This reports the traced functions
       (prog (t0)
        (setq t0 nil)
        (return
-        (do ((t1 /tracenames (cdr t1)) (|df| nil))
-            ((or (atom t1) (progn (setq |df| (car t1)) nil)) (nreverse0 =
t0))
+        (do ((t1 /tracenames (cdr t1)) (df nil))
+            ((or (atom t1) (progn (setq df (car t1)) nil)) (nreverse0 t0=
))
          (seq
           (exit
            (cond ((|untraceDomainConstructor,keepTraced?|
-                    |df| |domainConstructor|)
-             (setq t0 (cons |df| t0))))))))))
+                    df |domainConstructor|)
+             (setq t0 (cons df t0))))))))))
      (setq |innerDomainConstructor|
       (intern (strconc |domainConstructor| ";")))
      (cond
@@ -12328,7 +12329,7 @@ This reports the traced functions
 \defun{flattenOperationAlist}{flattenOperationAlist}
 <<defun flattenOperationAlist>>=3D
 (defun |flattenOperationAlist| (|opAlist|)
- (prog (|op| |mmList| |res|)
+ (prog (op |mmList| |res|)
   (return
    (seq
     (progn
@@ -12337,7 +12338,7 @@ This reports the traced functions
          ((or (atom t0)=20
               (progn (setq t1 (car t0)) nil)
               (progn
-               (progn (setq |op| (car t1)) (setq |mmList| (cdr t1)) t1)
+               (progn (setq op (car t1)) (setq |mmList| (cdr t1)) t1)
                nil))=20
              nil)
       (seq
@@ -12347,12 +12348,12 @@ This reports the traced functions
           (prog (t2)
            (setq t2 nil)
            (return
-            (do ((t3 |mmList| (cdr t3)) (|mm| nil))
+            (do ((t3 |mmList| (cdr t3)) (mm nil))
                 ((or (atom t3)
-                     (progn (setq |mm| (car t3)) nil)) (nreverse0 t2))
+                     (progn (setq mm (car t3)) nil)) (nreverse0 t2))
              (seq
               (exit
-               (setq t2 (cons (cons |op| |mm|) t2))))))))))))
+               (setq t2 (cons (cons op mm) t2))))))))))))
      |res|)))))=20
=20
 @
@@ -12370,6 +12371,7 @@ This reports the traced functions
 <<defun letPrint>>=3D
 (defun |letPrint| (x |val| |currentFunction|)
  (prog (y)
+ (declare (special |$letAssoc|))
   (return
    (progn
     (cond ((and |$letAssoc|=20
@@ -12406,7 +12408,7 @@ This reports the traced functions
 <<defun letPrint2>>=3D
 (defun |letPrint2| (x |printform| |currentFunction|)
  (prog (|$BreakMode| |flag| y)
-  (declare (special |$BreakMode|))
+  (declare (special |$BreakMode| |$letAssoc| ))
   (return
    (progn
     (setq |$BreakMode| nil)
@@ -12449,7 +12451,7 @@ to convert the data into type "Expression"
 <<defun letPrint3>>=3D
 (defun |letPrint3| (x |xval| |printfn| |currentFunction|)
  (prog (|$BreakMode| |flag| y)
-  (declare (special |$BreakMode|))
+  (declare (special |$BreakMode| |$letAssoc| ))
   (return
    (progn
     (setq |$BreakMode| nil)
@@ -12492,13 +12494,14 @@ to convert the data into type "Expression"
 <<defun getAliasIfTracedMapParameter>>=3D
 (defun |getAliasIfTracedMapParameter| (x |currentFunction|)
  (prog (|aliasList|)
+ (declare (special |$InteractiveFrame|))
   (return
    (seq
     (cond
      ((|isSharpVarWithNum| x)
        (cond
         ((setq |aliasList|
-           (|get| |currentFunction| '|alias| |$InteractiveFrame|))
+           (|get| |currentFunction| 'alias |$InteractiveFrame|))
          (exit
           (elt |aliasList|
            (spaddifference
@@ -12510,13 +12513,14 @@ to convert the data into type "Expression"
 \defun{getBpiNameIfTracedMap}{getBpiNameIfTracedMap}
 <<defun getBpiNameIfTracedMap>>=3D
 (defun |getBpiNameIfTracedMap| (name)
- (prog (|lmm| |bpiName|)
+ (prog (lmm |bpiName|)
+ (declare (special |$InteractiveFrame| /tracenames))
   (return
    (seq
     (cond=20
-     ((setq |lmm| (|get| name '|localModemap| |$InteractiveFrame|))
+     ((setq lmm (|get| name '|localModemap| |$InteractiveFrame|))
        (cond
-        ((memq (setq |bpiName| (cadar |lmm|)) /tracenames)
+        ((memq (setq |bpiName| (cadar lmm)) /tracenames)
            (exit |bpiName|))))
      (t name))))))=20
=20
@@ -12551,30 +12555,29 @@ to convert the data into type "Expression"
=20
 \defun{spadTraceAlias}{spadTraceAlias}
 <<defun spadTraceAlias>>=3D
-(defun |spadTraceAlias| (|domainId| |op| |n|)
- (internl |domainId| (intern "." "boot") |op| '|,| (stringimage |n|)))=20
+(defun |spadTraceAlias| (domainid op n)
+ (internl domainid (intern "." "boot") op '|,| (stringimage n)))=20
=20
 @
=20
 \defun{getOption}{getOption}
 <<defun getOption>>=3D
 (defun |getOption| (opt l)
- (prog (y)
-  (return
-   (seq
-    (cond ((setq y (|assoc| opt l)) (exit (cdr y))))))))=20
+ (let (y)
+  (when (setq y (|assoc| opt l))  (cdr y))))
=20
 @
=20
 \defun{reportSpadTrace}{reportSpadTrace}
 <<defun reportSpadTrace>>=3D
 (defun |reportSpadTrace| (|header| t0)
- (prog (|op| |sig| |n| |t| |msg| |namePart| y |tracePart|)
+ (prog (op sig n |t| |msg| |namePart| y |tracePart|)
+ (declare (special |$traceNoisely|))
   (return=20
    (progn
-    (setq |op| (car t0))
-    (setq |sig| (cadr t0))
-    (setq |n| (caddr t0))
+    (setq op (car t0))
+    (setq sig (cadr t0))
+    (setq n (caddr t0))
     (setq |t| (cdddr t0))
     (cond
      ((null |$traceNoisely|) nil)
@@ -12582,14 +12585,14 @@ to convert the data into type "Expression"
       (setq |msg|
        (cons |header|
         (cons '|%b|
-         (cons |op|
+         (cons op
           (cons '|:|
            (cons '|%d|
-            (cons (CDR |sig|)
+            (cons (CDR sig)
              (cons '| -> |
-              (cons (car |sig|)
+              (cons (car sig)
                (cons '| in slot |
-                (cons |n| nil)))))))))))
+                (cons n nil)))))))))))
       (setq |namePart| nil)
       (setq |tracePart|
        (cond
@@ -12606,7 +12609,7 @@ to convert the data into type "Expression"
 \defun{orderBySlotNumber}{orderBySlotNumber}
 <<defun orderBySlotNumber>>=3D
 (defun |orderBySlotNumber| (arg)
- (prog (|n|)
+ (prog (n)
   (return=20
    (seq
     (assocright
@@ -12617,11 +12620,11 @@ to convert the data into type "Expression"
         (do ((t1 arg (cdr t1)) (x nil))
             ((or (atom t1)
                  (progn (setq x (car t1)) nil)
-                 (progn (progn (setq |n| (caddr x)) x) nil))
+                 (progn (progn (setq n (caddr x)) x) nil))
                (nreverse0 t0))
          (seq
           (exit
-           (setq t0 (cons (cons |n| x) t0)))))))))))))=20
+           (setq t0 (cons (cons n x) t0)))))))))))))=20
=20
 @
=20
@@ -12667,6 +12670,7 @@ to convert the data into type "Expression"
 <<defun spadReply>>=3D
 (defun |spadReply| ()
  (prog ()=20
+ (declare (special /tracenames))
   (return
    (seq
     (prog (t0)
@@ -12682,50 +12686,51 @@ to convert the data into type "Expression"
=20
 \defun{spadUntrace}{spadUntrace}
 <<defun spadUntrace>>=3D
-(defun |spadUntrace| (|domain| |options|)
- (prog (|anyifTrue| |listOfOperations| |domainId| |pair| |sigSlotNumberA=
list|=20
-        |op| |sig| |n| |lv| |bpiPointer| tracename |alias| |assocPair|=20
+(defun |spadUntrace| (|domain| options)
+ (prog (anyiftrue listofoperations domainid |pair| sigslotnumberalist=20
+        op sig n |lv| |bpiPointer| tracename alias |assocPair|=20
         |newSigSlotNumberAlist|)
+ (declare (special |$letAssoc| /tracenames))
   (return
    (seq
     (cond
      ((null (|isDomainOrPackage| |domain|))
        (|userError| "bad argument to untrace"))
      (t
-      (setq |anyifTrue| (null |options|))
-      (setq |listOfOperations| (|getOption| '|ops:| |options|))
-      (setq |domainId| (|devaluate| |domain|))
+      (setq anyiftrue (null options))
+      (setq listofoperations (|getOption| '|ops:| options))
+      (setq domainid (|devaluate| |domain|))
       (cond
        ((null (setq |pair| (|assoc| |domain| /tracenames)))
          (|sayMSG|=20
           (cons "   No functions in"=20
            (append
-            (|bright| (|prefix2String| |domainId|))
+            (|bright| (|prefix2String| domainid))
             (cons "are now traced." nil)))))
        (t=20
-        (setq |sigSlotNumberAlist| (cdr |pair|))
-        (do ((t0 |sigSlotNumberAlist| (cdr t0)) (|pair| nil))
+        (setq sigslotnumberalist (cdr |pair|))
+        (do ((t0 sigslotnumberalist (cdr t0)) (|pair| nil))
             ((or (atom t0)=20
                  (progn (setq |pair| (car t0)) nil)
                  (progn
                   (progn
-                   (setq |op| (car |pair|))
-                   (setq |sig| (cadr |pair|))
-                   (setq |n| (caddr |pair|))
+                   (setq op (car |pair|))
+                   (setq sig (cadr |pair|))
+                   (setq n (caddr |pair|))
                    (setq |lv| (cadddr |pair|))
                    (setq |bpiPointer| (car (cddddr |pair|)))
                    (setq tracename (cadr (cddddr |pair|)))
-                   (setq |alias| (caddr (cddddr |pair|)))
+                   (setq alias (caddr (cddddr |pair|)))
                    |pair|)
                   nil))
                  nil)
          (seq
           (exit
            (cond
-            ((or |anyifTrue| (memq |op| |listOfOperations|))
+            ((or anyiftrue (memq op listofoperations))
               (progn
-                (bpiuntrace tracename |alias|)
-                (rplac (car (elt |domain| |n|)) |bpiPointer|)
+                (bpiuntrace tracename alias)
+                (rplac (car (elt |domain| n)) |bpiPointer|)
                 (rplac (cdddr |pair|) nil)
                 (cond
                  ((setq |assocPair|
@@ -12739,7 +12744,7 @@ to convert the data into type "Expression"
          (prog (t1)=20
           (setq t1 nil)
           (return
-           (do ((t2 |sigSlotNumberAlist| (cdr t2)) (x nil))
+           (do ((t2 sigslotnumberalist (cdr t2)) (x nil))
                ((or (atom t2) (progn (setq x (car t2)) nil)) (nreverse0 =
t1))
              (seq
               (exit
@@ -12769,6 +12774,7 @@ to convert the data into type "Expression"
 \defun{prTraceNames}{prTraceNames}
 <<defun prTraceNames>>=3D
 (defun |prTraceNames| ()
+ (declare (special /tracenames))
  (seq
   (progn
    (do ((t0 /tracenames (cdr t0)) (x nil))
@@ -12784,7 +12790,8 @@ to convert the data into type "Expression"
 (defun |traceReply| ()
  (prog (|$domains| |$packages| |$constructors| |d| |functionList|=20
         |displayList|)
-  (declare (special |$domains| |$packages| |$constructors|))
+  (declare (special |$domains| |$packages| |$constructors| /tracenames
+     $linelength))
   (return
    (seq
     (progn
@@ -12852,7 +12859,7 @@ to convert the data into type "Expression"
           ((atom |displayList|)
            (setq |displayList| (cons |displayList| nil))))
          (|sayBrightly| "   Domains traced: ")
-         (|sayBrightly| (|flowSegmentedMsg| |displayList| $LINELENGTH 6)=
)))
+         (|sayBrightly| (|flowSegmentedMsg| |displayList| $linelength 6)=
)))
        (cond=20
         (|$packages|
           (setq |displayList|
@@ -12943,7 +12950,8 @@ to convert the data into type "Expression"
 <<defun tracelet>>=3D
 (defun |tracelet| (fn |vars|)
  (prog ($traceletflag |$QuickLet| l)
-  (declare (special $traceletflag |$QuickLet|))
+  (declare (special $traceletflag |$QuickLet| |$letAssoc|=20
+     |$traceletFunctions|))
   (return
    (progn
     (cond
@@ -12981,7 +12989,7 @@ to convert the data into type "Expression"
 <<defun breaklet>>=3D
 (defun |breaklet| (fn |vars|)
  (prog (|$QuickLet| |fnEntry| |pair|)
-  (declare (special |$QuickLet|))
+  (declare (special |$QuickLet| |$letAssoc| |$traceletFunctions|))
   (return
    (progn
     (cond
@@ -13192,6 +13200,8 @@ $previousBindings :=3D nil
 <<defun recordFrame>>=3D
 (defun |recordFrame| (systemNormal)
  (prog (currentAlist delta)
+ (declare (special |$undoFlag| |$frameRecord| |$InteractiveFrame|=20
+    |$previousBindings|))
   (return
    (seq
     (cond=20
@@ -13400,6 +13410,7 @@ Properties of r ::
 <<defun reportUndo>>=3D
 (defun |reportUndo| (acc)
  (prog (name proplist curproplist prop value)
+ (declare (special |$InteractiveFrame|))
   (return
    (seq
     (do ((tmp0 acc (cdr tmp0)) (tmp1 nil))
@@ -13452,6 +13463,7 @@ Properties of r ::
 <<defun undoCount>>=3D
 (defun |undoCount| (n)
  (prog (m)
+ (declare (special |$IOindex|))
   (return
    (progn
     (setq m=20
@@ -13613,6 +13625,7 @@ Removing undo lines from \verb|)hist )write linel=
ist|
 <<defun removeUndoLines>>=3D
 (defun |removeUndoLines| (u)
  (prog (xtra savedIOindex s s1 m s2 x code c n acc)
+ (declare (special |$currentLine| |$IOindex|))
   (return
    (seq
     (progn
@@ -13835,7 +13848,7 @@ The command synonym  {\tt )apropos} is equivalent=
 to
 <<defun whatSpad2Cmd>>=3D
 (defun |whatSpad2Cmd| (arg)
  (prog (|$e| |key0| key args)
-  (declare (special |$e|))
+  (declare (special |$e| |$whatOptions|))
   (return
    (seq
     (progn
@@ -13889,9 +13902,9 @@ The command synonym  {\tt )apropos} is equivalent=
 to
 <<defun filterAndFormatConstructors>>=3D
 (defun |filterAndFormatConstructors| (|constrType| label |patterns|)
  (prog (l)
+ (declare (special $linelength ))
   (return
-   (progn (|centerAndHighlight| label $linelength=20
-           (|specialChar| '|hbar|))
+   (progn (|centerAndHighlight| label $linelength (|specialChar| '|hbar|=
))
     (setq l
      (|filterListOfStringsWithFn| |patterns|
        (|whatConstructors| |constrType|)
@@ -14008,7 +14021,7 @@ This displays all operation names containing thes=
e fragments
 <<defun workfilesSpad2Cmd>>=3D
 (defun |workfilesSpad2Cmd| (args)
  (let (deleteflag type flist type1 fl)
-  (declare (special |$options| |$sourceFiles|))
+  (declare (special |$options| |$sourceFiles| $linelength))
   (cond=20
    (args (|throwKeyedMsg| 's2iz0047 nil))
    (t
@@ -14384,14 +14397,14 @@ This displays all operation names containing th=
ese fragments
 <<defun defiostream>>=3D
 (defun defiostream (stream-alist buffer-size char-position)
  (declare (ignore buffer-size))
-   (let ((mode (or (cdr (assoc 'MODE stream-alist)) 'INPUT))
-         (filename (cdr (assoc 'FILE stream-alist)))
-         (dev (cdr (assoc 'DEVICE stream-alist))))
-      (if (EQ dev 'CONSOLE) (make-synonym-stream '*terminal-io*)
+   (let ((mode (or (cdr (assoc 'mode stream-alist)) 'input))
+         (filename (cdr (assoc 'file stream-alist)))
+         (dev (cdr (assoc 'device stream-alist))))
+      (if (eq dev 'console) (make-synonym-stream '*terminal-io*)
        (let ((strm (case mode
-                          ((OUTPUT O) (open (make-filename filename)
+                          ((output o) (open (make-filename filename)
                                            :direction :output))
-                          ((INPUT I) (open (make-input-filename filename=
)
+                          ((input i) (open (make-input-filename filename=
)
                                            :direction :input)))))
          (if (and (numberp char-position) (> char-position 0))
            (file-position strm char-position))
@@ -14425,7 +14438,13 @@ This displays all operation names containing the=
se fragments
 \chapter{The Spad Server Mechanism}
 <<initvars>>=3D
 (defvar $openServerIfTrue t "t means try starting an open server")
+
+@
+<<initvars>>=3D
 (defconstant $SpadServerName "/tmp/.d" "the name of the spad server sock=
et")
+
+@
+<<initvars>>=3D
 (defvar |$SpadServer| nil "t means Scratchpad acts as a remote server")
=20
 @
@@ -14491,6 +14510,7 @@ DEBUGSYS=3D${OBJ}/${SYS}/bin/debugsys
 \end{list}
 <<defun spad-save>>=3D
 (defun user::spad-save (save-file)
+  (declare (special |$SpadServer| $openServerIfTrue))
   (setq |$SpadServer| nil)
   (setq $openServerIfTrue t)
 #+:AKCL
@@ -14530,7 +14550,7 @@ load the file \verb|exposed.lsp| to set up the ex=
posure group information.
  (cond
   ((load "./exposed" :verbose nil :if-does-not-exist nil)
     '|done|)
-  ((load (concat (system:getenv "AXIOM") "/algebra/exposed")
+  ((load (concat (getenviron "AXIOM") "/algebra/exposed")
      :verbose nil :if-does-not-exist nil)
    '|done|)
   (t '|failed|) ))
@@ -14662,6 +14682,280 @@ load the file \verb|exposed.lsp| to set up the =
exposure group information.
=20
 @
 =20
+\chapter{Dangling references}
+\section{shell variables}
+\begin{verbatim}
+AXIOM
+\end{verbatim}
+
+\section{catch tags}
+\begin{verbatim}
+|coerceFailure|=20
+filenam
+|$intTopLevel|=20
+|letPrint2|=20
+|$quitTag|
+|ScanOrPairVecAnswer|
+|top_level|
+|writifyTag|
+\end{verbatim}
+
+\section{catch tags}
+\begin{verbatim}
+|ScanOrPairVecAnswer|
+|top_level|
+|writifyTag|
+\end{verbatim}
+
+\section{defined special variables}
+\begin{verbatim}
+|$abbreviateTypes|
+|$algebraFormat|
+|$algebraOutputFile|
+|$algebraOutputStream|
+|$asharpCmdlineFlags|
+|$BreakMode|
+|$clearExcept|
+|$clearOptions|
+|$CommandSynonymAlist|
+|$compileDontDefineFunctions|
+|$compileRecurrence|
+compiler::*compile-verbose*
+credits
+|$defaultFortranType|
+*default-pathname-defaults*
+|$defaultSpecialCharacters|
+|$displayDroppedMap|
+|$displayMsgNumber|
+|$displayOptions|=20
+|$displaySetValue|
+|$displayStartMsgs|
+|$formulaFormat|
+|$formulaOutputFile|
+|$fortIndent|
+|$fortInts2Floats|
+|$fortLength|
+|$fortranArrayStartingIndex|
+|$fortranDirectory|
+|$fortranFormat|
+|$fortranLibraries|
+|$fortranOptimizationLevel|
+|$fortranOutputFile|
+|$fortranPrecision|
+|$fortranSegment|
+|$fortranTmpDir|
+|$fortPersistence|
+|$fractionDisplayType|
+|$frameMessages|
+|$fullScreenSysVars|
+|$giveExposureWarning|
+|$HiFiAccess|
+|$highlightAllowed|
+|$historyDirectory|
+|$historyDisplayWidth|
+|$historyFileType|
+|$InitialCommandSynonymAlist|
+|$inputPromptType|
+|$linearFormatScripts|
+$linelength
+|$mapSubNameAlist|
+|$mathmlFormat|
+|$mathmlOutputFile|
+|$maximumFortranExpressionLength|
+|$nagEnforceDouble|
+|$nagHost|
+|$nagMessages|
+|$noParseCommands|=20
+|$oldHistoryFileName|
+|$openMathFormat|
+|$openMathOutputFile|
+$openServerIfTrue
+|$optionAlist|
+|$options|
+|$plainRTspecialCharacters|
+|$plainSpecialCharacters0|
+|$plainSpecialCharacters1|
+|$plainSpecialCharacters2|
+|$plainSpecialCharacters3|
+$prettyprint
+|$printAnyIfTrue|
+|$printFortranDecs|
+|$printLoadMsgs|
+|$printMsgsToFile|
+|$printStatisticsSummaryIfTrue|
+|$printTimeIfTrue|
+|$printTypeIfTrue|
+|$printVoidIfTrue|
+|$quitCommandType|
+|$reportBottomUpFlag|
+|$reportCoerceIfTrue|
+|$reportCompilation|
+|$reportEachInstantiation|
+|$reportInstantiations|
+|$reportInterpOnly|
+|$reportOptimization|
+|$reportSpadTrace|
+|$RTspecialCharacters|
+*standard-input*
+*standard-output*
+|$SpadServer|
+$SpadServerName
+|$specialCharacterAlist|=20
+|$specialCharacters|
+|$streamCount|
+|$streamsShowAll|
+compiler::*suppress-compiler-notes*
+compiler::*suppress-compiler-warnings*
+|$systemCommandFunction|
+$syscommands
+|$systemCommands|
+*terminal-io*
+|$testingSystem|
+|$texFormat|
+|$texOutputFile|
+|$tokenCommands|
+system::*top-level-hook*
+|$tracedMapSignatures|
+|$traceNoisely|
+|$traceOptionList|
+underbar
+|$useEditorForShowOutput|
+|$useFullScreenHelp|
+|$useInternalHistoryTable|
+|$useIntrinsicFunctions|
+|$UserLevel|
+|$whatOptions|
+\end{verbatim}
+=20
+\section{undefined special variables}
+\begin{verbatim}
+|$attributeDb|
+$boot
+|$cacheAlist|
+|$cacheCount|=20
+|$CatOfCatDatabase|
+|$CloseClient|
+|$coerceIntByMapCounter|
+|$compileMapFlag|
+|$ConstructorCache|
+|$constructors|
+/countlist
+$current-directory
+|$currentFrameNum|
+|$currentLine|
+$dalymode
+|$defaultMsgDatabaseName|
+|$dependeeClosureAlist|
+$directory-list
+|$displayStartMsgs|=20
+|$domains|
+|$DomOfCatDatabase|
+|$domainTraceNameAssoc|
+|$doNotAddEmptyModeIfTrue|
+|$e|
+|$echoLineStack|
+/editfile
+|$EmptyEnvironment|
+|$env|
+*eof*
+|$erMsgToss|
+|$existingFiles|
+|$fn|
+|$formulaOutputStream|
+|$fortranOutputStream|
+|$frameMessages|
+|$frameRecord|
+|$fromSpadTrace|
+|$functionTable|
+|$globalExposureGroupAlist|
+|$HistList|
+|$HistListAct|
+|$HistListLen|
+|$HistRecord|
+|$inLispVM|
+|$inclAssertions|
+|$InitialModemapFrame|))=20
+in-stream
+|$InteractiveMode|
+|$InteractiveFrame|=20
+|$internalHistoryTable|
+|$interpreterFrameName|
+|$interpreterFrameRing|
+|$intRestart|
+|$intTopLevel|
+|$IOindex|=20
+|$JoinOfCatDatabase|
+|$JoinOfDomDatabase|
+|$lastPos|
+|$lastUntraced|
+|$letAssoc|=20
+|$libQuiet|
+$library-directory-list
+|$localExposureData|
+|$localExposureDataDefault|
+|$lookupDefaults|
+|$mathmlOutputStream|
+|$mathTraceList|
+|$mkTestInputStack|
+|$msgAlist|
+|$msgDatabase|
+|$msgDatabaseName|
+|$ncMsgList|
+|$newConlist|
+|$NonNullStream|=20
+|$nopos|
+|$newcompErrorCount|
+|$newcompMode|
+$newspad
+|$NullStream|
+|$okToExecuteMachineCode|
+|$openMathOutputStream|
+|$operationNameList|
+|$outputLibraryName|
+|$OutputForm|
+|$packages|
+/pretty
+|$previousBindings|
+|$PrintCompilerMessageIfTrue|
+|$printLoadMsgs|=20
+|$promptMsg|
+|$QuickLet
+|$quitTag|
+$relative-directory-list
+$relative-library-directory-list
+|$seen|
+|$SessionManager|
+|$setOptions|
+|$shoeReadLineFunction|
+|$slamFlag|
+/sourcefiles
+|$sourceFiles|
+/spacelist
+$spad
+$spadroot
+|$texOutputStream|
+/timerlist
+|$timerTicksPerSecond|
+|$tracedMapSignatures|
+|$tracedModemap|
+|$tracedSpadModemap|
+|$traceErrorStack|
+$traceletflag
+|$traceletFunctions|
+|$undoFlag|
+|$useFullScreenHelp|
+|$UserAbbreviationsAlist|
+|$variableNumberAlist|
+|$Void|
+|$writifyComplained|
+/wsname
+|$xdatabase|
+\end{verbatim}
+
+\section{functions}
+\begin{verbatim}
+\end{verbatim}
+
 \chapter{The Interpreter}
 <<Interpreter>>=3D
 (in-package "BOOT")
@@ -14703,13 +14997,8 @@ load the file \verb|exposed.lsp| to set up the e=
xposure group information.
 <<defun coerceSpadFunValue2E>>
 <<defun coerceTraceArgs2E>>
 <<defun coerceTraceFunValue2E>>
-<<defun compileAsharpArchiveCmd>>
-<<defun compileAsharpCmd>>
-<<defun compileAsharpCmd1>>
-<<defun compileAsharpLispCmd>>
 <<defun compileBoot>>
 <<defun compiler>>
-<<defun compileSpadLispCmd>>
 <<defun concat>>
 <<defun copyright>>
 <<defun countCache>>
@@ -15005,7 +15294,6 @@ load the file \verb|exposed.lsp| to set up the ex=
posure group information.
 <<defun whatSpad2Cmd>>
 <<defun whatSpad2Cmd,fixpat>>
 <<defun with>>
-<<defun withAsharpCmd>>
 <<defun workfiles>>
 <<defun workfilesSpad2Cmd>>
 <<defun writeHiFi>>
diff --git a/books/bookvol9.pamphlet b/books/bookvol9.pamphlet
index b539dd1..d8348fd 100644
--- a/books/bookvol9.pamphlet
+++ b/books/bookvol9.pamphlet
@@ -577,7 +577,7 @@ and mode.
        |$newConlist|))=20
    (setq path (|pathname| args))
    (cond
-    ((nequal (|pathnameType| path) "spad") (|throwKeyedMsg| 'S2IZ0082 ni=
l))
+    ((nequal (|pathnameType| path) "spad") (|throwKeyedMsg| 's2iz0082 ni=
l))
     ((null (probe-file path))
      (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil)))
     (t
@@ -638,12 +638,352 @@ and mode.
     (|spadPrompt|)))))
=20
 @
+\defun{compileSpadLispCmd}{compileSpadLispCmd}
+<<defun compileSpadLispCmd>>=3D
+(defun |compileSpadLispCmd| (args)
+ (let (path optlist optname optargs beQuiet dolibrary lsp)
+  (declare (special |$options|))
+  (setq path (|pathname| (|fnameMake| (car args) "code" "lsp")))
+  (cond
+   ((null (probe-file path))
+     (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil)))
+   (t
+    (setq optlist '(|quiet| |noquiet| |library| |nolibrary|))
+    (setq beQuiet nil)
+    (setq dolibrary t)
+    (dolist (opt |$options|)
+      (setq optname (car opt))
+      (setq optargs (cdr opt))
+      (case (|selectOptionLC| optname optlist nil)
+         (|quiet|     (setq beQuiet t))
+         (|noquiet|   (setq beQuiet nil))
+         (|library|   (setq dolibrary t))
+         (|nolibrary| (setq dolibrary nil))
+         (t
+          (|throwKeyedMsg| 's2iz0036
+           (list (strconc ")" (|object2String| optname)))))))
+    (setq lsp
+     (|fnameMake|
+      (|pathnameDirectory| path)
+      (|pathnameName| path)
+      (|pathnameType| path)))
+    (cond
+     ((|fnameReadable?| lsp)
+      (unless beQuiet (|sayKeyedMsg| 's2iz0089 (list (|namestring| lsp))=
))
+       (recompile-lib-file-if-necessary lsp))
+     (t
+      (|sayKeyedMsg| 's2il0003 (list (|namestring| lsp)))))
+    (cond
+     (dolibrary
+      (unless beQuiet (|sayKeyedMsg| 's2iz0090 (list (|pathnameName| pat=
h))))
+      (localdatabase (list (|pathnameName| (car args))) nil))
+     ((null beQuiet) (|sayKeyedMsg| 's2iz0084 nil))
+     (t nil))
+    (|terminateSystemCommand|)
+    (|spadPrompt|)))))
+
+@
+
+\defun{compileAsharpCmd}{compileAsharpCmd}
+<<defun compileAsharpCmd>>=3D
+(defun |compileAsharpCmd| (args)
+  (|compileAsharpCmd1| args)
+  (|terminateSystemCommand|)
+  (|spadPrompt|))
+
+@
+
+\defun{compileAsharpCmd1}{compileAsharpCmd1}
+<<defun compileAsharpCmd1>>=3D
+(defun |compileAsharpCmd1| (args)
+ (let (path pathtype optlist optname optargs bequiet docompilelisp=20
+        moreargs onlyargs dolibrary p tempargs s asharpargs command rc l=
sp)
+   (declare (special |$options| |$asharpCmdlineFlags| |$newConlist|
+             /editfile))
+   (setq path (|pathname| args))
+   (setq pathtype (|pathnameType| path))
+   (cond
+   ((and (nequal pathtype "as") (nequal pathtype "ao"))
+     (|throwKeyedMsg| 's2iz0083 nil))
+   ((null (probe-file path))
+     (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil)))
+   (t
+    (setq /editfile path)
+    (|updateSourceFiles| path)
+    (setq optlist
+     '(|new| |old| |translate| |onlyargs| |moreargs| |quiet|=20
+       |nolispcompile| |noquiet| |library| |nolibrary|))
+    (setq bequiet nil)
+    (setq dolibrary t)
+    (setq docompilelisp t)
+    (setq moreargs nil)
+    (setq onlyargs nil)
+    (dolist (opt |$options|)
+      (setq optname (car opt))
+      (setq optargs (cdr opt))
+      (case (|selectOptionLC| optname optlist nil)
+       (|new| nil)
+       (|old| (|error| '|Internal error: compileAsharpCmd got )old|))
+       (|translate|
+        (|error| '|Internal error: compileAsharpCmd got )translate|))
+       (|quiet|         (setq bequiet t))
+       (|noquiet|       (setq bequiet nil))
+       (|nolispcompile| (setq docompilelisp nil))
+       (|moreargs|      (setq moreargs optargs))
+       (|onlyargs|      (setq onlyargs optargs))
+       (|library|       (setq dolibrary t))
+       (|nolibrary|     (setq dolibrary nil))
+       (t=20
+        (|throwKeyedMsg| 's2iz0036
+         (cons (strconc ")" (|object2String| optname)) nil)))))
+    (setq tempargs
+     (if (string=3D pathtype "ao")
+       (if (setq p (strpos "-Fao" |$asharpCmdlineFlags| 0 nil))
+         (if (eql p 0)=20
+          (substring |$asharpCmdlineFlags| 5 nil)
+          (strconc (substring |$asharpCmdlineFlags| 0 p)=20
+             " " (substring |$asharpCmdlineFlags| (plus p 5) nil)))
+         |$asharpCmdlineFlags|)
+       |$asharpCmdlineFlags|))
+    (setq asharpargs
+     (cond
+      (onlyargs
+       (setq s '||)
+       (do ((t1 onlyargs (cdr t1)) (|a| nil))
+           ((or (atom t1) (progn (setq |a| (car t1)) nil)) nil)
+          (setq s (strconc s " " (|object2String| |a|))))
+       s)
+      (moreargs
+       (setq s tempargs)
+       (do ((t2 moreargs (cdr t2)) (|a| nil))
+           ((or (atom t2) (progn (setq |a| (car t2)) nil)) nil)
+          (setq s (strconc s " " (|object2String| |a|))))
+       s)
+      (t tempargs)))
+    (unless bequiet
+     (|sayKeyedMsg| 's2iz0038a  (list (|namestring| args) asharpargs )))
+    (setq command
+     (strconc
+      (strconc (getenv "ALDORROOT") "/bin/")
+      '|aldor | asharpargs " " (|namestring| args)))
+    (setq rc (obey command))
+    (cond
+     ((and (eql rc 0) docompilelisp)
+       (setq lsp (|fnameMake| "." (|pathnameName| args) "lsp"))
+       (cond
+        ((|fnameReadable?| lsp)
+         (unless  bequiet
+           (|sayKeyedMsg| 's2iz0089 (cons (|namestring| lsp) nil)))
+         (|compileFileQuietly| lsp))
+        (t (|sayKeyedMsg| 's2il0003 (cons (|namestring| lsp) nil))))))
+    (cond
+     ((and (eql rc 0) dolibrary)
+      (unless bequiet
+         (|sayKeyedMsg| 's2iz0090 (cons (|pathnameName| path) nil)))
+      (|withAsharpCmd| (cons (|pathnameName| path) nil)))
+     ((null bequiet) (|sayKeyedMsg| 's2iz0084 nil))
+     (t nil))
+    (|extendLocalLibdb| |$newConlist|)))))
+
+@
+
+\defun{compileAsharpArchiveCmd}{compileAsharpArchiveCmd}
+<<defun compileAsharpArchiveCmd>>=3D
+(defun |compileAsharpArchiveCmd| (args)
+ (let (path dir exists isdir curdir cmd rc asos)
+  (declare (special $current-directory))
+  (setq path (|pathname| args))
+  (if (null (probe-file path))
+   (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil))
+   (progn
+    (setq dir (|fnameMake| "." (|pathnameName| path) "axldir"))
+    (setq exists (probe-file dir))
+    (setq isdir (|directoryp| (|namestring| dir)))
+    (if (and exists (nequal isdir 1))
+     (|throwKeyedMsg| 's2il0027 (list (|namestring| dir) (|namestring| a=
rgs)))
+     (progn
+      (when (nequal isdir 1)
+        (setq cmd (strconc "mkdir " (|namestring| dir)))
+        (setq rc (obey cmd))
+        (when (nequal rc 0)
+          (|throwKeyedMsg| 's2il0027=20
+           (list (|namestring| dir) (|namestring| args)))))
+      (setq curdir $current-directory)
+      (|cd| (cons (|object2Identifier| (|namestring| dir)) nil))
+      (setq cmd (strconc "ar x " (|namestring| path)))
+      (setq rc (obey cmd))
+      (cond
+       ((nequal rc 0)
+        (|cd| (cons (|object2Identifier| (|namestring| curdir)) nil))
+        (|throwKeyedMsg| 's2il0028
+         (cons (|namestring| dir) (cons (|namestring| args) nil))))
+       (t
+        (setq asos (directory "*.ao"))
+        (if (null asos)
+         (progn
+          (|cd| (cons (|object2Identifier| (|namestring| curdir)) nil))
+          (|throwKeyedMsg| 's2il0029
+           (cons (|namestring| dir) (cons (|namestring| args) nil))))
+         (progn
+          (dolist (aso asos)
+             (|compileAsharpCmd1| (list (|namestring| aso))))
+          (|cd| (list (|object2Identifier| (|namestring| curdir))))
+          (|terminateSystemCommand|)
+          (|spadPrompt|)))))))))))
+
+@
+
+\defun{compileAsharpLispCmd}{compileAsharpLispCmd}
+<<defun compileAsharpLispCmd>>=3D
+(defun |compileAsharpLispCmd| (args)
+ (let (path optlist optname optargs bequiet dolibrary lsp)
+  (declare (special |$options|))
+  (setq path (|pathname| args))
+  (if (null (probe-file path))=20
+   (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil))
+   (progn
+    (setq optlist '(|quiet| |noquiet| |library| |nolibrary|))
+    (setq bequiet nil)
+    (setq dolibrary t)
+    (dolist (opt |$options|)
+      (setq optname (car opt))
+      (setq optargs (cdr opt))
+      (case (|selectOptionLC| optname optlist nil)
+        (|quiet|     (setq bequiet t))
+        (|noquiet|   (setq bequiet nil))
+        (|library|   (setq dolibrary t))
+        (|nolibrary| (setq dolibrary nil))
+        (t
+          (|throwKeyedMsg| 's2iz0036=20
+           (list (strconc ")" (|object2String| optname)))))))
+    (setq lsp
+     (|fnameMake|
+      (|pathnameDirectory| path)
+      (|pathnameName| path)
+      (|pathnameType| path)))
+    (cond
+     ((|fnameReadable?| lsp)
+      (unless bequiet
+         (|sayKeyedMsg| 's2iz0089 (cons (|namestring| lsp) nil)))
+      (|compileFileQuietly| lsp))
+     (t (|sayKeyedMsg| 's2il0003 (cons (|namestring| lsp) nil))))
+    (cond
+     (dolibrary
+      (unless  bequiet
+        (|sayKeyedMsg| 's2iz0090 (cons (|pathnameName| path) nil)))
+      (|withAsharpCmd| (cons (|pathnameName| path) nil)))
+     ((null bequiet) (|sayKeyedMsg| 's2iz0084 nil))
+     (t nil))
+    (|terminateSystemCommand|)
+    (|spadPrompt|)))))
+
+@
+
+\defun{withAsharpCmd}{withAsharpCmd}
+<<defun withAsharpCmd>>=3D
+(defun |withAsharpCmd| (args)
+ (let (|$options|)
+  (declare (special |$options|))
+  (localdatabase args |$options|)))
+
+@
+
+\defun{compileFileQuietly}{compileFileQuietly}
+if \verb|$InteractiveMode| then use a null outputstream=20
+<<defun compileFileQuietly>>=3D
+(defun |compileFileQuietly| (fn)=20
+  (let (
+	(*standard-output*
+	 (if |$InteractiveMode| (make-broadcast-stream)
+	   *standard-output*)))
+  (declare (special *standard-output*))
+  (compile-file fn)))
+
+@
+
+\chapter{Dangling references}
+\section{shell variables}
+\begin{verbatim}
+ALDORROOT
+\end{verbatim}
+
+\section{throw tags}
+\begin{verbatim}
+\end{verbatim}
+
+\section{defined special variables}
+\begin{verbatim}
+$syscommands
+|$systemCommands|
+\end{verbatim}
+
+\section{undefined special variables}
+\begin{verbatim}
+|$asharpCmdlineFlags|
+|$compileOnlyCertainItems|=20
+$current-directory
+/editfile=20
+|$f|=20
+|$InteractiveMode|=20
+|$m|=20
+|$ncConverse|=20
+|$newcompMode|=20
+|$newComp|=20
+|$newConlist|
+|$options|
+|$QuickCode|=20
+|$QuickLet|=20
+|$scanIfTrue|=20
+|$sourceFileTypes|=20
+\end{verbatim}
+
+\section{functions}
+\begin{verbatim}
+|browserAutoloadOnceTrigger|
+|compilerDoit|
+|compilerDoitWithScreenedLisplib|
+|convertSpadToAsFile|
+directory
+|directoryp|
+|error|
+|extendLocalLibdb|
+|fnameMake|
+|fnameReadable?|
+getenv
+|namestring|
+nequal
+obey
+|object2Identifier|
+|object2String|
+|oldParserAutoloadOnceTrigger|
+|pathname|
+|pathnameDirectory|
+|pathnameName|
+|pathnameType|
+recompile-lib-file-if-necessary
+|sayKeyedMsg|
+|spadPrompt|
+|spad2AsTranslatorAutoloadOnceTrigger|
+strconc
+strpos
+|throwKeyedMsg|
+|terminateSystemCommand|
+|updateSourceFiles|
+\end{verbatim}
+
 \chapter{The Compiler}
 <<Compiler>>=3D
 (in-package "BOOT")
=20
+<<defun compileAsharpArchiveCmd>>
+<<defun compileAsharpCmd>>
+<<defun compileAsharpCmd1>>
+<<defun compileAsharpLispCmd>>
+<<defun compileFileQuietly>>
 <<defun compileSpad2Cmd>>
+<<defun compileSpadLispCmd>>
=20
+<<defun withAsharpCmd>>
 @
 \eject
 \begin{thebibliography}{99}
diff --git a/changelog b/changelog
index d2c57aa..96cdc7f 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,9 @@
+20090329 tpd src/axiom-website/patches.html 20090329.01.tpd.patch
+20090329 tpd src/input/unittest2.input unit test special variables
+20090329 tpd src/interp/comp.lisp move compiler code to bookvol9
+20090329 tpd src/input/Makefile add unittest2 for specials
+20090329 tpd books/bookvol9 add more compiler code
+20090329 tpd books/bookvol5 move compiler, validate specials
 20090327 tpd src/axiom-website/patches.html 20090327.01.tpd.patch
 20090327 tpd src/interp/util.lisp stop autoloading compiler root
 20090327 tpd src/interp/Makefile build bookvol9
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.h=
tml
index 4ec4d96..50c455b 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -1030,5 +1030,7 @@ download.html add March 2009 column, add fedora10 b=
inary<br/>
 bookvol4 Finding Anonymous Function Signatures<br/>
 <a href=3D"patches/20090327.01.tpd.patch">20090327.01.tpd.patch</a>
 bookvol9 create compiler root<br/>
+<a href=3D"patches/20090329.01.tpd.patch">20090329.01.tpd.patch</a>
+bookvol9 add compiler code<br/>
  </body>
 </html>
diff --git a/src/input/Makefile.pamphlet b/src/input/Makefile.pamphlet
index 0e0d567..a506c77 100644
--- a/src/input/Makefile.pamphlet
+++ b/src/input/Makefile.pamphlet
@@ -380,7 +380,7 @@ REGRES=3D algaggr.regress algbrbf.regress  algfacob.r=
egress alist.regress  \
     textfile.regress  torus.regress \
     triglim.regress   tsetcatvermeer.regress            tutchap1.regress=
 \
     typetower.regress void.regress      uniseg.regress \
-    unittest1.regress
+    unittest1.regress unittest2.regress
=20
 IN=3D     ${SRC}/input
 MID=3D	${INT}/input
@@ -690,6 +690,7 @@ FILES=3D ${OUT}/algaggr.input  ${OUT}/algbrbf.input  =
  ${OUT}/algfacob.input \
        ${OUT}/tutchap4.input ${OUT}/tutchap67.input  ${OUT}/typetower.in=
put \
        ${OUT}/typo.input     \
        ${OUT}/uniseg.input   ${OUT}/up.input         ${OUT}/unittest1.in=
put \
+       ${OUT}/unittest2.input \
        ${OUT}/vector.input   ${OUT}/vectors.input    ${OUT}/viewdef.inpu=
t \
        ${OUT}/void.input     ${OUT}/wiggle.input   \
        ${OUT}/wutset.input \
diff --git a/src/input/unittest2.input.pamphlet b/src/input/unittest2.inp=
ut.pamphlet
new file mode 100644
index 0000000..647d105
--- /dev/null
+++ b/src/input/unittest2.input.pamphlet
@@ -0,0 +1,1510 @@
+\documentclass{article}
+\usepackage{axiom}
+\begin{document}
+\title{\$SPAD/src/input unittest2.input}
+\author{Timothy Daly}
+\maketitle
+\begin{abstract}
+Unit test the user level commands
+\end{abstract}
+\eject
+\tableofcontents
+\eject
+<<*>>=3D
+)set break resume
+)sys rm -f unittest2.output
+)spool unittest2.output
+)lisp (setq *print-circle* t)
+)set mes auto off
+)clear all
+
+--S 1 of 237
+)lisp (identity |$abbreviateTypes|)
+--R=20
+--RValue =3D NIL
+--E 1
+
+--S 2 of 237
+)lisp (identity |$algebraFormat|)
+--R=20
+--RValue =3D T
+--E 2
+
+--S 3 of 237
+)lisp (identity |$algebraOutputFile|)
+--R=20
+--RValue =3D "CONSOLE"
+--E 3
+
+--S 4 of 237
+)lisp (identity |$algebraOutputStream|)
+--R=20
+--RValue =3D #<synonym stream to *TERMINAL-IO*>
+--E 4
+
+--S 5 of 237
+)lisp (identity |$asharpCmdlineFlags|)
+--R=20
+--RValue =3D "-O -Fasy -Fao -Flsp -laxiom -Mno-AXL_W_WillObsolete -DAxio=
m -Y $AXIOM/algebra"
+--E 5
+
+--S 6 of 237
+)lisp (identity |$BreakMode|)
+--R=20
+--RValue =3D |resume|
+--E 6
+
+--S 7 of 237
+)lisp (identity |$clearExcept|)
+--R=20
+--R=20
+--R   >> System error:
+--R   The variable |$clearExcept| is unbound.
+--R
+--R   Continuing to read the file...
+--R
+--E 7
+
+--S 8 of 237
+)lisp (identity |$clearOptions|)
+--R=20
+--RValue =3D (|modes| |operations| |properties| |types| |values|)
+--E 8
+
+--S 9 of 237
+)lisp (identity |$CommandSynonymAlist|)
+--R=20
+--RValue =3D ((? . "what commands") (|ap| . "what things") (|apr| . "wha=
t things") (|apropos| . "what things") (|cache| . "set ffunctions cache")=
 (|cl| . "clear") (|cls| . "zsystemdevelopment )cls") (|cms| . "system") =
(|co| . "compiler") (|d| . "display") (|dep| . "display dependents") (|de=
pendents| . "display dependents") (|e| . "edit") (|expose| . "set expose =
add constructor") (|fc| . "zsystemdevelopment )c") (|fd| . "zsystemdevelo=
pment )d") (|fdt| . "zsystemdevelopment )dt") (|fct| . "zsystemdevelopmen=
t )ct") (|fctl| . "zsystemdevelopment )ctl") (|fe| . "zsystemdevelopment =
)e") (|fec| . "zsystemdevelopment )ec") (|fect| . "zsystemdevelopment )ec=
t") (|fns| . "exec spadfn") (|fortran| . "set output fortran") (|h| . "he=
lp") (|hd| . "system hypertex &") (|kclam| . "boot clearClams ( )") (|kil=
lcaches| . "boot clearConstructorAndLisplibCaches ( )") (|patch| . "zsyst=
emdevelopment )patch") (|pause| . "zsystemdevelopment )pause") (|prompt| =
. "set message prompt") (|recurrence| . "set functions recurrence") (|res=
tore| . "history )restore") (|save| . "history )save") (|startGraphics| .=
 "system $AXIOM/lib/viewman &") (|startNAGLink| . "system $AXIOM/lib/nagm=
an &") (|stopGraphics| . "lisp (|sockSendSignal| 2 15)") (|stopNAGLink| .=
 "lisp (|sockSendSignal| 8 15)") (|time| . "set message time") (|type| . =
"set message type") (|unexpose| . "set expose drop constructor") (|up| . =
"zsystemdevelopment )update") (|version| . "lisp *yearweek*") (|w| . "wha=
t") (|wc| . "what categories") (|wd| . "what domains") (|who| . "lisp (pp=
rint credits)") (|wp| . "what packages") (|ws| . "what synonyms"))
+--E 9
+
+--S 10 of 237
+)lisp (identity |$compileDontDefineFunctions|)
+--R=20
+--RValue =3D T
+--E 10
+
+--S 11 of 237
+)lisp (identity |$compileRecurrence|)
+--R=20
+--RValue =3D T
+--E 11
+
+--S 12 of 237
+)lisp (identity compiler::*compile-verbose*)
+--R=20
+--RValue =3D NIL
+--E 12
+
+--S 13 of 237
+)lisp (identity credits)
+--R=20
+--RValue =3D ("An alphabetical listing of contributors to AXIOM:" "Cyril=
 Alberga          Roy Adler              Christian Aistlleitner" "Richard=
 Anderson       George Andrews         S.J. Atkins" "Henry Baker         =
   Stephen Balzac         Yurij Baransky" "David R. Barton        Gerald =
Baumgartner     Gilbert Baumslag" "Jay Belanger           David Bindel   =
        Fred Blair" "Vladimir Bondarenko    Mark Botch" "Alexandre Bouyer=
       Peter A. Broadbery     Martin Brock" "Manuel Bronstein       Steph=
en Buchwald       Florian Bundschuh" "Luanne Burns           William Burg=
e" "Quentin Carpent        Robert Caviness        Bruce Char" "Ondrej Cer=
tik          Cheekai Chin           David V. Chudnovsky" "Gregory V. Chud=
novsky  Josh Cohen             Christophe Conil" "Don Coppersmith        =
George Corliss         Robert Corless" "Gary Cornell           Meino Cram=
er           Claire Di Crescenzo" "David Cyganski" "Timothy Daly Sr.     =
  Timothy Daly Jr.       James H. Davenport" "Didier Deshommes       Mich=
ael Dewar" "Jean Della Dora        Gabriel Dos Reis       Claire DiCresce=
ndo" "Sam Dooley             Lionel Ducos           Martin Dunstan" "Bria=
n Dupee            Dominique Duval" "Robert Edwards         Heow Eide-Goo=
dman      Lars Erickson" "Richard Fateman        Bertfried Fauser       S=
tuart Feldman" "Brian Ford             Albrecht Fortenbacher  George Fran=
ces" "Constantine Frangos    Timothy Freeman        Korrinn Fu" "Marc Gae=
tano           Rudiger Gebauer        Kathy Gerber" "Patricia Gianni     =
   Samantha Goldrich      Holger Gollan" "Teresa Gomez-Diaz      Laureano=
 Gonzalez-Vega Stephen Gortler" "Johannes Grabmeier     Matt Grayson     =
      Klaus Ebbe Grue" "James Griesmer         Vladimir Grinberg      Osw=
ald Gschnitzer" "Jocelyn Guidry" "Steve Hague            Satoshi Hamaguch=
i      Mike Hansen" "Richard Harke          Vilya Harvey           Martin=
 Hassner" "Arthur S. Hathaway     Dan Hatton             Waldek Hebisch" =
"Karl Hegbloom          Ralf Hemmecke          Henderson" "Antoine Hers!
en         Gernot Hueber" "Pietro Iglio" "Alejandro Jakubi       Richard =
Jenks" "Kai Kaminski           Grant Keady            Tony Kennedy" "Paul=
 Kosinski          Klaus Kusche           Bernhard Kutzler" "Tim Lahey   =
           Larry Lambe            Franz Lehner" "Frederic Lehobey       M=
ichel Levaud          Howard Levy" "Liu Xiaojun            Rudiger Loos  =
         Michael Lucks" "Richard Luczak" "Camm Maguire           Francois=
 Maltey        Alasdair McAndrew" "Bob McElrath           Michael McGettr=
ick     Ian Meikle" "David Mentre           Victor S. Miller       Gerard=
 Milmeister" "Mohammed Mobarak       H. Michael Moeller     Michael Monag=
an" "Marc Moreno-Maza       Scott Morrison         Joel Moses" "Mark Murr=
ay" "William Naylor         C. Andrew Neff         John Nelder" "Godfrey =
Nolan          Arthur Norman          Jinzhong Niu" "Michael O'Connor    =
   Summat Oemrawsingh     Kostas Oikonomou" "Humberto Ortiz-Zuazaga" "Jul=
ian A. Padget       Bill Page              Susan Pelzel" "Michel Petitot =
        Didier Pinchon         Ayal Pinkus" "Jose Alfredo Portes" "Claude=
 Quitte" "Arthur C. Ralfs        Norman Ramsey          Anatoly Raportire=
nko" "Michael Richardson     Renaud Rioboo          Jean Rivlin" "Nicolas=
 Robidoux       Simon Robinson         Raymond Rogers" "Michael Rothstein=
      Martin Rubey" "Philip Santas          Alfred Scheerhorn      Willia=
m Schelter" "Gerhard Schneider      Martin Schoenert       Marshall Schor=
" "Frithjof Schulze       Fritz Schwarz          Nick Simicich" "William =
Sit            Elena Smirnova         Jonathan Steinbach" "Fabio Stumbo  =
         Christine Sundaresan   Robert Sutor" "Moss E. Sweedler       Eug=
ene Surowitz" "Max Tegmark            James Thatcher         Balbir Thoma=
s" "Mike Thomas            Dylan Thurston         Barry Trager" "Themos T=
. Tsikas" "Gregory Vanuxem" "Bernhard Wall          Stephen Watt         =
  Jaap Weel" "Juergen Weiss          M. Weller              Mark Wegman" =
"James Wen              Thorsten Werther       Michael Wester" "John!
 M. Wiley          Berhard Will           Clifton J. Williamson" "Stephen=
 Wilson         Shmuel Winograd        Robert Wisbauer" "Sandra Wityak   =
       Waldemar Wiwianka      Knut Wolf" "Clifford Yapp          David Yu=
n" "Vadim Zhytnikov        Richard Zippel         Evelyn Zoernack" "Bruno=
 Zuercher         Dan Zwillinger")
+--E 13
+
+--S 14 of 237
+)lisp (identity |$defaultFortranType|)
+--R=20
+--RValue =3D REAL
+--E 14
+
+--S 15 of 237
+)lisp (identity *default-pathname-defaults*)
+--R=20
+--IValue =3D #p"/tmp/"
+--E 15
+
+--S 16 of 237
+)lisp (identity |$defaultSpecialCharacters|)
+--R=20
+--RValue =3D (#\^\ #\^[ #\^^ #\^_ #\O #\- #\\220 #\\255 #\\275 #\\300 #\=
\320 #\; #\> #\? #\=3D #\, #\\340)
+--E 16
+
+--S 17 of 237
+)lisp (identity |$displayDroppedMap|)
+--R=20
+--RValue =3D NIL
+--E 17
+
+--S 18 of 237
+)lisp (identity |$displayMsgNumber|)
+--R=20
+--RValue =3D NIL
+--E 18
+
+--S 19 of 237
+)lisp (identity |$displayOptions| )
+--R=20
+--RValue =3D (|abbreviations| |all| |macros| |modes| |names| |operations=
| |properties| |types| |values|)
+--E 19
+
+--S 20 of 237
+)lisp (identity |$displaySetValue|)
+--R=20
+--RValue =3D NIL
+--E 20
+
+--S 21 of 237
+)lisp (identity |$displayStartMsgs|)
+--R=20
+--RValue =3D T
+--E 21
+
+--S 22 of 237
+)lisp (identity |$formulaFormat|)
+--R=20
+--RValue =3D NIL
+--E 22
+
+--S 23 of 237
+)lisp (identity |$formulaOutputFile|)
+--R=20
+--RValue =3D "CONSOLE"
+--E 23
+
+--S 24 of 237
+)lisp (identity |$fortIndent|)
+--R=20
+--RValue =3D 6
+--E 24
+
+--S 25 of 237
+)lisp (identity |$fortInts2Floats|)
+--R=20
+--RValue =3D T
+--E 25
+
+--S 26 of 237
+)lisp (identity |$fortLength|)
+--R=20
+--RValue =3D 72
+--E 26
+
+--S 27 of 237
+)lisp (identity |$fortranArrayStartingIndex|)
+--R=20
+--RValue =3D 1
+--E 27
+
+--S 28 of 237
+)lisp (identity |$fortranDirectory|)
+--R=20
+--RValue =3D "./"
+--E 28
+
+--S 29 of 237
+)lisp (identity |$fortranFormat|)
+--R=20
+--RValue =3D NIL
+--E 29
+
+--S 30 of 237
+)lisp (identity |$fortranLibraries|)
+--R=20
+--RValue =3D "-lxlf"
+--E 30
+
+--S 31 of 237
+)lisp (identity |$fortranOptimizationLevel|)
+--R=20
+--RValue =3D 0
+--E 31
+
+--S 32 of 237
+)lisp (identity |$fortranOutputFile|)
+--R=20
+--RValue =3D "CONSOLE"
+--E 32
+
+--S 33 of 237
+)lisp (identity |$fortranPrecision|)
+--R=20
+--RValue =3D |double|
+--E 33
+
+--S 34 of 237
+)lisp (identity |$fortranSegment|)
+--R=20
+--RValue =3D T
+--E 34
+
+--S 35 of 237
+)lisp (identity |$fortranTmpDir|)
+--R=20
+--RValue =3D "/tmp/"
+--E 35
+
+--S 36 of 237
+)lisp (identity |$fortPersistence|)
+--R=20
+--RValue =3D 1
+--E 36
+
+--S 37 of 237
+)lisp (identity |$fractionDisplayType|)
+--R=20
+--RValue =3D |vertical|
+--E 37
+
+--S 38 of 237
+)lisp (identity |$frameMessages|)
+--R=20
+--RValue =3D NIL
+--E 38
+
+--S 39 of 237
+)lisp (identity |$fullScreenSysVars|)
+--R=20
+--RValue =3D NIL
+--E 39
+
+--S 40 of 237
+)lisp (identity |$giveExposureWarning|)
+--R=20
+--RValue =3D NIL
+--E 40
+
+--S 41 of 237
+)lisp (identity |$HiFiAccess|)
+--R=20
+--RValue =3D T
+--E 41
+
+--S 42 of 237
+)lisp (identity |$highlightAllowed|)
+--R=20
+--RValue =3D NIL
+--E 42
+
+--S 43 of 237
+)lisp (identity |$historyDirectory|)
+--R=20
+--RValue =3D A
+--E 43
+
+--S 44 of 237
+)lisp (identity |$historyDisplayWidth|)
+--R=20
+--RValue =3D 120
+--E 44
+
+--S 45 of 237
+)lisp (identity |$historyFileType|)
+--R=20
+--RValue =3D |axh|
+--E 45
+
+--S 46 of 237
+)lisp (identity |$InitialCommandSynonymAlist|)
+--R=20
+--RValue =3D ((? . "what commands") (|ap| . "what things") (|apr| . "wha=
t things") (|apropos| . "what things") (|cache| . "set ffunctions cache")=
 (|cl| . "clear") (|cls| . "zsystemdevelopment )cls") (|cms| . "system") =
(|co| . "compiler") (|d| . "display") (|dep| . "display dependents") (|de=
pendents| . "display dependents") (|e| . "edit") (|expose| . "set expose =
add constructor") (|fc| . "zsystemdevelopment )c") (|fd| . "zsystemdevelo=
pment )d") (|fdt| . "zsystemdevelopment )dt") (|fct| . "zsystemdevelopmen=
t )ct") (|fctl| . "zsystemdevelopment )ctl") (|fe| . "zsystemdevelopment =
)e") (|fec| . "zsystemdevelopment )ec") (|fect| . "zsystemdevelopment )ec=
t") (|fns| . "exec spadfn") (|fortran| . "set output fortran") (|h| . "he=
lp") (|hd| . "system hypertex &") (|kclam| . "boot clearClams ( )") (|kil=
lcaches| . "boot clearConstructorAndLisplibCaches ( )") (|patch| . "zsyst=
emdevelopment )patch") (|pause| . "zsystemdevelopment )pause") (|prompt| =
. "set message prompt") (|recurrence| . "set functions recurrence") (|res=
tore| . "history )restore") (|save| . "history )save") (|startGraphics| .=
 "system $AXIOM/lib/viewman &") (|startNAGLink| . "system $AXIOM/lib/nagm=
an &") (|stopGraphics| . "lisp (|sockSendSignal| 2 15)") (|stopNAGLink| .=
 "lisp (|sockSendSignal| 8 15)") (|time| . "set message time") (|type| . =
"set message type") (|unexpose| . "set expose drop constructor") (|up| . =
"zsystemdevelopment )update") (|version| . "lisp *yearweek*") (|w| . "wha=
t") (|wc| . "what categories") (|wd| . "what domains") (|who| . "lisp (pp=
rint credits)") (|wp| . "what packages") (|ws| . "what synonyms"))
+--E 46
+
+--S 47 of 237
+)lisp (identity |$inputPromptType|)
+--R=20
+--RValue =3D |step|
+--E 47
+
+--S 48 of 237
+)lisp (identity |$linearFormatScripts|)
+--R=20
+--RValue =3D NIL
+--E 48
+
+--S 49 of 237
+)lisp (identity $linelength)
+--R=20
+--RValue =3D 77
+--E 49
+
+--S 50 of 237
+)lisp (identity |$mapSubNameAlist|)
+--R=20
+--RValue =3D NIL
+--E 50
+
+--S 51 of 237
+)lisp (identity |$mathmlFormat|)
+--R=20
+--RValue =3D NIL
+--E 51
+
+--S 52 of 237
+)lisp (identity |$mathmlOutputFile|)
+--R=20
+--RValue =3D "CONSOLE"
+--E 52
+
+--S 53 of 237
+)lisp (identity |$maximumFortranExpressionLength|)
+--R=20
+--RValue =3D 1320
+--E 53
+
+--S 54 of 237
+)lisp (identity |$nagEnforceDouble|)
+--R=20
+--RValue =3D T
+--E 54
+
+--S 55 of 237
+)lisp (identity |$nagHost|)
+--R=20
+--RValue =3D "localhost"
+--E 55
+
+--S 56 of 237
+)lisp (identity |$nagMessages|)
+--R=20
+--RValue =3D T
+--E 56
+
+--S 57 of 237
+)lisp (identity |$noParseCommands| )
+--R=20
+--RValue =3D (|boot| |copyright| |credits| |fin| |lisp| |pquit| |quit| |=
synonym| |system|)
+--E 57
+
+--S 58 of 237
+)lisp (identity |$oldHistoryFileName|)
+--R=20
+--RValue =3D |last|
+--E 58
+
+--S 59 of 237
+)lisp (identity |$openMathFormat|)
+--R=20
+--RValue =3D NIL
+--E 59
+
+--S 60 of 237
+)lisp (identity |$openMathOutputFile|)
+--R=20
+--RValue =3D "CONSOLE"
+--E 60
+
+--S 61 of 237
+)lisp (identity $openServerIfTrue)
+--R=20
+--RValue =3D T
+--E 61
+
+--S 62 of 237
+)lisp (identity |$optionAlist|)
+--R=20
+--RValue =3D NIL
+--E 62
+
+--S 63 of 237
+)lisp (identity |$options|)
+--R=20
+--RValue =3D NIL
+--E 63
+
+--S 64 of 237
+)lisp (identity |$plainRTspecialCharacters|)
+--R=20
+--RValue =3D (+ + + + |\|| - ? [ ] { } + + + + + |\\|)
+--E 64
+
+--S 65 of 237
+)lisp (identity |$plainSpecialCharacters0|)
+--R=20
+--RValue =3D (#\N #\N #\N #\N #\O #\` #\o #\\255 #\\275 #\\300 #\\320 #\=
N #\N #\N #\N #\N #\\340)
+--E 65
+
+--S 66 of 237
+)lisp (identity |$plainSpecialCharacters1|)
+--R=20
+--RValue =3D (#\k #\k #\} #\} #\O #\` #\o #\\255 #\\275 #\\300 #\\320 #\=
N #\N #\N #\N #\N #\\340)
+--E 66
+
+--S 67 of 237
+)lisp (identity |$plainSpecialCharacters2|)
+--R=20
+--RValue =3D (#\O #\O #\O #\O #\O #\` #\o #\\255 #\\275 #\\300 #\\320 #\=
N #\N #\N #\N #\N #\\340)
+--E 67
+
+--S 68 of 237
+)lisp (identity |$plainSpecialCharacters3|)
+--R=20
+--RValue =3D (#\` #\` #\` #\` #\O #\` #\o #\\255 #\\275 #\\300 #\\320 #\=
N #\N #\N #\N #\N #\\340)
+--E 68
+
+--S 69 of 237
+)lisp (identity $prettyprint)
+--R=20
+--RValue =3D T
+--E 69
+
+--S 70 of 237
+)lisp (identity |$printAnyIfTrue|)
+--R=20
+--RValue =3D T
+--E 70
+
+--S 71 of 237
+)lisp (identity |$printFortranDecs|)
+--R=20
+--RValue =3D T
+--E 71
+
+--S 72 of 237
+)lisp (identity |$printLoadMsgs|)
+--R=20
+--RValue =3D NIL
+--E 72
+
+--S 73 of 237
+)lisp (identity |$printMsgsToFile|)
+--R=20
+--RValue =3D NIL
+--E 73
+
+--S 74 of 237
+)lisp (identity |$printStatisticsSummaryIfTrue|)
+--R=20
+--RValue =3D NIL
+--E 74
+
+--S 75 of 237
+)lisp (identity |$printTimeIfTrue|)
+--R=20
+--RValue =3D NIL
+--E 75
+
+--S 76 of 237
+)lisp (identity |$printTypeIfTrue|)
+--R=20
+--RValue =3D T
+--E 76
+
+--S 77 of 237
+)lisp (identity |$printVoidIfTrue|)
+--R=20
+--RValue =3D NIL
+--E 77
+
+--S 78 of 237
+)lisp (identity |$quitCommandType|)
+--R=20
+--RValue =3D |protected|
+--E 78
+
+--S 79 of 237
+)lisp (identity |$reportBottomUpFlag|)
+--R=20
+--RValue =3D NIL
+--E 79
+
+--S 80 of 237
+)lisp (identity |$reportCoerceIfTrue|)
+--R=20
+--RValue =3D NIL
+--E 80
+
+--S 81 of 237
+)lisp (identity |$reportCompilation|)
+--R=20
+--RValue =3D NIL
+--E 81
+
+--S 82 of 237
+)lisp (identity |$reportEachInstantiation|)
+--R=20
+--RValue =3D NIL
+--E 82
+
+--S 83 of 237
+)lisp (identity |$reportInstantiations|)
+--R=20
+--RValue =3D NIL
+--E 83
+
+--S 84 of 237
+)lisp (identity |$reportInterpOnly|)
+--R=20
+--RValue =3D T
+--E 84
+
+--S 85 of 237
+)lisp (identity |$reportOptimization|)
+--R=20
+--RValue =3D NIL
+--E 85
+
+--S 86 of 237
+)lisp (identity |$reportSpadTrace|)
+--R=20
+--RValue =3D NIL
+--E 86
+
+--S 87 of 237
+)lisp (identity |$RTspecialCharacters|)
+--R=20
+--IValue =3D (=DA =BF =C0 =D9 =B3 =C4 "=1D=E2" [ ] { } =C2 =C1 =B4 =C3 =C5=
 |\\|)
+--E 87
+
+--S 88 of 237
+)lisp (identity *standard-input*)
+--R=20
+--RValue =3D #<synonym stream to *TERMINAL-IO*>
+--E 88
+
+--S 89 of 237
+)lisp (identity *standard-output*)
+--R=20
+--RValue =3D #<synonym stream to *TERMINAL-IO*>
+--E 89
+
+--S 90 of 237
+)lisp (identity |$SpadServer|)
+--R=20
+--RValue =3D NIL
+--E 90
+
+--S 91 of 237
+)lisp (identity $SpadServerName)
+--R=20
+--RValue =3D "/tmp/.d"
+--E 91
+
+--S 92 of 237
+)lisp (identity |$specialCharacterAlist| )
+--R=20
+--RValue =3D ((|ulc| . 0) (|urc| . 1) (|llc| . 2) (|lrc| . 3) (|vbar| . =
4) (|hbar| . 5) (|quad| . 6) (|lbrk| . 7) (|rbrk| . 8) ((|lbrc| . 9) (|rb=
rc| . 10) (|ttee| . 11) (|btee| . 12) (|rtee| . 13) (|ltee| . 14) (|ctee|=
 . 15) (|bslash| . 16))
+--E 92
+
+--S 93 of 237
+)lisp (identity |$specialCharacters|)
+--R=20
+--RValue =3D (+ + + + |\|| - ? [ ] { } + + + + + |\\|)
+--E 93
+
+--S 94 of 237
+)lisp (identity |$streamCount|)
+--R=20
+--RValue =3D 10
+--E 94
+
+--S 95 of 237
+)lisp (identity |$streamsShowAll|)
+--R=20
+--RValue =3D NIL
+--E 95
+
+--S 96 of 237
+)lisp (identity compiler::*suppress-compiler-notes*)
+--R=20
+--RValue =3D T
+--E 96
+
+--S 97 of 237
+)lisp (identity compiler::*suppress-compiler-warnings*)
+--R=20
+--RValue =3D T
+--E 97
+
+--S 98 of 237
+)lisp (identity |$systemCommandFunction|)
+--R=20
+--RValue =3D #<compiled-function |InterpExecuteSpadSystemCommand|>
+--E 98
+
+--S 99 of 237
+)lisp (identity $syscommands)
+--R=20
+--RValue =3D (|abbreviations| |boot| |browse| |cd| |clear| |close| |comp=
iler| |copyright| |credits| |display| |edit| |fin| |framme| |help| |histo=
ry| |lisp| |library| |load| |ltrace| |pquit| |quit| |read| |savesystem| |=
set| |show| |spool| |summary| |synonym| |system| |trace| |undo| |what| |w=
ith| |workfiles| |zsystemdevelopment|)
+--E 99
+
+--S 100 of 237
+)lisp (identity |$systemCommands|)
+--R=20
+--RValue =3D ((|abbreviations| . |compiler|) (|boot| . |development|) (|=
browse| . |development|) (|cd| . |interpreter|) (|clear|| . |interpreter|=
) (|close| . |interpreter|) (|compiler| . |compiler|) (|copyright| . |int=
erpreter|) (|credits| . |interpreter|) (|display| . |interpreter|) (|edit=
| . |interpreter|) (|fin| . |development|) (|frame| . |interpreter|) (|he=
lp| . |interpreter|) (|history| . |interpreter|) (|lisp| . |development|)=
 (|library| . |interpreter|) (|load| . |interpreter|) (|ltrace| . |interp=
reter|) (|pquit| . |interpreter|) (|quit| . |interpreter|) (|read| . |int=
erpreter|) (|savesystem| . |interpreter|) (|set| . |interpreter|) (|show|=
 . |interpreter|) (|spool| . |interpreter|) (|summary| . |interpreter|) (=
|synonym| . |interpreter|) (|system| . |interpreter|) (|trace| . |interpr=
eter|) (|undo| . |interpreter|) (|what| . |interpreter|) (|with| . |inter=
preter|) (|workfiles| . |development|) (|zsystemdevelopment| . |interpret=
er|))
+--E 100
+
+--S 101 of 237
+)lisp (identity *terminal-io*)
+--R=20
+--IValue =3D #<two-way stream 090631d4>
+--E 101
+
+--S 102 of 237
+)lisp (identity |$testingSystem|)
+--R=20
+--RValue =3D NIL
+--E 102
+
+--S 103 of 237
+)lisp (identity |$texFormat|)
+--R=20
+--RValue =3D NIL
+--E 103
+
+--S 104 of 237
+)lisp (identity |$texOutputFile|)
+--R=20
+--RValue =3D "CONSOLE"
+--E 104
+
+--S 105 of 237
+)lisp (identity |$tokenCommands|)
+--R=20
+--RValue =3D (|abbreviations| |cd| |clear| |close| |compiler| |depends| =
|display| |edit| |frame| |frame| |help| |history| |inputt| |library| |loa=
d| |ltrace| |read| |savesystem| |set| |spool| |undo| |what| |with| |workf=
iles| |zsystemdevelopment|)
+--E 105
+
+--S 106 of 237
+)lisp (identity system::*top-level-hook*)
+--R=20
+--RValue =3D RESTART
+--E 106
+
+--S 107 of 237
+)lisp (identity |$tracedMapSignatures|)
+--R=20
+--RValue =3D NIL
+--E 107
+
+--S 108 of 237
+)lisp (identity |$traceNoisely|)
+--R=20
+--RValue =3D NIL
+--E 108
+
+--S 109 of 237
+)lisp (identity |$traceOptionList|)
+--R=20
+--RValue =3D (|after| |before| |break| |cond| |count| |depth| |local| |m=
athprint| |nonquietly| |nt| |of| |only| |ops| |restore|  |timer| |varbrea=
k| |vars| |within|)
+--E 109
+
+--S 110 of 237
+)lisp (identity underbar)
+--R=20
+--RValue =3D "_"
+--E 110
+
+--S 111 of 237
+)lisp (identity |$useEditorForShowOutput|)
+--R=20
+--RValue =3D NIL
+--E 111
+
+--S 112 of 237
+)lisp (identity |$useFullScreenHelp|)
+--R=20
+--RValue =3D NIL
+--E 112
+
+--S 113 of 237
+)lisp (identity |$useInternalHistoryTable|)
+--R=20
+--RValue =3D T
+--E 113
+
+--S 114 of 237
+)lisp (identity |$useIntrinsicFunctions|)
+--R=20
+--RValue =3D NIL
+--E 114
+
+--S 115 of 237
+)lisp (identity |$UserLevel|)
+--R=20
+--RValue =3D |development|
+--E 115
+
+--S 116 of 237
+)lisp (identity |$whatOptions|)
+--R=20
+--RValue =3D (|operations| |categories| |domains| |packages| |commands| =
|synonyms| |things|)
+--E 116
+
+
+
+
+
+--S 117 of 237
+)lisp (identity |$attributeDb|)
+--R=20
+--RValue =3D NIL
+--E 117
+
+--S 118 of 237
+)lisp (identity $boot)
+--R=20
+--RValue =3D NIL
+--E 118
+
+--S 119 of 237
+)lisp (identity |$cacheAlist|)
+--R=20
+--RValue =3D NIL
+--E 119
+
+--S 120 of 237
+)lisp (identity |$cacheCount| )
+--R=20
+--RValue =3D 0
+--E 120
+
+--S 121 of 237
+)lisp (identity |$CatOfCatDatabase|)
+--R=20
+--RValue =3D NIL
+--E 121
+
+--S 122 of 237
+)lisp (identity |$CloseClient|)
+--R=20
+--RValue =3D 10
+--E 122
+
+--S 123 of 237
+)lisp (identity |$coerceIntByMapCounter|)
+--R=20
+--RValue =3D 0
+--E 123
+
+--S 124 of 237
+)lisp (identity |$compileMapFlag|)
+--R=20
+--RValue =3D NIL
+--E 124
+
+--S 125 of 237
+)lisp (identity |$ConstructorCache|)
+--R=20
+--IValue =3D #<hash-table 08a68f18>
+--E 125
+
+--S 126 of 237
+)lisp (identity |$constructors|)
+--R=20
+--R=20
+--R   >> System error:
+--R   The variable |$constructors| is unbound.
+--R
+--R   Continuing to read the file...
+--R
+--E 126
+
+--S 127 of 237
+)lisp (identity /countlist)
+--R=20
+--RValue =3D NIL
+--E 127
+
+--S 128 of 237
+)lisp (identity $current-directory)
+--R=20
+--IValue =3D "/tmp/"
+--E 128
+
+--S 129 of 237
+)lisp (identity |$currentFrameNum|)
+--R=20
+--RValue =3D 0
+--E 129
+
+--S 130 of 237
+)lisp (identity |$currentLine|)
+--R=20
+--RValue =3D ")lisp (identity |$currentLine|)"
+--E 130
+
+--S 131 of 237
+)lisp (identity $dalymode)
+--R=20
+--RValue =3D NIL
+--E 131
+
+--S 132 of 237
+)lisp (identity |$defaultMsgDatabaseName|)
+--R=20
+--IValue =3D #p"/research/reference/mnt/ubuntu/doc/msgs/s2-us.msgs"
+--E 132
+
+--S 133 of 237
+)lisp (identity |$dependeeClosureAlist|)
+--R=20
+--RValue =3D NIL
+--E 133
+
+--S 134 of 237
+)lisp (identity $directory-list)
+--R=20
+--IValue =3D ("/research/reference/mnt/ubuntu/../../src/input/" "/resear=
ch/reference/mnt/ubuntu/doc/msgs/" "/research/reference//mnt/ubuntu/../..=
/src/algebra/" "/research/reference/mnt/ubuntu/../../src/interp/" "/resea=
rch/reference/mnt/ubuntu/doc/spadhelp/")
+--E 134
+
+--S 135 of 237
+)lisp (identity |$displayStartMsgs| )
+--R=20
+--RValue =3D T
+--E 135
+
+--S 136 of 237
+)lisp (identity |$domains|)
+--R=20
+--R=20
+--R   >> System error:
+--R   The variable |$domains| is unbound.
+--R
+--R   Continuing to read the file...
+--R
+--E 136
+
+--S 137 of 237
+)lisp (identity |$DomOfCatDatabase|)
+--R=20
+--RValue =3D NIL
+--E 137
+
+--S 138 of 237
+)lisp (identity |$domainTraceNameAssoc|)
+--R=20
+--RValue =3D NIL
+--E 138
+
+--S 139 of 237
+)lisp (identity |$doNotAddEmptyModeIfTrue|)
+--R=20
+--R=20
+--R   >> System error:
+--R   The variable |$doNotAddEmptyModeIfTrue| is unbound.
+--R
+--R   Continuing to read the file...
+--R
+--E 139
+
+--S 140 of 237
+)lisp (identity |$e|)
+--R=20
+--RValue =3D ((((|Category| (|modemap| (((|Category|) (|Category|)) (T *=
)))) (|Join| (|modemap| (((|Category|) (|Category|) (|Caategory|) (|Categ=
ory|)) (T *)) (((|Category|) (|Category|) (|List| (|Category|)) (|Categor=
y|)) (T *)))))))
+--E 140
+
+--S 141 of 237
+)lisp (identity |$echoLineStack|)
+--R=20
+--RValue =3D NIL
+--E 141
+
+--S 142 of 237
+)lisp (identity /editfile)
+--R=20
+--IValue =3D #p"/tmp/u.input"
+--E 142
+
+--S 143 of 237
+)lisp (identity |$EmptyEnvironment|)
+--R=20
+--RValue =3D ((NIL))
+--E 143
+
+--S 144 of 237
+)lisp (identity |$env|)
+--R=20
+--RValue =3D ((NIL))
+--E 144
+
+--S 145 of 237
+)lisp (identity *eof*)
+--R=20
+--RValue =3D NIL
+--E 145
+
+--S 146 of 237
+)lisp (identity |$erMsgToss|)
+--R=20
+--RValue =3D NIL
+--E 146
+
+--S 147 of 237
+)lisp (identity |$existingFiles|)
+--R=20
+--IValue =3D #<hash-table 08c5b230>
+--E 147
+
+--S 148 of 237
+)lisp (identity |$fn|)
+--R=20
+--IValue =3D "/tmp/u.input"
+--E 148
+
+--S 149 of 237
+)lisp (identity |$formulaOutputStream|)
+--R=20
+--RValue =3D #<synonym stream to *TERMINAL-IO*>
+--E 149
+
+--S 150 of 237
+)lisp (identity |$fortranOutputStream|)
+--R=20
+--RValue =3D #<synonym stream to *TERMINAL-IO*>
+--E 150
+
+--S 151 of 237
+)lisp (identity |$frameMessages|)
+--R=20
+--RValue =3D NIL
+--E 151
+
+--S 152 of 237
+)lisp (identity |$frameRecord|)
+--R=20
+--RValue =3D NIL
+--E 152
+
+--S 153 of 237
+)lisp (identity |$fromSpadTrace|)
+--R=20
+--RValue =3D NIL
+--E 153
+
+--S 154 of 237
+)lisp (identity |$functionTable|)
+--R=20
+--RValue =3D NIL
+--E 154
+
+--S 155 of 237
+)lisp (identity |$globalExposureGroupAlist|)
+--R=20
+--RValue =3D ((|basic| (|AlgebraicManipulations| . ALGMANIP) (|Algebraic=
Number| . AN) (|AlgFactor| . ALGFACT) (|AlgebraicMultFacct| . ALGMFACT) (=
|AlgebraPackage| . ALGPKG) (|AlgebraGivenByStructuralConstants| . ALGSC) =
(|Any| . ANY) (|AnyFunctions1| . ANY1) (|ApplicationProgramInterface| . A=
PI) (|ArrayStack| . ASTACK) (|AssociatedJordanAlgebra| . JORDAN) (|Associ=
atedLieAlgebra| . LIE) (|AttachPredicates| . PMPRED) (|AxiomServer| . AXS=
ERV) (|BalancedBinaryTree| . BBTREE) (|BasicOperator| . BOP) (|BasicOpera=
torFunctions1| . BOP1) (|BinaryExpansion| . BINARY) (|BinaryFile| . BINFI=
LE) (|BinarySearchTree| . BSTREE) (|BinaryTournament| . BTOURN) (|BinaryT=
ree| . BTREE) (|Bits| . BITS) (|Boolean| . BOOLEAN) (|CardinalNumber| . C=
ARD) (|CartesianTensor| . CARTEN) (|CartesianTensorFunctions2| . CARTEN2)=
 (|Character| . CHAR) (|CharacterClass| . CCLASS) (|CharacteristicPolynom=
ialPackage| . CHARPOL) (|CliffordAlgebra| . CLIF) (|Color| . COLOR) (|Com=
monDenominator| . CDEN) (|Commutator| . COMM) (|Complex| . COMPLEX) (|Com=
plexFactorization| . COMPFACT) (|ComplexFunctions2| . COMPLEX2) (|Complex=
RootPackage| . CMPLXRT) (|ComplexTrigonometricManipulations| . CTRIGMNP) =
(|ContinuedFraction| . CONTFRAC) (|CoordinateSystems| . COORDSYS) (|CRApa=
ckage| . CRAPACK) (|CycleIndicators| . CYCLES) (|Database| . DBASE) (|Dat=
aList| . DLIST) (|DecimalExpansion| . DECIMAL) (|DenavitHartenbergMatrix|=
 . DHMATRIX) (|Dequeue| . DEQUEUE) (|DiophantineSolutionPackage| . DIOSP)=
 (|DirectProductFunctions2| . DIRPROD2) (|DisplayPackage| . DISPLAY) (|Di=
stinctDegreeFactorize| . DDFACT) (|DoubleFloat| . DFLOAT) (|DoubleFloatSp=
ecialFunctions| . DFSFUN) (|DrawComplex| . DRAWCX) (|DrawNumericHack| . D=
RAWHACK) (|DrawOption| . DROPT) (|EigenPackage| . EP) (|ElementaryFunctio=
nDefiniteIntegration| . DEFINTEF) (|ElementaryFunctionLODESolver| . LODEE=
F) (|ElementaryFunctionODESolver| . ODEEF) (|ElementaryFunctionSign| . SI=
GNEF) (|ElementaryFunctionStructurePackage| . EFSTRUC) (|Equation| . EQ) =
(|EquationFunctions2| . EQ2) (|ErrorFunctions| . ERROR) (|EuclideanGroe!
bnerBasisPackage| . GBEUCLID) (|Exit| . EXIT) (|Expression| . EXPR) (|Exp=
ressionFunctions2| . EXPR2) (|ExpressionSolve| . EXPRSOL) (|ExpressionSpa=
ceFunctions2| . ES2) (|ExpressionSpaceODESolver| . EXPRODE) (|ExpressionT=
oOpenMath| . OMEXPR) (|ExpressionToUnivariatePowerSeries| . EXPR2UPS) (|F=
actored| . FR) (|FactoredFunctions2| . FR2) (|File| . FILE) (|FileName| .=
 FNAME) (|FiniteAbelianMonoidRingFunctions2| . FAMR2) (|FiniteDivisorFunc=
tions2| . FDIV2) (|FiniteField| . FF) (|FiniteFieldCyclicGroup| . FFCG) (=
|FiniteFieldPolynomialPackage2| . FFPOLY2) (|FiniteFieldNormalBasis| . FF=
NB) (|FiniteFieldHomomorphisms| . FFHOM) (|FiniteLinearAggregateFunctions=
2| . FLAGG2) (|FiniteLinearAggregateSort| . FLASORT) (|FiniteSetAggregate=
Functions2| . FSAGG2) (|FlexibleArray| . FARRAY) (|Float| . FLOAT) (|Floa=
tingRealPackage| . FLOATRP) (|FloatingComplexPackage| . FLOATCP) (|Fourie=
rSeries| . FSERIES) (|Fraction| . FRAC) (|FractionalIdealFunctions2| . FR=
IDEAL2) (|FractionFreeFastGaussian| . FFFG) (|FractionFreeFastGaussianFra=
ctions| . FFFGF) (|FractionFunctions2| . FRAC2) (|FreeNilpotentLie| . FNL=
A) (|FullPartialFractionExpansion| . FPARFRAC) (|FunctionFieldCategoryFun=
ctions2| . FFCAT2) (|FunctionSpaceAssertions| . PMASSFS) (|FunctionSpaceA=
ttachPredicates| . PMPREDFS) (|FunctionSpaceComplexIntegration| . FSCINT)=
 (|FunctionSpaceFunctions2| . FS2) (|FunctionSpaceIntegration| . FSINT) (=
|FunctionSpacePrimitiveElement| . FSPRMELT) (|FunctionSpaceSum| . SUMFS) =
(|GaussianFactorizationPackage| . GAUSSFAC) (|GeneralUnivariatePowerSerie=
s| . GSERIES) (|GenerateUnivariatePowerSeries| . GENUPS) (|GraphicsDefaul=
ts| . GRDEF) (|GroebnerPackage| . GB) (|GroebnerFactorizationPackage| . G=
BF) (|Guess| . GUESS) (|GuessAlgebraicNumber| . GUESSAN) (|GuessFinite| .=
 GUESSF) (|GuessFiniteFunctions| . GUESSF1) (|GuessInteger| . GUESSINT) (=
|GuessOption| . GOPT) (|GuessOptionFunctions0| . GOPT0) (|GuessPolynomial=
| . GUESSP) (|GuessUnivariatePolynomial| . GUESSUP) (|HallBasis| . HB) (|=
Heap| . HEAP) (|HexadecimalExpansion| . HEXADEC) (|IndexCard| . ICAR!
D) (|IdealDecompositionPackage| . IDECOMP) (|InfiniteProductCharacteristi=
cZero| . INFPROD0) (|InfiniteProductFiniteField| . INPRODFF) (|InfinitePr=
oductPrimeField| . INPRODPF) (|InfiniteTuple| . ITUPLE) (|InfiniteTupleFu=
nctions2| . ITFUN2) (|InfiniteTupleFunctions3| . ITFUN3) (|Infinity| . IN=
FINITY) (|Integer| . INT) (|IntegerCombinatoricFunctions| . COMBINAT) (|I=
ntegerLinearDependence| . ZLINDEP) (|IntegerNumberTheoryFunctions| . INTH=
EORY) (|IntegerPrimesPackage| . PRIMES) (|IntegerRetractions| . INTRET) (=
|IntegerRoots| . IROOT) (|IntegrationResultFunctions2| . IR2) (|Integrati=
onResultRFToFunction| . IRRF2F) (|IntegrationResultToFunction| . IR2F) (|=
Interval| . INTRVL) (|InventorDataSink| . IVDATA) (|InventorViewPort| . I=
VVIEW) (|InventorRenderPackage| . IVREND) (|InverseLaplaceTransform| . IN=
VLAPLA) (|IrrRepSymNatPackage| . IRSN) (|KernelFunctions2| . KERNEL2) (|K=
eyedAccessFile| . KAFILE) (|LaplaceTransform| . LAPLACE) (|LazardMorenoSo=
lvingPackage| . LAZM3PK) (|Library| . LIB) (|LieSquareMatrix| . LSQM) (|L=
inearOrdinaryDifferentialOperator| . LODO) (|LinearSystemMatrixPackage| .=
 LSMP) (|LinearSystemMatrixPackage1| . LSMP1) (|LinearSystemPolynomialPac=
kage| . LSPP) (|List| . LIST) (|ListFunctions2| . LIST2) (|ListFunctions3=
| . LIST3) (|ListToMap| . LIST2MAP) (|MakeFloatCompiledFunction| . MKFLCF=
N) (|MakeFunction| . MKFUNC) (|MakeRecord| . MKRECORD) (|MappingPackage1|=
 . MAPPKG1) (|MappingPackage2| . MAPPKG2) (|MappingPackage3| . MAPPKG3) (=
|MappingPackage4| . MAPPKG4) (|MathMLFormat| . MMLFORM) (|Matrix| . MATRI=
X) (|MatrixCategoryFunctions2| . MATCAT2) (|MatrixCommonDenominator| . MC=
DEN) (|MatrixLinearAlgebraFunctions| . MATLIN) (|MergeThing| . MTHING) (|=
ModularDistinctDegreeFactorizer| . MDDFACT) (|ModuleOperator| . MODOP) (|=
MonoidRingFunctions2| . MRF2) (|MoreSystemCommands| . MSYSCMD) (|MPolyCat=
Functions2| . MPC2) (|MPolyCatRationalFunctionFactorizer| . MPRFF) (|Mult=
iset| . MSET) (|MultivariateFactorize| . MULTFACT) (|MultivariatePolynomi=
al| . MPOLY) (|MultFiniteFactorize| . MFINFACT) (|MyUnivariatePolyno!
mial| . MYUP) (|MyExpression| . MYEXPR) (|NoneFunctions1| . NONE1) (|NonN=
egativeInteger| . NNI) (|NottinghamGroup| . NOTTING) (|NormalizationPacka=
ge| . NORMPK) (|NormInMonogenicAlgebra| . NORMMA) (|NumberTheoreticPolyno=
mialFunctions| . NTPOLFN) (|Numeric| . NUMERIC) (|NumericalOrdinaryDiffer=
entialEquations| . NUMODE) (|NumericalQuadrature| . NUMQUAD) (|NumericCom=
plexEigenPackage| . NCEP) (|NumericRealEigenPackage| . NREP) (|NumericCon=
tinuedFraction| . NCNTFRAC) (|Octonion| . OCT) (|OctonionCategoryFunction=
s2| . OCTCT2) (|OneDimensionalArray| . ARRAY1) (|OneDimensionalArrayFunct=
ions2| . ARRAY12) (|OnePointCompletion| . ONECOMP) (|OnePointCompletionFu=
nctions2| . ONECOMP2) (|OpenMathConnection| . OMCONN) (|OpenMathDevice| .=
 OMDEV) (|OpenMathEncoding| . OMENC) (|OpenMathError| . OMERR) (|OpenMath=
ErrorKind| . OMERRK) (|OpenMathPackage| . OMPKG) (|OpenMathServerPackage|=
 . OMSERVER) (|OperationsQuery| . OPQUERY) (|OrderedCompletion| . ORDCOMP=
) (|OrderedCompletionFunctions2| . ORDCOMP2) (|OrdinaryDifferentialRing| =
. ODR) (|OrdSetInts| . OSI) (|OrthogonalPolynomialFunctions| . ORTHPOL) (=
|OutputPackage| . OUT) (|PadeApproximantPackage| . PADEPAC) (|Palette| . =
PALETTE) (|PartialFraction| . PFR) (|PatternFunctions2| . PATTERN2) (|Par=
ametricPlaneCurve| . PARPCURV) (|ParametricSpaceCurve| . PARSCURV) (|Para=
metricSurface| . PARSURF) (|ParametricPlaneCurveFunctions2| . PARPC2) (|P=
arametricSpaceCurveFunctions2| . PARSC2) (|ParametricSurfaceFunctions2| .=
 PARSU2) (|PartitionsAndPermutations| . PARTPERM) (|PatternMatch| . PATMA=
TCH) (|PatternMatchAssertions| . PMASS) (|PatternMatchResultFunctions2| .=
 PATRES2) (|PendantTree| . PENDTREE) (|Permanent| . PERMAN) (|Permutation=
GroupExamples| . PGE) (|PermutationGroup| . PERMGRP) (|Permutation| . PER=
M) (|Pi| . HACKPI) (|PiCoercions| . PICOERCE) (|PointFunctions2| . PTFUNC=
2) (|PolyGroebner| . PGROEB) (|Polynomial| . POLY) (|PolynomialAN2Express=
ion| . PAN2EXPR) (|PolynomialComposition| . PCOMP) (|PolynomialDecomposit=
ion| . PDECOMP) (|PolynomialFunctions2| . POLY2) (|PolynomialIdeals|!
 . IDEAL) (|PolynomialToUnivariatePolynomial| . POLY2UP) (|PositiveIntege=
r| . PI) (|PowerSeriesLimitPackage| . LIMITPS) (|PrimeField| . PF) (|Prim=
itiveArrayFunctions2| . PRIMARR2) (|PrintPackage| . PRINT) (|QuadraticFor=
m| . QFORM) (|QuasiComponentPackage| . QCMPACK) (|Quaternion| . QUAT) (|Q=
uaternionCategoryFunctions2| . QUATCT2) (|QueryEquation| . QEQUAT) (|Queu=
e| . QUEUE) (|QuotientFieldCategoryFunctions2| . QFCAT2) (|RadicalEigenPa=
ckage| . REP) (|RadicalSolvePackage| . SOLVERAD) (|RadixExpansion| . RADI=
X) (|RadixUtilities| . RADUTIL) (|RandomNumberSource| . RANDSRC) (|Ration=
alFunction| . RF) (|RationalFunctionDefiniteIntegration| . DEFINTRF) (|Ra=
tionalFunctionFactor| . RFFACT) (|RationalFunctionFactorizer| . RFFACTOR)=
 (|RationalFunctionIntegration| . INTRF) (|RationalFunctionLimitPackage| =
. LIMITRF) (|RationalFunctionSign| . SIGNRF) (|RationalFunctionSum| . SUM=
RF) (|RationalRetractions| . RATRET) (|RealClosure| . RECLOS) (|RealPolyn=
omialUtilitiesPackage| . POLUTIL) (|RealZeroPackage| . REAL0) (|RealZeroP=
ackageQ| . REAL0Q) (|RecurrenceOperator| . RECOP) (|RectangularMatrixCate=
goryFunctions2| . RMCAT2) (|RegularSetDecompositionPackage| . RSDCMPK) (|=
RegularTriangularSet| . REGSET) (|RegularTriangularSetGcdPackage| . RSETG=
CD) (|RepresentationPackage1| . REP1) (|RepresentationPackage2| . REP2) (=
|ResolveLatticeCompletion| . RESLATC) (|RewriteRule| . RULE) (|RightOpenI=
ntervalRootCharacterization| . ROIRC) (|RomanNumeral| . ROMAN) (|Ruleset|=
 . RULESET) (|ScriptFormulaFormat| . FORMULA) (|ScriptFormulaFormat1| . F=
ORMULA1) (|Segment| . SEG) (|SegmentBinding| . SEGBIND) (|SegmentBindingF=
unctions2| . SEGBIND2) (|SegmentFunctions2| . SEG2) (|Set| . SET) (|Simpl=
eAlgebraicExtensionAlgFactor| . SAEFACT) (|SimplifyAlgebraicNumberConvert=
Package| . SIMPAN) (|SingleInteger| . SINT) (|SmithNormalForm| . SMITH) (=
|SparseUnivariatePolynomialExpressions| . SUPEXPR) (|SparseUnivariatePoly=
nomialFunctions2| . SUP2) (|SpecialOutputPackage| . SPECOUT) (|SquareFree=
RegularSetDecompositionPackage| . SRDCMPK) (|SquareFreeRegularTriang!
ularSet| . SREGSET) (|SquareFreeRegularTriangularSetGcdPackage| . SFRGCD)=
 (|SquareFreeQuasiComponentPackage| . SFQCMPK) (|Stack| . STACK) (|Stream=
| . STREAM) (|StreamFunctions1| . STREAM1) (|StreamFunctions2| . STREAM2)=
 (|StreamFunctions3| . STREAM3) (|String| . STRING) (|SturmHabichtPackage=
| . SHP) (|Symbol| . SYMBOL) (|SymmetricGroupCombinatoricFunctions| . SGC=
F) (|SystemSolvePackage| . SYSSOLP) (|SAERationalFunctionAlgFactor| . SAE=
RFFC) (|Tableau| . TABLEAU) (|TaylorSeries| . TS) (|TaylorSolve| . UTSSOL=
) (|TexFormat| . TEX) (|TexFormat1| . TEX1) (|TextFile| . TEXTFILE) (|Thr=
eeDimensionalViewport| . VIEW3D) (|ThreeSpace| . SPACE3) (|Timer| . TIMER=
) (|TopLevelDrawFunctions| . DRAW) (|TopLevelDrawFunctionsForAlgebraicCur=
ves| . DRAWCURV) (|TopLevelDrawFunctionsForCompiledFunctions| . DRAWCFUN)=
 (|TopLevelDrawFunctionsForPoints| . DRAWPT) (|TopLevelThreeSpace| . TOPS=
P) (|TranscendentalManipulations| . TRMANIP) (|TransSolvePackage| . SOLVE=
TRA) (|Tree| . TREE) (|TrigonometricManipulations| . TRIGMNIP) (|Univaria=
teLaurentSeriesFunctions2| . ULS2) (|UnivariateFormalPowerSeries| . UFPS)=
 (|UnivariateFormalPowerSeriesFunctions| . UFPS1) (|UnivariatePolynomial|=
 . UP) (|UnivariatePolynomialCategoryFunctions2| . UPOLYC2) (|UnivariateP=
olynomialCommonDenominator| . UPCDEN) (|UnivariatePolynomialFunctions2| .=
 UP2) (|UnivariatePolynomialMultiplicationPackage| . UPMP) (|UnivariatePu=
iseuxSeriesFunctions2| . UPXS2) (|UnivariateTaylorSeriesFunctions2| . UTS=
2) (|UniversalSegment| . UNISEG) (|UniversalSegmentFunctions2| . UNISEG2)=
 (|UserDefinedVariableOrdering| . UDVO) (|Vector| . VECTOR) (|VectorFunct=
ions2| . VECTOR2) (|ViewDefaultsPackage| . VIEWDEF) (|Void| . VOID) (|WuW=
enTsunTriangularSet| . WUTSET)) (|naglink| (|Asp1| . ASP1) (|Asp4| . ASP4=
) (|Asp6| . ASP6) (|Asp7| . ASP7) (|Asp8| . ASP8) (|Asp9| . ASP9) (|Asp10=
| . ASP10) (|Asp12| . ASP12) (|Asp19| . ASP19) (|Asp20| . ASP20) (|Asp24|=
 . ASP24) (|Asp27| . ASP27) (|Asp28| . ASP28) (|Asp29| . ASP29) (|Asp30| =
. ASP30) (|Asp31| . ASP31) (|Asp33| . ASP33) (|Asp34| . ASP34) (|Asp!
35| . ASP35) (|Asp41| . ASP41) (|Asp42| . ASP42) (|Asp49| . ASP49) (|Asp5=
0| . ASP50) (|Asp55| . ASP55) (|Asp73| . ASP73) (|Asp74| . ASP74) (|Asp77=
| . ASP77) (|Asp78| . ASP78) (|Asp80| . ASP80) (|FortranCode| . FC) (|For=
tranCodePackage1| . FCPAK1) (|FortranExpression| . FEXPR) (|FortranMachin=
eTypeCategory| . FMTC) (|FortranMatrixCategory| . FMC) (|FortranMatrixFun=
ctionCategory| . FMFUN) (|FortranOutputStackPackage| . FOP) (|FortranPack=
age| . FORT) (|FortranProgramCategory| . FORTCAT) (|FortranProgram| . FOR=
TRAN) (|FortranFunctionCategory| . FORTFN) (|FortranScalarType| . FST) (|=
FortranType| . FT) (|FortranTemplate| . FTEM) (|FortranVectorFunctionCate=
gory| . FVFUN) (|FortranVectorCategory| . FVC) (|MachineComplex| . MCMPLX=
) (|MachineFloat| . MFLOAT) (|MachineInteger| . MINT) (|MultiVariableCalc=
ulusFunctions| . MCALCFN) (|NagDiscreteFourierTransformInterfacePackage| =
. NAGDIS) (|NagEigenInterfacePackage| . NAGEIG) (|NAGLinkSupportPackage| =
. NAGSP) (|NagOptimisationInterfacePackage| . NAGOPT) (|NagQuadratureInte=
rfacePackage| . NAGQUA) (|NagResultChecks| . NAGRES) (|NagSpecialFunction=
sInterfacePackage| . NAGSPE) (|NagPolynomialRootsPackage| . NAGC02) (|Nag=
RootFindingPackage| . NAGC05) (|NagSeriesSummationPackage| . NAGC06) (|Na=
gIntegrationPackage| . NAGD01) (|NagOrdinaryDifferentialEquationsPackage|=
 . NAGD02) (|NagPartialDifferentialEquationsPackage| . NAGD03) (|NagInter=
polationPackage| . NAGE01) (|NagFittingPackage| . NAGE02) (|NagOptimisati=
onPackage| . NAGE04) (|NagMatrixOperationsPackage| . NAGF01) (|NagEigenPa=
ckage| . NAGF02) (|NagLinearEquationSolvingPackage| . NAGF04) (|NagLapack=
| . NAGF07) (|NagSpecialFunctionsPackage| . NAGS) (|PackedHermitianSequen=
ce| . PACKED) (|Result| . RESULT) (|SimpleFortranProgram| . SFORT) (|Swit=
ch| . SWITCH) (|SymbolTable| . SYMTAB) (|TemplateUtilities| . TEMUTL) (|T=
heSymbolTable| . SYMS) (|ThreeDimensionalMatrix| . M3D)) (|anna| (|AnnaNu=
mericalIntegrationPackage| . INTPACK) (|AnnaNumericalOptimizationPackage|=
 . OPTPACK) (|AnnaOrdinaryDifferentialEquationPackage| . ODEPACK) (|!
AnnaPartialDifferentialEquationPackage| . PDEPACK) (|AttributeButtons| . =
ATTRBUT) (|BasicFunctions| . BFUNCT) (|d01ajfAnnaType| . D01AJFA) (|d01ak=
fAnnaType| . D01AKFA) (|d01alfAnnaType| . D01ALFA) (|d01amfAnnaType| . D0=
1AMFA) (|d01anfAnnaType| . D01ANFA) (|d01apfAnnaType| . D01APFA) (|d01aqf=
AnnaType| . D01AQFA) (|d01asfAnnaType| . D01ASFA) (|d01fcfAnnaType| . D01=
FCFA) (|d01gbfAnnaType| . D01GBFA) (|d01AgentsPackage| . D01AGNT) (|d01Tr=
ansformFunctionType| . D01TRNS) (|d01WeightsPackage| . D01WGTS) (|d02Agen=
tsPackage| . D02AGNT) (|d02bbfAnnaType| . D02BBFA) (|d02bhfAnnaType| . D0=
2BHFA) (|d02cjfAnnaType| . D02CJFA) (|d02ejfAnnaType| . D02EJFA) (|d03Age=
ntsPackage| . D03AGNT) (|d03eefAnnaType| . D03EEFA) (|d03fafAnnaType| . D=
03FAFA) (|e04AgentsPackage| . E04AGNT) (|e04dgfAnnaType| . E04DGFA) (|e04=
fdfAnnaType| . E04FDFA) (|e04gcfAnnaType| . E04GCFA) (|e04jafAnnaType| . =
E04JAFA) (|e04mbfAnnaType| . E04MBFA) (|e04nafAnnaType| . E04NAFA) (|e04u=
cfAnnaType| . E04UCFA) (|ExpertSystemContinuityPackage| . ESCONT) (|Exper=
tSystemContinuityPackage1| . ESCONT1) (|ExpertSystemToolsPackage| . ESTOO=
LS) (|ExpertSystemToolsPackage1| . ESTOOLS1) (|ExpertSystemToolsPackage2|=
 . ESTOOLS2) (|NumericalIntegrationCategory| . NUMINT) (|NumericalIntegra=
tionProblem| . NIPROB) (|NumericalODEProblem| . ODEPROB) (|NumericalOptim=
izationCategory| . OPTCAT) (|NumericalOptimizationProblem| . OPTPROB) (|N=
umericalPDEProblem| . PDEPROB) (|ODEIntensityFunctionsTable| . ODEIFTBL) =
(|IntegrationFunctionsTable| . INTFTBL) (|OrdinaryDifferentialEquationsSo=
lverCategory| . ODECAT) (|PartialDifferentialEquationsSolverCategory| . P=
DECAT) (|RoutinesTable| . ROUTINE)) (|categories| (|AbelianGroup| . ABELG=
RP) (|AbelianMonoid| . ABELMON) (|AbelianMonoidRing| . AMR) (|AbelianSemi=
Group| . ABELSG) (|Aggregate| . AGG) (|Algebra| . ALGEBRA) (|Algebraicall=
yClosedField| . ACF) (|AlgebraicallyClosedFunctionSpace| . ACFS) (|ArcHyp=
erbolicFunctionCategory| . AHYP) (|ArcTrigonometricFunctionCategory| . AT=
RIG) (|AssociationListAggregate| . ALAGG) (|AttributeRegistry| . ATT!
REG) (|BagAggregate| . BGAGG) (|BasicType| . BASTYPE) (|BiModule| . BMODU=
LE) (|BinaryRecursiveAggregate| . BRAGG) (|BinaryTreeCategory| . BTCAT) (=
|BitAggregate| . BTAGG) (|CachableSet| . CACHSET) (|CancellationAbelianMo=
noid| . CABMON) (|CharacteristicNonZero| . CHARNZ) (|CharacteristicZero| =
. CHARZ) (|CoercibleTo| . KOERCE) (|Collection| . CLAGG) (|CombinatorialF=
unctionCategory| . CFCAT) (|CombinatorialOpsCategory| . COMBOPC) (|Commut=
ativeRing| . COMRING) (|ComplexCategory| . COMPCAT) (|ConvertibleTo| . KO=
NVERT) (|DequeueAggregate| . DQAGG) (|Dictionary| . DIAGG) (|DictionaryOp=
erations| . DIOPS) (|DifferentialExtension| . DIFEXT) (|DifferentialPolyn=
omialCategory| . DPOLCAT) (|DifferentialRing| . DIFRING) (|DifferentialVa=
riableCategory| . DVARCAT) (|DirectProductCategory| . DIRPCAT) (|Division=
Ring| . DIVRING) (|DoublyLinkedAggregate| . DLAGG) (|ElementaryFunctionCa=
tegory| . ELEMFUN) (|Eltable| . ELTAB) (|EltableAggregate| . ELTAGG) (|En=
tireRing| . ENTIRER) (|EuclideanDomain| . EUCDOM) (|Evalable| . EVALAB) (=
|ExpressionSpace| . ES) (|ExtensibleLinearAggregate| . ELAGG) (|Extension=
Field| . XF) (|Field| . FIELD) (|FieldOfPrimeCharacteristic| . FPC) (|Fin=
ite| . FINITE) (|FileCategory| . FILECAT) (|FileNameCategory| . FNCAT) (|=
FiniteAbelianMonoidRing| . FAMR) (|FiniteAlgebraicExtensionField| . FAXF)=
 (|FiniteDivisorCategory| . FDIVCAT) (|FiniteFieldCategory| . FFIELDC) (|=
FiniteLinearAggregate| . FLAGG) (|FiniteRankNonAssociativeAlgebra| . FINA=
ALG) (|FiniteRankAlgebra| . FINRALG) (|FiniteSetAggregate| . FSAGG) (|Flo=
atingPointSystem| . FPS) (|FramedAlgebra| . FRAMALG) (|FramedNonAssociati=
veAlgebra| . FRNAALG) (|FramedNonAssociativeAlgebraFunctions2| . FRNAAF2)=
 (|FreeAbelianMonoidCategory| . FAMONC) (|FreeLieAlgebra| . FLALG) (|Free=
ModuleCat| . FMCAT) (|FullyEvalableOver| . FEVALAB) (|FullyLinearlyExplic=
itRingOver| . FLINEXP) (|FullyPatternMatchable| . FPATMAB) (|FullyRetract=
ableTo| . FRETRCT) (|FunctionFieldCategory| . FFCAT) (|FunctionSpace| . F=
S) (|GcdDomain| . GCDDOM) (|GradedAlgebra| . GRALG) (|GradedModule| !
. GRMOD) (|Group| . GROUP) (|HomogeneousAggregate| . HOAGG) (|HyperbolicF=
unctionCategory| . HYPCAT) (|IndexedAggregate| . IXAGG) (|IndexedDirectPr=
oductCategory| . IDPC) (|InnerEvalable| . IEVALAB) (|IntegerNumberSystem|=
 . INS) (|IntegralDomain| . INTDOM) (|IntervalCategory| . INTCAT) (|Keyed=
Dictionary| . KDAGG) (|LazyStreamAggregate| . LZSTAGG) (|LeftAlgebra| . L=
ALG) (|LeftModule| . LMODULE) (|LieAlgebra| . LIECAT) (|LinearAggregate| =
. LNAGG) (|LinearlyExplicitRingOver| . LINEXP) (|LinearOrdinaryDifferenti=
alOperatorCategory| . LODOCAT) (|LiouvillianFunctionCategory| . LFCAT) (|=
ListAggregate| . LSAGG) (|Logic| . LOGIC) (|MatrixCategory| . MATCAT) (|M=
odule| . MODULE) (|Monad| . MONAD) (|MonadWithUnit| . MONADWU) (|Monoid| =
. MONOID) (|MonogenicAlgebra| . MONOGEN) (|MonogenicLinearOperator| . MLO=
) (|MultiDictionary| . MDAGG) (|MultisetAggregate| . MSETAGG) (|Multivari=
ateTaylorSeriesCategory| . MTSCAT) (|NonAssociativeAlgebra| . NAALG) (|No=
nAssociativeRing| . NASRING) (|NonAssociativeRng| . NARNG) (|NormalizedTr=
iangularSetCategory| . NTSCAT) (|Object| . OBJECT) (|OctonionCategory| . =
OC) (|OneDimensionalArrayAggregate| . A1AGG) (|OpenMath| . OM) (|OrderedA=
belianGroup| . OAGROUP) (|OrderedAbelianMonoid| . OAMON) (|OrderedAbelian=
MonoidSup| . OAMONS) (|OrderedAbelianSemiGroup| . OASGP) (|OrderedCancell=
ationAbelianMonoid| . OCAMON) (|OrderedFinite| . ORDFIN) (|OrderedIntegra=
lDomain| . OINTDOM) (|OrderedMonoid| . ORDMON) (|OrderedMultisetAggregate=
| . OMSAGG) (|OrderedRing| . ORDRING) (|OrderedSet| . ORDSET) (|PAdicInte=
gerCategory| . PADICCT) (|PartialDifferentialRing| . PDRING) (|PartialTra=
nscendentalFunctions| . PTRANFN) (|Patternable| . PATAB) (|PatternMatchab=
le| . PATMAB) (|PermutationCategory| . PERMCAT) (|PlottablePlaneCurveCate=
gory| . PPCURVE) (|PlottableSpaceCurveCategory| . PSCURVE) (|PointCategor=
y| . PTCAT) (|PolynomialCategory| . POLYCAT) (|PolynomialFactorizationExp=
licit| . PFECAT) (|PolynomialSetCategory| . PSETCAT) (|PowerSeriesCategor=
y| . PSCAT) (|PrimitiveFunctionCategory| . PRIMCAT) (|PrincipalIdeal!
Domain| . PID) (|PriorityQueueAggregate| . PRQAGG) (|QuaternionCategory| =
. QUATCAT) (|QueueAggregate| . QUAGG) (|QuotientFieldCategory| . QFCAT) (=
|RadicalCategory| . RADCAT) (|RealClosedField| . RCFIELD) (|RealConstant|=
 . REAL) (|RealNumberSystem| . RNS) (|RealRootCharacterizationCategory| .=
 RRCC) (|RectangularMatrixCategory| . RMATCAT) (|RecursiveAggregate| . RC=
AGG) (|RecursivePolynomialCategory| . RPOLCAT) (|RegularChain| . RGCHAIN)=
 (|RegularTriangularSetCategory| . RSETCAT) (|RetractableTo| . RETRACT) (=
|RightModule| . RMODULE) (|Ring| . RING) (|Rng| . RNG) (|SegmentCategory|=
 . SEGCAT) (|SegmentExpansionCategory| . SEGXCAT) (|SemiGroup| . SGROUP) =
(|SetAggregate| . SETAGG) (|SetCategory| . SETCAT) (|SExpressionCategory|=
 . SEXCAT) (|SpecialFunctionCategory| . SPFCAT) (|SquareFreeNormalizedTri=
angularSetCategory| . SNTSCAT) (|SquareFreeRegularTriangularSetCategory| =
. SFRTCAT) (|SquareMatrixCategory| . SMATCAT) (|StackAggregate| . SKAGG) =
(|StepThrough| . STEP) (|StreamAggregate| . STAGG) (|StringAggregate| . S=
RAGG) (|StringCategory| . STRICAT) (|StructuralConstantsPackage| . SCPKG)=
 (|TableAggregate| . TBAGG) (|ThreeSpaceCategory| . SPACEC) (|Transcenden=
talFunctionCategory| . TRANFUN) (|TriangularSetCategory| . TSETCAT) (|Tri=
gonometricFunctionCategory| . TRIGCAT) (|TwoDimensionalArrayCategory| . A=
RR2CAT) (|Type| . TYPE) (|UnaryRecursiveAggregate| . URAGG) (|UniqueFacto=
rizationDomain| . UFD) (|UnivariateLaurentSeriesCategory| . ULSCAT) (|Uni=
variateLaurentSeriesConstructorCategory| . ULSCCAT) (|UnivariatePolynomia=
lCategory| . UPOLYC) (|UnivariatePowerSeriesCategory| . UPSCAT) (|Univari=
atePuiseuxSeriesCategory| . UPXSCAT) (|UnivariatePuiseuxSeriesConstructor=
Category| . UPXSCCA) (|UnivariateSkewPolynomialCategory| . OREPCAT) (|Uni=
variateTaylorSeriesCategory| . UTSCAT) (|VectorCategory| . VECTCAT) (|Vec=
torSpace| . VSPACE) (|XAlgebra| . XALG) (|XFreeAlgebra| . XFALG) (|XPolyn=
omialsCat| . XPOLYC) (|ZeroDimensionalSolvePackage| . ZDSOLVE)) (|Hidden|=
 (|AlgebraicFunction| . AF) (|AlgebraicFunctionField| . ALGFF) (|Alg!
ebraicHermiteIntegration| . INTHERAL) (|AlgebraicIntegrate| . INTALG) (|A=
lgebraicIntegration| . INTAF) (|AnonymousFunction| . ANON) (|AntiSymm| . =
ANTISYM) (|ApplyRules| . APPRULE) (|ApplyUnivariateSkewPolynomial| . APPL=
YORE) (|ArrayStack| . ASTACK) (|AssociatedEquations| . ASSOCEQ) (|Associa=
tionList| . ALIST) (|Automorphism| . AUTOMOR) (|BalancedFactorisation| . =
BALFACT) (|BalancedPAdicInteger| . BPADIC) (|BalancedPAdicRational| . BPA=
DICRT) (|BezoutMatrix| . BEZOUT) (|BoundIntegerRoots| . BOUNDZRO) (|Brill=
hartTests| . BRILL) (|ChangeOfVariable| . CHVAR) (|CharacteristicPolynomi=
alInMonogenicalAlgebra| . CPIMA) (|ChineseRemainderToolsForIntegralBases|=
 . IBACHIN) (|CoerceVectorMatrixPackage| . CVMP) (|CombinatorialFunction|=
 . COMBF) (|CommonOperators| . COMMONOP) (|CommuteUnivariatePolynomialCat=
egory| . COMMUPC) (|ComplexIntegerSolveLinearPolynomialEquation| . CINTSL=
PE) (|ComplexPattern| . COMPLPAT) (|ComplexPatternMatch| . CPMATCH) (|Com=
plexRootFindingPackage| . CRFP) (|ConstantLODE| . ODECONST) (|CyclicStrea=
mTools| . CSTTOOLS) (|CyclotomicPolynomialPackage| . CYCLOTOM) (|Definite=
IntegrationTools| . DFINTTLS) (|DegreeReductionPackage| . DEGRED) (|DeRha=
mComplex| . DERHAM) (|DifferentialSparseMultivariatePolynomial| . DSMP) (=
|DirectProduct| . DIRPROD) (|DirectProductMatrixModule| . DPMM) (|DirectP=
roductModule| . DPMO) (|DiscreteLogarithmPackage| . DLP) (|DistributedMul=
tivariatePolynomial| . DMP) (|DoubleResultantPackage| . DBLRESP) (|DrawOp=
tionFunctions0| . DROPT0) (|DrawOptionFunctions1| . DROPT1) (|ElementaryF=
unction| . EF) (|ElementaryFunctionsUnivariateLaurentSeries| . EFULS) (|E=
lementaryFunctionsUnivariatePuiseuxSeries| . EFUPXS) (|ElementaryIntegrat=
ion| . INTEF) (|ElementaryRischDE| . RDEEF) (|ElementaryRischDESystem| . =
RDEEFS) (|EllipticFunctionsUnivariateTaylorSeries| . ELFUTS) (|EqTable| .=
 EQTBL) (|EuclideanModularRing| . EMR) (|EvaluateCycleIndicators| . EVALC=
YC) (|ExponentialExpansion| . EXPEXPAN) (|ExponentialOfUnivariatePuiseuxS=
eries| . EXPUPXS) (|ExpressionSpaceFunctions1| . ES1) (|ExpressionTu!
bePlot| . EXPRTUBE) (|ExtAlgBasis| . EAB) (|FactoredFunctions| . FACTFUNC=
) (|FactoredFunctionUtilities| . FRUTIL) (|FactoringUtilities| . FACUTIL)=
 (|FGLMIfCanPackage| . FGLMICPK) (|FindOrderFinite| . FORDER) (|FiniteDiv=
isor| . FDIV) (|FiniteFieldCyclicGroupExtension| . FFCGX) (|FiniteFieldCy=
clicGroupExtensionByPolynomial| . FFCGP) (|FiniteFieldExtension| . FFX) (=
|FiniteFieldExtensionByPolynomial| . FFP) (|FiniteFieldFunctions| . FFF) =
(|FiniteFieldNormalBasisExtension| . FFNBX) (|FiniteFieldNormalBasisExten=
sionByPolynomial| . FFNBP) (|FiniteFieldPolynomialPackage| . FFPOLY) (|Fi=
niteFieldSolveLinearPolynomialEquation| . FFSLPE) (|FormalFraction| . FOR=
MAL) (|FourierComponent| . FCOMP) (|FractionalIdeal| . FRIDEAL) (|FramedM=
odule| . FRMOD) (|FreeAbelianGroup| . FAGROUP) (|FreeAbelianMonoid| . FAM=
ONOID) (|FreeGroup| . FGROUP) (|FreeModule| . FM) (|FreeModule1| . FM1) (=
|FreeMonoid| . FMONOID) (|FunctionalSpecialFunction| . FSPECF) (|Function=
Called| . FUNCTION) (|FunctionFieldIntegralBasis| . FFINTBAS) (|FunctionS=
paceReduce| . FSRED) (|FunctionSpaceToUnivariatePowerSeries| . FS2UPS) (|=
FunctionSpaceToExponentialExpansion| . FS2EXPXP) (|FunctionSpaceUnivariat=
ePolynomialFactor| . FSUPFACT) (|GaloisGroupFactorizationUtilities| . GAL=
FACTU) (|GaloisGroupFactorizer| . GALFACT) (|GaloisGroupPolynomialUtiliti=
es| . GALPOLYU) (|GaloisGroupUtilities| . GALUTIL) (|GeneralHenselPackage=
| . GHENSEL) (|GeneralDistributedMultivariatePolynomial| . GDMP) (|Genera=
lPolynomialGcdPackage| . GENPGCD) (|GeneralSparseTable| . GSTBL) (|Generi=
cNonAssociativeAlgebra| . GCNAALG) (|GenExEuclid| . GENEEZ) (|Generalized=
MultivariateFactorize| . GENMFACT) (|GeneralModulePolynomial| . GMODPOL) =
(|GeneralPolynomialSet| . GPOLSET) (|GeneralTriangularSet| . GTSET) (|Gen=
UFactorize| . GENUFACT) (|GenusZeroIntegration| . INTG0) (|GosperSummatio=
nMethod| . GOSPER) (|GraphImage| . GRIMAGE) (|GrayCode| . GRAY) (|Groebne=
rInternalPackage| . GBINTERN) (|GroebnerSolve| . GROEBSOL) (|HashTable| .=
 HASHTBL) (|Heap| . HEAP) (|HeuGcd| . HEUGCD) (|HomogeneousDistribut!
edMultivariatePolynomial| . HDMP) (|HyperellipticFiniteDivisor| . HELLFDI=
V) (|IncrementingMaps| . INCRMAPS) (|IndexedBits| . IBITS) (|IndexedDirec=
tProductAbelianGroup| . IDPAG) (|IndexedDirectProductAbelianMonoid| . IDP=
AM) (|IndexedDirectProductObject| . IDPO) (|IndexedDirectProductOrderedAb=
elianMonoid| . IDPOAM) (|IndexedDirectProductOrderedAbelianMonoidSup| . I=
DPOAMS) (|IndexedExponents| . INDE) (|IndexedFlexibleArray| . IFARRAY) (|=
IndexedList| . ILIST) (|IndexedMatrix| . IMATRIX) (|IndexedOneDimensional=
Array| . IARRAY1) (|IndexedString| . ISTRING) (|IndexedTwoDimensionalArra=
y| . IARRAY2) (|IndexedVector| . IVECTOR) (|InnerAlgFactor| . IALGFACT) (=
|InnerAlgebraicNumber| . IAN) (|InnerCommonDenominator| . ICDEN) (|InnerF=
initeField| . IFF) (|InnerFreeAbelianMonoid| . IFAMON) (|InnerIndexedTwoD=
imensionalArray| . IIARRAY2) (|InnerMatrixLinearAlgebraFunctions| . IMATL=
IN) (|InnerMatrixQuotientFieldFunctions| . IMATQF) (|InnerModularGcd| . I=
NMODGCD) (|InnerMultFact| . INNMFACT) (|InnerNormalBasisFieldFunctions| .=
 INBFF) (|InnerNumericEigenPackage| . INEP) (|InnerNumericFloatSolvePacka=
ge| . INFSP) (|InnerPAdicInteger| . IPADIC) (|InnerPolySign| . INPSIGN) (=
|InnerPolySum| . ISUMP) (|InnerPrimeField| . IPF) (|InnerSparseUnivariate=
PowerSeries| . ISUPS) (|InnerTable| . INTABL) (|InnerTaylorSeries| . ITAY=
LOR) (|InnerTrigonometricManipulations| . ITRIGMNP) (|InputForm| . INFORM=
) (|InputFormFunctions1| . INFORM1) (|IntegerBits| . INTBIT) (|IntegerFac=
torizationPackage| . INTFACT) (|IntegerMod| . ZMOD) (|IntegerSolveLinearP=
olynomialEquation| . INTSLPE) (|IntegralBasisPolynomialTools| . IBPTOOLS)=
 (|IntegralBasisTools| . IBATOOL) (|IntegrationResult| . IR) (|Integratio=
nTools| . INTTOOLS) (|InternalPrintPackage| . IPRNTPK) (|InternalRational=
UnivariateRepresentationPackage| . IRURPK) (|IrredPolyOverFiniteField| . =
IRREDFFX) (|Kernel| . KERNEL) (|Kovacic| . KOVACIC) (|LaurentPolynomial| =
. LAUPOL) (|LeadingCoefDetermination| . LEADCDET) (|LexTriangularPackage|=
 . LEXTRIPK) (|LieExponentials| . LEXP) (|LiePolynomial| . LPOLY) (|!
LinearDependence| . LINDEP) (|LinearOrdinaryDifferentialOperatorFactorize=
r| . LODOF) (|LinearOrdinaryDifferentialOperator1| . LODO1) (|LinearOrdin=
aryDifferentialOperator2| . LODO2) (|LinearOrdinaryDifferentialOperatorsO=
ps| . LODOOPS) (|LinearPolynomialEquationByFractions| . LPEFRAC) (|LinGro=
ebnerPackage| . LGROBP) (|LiouvillianFunction| . LF) (|ListMonoidOps| . L=
MOPS) (|ListMultiDictionary| . LMDICT) (|LocalAlgebra| . LA) (|Localize| =
. LO) (|LyndonWord| . LWORD) (|Magma| . MAGMA) (|MakeBinaryCompiledFuncti=
on| . MKBCFUNC) (|MakeCachableSet| . MKCHSET) (|MakeUnaryCompiledFunction=
| . MKUCFUNC) (|MappingPackageInternalHacks1| . MAPHACK1) (|MappingPackag=
eInternalHacks2| . MAPHACK2) (|MappingPackageInternalHacks3| . MAPHACK3) =
(|MeshCreationRoutinesForThreeDimensions| . MESH) (|ModMonic| . MODMON) (=
|ModularField| . MODFIELD) (|ModularHermitianRowReduction| . MHROWRED) (|=
ModularRing| . MODRING) (|ModuleMonomial| . MODMONOM) (|MoebiusTransform|=
 . MOEBIUS) (|MonoidRing| . MRING) (|MonomialExtensionTools| . MONOTOOL) =
(|MPolyCatPolyFactorizer| . MPCPF) (|MPolyCatFunctions3| . MPC3) (|MRatio=
nalFactorize| . MRATFAC) (|MultipleMap| . MMAP) (|MultivariateLifting| . =
MLIFT) (|MultivariateSquareFree| . MULTSQFR) (|HomogeneousDirectProduct| =
. HDP) (|NewSparseMultivariatePolynomial| . NSMP) (|NewSparseUnivariatePo=
lynomial| . NSUP) (|NewSparseUnivariatePolynomialFunctions2| . NSUP2) (|N=
onCommutativeOperatorDivision| . NCODIV) (|NewtonInterpolation| . NEWTON)=
 (|None| . NONE) (|NonLinearFirstOrderODESolver| . NODE1) (|NonLinearSolv=
ePackage| . NLINSOL) (|NormRetractPackage| . NORMRETR) (|NPCoef| . NPCOEF=
) (|NumberFormats| . NUMFMT) (|NumberFieldIntegralBasis| . NFINTBAS) (|Nu=
mericTubePlot| . NUMTUBE) (|ODEIntegration| . ODEINT) (|ODETools| . ODETO=
OLS) (|Operator| . OP) (|OppositeMonogenicLinearOperator| . OMLO) (|Order=
edDirectProduct| . ODP) (|OrderedFreeMonoid| . OFMONOID) (|OrderedVariabl=
eList| . OVAR) (|OrderingFunctions| . ORDFUNS) (|OrderlyDifferentialPolyn=
omial| . ODPOL) (|OrderlyDifferentialVariable| . ODVAR) (|OrdinaryWe!
ightedPolynomials| . OWP) (|OutputForm| . OUTFORM) (|PadeApproximants| . =
PADE) (|PAdicInteger| . PADIC) (|PAdicRational| . PADICRAT) (|PAdicRation=
alConstructor| . PADICRC) (|PAdicWildFunctionFieldIntegralBasis| . PWFFIN=
TB) (|ParadoxicalCombinatorsForStreams| . YSTREAM) (|ParametricLinearEqua=
tions| . PLEQN) (|PartialFractionPackage| . PFRPAC) (|Partition| . PRTITI=
ON) (|Pattern| . PATTERN) (|PatternFunctions1| . PATTERN1) (|PatternMatch=
FunctionSpace| . PMFS) (|PatternMatchIntegerNumberSystem| . PMINS) (|Patt=
ernMatchIntegration| . INTPM) (|PatternMatchKernel| . PMKERNEL) (|Pattern=
MatchListAggregate| . PMLSAGG) (|PatternMatchListResult| . PATLRES) (|Pat=
ternMatchPolynomialCategory| . PMPLCAT) (|PatternMatchPushDown| . PMDOWN)=
 (|PatternMatchQuotientFieldCategory| . PMQFCAT) (|PatternMatchResult| . =
PATRES) (|PatternMatchSymbol| . PMSYM) (|PatternMatchTools| . PMTOOLS) (|=
PlaneAlgebraicCurvePlot| . ACPLOT) (|Plot| . PLOT) (|PlotFunctions1| . PL=
OT1) (|PlotTools| . PLOTTOOL) (|Plot3D| . PLOT3D) (|PoincareBirkhoffWittL=
yndonBasis| . PBWLB) (|Point| . POINT) (|PointsOfFiniteOrder| . PFO) (|Po=
intsOfFiniteOrderRational| . PFOQ) (|PointsOfFiniteOrderTools| . PFOTOOLS=
) (|PointPackage| . PTPACK) (|PolToPol| . POLTOPOL) (|PolynomialCategoryL=
ifting| . POLYLIFT) (|PolynomialCategoryQuotientFunctions| . POLYCATQ) (|=
PolynomialFactorizationByRecursion| . PFBR) (|PolynomialFactorizationByRe=
cursionUnivariate| . PFBRU) (|PolynomialGcdPackage| . PGCD) (|PolynomialI=
nterpolation| . PINTERP) (|PolynomialInterpolationAlgorithms| . PINTERPA)=
 (|PolynomialNumberTheoryFunctions| . PNTHEORY) (|PolynomialRing| . PR) (=
|PolynomialRoots| . POLYROOT) (|PolynomialSetUtilitiesPackage| . PSETPK) =
(|PolynomialSolveByFormulas| . SOLVEFOR) (|PolynomialSquareFree| . PSQFR)=
 (|PrecomputedAssociatedEquations| . PREASSOC) (|PrimitiveArray| . PRIMAR=
R) (|PrimitiveElement| . PRIMELT) (|PrimitiveRatDE| . ODEPRIM) (|Primitiv=
eRatRicDE| . ODEPRRIC) (|Product| . PRODUCT) (|PseudoRemainderSequence| .=
 PRS) (|PseudoLinearNormalForm| . PSEUDLIN) (|PureAlgebraicIntegrati!
on| . INTPAF) (|PureAlgebraicLODE| . ODEPAL) (|PushVariables| . PUSHVAR) =
(|QuasiAlgebraicSet| . QALGSET) (|QuasiAlgebraicSet2| . QALGSET2) (|Radic=
alFunctionField| . RADFF) (|RandomDistributions| . RDIST) (|RandomFloatDi=
stributions| . RFDIST) (|RandomIntegerDistributions| . RIDIST) (|Rational=
Factorize| . RATFACT) (|RationalIntegration| . INTRAT) (|RationalInterpol=
ation| . RINTERP) (|RationalLODE| . ODERAT) (|RationalRicDE| . ODERTRIC) =
(|RationalUnivariateRepresentationPackage| . RURPK) (|RealSolvePackage| .=
 REALSOLV) (|RectangularMatrix| . RMATRIX) (|ReducedDivisor| . RDIV) (|Re=
duceLODE| . ODERED) (|ReductionOfOrder| . REDORDER) (|Reference| . REF) (=
|RepeatedDoubling| . REPDB) (|RepeatedSquaring| . REPSQ) (|ResidueRing| .=
 RESRING) (|RetractSolvePackage| . RETSOL) (|RuleCalled| . RULECOLD) (|Se=
tOfMIntegersInOneToN| . SETMN) (|SExpression| . SEX) (|SExpressionOf| . S=
EXOF) (|SequentialDifferentialPolynomial| . SDPOL) (|SequentialDifferenti=
alVariable| . SDVAR) (|SimpleAlgebraicExtension| . SAE) (|SingletonAsOrde=
redSet| . SAOS) (|SortedCache| . SCACHE) (|SortPackage| . SORTPAK) (|Spar=
seMultivariatePolynomial| . SMP) (|SparseMultivariateTaylorSeries| . SMTS=
) (|SparseTable| . STBL) (|SparseUnivariatePolynomial| . SUP) (|SparseUni=
variateSkewPolynomial| . ORESUP) (|SparseUnivariateLaurentSeries| . SULS)=
 (|SparseUnivariatePuiseuxSeries| . SUPXS) (|SparseUnivariateTaylorSeries=
| . SUTS) (|SplitHomogeneousDirectProduct| . SHDP) (|SplittingNode| . SPL=
NODE) (|SplittingTree| . SPLTREE) (|SquareMatrix| . SQMATRIX) (|Stack| . =
STACK) (|StorageEfficientMatrixOperations| . MATSTOR) (|StreamInfinitePro=
duct| . STINPROD) (|StreamTaylorSeriesOperations| . STTAYLOR) (|StreamTra=
nscendentalFunctions| . STTF) (|StreamTranscendentalFunctionsNonCommutati=
ve| . STTFNC) (|StringTable| . STRTBL) (|SubResultantPackage| . SUBRESP) =
(|SubSpace| . SUBSPACE) (|SubSpaceComponentProperty| . COMPPROP) (|SuchTh=
at| . SUCH) (|SupFractionFactorizer| . SUPFRACF) (|SymmetricFunctions| . =
SYMFUNC) (|SymmetricPolynomial| . SYMPOLY) (|SystemODESolver| . ODES!
YS) (|Table| . TABLE) (|TableauxBumpers| . TABLBUMP) (|TabulatedComputati=
onPackage| . TBCMPPK) (|TangentExpansions| . TANEXP) (|ToolsForSign| . TO=
OLSIGN) (|TranscendentalHermiteIntegration| . INTHERTR) (|TranscendentalI=
ntegration| . INTTR) (|TranscendentalRischDE| . RDETR) (|TranscendentalRi=
schDESystem| . RDETRS) (|TransSolvePackageService| . SOLVESER) (|Triangul=
arMatrixOperations| . TRIMAT) (|TubePlot| . TUBE) (|TubePlotTools| . TUBE=
TOOL) (|Tuple| . TUPLE) (|TwoDimensionalArray| . ARRAY2) (|TwoDimensional=
PlotClipping| . CLIP) (|TwoDimensionalViewport| . VIEW2D) (|TwoFactorize|=
 . TWOFACT) (|UnivariateFactorize| . UNIFACT) (|UnivariateLaurentSeries| =
. ULS) (|UnivariateLaurentSeriesConstructor| . ULSCONS) (|UnivariatePolyn=
omialDecompositionPackage| . UPDECOMP) (|UnivariatePolynomialDivisionPack=
age| . UPDIVP) (|UnivariatePolynomialSquareFree| . UPSQFREE) (|Univariate=
PuiseuxSeries| . UPXS) (|UnivariatePuiseuxSeriesConstructor| . UPXSCONS) =
(|UnivariatePuiseuxSeriesWithExponentialSingularity| . UPXSSING) (|Univar=
iateSkewPolynomial| . OREUP) (|UnivariateSkewPolynomialCategoryOps| . ORE=
PCTO) (|UnivariateTaylorSeries| . UTS) (|UnivariateTaylorSeriesODESolver|=
 . UTSODE) (|UserDefinedPartialOrdering| . UDPO) (|UTSodetools| . UTSODET=
L) (|Variable| . VARIABLE) (|ViewportPackage| . VIEW) (|WeierstrassPrepar=
ation| . WEIER) (|WeightedPolynomials| . WP) (|WildFunctionFieldIntegralB=
asis| . WFFINTBS) (|XDistributedPolynomial| . XDPOLY) (|XExponentialPacka=
ge| . XEXPPKG) (|XPBWPolynomial| . XPBWPOLY) (|XPolynomial| . XPOLY) (|XP=
olynomialRing| . XPR) (|XRecursivePolynomial| . XRPOLY)) (|defaults| (|Ab=
elianGroup&| . ABELGRP-) (|AbelianMonoid&| . ABELMON-) (|AbelianMonoidRin=
g&| . AMR-) (|AbelianSemiGroup&| . ABELSG-) (|Aggregate&| . AGG-) (|Algeb=
ra&| . ALGEBRA-) (|AlgebraicallyClosedField&| . ACF-) (|AlgebraicallyClos=
edFunctionSpace&| . ACFS-) (|ArcTrigonometricFunctionCategory&| . ATRIG-)=
 (|BagAggregate&| . BGAGG-) (|BasicType&| . BASTYPE-) (|BinaryRecursiveAg=
gregate&| . BRAGG-) (|BinaryTreeCategory&| . BTCAT-) (|BitAggregate&!
| . BTAGG-) (|Collection&| . CLAGG-) (|ComplexCategory&| . COMPCAT-) (|Di=
ctionary&| . DIAGG-) (|DictionaryOperations&| . DIOPS-) (|DifferentialExt=
ension&| . DIFEXT-) (|DifferentialPolynomialCategory&| . DPOLCAT-) (|Diff=
erentialRing&| . DIFRING-) (|DifferentialVariableCategory&| . DVARCAT-) (=
|DirectProductCategory&| . DIRPCAT-) (|DivisionRing&| . DIVRING-) (|Eleme=
ntaryFunctionCategory&| . ELEMFUN-) (|EltableAggregate&| . ELTAGG-) (|Euc=
lideanDomain&| . EUCDOM-) (|Evalable&| . EVALAB-) (|ExpressionSpace&| . E=
S-) (|ExtensibleLinearAggregate&| . ELAGG-) (|ExtensionField&| . XF-) (|F=
ield&| . FIELD-) (|FieldOfPrimeCharacteristic&| . FPC-) (|FiniteAbelianMo=
noidRing&| . FAMR-) (|FiniteAlgebraicExtensionField&| . FAXF-) (|FiniteDi=
visorCategory&| . FDIVCAT-) (|FiniteFieldCategory&| . FFIELDC-) (|FiniteL=
inearAggregate&| . FLAGG-) (|FiniteSetAggregate&| . FSAGG-) (|FiniteRankA=
lgebra&| . FINRALG-) (|FiniteRankNonAssociativeAlgebra&| . FINAALG-) (|Fl=
oatingPointSystem&| . FPS-) (|FramedAlgebra&| . FRAMALG-) (|FramedNonAsso=
ciativeAlgebra&| . FRNAALG-) (|FullyEvalableOver&| . FEVALAB-) (|FullyLin=
earlyExplicitRingOver&| . FLINEXP-) (|FullyRetractableTo&| . FRETRCT-) (|=
FunctionFieldCategory&| . FFCAT-) (|FunctionSpace&| . FS-) (|GcdDomain&| =
. GCDDOM-) (|GradedAlgebra&| . GRALG-) (|GradedModule&| . GRMOD-) (|Group=
&| . GROUP-) (|HomogeneousAggregate&| . HOAGG-) (|HyperbolicFunctionCateg=
ory&| . HYPCAT-) (|IndexedAggregate&| . IXAGG-) (|InnerEvalable&| . IEVAL=
AB-) (|IntegerNumberSystem&| . INS-) (|IntegralDomain&| . INTDOM-) (|Keye=
dDictionary&| . KDAGG-) (|LazyStreamAggregate&| . LZSTAGG-) (|LeftAlgebra=
&| . LALG-) (|LieAlgebra&| . LIECAT-) (|LinearAggregate&| . LNAGG-) (|Lis=
tAggregate&| . LSAGG-) (|Logic&| . LOGIC-) (|LinearOrdinaryDifferentialOp=
eratorCategory&| . LODOCAT-) (|MatrixCategory&| . MATCAT-) (|Module&| . M=
ODULE-) (|Monad&| . MONAD-) (|MonadWithUnit&| . MONADWU-) (|Monoid&| . MO=
NOID-) (|MonogenicAlgebra&| . MONOGEN-) (|NonAssociativeAlgebra&| . NAALG=
-) (|NonAssociativeRing&| . NASRING-) (|NonAssociativeRng&| . NARNG-!
) (|OctonionCategory&| . OC-) (|OneDimensionalArrayAggregate&| . A1AGG-) =
(|OrderedRing&| . ORDRING-) (|OrderedSet&| . ORDSET-) (|PartialDifferenti=
alRing&| . PDRING-) (|PolynomialCategory&| . POLYCAT-) (|PolynomialFactor=
izationExplicit&| . PFECAT-) (|PolynomialSetCategory&| . PSETCAT-) (|Powe=
rSeriesCategory&| . PSCAT-) (|QuaternionCategory&| . QUATCAT-) (|Quotient=
FieldCategory&| . QFCAT-) (|RadicalCategory&| . RADCAT-) (|RealClosedFiel=
d&| . RCFIELD-) (|RealNumberSystem&| . RNS-) (|RealRootCharacterizationCa=
tegory&| . RRCC-) (|RectangularMatrixCategory&| . RMATCAT-) (|RecursiveAg=
gregate&| . RCAGG-) (|RecursivePolynomialCategory&| . RPOLCAT-) (|Regular=
TriangularSetCategory&| . RSETCAT-) (|RetractableTo&| . RETRACT-) (|Ring&=
| . RING-) (|SemiGroup&| . SGROUP-) (|SetAggregate&| . SETAGG-) (|SetCate=
gory&| . SETCAT-) (|SquareMatrixCategory&| . SMATCAT-) (|StreamAggregate&=
| . STAGG-) (|StringAggregate&| . SRAGG-) (|TableAggregate&| . TBAGG-) (|=
TranscendentalFunctionCategory&| . TRANFUN-) (|TriangularSetCategory&| . =
TSETCAT-) (|TrigonometricFunctionCategory&| . TRIGCAT-) (|TwoDimensionalA=
rrayCategory&| . ARR2CAT-) (|UnaryRecursiveAggregate&| . URAGG-) (|Unique=
FactorizationDomain&| . UFD-) (|UnivariateLaurentSeriesConstructorCategor=
y&| . ULSCCAT-) (|UnivariatePolynomialCategory&| . UPOLYC-) (|UnivariateP=
owerSeriesCategory&| . UPSCAT-) (|UnivariatePuiseuxSeriesConstructorCateg=
ory&| . UPXSCCA-) (|UnivariateSkewPolynomialCategory&| . OREPCAT-) (|Univ=
ariateTaylorSeriesCategory&| . UTSCAT-) (|VectorCategory&| . VECTCAT-) (|=
VectorSpace&| . VSPACE-)))
+--E 155
+
+--S 156 of 237
+)lisp (identity |$HistList|)
+--R=20
+--RValue =3D #0=3D(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL N=
IL NIL NIL NIL NIL NIL NIL NIL . #0#)
+--E 156
+
+--S 157 of 237
+)lisp (identity |$HistListAct|)
+--R=20
+--RValue =3D 0
+--E 157
+
+--S 158 of 237
+)lisp (identity |$HistListLen|)
+--R=20
+--RValue =3D 20
+--E 158
+
+--S 159 of 237
+)lisp (identity |$HistRecord|)
+--R=20
+--RValue =3D NIL
+--E 159
+
+--S 160 of 237
+)lisp (identity |$inLispVM|)
+--R=20
+--RValue =3D NIL
+--E 160
+
+--S 161 of 237
+)lisp (identity |$inclAssertions|)
+--R=20
+--RValue =3D (AIX |CommonLisp|)
+--E 161
+
+--S 162 of 237
+)lisp (identity |$InitialModemapFrame|)) )
+--R=20
+--RValue =3D ((NIL))
+--E 162
+
+--S 163 of 237
+)lisp (identity in-stream)
+--R=20
+--RValue =3D #<synonym stream to *STANDARD-INPUT*>
+--E 163
+
+--S 164 of 237
+)lisp (identity |$InteractiveMode|)
+--R=20
+--RValue =3D T
+--E 164
+
+--S 165 of 237
+)lisp (identity |$InteractiveFrame| )
+--R=20
+--RValue =3D ((NIL))
+--E 165
+
+--S 166 of 237
+)lisp (identity |$internalHistoryTable|)
+--R=20
+--RValue =3D NIL
+--E 166
+
+--S 167 of 237
+)lisp (identity |$interpreterFrameName|)
+--R=20
+--IValue =3D |frame0|
+--E 167
+
+--S 168 of 237
+)lisp (identity |$interpreterFrameRing|)
+--R=20
+--IValue =3D ((|frame0| ((NIL)) 1 T #0=3D(NIL NIL NIL NIL NIL NIL NIL NI=
L NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL . #00#) 20 0 NIL NI=
L #<vector 08cc0e8c>) (|initial| ((NIL)) 1 T #1=3D(NIL NIL NIL NIL NIL NI=
L NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL . #1#) 20 0=
 NIL NIL #<vector 086b1a48>))
+--E 168
+
+--S 169 of 237
+)lisp (identity |$intRestart|)
+--R=20
+--RValue =3D |restart|
+--E 169
+
+--S 170 of 237
+)lisp (identity |$intTopLevel|)
+--R=20
+--RValue =3D |top_level|
+--E 170
+
+--S 171 of 237
+)lisp (identity |$IOindex| )
+--R=20
+--RValue =3D 1
+--E 171
+
+--S 172 of 237
+)lisp (identity |$JoinOfCatDatabase|)
+--R=20
+--RValue =3D NIL
+--E 172
+
+--S 173 of 237
+)lisp (identity |$JoinOfDomDatabase|)
+--R=20
+--RValue =3D NIL
+--E 173
+
+--S 174 of 237
+)lisp (identity |$lastPos|)
+--R=20
+--RValue =3D (|noposition|)
+--E 174
+
+--S 175 of 237
+)lisp (identity |$lastUntraced|)
+--R=20
+--RValue =3D NIL
+--E 175
+
+--S 176 of 237
+)lisp (identity |$letAssoc| )
+--R=20
+--RValue =3D NIL
+--E 176
+
+--S 177 of 237
+)lisp (identity |$libQuiet|)
+--R=20
+--RValue =3D T
+--E 177
+
+--S 178 of 237
+)lisp (identity $library-directory-list)
+--R=20
+--IValue =3D ("/research/reference/mnt/ubuntu/algebra/")
+--E 178
+
+--S 179 of 237
+)lisp (identity |$localExposureData|)
+--R=20
+--IValue =3D #<vector 08cc0e8c>
+--E 179
+
+--S 180 of 237
+)lisp (identity |$localExposureDataDefault|)
+--R=20
+--IValue =3D #<vector 08a687fc>
+--E 180
+
+--S 181 of 237
+)lisp (identity |$lookupDefaults|)
+--R=20
+--R=20
+--R   >> System error:
+--R   The variable |$lookupDefaults| is unbound.
+--R
+--R   Continuing to read the file...
+--R
+--E 181
+
+--S 182 of 237
+)lisp (identity |$mathmlOutputStream|)
+--R=20
+--RValue =3D #<synonym stream to *TERMINAL-IO*>
+--E 182
+
+--S 183 of 237
+)lisp (identity |$mathTraceList|)
+--R=20
+--RValue =3D NIL
+--E 183
+
+--S 184 of 237
+)lisp (identity |$mkTestInputStack|)
+--R=20
+--RValue =3D NIL
+--E 184
+
+--S 185 of 237
+)lisp (identity |$msgAlist|)
+--R=20
+--RValue =3D NIL
+--E 185
+
+--S 186 of 237
+)lisp (identity |$msgDatabase|)
+--R=20
+--RValue =3D NIL
+--E 186
+
+--S 187 of 237
+)lisp (identity |$msgDatabaseName|)
+--R=20
+--RValue =3D NIL
+--E 187
+
+--S 188 of 237
+)lisp (identity |$ncMsgList|)
+--R=20
+--RValue =3D NIL
+--E 188
+
+--S 189 of 237
+)lisp (identity |$newConlist|)
+--R=20
+--RValue =3D NIL
+--E 189
+
+--S 190 of 237
+)lisp (identity |$NonNullStream| )
+--R=20
+--RValue =3D "NonNullStream"
+--E 190
+
+--S 191 of 237
+)lisp (identity |$nopos|)
+--R=20
+--RValue =3D (|noposition|)
+--E 191
+
+--S 192 of 237
+)lisp (identity |$newcompErrorCount|)
+--R=20
+--RValue =3D 0
+--E 192
+
+--S 193 of 237
+)lisp (identity |$newcompMode|)
+--R=20
+--RValue =3D NIL
+--E 193
+
+--S 194 of 237
+)lisp (identity $newspad)
+--R=20
+--RValue =3D T
+--E 194
+
+--S 195 of 237
+)lisp (identity |$NullStream|)
+--R=20
+--RValue =3D "NullStream"
+--E 195
+
+--S 196 of 237
+)lisp (identity |$okToExecuteMachineCode|)
+--R=20
+--RValue =3D T
+--E 196
+
+--S 197 of 237
+)lisp (identity |$openMathOutputStream|)
+--R=20
+--RValue =3D #<synonym stream to *TERMINAL-IO*>
+--E 197
+
+--S 198 of 237
+)lisp (identity |$operationNameList|)
+--R=20
+--RValue =3D NIL
+--E 198
+
+--S 199 of 237
+)lisp (identity |$outputLibraryName|)
+--R=20
+--RValue =3D NIL
+--E 199
+
+--S 200 of 237
+)lisp (identity |$OutputForm|)
+--R=20
+--RValue =3D (|OutputForm|)
+--E 200
+
+--S 201 of 237
+)lisp (identity |$packages|)
+--R=20
+--R=20
+--R   >> System error:
+--R   The variable |$packages| is unbound.
+--R
+--R   Continuing to read the file...
+--R
+--E 201
+
+--S 202 of 237
+)lisp (identity /pretty)
+--R=20
+--RValue =3D NIL
+--E 202
+
+--S 203 of 237
+)lisp (identity |$previousBindings|)
+--R=20
+--RValue =3D NIL
+--E 203
+
+--S 204 of 237
+)lisp (identity |$PrintCompilerMessageIfTrue|)
+--R=20
+--RValue =3D NIL
+--E 204
+
+--S 205 of 237
+)lisp (identity |$printLoadMsgs| )
+--R=20
+--RValue =3D NIL
+--E 205
+
+--S 206 of 237
+)lisp (identity |$promptMsg|)
+--R=20
+--RValue =3D S2CTP023
+--E 206
+
+--S 207 of 237
+)lisp (identity |$QuickLet)
+--R=20
+--R=20
+--R   >> System error:
+--R   Unexpected end of #<string-input stream from " (identity |$Qui..."=
>.
+--R
+--R   Continuing to read the file...
+--R
+--E 207
+
+--S 208 of 237
+)lisp (identity |$quitTag|)
+--R=20
+--RValue =3D (NIL)
+--E 208
+
+--S 209 of 237
+)lisp (identity $relative-directory-list)
+--R=20
+--RValue =3D ("/../../src/input/" "/doc/msgs/" "/../../src/algebra/" "/.=
./../src/interp/" "/doc/spadhelp/")
+--E 209
+
+--S 210 of 237
+)lisp (identity $relative-library-directory-list)
+--R=20
+--RValue =3D ("/algebra/")
+--E 210
+
+--S 211 of 237
+)lisp (identity |$seen|)
+--R=20
+--R=20
+--R   >> System error:
+--R   The variable |$seen| is unbound.
+--R
+--R   Continuing to read the file...
+--R
+--E 211
+
+--S 212 of 237
+)lisp (identity |$SessionManager|)
+--R=20
+--RValue =3D 1
+--E 212
+
+--S 213 of 237
+)lisp (identity |$setOptions|)
+--R=20
+--RValue =3D ((|breakmode| "execute break processing on error" |interpre=
ter| LITERALS |$BreakMode| (|nobreak| |break| |query| |rresume| |fastlink=
s|) |nobreak|) (|compiler| "Library compiler options" |interpreter| TREE =
|novar| ((|output| "library in which to place compiled code" |interpreter=
| FUNCTION |setOutputLibrary| NIL |htSetOutputLibrary|) (|input| "control=
s libraries from which to load compiled code" |interpreter| FUNCTION |set=
InputLibrary| NIL |htSetInputLibrary|) (|args| "arguments for compiling A=
XIOM code" |interpreter| FUNCTION |setAsharpArgs| (("enter compiler optio=
ns " STRING |$asharpCmdlineFlags| |chkDirectory| "-O -Fasy -Fao -Flsp -la=
xiom -Mno-AXL__W__WillObsolete -DAxiom -Y $AXIOM/algebra")) NIL))) (|expo=
se| "control interpreter constructor exposure" |interpreter| FUNCTION |se=
tExpose| NIL |htSetExpose|) (|functions| "some interpreter function optio=
ns" |interpreter| TREE |novar| ((|cache| "number of function results to c=
ache" |interpreter| FUNCTION |setFunctionsCache| NIL |htSetCache|) (|comp=
ile| "compile, don't just define function bodies" |interpreter| LITERALS =
|$compileDontDefineFunctions| (|on| |off|) |on|) (|recurrence| "specially=
 compile recurrence relations" |interpreter| LITERALS |$compileRecurrence=
| (|on| |off|) |on|))) (|fortran| "view and set options for FORTRAN outpu=
t" |interpreter| TREE |novar| ((|ints2floats| "where sensible, coerce int=
egers to reals" |interpreter| LITERALS |$fortInts2Floats| (|on| |off|) |o=
n|) (|fortindent| "the number of characters indented" |interpreter| INTEG=
ER |$fortIndent| (0 NIL) 6) (|fortlength| "the number of characters on a =
line" |interpreter| INTEGER |$fortLength| (1 NIL) 72) (|typedecs| "print =
type and dimension lines" |interpreter| LITERALS |$printFortranDecs| (|on=
| |off|) |on|) (|defaulttype| "default generic type for FORTRAN object" |=
interpreter| LITERALS |$defaultFortranType| (REAL INTEGER COMPLEX LOGICAL=
 CHARACTER) REAL) (|precision| "precision of generated FORTRAN objects" |=
interpreter| LITERALS |$fortranPrecision| (|single| |double|) |double|)!
 (|intrinsic| "whether to use INTRINSIC FORTRAN functions" |interpreter| =
LITERALS |$useIntrinsicFunctions| (|on| |off|) |off|) (|explength| "chara=
cter limit for FORTRAN expressions" |interpreter| INTEGER |$maximumFortra=
nExpressionLength| (0 NIL) 1320) (|segment| "split long FORTRAN expressio=
ns" |interpreter| LITERALS |$fortranSegment| (|on| |off|) |on|) (|optleve=
l| "FORTRAN optimisation level" |interpreter| INTEGER |$fortranOptimizati=
onLevel| (0 2) 0) (|startindex| "starting index for FORTRAN arrays" |inte=
rpreter| INTEGER |$fortranArrayStartingIndex| (0 1) 1) (|calling| "option=
s for external FORTRAN calls" |interpreter| TREE |novar| ((|tempfile| "se=
t location of temporary data files" |interpreter| FUNCTION |setFortTmpDir=
| (("enter directory name for which you have write-permission" DIRECTORY =
|$fortranTmpDir| |chkDirectory| "/tmp/")) NIL) (|directory| "set location=
 of generated FORTRAN files" |interpreter| FUNCTION |setFortDir| (("enter=
 directory name for which you have write-permission" DIRECTORY |$fortranD=
irectory| |chkDirectory| "./")) NIL) (|linker| "linker arguments (e.g. li=
braries to search)" |interpreter| FUNCTION |setLinkerArgs| (("enter linke=
r arguments " STRING |$fortranLibraries| |chkDirectory| "-lxlf")) NIL))))=
) (|kernel| "library functions built into the kernel for efficiency" |int=
erpreter| TREE |novar| ((|warn| "warn when re-definition is attempted" |i=
nterpreter| FUNCTION |protectedSymbolsWarning| NIL |htSetKernelWarn|) (|p=
rotect| "prevent re-definition of kernel functions" |interpreter| FUNCTIO=
N |protectSymbols| NIL |htSetKernelProtect|))) (|hyperdoc| "options in us=
ing HyperDoc" |interpreter| TREE |novar| ((|fullscreen| "use full screen =
for this facility" |interpreter| LITERALS |$fullScreenSysVars| (|on| |off=
|) |off|) (|mathwidth| "screen width for history output" |interpreter| IN=
TEGER |$historyDisplayWidth| (0 NIL) 120))) (|help| "view and set some he=
lp options" |interpreter| TREE |novar| ((|fullscreen| "use fullscreen fac=
ility, if possible" |interpreter| LITERALS |$useFullScreenHelp| (|on!
| |off|) |off|))) (|history| "save workspace values in a history file" |i=
nterpreter| LITERALS |$HiFiAccess| (|on| |off|) |on|) (|messages| "show m=
essages for various system features" |interpreter| TREE |novar| ((|any| "=
print the internal type of objects of domain Any" |interpreter| LITERALS =
|$printAnyIfTrue| (|on| |off|) |on|) (|autoload| "print file auto-load me=
ssages" |interpreter| LITERALS |$printLoadMsgs| (|on| |off|) |on|) (|bott=
omup| "display bottom up modemap selection" |development| LITERALS |$repo=
rtBottomUpFlag| (|on| |off|) |off|) (|coercion| "display datatype coercio=
n messages" |development| LITERALS |$reportCoerceIfTrue| (|on| |off|) |of=
f|) (|dropmap| "display old map defn when replaced" |interpreter| LITERAL=
S |$displayDroppedMap| (|on| |off|) |off|) (|expose| "warning for unexpos=
ed functions" |interpreter| LITERALS |$giveExposureWarning| (|on| |off|) =
|off|) (|file| "print msgs also to SPADMSG LISTING" |development| LITERAL=
S |$printMsgsToFile| (|on| |off|) |off|) (|frame| "display messages about=
 frames" |interpreter| LITERALS |$frameMessages| (|on| |off|) |off|) (|hi=
ghlighting| "use highlighting in system messages" |interpreter| LITERALS =
|$highlightAllowed| (|on| |off|) |off|) (|instant| "present instantiation=
 summary" |development| LITERALS |$reportInstantiations| (|on| |off|) |of=
f|) (|insteach| "present instantiation info" |development| LITERALS |$rep=
ortEachInstantiation| (|on| |off|) |off|) (|interponly| "say when functio=
n code is interpreted" |interpreter| LITERALS |$reportInterpOnly| (|on| |=
off|) |on|) (|naglink| "show NAGLink messages" |interpreter| LITERALS |$n=
agMessages| (|on| |off|) |on|) (|number| "display message number with mes=
sage" |interpreter| LITERALS |$displayMsgNumber| (|on| |off|) |off|) (|pr=
ompt| "set type of input prompt to display" |interpreter| LITERALS |$inpu=
tPromptType| (|none| |frame| |plain| |step| |verbose|) |step|) (|selectio=
n| "display function selection msgs" |interpreter| LITERALS |$reportBotto=
mUpFlag| (|on| |off|) |off|) (|set| "show )set setting after assignm!
ent" |interpreter| LITERALS |$displaySetValue| (|on| |off|) |off|) (|star=
tup| "display messages on start-up" |interpreter| LITERALS |$displayStart=
Msgs| (|on| |off|) |on|) (|summary| "print statistics after computation" =
|interpreter| LITERALS |$printStatisticsSummaryIfTrue| (|on| |off|) |off|=
) (|testing| "print system testing header" |development| LITERALS |$testi=
ngSystem| (|on| |off|) |off|) (|time| "print timings after computation" |=
interpreter| LITERALS |$printTimeIfTrue| (|on| |off| |long|) |off|) (|typ=
e| "print type after computation" |interpreter| LITERALS |$printTypeIfTru=
e| (|on| |off|) |on|) (|void| "print Void value when it occurs" |interpre=
ter| LITERALS |$printVoidIfTrue| (|on| |off|) |off|))) (|naglink| "option=
s for NAGLink" |interpreter| TREE |novar| ((|host| "internet address of h=
ost for NAGLink" |interpreter| FUNCTION |setNagHost| (("enter host name" =
DIRECTORY |$nagHost| |chkDirectory| "localhost")) NIL) (|persistence| "nu=
mber of (fortran) functions to remember" |interpreter| FUNCTION |setFortP=
ers| (("Requested remote storage (for asps):" INTEGER |$fortPersistence| =
(0 NIL) 10)) NIL) (|messages| "show NAGLink messages" |interpreter| LITER=
ALS |$nagMessages| (|on| |off|) |on|) (|double| "enforce DOUBLE PRECISION=
 ASPs" |interpreter| LITERALS |$nagEnforceDouble| (|on| |off|) |on|))) (|=
output| "view and set some output options" |interpreter| TREE |novar| ((|=
abbreviate| "abbreviate type names" |interpreter| LITERALS |$abbreviateTy=
pes| (|on| |off|) |off|) (|algebra| "display output in algebraic form" |i=
nterpreter| FUNCTION |setOutputAlgebra| (("display output in algebraic fo=
rm" LITERALS |$algebraFormat| (|off| |on|) |on|) (BREAK $ALGEBRAFORMAT) (=
"where algebra printing goes (enter {em console} or a pathname)?" FILENAM=
E |$algebraOutputFile| |chkOutputFileName| "console")) NIL) (|characters|=
 "choose special output character set" |interpreter| FUNCTION |setOutputC=
haracters| NIL |htSetOutputCharacters|) (|fortran| "create output in FORT=
RAN format" |interpreter| FUNCTION |setOutputFortran| (("create outp!
ut in FORTRAN format" LITERALS |$fortranFormat| (|off| |on|) |off|) (|bre=
ak| |$fortranFormat|) ("where FORTRAN output goes (enter {em console} or =
a a pathname)" FILENAME |$fortranOutputFile| |chkOutputFileName| "console=
")) NIL) (|fraction| "how fractions are formatted" |interpreter| LITERALS=
 |$fractionDisplayType| (|vertical| |horizontal|) |vertical|) (|length| "=
line length of output displays" |interpreter| INTEGER $LINELENGTH (10 245=
) 77) (|mathml| "create output in MathML style" |interpreter| FUNCTION |s=
etOutputMathml| (("create output in MathML format" LITERALS |$mathmlForma=
t| (|off| |on|) |off|) (|break| |$mathmlFormat|) ("where MathML output go=
es (enter {em console} or a pathname)" FILENAME |$mathmlOutputFile| |chkO=
utputFileName| "console")) NIL) (|openmath| "create output in OpenMath st=
yle" |interpreter| FUNCTION |setOutputOpenMath| (("create output in OpenM=
ath format" LITERALS |$openMathFormat| (|off| |on|) |off|) (|break| |$ope=
nMathFormat|) ("where TeX output goes (enter {em console} or a pathname)"=
 FILENAME |$openMathOutputFile| |chkOutputFileName| "console")) NIL) (|sc=
ript| "display output in SCRIPT formula format" |interpreter| FUNCTION |s=
etOutputFormula| (("display output in SCRIPT format" LITERALS |$formulaFo=
rmat| (|off| |on|) |off|) (|break| |$formulaFormat|) ("where script outpu=
t goes (enter {em console} or a a pathname)" FILENAME |$formulaOutputFile=
| |chkOutputFileName| "console")) NIL) (|scripts| "show subscripts,... li=
nearly" |interpreter| LITERALS |$linearFormatScripts| (|on| |off|) |off|)=
 (|showeditor| "view output of )show in editor" |interpreter| LITERALS |$=
useEditorForShowOutput| (|on| |off|) |off|) (|tex| "create output in TeX =
style" |interpreter| FUNCTION |setOutputTex| (("create output in TeX form=
at" LITERALS |$texFormat| (|off| |on|) |off|) (|break| |$texFormat|) ("wh=
ere TeX output goes (enter {em console} or a pathname)" FILENAME |$texOut=
putFile| |chkOutputFileName| "console")) NIL))) (|quit| "protected or unp=
rotected quit" |interpreter| LITERALS |$quitCommandType| (|protected!
| |unprotected|) |protected|) (|streams| "set some options for working wi=
th streams" |interpreter| TREE |novar| ((|calculate| "specify number of e=
lements to calculate" |interpreter| FUNCTION |setStreamsCalculate| (("num=
ber of initial stream elements you want calculated" INTEGER |$streamCount=
| (0 NIL) 10)) NIL) (|showall| "display all stream elements computed" |in=
terpreter| LITERALS |$streamsShowAll| (|on| |off|) |off|))) (|system| "se=
t some system development variables" |development| TREE |novar| ((|functi=
oncode| "show gen. LISP for functions when compiled" |development| LITERA=
LS |$reportCompilation| (|on| |off|) |off|) (|optimization| "show optimiz=
ed LISP code" |development| LITERALS |$reportOptimization| (|on| |off|) |=
off|) (|prettyprint| "prettyprint BOOT func's as they compile" |developme=
nt| LITERALS $PRETTYPRINT (|on| |off|) |on|))) (|userlevel| "operation ac=
cess level of system user" |interpreter| LITERALS |$UserLevel| (|interpre=
ter| |compiler| |development|) |development|))
+--E 213
+
+--S 214 of 237
+)lisp (identity |$shoeReadLineFunction|)
+--R=20
+--RValue =3D #<compiled-function |serverReadLine|>
+--E 214
+
+--S 215 of 237
+)lisp (identity |$slamFlag|)
+--R=20
+--RValue =3D NIL
+--E 215
+
+--S 216 of 237
+)lisp (identity /sourcefiles)
+--R=20
+--RValue =3D NIL
+--E 216
+
+--S 217 of 237
+)lisp (identity |$sourceFiles|)
+--R=20
+--RValue =3D NIL
+--E 217
+
+--S 218 of 237
+)lisp (identity /spacelist)
+--R=20
+--RValue =3D NIL
+--E 218
+
+--S 219 of 237
+)lisp (identity $spad)
+--R=20
+--RValue =3D T
+--E 219
+
+--S 220 of 237
+)lisp (identity $spadroot)
+--R=20
+--IValue =3D "/research/reference/mnt/ubuntu"
+--E 220
+
+--S 221 of 237
+)lisp (identity |$texOutputStream|)
+--R=20
+--RValue =3D #<synonym stream to *TERMINAL-IO*>
+--E 221
+
+--S 222 of 237
+)lisp (identity /timerlist)
+--R=20
+--RValue =3D NIL
+--E 222
+
+--S 223 of 237
+)lisp (identity |$timerTicksPerSecond|)
+--R=20
+--RValue =3D 100
+--E 223
+
+--S 224 of 237
+)lisp (identity |$tracedMapSignatures|)
+--R=20
+--RValue =3D NIL
+--E 224
+
+--S 225 of 237
+)lisp (identity |$tracedModemap|)
+--R=20
+--RValue =3D NIL
+--E 225
+
+--S 226 of 237
+)lisp (identity |$tracedSpadModemap|)
+--R=20
+--RValue =3D NIL
+--E 226
+
+--S 227 of 237
+)lisp (identity |$traceErrorStack|)
+--R=20
+--R=20
+--R   >> System error:
+--R   The variable |$traceErrorStack| is unbound.
+--R
+--R   Continuing to read the file...
+--R
+--E 227
+
+--S 228 of 237
+)lisp (identity $traceletflag)
+--R=20
+--RValue =3D NIL
+--E 228
+
+--S 229 of 237
+)lisp (identity |$traceletFunctions|)
+--R=20
+--RValue =3D NIL
+--E 229
+
+--S 230 of 237
+)lisp (identity |$undoFlag|)
+--R=20
+--RValue =3D T
+--E 230
+
+--S 231 of 237
+)lisp (identity |$useFullScreenHelp|)
+--R=20
+--RValue =3D NIL
+--E 231
+
+--S 232 of 237
+)lisp (identity |$UserAbbreviationsAlist|)
+--R=20
+--RValue =3D NIL
+--E 232
+
+--S 233 of 237
+)lisp (identity |$variableNumberAlist|)
+--R=20
+--RValue =3D NIL
+--E 233
+
+--S 234 of 237
+)lisp (identity |$Void|)
+--R=20
+--RValue =3D (|Void|)
+--E 234
+
+--S 235 of 237
+)lisp (identity |$writifyComplained|)
+--R=20
+--R=20
+--R   >> System error:
+--R   The variable |$writifyComplained| is unbound.
+--R
+--R   Continuing to read the file...
+--R
+--E 235
+
+--S 236 of 237
+)lisp (identity /wsname)
+--R=20
+--RValue =3D NOBOOT
+--E 236
+
+--S 237 of 237
+)lisp (identity |$xdatabase|)
+--R=20
+--RValue =3D NIL
+--E 237
+
+
+)spool
+=20
+
+
+)spool
+)lisp (bye)
+=20
+@
+\eject
+\begin{thebibliography}{99}
+\bibitem{1} nothing
+\end{thebibliography}
+\end{document}
diff --git a/src/interp/comp.lisp.pamphlet b/src/interp/comp.lisp.pamphle=
t
index f822aad..9e9deed 100644
--- a/src/interp/comp.lisp.pamphlet
+++ b/src/interp/comp.lisp.pamphlet
@@ -73,7 +73,6 @@
=20
 (defparameter FluidVars nil)
 (defparameter LocVars nil)
-; (defparameter OptionList nil) defined in nlib.lisp
 (defparameter SpecialVars nil)
=20
 (defun |compAndDefine| (L)
@@ -83,15 +82,6 @@
=20
 (defun COMP (L) (MAPCAR #'COMP-2 (MAPCAN #'COMP-1 L)))
=20
-;;(defun |compQuietly| (L)
-;;  (let (U CUROUTSTREAM)
-;;    (declare (special CUROUTSTREAM))
-;;    (ADDOPTIONS 'LISTING NULLOUTSTREAM)                    =20
-;;    (SETQ CUROUTSTREAM NULLOUTSTREAM)                      =20
-;;    (setq U (COMP L))
-;;    (setq OPTIONLIST (CDDR OPTIONLIST))
-;;    U))
-
 (defun |compQuietly| (fn)
   (let ((*comp370-apply*
 	 (if |$InteractiveMode|
@@ -103,32 +93,6 @@
 	   *standard-output*)))
     (COMP fn)))
=20
-#-:CCL
-(defun |compileFileQuietly| (fn)=20
-  (let (
-     ;; following creates a null outputstream if $InteractiveMode
-	(*standard-output*
-	 (if |$InteractiveMode| (make-broadcast-stream)
-	   *standard-output*)))
-    (COMPILE-FILE fn)))
-
-#+:CCL
-(defun |compileFileQuietly| (fn)
-  (let (
-     ;; following creates a null outputstream if $InteractiveMode
-     (*standard-output*
-       (if |$InteractiveMode| (make-broadcast-stream) *standard-output*)=
))
-     ;; The output-library is not opened before use unless set explicitl=
y
-     (if (null output-library)
-         (|openOutputLibrary|=20
-           (setq |$outputLibraryName|
-            (if (null |$outputLibraryName|)
-                (make-pathname :directory (get-current-directory)
-                               :name "user.lib")
-                (if (filep |$outputLibraryName|) (truename |$outputLibra=
ryName|)
-                                                 |$outputLibraryName|)))=
))
-     (compile-lib-file fn)))
-
 ;; The following are used mainly in setvars.boot
 (defun notEqualLibs (u v)
   (if (string=3D u (library-name v)) (seq (close-library v) t) nil))
@@ -147,19 +111,6 @@
   (|dropInputLibrary| lib)
    (setq input-libraries (cons (open-library lib) input-libraries)) )
=20
-
-
-;;(defun |compileQuietly| (L) (PROG (U CUROUTSTREAM)
-;;  ;; calls lisp system COMPILE or DEFINE                 =20
-;;  (ADDOPTIONS 'QUIET 'T)                                 =20
-;;  (ADDOPTIONS 'LISTING NULLOUTSTREAM)                    =20
-;;  (SETQ CUROUTSTREAM NULLOUTSTREAM)                      =20
-;;  (SETQ U (COND                                          =20
-;;    (|$compileDontDefineFunctions| (COMPILE L))          =20
-;;    ('T (DEFINE L))))                                    =20
-;;  (SETQ OPTIONLIST (CDDR OPTIONLIST))                    =20
-;;  (RETURN U)   ))                                      =20
-
 (defun |compileQuietly| (fn)
   (let ((*comp370-apply*
 	 (if |$InteractiveMode|



From MAILER-DAEMON Mon Mar 30 23:56:54 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LoV5q-0007Nq-I5
	for mharc-axiom-developer@gnu.org; Mon, 30 Mar 2009 23:56:54 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LoV5o-0007Na-Bk
	for axiom-developer@nongnu.org; Mon, 30 Mar 2009 23:56:52 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LoV5k-0007Mh-Nt
	for axiom-developer@nongnu.org; Mon, 30 Mar 2009 23:56:52 -0400
Received: from [199.232.76.173] (port=41682 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LoV5k-0007Me-KV
	for axiom-developer@nongnu.org; Mon, 30 Mar 2009 23:56:48 -0400
Received: from joseki.proulx.com ([216.17.153.58]:44524)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <mlmgr@proulx.com>) id 1LoV5k-0007HF-4I
	for axiom-developer@nongnu.org; Mon, 30 Mar 2009 23:56:48 -0400
Received: by joseki.proulx.com (Postfix, from userid 1021)
	id A9247FA72; Mon, 30 Mar 2009 21:56:47 -0600 (MDT)
Resent-From: mlmgr@proulx.com
Resent-Date: Mon, 30 Mar 2009 21:56:47 -0600
Resent-Message-ID: <20090331035647.GA11723@joseki.proulx.com>
Resent-To: axiom-developer@nongnu.org
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LoTYC-0006TM-QS
	for axiom-developer@nongnu.org; Mon, 30 Mar 2009 22:18:04 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LoTY8-0006SV-I4
	for axiom-developer@nongnu.org; Mon, 30 Mar 2009 22:18:04 -0400
Received: from [199.232.76.173] (port=44745 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LoTY8-0006SS-DM
	for axiom-developer@nongnu.org; Mon, 30 Mar 2009 22:18:00 -0400
Received: from mailer.coconet.de ([194.173.70.11]:36936)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <Michael.Becker@coconet.de>) id 1LoTY8-0008As-1X
	for axiom-developer@nongnu.org; Mon, 30 Mar 2009 22:18:00 -0400
Received: from mail-ccn.coconet.de (mail-ccn.coconet.de [172.20.0.6])
	by mailer.coconet.de (Postfix) with ESMTP id 04D882DFBE
	for <axiom-developer@nongnu.org>; Tue, 31 Mar 2009 04:17:59 +0200 (CEST)
Received: from strolch.coconet.de ([172.20.0.153]) by mail-ccn.coconet.de with
	Microsoft SMTPSVC(6.0.3790.3959); Tue, 31 Mar 2009 04:17:54 +0200
From: Michael Becker <Michael.Becker@coconet.de>
X-MimeOLE: Produced By Microsoft MimeOLE V6.00.3790.4325
To: axiom-developer@nongnu.org
User-Agent: KMail/1.7.1
MIME-Version: 1.0
Content-Disposition: inline
Date: Tue, 31 Mar 2009 04:17:53 +0200
Content-Type: text/plain;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable
Message-ID: <200903310417.53947.Michael.Becker@coconet.de>
X-OriginalArrivalTime: 31 Mar 2009 02:17:54.0418 (UTC)
	FILETIME=[E65AFD20:01C9B1A6]
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6,
	seldom 2.4 (older, 4)
X-detected-operating-system: by monty-python.gnu.org: Genre and OS details not
	recognized.
Resent-Date: Mon, 30 Mar 2009 23:56:52 -0400
Subject: [Axiom-developer] solved:  build from source failure
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Tue, 31 Mar 2009 03:56:52 -0000


        hi,

        my directory "$AXIOM" contained a symbolic link.=20
        i replaced the symbolic link and the build process runs fine.


        M.Becker
        =20



-------------------------------------------------------------------------=
-----------=20
Diese Nachricht k=F6nnte vertrauliche und/oder rechtlich
gesch=FCtzte Informationen enthalten. Wenn Sie nicht der
Adressat dieser Email sind oder nicht autorisiert sind, diese
f=FCr den Adressaten entgegenzunehmen, so ist es untersagt,
diese Nachricht oder in ihr enthaltene Informationen zu nutzen,
zu kopieren, offen zu legen oder anderweitig weiterzuverarbeiten.
Sollten Sie diese Nachricht f=E4lschlicherweise erhalten haben,
verst=E4ndigen Sie den Absender bitte unverz=FCglich per Antwort auf
diese Mail und l=F6schen sie diese anschlie=DFend.
Vielen Dank f=FCr Ihre Kooperation.
-------------------------------------------------------------------------=
-----------=20
This message may contain confidential and/or privileged=20
information. If you are not the addressee or authorized=20
to receive this for the addressee, you must not use, copy,=20
disclose or take any action based on this message or any=20
information herein. If you have received this message in=20
error, please advise the sender immediately by reply e-mail=20
and delete this message. Thank you for your co-operation.=20
-------------------------------------------------------------------------=
-----------=20
We make your business move.=20







