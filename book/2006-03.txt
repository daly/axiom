\start
Date: Tue, 28 Feb 2006 15:41:29 +0100
From: Gregory Vanuxem
To: Bill Page
Subject: RE: Compiler coercion and DoubleFloat

Hi,


> If I set $useBFasDefault in the Axiom interpreter I get the
> following error:
> 
> (1) -> )boot $useBFasDefault:=false
> (SPADLET |$useBFasDefault| NIL)
> Value = NIL
> (1) -> two4: DoubleFloat := 24.0
> 
>    >> System error:
>    Caught fatal error [memory may be damaged]
> 
> protected-symbol-warn called with (NIL)

The interpreter parser is different from the spad parser.
The bug is probably in the float2Sex function (parsing of real numbers
in the interpreter):

bfForm := MAKE_-FLOAT(intPart, READ_-FROM_-STRING fracPartString,
  LENGTH fracPartString, expPart)
[., frac, :exp] := bfForm
^^^^^^^^^^^^^^^

and MAKE-FLOAT returns a simple double float and not the (default)
BF "property", mantissa and exponent.

\start
Date: Tue, 28 Feb 2006 10:40:40 +0100
From: Ralf Hemmecke
To: Bill Page
Subject: Re: Bug in Tuple
Cc: Stephen Watt

On 02/27/2006 09:57 PM, Bill Page wrote:
> Ralf,
> 
> On February 25, 2006 4:22 PM you wrote:
>> Can someone explain that?
>>
>> Ralf
>>
>> (6) -> Tuple(Integer) has coerce: Tuple(Integer)->PrimitiveArrayInteger
>>
>>     (6)  false
>>                                                               
>>    Type: Boolean
> 
> I presume what you meant to write was:
> 
>   Tuple(Integer) has coerce:Tuple(Integer)->PrimitiveArray(Integer)
> 
> and that something like this might be possible in Aldor, right?

Well, I should have written something like

Tuple(Integer) has with {length: % -> MachineInteger}

but that doesn't work in Axiom either. And the reason in my eyes is that 
  I cannot remember that there exists a description of SPAD/Axiom that 
covers something like http://www.aldor.org/docs/HTML/chap7.html#9.

But try in Aldor...

aldor -gloop
#include "aldor"
#include "aldorinterp"
%3 >> Tuple Integer
   () @ Join(
  with
     ==  add ()
,
  with
         element: (%, MachineInteger) -> AldorInteger
         dispose!: % -> ()
         length: % -> MachineInteger
         tuple: (MachineInteger, Pointer) -> %
     ==  add ()
)
T%4 >> Tuple(Integer) has with {length: % -> MachineInteger}
T @ Boolean

> However the result the Axiom interpreter returns is still 'false'.

> So far as I can tell from the available Axiom documentation the
> 'has' expression only allows categories and axioms on the right
> hand side (rhs). So we can write:
> 
>   Tuple(Integer) has CoercibleTo(OuputForm)
>
> and
> 
>   Integer has commutative("*")
> 
> but almost anything else on the rhs returns either 'false' or
> an error message. You might have expected to be able to write:
> 
> (14) -> Tuple(Integer) has with Tuple(Integer)->PrimitiveArray(Integer)
>    Internal Error
>    Unexpected error in call to system function pf2Sex1
> 
> but that apparently doesn't work either. :(

Well, you probably meant:

Tuple(Integer) has with coerce: %->PrimitiveArray(Integer)

However, you agree, that the "with" expression *is* a category.

> Just as in Aldor different things might be possible in SPAD, but
> I was't able to find any documentation about this.

Right, Axiom is a bit weak here. But since we are (hopefully) agree to 
take Aldor for further development, then this is not such a big problem. 
The only point is that Axiom (as interpreter) should behave according to 
the Aldor language specification.

BTW, you cannot simply write something like

define MyCat: Category == with {
   +: (%, %) -> %;
   Commutative(+);
}

in Aldor, since that "commutative" is interpreted as a function with one 
argument and it should return a category. So you would have to write 
another category

define Commutative(f: (%, %) -> %): Category == with;

But that doesn't work since it is not clear what % refers to.

But you can at least compile the following:
--BEGIN
#include "aldor"
define Commutative(T: Type, f: (T, T) -> T): Category == with;
define CommutativePlus: Category == with {
   +: (%, %) -> %;
   Commutative(%, +);
}
--END

What is the problem here? Look at the definition of "Commutative".
Shouldn't Aldor allow me to write something like

--BEGIN
#include "aldor"
define Commutative(T: Type, f: (T, T) -> T): Category == {
   n: Integer := 1$Integer; while n>0 repeat n:=n+1;
   with;
}
define PlusCat: Category == with {
   +: (%, %) -> %;
   *: (%, %) -> %;
   Commutative(%, +);
}

Dom: PlusCat == add {
	(x: %) + (y: %): % == x;
	(x: %) * (y: %): % == y;
}

main(): () == {
	import from Dom;
	import from TextWriter, String, Character;
	b: Boolean == Dom has Commutative(Dom, +$Dom);
	stdout << "Dom has Commutative(Dom, +) = " << b << newline;
	c: Boolean == Dom has Commutative(Dom, *$Dom);
	stdout << "Dom has Commutative(Dom, *) = " << c << newline;
}
main();
--END

Yes, this file compiles and runs successfully.
aldor -grun -laldor comm.as
Dom has Commutative(Dom, +) = T
Dom has Commutative(Dom, *) = T

How could this program stop? In fact, already the compiler has to 
perform an evaluation of "Commutativive(%, +)", so it could never have 
produced the program. And why T is returned for "*"?

Very strange. Can somebody explain?

\start
Date: Tue, 28 Feb 2006 03:33:41 -0600
From: MathAction (wyscc)
To: MathAction
Subject: [DistributedMultivariatePolynomial] 

Bill Page wrote:

> I find your notation a little confusing. In Axiom notation I think you mean, for example:

There is nothing confusing about my notation in $R[x]$ where $R$ can be any integral domain (or even ring). The $x$ is transcendental over $R$ by the definition of polynomial ring. $R$ can be INT, or EXPR INT, POLY INT or what have you. $x$ is NEVER going to be in the ground coefficient ring if you are talking about polynomials in x (see PS below for a proof). You are confused because you refuse to accept the definition of polynomial ring. You, confused by the Interpreter, keep saying that an indeterminate $x$ can be an element of the coefficient ring. That is a violation of a universally accepted mathematical definition. On the opther hand, the Interpreter only errs in not catching your mistake. It did NOT coerce something from $R[x]$ that involves $x$ into $R$. There is simply no such coerce map in Axiom!

$Q(R[x])$ is the quotient field of the polynomial ring. It is the field of rational functions in one indeterminate $x$ with coefficients in $R$. $R$ can be any integral domain, including a field. That is why $Q(R[x]) = Q(Q(R)[x])$ (more precisely, isomorphic). In Axiom, this would be 'FRAC DMP([x], R)' is isomorphic to 'FRAC (DMP([x], FRAC R)' (and Axiom provides facilities to convert one into the other; I believe Aldor's compiler even knows about these "tower rearrangements"). In the examples under discussion, $R$ would be 'POLY INT', or 'FRAC POLY INT', but not 'INT'. But it is still true that the main variable of 'DMP([x], R)' cannot belong to 'R = POLY INT'.

>It is only when we coerce $Q(R[x])[x]$ ...

Your notation $Q(R[x])[x]$ is either meaningless (in case you think of the last $x$ as transcendental over the field $Q(R[x])$) or it is identical to $Q(R[x])$  as a mathematical object (in case you adjoin the *same* $x$ to the field of rational functions over $R$.)  It cannot mean both and in any case, this is the wrong way to notate what you meant. You should have used $Q(R[x])[y]$ where $y$ is another indeterminate independent over $Q(R[x])$.  We cannot *coerce* $Q(R[x])[y]$ into $Q(R[x])$ no matter what $R$ is since $y$ is transcendental over $Q(R[x])$. We can only *substitute* $x$ for $y$ so that any $f(x,y)$ evaluates to $f(x,x)$.  This is the substitution I was talking about and what FRAC2 implements. Unfortunately, looking at the code will only give you a more general "lifting" map. The substitution is actually given by the input 'A->B' in 'map' and supplied by the Interpreter in its automatic "coercion" magic.  The function 'map(f:A->B, A, B)' in the example of $A =!
 R[x,y]$, $B = R[x]$ and $f(x)=x, f(y)=y$ will map $\frac{1}{y} \times x$ to $1$. This is what you see done by the Interpreter. Unfortunately, the user insists using $x$ instead of $y$ as in
'monomial(x,0)$DMP([x], POLY INT)'. The correct way this:

\begin{axiom}
f:=monomial(y,0)$DMP([x], POLY INT)
subst(1/f*x, y=x)
\end{axiom}

William

PS. Let me define a univariate polynomial over a unitary ring $R$ where $0 \neq 1$, as an infinite sequence (function with finite support) from $N$ (the natural numbers) to $R$ and the polynomial ring as the totality of all polynomials. Then the indeterminate, let us call it $x$, will be the sequence represented by the function $f_x: N \rightarrow R$ where $f_x(1) = 1$ and $f_x(n) = 0$ for $n \neq 1$. An element $a \in R$ is identified as the function $f_a$ where $f_a(0)= a$ and $f_a(n)=0$ for $n \neq 0$. From this we see that $f_x \neq f_a$ for any $a \in R$ since $f_a(1) \neq f_x(1)$. So, there is no way one can *coerce* $f_x$ to $R$, no matter what $R$ is. We don't even need to know that $f_x$ is transcendental over $R$. We can only make a substitution to replace $f_x$ by some $f_a$ (or evaluation at $a$).

\start
Date: Tue, 28 Feb 2006 15:10:25 +0100
From: Gregory Vanuxem
To: Bill Page
Subject: RE: Compiler coercion and DoubleFloat

Hi,


Le mardi 28 f=E9vrier 2006 =E0 01:00 +0100, Bill Page a =E9crit :

> That's cool.
>
> Does '$useBFasDefault:=false' globally change the representation
> of DoubleFloat to lisp double-float?

No, the representation of DoubleFloat is already a lisp
double-float as far as i know.

> What is the advantage of lisp double-float over Axiom's
> DoubleFloat? Higher precision?
>
> (1) -> precision()$Float
>
>    (1)  68
>    Type: PositiveInteger
>
> Precisioni of Float is adjustable but the following are fixed.
>
> (2) -> precision()$DoubleFloat
>
>    (2)  53
>    Type: PositiveInteger
>
> (3) -> precision()$MachineFloat
>
>    (3)  16
>    Type: PositiveInteger
>
> -------
>
> If I set $useBFasDefault in the Axiom interpreter I get the
> following error:
>
> (1) -> )boot $useBFasDefault:=false
> (SPADLET |$useBFasDefault| NIL)
> Value = NIL
> (1) -> two4: DoubleFloat := 24.0
>
>    >> System error:
>    Caught fatal error [memory may be damaged]
>
> protected-symbol-warn called with (NIL)

Yes I have seen and i don't know why.
It isn't a problem for me since i change the value
of $useBFasDefault only in spad code and revert it at the end of
the code (i.e. just for the 'translation' of spad into lisp).

> -------
>
> So I suppose you have some specific application of this in the
> SPAD compiler?

\start
Date: Wed, 1 Mar 2006 09:49:09 +0100
From: David Mentre
To: Gabriel Dos Reis
Subject: Renaming at inheritance (was: Re: Curiosities with Axiom mathematical structures)

Hello,

27 Feb 2006 17:08:27 +0100, Gabriel Dos Reis=
:
> | One reason for having Monoid and AbelianMoniod (one with "*" and the
> | other with "+") is that neither SPAD nor Aldor allows to rename
> | functions during inheritance.
>
> yes, that is true for many (all?) object-oriented languages.

Not all, Eiffel can rename methods when inheriting:

http://www.maths.tcd.ie/~odunlain/eiffel/intro.html
"""
   class C inherit

        A rename x as x1, y as y1 end;

        B rename x as x2, y as y2 end

  feature...

Here, if both A and B have features named x and y, class C would be
invalid without the renaming.

Renaming also serves to provide more appropriate feature names in
descendants. For example, class WINDOW may inherit a routine
insert_subtree from TREE. For clients of WINDOW, however, such a
routine name is no longer appropriate. An application using this class
for window manipulation needs coherent window terminology, and should
not be concerned with the inheritance structure that led to the
implementation of the class. So you may wish to rename insert_subtree
as add_subwindow in the inheritance clause of WINDOW.
"""

\start
Date: 01 Mar 2006 09:56:02 +0100
From: Francois Maltey
To: Francois Maltey
Subject: Re: Curiosities with Axiom mathematical structures

Hello,

It seems I can define binary operator with the underscore _
in any *.spad file.

Are the name of the operator are fixed in the compiler or not ?
Can I define my own new operator azerty or not ?
  for computing 1 azerty 2 azerty 3 azerty 4 without problem.
Can I define my own factorial with ! or not ?
  the ! operator is a postfix one.     3!
  but the - operator is a prefix one. -3

Why are there 2 underscore in _/_\ in boolean.spad ?

Logic: Category == BasicType with
       _~:        % -> %
        ++ ~(x) returns the logical complement of x.
       _/_\:       (%, %) -> %
        ++ \spadignore { /\ }returns the logical `meet', e.g. `and'.
       _\_/:       (%, %) -> %
        ++ \spadignore{ \/ } returns the logical `join', e.g. `or'.

Can I do this in a *.input file for the interpreter ?
Can I fix a priority for each operator ?

\start
Date: Tue, 28 Feb 2006 12:13:22 -0500
From: Bill Page
To: Tim Daly
Subject: RE: doyen and virtual appliance

Tim,

I've looked at the web site but I still don't know what a
"virtual applicance" is. :( Sounds almost like a "shameless promo"
to me...

What does the Doyen CD have to do with VMWare? The CD boots
stand alone.

Regards,
Bill Page.

> -----Original Message-----
> 
> VMWare has announced a contest paying $200k for a virtual appliance.
> 
> Basically what they want is a virtual machine pre-configured to 
> perform a specific task that you can just install and turn on.
> 
> The Doyen CD with Axiom and the Axiom wiki installed comes to mind
> as a potential "scientific platform".
> 
> see http://www.vmware.com/vmtn/appliances/challenge

\start
Date: 28 Feb 2006 09:59:54 +0100
From: Gabriel Dos Reis
To: Martin Rubey
Subject: Re: Curiosities with Axiom mathematical structures

Martin Rubey writes:

| This problem was discussed in a thesis at St. Andrews, I forgot by whom but I
| can look it up.

Do you have a link?

| In fact it seems that this problem cannot be properly solved
| with Aldor. There was some discussion on this list, too.
| 
| The reason is 
| 
| Rng(): Category == Join(AbelianGroup,SemiGroup)
| 
| would give a problem...

What problems?

\start
Date: 28 Feb 2006 12:41:47 +0100
From: Martin Rubey
To: Gabriel Dos Reis
Subject: Re: Curiosities with Axiom mathematical structures

Here you go:

http://lists.nongnu.org/archive/html/axiom-developer/2005-09/msg00130.html

or page 124 of 

http://worldofnic.org/research/phd.ps

Gabriel Dos Reis writes:

> | In fact it seems that this problem cannot be properly solved
> | with Aldor. There was some discussion on this list, too.
> | 
> | The reason is 
> | 
> | Rng(): Category == Join(AbelianGroup,SemiGroup)
> | 
> | would give a problem...
> 
> What problems?

Well, if you inherit an operation, you cannot alter the name of the
operation. Rng inherits really two different monoids, one for addition and one
for multiplication. Thus there would be a name conflict...

\start
Date: Mon, 27 Feb 2006 12:19:47 -0500
From: Bill Page
To: Tim Daly
Subject: RE: about Expression Integer (with Quizzes)

On February 27, 2006 10:37 AM Tim Daly (root) wrote:
> ... 
> my experience is that written mathematics notation is very
> ambiguous. we don't normally notice this because we view
> each equation in the context of a given subject and, usually,
> in the context of a few paragraphs that contain the semantics.
> 
> axiom attempts to capture the semantics and carry it in the
> type. if the semantics of the type fits your understanding of
> the equation then axiom works "correctly". if not, it appears
> to be a bug. (axiom is hardly bug-free but i'm focused on the
> DMP issue here)
> 
> so what is the semantics of 2*x + 1/x? well, it's ambiguous.
> each of you have successfully argued your understanding of 
> the semantics. and, in the context you've established, you
> are correct.
>

Right on! I agree completely with both your analysis and your
conclusion.
 
> but axiom has to assign a meaning that might not match your 
> understanding. this is where the ambiguity becomes apparent.
> it is also where mathematics and computational mathematics
> part company.

Of course not all mathematics is inherently ambiguous and there
are usually several different ways in which the ambiguity can
be resolved. I would like to suggest (of course I can't prove
it, yet. :) that the current approach to many mathematical
subjects in terms of formal category theory provides a way of
reducing the ambiguities in a way that is largely compatible
with Axiom. For example, it seems to me that the formal definition
given by Ralf Hemmecke in this email thread of a polynomial in
terms of a graded sum is of this sort. That is the reason why
Axiom's behaviour seems much less anomalous when described in
this way.

>...
> 'semantic context' is really an 'extended type' idea. that is,
> you want to be able to tell axiom what area of mathematics you
> are working in and have the type system adapt its meaning to
> that area. 
> 
> this is the section of the textbook where the author say things
> like: "i'm carefully distinguishing the Ring of coefficients
> from the variables in the polynomial" vs "this book explores
> polynomial arithmetic".
>

I agree. My point of view is that as designers of computer algebra
systems we need to be sensitive to the way that mathematics is
actually done. We want a system that is easy to approach for
someone with at least the usual non-specialist undergraduate
experience in math - one that they will find immediately useful
for at least some of things they want to do. But that does not
mean that we need to be "held hostage" to only certain ways of
doing mathematics. Where it seems an advantage, a system like Axiom
needs to be free to present it's own method for formalizing and
solving mathematical problems. In this case the user might need
to learn something new in order to use Axiom even though they may
have an advanced level of understanding of their subject in
conventional mathematical terms.

More than just the mechanical assistance that Axiom provides in
solving a problem, it is this new formality that I think is the
real value added by Axiom. This means that in some cases Axiom's
way of doing things needs to be very carefully and completely
documented. Unfortunately we do not have much documentation of
this type for Axiom.
 
> the compiler will let you keep the two domains separate and will
> force you to merge the domains when you want that behaviour. the
> interpreter is just guessing and you have to be careful to
> understand how and why it guesses. (which means we have to
> construct a model of the interpreter so we can formally state
> the coercion/conversion graph).

I agree. And again this is largely a function of the quality of
the available documentation. I think the existing Axiom interpreter
has it's good and bad points. Each of these needs to be understood
without having to endure a long period of learning by trial and error.

Good user interface design is a large and still largely un-solved
problem. So there is still a lot of room for improvement. But
changes to a complex existing system like Axiom need to be done
very carefully because even simple changes can potentially have
large and unexpected consequences for some applications and some
ways of using Axiom. But at the same time this might provide
sufficient motivation to continue the development of alternate user
interfaces such as proposed in the B# project.

> 
> in my world view a semantic context is another facet in the
> crystal. (but that's still long-term fantasy so we won't talk
> about it here).
> 
> anyway, i don't see that it is possible to resolve this debate.
> you are all arguing from different semantic contexts. until you
> agree to use the same assumptions there is no resolution.
> 

I think you are right. In fact, I would say that the point is not
so much that we should agree, but rather that we need to understand
how it is possible to accommodate several different points of view
even though they might appear at first to be contradictory.

I think we need to focus *first* on documenting clearly what Axiom
actually does, rather than trying to judge whether what Axiom does
is "right or wrong". Because Axiom is open source software, if
necessary, we can actually read the source code itself to determine
this exactly. And we can demonstrate our understanding with actual
experiments in Axiom. So far, I think we are doing a pretty good
job of this. But it still needs to be distilled into useful
documentation that can be read by non-specialists.

Second, we need to try to explain *why* Axiom does what it does.
This is harder and it might be difficult to get full agreement.
Some parts of Axiom were clearly the result of experiments that
were part of the overall research project. Some of these experiments
where more successful than others and unfortunately we do not have
very much documentation of this original research. My point of
view is that where necessary we should try to create models that
are (perhaps only largely) consistent with Axiom but motivated by
contemporary methods in mathematics. This is where I see category
entering. Since category theory is now also a fairly well accepted
tool in programming language semantics, I think we are in a good
position here.

Third, we can consider changes to Axiom that would make it more
self-consistent and that would make it conform more closely to
the models that we have developed above, in brief: to make Axiom
more categorical.

\start
Date: Tue, 28 Feb 2006 12:25:37 -0500
From: Tim Daly
To: list
Subject: doyen and virtual appliance

VMWare has announced a contest paying $200k for a virtual appliance.

Basically what they want is a virtual machine pre-configured to 
perform a specific task that you can just install and turn on.

The Doyen CD with Axiom and the Axiom wiki installed comes to mind
as a potential "scientific platform".

see http://www.vmware.com/vmtn/appliances/challenge

\start
Date: 28 Feb 2006 08:38:14 +0100
From: Martin Rubey
To: Gabriel Dos Reis
Subject: Re: Curiosities with Axiom mathematical structures

This problem was discussed in a thesis at St. Andrews, I forgot by whom but I
can look it up. In fact it seems that this problem cannot be properly solved
with Aldor. There was some discussion on this list, too.

The reason is 

Rng(): Category == Join(AbelianGroup,SemiGroup)

would give a problem...

Gabriel Dos Reis writes:

> Hi,
> 
>   The recent discussions about Axiom/Aldor being object-oriented or
> not, whether Axiom could be made to be "truly categorial" or not
> reminded be of a curiosity I found in Axiom's hierarchy for
> mathematical structures.
> 
>   In the impressive diagram titled "Basic Agebra Hierarchy" displayed
> in the Axiom Book (I only have a copy of the edition copyrighted 1992,
> NAG), AbelianSemiGroup is not "derived" from SemiGroup, and similarly
> AbelianMonoid is not "derived" from Monoid.  I find that curious as it
> goes counter the mathematical fact that an AbelianMonoid *is* a
> Monoid, with an additional algebraic law (commutation).  
> 
> 
>   Does anyone know the reason of those curiosities?
> 
>   (A year or so ago, in a discussion with a friend I attributed those
> anomalies to object-orientation artifacts.  I would be glad to see
> that disproved...)
> 
> PS: libalgebra has similar curiosities

\start
Date: Tue, 28 Feb 2006 12:51:26 -0500
From: Bill Page
To: Tim Daly
Subject: RE: doyen and virtual appliance

Tim,

On February 28, 2006 1:20 PM you wrote:
> ... 
> So Doyen would be a virtual machine focused on adding and
> integrating scientific software into a single purpose platform.
> A hyper-packaging concept. Instead of installing a dozen tools
> to get a local axiom wiki working you just copy the VM image. 
> 

Ok, I get it. But of course VMware is not open source, right?
And you have to be running VMware first before this is possible.
But I suppose supporting an Axiom/Doyen VMware application is
not that different than supporting a Windows version of Axiom...

And who is going to laugh at $200,000? :)

Note that there is an open source alternative to VMware for linux
applications called Xen:

http://www.cl.cam.ac.uk/Research/SRG/netos/xen/index.html
http://sourceforge.net/projects/xen
http://www.xensource.com

\start
Date: Mon, 27 Feb 2006 12:37:19 -0600
From: MathAction (Bill Page)
To: MathAction
Subject: [#271 )show Expression Boolean gives a list] cannot reproduce axiom process died

I can not reproduce your observation that:

> the axiom process died the command-line after.

This does not happen for me on at least the Windows version of
Axiom.

But I do find it very odd that Axiom allows the construction of
the domain 'Expression Boolean' without complaint:
\begin{axiom}
x:=Expression Boolean:=true
\end{axiom}

The scary sounding message: 'Caught fatal error [memory may be damaged]'
occurs for many operations applied to this object.

The definition of the constructor 'Expression R: OrderedSet' seems
wrong to me since there are may operations exported by 'Expression'
that are not naturally interpreted over a domain that is just an
OrderedSet. For example 'Boolean' is considered ordered as follows:
\begin{axiom}
Boolean has OrderedSet
true > false
\end{axiom}

although we might also question the wisdom of considering 'Boolean'
ordered in this way.

\start
Date: Tue, 28 Feb 2006 03:33:41 -0600
From: MathAction (wyscc)
To: MathAction
Subject: [DistributedMultivariatePolynomial] 

Bill Page wrote:

> I find your notation a little confusing. In Axiom notation I think you mean, for example:

There is nothing confusing about my notation in $R[x]$ where $R$ can be any integral domain (or even ring). The $x$ is transcendental over $R$ by the definition of polynomial ring. $R$ can be INT, or EXPR INT, POLY INT or what have you. $x$ is NEVER going to be in the ground coefficient ring if you are talking about polynomials in x (see PS below for a proof). You are confused because you refuse to accept the definition of polynomial ring. You, confused by the Interpreter, keep saying that an indeterminate $x$ can be an element of the coefficient ring. That is a violation of a universally accepted mathematical definition. On the opther hand, the Interpreter only errs in not catching your mistake. It did NOT coerce something from $R[x]$ that involves $x$ into $R$. There is simply no such coerce map in Axiom!

$Q(R[x])$ is the quotient field of the polynomial ring. It is the field of rational functions in one indeterminate $x$ with coefficients in $R$. $R$ can be any integral domain, including a field. That is why $Q(R[x]) = Q(Q(R)[x])$ (more precisely, isomorphic). In Axiom, this would be 'FRAC DMP([x], R)' is isomorphic to 'FRAC (DMP([x], FRAC R)' (and Axiom provides facilities to convert one into the other; I believe Aldor's compiler even knows about these "tower rearrangements"). In the examples under discussion, $R$ would be 'POLY INT', or 'FRAC POLY INT', but not 'INT'. But it is still true that the main variable of 'DMP([x], R)' cannot belong to 'R = POLY INT'.

>It is only when we coerce $Q(R[x])[x]$ ...

Your notation $Q(R[x])[x]$ is either meaningless (in case you think of the last $x$ as transcendental over the field $Q(R[x])$) or it is identical to $Q(R[x])$  as a mathematical object (in case you adjoin the *same* $x$ to the field of rational functions over $R$.)  It cannot mean both and in any case, this is the wrong way to notate what you meant. You should have used $Q(R[x])[y]$ where $y$ is another indeterminate independent over $Q(R[x])$.  We cannot *coerce* $Q(R[x])[y]$ into $Q(R[x])$ no matter what $R$ is since $y$ is transcendental over $Q(R[x])$. We can only *substitute* $x$ for $y$ so that any $f(x,y)$ evaluates to $f(x,x)$.  This is the substitution I was talking about and what FRAC2 implements. Unfortunately, looking at the code will only give you a more general "lifting" map. The substitution is actually given by the input 'A->B' in 'map' and supplied by the Interpreter in its automatic "coercion" magic.  The function 'map(f:A->B, A, B)' in the example of $A =!
 R[x,y]$, $B = R[x]$ and $f(x)=x, f(y)=y$ will map $\frac{1}{y} \times x$ to $1$. This is what you see done by the Interpreter. Unfortunately, the user insists using $x$ instead of $y$ as in
'monomial(x,0)$DMP([x], POLY INT)'. The correct way this:

\begin{axiom}
f:=monomial(y,0)$DMP([x], POLY INT)
subst(1/f*x, y=x)
\end{axiom}

William

PS. Let me define a univariate polynomial over a unitary ring $R$ where $0 \neq 1$, as an infinite sequence (function with finite support) from $N$ (the natural numbers) to $R$ and the polynomial ring as the totality of all polynomials. Then the indeterminate, let us call it $x$, will be the sequence represented by the function $f_x: N \rightarrow R$ where $f_x(1) = 1$ and $f_x(n) = 0$ for $n \neq 1$. An element $a \in R$ is identified as the function $f_a$ where $f_a(0)= a$ and $f_a(n)=0$ for $n \neq 0$. From this we see that $f_x \neq f_a$ for any $a \in R$ since $f_a(1) \neq f_x(1)$. So, there is no way one can *coerce* $f_x$ to $R$, no matter what $R$ is. We don't even need to know that $f_x$ is transcendental over $R$. We can only make a substitution to replace $f_x$ by some $f_a$ (or evaluation at $a$).

\start
Date: Fri, 24 Feb 2006 09:26:57 +0100
From: David Mentre
To: Gabriel Dos Reis
Subject: re: ASDF and ./configure

Hello Gaby,

24 Feb 2006 07:54:40 +0100, Gabriel Dos Reis=
:
> The value of using Autoconf for Axiom is not in building it on or for
> Ultrix, but in reusing packaged knowledge about various regular systems,
> taken care of by system packagers.  Axiom really should be developing
> its own idea of config.guess or system triplet.

Ok. However, I had the impression that Autoconf triplets are not what
is needed for Axiom (e.g. is t possible to recognize a Fedora Core 3?
Could we integrate different Lisps as part of the system triplet?).
But you obviously think that using some m4 macros this is not an
issue.

> ahem, in which shell?

Bash. But you're perfectly right that I did not read the manual with
enough attention:
man bash
[...]
       string1 == string2
              True if the strings are equal.  = may be used in place of =
== for
              strict POSIX compliance.

Bourne sh is using '=' as string equality.

Gaby: 1 - David: 0 (well, rather -infinity on this one ;-)

> Autoconf has been widely test in more wild
> environment than anything variation you'll come up here.  I would
> suggest that we avoid NIH and reuse the wisdom of the Autoconf guys
> who have faced and experienced wild shell variation issues.

Ok, I'll look at Autoconf. If I should criticize it, at least should I
do it on sound grounds. :-) I'll try to make a first prototype, but as
I need to learn Autoconf first, don't hold your breath.

\start
Date: Wed, 01 Mar 2006 23:56:04 -0500
From: William Sit
To: Gabriel Dos Reis
Subject: Re: Curiosities with Axiom mathematical structures

 Bill Page writes:

 [...]

> | I don't think there is any essential reason why SemiGroup and
> | Monoid could not be implemented in the way you suggest. For
> | example:
> |
> | )abbrev category SGROUP SemiGroup
> | SemiGroup(m:Symbol): Category == SetCategory with
> |       m: (%,%) -> %    ++ returns the product of x and y.
> |       associative(m)
> |
> | )abbrev category ABELSQ AbelianSemiGroup
> | AbelianSemiGroup(m:Symbol): Category == SemiGroup(m) with
> |       abelian(m)
> |

Yes, there are no theoretical reasons, but there are plenty of practical ones.
I think such constructs will make it more difficult for the Interpreter to work
since it would not be able look up the appropriate signature from domains that
have not been instantiated during the session. Of course, if the Interpreter
knows what to instantiate, that won't be a problem. But how will the Interpreter
be able to know?  Indeed, how is a user to know what symbol was used, say, for
the operations? What if the user instantiates Integer with both * and + for the
same operations in two instances? Can a compiler or interpreter catch this? If
not, it would be a nightmare of bug reports.

By allowing renaming of operations (even just all binary operations), the
categorical notation for * or + no longer exists and it would be impossible for
the Interpreter to search for a suitable signature in a categorical manner ---
only on a specific domain by domain (and for instantiated domains only for that
matter) basis.

I do recognize some limitations for having two monoid categories structured on
two different operator notations. For example, there is no commutative monoid
with * as the multiplication and these are needed (if one wants to look at the
set of monomials in several variables as a multiplicative monoid). However, it
is far easier to have say, AbelianAdditiveMonoid and AbelianMultipicativeMonoid
categories (cf. one AbelianMonoid where the operator must be "+") than to
implement all operators used in algebras as parameters. For CAS to be practical,
certain compromises are necessary. I do not question the theorectical advantage
of rebuilding all algebra based on properties of operators (there is research in
theory of operads which would support such a design) but I doubt their
practicality, especially when the notation for the operators can only be known
dynamically at run-time.

As already well-known, with the current status, all properties of operators are
declarative and not verified. There is a certain degree of trust that users know
what they are doing. Creating examples that deliberately violate these
conventions and implicit assumptions of the system and show the "weakness" or
"buggiess" of Axiom (or any other CAS) is not productive. One consequence of
these examples is confusion of the real issues: the lack of documentation on the
conventions and implicit assumptions, and real bugs.

\start
Date: Thu, 02 Mar 2006 13:38:01 +0100
From: Ralf Hemmecke
To: Bill Page
Subject: Re: Renaming at inheritance (was: Re: Curiosities with Axiom mathematical structures)

Maybe, I am a bit behind ...

On 03/01/2006 05:26 AM, Bill Page wrote:
> On February 27, 2006 11:08 AM Gabriel Dos Reis wrote:
> 
>> ...
>>  
>> Ralf Hemmecke writes:
>> ... 
>> | One reason for having Monoid and AbelianMoniod (one with "*" and
>> | the other with "+") is that neither SPAD nor Aldor allows to
>> | rename functions during inheritance.
>>
>> yes, that is true for many (all?) object-oriented languages.  I can
>> understand the language limitation, but that is hardly an excuse for
>> chosing in advance that "+" is for Abelian monoid and "*" for
>> non-Abelian ones.
>>
> 
> I don't see why renaming is necessary.
>  
>> | Note that one would have to say something like
>> | 
>> | define Monoid(
>> |    *: (%, %) -> %;
>> |    1: %
>> | ): Category == ...
>> | 
>> | define Group(
>> |    *: (%, %) -> %,
>> |    inv: % -> %,
>> |    1: %
>> | ): Category == ...
>> | 
>> | define Ring(.....): Category == with {
>> |    Monoid(*, 1);
>> |    Group(+, -, 0);
>> | }
>>
>> Ring should be both Monoid and Group, whether they shoud be 
>> categories, I don't really know.

Well, think of Axiom's Category as just a list of function (and 
constant) signatures.

Well, as far as I know, something that is of type Category in 
Aldor/Axiom should be near to a mathematical category. (But I am not the 
original designer and unfortunately there is no page on the AxiomWiki 
that explains it clearly.

Anyway, what I suggested above is perhaps not so close to mathematics as 
I and probably other mathematicians would like it to be.

The point is that one speaks of a "category of rings, groups, monoids, 
etc.), but not of a "category of rings(*, 1, +, -, 0)". So defining 
those structures in Axiom without arguments would be highly preferable.

However, there is no way in Axiom to express that a Ring is a Monoid 
(SemiGroup if you like) "with respect to multiplication" and a Group 
(which is also a Monoid) "with respect to addition".

So the compromise in Axiom currently is to have Monoid and AbelianMonoid 
where AbelianMonoid does not inherit from Monoid and one is with respect 
to "*" and the other with respect to "+".
However, being a mathematician, it is not so nice that just because of 
language limitations I have to construct another algebra hierarchy that 
doesn't match the mathematical one.

About two years ago I have spoken to Stephen Watt about a possible way 
to rename functions, but he said that would be a major change to the 
compiler and very hard to implement. :-(

> In Axiom (SPAD) we can write:
> 
> Monoid(m:Symbol,u:Symbol): Category == with
>        m: (%,%) -> %       ++ returns the product of x and y
>        u: () -> %          ++ unit
>        associative(m)      ++ m(a,m(b,c)) = m(m(a,b),c)
>        identity(u)         ++ m(a,u) = m(u,a) = a

As you see below, that will not work in Aldor.

--begin mon.as
#include "aldor"
define Monoid(m:Symbol,u:Symbol): Category == with {
         m: (%,%) -> %;
         u: () -> %;
         associative(m);
         identity(u);
}
--end mon.as

aldor mon.as
"mon.as", line 5:         associative(m);
                   ........^
[L5 C9] #1 (Error) There are no suitable meanings for the operator 
`associative'.

"mon.as", line 6:         identity(u);
                   ........^
[L6 C9] #2 (Error) There are no suitable meanings for the operator 
`identity'.

It simply does not match the Aldor language specification.
"associative(m)" is interpreted as call to a function "associative" 
which simply does not exist.

And now, something interesting. The following file compiles.
--begin mon1.as
#include "aldor"
define Monoid(m:Symbol,u:Symbol): Category == with {
         m: (%,%) -> %;
         u: () -> %;
}
--end mon1.as

My first guess was that the compiler would complain, because m is a 
parameter of type Symbol and now we turn it into a function. But I was 
wrong. There are simply TWO m there. One of type Symbol and the other of 
type "(%, %) -> %" and the have NOTHING to do with each other. They just 
happen to have the same name.

That seems to be a difference between SPAD and Aldor.

> Then we can write:
> 
>   )sh Ring(+,-,"0"::Symbol,*,"1"::Symbol)
>   Ring(+,-,"0"::Symbol,*,"1"::Symbol) has commutative(+)
> 
> See the example at http://wiki.axiom-developer.org/SandBoxMonoid

That looks interesting, but as I said above, I would not like Ring to 
carry parameters. With parameters, it looks a bit more like a universal 
algebra.

Anyway, I think in the above example Axiom's "Symbol" domain (written 
*in* the SPAD language) is treated as part of the SPAD language. I 
cannot say that I like that. I prefer Aldor's approach even if it 
(still) forbids me to do "renaming during inheritance". But I can 
understand the code from the language definition.

See also my additions on
   http://wiki.axiom-developer.org/SandBoxMonoid

>> | If such renaming could be implemented into the Aldor language
>> | that would make it even better suited for mathematics. However, 
>> | then there is need that someone implements these ideas into the
>> | compiler. Who?
> 
> Could you explain what you mean by "renaming" and how it might
> be used to express mathematics?

Well, clearly a mathematian would always say that an abelian monoid is a 
monoid. These properties are properties of the structure and not of the 
names of the functions that form that structure.
We cannot express this in Aldor in general, and it is also not done in 
Axiom.

Anyway, it is a pity that "Axiom" cannot express axioms in its language.
By the category "AbelianMonoid" one has just a tag that domains that 
implement this category have to implement "+: (%,%)->%" in a commutative 
fashion. The only way to state commutativity is in the documentation, 
but not formally in a language construct.

There are some experiments, however...
http://citeseer.ist.psu.edu/poll98adding.html
http://www.cs.kent.ac.uk/people/staff/sjt/Atypical/AldorExs/index.html

 > Not all, Eiffel can rename methods when inheriting:
 >
 > http://www.maths.tcd.ie/~odunlain/eiffel/intro.html
 > """
 >    class C inherit
 >
 >         A rename x as x1, y as y1 end;
 >
 >         B rename x as x2, y as y2 end
 >
 >   feature...
 >
 > Here, if both A and B have features named x and y, class C would be
 > invalid without the renaming.

I don't know Eiffel, but I guess that feature is necessary for multiple 
inheritance.

In Aldor multiple inheritance is already possible for categories, but 
forbidden for domains.

But I would like to say something like

define SemiGroup: Category == with {
   *: (%, %) -> % -- or any other name.
}
Ring: Category == with
   SemiGroup;
   SemiGroup where {* == +};
}

Oh that will be getting complicated if I inherit from something like

define Structure: Category == with {
   foo: % -> %;
   foo: (%, %) -> %;
}

Where are the language designers?

\start
Date: 02 Mar 2006 11:11:32 +0100
From: Martin Rubey
To: Bill Page
Subject: Re: Curiosities with Axiom mathematical structures

Bill Page writes:

> In Axiom (SPAD) we can write:
> 
> Monoid(m:Symbol,u:Symbol): Category == with
>        m: (%,%) -> %       ++ returns the product of x and y
>        u: () -> %          ++ unit
>        associative(m)      ++ m(a,m(b,c)) = m(m(a,b),c)
>        identity(u)         ++ m(a,u) = m(u,a) = a
> 
> Group(m:Symbol,inv:Symbol,u:Symbol): Category == Monoid(m,u) with
>        inv: % -> %         ++ inverse
>        inverse(m,inv)      ++ m(inv(a),a) = m(a,inv(a)) = u
> 
> AbelianGroup(m:Symbol,inv:Symbol,u:Symbol): Category
>    == Group(m,inv,u) with
>       commutative(m)       ++ m(a,b) = m(b,a)
> 
> Ring(s:Symbol,inv:Symbol,z:Symbol, m:Symbol,u:Symbol): Category
>    == Join(AbelianGroup(s,inv,z),Monoid(m,u)) with
>       distributes(m,s)     ++ m(a,s(b,c)) = s(m(a,b),m(a,c))
>                            ++ m(s(a,b),c) = s(m(a,c),m(b,c))
> 
> Then we can write:
> 
>   )sh Ring(+,-,"0"::Symbol,*,"1"::Symbol)
>   Ring(+,-,"0"::Symbol,*,"1"::Symbol) has commutative(+)
> 
> See the example at http://wiki.axiom-developer.org/SandBoxMonoid

That's very interesting. I would have thought that it's not possible to use a
parameter as the name of an operation. Is this possible in Aldor, too? (I'd
guess so)

Ooops, I just tried to implement a domain:

)abbrev category MYMON MyMonoid
MyMonoid(m:Symbol): Category == with
       m: (%,%) -> %       ++ returns the product of x and y

       square: % -> %

     add
       square a == m(a,a)

)abb domain WORDS Words
Words: Exports == Implementation where

  Exports ==> MyMonoid("c"::Symbol) with

    coerce: String -> %

  Implementation == add

    Rep := String

    coerce(a: String): % == a

    c(a:%, b:%):% == concat(a::Rep, b::Rep)


but square won't work then: Axiom is looking for an operation m, which does not
exist, of course.

How about Aldor?

\start
Date: Mon, 27 Feb 2006 12:59:45 -0500
From: Bill Page
To: Gabriel Dos Reis
Subject: RE: about Expression Integer (with Quizzes)

On February 27, 2006 4:25 AM Gaby wrote:
> 
> Bill Page writes:
> 
> [...]
> 
> | > )set mess bot off
> | > (6) y:DMP([y], INT);
> | >     variables (2*y+1/y)
> | >
> | 
> | I wrote: "Error same as in (2)". So I have to admit I got this
> | one wrong but I should not have. The explanation is simple. This
> | is not a package call as it was in (2), so the interpreter is
> | free to apply the usual coercion to 'FRAC DMP([y], INT)' in order
> | to obtain a selection for '/'.
> 
> When it takes so many Axiom experts to get those things wrong --
> no matter how obvious they might seem with hindsight -- I believe
> the "free hands" given to the interpreter may be questioned :-)

Although I am not sure that number of available "Axiom experts"
should be interpreted as any sort of "guarantee" of convergence
;) I think your conclusion is right. I think the Axiom interpreter
currently does several things (some of which have already been
documented as Issues) that even experienced users might find
surprising - even though they might be able to offer a more or
less clear explanation of the behaviour. Thus Axiom clearly
violates the "principle of least surprise" that has been advocated
as one of the more important principles in user interface design.
But user interface design, being in large part more of an "art"
than a science, does not provide many well-understood solutions
to this problem.

I think some of what we have been discussing are not interpreter
issues as such, but rather what the best "categorical" representation
of certain mathematical objects such as polynomials, might be. This
is more a matter of how to match an object-oriented design to the
mathematics when that part of mathematics often does not naturally
inherit such a tradition.

> 
> What I retain from this fascinating thread is that the
> implemented underlying mechanism for interpreting polynomials
> is, hmmm, far from "obvious" and "intuitive".

I think one of the reasons that Axiom fails to be obvious here
is that it attempts to be both powerful and intuitive at the same
time. These are often conflicting goals and as a result Axiom
sometimes seems to fail at both (though I think more often it is
powerful but not so intuitive). However intuition is often a poor
guide when it comes to mathematics, so we should expect that we
need to sharpen our intuitions by reading the documentation.
Unfortunately a lot of this documentation still needs to be
written. :(

\start
Date: Tue, 28 Feb 2006 00:05:07 +0100
From: Gregory Vanuxem
To: Bill Page
Subject: RE: Compiler coercion and DoubleFloat

Hi,

Le dimanche 26 f=E9vrier 2006 =E0 20:50 -0500, Bill Page a =E9crit :
> On February 26, 2006 11:45 AM Vanuxem Gr=E9gory wrote:
> >
> > Is it possible to avoid this compiler coercion ?
> >
> > The code is:
> >         R ==> DoubleFloat
> >         two4: R := 24.0
> >         fourty: R := 40.0::R
> >         exp40: R := 235385266837019985.41::R
> >
>
> It is not necessary to write this as a coercion. Try
>
>   float(23538526683701998541,-2,10)$DoubleFloat
>
> 'float' is the function defined in the domain DoubleFloat
> that is analogous to the one in Float.

Thanks Bill but after some searches i have found exactly
what i'm looking for.

In fact, the parser, when it encounters a real number,
returns integer part, fractional part, length of fractional part
and exponent and call MAKE-FLOAT. MAKE-FLOAT returns mantissa,
exponent (in base 10) and a "property" attached |:BF:|
(for big float) if $useBFasDefault is true (its default value).
postBigFloat will return, later,
((|elt| (|Float|) |float|) 23538526683701998541 -2 10)

But if $useBFasDefault is false MAKE-FLOAT returns a lisp double-float.

So i add, at the beginning of the code

)boot $useBFasDefault:=false

the code is:
         two4: R := 24.0
         fourty: R := 40.0
         exp40: R := 235385266837019985.41

and the compiler output is:

(SEQ (LET (|:| |two4| (|DoubleFloat|)) 24.0)
     (LET (|:| |fourty| (|DoubleFloat|)) 40.0)
     (LET (|:| |exp40| (|DoubleFloat|)) 2.3538526683702E17)


\start
Date: 02 Mar 2006 19:59:59 +0100
From: Gabriel Dos Reis
To: William Sit
Subject: Re: Curiosities with Axiom mathematical structures

[ Woaw, I did not anticipate we would have so much fun with what I
think is a mistake in Axiom/Aldor :-)]


William Sit writes:

|  Bill Page writes:
| 
|  [...]
| 
| > | I don't think there is any essential reason why SemiGroup and
| > | Monoid could not be implemented in the way you suggest. For
| > | example:
| > |
| > | )abbrev category SGROUP SemiGroup
| > | SemiGroup(m:Symbol): Category == SetCategory with
| > |       m: (%,%) -> %    ++ returns the product of x and y.
| > |       associative(m)
| > |
| > | )abbrev category ABELSQ AbelianSemiGroup
| > | AbelianSemiGroup(m:Symbol): Category == SemiGroup(m) with
| > |       abelian(m)
| > |
| 
| Yes, there are no theoretical reasons, but there are plenty of
| practical ones.

In fact, practicality dictates that the implementations in Axiom/Aldor
closely follow the mathematical structures.  For example, the only
assumption  I need to define the power of an element is that its domain
has a monoidal structure.  From software engineering point of view,
Practicality dictates that I should not have to write duplicate codes,
one for additive operation, one for multiplicative operation when the
underlying mathematical structure is the same.  That is
the least I expect from a non-mathematically-oriented system.  

If the system does not let one do that, then the system is practically
defective :-)  

| I think such constructs will make it more difficult for the
| Interpreter to work since it would not be able look up the
| appropriate signature from domains that have not been instantiated
| during the session. 

That depends on the *kind of lookup*.  For a system where all symbols
are global with no proper scoping, then yes that is a problem.  But
then, if the system is designed to write mathematical software it
should have lookup rules that make that possible.  Said differently,
the system should be designed to serve writing "natural" mathematical
software. 

| Of course, if the Interpreter  knows what to instantiate, that won't
| be a problem. But how will the Interpreter be able to know?

By adequate scoping rules. 

|  Indeed, how is a user to know what symbol was used, say, for the
| operations? What if the user instantiates Integer with both * and +
| for the same operations in two instances?

When both will be in scope.  If the user uses * with Integer, the
system knows that (*, Int) is a monoidal structure.  Same if
(+, Int).

| Can a compiler or interpreter catch this?

Yes, definitely.

| If not, it would be a nightmare of bug reports.

It would be a nightmare only if one takes the rules that a type has a
unique algebraic structure.  That is both theoretically and practically
false.  See the examples (+, NN), (*, NN), (NN, max) I gave earlier.

| By allowing renaming of operations (even just all binary operations), the
| categorical notation for * or + no longer exists and it would be
| impossible for the Interpreter to search for a suitable signature in
| a categorical manner --- only on a specific domain by domain (and
| for instantiated domains only for that matter) basis.

I don't see what "renaming" has to do with this; from what I see, it
can only lead to greater confusion.

However, passing the operation as a parameter to the structure is a
first approximation of a viable solution. 

| I do recognize some limitations for having two monoid categories
| structured on two different operator notations. For example, there
| is no commutative monoid with * as the multiplication and these are
| needed (if one wants to look at the set of monomials in several
| variables as a multiplicative monoid). However, it is far easier to
| have say, AbelianAdditiveMonoid and AbelianMultipicativeMonoid 
| categories (cf. one AbelianMonoid where the operator must be "+")
| than to implement all operators used in algebras as parameters.

I beg to differ.  Having to write duplicate codes is known to be a nightmare
and fruitful source of bugs.  It does not really encourage
abstractions. I wanted to use Axiom to teach generic programming here,
but I'm being forced to walk away from it :-((
How can I convince students of the value of the system when it does
not support their knowledge?

| CAS to be practical, certain compromises are necessary.

100% agreed.  However, uniformity and coherence should not be compromised.
The current approach does not even support the mathematical or
"categorial" approach we would like to recommend.  How can we explain
the that concepts we clearly and unambiguously explained to the
students or engineering cannot translate directly to code in a
mathematically-oriented system?  How can we convince the engineer that
he has to duplicate code, when he knows from practice that it is a
source of disaster? 

| I do not question the theorectical advantage of rebuilding all
| algebra based on properties of operators (there is research in
| theory of operads which would support such a design) but I doubt
| their practicality, especially when the notation for the operators
| can only be known dynamically at run-time.

Well, I'm approaching the issue more from a *practical* point of view
than a theoretical point of view.  As the system currently stands, in
practice, I cannot simply and clearly write once a generic function
for monoidal structures and expect it to work for both for Abelian and
non Abelian monoids.  From a practical point of view, the system does
not support a direct mapping from design to codes.  And if I cannot
directly see the design in the code, how do I know the code reflects
the design and my intent.  If I have duplicate codes floating around,
how do I know for sure that I've fixed the bugs I have identified
through testing with some parameters?  If I do not have a direct
mapping from design to code, how do evolve my software in a sound and
controlled manner?  Those are practical questions.

| As already well-known, with the current status, all properties of
| operators are declarative and not verified.

My problem is simpler than that.  I'm not asking for the definition of
the algebraic properties of operators.  I'm trying to have a way to
convince Axiom/Aldor to support sound software engineering practice.
Even better if I can take the standard library as an example.

| There is a certain degree of trust that users know what they are doing.

I understand that.  But that issue is different from what mine.

| Creating examples that deliberately violate these conventions and
| implicit assumptions of the system and show the "weakness" or 
| "buggiess" of Axiom (or any other CAS) is not productive. 

if you are talking about the issue I raised, then I believe you
profoundly misunderstood it.  
And claiming it deliberately violates conventions and implicit
assumptions of Axiom is very unproductive.  I'm deeply disappointed :-((

The issue is this:  *why* should one be forced to duplicate codes for
an algorithms that work on the same mathematical structure.  The
question arise from software engineering point of view, in general,
and mathematical software in particular (I classified Axiom as a
mathematical software).  If the reasons for that are not theoretical,
I believe we need to improve over the situation.

I'm asking the question as someone interested in (mathematical)
software engineering teaching and someone interested in Axiom.

| One consequence of these examples is confusion of the real issues:
| the lack of documentation on the conventions and implicit
| assumptions, and real bugs. 

I fear you did not see what I was talking about.

\start
Date: 02 Mar 2006 20:23:54 +0100
From: Gabriel Dos Reis
To: Bill Page
Subject: Re: Curiosities with Axiom mathematical structures

Bill Page writes:

| On February 27, 2006 11:08 AM Gabriel Dos Reis wrote:
| 
| >...
| >  
| > Ralf Hemmecke writes:
| > ... 
| > | One reason for having Monoid and AbelianMoniod (one with "*" and
| > | the other with "+") is that neither SPAD nor Aldor allows to
| > | rename functions during inheritance.
| > 
| > yes, that is true for many (all?) object-oriented languages.  I can
| > understand the language limitation, but that is hardly an excuse for
| > chosing in advance that "+" is for Abelian monoid and "*" for
| > non-Abelian ones.
| >
| 
| I don't see why renaming is necessary.

Me neither, but I guess it is a solution.  But a solution that I
think brings greater confusion.

| > | Note that one would have to say something like
| > | 
| > | define Monoid(
| > |    *: (%, %) -> %;
| > |    1: %
| > | ): Category == ...
| > | 
| > | define Group(
| > |    *: (%, %) -> %,
| > |    inv: % -> %,
| > |    1: %
| > | ): Category == ...
| > | 
| > | define Ring(.....): Category == with {
| > |    Monoid(*, 1);
| > |    Group(+, -, 0);
| > | }
| > 
| > Ring should be both Monoid and Group, whether they shoud be 
| > categories, I don't really know.
| >
| 
| In Axiom (SPAD) we can write:
| 
| Monoid(m:Symbol,u:Symbol): Category == with
|        m: (%,%) -> %       ++ returns the product of x and y
|        u: () -> %          ++ unit

The reason I previously said I did not see why Monoid should be a
category is that the operation is already passed in as a parameter, so
there would nothing to implement "inside" in the Monoid.
However, upon discussion with a colleague, it appears that having to
pass in all the required properties (e.g. operation, neutral element,
etc.) will not be practical from software engineering point of view.
Indeed, there would be a redundancy in the system.  The underlying type
and the operation suffice to uniquely define the structure.  So that
means, the other parameters are somehow "function" of the essential
parameters. That implies that indeed Monoid will be a category which
domains will implement by supplying the value for the neutral element.
Same reasoning for Group where the type and the operation suffice to
define the inverse and the neutral element.

[...]

| > I believe this is something solvable -- at least, that can be
| > approximated to a good extent -- in a type system based on
| > predicate system directly available at the programming level.
| > We've been developing such an idea to build a type system for
| > C++ template arguments, see
| > 
| >    http://public.research.att.com/~bs/popl06.pdf
| > 
| > presented at POPL this year.
| 
| I think the predicates here are what Axiom calls "axioms" such as:
| 
|        associative(m)      ++ m(a,m(b,c)) = m(m(a,b),c)
|        identity(u)         ++ m(a,u) = m(u,a) = a
|        inverse(m,inv)      ++ m(inv(a),a) = m(a,inv(a)) = u
|        commutative(m)      ++ m(a,b) = m(b,a)
|        distributes(m,s)    ++ m(a,s(b,c)) = s(m(a,b),m(a,c))
|                            ++ m(s(a,b),c) = s(m(a,c),m(b,c))

The predicate as I use it was in the general sense; for example, in
the system Monoid is be predicate.  That is consistent with the theory
of "qualified types", of which type classes (Haskell) are examplar.
But, I suspect that use of predicate also integrates yours.

| In Axiom right now the only thing we can do with axioms is to
| test them, e.g.
| 
|   R:=Ring(+,-,"0"::Symbol,*,"1"::Symbol)
|   ...
|   if R has commutative(+) then
| 
| but one could easily imagine adding more complex predicates
| which could still be evaluated at compile time. (Remember that
| Axiom and Aldor are intended to be statically typed languages.)

yes, I know Aldor is a statically typed language; in the predicate
system I'm talking about Rin would be a predicate -- it says that a
combination of certain symbols are stated to conform to "Ring"
property.  Again, this is "obvious" from the qualified theory point of
view. 

| > Notice that the "post facto extenstion" of Aldor is a starting
| > point, but it still does not help solving that issue..
| 
| As I understand it, post facto extension allows for the
| iterative definition of a type, i.e. adding and/or refining
| new functions.

Yes!

| I am not sure how this might apply in the
| example of the Ring above, but I think there are more
| interesting types that must be defined by mutual recursion
| and in that case post facto extension seems very natural.
| Could you give some examples of how else you think this can
| be used?

Suppose I started with a monoid M = Monoid(T, foo), then later prove
or discover that it really is Abelian.  When ipso fact extension, I
could say

      M has commutative(operation.M)

the point here is that I do not need to have all properties that M
might have handy before defining it.  I can add those properties on the
go.

| > The make the approach practical for large libraries in
| > Axiom/Aldor I believe some form of deduction of category/domain
| > argument deduction would needed.  However, Axiom/Aldor types
| > being dependent, that be challenging.   Anyway, I have searched
| > the literature for the descirption of Axiom/Adlor type system
| > as implemented, I have found nothing that could assist me.
| > 
| 
| Have you looked at the papers by Erik Poll and Simon Thompson
| such as:

I had read two of the papers you pointed out (that was in 2004).  But
none of them helped me find clarify the problem I was after.  
I'll read the third one.

\start
Date: 02 Mar 2006 20:41:02 +0100
From: Gabriel Dos Reis
To: Ralf Hemmecke
Subject: Re: Renaming at inheritance (was: Re: Curiosities with Axiom mathematical structures)

Ralf Hemmecke writes:

[...]

| >> | Note that one would have to say something like
| >> | | define Monoid(
| >> |    *: (%, %) -> %;
| >> |    1: %
| >> | ): Category == ...
| >> | | define Group(
| >> |    *: (%, %) -> %,
| >> |    inv: % -> %,
| >> |    1: %
| >> | ): Category == ...
| >> | | define Ring(.....): Category == with {
| >> |    Monoid(*, 1);
| >> |    Group(+, -, 0);
| >> | }
| >>
| >> Ring should be both Monoid and Group, whether they shoud be
| >> categories, I don't really know.
| 
| Well, think of Axiom's Category as just a list of function (and
| constant) signatures.

See my last message in response to Bill's post for why I made that
statement. 
I believe, the implementation aspect that a Category is just a list of
functions is orthogonal.

| Well, as far as I know, something that is of type Category in
| Aldor/Axiom should be near to a mathematical category.

But that is not true, for any measure "nearness" I could think of :-)

| (But I am not
| the original designer and unfortunately there is no page on the
| AxiomWiki that explains it clearly.
| 
| Anyway, what I suggested above is perhaps not so close to mathematics
| as I and probably other mathematicians would like it to be.
| 
| The point is that one speaks of a "category of rings, groups, monoids,
| etc.), but not of a "category of rings(*, 1, +, -, 0)". So defining
| those structures in Axiom without arguments would be highly preferable.

I profoundly disagree.  Any respectable source on algebraic structures
defines rings as tuples.  When one colloquially says "take a monoid",
one speaks of that tuple, and it is also understood that the
components of that tuple are parameters, and as such will vary from
one tuple to another.  What the current system does is to say
"oh, the parameters are named the same" and later discover that that
"oh" is causing serious troubles.  Then it is decided to have Abelian
monoid not having anything to do with monoid.  That is at least
confusing. 

Computers are notoriously known not to good at reading minds, and when
they guess they usually guess wrong.  Furthermore, mathematics
discourses are highly syntactically ambiguous.  For computational
mathematics point of view, one needs to hunt those ambiguities and
flesh them out. 

| However, there is no way in Axiom to express that a Ring is a Monoid
| (SemiGroup if you like) "with respect to multiplication" and a Group
| (which is also a Monoid) "with respect to addition".

I understand there is no way.  My issue is *why*? E.g. is it
fundamental or just implementation details that shrine into the
interface?  My suspected answer is that it is an artifact of the
used object-oriented technology.

[...]

| There are some experiments, however...
| http://citeseer.ist.psu.edu/poll98adding.html
| http://www.cs.kent.ac.uk/people/staff/sjt/Atypical/AldorExs/index.html

\start
Date: Tue, 28 Feb 2006 13:20:17 -0500
From: Tim Daly
To: Bill Page
Subject: Re: doyen and virtual appliance

My understanding of the "virtual appliance" concept would be something
like a regular application stripped down to the essential elements and
packaged as a virtual machine. So, for instance, you could take ProTools
or Cakewalk (music software), add a bunch of special purpose tools like
LilyPond (open source music notation software), remove anything not useful
like browsers/email/office/etc. Then you put the result in a virtual machine.

My view would be that it mimics the VCR... a standalone special purpose
device. Packaging it all in a virtual machine means that you don't have
to worry about corrupting your local machine or ending up in DLL hell.
Adding a virtual machine is a copy operation on the disk-image file.
Removing one is the same thing. It's quite useful.

I have a half dozen VMs that I regularly use for Axiom testing and
they are all quite incompatible.

So Doyen would be a virtual machine focused on adding and integrating
scientific software into a single purpose platform. A hyper-packaging
concept. Instead of installing a dozen tools to get a local axiom
wiki working you just copy the VM image. 

\start
Date: 02 Mar 2006 20:42:13 +0100
From: Gabriel Dos Reis
To: Bill Page
Subject: Re: Curiosities with Axiom mathematical structures

Bill Page writes:

| On February 26, 2006 12:31 AM Gabriel Dos Reis wrote:
| > ... 
| >   In the impressive diagram titled "Basic Agebra Hierarchy" displayed
| > in the Axiom Book (I only have a copy of the edition copyrighted 1992,
| > NAG), AbelianSemiGroup is not "derived" from SemiGroup, and similarly
| > AbelianMonoid is not "derived" from Monoid.  I find that curious as it
| > goes counter the mathematical fact that an AbelianMonoid *is* a
| > Monoid, with an additional algebraic law (commutation).  
| > 
| 
| The following is a prettier (I think) rendition of these diagrams
| done using GraphViz. It also contains a couple of corrections:
| 
| http://wiki.axiom-developer.org/book--main--1/Endpaper3
| 
| When viewed as pdf and in some dvi viewers this diagram includes
| live hyperlinks to the appropriate source files.

Thanks; I'll send it to friends with whom we are looking at "concepts".
That will save me from having to scan that page of the book.

\start
Date: Thu, 02 Mar 2006 23:05:06 +0100
From: Gregory Vanuxem
To: Tim Daly
Subject: PATCH : float2Sex (was Compiler coercion and DoubleFloat)

Hi,

> Greg,
>
> Can you send me a patch of the change you propose so I can apply it
> and test it?

Attached is the patch (pf2sex.patch) that allows the use
of DoubleFloat by default in the interpreter. Test it.

(1) -> 1.7+7.2

   (1)  8.9
                               Type: Float
(2) -> 1.7-7.2

   (2)  - 5.5
                               Type: Float
(3) -> -1.7-7.2

   (3)  - 8.9
                               Type: Float
(4) -> )boot $useBFasDefault:=false

(SPADLET |$useBFasDefault| NIL)
Value = NIL

(4) -> 1.7+7.2

   (4)  8.9000000000000004
                               Type: DoubleFloat
(5) -> 1.7-7.2

   (5)  - 5.5
                               Type: DoubleFloat
(6) -> -1.7-7.2

   (6)  - 8.9000000000000004
                               Type: DoubleFloat



Cheers,

Greg

> Tim
>

PS: For those who use the Doublefloat domain
    there is an another (undocumented) patch that adds a
    lisp format to the DoubleFloat output routine. Copy
    int/algebra/DFLOAT.spad to your working directory,
    patch it, compile it and ")lib" it when necessary.


(1) -> )boot $useBFasDefault:=false

(SPADLET |$useBFasDefault| NIL)
Value = NIL
(1) -> a:= matrix [[0.5978,0.2356], [0.4512,0.2355]]

        +      0.5978               0.2356       +
   (1)  |                                        |
        +0.45119999999999999  0.23549999999999999+
                               Type: Matrix DoubleFloat
(2) -> )lib DFLOAT
   DoubleFloat is now explicitly exposed in frame initial
   DoubleFloat will be automatically loaded when needed
from /home/greg/Axiom/DFLOAT.NRLIB/code
(2) -> doubleFloatFormat("~,4,,F")

   (2)  "~G"
                               Type: String
(3) -> a

        +0.5978  0.2356+
   (3)  |              |
        +0.4512  0.2355+
                               Type: Matrix DoubleFloat





--=-D9m7iwOXGBohxPS7FFxO

--- ../axiom-old/src/interp/pf2sex.boot.pamphlet	2005-08-14 14:05:13.999276768 +0200
+++ src/interp/pf2sex.boot.pamphlet	2006-03-02 17:06:41.863940168 +0100
@@ -369,8 +369,10 @@
     '"0"
   bfForm := MAKE_-FLOAT(intPart, READ_-FROM_-STRING fracPartString,
     LENGTH fracPartString, expPart)
-  [., frac, :exp] := bfForm
-  [["$elt", intNewFloat(), 'float], frac, exp, 10]
+  $useBFasDefault =>
+    [., frac, :exp] := bfForm
+    [["$elt", intNewFloat(), 'float], frac, exp, 10]
+  bfForm 
 
 loopIters2Sex iterList ==
   result := nil

--=-D9m7iwOXGBohxPS7FFxO

--- /usr/local/axiom/int/algebra/DFLOAT.spad	2006-02-11 16:02:12.350650696 +0100
+++ DFLOAT.spad	2005-07-24 18:23:33.051285856 +0200
@@ -62,6 +62,7 @@
         ++ Gamma(x) is the Euler Gamma function.
       Beta : (%,%) -> %
         ++ Beta(x,y) is \spad{Gamma(x) * Gamma(y)/Gamma(x+y)}.
+      doubleFloatFormat : String -> String	
       rationalApproximation: (%, NonNegativeInteger) -> Fraction Integer
         ++ rationalApproximation(f, n) computes a rational approximation
         ++ r to f with relative error \spad{< 10**(-n)}.
@@ -71,10 +72,17 @@
          ++ (that is, \spad{|(r-f)/f| < b**(-n)}).
 
  == add
+   format: String := "~G"
    MER ==> Record(MANTISSA:Integer,EXPONENT:Integer)
 
    manexp: % -> MER
 
+   doubleFloatFormat(s:String): String ==
+     ss: String := format
+     format := s
+     ss
+
+   
    OMwrite(x: %): String ==
      s: String := ""
      sp := OM_-STRINGTOSTRINGPTR(s)$Lisp
@@ -132,7 +140,7 @@
    -- rational approximation to e accurate to 23 digits
    exp1()           == FLOAT(534625820200,MOST_-POSITIVE_-LONG_-FLOAT$Lisp)$Lisp / FLOAT(196677847971,MOST_-POSITIVE_-LONG_-FLOAT$Lisp)$Lisp
    pi()             == PI$Lisp
-   coerce(x:%):OutputForm == outputForm(x pretend DoubleFloat)
+   coerce(x:%):OutputForm == outputForm(FORMAT(NIL$Lisp,format,x)$Lisp pretend DoubleFloat)
    convert(x:%):InputForm == convert(x pretend DoubleFloat)$InputForm
    x < y            == (x<y)$Lisp
    - x              == (-x)$Lisp

\start
Date: Thu, 02 Mar 2006 23:34:50 +0100
From: Ralf Hemmecke
To: Gabriel Dos Reis, Bill Page
Subject: Re: Curiosities with Axiom mathematical structures

On 03/02/2006 08:23 PM, Gabriel Dos Reis wrote:
> Bill Page writes:
> | On February 27, 2006 11:08 AM Gabriel Dos Reis wrote:
> | > Ralf Hemmecke writes:
> | > | Note that one would have to say something like
> | > | 
> | > | define Monoid(
> | > |    *: (%, %) -> %;
> | > |    1: %
> | > | ): Category == ...
> | > | 
> | > | define Group(
> | > |    *: (%, %) -> %,
> | > |    inv: % -> %,
> | > |    1: %
> | > | ): Category == ...
> | > | 
> | > | define Ring(.....): Category == with {
> | > |    Monoid(*, 1);
> | > |    Group(+, -, 0);
> | > | }
> | > 
> | > Ring should be both Monoid and Group, whether they shoud be 
> | > categories, I don't really know.

> The reason I previously said I did not see why Monoid should be a
> category is that the operation is already passed in as a parameter, so
> there would nothing to implement "inside" in the Monoid.

I had to read your statement several times until I got the point. I must 
admit that I probably have not thought clearly enough before I wrote 
down the code. But it's clear that als a (multisorted) universal algebra

define Monoid: Category == with {
   1: %;
   *: (%, %) -> %
}

can mathematically be seen as

   a Monoid is a tuple (%, (f_1, f_2)) where % is the underlying set,
   f_1 is the unit element and f_2 is multiplication.

(Unfortunately, nothing in the Aldor code above says anything about 
relations between 1 and *.)

But although the operations are called 1 and * that should not matter. 
They should be just place holders for the actual name of the operation 
in the concrete monoid.

 > | The point is that one speaks of a "category of rings, groups,
 > | monoids, etc.), but not of a "category of rings(*, 1, +, -, 0)".
 > | So defining those structures in Axiom without arguments would be
 > | highly preferable.

 > I profoundly disagree.  Any respectable source on algebraic structures
 > defines rings as tuples.

Did I say something else?

 > When one colloquially says "take a monoid",
 > one speaks of that tuple, and it is also understood that the
 > components of that tuple are parameters, and as such will vary from
 > one tuple to another.

I think we should not argue here, we all know what a monoid is.

But it seems that Aldor tries to fix a names for the functions f_1 and 
f_2 (namely 1 and * in the definition of Monoid above) and doesn't allow 
other names in Aldor-categories that inherit from Monoid.

But actually, only when a concrete monoid is constructed (i.e. an 
Aldor-domain), then % becomes the name of the domain and the 
placeholders f_1 and f_2 become concrete functions.

In some sense the Monoid from above is not a concrete monoid, but maybe 
one can really see it as the "object" part of a mathematical category. I 
cannot see the "morphisms", however.

Would be nice to learn something from the original designers of the 
language. ;-)


> Indeed, there would be a redundancy in the system.  The underlying type
> and the operation suffice to uniquely define the structure.  So that
> means, the other parameters are somehow "function" of the essential
> parameters. That implies that indeed Monoid will be a category which
> domains will implement by supplying the value for the neutral element.
> Same reasoning for Group where the type and the operation suffice to
> define the inverse and the neutral element.

Yes. The domain provides the value for the neutral element. And who 
provides the name for the neutral element? You know the domain Integer 
is both a Monoid with respect to addition and multiplication. You have 
just the identifier "1" in the category Monoid. How would I specify/name 
the additive unit element in Integer?

 > | However, there is no way in Axiom to express that a Ring is a Monoid
 > | (SemiGroup if you like) "with respect to multiplication" and a Group
 > | (which is also a Monoid) "with respect to addition".
 >
 > I understand there is no way.  My issue is *why*? E.g. is it
 > fundamental or just implementation details that shrine into the
 > interface?  My suspected answer is that it is an artifact of the
 > used object-oriented technology.

I cannot belief that this issue is fundamental, but I am not an expert 
in this field. I you could help to come up with a nice syntax that would 
allow a compiler to translate

   [*] a Ring is a SemiGroup "with respect to multiplication"
       and a Group (which is also a Monoid) "with respect to addition"

into reasonable binaries, I would highly appreciate it, since it would 
make Aldor even more "mathematical".

 > In fact, practicality dictates that the implementations in Axiom/Aldor
 > closely follow the mathematical structures.  For example, the only
 > assumption  I need to define the power of an element is that its
 > domain
 > has a monoidal structure.  From software engineering point of view,
 > Practicality dictates that I should not have to write duplicate codes,
 > one for additive operation, one for multiplicative operation when the
 > underlying mathematical structure is the same.

Well, I don't think it is necessary to duplicate code very much. One 
only has to do a little bit of work.

Take for example

MyBinaryPowering(
     X: Type,
     *: (X, X) -> X,
     N: with {
             zero?: % -> Boolean;
             one?: % -> Boolean;
             length: % -> MachineInteger;
             bit?: (%, MachineInteger) -> Boolean;
     }
): with {
         binaryPower: (X, X, N) -> X; -- binaryPower(x,y,n)=x*y^n
} == add {
         <<implementation: MyBinaryPowering>>
}

Well, it's a package, but by giving the operation * as a parameter, I 
can do different things with it, for example,

P ==> MyBinaryPowering(Integer, +$Integer, Integer);
T ==> MyBinaryPowering(Integer, *$Integer, Integer);

binaryPower(5, 3, 2)$P; -- equals 5+3*2
binaryPower(5, 3, 2)$T; -- equals 5*3^2

BTW, assume for a moment we could espress something like [*]. In that 
case it would not even help if I could write

MyBinaryPower(X: Monoid, N: with {...}): ...

because then it would not be clear what binaryPower would compute if the 
parameter X has two Monoid structures at the same time.

\start
Date: Tue, 28 Feb 2006 15:10:25 +0100
From: Gregory Vanuxem
To: Bill Page
Subject: RE: Compiler coercion and DoubleFloat

Hi,


Le mardi 28 f=E9vrier 2006 =E0 01:00 +0100, Bill Page a =E9crit :

> That's cool.
>
> Does '$useBFasDefault:=false' globally change the representation
> of DoubleFloat to lisp double-float?

No, the representation of DoubleFloat is already a lisp
double-float as far as i know.

> What is the advantage of lisp double-float over Axiom's
> DoubleFloat? Higher precision?
>
> (1) -> precision()$Float
>
>    (1)  68
>    Type: PositiveInteger
>
> Precisioni of Float is adjustable but the following are fixed.
>
> (2) -> precision()$DoubleFloat
>
>    (2)  53
>    Type: PositiveInteger
>
> (3) -> precision()$MachineFloat
>
>    (3)  16
>    Type: PositiveInteger
>
> -------
>
> If I set $useBFasDefault in the Axiom interpreter I get the
> following error:
>
> (1) -> )boot $useBFasDefault:=false
> (SPADLET |$useBFasDefault| NIL)
> Value = NIL
> (1) -> two4: DoubleFloat := 24.0
>
>    >> System error:
>    Caught fatal error [memory may be damaged]
>
> protected-symbol-warn called with (NIL)

Yes I have seen and i don't know why.
It isn't a problem for me since i change the value
of $useBFasDefault only in spad code and revert it at the end of
the code (i.e. just for the 'translation' of spad into lisp).

> -------
>
> So I suppose you have some specific application of this in the
> SPAD compiler?

\start
Date: 03 Mar 2006 08:18:50 +0100
From: Gabriel Dos Reis
To: Ralf Hemmecke
Subject: Re: 1: %

Ralf Hemmecke writes:

[...]

| > | However, this behaviour is exactly, the difference between a constant
| > | and a nullary function in Aldor.
| 
| > The difference is not that between a constant and a nullary function
| > -- btw, anything defined with "==" is a constant in Aldor :-)
| 
| Yes. As I said. "y" is constant "y()" is not.

yes, however that is because the body is side-effecting, not just
because of "()".

| > if your nullary function y evaluates to the *same* value for same
| > argument each time, then  it would do just fine.
| 
| I agree, but it does not evaluate to the same thing. And Aldor allows
| this.

yes, however the issue is with the implementation of y(), not because
of the the presence of ().  If "literal" was side-effecting you would
get similar trouble.

| I understand that mathematically a constant and a nullary
| function is not much of a difference. I would also conceptually agree
| if we speak about functional languages where there are no side
| effects. But Aldor allows side-effects.

I don't think the issue has to do with having a functional language or
not.
For example, I have been working on a proposal 

    http://public.research.att.com/~bs/N1521-constant-expressions.pdf

to require C++ compiler to evaluate calls to certain functions with
constant expressions at compile-time, provided their bodies are
"sufficiently simple".  Such functions achieve the mapping of
conceptual mathematical functions to computational ones.

|  > You won't see any difference.
| 
| Except, maybe for the running time if the compiler is not smart enough
| to remove
| the function call and just replace it with the value.

:-)

| >  The real difference in your program is that of *binding time*.
| 
| Of course, I agree, that "x" and "y()" can be treated as constants if
| "y" where a function in the mathematical sense (returning the same
| value for the same input). In that case it is just different "binding
| time".
| 
| But in the example I gave in my previous mail. "y" is not a function
| that returns the same value in each invocation. And you don't think
| that is a difference?

There is a difference, but I do believe the fundamental reason if
becaue of "()".

\start
Date: 03 Mar 2006 23:10:54 +0100
From: Martin Rubey
To: Martin Rubey
Subject: [ANN] Axiom Workshop 2006 - rescheduled!

Due to an unfortunate collission with another workshop at the same institute,
we were forced to re-schedule the axiom workshop 2006. The new date is

    Thursday, April 27, 10 am, to Saturday, April 29, noon.
                                    _
                                   (_)
                          __ ___  ___  ___  _ __ ___
                         / _` \ \/ / |/ _ \| '_ ` _ \
                        | (_| |>  <| | (_) | | | | | |
                         \__,_/_/\_\_|\___/|_| |_| |_|
                                    _
                                   (_)

         __          ______  _____  _  __ _____ _    _  ____  _____
         \ \        / / __ \|  __ \| |/ // ____| |  | |/ __ \|  __ \
          \ \  /\  / / |  | | |__) | ' /| (___ | |__| | |  | | |__) |
           \ \/  \/ /| |  | |  _  /|  <  \___ \|  __  | |  | |  ___/
            \  /\  / | |__| | | \ \| . \ ____) | |  | | |__| | |
             \/  \/   \____/|_|  \_\_|\_\_____/|_|  |_|\____/|_|

                            ___   ___   ___    __
                           |__ \ / _ \ / _ \  / /
                              ) | | | | | | |/ /_
                             / /| | | | | | | '_ \
                            / /_| |_| | |_| | (_) |
                           |____|\___/ \___/ \___/



                Domain Specific Packages and their Mathematics


with a special focus on


                             Discrete Mathematics


will take place at the Research Institute for Symbolic Computation

  http://www.risc.uni-linz.ac.at

in Hagenberg, Austria

  http://www.risc.uni-linz.ac.at/about/map

from Thursday, April 27, 10 am, to Saturday, April 29, noon.

-------------------------------------------------------------------------------

Axiom is a Computer Algebra System with a long tradition.  It recently became
free software. See http://www.axiom-developer.org for more details


The workshop aims at a cooperation of Axiom developers with developers of
packages written for other Computer Algebra Systems or developers of
stand-alone packages.  Furthermore, the workshop wants to make the potential of
Axiom and Aldor more widely known in order to attract new users and new
developers.


If you would like to attend the workshop, please let us know until Friday,
March 31 at the very latest.


There will be time for a limited number of contributed talks. If you would like
to give a talk, please send us title and a short abstract as soon as possible.


There is no conference fee, but it is expected that participants pay
accommodation and meals themselves.  There is a limited number of rooms
available in Hagenberg for approximately 26 EUR/night.  Contact
Martin Rubey for details.

-------------------------------------------------------------------------------


Apart from a crash-course in Axiom/Aldor, the following talks are planned:


Petr Hiliny:       MACEK - real structural computations with matroids

Martin Rubey:      Guessing formulas for sequences

Carsten Schneider: Sigma - A package for multi-summation

Nicolas M. Thiery: Implementing Algebraic Combinatorics -
                   some experiences with MuPAD-Combinat

-------------------------------------------------------------------------------


Organisers: Ralf Hemmecke
            Martin Rubey


Email: Martin Rubey

Homepage: http://wiki.axiom-developer.org/AxiomWorkShopRISC2006

\start
Date: Fri, 3 Mar 2006 00:24:49 -0500
From: Tim Daly
To: Bill Page
Subject: Theory of Type Classification

A series of papers worth reading:
http://www.jot.fm/issues/issue_2002_05/column5

\start
Date: 04 Mar 2006 00:45:42 +0100
From: Gabriel Dos Reis
To: Martin Rubey
Subject: Re: Curiosities with Axiom mathematical structures

Martin Rubey writes:

| Dear Gaby,
| 
| I just would like to say that I do follow your reasoning and I do
| think that we should consider whether it makes sense to adapt Aldor
| to cope with the situation under discussion.

Many thanks!

| However, I do believe that this would imply a lot of work, and we
| really should see how often this situation occurs in practice. Of
| course, it is sad that it does ocur already so deep down in the
| hierarchy, but if this is the only place where we are in trouble,
| maybe we should ignore it for the moment. 

I agree.  It is a hard place to leave with history -- that would be my
second summary of my involvement in evolving languages like C++.  
Nevertheless, if we cannot attain the ideals, we should try hard to
approximate them to the best of our capabilities.

| Do you have experiences with hacking compilers and the like?

yes, I have been working on GCC (mostly the C++ front-end and library)
for nearly a decade now.  I also have some experience in
program transformations.

| Do you think you could implement the necessary changes?

I don't know the internals of the Aldor compiler, so it is hard for me
to say how much of work it would take.  I suspect 'a lot' especially
since we do not have a "formal" definition of the language.

| Did you read the proposed solution by Nicolas Doye?

I have not get a chance to read his thesis -- however, I'm printing it
while I'm composing this message.  I'll get back to you.  
The next week and the one after will totally filled up for me by
daytime job and work on getting "concepts" for C++.  However, I expect
to send feedback relatively soon (assuming planes are delayed :-))

\start
Date: Fri, 3 Mar 2006 10:30:48 +0600 (NOVT)
From: Andrey G. Grozin
To: Francois Maltey
Subject: Re: Curiosities with Axiom mathematical structures

On Wed, 1 Mar 2006, Francois Maltey wrote:
> Why are there 2 underscore in _/_\ in boolean.spad ?
You can use any character in an identifier if you prepend _ to it. 
This _ does not become part of the identifier, it just says that the 
immediately following character (whatever it may be) should be treated as 
a letter. Normally, neither / nor \ may be part of identifiers. Prepending 
_ to each of them, you get a valid identifier _/_\

\start
Date: Fri, 03 Mar 2006 17:26:09 +0100
From: Gregory Vanuxem
To: Martin Rubey
Subject: Re: Curiosities with Axiom mathematical structures

Hi,

Le mardi 28 f=E9vrier 2006 =E0 12:41 +0100, Martin Rubey a =E9crit :
> Here you go:
>
> http://lists.nongnu.org/archive/html/axiom-developer/2005-09/msg00130.h=
tml
>
> or page 124 of
>
> http://worldofnic.org/research/phd.ps
>
> Gabriel Dos Reis writes:
>
> > | In fact it seems that this problem cannot be properly solved
> > | with Aldor. There was some discussion on this list, too.
> > |
> > | The reason is
> > |
> > | Rng(): Category == Join(AbelianGroup,SemiGroup)
> > |
> > | would give a problem...
> >
> > What problems?
>
> Well, if you inherit an operation, you cannot alter the name of the
> operation. Rng inherits really two different monoids, one for addition =
and one
> for multiplication.

> Thus there would be a name conflict...

Does someone know the compiler and/or the interpreter behavior (from
which category the operation is selected if the categories define this
function ?) in this case ?

\start
Date: Mon, 27 Feb 2006 17:01:56 -0600
From: MathAction (billpage)
To: MathAction
Subject: [DistributedMultivariatePolynomial] polynomial magic

This coercion from DMP to POLY seems to come from:
\begin{axiom}
)sh PolToPol
\end{axiom}

I think Martin Rubey has previously mentioned this package as
a potential source of problems... :)

PolToPol apparently dates back to 1988. Looking at the
source code:
http://wiki.axiom-developer.org/images/axiom--test--1/src/algebra/poltopol.spad.pamphlet
we see that the action happens here::

    dmpToP(dpol:DPoly) : P ==
      map(convert,dpol)$MPC3(Ov,Symbol,DP,IES,R,DPoly,P)

The 'convert' function is apparently from DMP and returns the
InputForm which internally is represented by a Lisp SExpression.
So for variables which are Symbols, then returns the internal
(Lisp) representation of the variable.

This 'map' function comes from::

  MPolyCatFunctions3(Vars1,Vars2,E1,E2,R,PR1,PR2): C == T where
    E1   : OrderedAbelianMonoidSup
    E2   : OrderedAbelianMonoidSup
    Vars1: OrderedSet
    Vars2: OrderedSet
    R    : Ring
    PR1  : PolynomialCategory(R,E1,Vars1)
    PR2  : PolynomialCategory(R,E2,Vars2)

  ...

    map(f:Vars1 -> Vars2, p:PR1):PR2 ==
      (x1 := mainVariable p) case "failed" =>
        c:R:=(retract p)
        c::PR2
      up := univariate(p, x1::Vars1)
      x2 := f(x1::Vars1)
      ans:PR2 := 0
      while up ^= 0 repeat
        ans := ans + monomial(map(f,leadingCoefficient up),x2,degree up)
        up  := reductum up
      ans

----------

I think there is a little cheating here in this SPAD code. In
addition to making some hidden assumptions about internal about
the representation of variables, i.e. that they are just Lisp
symbols, it also tells the following lies::

    Vars1: OrderedSet
    Vars2: OrderedSet

It seems unlikely to me that one could play the same tricks
in Aldor!

In any case what this code appears to do is to break down the
polynomial from the source domain and re-build it in the target
domain, term by term using the 'monomial' function from the
target domain.

\start
Date: Thu, 2 Mar 2006 23:25:29 -0500
From: Tim Daly
To: Gregory Vanuxem
Subject: Re: PATCH : float2Sex (was Compiler coercion and DoubleFloat)

Greg,

Your patch was applied and will be tested and added at the next release.
I added the attached documentation to the sf.spad.pamphlet file (first
attachment) and the pf2sex file (second attachment)

Tim

=========================================================================
\section{domain DFLOAT DoubleFloat}
Greg Vanuxem has added some functionality to allow the user to modify
the printed format of floating point numbers. The format of the numbers
follows the common lisp format specification for floats. First we include
Greg's email to show the use of this feature:
\begin{verbatim}
PS: For those who use the Doublefloat domain
    there is an another (undocumented) patch that adds a
    lisp format to the DoubleFloat output routine. Copy 
    int/algebra/DFLOAT.spad to your working directory,
    patch it, compile it and ")lib" it when necessary.


(1) -> )boot $useBFasDefault:=false

(SPADLET |$useBFasDefault| NIL)
Value = NIL
(1) -> a:= matrix [ [0.5978,0.2356], [0.4512,0.2355] ]

        +      0.5978               0.2356       +
   (1)  |                                        |
        +0.45119999999999999  0.23549999999999999+
                               Type: Matrix DoubleFloat
(2) -> )lib DFLOAT
   DoubleFloat is now explicitly exposed in frame initial
   DoubleFloat will be automatically loaded when needed
from /home/greg/Axiom/DFLOAT.NRLIB/code
(2) -> doubleFloatFormat("~,4,,F")

   (2)  "~G"
                               Type: String
(3) -> a

        +0.5978  0.2356+
   (3)  |              |
        +0.4512  0.2355+
                               Type: Matrix DoubleFloat

\end{verbatim}
So it is clear that he has added a new function called
{\tt doubleFloatFormat} which takes a string argument that
specifies the common lisp format control string (\"{}\~{},4,,F\"{}).
For reference we quote from the common lisp manual \cite{1}.
On page 582 we find:

\begin{quote}
A format directive consists of a tilde (\~{}), optional prefix
parameters separated by commas, optional colon (:) and at-sign (@)
modifiers, and a single character indicating what kind of directive this is.
The alphabetic case of the directive character is ignored. The prefix
parameters are generally integers, notated as optionally signed decimal
numbers.

X3J13 voted in June 1987 (80) to specify that if both colon and at-sign
modifiers are present, they may appear in either order; thus \~{}:@R
and \~{}@:R mean the same thing. However, it is traditional to put the
colon first, and all examples in the book put colon before at-signs.
\end{quote}

\noindent
On page 588 we find:

\begin{quote}
\~{}F

{\sl Fixed-format floating-point}. The next {\sl arg} is printed as a
floating point number.

The full form is {\sl \~{}w,d,k,overfowchar,padchar}F. The parameter
{\sl w} is the width of the filed to be printed; {\sl d} is the number
of digits to print after the decimal point; {\sl k} is a scale factor
that defaults to zero.

Exactly {\sl w} characters will be output. First, leading copies of the
character {\sl padchar} (which defaults to a space) are printed, if 
necessary, to pad the field on the left. If the {\sl arg} is negative,
then a minus sign is printed; if the {\sl arg} is not negative, then
a plus signed is printed if and only if the @ modifier was specified.
Then a sequence of digits, containing a single embedded decimal point,
is printed; this represents the magnitude of the value of {\sl arg}
times $10^k$, rounded to {\sl d} fractional digits. (When rounding up
and rounding down would produce printed values equidistant from the
scaled value of {\sl arg}, then the implementation is free to use
either one. For example, printing the argument 6.375 using the format
\~{}4.2F may correctly produce either 6.37 or 6.38.) Leading zeros are
not permitted, except that a single zero digit is output before the
decimal point if the printed value is less than 1, and this single zero
digit is not output after all if $w = d + 1$.

If it is impossible to print the value in the required format in the
field of width {\sl w}, then one of two actions is taken. If the
parameter {\sl overflowchar} is specified, then {\sl w} copies of that
parameter are printed instead of the scaled value of {\sl arg}. If the
{\sl overflowchar} parameter is omitted, then the scaled value is
printed using more than {\sl w} characters, as many more as may be
needed.

If the {\sl w} parameter is omitted, then the field is of variable width.
In effect, a value is chosen for {\sl w} in such a way that no leading pad
characters need to be printed and exactly {\sl d} characters will follow
the decimal point. For example, the directive \~{},2F will print exactly
two digits after the decimal point and as many as necessary before the
decimal point.

If the parameter {\sl d} is omitted, then there is no constraint on the 
number of digits to appear after the decimal point. A value is chosen
for {\sl d} in such a way that as many digits as possible may be printed
subject to the width constraint imposed by the parameter {\sl w} and the
constraint that no trailing zero digits may appear in the fraction, except
that if the fraction to be printed is zero, then a single zero digit should
appear after the decimal point if permitted by the width constraint.

If both {\sl w} and {\sl d} are omitted, then the effect is to print the
value using ordinary free-format output; {\tt prin1} uses this format
for any number whose magnitude is either zero or between $10^{-3}$
(inclusive) and $10^7$ (exclusive).

If {\sl w} is omitted, then if the magnitude of {\sl arg} is so large
(or, if {\sl d} is also omitted, so small) that more than 100 digits
would have to be printed, then an implementation is free, at its 
discretion, to print the number using exponential notation instead,
as if by the directive \~{}E (with all parameters of \~{}E defaulted,
not taking their valued from the \~{}F directive).

If {\sl arg} is a rational number, then it is coerced to be a 
{\tt single-float} and then printed. (Alternatively, an implementation
is permitted to process a rational number by any other method that has
essentially the same behavior but avoids such hazards as loss of
precision or overflow because of the coercion. However, note that if
{\sl w} and {\sl d} are unspecified and the number has no exact decimal
representation, for example 1/3, some precision cutoff must be chosen
by the implementation; only a finite number of digits may be printed.)

If {\sl arg} is a complex number or some non-numeric object, then it 
is printed using the format directive {\sl \~{}w}D, thereby printing
it in decimal radix and a minimum field width of {\sl w}. (If it is
desired to print each of the real part and imaginary part of a 
complex number using a \~{}F directive, then this must be done explicitly
with two \~{}F directives and code to extract the two parts of the
complex number.)


\end{quote}

=====================================================================
\section{Changes}
In the function [[float2Sex]] we need to special case the return value
if the global variable [[$useBFasDefault]] is set to true. This variable
allows ``big'' floating point values.

The change can be seen from this email from Greg Vanuxem:
\begin{verbatim}
Attached is the patch (pf2sex.patch) that allows the use 
of DoubleFloat by default in the interpreter. Test it.

(1) -> 1.7+7.2

   (1)  8.9
                               Type: Float
(2) -> 1.7-7.2

   (2)  - 5.5
                               Type: Float
(3) -> -1.7-7.2

   (3)  - 8.9
                               Type: Float
(4) -> )boot $useBFasDefault:=false

(SPADLET |$useBFasDefault| NIL)
Value = NIL

(4) -> 1.7+7.2

   (4)  8.9000000000000004
                               Type: DoubleFloat
(5) -> 1.7-7.2

   (5)  - 5.5
                               Type: DoubleFloat
(6) -> -1.7-7.2

   (6)  - 8.9000000000000004
                               Type: DoubleFloat



\end{verbatim}

\start
Date: Tue, 28 Feb 2006 14:18:11 -0500
From: Tim Daly
To: Bill Page
Subject: Re: doyen and virtual appliance

Yeah, I'm familiar with Xen. It requires kernel tweaks.

The $200K was the bait, actually. One way to get funding 
is to put together a proposal. Not sure if there is only
one payout and if there is only one payout Doyen is unlikely
to win. But if they pay for multiple projects then it is
possible to get some Axiom funding thru this path.

\start
Date: 04 Mar 2006 08:46:46 +0100
From: Martin Rubey
To: list
Subject: Re: Curiosities with Axiom mathematical structures

mathaction-bounces@axiom-developer.org (Page, Bill) writes:

> We are talking about categories here, so this does not have
> any effect on the Axiom interpreter. Every function that the
> interpreter calls in located in some package or domain and
> if necessary the function can be selected based on the package
> or domain name. 

This is not true. Don't forget about default functions, for example powering in
the case of monoids!

Martin

PS: The more I think of it, the better I find the proposed solution of passing
the appropriate functions to the category. For example, along the following
lines. Of course, this code does *not* work currently. Rather, it is a proposal
for a possible extension of Aldor.

-------------------------------------------------------------------------------
)abbrev category MYMON MyMonoid
MyMonoid(m: (%,%)->%): Category == with
       square: % -> %
     add
       square a == m(a,a)

)abb domain WORD Word
Word: Exports == Implementation where

  Exports == with

    coerce: String -> %
    c: (%, %) -> %
    MyMonoid(c) -- in case of several different operations "c", we would need
                -- to provide the full signature, of course.
    
  Implementation == add

    Rep := String
    coerce(a: String): % == a
    c(a, b) == concat(a::Rep, b::Rep)
-------------------------------------------------------------------------------

This "solution" has two advantages: 

* we don't need any new syntax
* it also deals with the problem of implementing axioms, for example,
  "commutative" would simply be a category - without any exports.

I wonder whether this would be difficult to implement.

\start
Date: Thu, 02 Mar 2006 23:51:44 +0100
From: Ralf Hemmecke
To: Francois Maltey
Subject: Re: Curiosities with Axiom mathematical structures

Hi Francois,

if you insist on using SPAD for new code I cannot help.

On 03/01/2006 09:56 AM, Francois Maltey wrote:
> Hello, 
> 
> It seems I can define binary operator with the underscore _ 
> in any *.spad file.

In Aldor you don't need the underscore. An underscore is only needed if 
you want to write a function "mod_*" because if you write "mod*" that 
would mean "mod" "*" (two tokens).

> Are the name of the operator are fixed in the compiler or not ?

They are fixed Aldor. You find a list of them in the Aldor User Guide 
Section 4.7.1. (http://www.aldor.org/docs/HTML/index.html)

> Can I define my own new operator azerty or not ?

If you mean "binary infix operator" then the answer is NO.

>   for computing 1 azerty 2 azerty 3 azerty 4 without problem.

> Can I define my own factorial with ! or not ?

I haven't seen postfix operators in Aldor.

>   the ! operator is a postfix one.     3!
>   but the - operator is a prefix one. -3

> Why are there 2 underscore in _/_\ in boolean.spad ?

Simple. SPAD does not consider \ and / to be letters that can be used in 
an identifier. By escaping them with an _ you basically turn them into 
"nice" letters.



> Logic: Category == BasicType with
>        _~:        % -> %
>         ++ ~(x) returns the logical complement of x.
>        _/_\:       (%, %) -> %
>         ++ \spadignore { /\ }returns the logical `meet', e.g. `and'.
>        _\_/:       (%, %) -> %
>         ++ \spadignore{ \/ } returns the logical `join', e.g. `or'.
> 
> Can I do this in a *.input file for the interpreter ?

No idea.

> Can I fix a priority for each operator ?

No. That is fixed in Aldor.

\start
Date: 03 Mar 2006 11:56:35 +0100
From: Martin Rubey
To: Gabriel Dos Reis,
Subject: Re: Curiosities with Axiom mathematical structures

Dear Gaby,

I just would like to say that I do follow your reasoning and I do think that we
should consider whether it makes sense to adapt Aldor to cope with the
situation under discussion.

However, I do believe that this would imply a lot of work, and we really should
see how often this situation occurs in practice. Of course, it is sad that it
does ocur already so deep down in the hierarchy, but if this is the only place
where we are in trouble, maybe we should ignore it for the moment.

Do you have experiences with hacking compilers and the like? Do you think you
could implement the necessary changes? Did you read the proposed solution by
Nicolas Doye?

\start
Date: Mon, 27 Feb 2006 19:00:07 -0500
From: Bill Page
To: Gregory Vanuxem
Subject: RE: Compiler coercion and DoubleFloat

On February 27, 2006 6:05 PM you wrote:
> ...
> In fact, the parser, when it encounters a real number,
> returns integer part, fractional part, length of fractional part
> and exponent and call MAKE-FLOAT. MAKE-FLOAT returns mantissa,
> exponent (in base 10) and a "property" attached |:BF:|
> (for big float) if $useBFasDefault is true (its default value).
> postBigFloat will return, later,
> ((|elt| (|Float|) |float|) 23538526683701998541 -2 10)
>
> But if $useBFasDefault is false MAKE-FLOAT returns a lisp
> double-float.
>
> So i add, at the beginning of the code
>
> )boot $useBFasDefault:=false
>
> the code is:
>          two4: R := 24.0
>          fourty: R := 40.0
>          exp40: R := 235385266837019985.41
>
> and the compiler output is:
>
> (SEQ (LET (|:| |two4| (|DoubleFloat|)) 24.0)
>      (LET (|:| |fourty| (|DoubleFloat|)) 40.0)
>      (LET (|:| |exp40| (|DoubleFloat|)) 2.3538526683702E17)
>

That's cool.

Does '$useBFasDefault:=false' globally change the representation
of DoubleFloat to lisp double-float?

What is the advantage of lisp double-float over Axiom's
DoubleFloat? Higher precision?

(1) -> precision()$Float

   (1)  68
   Type: PositiveInteger

Precisioni of Float is adjustable but the following are fixed.

(2) -> precision()$DoubleFloat

   (2)  53
   Type: PositiveInteger

(3) -> precision()$MachineFloat

   (3)  16
   Type: PositiveInteger

-------

If I set $useBFasDefault in the Axiom interpreter I get the
following error:

(1) -> )boot $useBFasDefault:=false
(SPADLET |$useBFasDefault| NIL)
Value = NIL
(1) -> two4: DoubleFloat := 24.0

   >> System error:
   Caught fatal error [memory may be damaged]

protected-symbol-warn called with (NIL)

-------

So I suppose you have some specific application of this in the
SPAD compiler?

\start
Date: Sat, 04 Mar 2006 11:45:40 +0100
From: David Mentre
To: list
Subject: MediaWiki with literate programming

Hello,

Somebody pointed me to:
  http://literateprograms.org/LiteratePrograms:Welcome

This web site has adapted MediaWiki (the wiki engine behind Wikipedia)
to present literate programs in a wiki way and to allow online edition.
The infrastructure is based on noweb.

It might be a source of inspiration and/or code for Axiom.

\start
Date: 28 Feb 2006 16:06:52 +0100
From: Gabriel Dos Reis
To: Martin Rubey
Subject: Re: Curiosities with Axiom mathematical structures

Martin Rubey writes:

| Here you go:
| 
| http://lists.nongnu.org/archive/html/axiom-developer/2005-09/msg00130.html
| 
| or page 124 of 
| 
| http://worldofnic.org/research/phd.ps

Thanks, I'll read that carefully.

| Gabriel Dos Reis writes:
| 
| > | In fact it seems that this problem cannot be properly solved
| > | with Aldor. There was some discussion on this list, too.
| > | 
| > | The reason is 
| > | 
| > | Rng(): Category == Join(AbelianGroup,SemiGroup)
| > | 
| > | would give a problem...
| > 
| > What problems?
| 
| Well, if you inherit an operation, you cannot alter the name of the
| operation. Rng inherits really two different monoids, one for addition and one
| for multiplication. Thus there would be a name conflict...

Yes, that is what we discussed in the other messages.
Fundamentally, the problem is because inappropriate inheritance was
chosen, or rather, inheritance is inappropriate.

Suppose that the operation (and associated constants) are parameters
to Monoid, Group and so forth; why would now have a construct like

    Ring(mul, add, zero, one)  == Join(Group(add, zero),
                                       SemiGroup(mul, one)) ....

would cause a conflict?

\start
Date: Tue, 28 Feb 2006 10:40:40 +0100
From: Ralf Hemmecke
To: Bill Page
Subject: Re: Bug in Tuple
Cc: Stephen Watt

On 02/27/2006 09:57 PM, Bill Page wrote:
> Ralf,
> 
> On February 25, 2006 4:22 PM you wrote:
>> Can someone explain that?
>>
>> Ralf
>>
>> (6) -> Tuple(Integer) has coerce: Tuple(Integer)->PrimitiveArrayInteger
>>
>>     (6)  false
>>                                                               
>>    Type: Boolean
> 
> I presume what you meant to write was:
> 
>   Tuple(Integer) has coerce:Tuple(Integer)->PrimitiveArray(Integer)
> 
> and that something like this might be possible in Aldor, right?

Well, I should have written something like

Tuple(Integer) has with {length: % -> MachineInteger}

but that doesn't work in Axiom either. And the reason in my eyes is that 
  I cannot remember that there exists a description of SPAD/Axiom that 
covers something like http://www.aldor.org/docs/HTML/chap7.html#9.

But try in Aldor...

aldor -gloop
#include "aldor"
#include "aldorinterp"
%3 >> Tuple Integer
   () @ Join(
  with
     ==  add ()
,
  with
         element: (%, MachineInteger) -> AldorInteger
         dispose!: % -> ()
         length: % -> MachineInteger
         tuple: (MachineInteger, Pointer) -> %
     ==  add ()
)
T%4 >> Tuple(Integer) has with {length: % -> MachineInteger}
T @ Boolean

> However the result the Axiom interpreter returns is still 'false'.

> So far as I can tell from the available Axiom documentation the
> 'has' expression only allows categories and axioms on the right
> hand side (rhs). So we can write:
> 
>   Tuple(Integer) has CoercibleTo(OuputForm)
>
> and
> 
>   Integer has commutative("*")
> 
> but almost anything else on the rhs returns either 'false' or
> an error message. You might have expected to be able to write:
> 
> (14) -> Tuple(Integer) has with Tuple(Integer)->PrimitiveArray(Integer)
>    Internal Error
>    Unexpected error in call to system function pf2Sex1
> 
> but that apparently doesn't work either. :(

Well, you probably meant:

Tuple(Integer) has with coerce: %->PrimitiveArray(Integer)

However, you agree, that the "with" expression *is* a category.

> Just as in Aldor different things might be possible in SPAD, but
> I was't able to find any documentation about this.

Right, Axiom is a bit weak here. But since we are (hopefully) agree to 
take Aldor for further development, then this is not such a big problem. 
The only point is that Axiom (as interpreter) should behave according to 
the Aldor language specification.

BTW, you cannot simply write something like

define MyCat: Category == with {
   +: (%, %) -> %;
   Commutative(+);
}

in Aldor, since that "commutative" is interpreted as a function with one 
argument and it should return a category. So you would have to write 
another category

define Commutative(f: (%, %) -> %): Category == with;

But that doesn't work since it is not clear what % refers to.

But you can at least compile the following:
--BEGIN
#include "aldor"
define Commutative(T: Type, f: (T, T) -> T): Category == with;
define CommutativePlus: Category == with {
   +: (%, %) -> %;
   Commutative(%, +);
}
--END

What is the problem here? Look at the definition of "Commutative".
Shouldn't Aldor allow me to write something like

--BEGIN
#include "aldor"
define Commutative(T: Type, f: (T, T) -> T): Category == {
   n: Integer := 1$Integer; while n>0 repeat n:=n+1;
   with;
}
define PlusCat: Category == with {
   +: (%, %) -> %;
   *: (%, %) -> %;
   Commutative(%, +);
}

Dom: PlusCat == add {
	(x: %) + (y: %): % == x;
	(x: %) * (y: %): % == y;
}

main(): () == {
	import from Dom;
	import from TextWriter, String, Character;
	b: Boolean == Dom has Commutative(Dom, +$Dom);
	stdout << "Dom has Commutative(Dom, +) = " << b << newline;
	c: Boolean == Dom has Commutative(Dom, *$Dom);
	stdout << "Dom has Commutative(Dom, *) = " << c << newline;
}
main();
--END

Yes, this file compiles and runs successfully.
aldor -grun -laldor comm.as
Dom has Commutative(Dom, +) = T
Dom has Commutative(Dom, *) = T

How could this program stop? In fact, already the compiler has to 
perform an evaluation of "Commutativive(%, +)", so it could never have 
produced the program. And why T is returned for "*"?

Very strange. Can somebody explain?

\start
Date: Tue, 28 Feb 2006 10:25:40 +0100 (CET)
From: Peter Kruppa
To: list
Subject: missing bootsys image

Hi,

I am trying (again) to build axiom on FreeBSD .
Is there any well known reason why
 	../obj/freebsd/bin/bootsys
wasn't created?
I have got executables called
 			../depsys
                         ../lisp
in there. So something must have worked correctly so far.

Thanks for your answers,

\start
Date: Mon, 27 Feb 2006 14:08:29 -0600
From: MathAction (Bill Page)
To: MathAction
Subject: [DistributedMultivariatePolynomial] substitution?

Wiliam Sit wrote::

  S:=FRAC POLY INT
  Q:=DMP([x], S)
  a:Q:=x
  b:Q:=a/a
  ...
  signature:
    ((DMP([x],POLY INT) -> POLY INT),FRAC DMP([x],POLY INT)) -> FRAC POLY INT

  ... shows clearly that the coercion from 'DMP(['x'], FRAC POLY INT)'
  to 'FRAC POLY INT' for the denominator a is really a substitution,
  implemented using the map function from FRAC2 package, taking '1/x_Q'
  to '1/x_S' via the substitution 'x_Q' to 'x_S'.

I do not understand why you call this a "substitution". Reading the
source code for FRAC2 we see that 'map' just applies the coercion::

  (DMP([x],POLY INT) -> POLY INT)

to both the numerator and the denominator of some 'Fraction' to produce
another 'Fraction' over a different domain.

The critical thing here is the coercion. This coercion maps the members
and functions of 'DMP([x],POLY INT)' into members and functions of
'POLY INT'. In particular it maps '*' in DMP to '*' in POLY INT. As a
result the symbol 'x' used as both the polynomial variable and in the
coefficient domain 'DMP' are treated the same way as a polynomial
variable of 'POLY'.
For example:
\begin{axiom}
A1:=monomial(x,0)$DMP([x],POLY INT)
degree A1
B1:=monomial(1,1)$DMP([x],POLY INT)
degree B1
(A1=B1)::Boolean
A2:=A1::POLY INT
B2:=B1::POLY INT
(A2=B2)::Boolean
\end{axiom}

This is just the same sort of thing that happens all the
time when we use a coercion to move from say, 'POLY INT' to
'EXPR INT'. There is no substitution going on here.

\start
Date: Tue, 28 Feb 2006 03:55:01 -0600
From: MathAction (wyscc)
To: MathAction
Subject: [DistributedMultivariatePolynomial] 

Bill: One more thing: I am amazed that you keep insisting on using the same symbol for two different mathematical objects in one expression. You did this when you use the expression $Q(R[x])[x]$ and say that 

>the x in $Q(\dots)[x]$ remains transcendent over the x in $Q(R[x])$

I thought you had agreed not to do this! You wrote:
<pre>
>Date: Fri, 24 Feb 2006 14:39:45 -0500
>
>William 
>
>On Friday, February 24, 2006 8:07 AM you wrote:
>
>> Any scientific literate person, when (s)he wrote down:
>>
>>   2*x + 1/x
>>
>> would mean that there is only ONE x, the x means the same
>> thing throughout the expression.
>
>Yes.
</pre>

\start
Date: Mon, 27 Feb 2006 21:00:32 -0600
From: MathAction (wyscc)
To: MathAction
Subject: [DistributedMultivariatePolynomial] 

>The evaluation of 1/x x in
 'DistributedMultivariatePolynomial([x],Polynomial Integer)' is
 equivalent to 1 but it is not equivalent to 1 in
 'DistributedMultivariatePolynomial([x],Fraction Polynomial
 Integer)'. It is precisely because the coefficient ring is
 different. This is completely acceptable to me.

I am sorry, Bill. This is not acceptable. $R[x]$ is a subring of
$Q(R)[x]$ where $Q(R)$ is the quotient field of $R$. 1/x is in neither
of these polynomial rings, (((No matter what $R$ is!))). This is a
FACT of mathematics, the meaning of what an indeterminate x over a
ring or field is. 1/x ONLY lives in $Q(R[x]) = Q(Q(R)[x]$, where
$(1/x)\times x = 1$.

If you want Axiom to be "The Scientific Computation System", you can't
have it any other way.

The only meaningful justification that 

>1/x x in 'DistributedMultivariatePolynomial([x],Polynomial Integer)'
 is equivalent to 1

is to view 1/x x in its quotient field, perform the operation, gets 1
and then retract it back to the ring. (This is mathematics, and
independent of how the Interpreter does it).

There is NO justification for 

>but it is not equivalent to 1 in
 'DistributedMultivariatePolynomial([x],Fraction Polynomial Integer)'

where the only explanation you can give is to view 1/x in the ground
ring (which is totally wrong mathematically)!

Contrary to Tim's view, I don't think we can both be "right". You are
wrong, admit it, and let's move on.

William

PS I would challenge you to show me any other CAS that would interpret
1/x x to be anything other than 1 (if you can, then that CAS is also
wrong!)

PPS: This error is entirely due to the Interpreter and has nothing to
do with particular implementations of polynomial rings like DMP, UP,
SUP, you name it. When different polynomial implementations are used
and we get different coercion sequences leading to different results
on such a simple computation, it is time to get rid of automatic
coercion in the Interpreter. There is simply no coercion theory to
guarantees that one can get from point A to point B in a computation
(A = $(1/x)\times x$ and B = 1) independent of domains and the path of
coercions. We need confluence in such rewriting.  Axiom would be so
much easier to learn if it weren't for the automatic coercions in the
Interpreter. One benefit would be: if you test code in the Interpreter
successfully, you can immediately move it to the compiler without
change.

\start
Date: Thu, 2 Mar 2006 01:10:48 -0500
From: Tim Daly
To: Gregory Vanuxem
Subject: Re: Compiler coercion and DoubleFloat

Greg,

Can you send me a patch of the change you propose so I can apply it
and test it?

\start
Date: 04 Mar 2006 17:26:07 +0100
From: Martin Rubey
To: axiom-dev <list>
Subject: [ANN] Axiom Workshop rescheduled!

Since it seems that it hasn't got through yet, I post it again...

Due to an unfortunate collission with another workshop at the same institute,
we were forced to re-schedule the axiom workshop 2006. The new date is

    Thursday, April 27, 10 am, to Saturday, April 29, noon.
                                    _
                                   (_)
                          __ ___  ___  ___  _ __ ___
                         / _` \ \/ / |/ _ \| '_ ` _ \
                        | (_| |>  <| | (_) | | | | | |
                         \__,_/_/\_\_|\___/|_| |_| |_|
                                    _
                                   (_)

         __          ______  _____  _  __ _____ _    _  ____  _____
         \ \        / / __ \|  __ \| |/ // ____| |  | |/ __ \|  __ \
          \ \  /\  / / |  | | |__) | ' /| (___ | |__| | |  | | |__) |
           \ \/  \/ /| |  | |  _  /|  <  \___ \|  __  | |  | |  ___/
            \  /\  / | |__| | | \ \| . \ ____) | |  | | |__| | |
             \/  \/   \____/|_|  \_\_|\_\_____/|_|  |_|\____/|_|

                            ___   ___   ___    __
                           |__ \ / _ \ / _ \  / /
                              ) | | | | | | |/ /_
                             / /| | | | | | | '_ \
                            / /_| |_| | |_| | (_) |
                           |____|\___/ \___/ \___/



                Domain Specific Packages and their Mathematics


with a special focus on


                             Discrete Mathematics


will take place at the Research Institute for Symbolic Computation

  http://www.risc.uni-linz.ac.at

in Hagenberg, Austria

  http://www.risc.uni-linz.ac.at/about/map

from Thursday, April 27, 10 am, to Saturday, April 29, noon.

-------------------------------------------------------------------------------

Axiom is a Computer Algebra System with a long tradition.  It recently became
free software. See http://www.axiom-developer.org for more details


The workshop aims at a cooperation of Axiom developers with developers of
packages written for other Computer Algebra Systems or developers of
stand-alone packages.  Furthermore, the workshop wants to make the potential of
Axiom and Aldor more widely known in order to attract new users and new
developers.


If you would like to attend the workshop, please let us know until Friday,
March 31 at the very latest.


There will be time for a limited number of contributed talks. If you would like
to give a talk, please send us title and a short abstract as soon as possible.


There is no conference fee, but it is expected that participants pay
accommodation and meals themselves.  There is a limited number of rooms
available in Hagenberg for approximately 26 EUR/night.  Contact
Martin Rubey for details.

-------------------------------------------------------------------------------


Apart from a crash-course in Axiom/Aldor, the following talks are planned:


Petr Hiliny:       MACEK - real structural computations with matroids

Martin Rubey:      Guessing formulas for sequences

Carsten Schneider: Sigma - A package for multi-summation

Nicolas M. Thiery: Implementing Algebraic Combinatorics -
                   some experiences with MuPAD-Combinat

-------------------------------------------------------------------------------


Organisers: Ralf Hemmecke
            Martin Rubey


Email: Martin Rubey

Homepage: http://wiki.axiom-developer.org/AxiomWorkShopRISC2006




\start
Date: Sat, 04 Mar 2006 11:31:03 -0500
From: William Sit
To: Gabriel Dos Reis
Subject: Re: Curiosities with Axiom mathematical structures

Hi Gabe:

Gabriel Dos Reis wrote:
> William Sit writes:
> 
> |  Bill Page writes:
> |
> | > | I don't think there is any essential reason why SemiGroup and
> | > | Monoid could not be implemented in the way you suggest. For
> | > | example:
> | > |
> | > | )abbrev category SGROUP SemiGroup
> | > | SemiGroup(m:Symbol): Category == SetCategory with
> | > |       m: (%,%) -> %    ++ returns the product of x and y.
> | > |       associative(m)
> | > |
> | > | )abbrev category ABELSQ AbelianSemiGroup
> | > | AbelianSemiGroup(m:Symbol): Category == SemiGroup(m) with
> | > |       abelian(m)
> | > |
> |
> | Yes, there are no theoretical reasons, but there are plenty of
> | practical ones.

> In fact, practicality dictates that the implementations in Axiom/Aldor
> closely follow the mathematical structures.  

You probably misread my response to Bill. I was saying there are plenty of
practical reasons NOT to implement in the way suggested, but no theoretical
reasons NOT to implement the goal you suggested, in some way.

> For example, the only
> assumption  I need to define the power of an element is that its domain
> has a monoidal structure.  From software engineering point of view,
> Practicality dictates that I should not have to write duplicate codes,
> one for additive operation, one for multiplicative operation when the
> underlying mathematical structure is the same.  That is
> the least I expect from a non-mathematically-oriented system.


Agreed in theory, not in practice.  We should distinguish two issues: (1)
derived  operations that depend only on the defining operations should be
generically implemented and inherited, and (2) how to handle the notations
(equivalently, identifiers in computer science terminology) for the defining
operations and derived operations.  Notations (resp. identifiers) are extremely
important in mathematics(resp. computer programming). Mathematics can only
progress and make strides when good notations are invented AND agreed to.
Examples are the notations for differentiation and integration.  A software
system that deviates from the universally accepted mathematical notations, even
if for the sake of valid ideals,  will not be usable and at best be hardly
usable. Computer programs can work correctly only if identifiers are scoped
correctly and such scoping should be transparent when identifiers are
overloaded.

The concept of a ring is almost omnipotent in all branches of mathematics, and
the standard notations for the multiplication (*) and addition (+) are adopted.
You may almost forget about that a ring is a monoid wrt to * and an abelion
monoid wrt + because what is important to a ring is the two together, how they
interact via the distributive laws. A practical way to support the structure of
a ring requires these two separate notations. Even in the simple case of your
example for repeated operation (which you called "power"), the two operations *
and + will produce (and should produce) outputs in two different notations: x^n
(power) and n*x (multiple). In this case, the repeated operations in fact occur
both in an *abelian* submonoid setting even if multiplication is
non-commutative.

So I hope we need not argue a third issue: (3) maintaining standard notations
for the defining operations in common algebraic structures.

I think your ideal of avoiding "duplicate codes" (much like the ideal of sharing
dll libraries) is misplaced. In order to avoid duplicating code due to the dual
use of * and + in the monoid structures, one will have to, as admitted
throughout these discussions by everyone, ADD tons of code and in the end making
writing software for a ring more difficult, not less. Not only that, I doubt if
the experts here could agree to how that additional code should be written, even
if everything were started from scratch.

I think a proper way to "allow" the kind of identification of underlying
mathematical structures that are the same is the concept of "isomorphism". For
isomorphisms between two domains in Axiom, this is approximated via facilities
called "map". In the ideal world, one should design code that can implement
inheritance via isomorphisms. However, it should be emphasized that implementing
isomorphisms involves extra code as well as duplicating code, but it will allow
flexibility in notations that is the facilitator of all mathematics thinking
(and in contrast, it creates a tedious complexity in programming due to the
rigidity of computer languages).

However, there is a caveat. Isomorphisms between a category specification and an
actual domain in that category are meaningless, mathematically speaking. The
categorical specification has no default sample domain. So we need a simulated
isomorphism mechanism. The parameter passing method is one way to indicate an
isomorphism but for more complicated structures, this becomes very clumbersome. 
We need to figure out a way to indicate isomorphisms that will allow, as did the
parameter passing method, multiple isomorphisms involving the same domain (or
subdomains) and category constructor. Putting this aside for future discussions,
let's concentrate on the interpretation for just a single isomorphism. 

Let's say in Monoid, I used & for the defining monoid operation. If I want to
form a monoid domain with set Integer and operation #, (Integer, #), I would
have to specify to the compiler an isomorphism. The compiler would have to
execute this isomorphism by replacing each occurrence of '&' by '#' in the
category definition temporarily before matching the domain signatures with the
category signatures. This necessitates that in the category definition of a
monoid, and in the domain code of an actual monoid, we can identify and separate
the defining operations from the derived operations -- which is currently not
the case. Let's assume this is done nonetheless. Then the generic code of
derived operations (such as 'square' or 'power'), if available, will have to be
translated, duplicated, and inserted in the domain for correct signatures and
implementation. Those derived operations that are not generically implemented
will be handled like the defining operations except that their identifiers will
not be changed.  Finally, the properties of the defining operations must also be
translated, duplicated and inserted into the domain. The code in the category
should be restored afterwards.

Of course, in the cases where the default notations are used, none of the above
is necessary and thus using default notations gain efficiency over a new set of
notations. Moreover, when the notations are changed, even the properties of the
defining operations must be copied to the domain itself. This creates extra
search info in the database for the compiler and interpreter. Thus this
mechanism "duplicates" code, much like the templates in C++ classes. 

This mechanism is different from parameter passing in its details but not in
essense. The difference is that it emphasizes the role of isomorphisms and
suggests a way to retain default notations in the categorical definitions while
allowing new notations. The details also highlight some requirements for
implementation. As we shall see later, there are more.

A similar isomorphism mechanism already exists between two implementations of
the same mathematical object where the two data representations of objects in
the domains differ. The domains in POLYCAT are nothing but such and are viewed
as isomorphic using an extensive set of map facilities (which typically
translates by deconstructing a polynomial in one domain and then reconstructing
it in the other domain).  The different implementations of these domains are not
considered duplicated code for the mathematical structure of a polynomial ring,
and indeed are essential to the efficient implementation of certain algorithms
in polynomial rings. These map facilities need to be updated in case notations
for defining operations of the two domains are different.

> If the system does not let one do that, then the system is practically
> defective :-)

All systems have defects. Be realistic!
 
> | I think such constructs will make it more difficult for the
> | Interpreter to work since it would not be able look up the
> | appropriate signature from domains that have not been instantiated
> | during the session.
> 
> That depends on the *kind of lookup*.  For a system where all symbols
> are global with no proper scoping, then yes that is a problem.  But
> then, if the system is designed to write mathematical software it
> should have lookup rules that make that possible.  Said differently,
> the system should be designed to serve writing "natural" mathematical
> software.

These "look-up" rules are generated precisely by the isomorphisms discussed
above. However, to write "natural" mathematical software, we need to adopt the
"natural" mathematical notations accepted by the mathematical and scientific
community.

> | Of course, if the Interpreter  knows what to instantiate, that won't
> | be a problem. But how will the Interpreter be able to know?
> 
> By adequate scoping rules.

Scoping rules play a small part in the isomorphism mechanism. Scoping rules are
needed when the same identifiers (minus the prefixes or info used to aid proper
scoping) are used in different contexts (scopes).  Isomorphisms (as described
above) are needed to inherit properties when corresponding operators (between a
domain and its category, or between two domains) have different identifiers
(notatiosn) for the defining operations.  The Interpreter needs the duplicated
code in its database for domains which use a non-standard set of identifiers for
the defining operations. The non-standard set of identifiers are distinct from
the standard identifiers.
 
> |  Indeed, how is a user to know what symbol was used, say, for the
> | operations? What if the user instantiates Integer with both * and +
> | for the same operations in two instances?
> 
> When both will be in scope.  If the user uses * with Integer, the
> system knows that (*, Int) is a monoidal structure.  Same if
> (+, Int).

I meant using * for multiplication of integer in one instantiation, and using +
for multiplication of integer in another instantiation, two notations for the
same set and operation. (I am not advocating this! see original message for the
context, please).
 
> | Can a compiler or interpreter catch this?
> 
> Yes, definitely.

Really? The two copies of the multiplicative monoid of integers are compiled at
different times and instantiatiated in the SAME interpreter session. Can the
interpreter execute something like 3*4+5 correctly and give 60 (without package
calls)? What if we have two copies of the ring of integers where in one the
notations for * and + are interchanged? When this sort of arbitrary notations is
allowed, every function call need to be a package call or else it would be a
nightmare to explain all the "strange" answers. (The isomorphism mechanism does
not seem to solve this problem).

> | If not, it would be a nightmare of bug reports.
> 
> It would be a nightmare only if one takes the rules that a type has a
> unique algebraic structure.  That is both theoretically and practically
> false.  See the examples (+, NN), (*, NN), (NN, max) I gave earlier.

Quite the contrary. When a type has a unique algebraic structure (I presume you
meant only default notations for its defining operators are allowed), there is
no ambiguity possible like the 3*4+5 above. I don't disagree this state is
non-optimal, but the proposed state has its problems. Your examples show three
*different* binary operations with three *different* identifiers.  If you want
to inherit say the function 'square' for each, you need to, as explained above,
establish three isomorphisms to the fictitious domain % in the categorical
definition and translate, duplicate, and insert 'square' in each domain so that
the Interpreter can find the translated defining operations and their
properties, or else you have to package call because the Interpreter has no way
to tell when you write 'square(5)' to which of the three monoids 5 would be in.
It would be all the more of a problem when all the three monoid structures
co-exist in the *same* domain (multiple inheritance). Notice that while the
domain (NN, +, *, max) exists, the domains (NN, +), (NN, *), and (NN, max) are
transiently constructed during compilation only! There is no (NN, +).NRLIB for
example. Besides, you can only have ONE signature 'square: % -> %' in the domain
(NN, +, *, max), not three.  This possibly is an important reasons why
AbelianMonoid does not descend from Monoid.  


There seems to be no good way to solve this multiple inheritance problem.
One way is for the compiler to tag each of the derived operations differently
for each instance of a category constructor, so we can have three different
'square', each replaced by a different identifier. But clearly, not only will
this destroy the very desirable overloading of operators, it will also destroy
the membership of the domain in the monoid category in each case.

Another way will be to ask the compiler to create the missing (NN,+).NRLIB and
the other two. Then (NN, +, *, max) will have three imported 'square' functions
and each will have to be package called. Not a big deal, yet. However, there is
then the danger of first too many NRLIBs and second there will be need for
multiple copies of (NN, +).NRLIB, one for each time (NN, +) becomes a subdomain,
and since the + may mean different operations (it is only an identifier, not a
distinguished identifier), each will in turn need to be tagged by their
superdomain! That will quickly become a nightmare.



Needless to add, such automated translation, duplication and insertion are
simply not supported currently (see SandBoxMonoid).

> 
> | By allowing renaming of operations (even just all binary operations), the
> | categorical notation for * or + no longer exists and it would be
> | impossible for the Interpreter to search for a suitable signature in
> | a categorical manner --- only on a specific domain by domain (and
> | for instantiated domains only for that matter) basis.
> 
> I don't see what "renaming" has to do with this; from what I see, it
> can only lead to greater confusion.

Renaming is really setting up an isomophism using the identity map (if the
underlying sets are the same set, or the vacuous map if between a category and a
domain). This is similar to the renaming of ? to x for the main variable in
domains like UP(x, INT). The current renaming mechanism is too simplistic and
superficial and in my opinion, is the cause for errors. In your idealized
version of a monoid definition, the monoid operation should have no name, like a
?, because it is abstracted. But in any real monoid (domain), the operation must
have a name, just like a polynomial in UP needs a name for the main variable
(which is passed as a parameter). Without a name categorically, there can be no
search categorically. The way the Interpreter currently matches ? in UP(x, INT)
can easily be made to say x = y when they are distinct variables.

x:=variables (2*x::UP(x,INT));
y:=variables (2*y::UP(y,INT));
t:Boolean:= x=y

would return 'true'.

> However, passing the operation as a parameter to the structure is a
> first approximation of a viable solution.

The entire 'with' clause in constructors is to pass operations as parameters.
But their identifiers cannot be changed! (see SandBoxMonoid). It is not how to
specify an isomorphism that is the problem, it is how the compiler will
interpret and act on that specification that is the problem.
 
> | I do recognize some limitations for having two monoid categories
> | structured on two different operator notations. For example, there
> | is no commutative monoid with * as the multiplication and these are
> | needed (if one wants to look at the set of monomials in several
> | variables as a multiplicative monoid). However, it is far easier to
> | have say, AbelianAdditiveMonoid and AbelianMultipicativeMonoid
> | categories (cf. one AbelianMonoid where the operator must be "+")
> | than to implement all operators used in algebras as parameters.
> 
> I beg to differ.  Having to write duplicate codes is known to be a nightmare
> and fruitful source of bugs.  It does not really encourage
> abstractions. 

I said it is far easier, not that it is the correct solution. However, I don't
agree duplicated code should be the reason for objection to the easier way out.
Code efficiency is the least of our problems.

> I wanted to use Axiom to teach generic programming here,
> but I'm being forced to walk away from it :-((
> How can I convince students of the value of the system when it does
> not support their knowledge?

Your students should be able to learn the abstract concepts abstractly :-) You
can teach them about isomorphisms. Also, tell your students life is always a
compromise.

> | CAS to be practical, certain compromises are necessary.
> 
> 100% agreed.  However, uniformity and coherence should not be compromised.
> The current approach does not even support the mathematical or
> "categorial" approach we would like to recommend.  

The current approach does support, within the limits of the programming
language. The Axiom designers are mathematicians and computer scientists and
they must have thought about this before deciding on the compromise. Remember,
that was in the 1970's and I think their compromise is quite reasonable and have
served the community well for over 30 years. 

Regarding uniformity, I am not totally satisfied with the isomorphism mechanism.
For example,  the domain that uses a new set of notations "belongs" to the
category in a way slightly different from another one that uses the default
notations. This non-uniformity may be a problem. But to uniformize would require
one to abandon the notion of default notations.

Coherence, if I understand what you meant by that, requires confluence in
rewriting rules. As far as I know, this property has not been proven with the
coercion system. So I don't know how you propose to improve this aspect (Axiom
is not coherent at this time).

If you think now one can redo Axiom in a better way, we are all for it. What's
your priorities? (in other words, when can you start? :-)

> How can we explain
> the that concepts we clearly and unambiguously explained to the
> students or engineering cannot translate directly to code in a
> mathematically-oriented system?  

Indeed, computer programming and even mathematics, have their (different degrees
of) limitations (google theories by Godel, Turing, and Chaitain).

Humans can learn abstraction, the computer cannot. Natural languages do not
express abstractions well (otherwise, we don't need lawyers). It takes a human
being to interpret between the lines to understand abstraction. We *understand*
abstractions by making jumps in our logic system (the brain).


> How can we convince the engineer that
> he has to duplicate code, when he knows from practice that it is a
> source of disaster?

(with a million dollars dangling over their heads?)

Code duplication is a fact of programming life. The difference is simply whether
it is done automatically or manually. If a little bit of manual duplication can
be used to avoid a lot of automatic duplications, I'll choose the former, and do
it and monitor it VERY CAREFULLY. It is a temporary solution, until better
times.

 
> | I do not question the theorectical advantage of rebuilding all
> | algebra based on properties of operators (there is research in
> | theory of operads which would support such a design) but I doubt
> | their practicality, especially when the notation for the operators
> | can only be known dynamically at run-time.
> 
> Well, I'm approaching the issue more from a *practical* point of view
> than a theoretical point of view.  As the system currently stands, in
> practice, I cannot simply and clearly write once a generic function
> for monoidal structures and expect it to work for both for Abelian and
> non Abelian monoids. 

This is not true. First, you don't mean non-Abelian monoids, you meant
not-necessarily Abelian monoids (or simply monoids). An abelian monoid IS also a
monoid and hence it will work! (You just need to redefine AbelianMonoid to use *
instead of +, showing it is not an inherent weakness of the system but just a
matter of notations).  Axiom chooses to allow different notations for the monoid
operation, to distinguish between the commutative case using the more common +
notation. The problem as the system stands is due to the rigidity of the
computer programming languages in general, which does not exist in mathematical
abstractions.

> From a practical point of view, the system does
> not support a direct mapping from design to codes.  

Well, I doubt any system will ever do, at least not without adding on so much
baggage that most will shunt away.  Even if the isomorphisms mechanisms (in the
sense above) are fully implemented it still will not support the mapping from
design to codes because of problems discussed above. In a sense, we want the
input and output to be simple and ambiguous, but the computation to be exactly
what we have in our mind.

> And if I cannot
> directly see the design in the code, how do I know the code reflects
> the design and my intent.  If I have duplicate codes floating around,
> how do I know for sure that I've fixed the bugs I have identified
> through testing with some parameters?  If I do not have a direct
> mapping from design to code, how do evolve my software in a sound and
> controlled manner?  Those are practical questions.

Sure, these questions exist independent of the problem we are discussing here.
Recompiling the world may allow a well-designed system to propagate fixes
automatically while regenerating duplicated codes. For manually duplicated code,
we have to rely on documentation.

> | As already well-known, with the current status, all properties of
> | operators are declarative and not verified.
> 
> My problem is simpler than that.  I'm not asking for the definition of
> the algebraic properties of operators.  I'm trying to have a way to
> convince Axiom/Aldor to support sound software engineering practice.
> Even better if I can take the standard library as an example.

No, you are not discussing "sound software engineering practice". You are
arguing about how to inherit abstract algebraic properties. If all you are
arguing is for absolutely avoiding manually duplicating code or maintaining it,
I'll say that is not a sound software engineering practice to begin with. Here
is a sound principle: Avoid duplication code if you can, but you do what you
have to do to make things work (and you better check the code and document it
well :-).

> | There is a certain degree of trust that users know what they are doing.
> 
> I understand that.  But that issue is different from what mine.
> 
> | Creating examples that deliberately violate these conventions and
> | implicit assumptions of the system and show the "weakness" or
> | "buggiess" of Axiom (or any other CAS) is not productive.
> 
> if you are talking about the issue I raised, then I believe you
> profoundly misunderstood it.
> And claiming it deliberately violates conventions and implicit
> assumptions of Axiom is very unproductive.  I'm deeply disappointed :-((

Sorry. Nothing personal and that was a general, misplaced, remark. 

I understand your points. There are many monoid structures in any algebraic
object because monoid is a very simple structure. Nothing I said disagrees with
your premise that (NN,+), (NN,*), (NN, max) are all abelian monoids. I agree
also that currently, you cannot tell Axiom that NN (Integer or even NNI) has all
three operations as monoid operators and that is a limitation due to the
rigidity of computer languages. To do that, you have to create something like
AbelianAdditiveMonoid (same as AbelianMonoid), AbelianMultipicativeMonoid, and
AbelianMaxMonoid, and that, while not entirely satisfactory, does not have the
problem discussed earlier.

Moreover, the three 'square' functions would produce x^2, 2*x, and x and the
three 'power' functions produce x^n, n*x, and x. Clearly, in (NN, max), the
'square' and 'power' functions are superfluous, but this automatic application
of the monoid construction will not simplify them. In AbelianMonoid, the
'square' function is simply not removed. So there are some simplification
possibilities when a categorical constructor is duplicated in cases with special
properties.

While manually duplicating this for the most common notations is not a problem,
I admit this can generalize  and we may have to duplicate a complicated
structure in more advanced mathematics.   An example would be Set(S), which is a
commutative ring (and a Boolean algebra) in two different ways at least. In such
case, the current practice would be to declare implictly the properties of a
Boolean algebra and use different notations for its operators. Since algebraic
properties of operations are only declarative, it is easy enough to state these
again. However, Set(S) will not inherit from CommutativeRing and so Matrix
Set(S) will not be a valid type construction. 

So my objections are not targeted to your proposal to find a way to allow such
inheritance. My objection is based on practical difficulties: not only is the
modifications proposed (even via isomorphism) very involved, they do not solve
all the problems. As far as I know, most standard higher algebraic structures
use well-established notations. (In fact, if a mathematical paper deviates
significantly from de facto notations, the paper will probably be rejected! Have
you seen ANY paper which interchanges the * and + notations in a commutative
ring?) This does not mean one cannot form a commutative ring with other
operators. To allow such inheritance needs a different yet undiscovered
mechanism, one which, like isomorphism, will likely require at least duplication
of code, albeit automatically.

> The issue is this:  *why* should one be forced to duplicate codes for
> an algorithms that work on the same mathematical structure.  The
> question arise from software engineering point of view, in general,
> and mathematical software in particular (I classified Axiom as a
> mathematical software).  If the reasons for that are not theoretical,
> I believe we need to improve over the situation.

I hope this long message provides some answers to *why*. But duplicating code is
not the main problem. The reasons are technical in nature, not theoretical. They
include the role identifiers play in inheritance, in multiple inheritance,
subdomains, the "un-overloading" of overloaded operators, and to some extent, in
scoping and the proliferation of libraries, as well as complexity in calling
sequences.
 
> I'm asking the question as someone interested in (mathematical)
> software engineering teaching and someone interested in Axiom.

Glad to know you. A rare combination.
 
> | One consequence of these examples is confusion of the real issues:
> | the lack of documentation on the conventions and implicit
> | assumptions, and real bugs.

I withdraw that comment, with apology.
 
> I fear you did not see what I was talking about.

Is this better? (Boy, I'm beginning to feel that I don't know what I was talking
about!)

\start
Date: Sat, 4 Mar 2006 12:49:19 -0500
From: Tim Daly
To: Peter Kruppa
Subject: Re: missing bootsys image

ah, i'm also trying to do that. i bought an apple specifically to
track down the problems but the effort has been stalled due to lack
of time. i'll try the build locally and see where i was.

please post a console trace of the build so we can try to spot the
failure.

\start
Date: Sat, 4 Mar 2006 13:45:37 -0500
From: Bill Page
To: David Mentre
Subject: RE: MediaWiki with literate programming

On March 4, 2006 5:46 AM David MENTRE wrote:

> 
> Somebody pointed me to:
>   http://literateprograms.org/LiteratePrograms:Welcome
> 
> This web site has adapted MediaWiki (the wiki engine behind
> Wikipedia) to present literate programs in a wiki way and to
> allow online edition. The infrastructure is based on noweb.
> 
> It might be a source of inspiration and/or code for Axiom.
> 

For obvious reasons, I think this is a fantastic idea! :)

See the link "Scientific computing" ...

I hope someone will post some SPAD and Aldor programs to
this site.

\start
Date: Mon, 27 Feb 2006 15:57:47 -0500
From: Bill Page
To: Ralf Hemmecke
Subject: RE: Bug in Tuple

Ralf,

On February 25, 2006 4:22 PM you wrote:
> 
> Can someone explain that?
> 
> Ralf
> 
> (6) -> Tuple(Integer) has coerce: Tuple(Integer)->PrimitiveArrayInteger
> 
>     (6)  false
>                                                               
>    Type: Boolean

I presume what you meant to write was:

  Tuple(Integer) has coerce:Tuple(Integer)->PrimitiveArray(Integer)

and that something like this might be possible in Aldor, right?

However the result the Axiom interpreter returns is still 'false'.

So far as I can tell from the available Axiom documentation the
'has' expression only allows categories and axioms on the right
hand side (rhs). So we can write:

  Tuple(Integer) has CoercibleTo(OuputForm)

and

  Integer has commutative("*")

but almost anything else on the rhs returns either 'false' or
an error message. You might have expected to be able to write:

(14) -> Tuple(Integer) has with Tuple(Integer)->PrimitiveArray(Integer)
   Internal Error
   Unexpected error in call to system function pf2Sex1

but that apparently doesn't work either. :(

Just as in Aldor different things might be possible in SPAD, but
I was't able to find any documentation about this.

\start
Date: Fri, 24 Feb 2006 11:03:17 +0100
From: David Mentre
To: Gabriel Dos Reis
Subject: re: ASDF and ./configure

24 Feb 2006 10:50:29 +0100, Gabriel Dos Reis=
:
> To a very large extent, it is less important to recognize Fedora Core 3
> (yes, that is what the current ./configure script does, but that is
> wrong).  It is far more important to recognize *available*
> functionalities, whether they come from Fedora Core 3 or SuSE Linux 9.3
> Professional.

You're probably right.

As far as I can remember[1], the main issue is that Fedora Core 3
introduced a randomization of libc mappings that impact the way GCL is
saving its image. So, in that particular case, the feature to detect
is randomized mapping of libraries.

Best wishes,
d.

[1] The Makefile.pamphlet says "Fedora Core 3 needs special GCL
options for local bfd." but it does not say *why* the local bfd is
necessary. Writting good doc is probably as hard as writting good
code. :-(

\start
Date: Mon, 27 Feb 2006 19:45:33 -0500
From: Bill Page
To: Gabriel Dos Reis
Subject: RE: Curiosities with Axiom mathematical structures

On February 26, 2006 12:31 AM Gabriel Dos Reis wrote:
> ... 
>   In the impressive diagram titled "Basic Agebra Hierarchy" displayed
> in the Axiom Book (I only have a copy of the edition copyrighted 1992,
> NAG), AbelianSemiGroup is not "derived" from SemiGroup, and similarly
> AbelianMonoid is not "derived" from Monoid.  I find that curious as it
> goes counter the mathematical fact that an AbelianMonoid *is* a
> Monoid, with an additional algebraic law (commutation).  
> 

The following is a prettier (I think) rendition of these diagrams
done using GraphViz. It also contains a couple of corrections:

http://wiki.axiom-developer.org/book--main--1/Endpaper3

When viewed as pdf and in some dvi viewers this diagram includes
live hyperlinks to the appropriate source files.

\start
Date: 04 Mar 2006 21:39:55 +0100
From: Martin Rubey
To: Francois Maltey
Subject: "Factoring" Expression Integer/ simplifying powers

Francois Maltey writes:

> but how can I transform this recursive formula :
> 
>     (1+x)^n*(1+x) + x + 1 
> to  (1+x)(1+x)^n 
> and (1+x)^(n+1) ?

Well, I guess you are currently a little out of luck here. (again and again,
sorry Francois)

To transform (1+x)^n*(1+x) into (1+x)^(n+1) you are probably best of by making
up a rule, i.e., using pattern matching. See AxiomProblems on MathAction for
some examples.

But I guess, that this is not what you "should" be after. Maybe you can (with
pencil and paper) describe a "normal form" of the expressions you want to
consider. If you have found (a computable) one, we can write an operation that
does the trick.

Maybe you want to consider the operation 'normalize'.

\start
Date: Mon, 27 Feb 2006 22:59:35 -0600
From: MathAction (Bill Page)
To: MathAction
Subject: [DistributedMultivariatePolynomial] 

William wrote:

> $R[x]$ is a subring of $Q(R)[x]$ where $Q(R)$ is the quotient
> field of $R$.

I find your notation a little confusing. In Axiom notation I think
you mean, for example:

$R[x]$ = POLY INT

then:

$Q(R)[x]$ = POLY FRAC INT

Is that right? If so, then I agree that:

> '1/x' is in neither of these polynomial rings,

But I do not agree with your continuation of the statement:

> (((No matter what $R$ is!))). This is a FACT of mathematics,
> the meaning of what an indeterminate x over a ring or
> field is. 1/x ONLY lives in $Q(R[x]) = Q(Q(R)[x]$, where
> $(1/x)\times x = 1$.

By $Q(R[x])$ I suppose you mean, for example:

$Q(R[x])$ = FRAC POLY INT

I don't understand why you write $Q(Q(R)[x]$ meaning for example:

$Q(Q(R)[x])$ = FRAC FRAC POLY INT

but certainly '1/x' does "live" in these domains, if by "live" you
mean that a suitable function '/' can be found by a selection
from these domains.

However '1/x' is also lives in other polynomial rings such as:

$Q(R[x])[x]$ = DMP(![x], FRAC POLY INT)

where $(1/x)\times x \ne 1$. $Q(R[x])[x]$ satisfies all of the
axioms of a ring and the 'x' in $Q(...)[x]$ remains transcendent
over the 'x' in $R[x]$. You can see that a valid selection for
the function '/' exists in this domain by doing::

  )sh DMP([x], FRAC POLY INT)

It is convenient that you choose to write $\times$ above because
we need to distinquish two different multiplications: the $\times$
in DMP and the '*' in 'POLY INT'.

It is only when we coerce $Q(R[x])[x]$ into $Q(R[x])$, which
means that we map the $\times$ and '/' of 'DMP(![x], FRAC POLY INT)'
into the $*$ and '/' of 'FRAC POLY INT' that we can equate these
two uses of $x$.

In making this claim I have not violated any FACT of mathematics.

\start
Date: 05 Mar 2006 14:12:24 +0100
From: Francois Maltey
To: list
Subject: Re: "Factoring" Expression Integer/ simplifying powers (an example)

So I try to translate into axiom the work that my students make with mupad
or maple.

So I compare what maple, mupad and axiom can do.

The questions and my solution with axiom are bellow.

My students must be do the exercice << with pencil and paper >>,
                       and with a computer algebra system.

I can't translate theses french questions, my english is too poor.

The main differences are :

1/ with mupad I can define an operator *%* (with any priority),
   so I type x *%* y and not etoile (x, y), it's nicer to read

2/ mupad and maple have expression as tree,
   we must rewrite etoile (x, etoile (x, y)) when we want to test the
   associative law, with expand or normal.
   axiom do this without any rewrite because the result is Polynomial.

3/ There is no problem for commutative :
   mupad and maple rewrite sum in a internal order x*y=y*x, x+y=y+x

4/ axiom solve is nice to use : we get a list [ident = value]
   the maple solve is less nice to use,
   sometime there is the name of the variable, sometimes not
   the result is a empty sequence,
   so there is nothing to read when the set is empty
   the mupad solver is finest :
   solve (x*y=0,x) gives  (y=0 => x \in C) AND (y<>0 => x=0)
   a little problem with axiom :
   solve (x*y=0, [x,y]) doesn't work, I must type solve ([x*y=0],[x,y])

5/ With axiom I can't compute x^(n) for the indeterminate n
With other CAS I can transform :
(1+x)^n*(1+x) + x + 1 into (1+x)^n*(1+x)

a/ Either with a solve (rec (u(n+1)=u(n)*(1+x)+x+1, u(0)=1, u(n)))
b/ or factor ((1+x)^n*(1+x) + x + 1) computes (1+x)^n*(1+x)

a/ It seems that solve (rec ...)) doesn't exist in axiom.

b/ Axiom is very adaptive for Polynomial :

   I can use Polynomial Integer, Fraction Polynomial Integer,
   Polynomial Integer, Factored Polynomial Integer, etc.

   Other CAS have functions as collect,
   With axiom, I also can do this with coerce :

   (x+y+1)^2 ::DMP([x,y],Integer), (x+y+1)^2 ::DMP([y,x],Integer)

// Is it an axiom bug in axiom ?
  I don't understand why (x+y+1)^2 ::DMP([x],Integer) gives me an
  Expression Integer, not an error.  //

But when I use Expression I only have ONE type : Expression Integer.
On this example the (1+x)^n term force me to use Expression Integer.

So I lose (almost) all the power of axiom.

I hope you find some interest to this mail !
Have a good day.

Francois Maltey

First are the questions in pseudo-latex.
My solution with axiom comes after, is there mistakes ?


--------------------------------------------------------------------
\section{=C3=A9tude d'une loi de composition interne}

Dans l'=C3=A9nonc=C3=A9 $E$ un ensemble muni d'une loi de composition inter=
ne~$\star$,
et $\lambda$, $\mu$, $a$, $b$, $c$ et $d$ sont des nombres r=C3=A9els.
L'=C3=A9l=C3=A9ment $u \in E$ est absorbant pour la loi $\star$ si et seule=
ment si
$u$ v=C3=A9rifie cette proposition :

$$\forall x \in E \qquad u \star x = x \star u = u $$

Dans cette partie $x \in \R$, $(n, p) \in \Z^2$ et la loi
$\star$ est d=C3=A9finie sur $\R$ ainsi :

$$ \forall (x, y) \in \R^2 \qquad x \star y = x + y - xy $$

Justifier que toute structure $(E, \star)$ poss=C3=A8de au maximum un =C3=
=A9l=C3=A9ment
absorbant.

Montrer par la contrapos=C3=A9e que tout groupe ayant au moins deux =C3=A9l=
=C3=A9ments ne
poss=C3=A8de aucun =C3=A9l=C3=A9ment absorbant.

=C3=89tudier les =C3=A9l=C3=A9ments absorbants de $\R$ pour la loi $\star$ ;
en d=C3=A9duire que $(\R, \star)$ n'est pas un groupe.

Prouver que $(\R \setminus \set 1, \star)$ est un groupe
commutatif ; calculer l'=C3=A9l=C3=A9ment neutre de $\star$ sur $\R \setmin=
us \set 1$
et le sym=C3=A9trique d'un =C3=A9l=C3=A9ment de $\star$ sur $\R \setminus \=
set 1$.

Les puissances it=C3=A9r=C3=A9es $x^{(n)}$ pour la loi $\star$ sont d=C3=A9=
finies ainsi :
$$
x^{(n)} =
\begin{cases}
\underbrace{x \star x \star x \star \cdots \star x}_{n \text{ fois}}
  & \text {pour $n > 0$} \\
0 & \text {pour $n=0$} \\
(x^{(-1)})^{(-n)}=(x^{(-n)})^{(-1)} & \text{pour $n < 0$}
\end{cases}
$$

Elles v=C3=A9rifient
$x^{(n)}\star x^{(p)} = x^{(n+p)}$ et $(x^{(n)})^{(p)} = x^{(np)}$.

Dans le cas o=C3=B9 $n > 0$ calculer par r=C3=A9currence $x^{(n)}$
=C3=A0 l'aide des op=C3=A9rations classiques d'additions, de multiplication=
s,
et de puissances sur $\R$.

D=C3=A9terminer une formule similaire pour $x^{(n)}$ lorsque $n<0$.

Calculer un couple $(\lambda,\mu)$ pour que l'application~$f$
soit un isomorphisme du groupe
$(\R \setminus \set 1, \star)$ dans le groupe $(\R^*, \times)$ :

f : \R \setminus \set 1 \to \R^* \qquad f(x)=\lambda x + \mu

------------------------------------------------------------------------
-- d=C3=A9finitions et r=C3=A9initialisations
)clear properties a b x y z etoile eltAbs eltNeutre sym
etoile := (x,y) +-> x+y-x*y

-- recherche de l'=C3=A9l=C3=A9ment absorbant, et v=C3=A9rification
tmpres := solve (etoile(x,a)=a, a)
eltAbs := rhs (first tmpres)
etoile (x, eltAbs) = eltAbs
(etoile (x, eltAbs) = eltAbs)::Boolean

-- v=C3=A9rification que la loi etoile est de composition interne
solve (etoile (x,y)=1, [x,y])

-- recherche de l'=C3=A9l=C3=A9ment neutre
tmpres := solve (etoile(x,e)=x, e)
eltNeutre := rhs (first tmpres)
etoile (x, eltNeutre) = x
(etoile (x, eltNeutre) = x)::Boolean

-- v=C3=A9rification de la commutativit=C3=A9
etoile (x, y)
etoile (y, x)
etoile(x,y) - etoile(y,x)
etoile(x,y) = etoile(y,x)
(etoile(x,y) = etoile(y,x))::Boolean

-- v=C3=A9rification de l'associativit=C3=A9
etoile (etoile (x, y), z)
etoile (x, etoile (y, z))
etoile (etoile (x, y), z) = etoile (x, etoile (y, z))
etoile (etoile (x, y), z) - etoile (x, etoile (y, z))
(etoile (etoile (x, y), z) = etoile (x, etoile (y, z)))::Boolean

-- recherche du sym=C3=A9trique
tmpres := solve (etoile (x, y) = eltNeutre, y)
exprSym := rhs (first tmpres)
function (exprSym, 'sym, 'x)
sym
etoile (x, sym x)
(etoile (x, sym x) = eltNeutre)::Boolean
(etoile (sym x, sym y) = sym etoile (x, y))::Boolean

-- puissances it=C3=A9r=C3=A9es dans le cas n>0
tmpres := [generate (y +-> etoile (y,x), 0::Polynomial Integer)]
[rmpres.k for k in 1..7]
[tmpres.k-1 for k in 1..7]
[factor (tmpres.k-1) for k in 1..7]

-- puissances it=C3=A9r=C3=A9es dans le cas n<0
tmpres2 := [generate (y +-> etoile (y,sym x), 0::Fraction Polynomial Inte=
ger)]
[tmpres2.k for k in 1..7]
[tmpres2.k-1 for k in 1..7]
[(tmpres2.k-1)::Fraction Factored Polynomial Integer for k in 1..7]

-- recherche du morphisme non constant
fct := x +-> a*x+b
tmpres := solve ([fct (etoile (2, 3)) = fct 2 * fct 3,
        fct (etoile (2, 4)) = fct 2 * fct 4], [a,b])
tmpres := select (L +-> not (rhs (L.1) = 0), tmpres)
function (subst (fct x, tmpres.1), fct2, x)
(fct2 x * fct2 y = fct2 (etoile (x,y)))::Boolean

\start
Date: Sun, 5 Mar 2006 18:51:33 -0500
From: Tim Daly
To: list
Subject: mailing list troubles

The claim is that the mailing list is fixed.

------- Start of forwarded message -------

Date: Sun,  5 Mar 2006 21:28:02 +0100
From: Sylvain Beucler
To: Tim Daly, Sylvain Beucler
Subject: [sr #105195] Email mailing loop -- please fix quickly. LOTS of duplicates



Update of sr #105195 (project administration):

                  Status:                    None => Done                   
             Assigned to:                    None => Beuc                   
             Open/Closed:                    Open => Closed                 

    _______________________________________________________

Follow-up Comment #1:

Hi.

Situation is back to normal now. You can check the news item for details
about what happened.

    _______________________________________________________

Reply to this item at:

  <http://savannah.gnu.org/support/?func=detailitem&item_id=105195>

_______________________________________________
  Message post via/par Savannah
  http://savannah.gnu.org/
------- End of forwarded message -------



\start
Date: Mon, 6 Mar 2006 00:03:00 -0500
From: Tim Daly
To: Fabio Stumbo
Subject: xpoly.spad change

> Eventually we will submit a patch to xpoly.spad.pamphlet
> including this change to provide an implementation of "div" and
> also (I hope) some documentation. This will become part of the
> Axiom source distribution. At that time, a complete new version
> of the Axiom library can be built from source.

please copy the original xpoly.spad.pamphlet to /tmp/xpoly.spad.pamphlet
then copy your modified xpoly.spad.pamphlet to /tmp/xpoly.spad.pamphlet.new
then type:

  diff -Naur xpoly.spad.pamphet xpoly.spad.pamphlet.new >xpoly.spad.pamphlet.patch

and send me the xpoly.spad.pamphlet.patch file.

\start
Date: Mon, 6 Mar 2006 14:26:20 -0500
From: Bill Page
To: Tim Yamin
Subject: RE: Axiom+Texmacs

Tim,

The issue in [1] is not really a problem for the expected
use of Axiom in Texmacs. The main axiom executable is called
AXIOMsys. The TeXmacs - Axiom interface program called
tm_axiom.c normally starts the AXIOMsys process. This process
creates only one prompt for user input and everything works
fine (I think). The double prompt problem arises if someone
tries to modify the tm_axiom.c program to call the 'axiom'
script. This script starts several processes including
AXIOMsys, sman and other processes depending on the options
passed to the script. It has the consequence that two prompts
are generated for user input - the first one due to the
interaction between AXIOMsys and sman.

The point is that *if* one wants to be able to generate Axiom
graphics from a TeXmacs session - something not supported by
just AXIOMsys alone - then it is necessary to call the 'axiom'
script (or at least the sman process) and also make additional
changes to the tm_axiom.c program to accommodate the additional
prompt. This is described in [2].

I am not sure exactly what the issue is in [2]. I am not a
gentoo user and I am not familiar with the gentoo binary
distribution process. But this issue could be related to [1]
if for some reason the person responsible for the gentoo binary
version of tm_axiom.c (which normally comes from the TeXmacs
distribution) configured it to call something other than the
AXIOMsys executable but did not make the required additional
modification to support the double prompt. One of the symptoms
of the double problem problem is that the communication between
Axiom and TeXmacs is broken and the result is similar to what
is described in [1].

Regards,
Bill Page.

PS. I've cc'd the axiom-developer email list since there may
well be some gentoo user out there who has a better idea about
this than I do.

> -----Original Message-----
> From: Tim Yamin [mailto:Tim Yamin]
> Sent: Monday, March 06, 2006 1:40 PM
> To: Bill Page
> Subject: Axiom+Texmacs
>
> Hi Bill,
>
> Do you know if the Axiom double-input issue has been fixed
> in CVS? There are comments both on the Axiom wiki [1] and a
> bug a Gentoo user filed [2] and I'm not too sure where the
> issue is - whether it's upstream or something introduced
> by the compile process.
>
> Thanks,
>
> Tim
>
> [1] http://wiki.axiom-developer.org/TeXmacs
> [2] http://bugs.gentoo.org/show_bug.cgi?id=121430
>

\start
Date: Mon, 6 Mar 2006 20:14:03 +0000
From: Tim Yamin
To: Bill Page
Subject: Re: Axiom+Texmacs

On Mon, Mar 06, 2006 at 02:26:20PM -0500, Page, Bill wrote:
> I am not sure exactly what the issue is in [2]. I am not a
> gentoo user and I am not familiar with the gentoo binary
> distribution process. But this issue could be related to [1]
> if for some reason the person responsible for the gentoo binary
> version of tm_axiom.c (which normally comes from the TeXmacs
> distribution) configured it to call something other than the
> AXIOMsys executable but did not make the required additional
> modification to support the double prompt. One of the symptoms
> of the double problem problem is that the communication between
> Axiom and TeXmacs is broken and the result is similar to what
> is described in [1].

Hi Bill,

Well, neither are shipped as binaries. Both are compiled from source.
Looking at Axiom 3.9 with both AXIOMsys and axiom I'm getting a double
prompt once [Enter] has been keyed - I'm guessing this is what is
confusing Texmacs.

Thanks for the tip - turns out this is a bug in the packaging code. The
wrapper to launch AXIOMsys is the same one as that to launch 'axiom' and
hence the double prompt issue :)

Also it might be a good idea to add a noweb security patch [1] to Axiom
since Axiom builds and uses its own distribution and the version currently
there has a few holes that could do with plugging :)

Thanks,

Tim

[1] http://www.gentoo.org/cgi-bin/viewcvs.cgi/*checkout*/sci-mathematics/axiom/files/noweb-2.9-insecure-tmp-file.patch.input?rev=HEAD&content-type=text/plain

\start
From: Jean-Christophe Helary
Date: Tue, 7 Mar 2006 01:18:27 +0900
To: Tim Daly
Cc: Frederic Lehobey, list
Subject: Re: French translation

Tim,
I just subscribed to axiom-dev.

> Jean-Christophe, Frederic, David,
>
> Jean-Christophe Helary has started looking at the problem of 
> translating
> Axiom to French.
>
> Frederic Lehobey and David Mentre have also started looking at the 
> problem.

Enchant=E9.

Let me introduce myself. I am a freelance translator, mostly working 
from Japanese and English to French. I am not a scientist, I am not a 
developer. I spend some free time on localizing some applications 
that I find interesting, and in the case of Axiom, I was proposed to 
contribute after a mail I sent to the CL-Gardeners list.

Right now I am working on the UI strings, after converting them to 
the Java properties format for parsing into the translation memory 
tool that I use: OmegaT.

OmegaT does not support Latex, so I am trying to think of a way to 
create a "pseudo" parser for such files.

If there are ways to round-trip Latex to some xml format then I could 
easily adapt the source to create a proper filter, based on the xhtml 
filter that already exists (I did that for DocBook or WordML/ExcelML 
files already).

So basically, my first challenge is to find a way to have OmegaT 
parse the source files. Then comes the translation, and since 1) I am 
not an axiom user 2) I do have 2 kids to feed with "real" 
deadlines :) I will appreciate support here...

Considering the scope of the translation, I'd say that getting the UI 
into French should not take more that a few days of work-I mean with 
final editing/proofreading. As far as the doc is concerned, it will 
take time so we'd better find a technically satisfying way of doing 
that right now :)

> In general I think we should consider changing the string control
> characters to use common lisp syntax and semantics. This won't be
> a simple job but is probably best for the long term. I can look at
> that problem.

Still, since the control character, even if replaced by cleaner 
syntax are not supposed to include translatable contents, I don't 
think it is an emergency as far as the translation itself is 
concerned, unless I have misunderstood what you meant.

My original comment came from the fact that having a place holder at 
the beginning of a sentence is fine, but then it should not be 
followed by an uppercase word... Now it really depends on what the 
placeholder contains, hence my request for practical examples.

> Latex is essentially a document markup language. Latex commands all
> begin with "\" and then a word, possibly with parameters. So making
> something bold would be:
>
>   \bf thing
>
> the other syntax is the use of the "$" to delimit mathematics so
> math "inline" in the sentence has 1 "$" delimiter like $x=y$ and
> math in its own box outside the line has 2 "$" delimiters like
> $$x=y$$. Beyond that the rest is generally text.

Ok, I'll see with your source.

>> Also, you mentioned the hyperdoc system. DO you have a file sample ?
>
> Many. I've attached an example.

It is Latex too ? TexInfo ?

> =========================
==========================
=====================
> ===
>
> % Copyright The Numerical Algorithms Group Limited 1992-94. All 
> rights reserved.
> % !! DO NOT MODIFY THIS FILE BY HAND !! Created by ht.awk.
> \newcommand{\OneDimensionalArrayXmpTitle}{OneDimensionalArray}
> \newcommand{\OneDimensionalArrayXmpNumber}{9.57}
> %
> % 
> =========================
==========================
====================
> \begin{page}{OneDimensionalArrayXmpPage}{9.57 OneDimensionalArray}
> % 
> =========================
==========================
====================
> \beginscroll

\start
Date: Mon, 6 Mar 2006 15:59:29 -0500
From: Bill Page
To: Tim Yamin
Subject: RE: Axiom+Texmacs

On Monday, March 06, 2006 3:14 PM Tim Yamin wrote:
>
> Thanks for the tip - turns out this is a bug in the packaging
> code. The wrapper to launch AXIOMsys is the same one as that
> to launch 'axiom' and hence the double prompt issue :)

I am glad you found it!

>
> Also it might be a good idea to add a noweb security patch
> [1] to Axiom since Axiom builds and uses its own distribution
> and the version currently there has a few holes that could do
> with plugging :)
>

Thanks for the "heads up" about noweb.

My preference would be to stop re-distributing noweb with Axiom.
What Axiom needs can be accomplished with a simple awk filter.
See:

http://lists.nongnu.org/archive/html/axiom-developer/2005-12/msg00230.ht
ml

[1]
http://www.gentoo.org/cgi-bin/viewcvs.cgi/*checkout*/sci-mathematics/axi
om/files/noweb-2.9-insecure-tmp-file.patch.input?rev=HEAD&content-type==
t
ext/plain

\start
Date: Mon, 6 Mar 2006 11:29:08 -0500
From: Tim Daly
To: Jean-Christophe Helary
Subject: French translation
Cc: Frederic Lehobey

Jean-Christophe, Frederic, David, 

Jean-Christophe Helary has started looking at the problem of translating
Axiom to French.

Frederic Lehobey and David Mentre have also started looking at the problem.

> 
> As far as your message file is concerned I will convert it to a  
> simple key=value for parsing purposes and will deliver the French is  
> the original format. I would like to know if you have currently  
> French people in the development team who could help me with  
> difficult items ?

Frederic and David are both native french speakers.  They have also
considered the translation problem (thus my comment about po4a which
they mentioned). A French version of Axiom would be most interesting.


> Tim, I have a question concerning control charaters:
> 
> > is here. There are also some "control characters", %b is bold, %1, % 
> > 2, etc
> > refer to the arguments for the message, %l is a newline, etc.
> > S2CD0001
> >  %b Constructor documentation warnings (++ comments): %d
> 
> Would be:
> 
> > S2CD0001
> >  %b Alertes du constructeur de documentation (++ commentaires): %d
> 
> But:
> 
> > S2CD0002
> >  %1 The constructor %2b has missing documentation.
> 
> would be what ?
> 
> Where does %1 fit in the output ?
> 
> Same here:
> 
> > S2CD0003
> >  %x3 %1 The constructor %2b is missing the heading description.
> 
> for %x3 and %1 ?
> 
> etc.
> 
> Could you give me an output example for a few pairs using such place  
> holders ?

Yes, I'll try to construct an example of each error message. It may 
take a while so they'll come in groups.

In general I think we should consider changing the string control
characters to use common lisp syntax and semantics. This won't be
a simple job but is probably best for the long term. I can look at
that problem.

> I am currently looking for more info about Latex so that I can  
> produce a correct Latex file in French too. I have no idea about  
> Latex syntax :)

Latex is essentially a document markup language. Latex commands all
begin with "\" and then a word, possibly with parameters. So making
something bold would be:

  \bf thing

the other syntax is the use of the "$" to delimit mathematics so
math "inline" in the sentence has 1 "$" delimiter like $x=y$ and
math in its own box outside the line has 2 "$" delimiters like
$$x=y$$. Beyond that the rest is generally text.

> 
> Also, you mentioned the hyperdoc system. DO you have a file sample ?

Many. I've attached an example.

I'd suggest you go to savannah.nongnu.org/projects/axiom and sign up 
for the axiom-developer mailing list where we discuss these issues.
In any case, please copy list so we can journal
the discussion.

t

=========================================================================

% Copyright The Numerical Algorithms Group Limited 1992-94. All rights reserved.
% !! DO NOT MODIFY THIS FILE BY HAND !! Created by ht.awk.
\newcommand{\OneDimensionalArrayXmpTitle}{OneDimensionalArray}
\newcommand{\OneDimensionalArrayXmpNumber}{9.57}
%
% =====================================================================
\begin{page}{OneDimensionalArrayXmpPage}{9.57 OneDimensionalArray}
% =====================================================================
\beginscroll
The \spadtype{OneDimensionalArray} domain is used for storing data in a
one-dimensional indexed data structure.
Such an array is a homogeneous data structure in that all the entries of
the array must belong to the same \Language{} domain.
Each array has a fixed length specified by the user and arrays are not
extensible.
The indexing of one-dimensional arrays is one-based.
This means that the ``first'' element of an array is given the index
\spad{1}.
See also \downlink{`Vector'}{VectorXmpPage}\ignore{Vector} and \downlink{`FlexibleArray'}{FlexibleArrayXmpPage}\ignore{FlexibleArray}.
\xtc{
To create a one-dimensional array, apply the
operation \spadfun{oneDimensionalArray} to a list.
}{
\spadpaste{oneDimensionalArray [i**2 for i in 1..10]}
}
\xtc{
Another approach is to first create \spad{a}, a one-dimensional array of 10 \spad{0}'s.
\spadtype{OneDimensionalArray} has the convenient abbreviation \spadtype{ARRAY1}.
}{
\spadpaste{a : ARRAY1 INT := new(10,0)\bound{a}}
}
\xtc{
Set each \spad{i}th element to i, then display the result.
}{
\spadpaste{for i in 1..10 repeat a.i := i; a\bound{a1}\free{a}}
}
\xtc{
Square each element by mapping the function
\texht{$i \mapsto i^2$}{i +-> i**2} onto each element.
}{
\spadpaste{map!(i +-> i ** 2,a); a\bound{a3}\free{a2}}
}
\xtc{
Reverse the elements in place.
}{
\spadpaste{reverse! a\bound{a4}\free{a3}}
}
\xtc{
Swap the \spad{4}th and \spad{5}th element.
}{
\spadpaste{swap!(a,4,5); a\bound{a5}\free{a4}}
}
\xtc{
Sort the elements in place.
}{
\spadpaste{sort! a \bound{a6}\free{a5}}
}
\xtc{
Create a new one-dimensional array \spad{b} containing the last 5 elements of \spad{a}.
}{
\spadpaste{b := a(6..10)\bound{b}\free{a6}}
}
\xtc{
Replace the first 5 elements of \spad{a} with those of \spad{b}.
}{
\spadpaste{copyInto!(a,b,1)\free{b}}
}

\endscroll
\autobuttons
\end{page}
%

\start
Date: Mon, 6 Mar 2006 17:09:14 -0500
From: Tim Daly
To: Bill Page
Subject: Re: Axiom+Texmacs
Cc: Tim Yamin

i admit that i'm not awk literate. even so, this patch is nearly line noise.

can you give me a clue what the security hole is and how this patch
fixes it? the whole point of literate programming is to explain the
how and why. please write a literate form of the patch.

\start
Date: Mon, 6 Mar 2006 21:37:21 +0000
From: Tim Yamin
To: Tim Daly
Subject: Re: Axiom+Texmacs

On Mon, Mar 06, 2006 at 05:09:14PM -0500, root wrote:
> i admit that i'm not awk literate. even so, this patch is nearly line noise.
> 
> can you give me a clue what the security hole is and how this patch
> fixes it? the whole point of literate programming is to explain the
> how and why. please write a literate form of the patch.

Not my patch I'm afraid. I believe it's a Debian patch and some of it fixes
CVE-2005-3342 while other parts fix an older issue from 2003; CAN-2003-0381.

The following bugs have some more details:

* http://bugs.gentoo.org/show_bug.cgi?id=22972
* http://bugs.gentoo.org/show_bug.cgi?id=122705

\start
Date: 06 Mar 2006 12:42:25 +0100
From: Martin Rubey
To: Francois Maltey
Subject: re: "Factoring" Expression Integer/ simplifying powers (an example)

Dear Francois,

I think that your observations are very helpful. Some comments below.

Francois Maltey writes:

> 1/ with mupad I can define an operator *%* (with any priority), 
>    so I type x *%* y and not etoile (x, y), it's nicer to read

Yes, the infix operator precedences seem to be hardcoded in
interp/newaux.lisp.pamphlet.

>    solve (x*y=0, [x,y]) doesn't work, I must type solve ([x*y=0],[x,y])
> 
> 5/ With axiom I can't compute x^(n) for the indeterminate n
> With other CAS I can transform :
> (1+x)^n*(1+x) + x + 1 into (1+x)^n*(1+x) 

I don't really understand. (1+x)^n*(1+x) + x + 1 is not equal to (1+x)^n*(1+x),
is it?

> a/ Either with a solve (rec (u(n+1)=u(n)*(1+x)+x+1, u(0)=1, u(n)))

> b/ or factor ((1+x)^n*(1+x) + x + 1) computes (1+x)^n*(1+x)

I don't believe this.

> a/ It seems that solve (rec ...)) doesn't exist in axiom.

not yet. As you might know I did already propose a hierarchy for these things
and Antoine Hersen said that he'd be interested in implementing. Unfortunately,
he did not do it yet.

I can help, but I'm unable to do it all by myself, I don't have enough time. If
you come to the axiom workshop, I guess we could get it started in very little
time.

> // Is it an axiom bug in axiom ?
>   I don't understand why (x+y+1)^2 ::DMP([x],Integer) gives me an 
>   Expression Integer, not an error.  //

Well, even (x+y+1)^2 ::DMP([x,y],Integer) gives an EXPR INT. The reason is,
that :: has a very high precedence. So you are converting 2 to a DMP([x],INT)
-- or a DMP([x,y], INT) -- and then you compute (1+x+y) to the power of that
polynomial...

> But when I use Expression I only have ONE type : Expression Integer.
> On this example the (1+x)^n term force me to use Expression Integer.
> 
> So I lose (almost) all the power of axiom.

very true. It is one of my main goals to introduce a good hierarchy of common
functions. I hope that this won't take too long. Help (with coding) is very
much appreciated.

Unfortunately, I don't have the time to go through your worksheet right now,
sorry.

\start
Date: Mon, 6 Mar 2006 19:43:54 -0500
From: Bill Page
To: Martin Rubey
Subject: re: "Factoring" Expression Integer/simplifying powers (an example)

On Monday, March 06, 2006 6:42 AM Martin Rubey wrote:
> ...
> Francois Maltey wrote:
> > // Is it an axiom bug in axiom ?
> >   I don't understand why (x+y+1)^2 ::DMP([x],Integer) gives me an
> >   Expression Integer, not an error.  //
>
> Well, even (x+y+1)^2 ::DMP([x,y],Integer) gives an EXPR INT.
> The reason is, that :: has a very high precedence. So you are
> converting 2 to a DMP([x],INT) -- or a DMP([x,y], INT) -- and
> then you compute (1+x+y) to the power of that polynomial...

Hmmm... that is interesting.

(1) -> x^1

   (1)  x
   Type: Polynomial Integer

Ok, here the interpreter finds ^:(%,NNI)->% in 'Polynomial Integer'.

(2) -> x^(1::POLY INT)

   (2)  x
   Type: Expression Integer

So, here the interpreter finds ^:(%,%)->% in 'Expression Integer',
and the coercion POLY INT -> EXPR INT, just like this:

(3) -> x^(y::POLY(INT))

         y
   (3)  x
   Type: Expression Integer

But how can we explain these results?

(4) -> x^(1::DMP([x],Integer))

   (4)  x
   Type: Fraction Polynomial Integer

(5) -> x^(1::SUP(INT))

   (5)  x
   Type: Expression SparseUnivariatePolynomial Integer

And why not this?

(6) -> x^(y::DMP([y],INT))
   There are 4 exposed and 0 unexposed library operations named ^
      having 2 argument(s) but none was determined to be applicable.
      Use HyperDoc Browse, or issue
                                )display op ^
      to learn more about the available operations. Perhaps
      package-calling the operation or using coercions on the arguments
      will allow you to apply the operation.

   Cannot find a definition or applicable library operation named ^
      with argument type(s)
                                 Variable x
               DistributedMultivariatePolynomial([y],Integer)

      Perhaps you should use "@" to indicate the required return type,
      or "$" to specify which version of the function you need.

\start
Date: Tue, 7 Mar 2006 09:56:05 +0100
From: David Mentre
To: Jean-Christophe Helary
Subject: Re: French translation
Cc: Frederic Lehobey

Hello Jean-Christophe,

2006/3/6, Jean-Christophe Helary:
> Enchant=E9.

Bienvenu !

> Let me introduce myself. I am a freelance translator, mostly working
> from Japanese and English to French. I am not a scientist, I am not a
> developer. I spend some free time on localizing some applications
> that I find interesting, and in the case of Axiom, I was proposed to
> contribute after a mail I sent to the CL-Gardeners list.

Short introduction about myslef: I am more a developer. I've done some
Axiom hacking two years ago, and I'm still interested in very specific
Axiom parts (./configure script). I'm a friend of Fr=E9d=E9ric Lehobey and
this is him who interested me in Axiom.

Regarding translation of Axiom, you should coordinate with Fr=E9d=E9ric
Lehobey. In fact, Fr=E9d=E9ric is looking at a way to translate the Axiom
book, which is a bit different (and more ambitious!) than the
translation of Axiom user interface. You should definitely discuss
with him.


> If there are ways to round-trip Latex to some xml format

Not of I could think of. But I don't know all the latex world.


> Ok, I'll see with your source.

If you want a quick introduction to LaTeX, I would advise you to read
this small book (128 p.):
  LaTeX pour l'impatient
  http://www.h-k.fr/publications/technique_et_pratique.html#LPI


> It is Latex too ? TexInfo ?

It Latex syntax but the macro used are not standard LaTeX ones
(\spadpaste, \autobuttons, \beginscroll, ...).

\start
Date: Tue, 7 Mar 2006 18:18:00 +0900
From: Jean-Christophe Helary
To: David Mentre
Subject: Re: French translation
Cc: Frederic Lehobey

Can I consider that David and Frederic are both on axiom-dev ?

> Regarding translation of Axiom, you should coordinate with Fr=E9d=E9ric
> Lehobey. In fact, Fr=E9d=E9ric is looking at a way to translate the =
Axiom
> book, which is a bit different (and more ambitious!) than the
> translation of Axiom user interface. You should definitely discuss
> with him.

Actually that was the first part of Tim's proposal, I then asked 
about the UI, which is the reason why I mentioned it.

>> If there are ways to round-trip Latex to some xml format
> Not of I could think of. But I don't know all the latex world.
>
> If you want a quick introduction to LaTeX, I would advise you to read
> this small book (128 p.):

Haha :) Well, one thing I found, after taking a look at the source, 
is that there are actually only a small number of translatable 
segments _within_ Latex code. Pretty much all of the text is in 
distinct paragraphs that are not preceeded or folowed by code. So I 
just need to figure out a way to deal with the "embedded" part.

>   LaTeX pour l'impatient
>   http://www.h-k.fr/publications/technique_et_pratique.html#LPI

Thanks for the reference, I'll take a look at it.

>> It is Latex too ? TexInfo ?
>
> It Latex syntax but the macro used are not standard LaTeX ones
> (\spadpaste, \autobuttons, \beginscroll, ...).

I have not checked the file's contents but I will later this week.

\start
Date: Tue, 07 Mar 2006 06:35:36 +0100
From: Ralf Hemmecke
To: William Sit
Subject: Re: Curiosities with Axiom mathematical structures

Dear William,

On 03/04/2006 05:31 PM, William Sit wrote:
> Hi Gabe:
> Gabriel Dos Reis wrote:
>> William Sit writes:

> Agreed in theory, not in practice.  We should distinguish two issues: (1)
> derived  operations that depend only on the defining operations should be
> generically implemented and inherited, and (2) how to handle the notations
> (equivalently, identifiers in computer science terminology) for the defining
> operations and derived operations.

By (1) you probably mean to say something like

define PrimitiveType: Category == with {
	=: (%, %) -> Boolean;
	~=: (%, %) -> Boolean;
     default { (a:%) ~= (b:%):Boolean == ~(a = b); }
}

I must say that I liked this idea of "default implementations" when I've 
encountered it. But it also introduces all the complications with 
multiple inheritance.

For example, assume we have

define ContainerType(T: Type): Category == with {
   bracket: Tuple Type -> %;    -- constructor
   generator: % -> Generator T; -- yields all the elements
   #: % -> Integer;             -- size
   default {
     #(x: %): Integer == {
       n: Integer := 0;
       for element in x repeat n := n + 1;
     }
     return n;
   }
}

define FixedArrayType(n: Integer, T: Type): Category == with {
   ContainerType(T);
   default {#(x: %): Integer == n;}
}

Theoretically, there is no difference in the two # functions, but 
practically, one would prefer the second one for FixedArray's since it 
is a little bit faster.

Now, assume I have some other category MyFancyCat that inherits from 
ContainerType, but not from FixedArrayType. Then I create

define MyFixedCat(n: Integer, T: Type): Category == with {
   MyFancyCat T;
   FixedArrayType(n, T);
}

Of course, MyFixedCat also inherits defaults, but which one? (The 
current compiler takes the first one.) Changing the order of the 
categories results in more efficient code. However, think of a second 
default function that could be implemented in both categories, but the 
more efficient one in ContainerType. Then you can choose any order for 
MyFixedCat and get always only one efficient default.

When I started with Aldor, I used defaults a lot, but I encountered 
exactly the above scenario and then removed the defaults in almost all 
places and shifted it to the actual domains. Default implementations 
should be used with great care.

Computation time is never an issue in mathematics, but one should not 
(totally) neglect it in computer algebra.



Your (2) from above refers to the idea of renaming operators. Currently, 
apart from the "renaming during inheritance", we are restricted anyway 
quite a bit. For example, I would like my multiplication sign to look 
like \times or \circ. Well, Aldor does not (yet) handle Unicode. But 
even if it did, I would probably have to disambiguate certain 
mathematical expressions so that they become Aldor programs.

But actually that is another issue: How to write a good user interface 
(notations) that maps nice looking expressions to the right underlying 
algorithm. Maple and Mathematica know already quite a bit of such user 
interfaces. However, they don't have the beauty of types.

There is Chapter 9 of Doye's PhD thesis
http://portal.axiom-developer.org/refs/articles/doye-aldor-phd.pdf
which deals in part with the renaming.

 From what I understand, it simply makes two mathematically distinct 
things (operator symbols and operator names) distinct in the programming 
language. (Though I don't quite like the syntax.)


> The concept of a ring is almost omnipotent in all branches of mathematics, and
> the standard notations for the multiplication (*) and addition (+) are adopted.
> You may almost forget about that a ring is a monoid wrt to * and an abelion
> monoid wrt + because what is important to a ring is the two together, how they
> interact via the distributive laws. A practical way to support the structure of
> a ring requires these two separate notations. Even in the simple case of your
> example for repeated operation (which you called "power"), the two operations *
> and + will produce (and should produce) outputs in two different notations: x^n
> (power) and n*x (multiple). In this case, the repeated operations in fact occur
> both in an *abelian* submonoid setting even if multiplication is
> non-commutative.

It would certainly make sense to print "a + a" as "2*a", but how an 
element of a domain is printed is decided by the domain.



If we have

define MyMonoid: Category == with {
   1: %;
   *: (%, %) -> %;
   power: (%, Integer) -> %;
}

-- and (now fancy notation with renaming)

define MyTimesPlus: Category == with
   MyMonoid;
   MyMonoid where {
     0: % == 1;
     +: (%, %) -> % == +;
     ntimes: (%, Integer) -> % == power;
   }
}

Then MyTimesPlus has 6 different signatures.
If one removes the line "ntimes" then it would be only 5 and "power" 
would correspond to the multiplication (or (more correctly) to the 
actual implementation of it in a corresponding domain).

So, operator symbols and operator names agree as long as they are not 
renamed.

And one could also build

MyInteger1: MyTimesPlus == add {
   Rep == Integer;
   0: % == per 0;
   1: % == per 1;
   ...
}

MyInteger2: MyTimesPlus == add {
   Rep == Integer;
   0: % == per 1;
   1: % == per 0;
   (x: %) + (y: %): % == per (rep x * rep y);
   (x: %) * (y: %): % == per (rep x + rep y);
   ...
}

Now, clearly, it can easily be figured out what 0, 1, +, etc. mean if 
MyInteger1 or MyInteger2 is in scope. If both are in scope then nobody 
can infer what "0 + 1" should return. In fact, constructing 
implementations like that is also currently possible without renaming.


> So I hope we need not argue a third issue: (3) maintaining standard notations
> for the defining operations in common algebraic structures.

Hmmm, don't some people use \cdot, \times, \circ, \odot, etc to denote 
multiplication? ;-)


But let's continue with MyInteger1/2.
If I now ask

MyInteger1 has MyMonoid

then that refers to the multiplicative structure. I have, however, to say

macro MyAdditiveMonoidMacro == {
   MyMonoid where {
     0: % == 1;
     +: (%, %) -> % == +;
     ntimes: (%, Integer) -> % == power;
   }
}
MyInteger1 has MyAdditiveMonoidMacro

So what do I gain by a "renaming feature"? Not much, since now I must 
add the corresponding "with respect to addition" or create another category.
(Isn't that very similar to the case when Monoid and AbelianMonoid are 
totally unrelated?)

In fact, if I now define a new category

define MyAdditiveMonoidCategory == {
   MyMonoid where {
     0: % == 1;
     +: (%, %) -> % == +;
     ntimes: (%, Integer) -> % == power;
   }
}

and ask

MyInteger1 has MyAdditiveMonoidCategory

then this should (and must) return false since MyInteger1 is not 
explicitly declared to be a member of that category.

\start
Date: Tue, 7 Mar 2006 18:53:00 +0100
From: Frederic Lehobey
To: Jean-Christophe Helary
Subject: Re: French translation
Cc: David Mentre

Hi,

On Tue, Mar 07, 2006 at 06:18:00PM +0900, JC Helary wrote:
> Can I consider that David and Frederic are both on axiom-dev ?

Yes.  But I have left your address in Cc: as axiom-dev still seems to
be horribly delayed.

> Haha :) Well, one thing I found, after taking a look at the source,  
> is that there are actually only a small number of translatable  
> segments _within_ Latex code. Pretty much all of the text is in  
> distinct paragraphs that are not preceeded or folowed by code. So I  
> just need to figure out a way to deal with the "embedded" part.

A nice tool for that is po4a.  I have created a dedicated page on my
personal wiki:
http://lehobey-rennes.dyndns.org/dokuwiki/doku.php?id=doc:axiom:traduction#utiliser_po4a

For other readers, yes, sorry, it is in French (for my own efficiency)
but the explicit commands and links should be enough to give you a
feeling of what it revolves around.

Interesting examples and output are:
http://lehobey-rennes.dyndns.org/axiom/noweb.pamphlet (explains the
problems between noweb and po4a) and
http://lehobey-rennes.dyndns.org/axiom/bookvol1.pot (that could be the
base for translations in every languages).  Do not use it yet as long
as the above problems have not yet been dealt with in a satisfying
way.

\start
Date: Tue, 07 Mar 2006 14:52:08 -0500
From: William Sit
To: Ralf Hemmecke
Subject: Re: Curiosities with Axiom mathematical structures

Hi Ralf:

Ralf Hemmecke wrote:

> >> William Sit writes:
> 
> > Agreed in theory, not in practice.  We should distinguish two issues: (1)
> > derived  operations that depend only on the defining operations should be
> > generically implemented and inherited, and (2) how to handle the notations
> > (equivalently, identifiers in computer science terminology) for the defining
> > operations and derived operations.
> 
> By (1) you probably mean to say something like
> 
> define PrimitiveType: Category == with {
>         =: (%, %) -> Boolean;
>         ~=: (%, %) -> Boolean;
>      default { (a:%) ~= (b:%):Boolean == ~(a = b); }
> }

That is right, but I forgot to point out that the generic implementation may be
overriden. 
 
> I must say that I liked this idea of "default implementations" when I've
> encountered it. But it also introduces all the complications with
> multiple inheritance.
> 
> For example, assume we have
> 
> define ContainerType(T: Type): Category == with {
>    bracket: Tuple Type -> %;    -- constructor
>    generator: % -> Generator T; -- yields all the elements
>    #: % -> Integer;             -- size
>    default {
>      #(x: %): Integer == {
>        n: Integer := 0;
>        for element in x repeat n := n + 1;
>      }
>      return n;
>    }
> }
> 
> define FixedArrayType(n: Integer, T: Type): Category == with {
>    ContainerType(T);
>    default {#(x: %): Integer == n;}
> }
> 
> Theoretically, there is no difference in the two # functions, but
> practically, one would prefer the second one for FixedArray's since it
> is a little bit faster.

Yes, a default implementation, because it is more general, may be less
efficient. However, in Axiom, I trust Aldor also, any default implementation can
be overriden by simply defining the same operations in the domain constructor.
So in the example above, the compiler will compile the function '#' for
'FixedArrayType' using the simpler code.

> Now, assume I have some other category MyFancyCat that inherits from
> ContainerType, but not from FixedArrayType. Then I create
> 
> define MyFixedCat(n: Integer, T: Type): Category == with {
>    MyFancyCat T;
>    FixedArrayType(n, T);
> }
> 
> Of course, MyFixedCat also inherits defaults, but which one? (The
> current compiler takes the first one.) Changing the order of the
> categories results in more efficient code. However, think of a second
> default function that could be implemented in both categories, but the
> more efficient one in ContainerType. Then you can choose any order for
> MyFixedCat and get always only one efficient default.
>
In case of multiple inheritance, it is the responsibility of the user to choose,
not asking the compiler to choose for you (that would be equivalent to asking
the Interpreter to coerce and then complain about the result or resulting type).
It would be trivial to override (and choose) by something like:

   default(#: %)->Integer == #$(MyFancyCat T)

or 

   default(#:% ->Integer == #$FixedArrayType(n,T)

The compiler should not choose this and should flag it as a user error.

> When I started with Aldor, I used defaults a lot, but I encountered
> exactly the above scenario and then removed the defaults in almost all
> places and shifted it to the actual domains. Default implementations
> should be used with great care.

Are you telling me that Aldor does not allow overriding a default
implementation? I know Axiom allows.
 
> Computation time is never an issue in mathematics, but one should not
> (totally) neglect it in computer algebra.

Well, you need mathematics to prove computation time complexities. Then you let
computer programs worry about the details.
 
> Your (2) from above refers to the idea of renaming operators. Currently,
> apart from the "renaming during inheritance", we are restricted anyway
> quite a bit. For example, I would like my multiplication sign to look
> like \times or \circ. Well, Aldor does not (yet) handle Unicode. But
> even if it did, I would probably have to disambiguate certain
> mathematical expressions so that they become Aldor programs.

First of all, it is not I who suggested this renaming. I am opposing it, if
anything, as a solution to the problem raised because Axiom did not consider
AbelianMonoid as inherited from Monoid. I think "duplicating code", to some
extent, ease the problem, but down the road, it may not be a satisfactory
option.

How to handle renaming is of course a very difficult problem. The idea, in both
mathematics and symbolic computation, to overload operators (symbols) is to
reduce the number of different notations when the operators have essentially the
same properties. Let's not even discuss the complication that arises when
typesetting (which is when \cdot  or \times or simply concatenation may be used
for the same multiplication).  Thus * is commonly used for commutative
multiplication and sometimes for noncommutative multiplication as well, + is
always for addition, \circ for composition (non-commutative of course), \cdot
for matrix product or vector dot product, etc.  When an algebraic structure
involves more than one kind of multiplication, sometimes mathematicians "abuse"
notations by not distinguishing them, like k(yz) could mean a scalar
multiplication by k to an algebra product y and z.  In computer algebra, this is
clearly not allowed because, as I said, computer languages are rigid. So there
has to be a proliferation of symbols (operators, function names, etc) to make
every operation unique and unambiguous. In CAS, the best that can be done is to
retain a small set of symbols commonly used, and then use long function names
for others. Overloading helps to hide this proliferation. In choosing this set,
we must agree to the properties of each so that + will never be used for
non-commutative binary operation. Allowing arbitrary user selected symbols is
simply looking for trouble.


> But actually that is another issue: How to write a good user interface
> (notations) that maps nice looking expressions to the right underlying
> algorithm. Maple and Mathematica know already quite a bit of such user
> interfaces. However, they don't have the beauty of types.

I don't see how Maple or Mathematica handle this any better than Axiom. They
still fix properties of commonly used notations (perhaps not in a way that
everyone agrees, but if you use their system, you have to: for example,
Mathematica uses ** for non-commutative multiplication). What Maple and
Mathematica did better for user I/O is in their display technology, not their
input technology. You can type tex expressions like \lambda and it will display
the Greek font for lambda and it is treated just like any other symbol for input
purposes. There is no difference (other than display) if you use the identifier
'lambda' instead. The palettes that allow you to enter nice looking expression
as input are really mouse-click functions that display one thing and enter
something else to the kernel.

I believe we were not discussing user interface earlier. We were discussing
whether one should be allowed to use arbitrary operators (or functions) for, say
the multiplication of a monoid. We are trying to find a way to express the
mathematical fact that an abelian monoid is a monoid, despite the difference in
notation for the monoid operation. As I pointed out in previous email, the
problem is not simply "renaming" (and certainly not I/O) but rather the concept
of isomorphism is behind it.


> There is Chapter 9 of Doye's PhD thesis
> http://portal.axiom-developer.org/refs/articles/doye-aldor-phd.pdf
> which deals in part with the renaming.
> 
>  From what I understand, it simply makes two mathematically distinct
> things (operator symbols and operator names) distinct in the programming
> language. (Though I don't quite like the syntax.)

Thanks for the pointer. Glad that someone actually thought about this issue
already. After glancing Chap. 9 and guessing at the notations from earlier
chapters, it seems to me Doye is making each defining operation into an
equivalent class, or may be just a set, (\sigma (source target)) where \sigma
would be the default and hard coded symbol for the operation, and source and
targets are uniquely identifiable as sorted domains. The user can then declare
another symbol, say \lambda, to belong to this equivalent class or set, thus
changing the notation (renaming the function). So in effect, \lambda is tagged
by (\sigma (source target)). This seems to be the reverse of overloading. I'll
reserve judgement until I have read the thesis in more details.

By the way, I don't follow his example at bottom of p. 127: If \phi is a functor
(he said homomorphism, but that is wrong, because a list and a set are from
different categories), he wants the equation to hold:

    \phi(#([1,1]) = #(\phi([1,1]))

The right hand side makes sense, with answer 1, but the left hand side does not,
since #([1,1]) = 2 is a number, not a list. He claimed \phi(2) = 2.
In addition, there is no requirement that a functor commutes with operations. A
functor should, in addition to taking objects (lists) to objects (sets), also
has to take a morphism *between* source objects (lists) to another morphism
*between* the image objects (sets). The map '#' is not a morphism in the
category of Lists, nor of Sets. If one must, then '#' is a functor from the
category of Lists (and also for Sets) to the category whose objects are
non-negative integers. But the composition of functors \phi \circ # does not
make sense.  What Doye has in mind is the following diagram:

                 #
          Lists --> NNI
            |        |
       \phi |        |  id
            v   #    v
          Sets  --> NNI

But there is no reason to expect this to be a commutative diagram of functors.
So I think his example illustrates nothing.
            


> It would certainly make sense to print "a + a" as "2*a", but how an
> element of a domain is printed is decided by the domain.


It is more than just "certainly make sense to print". In a ring, a+a IS 2a. The
additive group structure is the same as a Z-module structure and hence 2a is the
correct way to denote the answer. How it is displayed in a CAS is something
else, and my argument is that this answer not only "makes sense", but it
"should" be displayed as 2a.
 
> If we have
> 
> define MyMonoid: Category == with {
>    1: %;
>    *: (%, %) -> %;
>    power: (%, Integer) -> %;
> }
> 
> -- and (now fancy notation with renaming)
> 
> define MyTimesPlus: Category == with
>    MyMonoid;
>    MyMonoid where {
>      0: % == 1;
>      +: (%, %) -> % == +;
>      ntimes: (%, Integer) -> % == power;
>    }
> }

Some typo above? should be '+: (%,%)->% == *' ? I am not following your syntax
for MyTimesPlus either (why use "where"?)  Parethesis not balanced also. I
thought you meant:

 define MyTimesPlus: Category == MyMonoid with {
  0: %;
  +: (%,%);
  ntimes: (%, INteger) -> %;
  default {
      0: % == 1;
      +: (%, %) -> % == *;
      ntimes: (%, Integer) -> % == power;
  }
 }

which says a domain of category MyTimesPlus belongs to the category of MyMonoid
but has three additional objects 0, + and ntimes, and here're the default
implementations. Or do you really mean the defaults are compulsory? (If so, then
I don't know why in MyInteger1 (and MyInteger2) below you define 0 (and +). You
would be overriding the defaults.)
 
> Then MyTimesPlus has 6 different signatures.
> If one removes the line "ntimes" then it would be only 5 and "power"
> would correspond to the multiplication (or (more correctly) to the
> actual implementation of it in a corresponding domain).
> 
> So, operator symbols and operator names agree as long as they are not
> renamed.
> 
> And one could also build
> 
> MyInteger1: MyTimesPlus == add {
>    Rep == Integer;
>    0: % == per 0;
>    1: % == per 1;
>    ...
> }
> 
> MyInteger2: MyTimesPlus == add {
>    Rep == Integer;
>    0: % == per 1;
>    1: % == per 0;
>    (x: %) + (y: %): % == per (rep x * rep y);
>    (x: %) * (y: %): % == per (rep x + rep y);
>    ...
> }
> 
> Now, clearly, it can easily be figured out what 0, 1, +, etc. mean if
> MyInteger1 or MyInteger2 is in scope. 

Depends. Most likely, MyInteger1 and MyInteger2 would have coercion to and from
Integer (to enable input).  Unless you type qualify the constants, it is not
clear what an interpreter would do.

> If both are in scope then nobody
> can infer what "0 + 1" should return. In fact, constructing
> implementations like that is also currently possible without renaming.

No one can tell what "0+1" is unless the 0 and 1 are qualified as to which
domain each belongs. You are creating an ambiguous situation deliberately, and
so you have to make it unambiguous again by package call (which is in some sense
the same as renaming). But what is your point?

You know, there is some mathematics behind these constructions, but that is bad
mathematics: it may be fun to confuse students to switch the two monoid
structures in Integer and even to interchange the notation for 0 and1 and + and
*. But no real mathematics is done that way, even if it is "allowed" AND
correct! We don't say this is a bug in the mathematical system and we don't view
it as a problem at all. So why should computer algebra systems be different? 

> > So I hope we need not argue a third issue: (3) maintaining standard notations
> > for the defining operations in common algebraic structures.
> 
> Hmmm, don't some people use \cdot, \times, \circ, \odot, etc to denote
> multiplication? ;-)

There are many kinds of multiplication. Sometimes people overload a symbol and
sometimes to emphasize the distinction, they use different ones. Very often,
these distinctions are unnecessary as they can be deduced from context (by
intelligent human). In symbolic computation, that is different. Without detail
package call or domain declaration, the computer cannot tell the context.
Computer can handle "overloading" so let's use it, and use it in a way in
agreement with mathematics when mathematical symbols of operations are used as
identifiers.
 
> But let's continue with MyInteger1/2.
> If I now ask
> 
> MyInteger1 has MyMonoid
> 
> then that refers to the multiplicative structure. I have, however, to say
> 
> macro MyAdditiveMonoidMacro == {
>    MyMonoid where {
>      0: % == 1;
>      +: (%, %) -> % == +;
>      ntimes: (%, Integer) -> % == power;
>    }
> }
> MyInteger1 has MyAdditiveMonoidMacro

Do you mean you have to use the macro to ask:

  MyInteger1 has MyTimesPlus

while 'MyInteger1 has MyMonoid' works?

> So what do I gain by a "renaming feature"? Not much, since now I must
> add the corresponding "with respect to addition" or create another category.
> (Isn't that very similar to the case when Monoid and AbelianMonoid are
> totally unrelated?)
> 
> In fact, if I now define a new category
> 
> define MyAdditiveMonoidCategory == {
>    MyMonoid where {
>      0: % == 1;
>      +: (%, %) -> % == +;
>      ntimes: (%, Integer) -> % == power;
>    }
> }
> 
> and ask
> 
> MyInteger1 has MyAdditiveMonoidCategory
> 
> then this should (and must) return false since MyInteger1 is not
> explicitly declared to be a member of that category.
> 
> Ralf

I think you just demonstrated the rigidity of computer languages. I believe
allowing "user renaming" of functions sets up another level of abstraction that
will only cause more confusion and will not solve the problem of multiple
inheritance (I may change my mind after reading Doye). The designers of Axiom
made a good compromise, even though it does not reflect the true mathematics
algebraic hierarchy. One possible improvement (but far from a total solution) is
to include inheritance via isomorphisms, but even that is a lot of work.

\start
Date: 08 Mar 2006 10:22:02 +0100
From: Martin Rubey
To: William Sit
Subject: Re: Curiosities with Axiom mathematical structures
Cc: Ralf Hemmecke

William Sit writes:

> In case of multiple inheritance, it is the responsibility of the user to choose,
> not asking the compiler to choose for you (that would be equivalent to asking
> the Interpreter to coerce and then complain about the result or resulting type).
> It would be trivial to override (and choose) by something like:
> 
>    default(#: %)->Integer == #$(MyFancyCat T)
> 
> or 
> 
>    default(#:% ->Integer == #$FixedArrayType(n,T)

> 
> The compiler should not choose this and should flag it as a user error.

William, I agree! (in both points)

> By the way, I don't follow his example at bottom of p. 127: If \phi is a functor
> (he said homomorphism, but that is wrong, because a list and a set are from
> different categories), he wants the equation to hold:
> 
>     \phi(#([1,1]) = #(\phi([1,1]))
> 
> The right hand side makes sense, with answer 1, but the left hand side does not,
> since #([1,1]) = 2 is a number, not a list. He claimed \phi(2) = 2.
> In addition, there is no requirement that a functor commutes with operations. A
> functor should, in addition to taking objects (lists) to objects (sets), also
> has to take a morphism *between* source objects (lists) to another morphism
> *between* the image objects (sets). The map '#' is not a morphism in the
> category of Lists, nor of Sets. If one must, then '#' is a functor from the
> category of Lists (and also for Sets) to the category whose objects are
> non-negative integers. But the composition of functors \phi \circ # does not
> make sense.  What Doye has in mind is the following diagram:
> 
>                  #
>           Lists --> NNI
>             |        |
>        \phi |        |  id
>             v   #    v
>           Sets  --> NNI
> 
> But there is no reason to expect this to be a commutative diagram of functors.
> So I think his example illustrates nothing.

Thank you for pointing out this. I had the same feeling, but I wasn't sure
enough about it. Now it's settled.

> I think you just demonstrated the rigidity of computer languages. I believe
> allowing "user renaming" of functions sets up another level of abstraction
> that will only cause more confusion and will not solve the problem of
> multiple inheritance (I may change my mind after reading Doye). The designers
> of Axiom made a good compromise, even though it does not reflect the true
> mathematics algebraic hierarchy. One possible improvement (but far from a
> total solution) is to include inheritance via isomorphisms, but even that is
> a lot of work.

Do you mean that passing operations to the categories would be a feasible
approach? I.e., being allowed to say something like

Monoid(m:(%,%)->%): Category == with
       square: % -> %

     add
       square a == m(a,a)

Of course, one would have to rethink this several times, the suggested notation
here is clearly not yet perfect. One might object that this notation violates
the possibility of creating anonymous categories, but I suspect that this
wouldn't make sense anyway.

\start
Date: Wed, 8 Mar 2006 10:29:45 -0500
From: Tim Daly
To: Alfredo Portes, Bill Page
Subject: Web-to-PC Clipboard

http://www.informationweek.com/story/showArticle.jhtml?articleID=181501850&cid=RSSfeed_tWk_All

Microsoft Debuts Web-To-PC Clipboard

The ability to cut-and-paste across Web sites, called "Live
Clipboard," is going to be freely available under Creative Commons
license. To further emphasize the point, Microsoft's Ray Ozzie
demonstrated the tool with Firefox instead of using Internet Explorer.

By Reuters
InformationWeek

Mar 8, 2006 08:10 AM

SAN DIEGO (Reuters) - Microsoft Corp. extended an olive branch to some
of its harshest critics on Tuesday by proposing a way for Internet
users to "cut and paste" live Web data across different sites, just as
they can between computer programs.

Ray Ozzie, Microsoft's chief technical officer, told a conference of
top Web developers here that his company wants to openly license a
simple technology for sharing data between Web and computer programs
-- whether Microsoft-controlled or not.

"Live Clipboard," as the concept technology is known, would take the
widely used clipboard feature common to many computer programs and
extend it to the Web, allowing users to share organized data between
Web sites or move it into PC programs.

In a slide show demonstration, Ozzie showed how users could simply cut
and paste complex structured information from one Web site to another,
or move the same data, preserving its formatting, to programs running
on Windows desktop computers.

He copied personal contact information out of his computer address
book into an online shopping checkout page, filling out the order
processing pages in a quick gesture, for example.

"It allows the user to copy structured information from one place to
another in a non-geeky fashion," Ozzie told roughly 1,000 programmers
and Web developers attending the O'Reilly Emerging Technology
conference under way here this week.

The O'Reilly conference is an intellectual hothouse for Web developers
who gather each year to debate how best to build a new generation of
collaborative software based on open source software principles that
pose a big challenge to Microsoft.

Striking a decidedly humbler tone than older generations of Microsoft
executives, Ozzie showed how his Web-sharing prototype can work on a
variety of non-Microsoft Web sites.

To emphasize his point, Ozzie used the open source Firefox browser
rather than Microsoft's own Internet Explorer browser.

"It's impressive stuff," said Doc Searles, a co-author of iconoclastic
marketing manual "The Cluetrain Manifesto" and a leading open source
advocate. "It shows the amount of change that has occurred in
Microsoft management."

Sam Ruby, an IBM engineer who is director of the Apache Software
Foundation, whose open source software is widely used to run Web
servers, also said he was keen to give the Web clipboard software a
try, but still needed to be convinced of Microsoft's commitment to
open standards.

Ozzie copied a calendar entry from the independent event listings Web
site Eventful and pasted it into that his Outlook calendar, moving not
just text, but all of the appropriate elements that made up the full
appointment entry.

In a more dramatic attempt to impress the geeky audience, Ozzie took
location-tracking data that appears on his personal blog that monitors
his movements via his cellphone and pasted it onto the page of
youthful social networking site Facebook.

He then copied an updating list of his contacts from Facebook into a
Microsoft Web-based mapping application and the locations of his
contacts immediately appeared as flags on the map. Ozzie posted an
example on his blog at
http://spaces.msn.com/editorial/rayozzie/demo/liveclip/liveclips
ample/clipboardexample.html

Ozzie said he conceived of the idea a month ago while mulling the
history of how computer user interaction had evolved over the past two
to three decades. He asked a project team including his brother, Jack
Ozzie, to implement his idea.

Live Clipboard is based on JavaScript and standard data formats widely
used by Web developers. "This is not platform specific," Ozzie said,
using industry jargon for operating systems like Microsoft Windows or
Apple Mac OS X software.

Microsoft also plans to freely license the software under the Creative
Commons license, requiring only that Microsoft receive attribution for
its work and that any improvements to the code are shared with other
developers.

"It's a little gift to the Web," he said.

\start
Date: Wed, 8 Mar 2006 10:35:30 -0500
From: Tim Daly
To: Alfredo Portes, Bill Page
Subject: Web-to-PC Clipboard

In the article it appears that there is a javascript program available
somewhere that allows cut and paste from web to program and back.

This is the kind of tool that Doyen and Axiom need to allow moving
pamphlet files from Axiom to the wiki and back. 

I'm not sure what the clipboard interface would look like but it should
be possible to push it into a file using a standalone program that can
type the clipboard to stdout or move a file to the clipboard.

http://www.informationweek.com/story/showArticle.jhtml?articleID=181501850&cid=RSSfeed_tWk_All

Microsoft Debuts Web-To-PC Clipboard

\start
Date: Wed, 08 Mar 2006 17:01:42 +0100
From: Ralf Hemmecke
To: William Sit
Subject: Re: Curiosities with Axiom mathematical structures

On 03/07/2006 08:52 PM, William Sit wrote:
> Ralf Hemmecke wrote:
>> For example, assume we have
>>
>> define ContainerType(T: Type): Category == with {
>>    bracket: Tuple Type -> %;    -- constructor
>>    generator: % -> Generator T; -- yields all the elements
>>    #: % -> Integer;             -- size
>>    default {
>>      #(x: %): Integer == {
>>        n: Integer := 0;
>>        for element in x repeat n := n + 1;
>>      }
>>      return n;
>>    }
>> }
>>
>> define FixedArrayType(n: Integer, T: Type): Category == with {
>>    ContainerType(T);
>>    default {#(x: %): Integer == n;}
>> }

>> Now, assume I have some other category MyFancyCat that inherits from
>> ContainerType, but not from FixedArrayType. Then I create
>>
>> define MyFixedCat(n: Integer, T: Type): Category == with {
>>    MyFancyCat T;
>>    FixedArrayType(n, T);
>> }
>>
>> Of course, MyFixedCat also inherits defaults, but which one? (The
>> current compiler takes the first one.) Changing the order of the
>> categories results in more efficient code. However, think of a second
>> default function that could be implemented in both categories, but the
>> more efficient one in ContainerType. Then you can choose any order for
>> MyFixedCat and get always only one efficient default.

> In case of multiple inheritance, it is the responsibility of the user to choose,
> not asking the compiler to choose for you (that would be equivalent to asking
> the Interpreter to coerce and then complain about the result or resulting type).
> It would be trivial to override (and choose) by something like:
> 
>    default(#: %)->Integer == #$(MyFancyCat T)
> 
> or 
> 
>    default(#:% ->Integer == #$FixedArrayType(n,T)
> 
> The compiler should not choose this and should flag it as a user error.

Ah, I like your idea with the package calling mechanism via

   $(MyFancyCat(T)

Unfortunately, the current Aldor compiler rejects that.

"defaultChoice.as", line 28:
     #(x: %): Integer == #(x)$FixedArrayType(n, T);
............................^^
[L28 C29] #2 (Error) There are no suitable meanings for the operator 
`#$FixedArrayType(n, T)'.
[L28 C30] #1 (Error) No one possible return type satisfies the context type.
   These possible return types were rejected:
           -- Category == ContainerType(T) with default #(x: %): 
AldorIntege...
   The context requires an expression of type  with .


And from Section 8.3 of the Aldor User Guide

   http://www.aldor.org/docs/HTML/chap8.html#3

it is not completely obvious that $ couldn't also be used with 
categories (instead of domains) as the second argument.

But your suggestion is great. As with other things if the compiler 
detects ambiguities, it should simply stop and tell that, or to be a bit 
more user friendly give a warning so that a programmer can override the 
default if he/she does not like what the compiler chooses.

Anyway, if there where some control over the "default"s that would be an 
advantage.

>> When I started with Aldor, I used defaults a lot, but I encountered
>> exactly the above scenario and then removed the defaults in almost all
>> places and shifted it to the actual domains. Default implementations
>> should be used with great care.
> 
> Are you telling me that Aldor does not allow overriding a default
> implementation? I know Axiom allows.

No. SPAD and Aldor behave in the same way. Any specific implementation 
in a domain overrides the category defaults.

At the time I used it, I wanted to avoid to duplicate code, so I tried 
to give efficient default implementations in categories. Until I 
discovered the problem that I could not select which default would be used.

Inheritance of behaviour from domains might seem a bit strange for 
people coming from other programming languages.

Quiz: What is the output of the following code? Explain why!

--quiz.as
#include "aldor"
#include "aldorio"
Cat: Category == with {
   coerce: Integer -> %;
   <<: (TextWriter, %) -> TextWriter;
   foo: % -> Integer;
}
DomA: Cat == add {
   Rep == Integer;
   import from Integer;
   coerce(i: Integer): % == per i;
   foo(x: %): Integer == rep x;
   (tw: TextWriter) << (x: %): TextWriter == tw << foo(x);
}

Dom2A: Cat == DomA add {
   Rep == Integer;
   import from Integer;
   foo(x: %): Integer == 2*(rep x);
}

main(): () == {
   import from Integer, DomA, Dom2A;
   stdout << "DomA  " << (2::DomA ) << newline;
   stdout << "Dom2A " << (3::Dom2A) << newline;
}
main();
--end quiz.as

> How to handle renaming is of course a very difficult problem. The idea, in both
> mathematics and symbolic computation, to overload operators (symbols) is to
> reduce the number of different notations when the operators have essentially the
> same properties. Let's not even discuss the complication that arises when
> typesetting (which is when \cdot  or \times or simply concatenation may be used
> for the same multiplication).  Thus * is commonly used for commutative
> multiplication and sometimes for noncommutative multiplication as well, + is
> always for addition, \circ for composition (non-commutative of course), \cdot
> for matrix product or vector dot product, etc.  When an algebraic structure
> involves more than one kind of multiplication, sometimes mathematicians "abuse"
> notations by not distinguishing them, like k(yz) could mean a scalar
> multiplication by k to an algebra product y and z.  In computer algebra, this is
> clearly not allowed because, as I said, computer languages are rigid.

Well, I think you are wrong with the last sentence. If y and z are 
polynomials over integers and k is an integer (in Aldor or Axiom) then 
it is already possible to write "k*(y*z)". And if one exploits the 
syntactic sugar features of Aldor and defines functions

macro P == UnivariatePolynomial Integer;
apply: (Integer, P) -> P;
apply: (P, P) -> P;

then one could even write "k(y z)".

But you probably know that interally the function name of "*" includes 
its type.

> By the way, I don't follow his example at bottom of p. 127: If \phi is a functor
> (he said homomorphism, but that is wrong, because a list and a set are from
> different categories), he wants the equation to hold:
> 
>     \phi(#([1,1]) = #(\phi([1,1]))
> 
> The right hand side makes sense, with answer 1, but the left hand side does not,
> since #([1,1]) = 2 is a number, not a list. He claimed \phi(2) = 2.

Wow, exactly that point puzzled me, too. But maybe the important thing 
is that the design of a good category and domain hierarchy is not 
straightforward if an automated coercion routine should be possible.

But I won't say much more since I haven't really studied the details.

\start
Date: Wed, 08 Mar 2006 17:54:25 +0100
From: Ralf Hemmecke
To: William Sit
Subject: Re: Curiosities with Axiom mathematical structures

On 03/07/2006 08:52 PM, William Sit wrote:
> Ralf Hemmecke wrote:
>> If we have
>>
>> define MyMonoid: Category == with {
>>    1: %;
>>    *: (%, %) -> %;
>>    power: (%, Integer) -> %;
>> }
>>
>> -- and (now fancy notation with renaming)
>>
>> define MyTimesPlus: Category == with
>>    MyMonoid;
>>    MyMonoid where {
>>      0: % == 1;
>>      +: (%, %) -> % == +;
>>      ntimes: (%, Integer) -> % == power;
>>    }
>> }
> 
> Some typo above? should be '+: (%,%)->% == *' ?

Of course.

 > I am not following your syntax
> for MyTimesPlus either (why use "where"?)  Parethesis not balanced also.

Hmm, I forgot the opening { after with. :-(
I've just "invented" this syntax for the purpose of renaming. Don't take 
it to serious.

 > I thought you meant:
> 
>  define MyTimesPlus: Category == MyMonoid with {
>   0: %;
>   +: (%,%);
>   ntimes: (%, Integer) -> %;
>   default {
>       0: % == 1;
>       +: (%, %) -> % == *;
>       ntimes: (%, Integer) -> % == power;
>   }
>  }
> 
> which says a domain of category MyTimesPlus belongs to the category of MyMonoid
> but has three additional objects 0, + and ntimes, and here're the default
> implementations.

No. I definitely did not mean that. As your code looks to me, it should 
even be possible to compile that with the Aldor compiler. But in your 
code MyTimesPlus has only one monoid structure while in my code the 
"Monoid where {...}" would be the second monoid structure.
> Or do you really mean the defaults are compulsory?

Yes, it looks like a default, but it isn't. Or better, it was not
intended to be like default.

>> Then MyTimesPlus has 6 different signatures.
>> If one removes the line "ntimes" then it would be only 5 and "power"
>> would correspond to the multiplication (or (more correctly) to the
>> actual implementation of it in a corresponding domain).
>>
>> So, operator symbols and operator names agree as long as they are not
>> renamed.
>>
>> And one could also build
>>
>> MyInteger1: MyTimesPlus == add {
>>    Rep == Integer;
>>    0: % == per 0;
>>    1: % == per 1;
>>    ...
>> }
>>
>> MyInteger2: MyTimesPlus == add {
>>    Rep == Integer;
>>    0: % == per 1;
>>    1: % == per 0;
>>    (x: %) + (y: %): % == per (rep x * rep y);
>>    (x: %) * (y: %): % == per (rep x + rep y);
>>    ...
>> }
>>
>> Now, clearly, it can easily be figured out what 0, 1, +, etc. mean if
>> MyInteger1 or MyInteger2 is in scope. 
> 
> Depends. Most likely, MyInteger1 and MyInteger2 would have coercion to and from
> Integer (to enable input).  Unless you type qualify the constants, it is not
> clear what an interpreter would do.

No? Without coerce functions and without Integer in scope what would be 
the problem if the interpreter only sees MyInteger2?

I don't need Integer in scope. And if Integer and MyInteger2 are in 
scope then clearly "0+1" is ambiguous. Even if you replace MyInteger2 by 
MyInteger1, "0+1" is ambiguous since 0 and 1 could be Integer or 
MyInteger1 and there would be both +: (Integer, Integer) -> Integer and 
+: (MyInteger1, MyInteger1) -> MyInteger1 in scope. That the compiler 
should reject it is clear with and without coerce functions to and from 
Integer. But if there is no coerce also the interpreter must reject that 
expression.

>> If both are in scope then nobody
>> can infer what "0 + 1" should return. In fact, constructing
>> implementations like that is also currently possible without renaming.
> 
> No one can tell what "0+1" is unless the 0 and 1 are qualified as to which
> domain each belongs. You are creating an ambiguous situation deliberately, and
> so you have to make it unambiguous again by package call (which is in some sense
> the same as renaming). But what is your point?

Maybe I don't understand what the interpreter is doing. But if I just 
bring MyInteger2 into scope and NOT Integer (no idea how to do this in 
Axiom) then why wouldn't the interpreter be able to relate the 
characters (or literals) 0 and 1 as something of type MyInteger2 and the 
+ as the corresponding function from MyInteger2? The result of "0+1" is 
covered by

     (x: %) + (y: %): % == per (rep x * rep y);

so inside MyInteger2 the result is represented by the Integer 0 but 
should print (if I had implemented a output routine) as 1@MyInteger2.

> You know, there is some mathematics behind these constructions, but that is bad
> mathematics:

I deliberately called it MyTimesPlus and not Ring!

> it may be fun to confuse students to switch the two monoid
> structures in Integer and even to interchange the notation for 0 and 1 and + and
> *. But no real mathematics is done that way, even if it is "allowed" AND
> correct! We don't say this is a bug in the mathematical system and we don't view
> it as a problem at all. So why should computer algebra systems be different? 

Of course, the MyInteger stuff above was some playing around, but you 
said that the interpreter could not figure out what is meant by "*" or 
"+" if Aldor would allow renaming. I still don't see the problem. It's a 
question of what one makes visible to the interpreter/compiler.

The whole discussion came about since people (including me) wonder why 
an AbelianMonoid does not inherit from Monoid. If that design (and the 
reasons why it must be that way in Axiom) where explained better I think 
that would avoid lots of questions about that difference between 
mathematics and Axiom.

>> But let's continue with MyInteger1/2.
>> If I now ask
>>
>> MyInteger1 has MyMonoid
>>
>> then that refers to the multiplicative structure. I have, however, to say
>>
>> macro MyAdditiveMonoidMacro == {
>>    MyMonoid where {
>>      0: % == 1;
>>      +: (%, %) -> % == +;
>>      ntimes: (%, Integer) -> % == power;
>>    }
>> }
>> MyInteger1 has MyAdditiveMonoidMacro
> 
> Do you mean you have to use the macro to ask:
> 
>   MyInteger1 has MyTimesPlus
> 
> while 'MyInteger1 has MyMonoid' works?

No.

For MyInteger1 has MyAdditiveMonoidMacro":
The syntax with the "where" is NOT Aldor. This is just an ad hoc syntax 
introduced by me. But without the macro one would have to use 
parentheses around the category (including the "where") since "has" 
binds higher than "where".

The expression

MyInteger1 has MyTimesPlus

should work perfectly and return true since MyInteger1 has been declared 
to be of that type.

\start
Date: Wed, 8 Mar 2006 14:36:26 -0500
From: Bill Page
To: list
Subject: RE: Curiosities with Axiom mathematical structures

BTW. I've replied just on the axiom-developer since the email
lists seem to be functioning (more or less) properly again.
When replying to something that includes a Cc: to Axiom Wiki
email mathaction@aximo-developer.org, I think we need to keep
in mind that the email will be appended to a page named by the
bracket in the subject, [axiom-developer] in this case. Since
this name automatically occurs on all emails forwarded from
the axiom-developer list, this means the corresponding page on
the Axiom Wiki can get unmanageably long...

On March 7, 2006 2:53 PM William Sit wrote:
> ...
> Ralf Hemmecke wrote:
> > There is Chapter 9 of Doye's PhD thesis
> > http://portal.axiom-developer.org/refs/articles/doye-aldor-phd.pdf
> > which deals in part with the renaming.
> > 
> >  From what I understand, it simply makes two mathematically
> > distinct things (operator symbols and operator names) distinct
> > in the programming language. (Though I don't quite like the syntax.)
> 
> ... 
> By the way, I don't follow his example at bottom of p. 127: 
> If \phi is a functor (he said homomorphism, but that is wrong,
> because a list and a set are from different categories),

Doye's use of the work homomorphism is correct in the context
of order-sorted algebra. Doye is not using the language of
category theory in either the mathematical sense or in Axiom's
sense.

http://en.wikipedia.org/wiki/Homomorphism

A homomorphism is just a map from one algebra to another that
preserves the abstract algebraic structure. From Doye's point of
view both lists and sets are algebras in this sense).

> he wants the equation to hold:
> 
>     \phi(#([1,1]) = #(\phi([1,1]))
>

This is just the definition of preservation of algebraic structure.
 
> The right hand side makes sense, with answer 1, but the left 
> hand side does not, since #([1,1]) = 2 is a number, not a list.

In Doye's formalism both number 2 and the list [1,1] are part
of the algebraic structure of 'List'. phi maps both of these to
the corresponding structures in 'Set'.

> He claimed \phi(2) = 2.

Yes, the '2' in 'List' maps to the '2' in 'Set'.

> In addition, there is no requirement that a functor commutes 
> with operations. A functor should, in addition to taking
> objects (lists) to objects (sets), also has to take a morphism
> *between* source objects (lists) to another morphism *between*
> the image objects (sets). The map '#' is not a  morphism in the
> category of Lists, nor of Sets.

'#' is an operator in both the 'List' and 'Set' order-sorted
algebras.

> If one must, then '#' is a functor from the category of Lists
> (and also for Sets) to the category whose objects are
> non-negative integers. But the composition of functors \phi 
> \circ # does not make sense.

No, this is not what Doye has in mind.

> What Doye has in mind is the following diagram:
> 
>                  #
>           Lists --> NNI
>             |        |
>        \phi |        |  id
>             v   #    v
>           Sets  --> NNI
> 
> But there is no reason to expect this to be a commutative 
> diagram of functors. So I think his example illustrates nothing.
>             

No. The diagram should look like this:

        #: Lists --> NNI
                  |     
             \phi |
                  |
                  v
        #: Sets  --> NNI

Where we have the algebra 'List' on top and the algebra 'Set'
on the bottom. We should think of \phi as mapping everything
from 'List' to 'Set', i.e. %_list -> %_set, NNI_list -> NNI_set,
and #_list -> #_set.

\start
Date: Wed, 08 Mar 2006 23:24:42 +0100
From: Ralf Hemmecke
To: Martin Rubey
Subject: Re: Curiosities with Axiom mathematical structures

> Do you mean that passing operations to the categories would be a feasible
> approach? I.e., being allowed to say something like
> 
> Monoid(m:(%,%)->%): Category == with
>        square: % -> %
> 
>      add
>        square a == m(a,a)

Martin, stop writing in SPAD. I thought you also agreed that new things 
have to be written in Aldor. And there you would to write the default 
implementation with "default" and not with "add". Otherwise there would 
be an anonymous domain "add {square ...}" inside a with clause.

> Of course, one would have to rethink this several times, the suggested notation
> here is clearly not yet perfect. One might object that this notation violates
> the possibility of creating anonymous categories, but I suspect that this
> wouldn't make sense anyway.

Yes, one has to rethink that quite a lot. The problem with your 
suggestion is the following

1) You cannot simply ask

   Integer has Monoid

because you have to give a parameter.

2) If you say something like

MyMonoid(T: Type, m: (T, T) -> T): Category == with {
   square: T-> T;
   default {square(t: T): T == m(t, t)}
}

then it is perfect Aldor.
Then, however, you ask

   Integer has MyMonoid(Integer, *)

and it will return true only if you have said

extend Integer: MyMonoid(Integer, *) == add;

somewhere.
(But probably you had something else in mind.)

Although I don't really like that an AbelianMonoid is not a Monoid, and 
although I think that renaming during inheritance would be nearer to 
mathematics... after all the discussion here, I somehow think that the 
design in Axiom is not really bad. The reason is that I have not seen a 
clear case where renaming would be over-advantageous.

I'd like to say

   Integer has Monoid

instead of

   Integer has Monoid(*, 1);
   Integer has Monoid(+, 0);

Simply think of a category Foo with hundreds of exported function, would 
you like to write

   Dom has Foo(f1, f2, ..., f100)

??? That is not really handy.

Maybe we should open up a page on AxiomWiki and list some cases where 
one could really benefit from renaming. I guess the list would be quite 
short and not comparable with the effort such an Aldor extension would cost.

\start
Date: 09 Mar 2006 15:46:14 +0100
From: Martin Rubey
To: Ralf Hemmecke
Subject: Re: Curiosities with Axiom mathematical structures

Ralf Hemmecke writes:

> > Do you mean that passing operations to the categories would be a feasible
> > approach? I.e., being allowed to say something like
> > Monoid(m:(%,%)->%): Category == with
> >        square: % -> %
> >      add
> >        square a == m(a,a)
 
> Martin, stop writing in SPAD. I thought you also agreed that new
> things have to be written in Aldor. And there you would to write the
> default implementation with "default" and not with "add". Otherwise
> there would be an anonymous domain "add {square ...}" inside a with
> clause.

Well, I'm not yet fluent in Aldor. I'm waiting for your talk at the Workshop...

> > Of course, one would have to rethink this several times, the
> > suggested notation here is clearly not yet perfect. One might
> > object that this notation violates the possibility of creating
> > anonymous categories, but I suspect that this wouldn't make sense
> > anyway.
 
> Yes, one has to rethink that quite a lot. The problem with your suggestion is
> the following
> 
> 1) You cannot simply ask
> 
>    Integer has Monoid
> 
> because you have to give a parameter.

I wouldn't want to ask "Integer has Monoid", since this doesn't make any sense
to me. I'd like to ask "Integer has Monoid(Integer, *)" or 
"Integer has Monoid(*)"

> 2) If you say something like
> 
> MyMonoid(T: Type, m: (T, T) -> T): Category == with {
>    square: T-> T;
>    default {square(t: T): T == m(t, t)}
> }
> 
> then it is perfect Aldor.

> Then, however, you ask
> 
>    Integer has MyMonoid(Integer, *)
> 
> and it will return true only if you have said
> 
> extend Integer: MyMonoid(Integer, *) == add;
> 
> somewhere.
> (But probably you had something else in mind.)

So, in fact in Aldor we can solve the "problem"?

Monoid(T: Type, m: (T, T) -> T): Category == with {
   square: T-> T;
   default {square(t: T): T == m(t, t)}
}

Word: BasicType == add {
   add {*(a: %, b: %):%  == concat(a,b) }

extend Word: Monoid(Word, *) == add;

??? If this is the case, I know what I want!!!

> Although I don't really like that an AbelianMonoid is not a Monoid, and
> although I think that renaming during inheritance would be nearer to
> mathematics... after all the discussion here, I somehow think that the design
> in Axiom is not really bad. The reason is that I have not seen a clear case
> where renaming would be over-advantageous.

yes

> I'd like to say
> 
>    Integer has Monoid
> 
> instead of
> 
>    Integer has Monoid(*, 1);
>    Integer has Monoid(+, 0);

NOOO!
 
> Simply think of a category Foo with hundreds of exported function, would you
> like to write
> 
>    Dom has Foo(f1, f2, ..., f100)

no, but wait a moment: It is obvious to me that I don't want to have all
exported functions as parameters. Only certain "defining" functions, like:

Integer has Monoid(*, 1);
Integer has Ring(+, *, 1);

Can you think of an example where more than, say 5, parameters would
be desirable?

\start
Date: Thu, 09 Mar 2006 10:52:27 -0500
From: William Sit
To: Bill Page
Subject: Re: Curiosities with Axiom mathematical structures

Bill Page wrote:
> > Ralf Hemmecke wrote:
> > > There is Chapter 9 of Doye's PhD thesis
> > > http://portal.axiom-developer.org/refs/articles/doye-aldor-phd.pdf
> > > which deals in part with the renaming.

> > William Sit wrote:
> > By the way, I don't follow his example at bottom of p. 127:
> > If \phi is a functor (he said homomorphism, but that is wrong,
> > because a list and a set are from different categories),
> 
> Doye's use of the work homomorphism is correct in the context
> of order-sorted algebra. Doye is not using the language of
> category theory in either the mathematical sense or in Axiom's
> sense.

> > What Doye has in mind is the following diagram:
> >
> >                  #
> >           Lists --> NNI
> >             |        |
> >        \phi |        |  id
> >             v   #    v
> >           Sets  --> NNI
> >
> > But there is no reason to expect this to be a commutative
> > diagram of functors. So I think his example illustrates nothing.
> >
> 
> No. The diagram should look like this:
> 
>         #: Lists --> NNI
>                   |
>              \phi |
>                   |
>                   v
>         #: Sets  --> NNI
> 

Thanks, Bill, for clarifying this and my apologies to Doye. So Doye is really
saying the same thing I said, that in his setup, \phi (in your diagram above) is
not a homomorphism and there is no such homomorphism possible. If I follow this
correctly (using normal meaning of functor and category):

  the objects in Doye's setup the objects are functors between categories,     
f:A -> B, g: C -> D, where A, B, C, D are categories
     for example, f = #_List and g = #_Set in your diagram

  a morphism between two such objects f and g is a pair of functors 
    \phi = (h: A->C, k: B->D) which make the diagram below commute:

                f
            A  -->   B
            |        |
          h |        |  k
            v   g    v
            C  -->   D
    

and Doye says for the example f and g, there is no morphism \phi:f -> g where h
is the functor that takes a list to the corresponding set, precisely because my
diagram is not commutative. (I may yet be wrong in this interpretation, since
this could be far from the order-sorted algebra, which I find difficult because
of all the new terms.)

Back to reading more of Doye to understand the implication of this. Is it his
conclusion that automatic coercion is not possible because of this lack of
homomorphism between the two 'ordered-sorted algebras' in Axiom?

\start
Date: 09 Mar 2006 17:08:29 +0100
From: Martin Rubey
To: Martin Rubey
Subject: BINGO,	Curiosities with Axiom mathematical structures

I am satisfied now:
-------------------------------------------------------------------------------
#include "axiom"

MyMonoid(T: Type, m: (T, T) -> T): Category == with {
   square: T-> T;
   default {square(t: T): T == m(t, t)}
}

MyWord: with { 
   coerce: String -> %;
   c:(%, %) -> %
}
   == add {
   Rep == String;
   import from String;
   coerce(a: String): % == per(a);
   c(a: %, b: %):%  == coerce(concat(rep(a), rep(b))$String) }

import from MyWord;
extend MyWord: MyMonoid(MyWord, c) == add;
-------------------------------------------------------------------------------

The only slight inconvenience is that we need to have the domain itself as
parameter of the category, too. But I think that's ok, given that there is no
need to change the compiler in any way. I'll post this on SandboxMonoid as
well.

-------------------------------------------------------------------------------

                        AXIOM Computer Algebra System 
                     Version: Axiom 3.9 (September 2005)
               Timestamp: Monday October 31, 2005 at 16:30:26 
-----------------------------------------------------------------------------
   Issue )copyright to view copyright notices.
   Issue )summary for a summary of useful system commands.
   Issue )quit to leave AXIOM and return to shell.
-----------------------------------------------------------------------------
 
   Re-reading compress.daase   Re-reading interp.daase
   Re-reading operation.daase
   Re-reading category.daase
   Re-reading browse.daase
(1) -> 
(1) -> )co test.as

(1) -> )sh MyMonoid
 MyMonoid(T: Type,m: ((T,T) -> T))  is a category constructor
 Abbreviation for MyMonoid is MYMONOI 
 This constructor is exposed in this frame.
 Issue )edit test.as to see algebra source code for MYMONOI 

------------------------------- Operations --------------------------------
 square : T -> T                      

(1) -> )sh MyWord
 MyWord  is a domain constructor
 Abbreviation for MyWord is MYWORD 
 This constructor is exposed in this frame.
 Issue )edit test.as to see algebra source code for MYWORD 

------------------------------- Operations --------------------------------
 c : (%,%) -> %                        coerce : String -> %
 square : MyWord -> MyWord            

(1) -> a := "Bingo"::MyWord

 LISP output:
Bingo
                                                                 Type: MyWord
(2) -> square a

 LISP output:
BingoBingo
                                                                 Type: MyWord

(3) -> MyWord has MyMonoid(MyWord, c)

   (3)  true

\start
Date: Thu, 09 Mar 2006 12:17:37 -0500
From: William Sit
To: Ralf Hemmecke
Subject: Re: Curiosities with Axiom mathematical structures

Hi Ralf:

Earlier, Ralf Hemmecke wrote (typo corrected):
> >> If we have
> >>
> >> define MyMonoid: Category == with {
> >>    1: %;
> >>    *: (%, %) -> %;
> >>    power: (%, Integer) -> %;
> >> }
> >>
> >> -- and (now fancy notation with renaming)
> >>
> >> define MyTimesPlus: Category == with {
> >>    MyMonoid;
> >>    MyMonoid where {
> >>      0: % == 1;
> >>      +: (%, %) -> % == *;
> >>      ntimes: (%, Integer) -> % == power;
> >>    }
> >> }
You clarified:
> I've just "invented" this syntax for the purpose of renaming. Don't take
> it to serious.
> 
> [snipped] ... in my code the
> "MyMonoid where {...}" would be the second monoid structure.
  [snipped] 
> Yes, it looks like a default, but it isn't. Or better, it was not
> intended to be like default.
>

Ok, thanks for the clarrification. I see you are really defining an algebraic
structure with two monoid substructure, one using (*, 1, power) and the other
(+, 0, ntimes) and you are making a renaming of the second to conform to the
single rigid MyMonoid declarations. The key is the new use of "where" which
instructs the compiler to perform, hopefully, the isomorphism mechanism I
described previously. But I think your construction probably would not work. In
particular, the domain constructor for an MyTimesPlus object would have to
specify the '(*, 1, power)' of the second 'MyMonoid': the forced definition for
'(+,0, ntimes)' can only make sense AFTER '(*, 1, power)' is defined for the
second 'MyMonoid' structure, since that is only a notational substitution
device.

The alternative, as suggested along the lines by Martin would be:

 define MyTimesPlus2: Category == with {
    MyMonoid;
    0: %
    +: (%,%)->%
    ntimes: (%, Integer) -> %
    MyMonoid where {
      1 == 0;
      *: (%, %) -> % == +;
      power: (%, Integer) -> % == ntimes;
    }
 }

This effectively passes the structure maps for the second MyMonoid as parameters
(see SandBoxMonoid where Bill Page implemented similar code and where I made
some comments).

The "natural" thing for the change in code is, mathematically, "where" always
explains the notation. Here the second 'MyMonoid' demands the meaning of 1, *
and power.  However, as commented on SandBoxMonoid, this does not solve the
notation issue.

 
> >> Then MyTimesPlus has 6 different signatures.
> >> If one removes the line "ntimes" then it would be only 5 and "power"
> >> would correspond to the multiplication (or (more correctly) to the
> >> actual implementation of it in a corresponding domain).
> >>
> >> So, operator symbols and operator names agree as long as they are not
> >> renamed.
> >>
> >> And one could also build
> >>
> >> MyInteger1: MyTimesPlus == add {
> >>    Rep == Integer;
> >>    0: % == per 0;
> >>    1: % == per 1;
> >>    ...
> >> }

Here the definition of 0:% either overrides that given in 'MyTimesPlus' or
contradicts it, and will not give 'MyInteger1' the second 'MyMonoid' structure
with '(+,0,ntimes)'.

> >> MyInteger2: MyTimesPlus == add {
> >>    Rep == Integer;
> >>    0: % == per 1;
> >>    1: % == per 0;
> >>    (x: %) + (y: %): % == per (rep x * rep y);
> >>    (x: %) * (y: %): % == per (rep x + rep y);
> >>    ...
> >> }

Here also, the definitions for '(+, 0)' override the defaults or contradicts it.
The way it was in your version, you must somehow be able to tell the compiler
the definitions for '(*, 1, power)' for the second 'MyMonoid' structure. Without
two different identifiers for the two instances of 'MyMonid', you cannot even
package qualify the two '*', two '1' and the two 'power' maps in 'MyInteger2'.

> >> Now, clearly, it can easily be figured out what 0, 1, +, etc. mean if
> >> MyInteger1 or MyInteger2 is in scope.
> >
> > Depends. Most likely, MyInteger1 and MyInteger2 would have coercion to and from
> > Integer (to enable input).  Unless you type qualify the constants, it is not
> > clear what an interpreter would do.
> 
> No? Without coerce functions and without Integer in scope what would be
> the problem if the interpreter only sees MyInteger2?

The problems that I see appear way before 'MyInteger2' can be "in scope" because
of the overriding problems and 'MyInteger2' should not have compiled, in
principle. On the other hand, 'MyInteger2' may well compile by replacing
'MyTimesPlus' by 'MyTimesPlus2'. However, then we lost the notation, and the two
"*" and "1" must be package called, which unfortunately, is impossible because
there is no distinction between the two substructures (both are 'MyMonoid'
without parameters).

[premature discussions on scope snipped]
 
> I deliberately called it MyTimesPlus and not Ring!

Ok, problem at issue is not the Ring structure, but the dual monoid structures.
 
> The whole discussion came about since people (including me) wonder why
> an AbelianMonoid does not inherit from Monoid. If that design (and the
> reasons why it must be that way in Axiom) were explained better I think
> that would avoid lots of questions about that difference between
> mathematics and Axiom.

Agreed. I suppose it is left to us, through these discussions, to recover what
might have been in the minds of the original designers. 

> >> But let's continue with MyInteger1/2.
> >> If I now ask
> >>
> >> MyInteger1 has MyMonoid
> >>
> >> then that refers to the multiplicative structure. I have, however, to say
> >>
> >> macro MyAdditiveMonoidMacro == {
> >>    MyMonoid where {
> >>      0: % == 1;
> >>      +: (%, %) -> % == +;
> >>      ntimes: (%, Integer) -> % == power;
> >>    }
> >> }
> >> MyInteger1 has MyAdditiveMonoidMacro

> The syntax with the "where" is NOT Aldor. This is just an ad hoc syntax
> introduced by me. But without the macro one would have to use
> parentheses around the category (including the "where") since "has"
> binds higher than "where".

OK, I see you are attempting to use the macro to isolate the second 'MyMonoid'
structure from 'MyTimesPlus'.  This macro is in some sense the equivalent or
replacement for 'AbelianMonoid'. So there is not much advantage over the present
implementation, except that, if it works, we could have defined either as:

 define MyAbelianMonoid: Category == with {
    MyMonoid where {
      0:% == 1;
      +: (%, %) -> % == *;
      ntimes: (%, Integer) -> % == power;
    }
 }

or

 define MyAbelianMonoid2: Category == with {
    0: %
    +: (%,%)->%
    ntimes: (%, Integer) -> %
    MyMonoid where {
      1 == 0;
      *: (%, %) -> % == +;
      power: (%, Integer) -> % == ntimes;
    }
 }

in which cases, 'MyAbelianMonoid[2] has Monoid' would work, but the notation
still does not. In fact, even in the first case, the Interpreter will have to
parse + as in MyAbelianMonoid, then translates it to * of MyMonoid, where this *
is implemented in MyAdditiveInteger as a mangled +. All these overhead, for
what? Would this have been simpler the way it currently is?

The real problem is how to ask 'MyInteger2 has MyMonoid(+,0,ntimes)' and without
the parameters and get an affirmative answer. That problem still has not been
solved (except as currently in Axiom).

\start
Date: Thu, 09 Mar 2006 14:27:10 -0500
From: William Sit
To: Martin Rubey, Bill Page, Ralf Hemmecke
Subject: Re: BINGO,Curiosities with Axiom mathematical structures

Martin:

Good work (I'm impressed :-). I think your solution is in fact the way
mathematicians build up algebraic structures: first define the underlying set
and the basic operations, then prove that the axioms of certain algebraic
structure are satisfied. Here you declare (rather than prove) these using
Aldor's 'extend' mechanism.

The beauty of your solution is that the notation (naming of the operations) is
defined in the domain itself and then the algebraic properties declared by
extension.

The slight disadvantage is that these structural operations must be listed with
each domain, and there is no default way (yet). So perhaps in MyMonoid, with
parameters, there can be a default syntax, such as:

  MyMonoid(T:Type, default{*:(T,T)->T)}):Category
  MyDualMonoid(T:Type, default{*:(T,T)->T, o:(T,T)->T}):Category ==
    with{MyMonoid(T); MyMonoid(T, o)};
  MyAbelianMonoid(T:Type, default{+:(T,T)->T}):Category ==
    with{commutative(+); MyMonoid(T, +), ...};
  MyRing(T:Type, default{*:(T,T)->T, +:(T,T)->T}:Category ==
    with{MyAbelianMonoid(T), MyMonoid(T), ...};
  MyCommutativeRing(T:Type, default{*:(T,T)->T, +:(T,T)->T}:Category ==
    with{MyAbelianMonoid(T), MyAbelianMonoid(T,*), ...};

(the above omits the units for the operations, which could be added easily) so
that 

  extend MyInteger: MyRing(MyInteger) == add;

would make sense.

\start
Date: Thu, 9 Mar 2006 16:21:41 -0500
From: Bill Page
To: Martin Rubey
Subject: RE: BINGO, Curiosities with Axiom mathematical structures

Martin,

I think you have a rather beautiful idea... but I see some
problems.

On March 9, 2006 11:08 AM you wrote:
> 
> I am satisfied now:
> -----------------
> #include "axiom"
> 
> MyMonoid(T: Type, m: (T, T) -> T): Category == with {
>    square: T-> T;
>    default {square(t: T): T == m(t, t)}
> }

This definition of the category MyMonoid looks quite strange
because it does not export any binary operation!

Also, I think you should write:

   square: % -> %;
   default {square(t: %): % == m(t pretend T, t pretend T) pretend %

although apparently the compiler does not worry about this since
your representation of the domain MyWord below is the same as the
operation that you pass to MyMonoid.

> 
> MyWord: with { 
>    coerce: String -> %;
>    c:(%, %) -> %
> }
>    == add {
>    Rep == String;
>    import from String;
>    coerce(a: String): % == per(a);
>    c(a: %, b: %):%  == coerce(concat(rep(a), rep(b))$String) }
> 
> import from MyWord;
> extend MyWord: MyMonoid(MyWord, c) == add;
> -----------------
> 

The exported binary operation that we normally think of as
belonging to the monoid, had to be declared in the definition
of this domain. This does not see right.

We could define it like this:

MyMonoid(T: Type, m: (T, T) -> T): Category == with {
   * : (%,%) -> %;
   square: %-> %;
   default {
     (x:%)*(y:%):% == m(x pretend T, y pretend T) pretend %;
     square(t: %): % == m(t pretend T, t pretend T) pretend %
   }
}

MyWord: with { 
   coerce: String -> %;
}
   == add {
   Rep == String;
   coerce(a: String): % == per(a);
}

import from MyWord;
extend MyWord: MyMonoid(String, concat$String) == add;

-----------

But then we have fixed the symbol * to denote the monoid operation.
This was something we were trying to avoid, right?

\start
Date: Thu, 09 Mar 2006 23:30:46 +0100
From: Ralf Hemmecke
To: Martin Rubey
Subject: Re: Curiosities with Axiom mathematical structures

On 03/09/2006 03:46 PM, Martin Rubey wrote:
> I wouldn't want to ask "Integer has Monoid", since this doesn't make any sense
> to me. I'd like to ask "Integer has Monoid(Integer, *)" or 
> "Integer has Monoid(*)"

Well, if one interprets Monoid as the category of monoids then

   Integer has Monoid

just say that the integers (now the question is whether you mean the 
integers with the additive or the multiplicative structure) are an 
object in the category of monoids.

Integer is a name for a structure with carrier set

{0, 1, -1, 2, -2, ...}

and operations {+, *, 0, 1, ...}.

Integer is certainly not the carrier set alone.
How would you mathematically express that the integers belong to the 
category of monoids? You would probably say that

F(Integer) is an object in the category of monoids

where F is a functor from the category of rings (or rather the category 
in which Integer really lives) that forgets every extra structure of a 
ring an just selects a monoid structure. Yes, the functor F decides 
whether you mean the additive or the multiplicative structure.

I hope, some category experts correct me, if I am wrong. I'm not so 
fluent in that language.

Anyway there is clearly something missing in the "has" construction if 
that would have to be written mathematically.

>> Simply think of a category Foo with hundreds of exported function, would you
>> like to write
>>
>>    Dom has Foo(f1, f2, ..., f100)
> 
> no, but wait a moment: It is obvious to me that I don't want to have all
> exported functions as parameters. Only certain "defining" functions, like:
> 
> Integer has Monoid(*, 1);
> Integer has Ring(+, *, 1);
> 
> Can you think of an example where more than, say 5, parameters would be desirable?

A partial differential ring (0,1,+,*) with n derivations. ;-) But maybe 
you prefer k automorphisms in order to get a difference algebra.

\start
Date: Thu, 09 Mar 2006 23:30:53 +0100
From: Ralf Hemmecke
To: William Sit
Subject: Re: Curiosities with Axiom mathematical structures

On 03/09/2006 06:17 PM, William Sit wrote:
> Hi Ralf:
> 
> Earlier, Ralf Hemmecke wrote (typo corrected):
>>>> If we have
>>>>
>>>> define MyMonoid: Category == with {
>>>>    1: %;
>>>>    *: (%, %) -> %;
>>>>    power: (%, Integer) -> %;
>>>> }
>>>>
>>>> -- and (now fancy notation with renaming)
>>>>
>>>> define MyTimesPlus: Category == with {
>>>>    MyMonoid;
>>>>    MyMonoid where {
>>>>      0: % == 1;
>>>>      +: (%, %) -> % == *;
>>>>      ntimes: (%, Integer) -> % == power;
>>>>    }
>>>> }
> You clarified:
>> I've just "invented" this syntax for the purpose of renaming. Don't take
>> it to serious.
>>
>> [snipped] ... in my code the
>> "MyMonoid where {...}" would be the second monoid structure.
>   [snipped] 
>> Yes, it looks like a default, but it isn't. Or better, it was not
>> intended to be like default.

> Ok, thanks for the clarrification. I see you are really defining an algebraic
> structure with two monoid substructure, one using (*, 1, power) and the other
> (+, 0, ntimes) and you are making a renaming of the second to conform to the
> single rigid MyMonoid declarations. The key is the new use of "where" which
> instructs the compiler to perform, hopefully, the isomorphism mechanism I
> described previously. But I think your construction probably would not work. In
> particular, the domain constructor for an MyTimesPlus object would have to
> specify the '(*, 1, power)' of the second 'MyMonoid': the forced definition for
> '(+,0, ntimes)' can only make sense AFTER '(*, 1, power)' is defined for the
> second 'MyMonoid' structure, since that is only a notational substitution
> device.

> The alternative, as suggested along the lines by Martin would be:
> 
>  define MyTimesPlus2: Category == with {
>     MyMonoid;
>     0: %
>     +: (%,%)->%
>     ntimes: (%, Integer) -> %
>     MyMonoid where {
>       1 == 0;
>       *: (%, %) -> % == +;
>       power: (%, Integer) -> % == ntimes;
>     }
>  }

Well, it seems that my "where" invention was not explained clearly 
enough. What I meant by

   MyMonoid where {
     0: % == 1;
     +: (%, %) -> % == *;
     ntimes: (%, Integer) -> % == power;
   }

was that this construct actually defines a category that exports
     0: %;
     +: (%, %) -> %;
     ntimes: (%, Integer) -> %;
and at the same time declares those functions to be just other names for
1, *, and power in the structure MyMonoid. It all boils down to 
declaring a category

   with {
     0: %;
     +: (%, %) -> %;
     ntimes: (%, Integer) -> %;
   }

but somehow with the name MyMonoid attached to it. Or saying it in 
another way. It is like defining MultiplicativeMonoid and AdditiveMonoid 
  and giving them the same name MyMonoid. I don't anymore think that 
such "renaming" has much advantage. (However, I was not so convinced 
before the discussion started.)

BTW, in my "where" syntax I though quite a bit whether I should write

   + == *

or

   * == +

Unfortunately, my choice led you to think it is a category default.

>>>> Then MyTimesPlus has 6 different signatures.
>>>> If one removes the line "ntimes" then it would be only 5 and "power"
>>>> would correspond to the multiplication (or (more correctly) to the
>>>> actual implementation of it in a corresponding domain).

Hmm, I thought that explanation would have been enough to explain my 
"funny syntax". Sorry for all the confusion.

>>>> So, operator symbols and operator names agree as long as they are not
>>>> renamed.
>>>>
>>>> And one could also build
>>>>
>>>> MyInteger1: MyTimesPlus == add {
>>>>    Rep == Integer;
>>>>    0: % == per 0;
>>>>    1: % == per 1;
>>>>    ...
>>>> }
> 
> Here the definition of 0:% either overrides that given in 'MyTimesPlus' or
> contradicts it,

Neither of them, since there is NO category default in MyTimesPlus, 
MyInteger1 **must** implement all 6 signatures.

>> The whole discussion came about since people (including me) wonder why
>> an AbelianMonoid does not inherit from Monoid. If that design (and the
>> reasons why it must be that way in Axiom) were explained better I think
>> that would avoid lots of questions about that difference between
>> mathematics and Axiom.
> 
> Agreed. I suppose it is left to us, through these discussions, to recover what
> might have been in the minds of the original designers. 

Oh, now I am a bit puzzled. Didn't I read the name "William Sit" on one 
the first pages of the original Axiom book (by Jenks&Sutor)? I always 
thought you are one of the designers. No?

\start
Date: Fri, 10 Mar 2006 00:24:20 -0500
From: William Sit
To: Bill Page
Subject: Re: BINGO,Curiosities with Axiom mathematical structures

Bill Page wrote:
> 
> Martin,
> 
> I think you have a rather beautiful idea... but I see some
> problems.
> 
> On March 9, 2006 11:08 AM you wrote:
> >
> > I am satisfied now:
> > -----------------
> > #include "axiom"
> >
> > MyMonoid(T: Type, m: (T, T) -> T): Category == with {
> >    square: T-> T;
> >    default {square(t: T): T == m(t, t)}
> > }
> 
> This definition of the category MyMonoid looks quite strange
> because it does not export any binary operation!

Correct, but if the goal is to allow the domains to define the
notations for the structure operations, then the domain must export
it. The category would have no way to know.
 

> The exported binary operation that we normally think of as
> belonging to the monoid, had to be declared in the definition
> of this domain. This does not see right.
> We could define it like this:
> 
> MyMonoid(T: Type, m: (T, T) -> T): Category == with {
>    * : (%,%) -> %;
>    square: %-> %;
>    default {
>      (x:%)*(y:%):% == m(x pretend T, y pretend T) pretend %;
>      square(t: %): % == m(t pretend T, t pretend T) pretend %
>    }
> }

This, in fact, is exactly what Axiom now have, except for the fact
that both T and m are anonymous and implicitly mapped to % and * when
one writes:

    Word: Monoid == ...

In your code above, there is no explicit relation between T and %, the
code x pretend T may or may not work.

> MyWord: with {
>    coerce: String -> %;
> }
>    == add {
>    Rep == String;
>    coerce(a: String): % == per(a);
> }
> 
> import from MyWord;
> extend MyWord: MyMonoid(String, concat$String) == add;
> 
This illustrates my comment above. The Rep == String (or Rep:=String) is not
visible externally, and hence your extend statement may have a problem.

> But then we have fixed the symbol * to denote the monoid operation.
> This was something we were trying to avoid, right?

That is right. But you can't have both (at least, we haven't found a
way and it seems very unlikely given the current compiler restraints),
and this is why the exports must come from the domain, unless some
default notation is chosen in the category itself.

\start
Date: Fri, 10 Mar 2006 00:40:12 -0500
From: Bill Page
To: Ralf Hemmecke
Subject: RE: Curiosities with Axiom mathematical structures

On March 9, 2006 5:31 PM Ralf Hemmecke wrote:
> 
> On 03/09/2006 03:46 PM, Martin Rubey wrote:
> > I wouldn't want to ask "Integer has Monoid", since this 
> > doesn't make any sense to me. I'd like to ask "Integer
> > has Monoid(Integer, *)" or "Integer has Monoid(*)"
> ... 
> How would you mathematically express that the integers belong
> to the category of monoids? You would probably say that
> 
> F(Integer) is an object in the category of monoids
> 
> where F is a functor from the category of rings (or rather the
> category in which Integer really lives) that forgets every
> extra structure of a ring an just selects a monoid structure.
> Yes, the functor F decides whether you mean the additive or the
> multiplicative structure.
> 
> I hope, some category experts correct me, if I am wrong. I'm not
> so fluent in that language.
>

I think your description is correct.
 
> Anyway there is clearly something missing in the "has" 
> construction if that would have to be written mathematically.
> 

I agree with Martin. One should interpret:

  if Integer has Monoid(*,1)

as the question of whether F = (*,1) is a functor from the category
containing Integer to Monoid, the category of monoids.

Axiom/Aldor language constraints require us to write

  Integer has Monoid(Integer,*,1)

Martin has suggested a method using 'extend' in Aldor to make
such an assertion by:

  extend Integer: Monoid(Integer,+,1)

where Monoid is the category:

  Monoid(T:Type,m:(T,T)->,u:T): category == with { }
  ++ m(m(a,b),c) = m(a,m(b,c)) and m(a,u)=a and m(u,a)=a
  ++ for all a,b,c in T

and of course it is up to the programmer to verify that the
axioms are satisfied.

It is also possible to write a domain constructor such that
MonoidDomain(Integer,+,1) is a Monoid.

In the current version of Axiom with the Aldor interface installed
the 'extend' construct works for domains written in Aldor but not
for Axiom domains written in SPAD such as Integer above. This is
a known bug in the Aldor interface mentioned by Peter Broadbery
several months ago.

\start
Date: Fri, 10 Mar 2006 00:43:04 -0500
From: William Sit
To: Ralf Hemmecke
Subject: Re: Curiosities with Axiom mathematical structures

Ralf Hemmecke wrote:
> 
> On 03/09/2006 03:46 PM, Martin Rubey wrote:
> > I wouldn't want to ask "Integer has Monoid", since this doesn't make any sense
> > to me. I'd like to ask "Integer has Monoid(Integer, *)" or
> > "Integer has Monoid(*)"
> 
> Well, if one interprets Monoid as the category of monoids then
> 
>    Integer has Monoid
> 
> just say that the integers (now the question is whether you mean the
> integers with the additive or the multiplicative structure) are an
> object in the category of monoids.
> 
> Integer is a name for a structure with carrier set
> 
> {0, 1, -1, 2, -2, ...}
> 
> and operations {+, *, 0, 1, ...}.
> 
> Integer is certainly not the carrier set alone.
> How would you mathematically express that the integers belong to the
> category of monoids? You would probably say that
> 
> F(Integer) is an object in the category of monoids
> 
> where F is a functor from the category of rings (or rather the category
> in which Integer really lives) that forgets every extra structure of a
> ring an just selects a monoid structure. Yes, the functor F decides
> whether you mean the additive or the multiplicative structure.
> 
> I hope, some category experts correct me, if I am wrong. I'm not so
> fluent in that language.

You are right.
 
> Anyway there is clearly something missing in the "has" construction if
> that would have to be written mathematically.


Not really (other than documentation). "has Monoid" means the domain has
implemented a Monoid structure according to the default notation, using * for
the monoid operation. It may not be what you like. You can clearly define a
MaxMonoid or an AddMonoid using other operators. To do this with parametrized
operator, as we learn in these discussions, is not easy. "has" also allows
something like "has Monoid(*,1)" if Monoid(*,1) were a category constructor.
 
[snipped]

> > Can you think of an example where more than, say 5, parameters would be desirable?
> 
> A partial differential ring (0,1,+,*) with n derivations. ;-) But maybe
> you prefer k automorphisms in order to get a difference algebra.

Ralf, I don't know you are interested in differential and difference algebra!
Other examples would be a Hopf algebra, and may be a sheaf or scheme. I agree
with you that we shouldn't have to tag along the notations if they are
"standard" (that is, if they are the default ones).
 
\start
Date: Fri, 10 Mar 2006 01:02:26 -0500
From: William Sit
To: Ralf Hemmecke
Subject: Re: Curiosities with Axiom mathematical structures

Ralf Hemmecke wrote:
> 
> Well, it seems that my "where" invention was not explained clearly
> enough. What I meant by
> 
>    MyMonoid where {
>      0: % == 1;
>      +: (%, %) -> % == *;
>      ntimes: (%, Integer) -> % == power;
>    }
> 
> was that this construct actually defines a category that exports
>      0: %;
>      +: (%, %) -> %;
>      ntimes: (%, Integer) -> %;
> and at the same time declares those functions to be just other names for
> 1, *, and power in the structure MyMonoid. It all boils down to
> declaring a category
> 
>    with {
>      0: %;
>      +: (%, %) -> %;
>      ntimes: (%, Integer) -> %;
>    }
> 
> but somehow with the name MyMonoid attached to it. Or saying it in
> another way. It is like defining MultiplicativeMonoid and AdditiveMonoid
>   and giving them the same name MyMonoid. I don't anymore think that
> such "renaming" has much advantage. (However, I was not so convinced
> before the discussion started.)
> 
> BTW, in my "where" syntax I though quite a bit whether I should write
> 
>    + == *
> 
> or
> 
>    * == +
> 
> Unfortunately, my choice led you to think it is a category default.

I was just following Aldor syntax, not knowing you were inventing something new.
So it is all "clear" now :-).
 
> Oh, now I am a bit puzzled. Didn't I read the name "William Sit" on one
> the first pages of the original Axiom book (by Jenks&Sutor)? I always
> thought you are one of the designers. No?
> 

I must then correct your wrong impression. I came to Axiom quite late in the
game, around 1987-88, when spad was running on an IBM 360 (or may be it was
7090) in 16MB memory space. Later that moved to the RT. Spad was well developed
by then Steven Watts was already working on the Aldor compiler (called A#). The
designers were no longer fixing spad compiler bugs (unless it is really
serious).

My name got into the Axiom book through the generosity of the authors (Robert
Sutor and Richard Jenks). I made only a few pages of contribution on ordinary
differential polynomial rings in the book. So, I am only an Axiom user (and a
limited one at that).

\start
Date: 10 Mar 2006 09:53:32 +0100
From: Martin Rubey
To: Martin Rubey
Subject: Re: BINGO, Curiosities with Axiom mathematical structures

Dear all,

as Ralf pointed out to me, my construction does have a problem in current Aldor:

-------------------------------------------------------------------------------

#include "axiom"

MyMonoid(T: Type, m: (T, T) -> T): Category == with {
   monoidSquare: T-> T;
   default {monoidSquare(t: T): T == m(t, t)}
}

MyWord: with { 
   coerce: String -> %;
   c:(%, %) -> %;
   d:(%, %) -> %
}
   == add {
   Rep == String;
   import from String;
   coerce(a: String): % == per(a);
   c(a: %, b: %):%  == coerce(concat(rep(a), rep(b))$String);
   d(a: %, b: %):%  == a }

import from MyWord;
extend MyWord: MyMonoid(MyWord, c) == add;

-------------------------------------------------------------------------------

(3) -> MyWord has MyMonoid(MyWord, c)

   (3)  true

(4) -> MyWord has MyMonoid(MyWord, d)

   (4)  true

-------------------------------------------------------------------------------

Unfortunately, this messes everything up. However, I think that this problem
should be correctable.

There is a related, more serious problem, I overlooked, namely with multiple
inheritance. To make things clearer, I continue the example from above -- even
though it does not work the way I intended.

-------------------------------------------------------------------------------

MyInteger: Category == with {
   +: (%, %) -> %;
   *: (%, %) -> %;
} == add { bla bla 
}

   (a: %) ^ (b: NonNegativeInteger): % == monoidPower(a, b }

import from MyInteger;
extend MyInteger: MyMonoid(MyInteger, +) with {   
  double: % -> %; }
== add {
  double(a:%): % == monoidSquare(a); }

extend MyInteger: MyMonoid(MyInteger, +) with {   
  square: % -> %; }
== add {
  square(a:%): % == monoidSquare(a); }


-------------------------------------------------------------------------------

The good news: we do have our natural notation back. Instead of "double", we
would have "*", instead of "square" we would have "^" and instead of
"monoidSquare" we would have "monoidPower" in real life, of course. I.e., in
the base category, names of derived operations would have to be generic, since
the will be available in all domains that stem from this category, and it would
be very strange to have some additive structure, but having to use "square" for
doubling. I think the name "monoidSquare" is just good enough, although one
could maybe think of a better name.

Now the (very) bad news (indeed):

Since MyInteger is derived from MyMonoid, "monoidSquare" will be available. But
what will it do? Well, in fact, this construction is not even allowed
currently:

Bottom of Page 120 of the Aldor User Guide says:

-------------------------------------------------------------------------------

  If two extensions have intersecting categories, then they may not be imported
  in the same scope.

-------------------------------------------------------------------------------

I do have an idea, but this will obviously involve changes in the
language. What I'm thinking of is as follows. Instead of having to extend the
domain, we should be allowed to write:

-------------------------------------------------------------------------------
MyWord: with { 
   coerce: String -> %;
   c:(%, %) -> %;
   d:(%, %) -> %;
   MyMonoid(%, c)
}
   ==  add {
   Rep == String;
   import from String;
   coerce(a: String): % == per(a);
   c(a: %, b: %):%  == coerce(concat(rep(a), rep(b))$String);
   d(a: %, b: %):%  == a }
-------------------------------------------------------------------------------

Currently this yields: 
  Compiler bug...Bug: gen0Syme:  syme unallocated by gen0Vars

Finally, if we have two colliding signatures, none of them should be exported
"directly". i.e, given

-------------------------------------------------------------------------------
MyStruc: with { 
   coerce: String -> %;
   c:(%, %) -> %;
   d:(%, %) -> %;
   MyMonoid(%, c);
   MyMonoid(%, d)
}
-------------------------------------------------------------------------------

monoidSquare(x)$MyStruc 

would yield an error. Instead, 

if MyStruc has MyMonoid(MyStruc, c) then 
  newop(a:%):% == monoidSquare(a)

would work, and yield the monoidSquare from MyMonoid(MyStruc, c).


(In fact, I do believe that similar problems would arise if we were to follow
Nicolas Doye.)

\start
Date: Fri, 10 Mar 2006 00:39:47 +0100
From: Ralf Hemmecke
To: William Sit
Subject: Re: BINGO, Curiosities with Axiom mathematical structures
Cc: Bill Page

On 03/09/2006 08:27 PM, William Sit wrote:
> Martin:
> 
> Good work (I'm impressed :-).

Sorry, but I am not so much. I've already pointed out one problem in my 
last mail and Bill saw another.

> I think your solution is in fact the way
> mathematicians build up algebraic structures: first define the underlying set
> and the basic operations, then prove that the axioms of certain algebraic
> structure are satisfied. Here you declare (rather than prove) these using
> Aldor's 'extend' mechanism.

OK, that is why "extend" is so great. But look at

define MyMonoid(T: Type, m: (T, T) -> T): Category == with {
     square: T-> T;
     default {square(t: T): T == m(t, t)}
}

(Didn't I write that?)

If you define

extend DomA: MyMonoid(DomA, f) == add;

then f must already be an operation in the exports of DomA. Well, we can 
do this.

define CatA: Category == with {
   f: (%, %) -> %;
}
DomA: CatA == add {f(x: %, y: %): % == ...}

Now we can extend DomA by MyMonoid(DomA, f$DomA).

Then DomA has the exports
   f: (%, %) -> %;
   square: DomA -> DomA;
That is a bit funny, because the type of DomA involves DomA.

> The beauty of your solution is that the notation (naming of the operations) is
> defined in the domain itself and then the algebraic properties declared by
> extension.

> The slight disadvantage is that these structural operations must be listed with
> each domain, and there is no default way (yet). So perhaps in MyMonoid, with
> parameters, there can be a default syntax, such as:

>   MyMonoid(T:Type, default{*:(T,T)->T)}):Category

Well, did you forget "== with;" here?

>   MyDualMonoid(T:Type, default{*:(T,T)->T, o:(T,T)->T}):Category ==
>     with{MyMonoid(T); MyMonoid(T, o)};

That does not look bad, but it will not work as expected if you used 
"Category". If you later declare something of type MyDualMonoid(..) it 
will only export two more symbols that can be checked through "has", 
namely "MyDualMonoid" and "MyMonoid". But see my last BINGO mail.
There must be another mechanism to achieve the desired behaviour. Via 
categories that does not work.

>   MyAbelianMonoid(T:Type, default{+:(T,T)->T}):Category ==
>     with{commutative(+); MyMonoid(T, +), ...};

Oh, "commutative(+)" is not declared. Aldor does not allow such 
attributes. "commutative(+)" must be a category. And since one cannot 
specify + without giving it a type, one would have to write something 
like "commutative(T, +)".

>   MyRing(T:Type, default{*:(T,T)->T, +:(T,T)->T}:Category ==
>     with{MyAbelianMonoid(T), MyMonoid(T), ...};
>   MyCommutativeRing(T:Type, default{*:(T,T)->T, +:(T,T)->T}:Category ==
>     with{MyAbelianMonoid(T), MyAbelianMonoid(T,*), ...};

> (the above omits the units for the operations, which could be added easily) so
> that 
> 
>   extend MyInteger: MyRing(MyInteger) == add;
> 
> would make sense.

Anyway, to me this all looks like specifying properties through tags.
We should, maybe rather write

   MyMonoid(T:Type, default{*:(T,T)->T)}): Property == properties;
    MyDualMonoid(T:Type, default{*:(T,T)->T, o:(T,T)->T}):Property ==
      properties{MyMonoid(T); MyMonoid(T, o)};

where I have just replaced Category by Property and "with" by "properties".

But all this is unsatisfactory, since if Aldor should allow properties, 
I would rather prefer to write some predicate logic formula than just 
declaring names for the properties.

Maybe adding the ability to Aldor to express properties by logical 
formulas that could also be used by proof checkers, that would be some 
step forward.

\start
Date: Fri, 10 Mar 2006 13:29:47 +0100
From: Ralf Hemmecke
To: Martin Rubey
Subject: Re: BINGO, Curiosities with Axiom mathematical structures
Cc: Stephen Watt

Unfortunately, I've sent this mail only to Martin, so here it comes to 
axiom-developer together with an explanation of why there is this 
strange output.

(Well, that is my interpretation. I might be wrong so if anybody with 
more inside into the internals is on the list, feel free to correct me.)

Here you go...
---------------------------------------------------
On 03/09/2006 05:08 PM, Martin Rubey wrote:
 > I am satisfied now:

Believe me, you are not.

Unfortunately, my Axiom now gives me the error message

(1) -> Integer has MyMonoid(Integer, *)

    >> System error:
    Cannot open the file 
/home/hemmecke/software/Axiom/mnt/linux/aldor/lib/runtime.o.

,.. so I demonstrate it with pure Aldor.

Basically, if you replace "ArithmeticType" by "Ring" it should work with
   #include "axiom"
and inside Axiom.

-- mymonoid.as
#include "aldor"

MyMonoid(T: Type, m: (T, T) -> T): Category == with {
    square: T-> T;
    default {square(t: T): T == m(t, t)}
}

MyInteger: ArithmeticType == Integer add;
extend MyInteger: MyMonoid(MyInteger, *$MyInteger) == add;
extend Integer: MyMonoid(Integer, *$Integer) == add;
-- end mymonoid.as

--mymonoidtest.as
#include "aldor"
#include "aldorio"
#library MyMon "mymonoid.ao"
import from MyMon;
macro {
     Z == Integer;
     M == MyInteger;
}
main(): () == {
   stdout << "1: " << (Z has MyMonoid(Z, *$Z)) << newline;
   stdout << "2: " << (Z has MyMonoid(Z, +$Z)) << newline;
   stdout << "3: " << (M has MyMonoid(M, *$M)) << newline;
   stdout << "4: " << (M has MyMonoid(M, +$M)) << newline;
}
main();
--end mymonoidtest.as

Compile with

aldor -fo -fao mymonoid.as
aldor -grun -laldor mymonoidtest.as mymonoid.o

and try to explain the output.

1: T
2: T
3: T
4: T

It's clear, isn't it?

Ralf
---------------------------------------------------

OK, and now the explanation. One would like the output (T, F, T, F), rigth?

Now look at MyInteger. It has type

with {
   ArithmeticType; -- includes +, *, 0, 1
   MyMonoid(MyInteger, *$MyInteger);
}

Well, but MyMonoid is a **function**. So the type is (nearly)
with {
   ArithmeticType;
   square: MyInteger -> MyInteger;
   default {square(t: MyInteger): T == (*$MyInteger)(t, t)}
}

You see, the * is hidden behind the == sign. The actual exports are that 
of ArithmeticType together with "square". It should be clear that then
2 and 4 from above also return true.

HOWEVER, remove the line

   extend Integer: MyMonoid(Integer, *$Integer) == add;

and try to compile "aldor -fasy mymonoid.as". Then look at the generated 
"mymonoid.asy". Look at the exports of |MyInteger|. Under |domExports| 
right at the bottom of the file, we find

         (|Declare|
           %%
           (|Apply| |MyMonoid| |MyInteger| (|Qualify| * |MyInteger|))
           ((|default| . 1)
             (|symeNameCode| . 51482908)
             (|symeTypeCode| . 366734318)))

That's interesting. The compiler would have a way to tell
that "MyInteger has MyMonoid(MyInteger, +$MyInteger)" is false.

Can someone explain that compiler design?

Well, mathematically thinking, I would say that (T, T, T, T) is OK, 
since "MyMonoid(Z, +$Z)" stands for the value that MyMonoid gives when 
applied to the arguments Z and +. There would be no way to guess the 
arguments from the value.

Well, this discussion is getting more and more into the internals...
I hope we all learn from that.

\start
Date: Fri, 10 Mar 2006 08:10:47 -0500
From: William Sit
To: Ralf Hemmecke
Subject: Re: BINGO,Curiosities with Axiom mathematical structures
Cc: Bill Page

Ralf Hemmecke wrote:
> 
> On 03/09/2006 08:27 PM, William Sit wrote:
> > Martin:
> >
> > Good work (I'm impressed :-).
> 
> Sorry, but I am not so much. I've already pointed out one problem in my
> last mail and Bill saw another.

Those who are ignorant can be easily impressed!  (The earlier comment
was just a joke to Bill's remark that I can be easily "not impressed"
(from SandBoxMonoid)).

The more we discussed this, the more it showed how difficult it is to master
Axiom/Aldor and their limitations. But that was a very good learning and
humbling experience.

To me, Martin's find that:

>Bottom of Page 120 of the Aldor User Guide says:

>------------------------------------------------------------------------

> If two extensions have intersecting categories, then they may not be 
> imported in the same scope.
>------------------------------------------------------------------------

may just have "nailed the coffin". (But I am not sure I fullly understand that
line: what are "intersecting categories"?).


\start
Date: 10 Mar 2006 15:02:44 +0100
From: Martin Rubey
To: Ralf Hemmecke
Subject: Re: Curiosities with Axiom mathematical structures

Dear Ralf, *,

Ralf Hemmecke writes:

> On 03/09/2006 03:46 PM, Martin Rubey wrote:
> > I wouldn't want to ask "Integer has Monoid", since this doesn't make any sense
> > to me. I'd like to ask "Integer has Monoid(Integer, *)" or "Integer has
> > Monoid(*)"
> 
> Well, if one interprets Monoid as the category of monoids then
> 
>    Integer has Monoid
> 
> just say that the integers (now the question is whether you mean the integers
> with the additive or the multiplicative structure) are an object in the
> category of monoids.

There is a simple practical reason why I dislike the idea of asking just
"Integer has Monoid".

Imagine I'm programming a package, and I need that a parameter domain M is a
monoid, so that I can use the monoidal structure, for example for
multiplying. Well, then simply asking M has Monoid doesn't buy me anything,
since I won't be sure that M really is a Monoid with respect to "+".

Of course, usually that is not such a big problem, interesting software can be
written without. However, I find the limitation rather annoying.

Apart from that, thank you very much for your explanation of
MyMonoid(MyInteger, op) giving true for any op having the right signature.

Still I hope that this idea works out somehow. I believe that bringing logic
into play won't make the problem any easier, I think we should try to solve it
with as little modification of aldor as possible for the moment. And most
importantly, we should try to figure out the correct scheme. Maybe we can talk
about it at the workshop.

\start
Date: 10 Mar 2006 15:08:14 +0100
From: Martin Rubey
To: list
Subject: Axiom Workshop - Poster available

For those who still have not spotted the mail:

>From April 27 - April 29 there will be a Workshop on Axiom. We do have great
speakers, unfortunately there is not much audience so far. 

I'd like to encourage *everybody* to come.

Meanwhile a poster is available at

www.mat.univie.ac.at/~rubey/Poster.jpg

If you want a printed copy, please let me know as soon as possible - don't
forget to give me your postal address!

\start
Date: Fri, 10 Mar 2006 09:36:51 -0500
From: Doug Stewart
To: Martin Rubey
Subject: Re: Axiom Workshop - Poster available

Martin Rubey wrote:

>For those who still have not spotted the mail:
>
>>From April 27 - April 29 there will be a Workshop on Axiom. We do have great
>speakers, unfortunately there is not much audience so far. 
>
>I'd like to encourage *everybody* to come.
>
>Meanwhile a poster is available at
>
>www.mat.univie.ac.at/~rubey/Poster.jpg
>
>If you want a printed copy, please let me know as soon as possible - don't
>forget to give me your postal address!
>
I would love to come    but   it is a long walk from here.   :-(

\start
Date: Fri, 10 Mar 2006 12:20:36 -0500
From: Tim Daly
To: list
Subject: CATS and Maple test suite

INTRODUCTION --------------------------------------------------------

I've been working for some time to construct a Computer Algebra
Test Suite (CATS). The idea came about because it is clear that
there is a lack of time and attention on cross-platform testing.
We should have available a range of problems with associated
math theory and verified results that every computer algebra
system can use for testing purposes. To this end I've been 
collecting test suites from various computer algebra systems and
running them thru Axiom. The lastest collection is the Maple bug
list posted by Vladimir. 

Of course there is no common syntax and so one of the problems
is that every integral has to be hand-written to match the likely
semantics of the original. This is a time consuming effort.
Furthermore there is no general mechanism for collecting results
(although I have been looking at automating regression testing
in Axiom) so result collection and summary are also hand operations.
Nevertheless, the process has completed the first phase of testing
and I've attached some summary statistics. Detailed results will
be included with the next release of Axiom.

For the next phase I've built a special purpose version of Axiom
with instrumentation in all of the integration routines. I plan to
classify each integral and associate it with the code as part of
the literate documentation. This will give us a basis for finding
bugs and corner cases. It will also give us working regression
test cases.


BREAKDOWN OF RESULTS -------------------------------------------------

There were 4865 integrals tested. Of these

  *> (5     0.10%) Missing Functions
  *> (1206 24.78%) Undefined Special Functions or untranslated functions
  *> (84    1.72%) Mismatched signatures of existing functions
  *> (158   3.25%) Badly Behaved Integrals
  *> (7     0.14%) Axiom Internal Errors
  *> (279   5.73%) Risch Algorithm Boundary Cases
  *> (2331 47.91%) Failed results
  *> (490  10.07%) Successful Results
  *> (305   6.27%) Indeterminate Results

Of the 4865 integrals the first three cases would not run. That
leaves 3570 tests. Of these there were 3097 (73.38%) integrals 
that had a potential pole in the path of integration making them
rather more difficult to compute.

We further break down the results. The number in parentheses is
the number of integrals of this class. One observation is that a
large number of these integrals involve the signum function. Axiom
does not have an integrable form of this function. Frankly, I'm not
sure how to integrate functions involving signum. It is hardly a
surprise that Maple gets these wrong.

On some of the functions I've given example integrals that exhibit
the behavior of their category.

Axiom has a robust implementation of the Risch algorithm done by
Barry Trager and Manuel Bronstein. Still, there are some corner
cases that are not implemented. We collected these under a
separate category so they will be useful for people who want to
investigate extending the algorithms. It is hardly a surprise that
Maple finds these hard to do.

These tests have uncovered 3 internal errors involving a total of
6 of the integrals. These will be investigated and fixed in a future
release.

Testing continues on the results that did not complete. Raising the
maximum time limit to 10 minutes has generated additional results.


(5) MISSING FUNCTIONS ---------------------------------------------------

These are apparently bogus function names. 

  *> (1) f 
  *> (1) op
  *> (1) product
  *> (2) elt

(1206) UNDEFINED SPECIAL FUNCTIONS OR UNTRANSLATED FUNCTIONS ------------

Maple has these functios in different forms than Axiom. Some of the special
functions have equivalent Axiom representations but Maple is much stronger
in special functions. Axiom has single-argument forms of some of these
functions but the translations were not clear.


  *> (2) airyAi -- 2 argument form
  *> (1) airyBi -- 2 argument form
  *> (2) argument
  *> (57) atan -- 2 argument form
  *> (26) ceil 
  *> (2) chebyshevT -- with fractional first argument
  *> (1) chebyshevU -- with fractional first argument
  *> (5) conjugate
  *> (8) Chi
  *> (78) csgn 
  *> (19) Dirac
  *> (11) Ei
  *> (2) EllipticE 
  *> (9) EllipticK 
  *> (4) EllipticPi 
  *> (1) erfc 
  *> (23) floor
  *> (3) frac
  *> (30) FresnelC
  *> (3) Fresnelf
  *> (1) Fresnelg
  *> (26) FresnelS
  *> (3) GegenbauerC 
  *> (6) HankelH1
  *> (8) HankelH2 
  *> (22) Heaviside 
  *> (2) hermiteH -- with fractional first argument
  *> (1) hypergeom 
  *> (4) KelvinKei
  *> (4) KelvinKer 
  *> (4) KummerU 
  *> (3) LambertW 
  *> (2) legendreP -- having 3 arguments
  *> (4) LegendreQ 
  *> (15) LerchPhi 
  *> (2) MeijerG 
  *> (31) polylog 
  *> (34) Psi
  *> (1) Re 
  *> (1) RootOf 
  *> (25) round 
  *> (2) Shi 
  *> (3) Ssi 
  *> (669) signum
  *> (11) StruveH
  *> (10) StruveL 
  *> (12) trunc
  *> (13) Zeta 

(84) MISMATCHED SIGNATURES OF EXISTING FUNCTIONS ------------------------

Axiom's integration routines return a Union of several types. 
In order to use the result in various other operations one branch
of the Union needs to be chosen. I have not done that here so these
are listed as though they were special functions with a missing
signature.

  *> (1) +
  *> (7) *
  *> (1) /
  *> (1) log
  *> (73) integrate
  *> (1) abs


(158) BADLY BEHAVED INTEGRALS -------------------------------------------

  *> (158) integrate: pole in path of integration

integrate(legendreP(0, z)/(z^2+3*z), z= 0..3,"noPole")


(7) AXIOM INTERNAL ERRORS -----------------------------------------------


  *> (1) internal error

   >> Error detected within library code:
   (construct (= left 0) (= right 2))
   is not a valid isolation interval for
   (+ (+ (- (** ? 4)) (* 2 (** ? 2))) -1)

in961:=integrate(log(z-1)*z/(z^2-1)^2, z= 1..%plusInfinity)


  *> (4) Cannot take first of an empty list

integrate(sin(z)*csc(z)*(1-1/(%i*z)^(1/2))^(1/2), z= 0..1,"noPole")


  *> (2) The function * with signature hashcode is missing from domain 
         Polynomial(OrderedCompletion (Integer)) 

integrate(a^z, z= 0..I*%plusInfinity)
integrate((1*z-3)/(2+(0*z-4)^2), z= %minusInfinity..1+I*%plusInfinity)


(279) RISCH ALGORITHM BOUNDARY CASES ------------------------------------

  *> (3) PFO::possibleOrder: more than 1 algebraic constant

integrate(tan(z)/sqrt(sin(z+%pi/4)), z= 0..1,"noPole")


  *> (1) Not integrable (provided residues have no relations)

integrate(((z^3-1)/(1+z))^(1/2)/z^2, z= 1..%plusInfinity,"noPole")


  *> (35) integrate: implementation incomplete (non-algebraic residues)

integrate(-(1-(I*z)^(1/2)/(1-I*z))^(1/2), z= -1..1,"noPole")


  *> (177) integrate: implementation incomplete (constant residues)

integrate(sin(z)^2*(1+z^(1/2))^(1/2), z= 0..1,"noPole")


  *> (22) Imaginary part is nonzero. Cannot retract.

integrate(sqrt(sin(2*z))/sqrt(cos(2*z)),z)


  *> (29) Function not supported by Risch d.e.

integrate(exp(-I*(I*z)^(1/2))/abs(z)^2, z= 0..1,"noPole")


  *> (12) integrate: implementation incomplete (residue poly has multiple 
          non-linear factors)

integrate(tanh(z)^(4/3), z = -1..1,"noPole")


  *> (0) integralBasis: possible wild ramification


(2331) FAILED RESULTS --------------------------------------------------

  *> (2033) "failed"

integrate(log(2-z^2)/(1-z^3), z= 0..1)


  *> (56) Sorry - cannot handle that integrand yet

integrate(erf((I*z)^(1/3)), z= -1..1,"noPole")


  *> (242) failed - cannot handle that integrand

integrate(sin(1/z)+(1-1/z^4)^(1/2), z= 0..%pi,"noPole")

(490) SUCCESSFUL RESULTS -----------------------------------------------

(305) INDETERMINATE RESULTS -------------------------------------------

There were some integrals that Axiom failed to complete given
the bounds on the allowed CPU time (about 10 minutes of execution).
Further effort will be applied to try to resolve these cases.

It may be that some portion of the integration algorithm either has
an infinite loop or has non-polynomial time behavior. We will attempt
to investigate both possibilities.

\start
Date: Fri, 10 Mar 2006 14:37:10 -0500
From: Tim Daly
To: Nicolas Neuss
Subject: Axiom with ANSI CL?

> as much as I understand, Axiom builds only with GCL.  Is this correct?  If
> yes, is there any intentions of making it into a ANSI CL library?  Does
> this make sense at all?

GCL is working on being ANSI compliant and there is work to try to port
Axiom to other CL implementations.

Axiom isn't really structured as a library although with some effort
I suppose it could be made into one. Unlike other computer algebra
systems Axiom is strongly dependent on it's type structure which
is associated with every result. A lisp call would have to know how
to carry this structure.

But Axiom is just a program implemented in common lisp (CLtL2) so
it is entirely possible to load lisp code into an Axiom image and
use it from there.

\start
Date: Fri, 10 Mar 2006 14:19:12 -0800 (PST)
From: Cliff Yapp
To: list, technical@nmconsortium.org
Subject: Numerical Mathematics Consortium first draft released

Is this something that could be relevant to the Axiom CAS?  I thought I
recalled seeing this mentioned once a while back but I can't recall
now.

http://www.nmconsortium.org/

\start
Date: Fri, 10 Mar 2006 18:50:01 -0500
From: Tim Daly
To: Cliff Yapp
Subject: Re: Numerical Mathematics Consortium first draft released
Cc: list, technical@nmconsortium.org

> Is this something that could be relevant to the Axiom CAS?  I thought I
> recalled seeing this mentioned once a while back but I can't recall
> now.

> http://www.nmconsortium.org/

I signed us up as a member last year but the paperwork seems to have
been lost (I just got email this week about it). I'm re-applying.

\start
Date: Sat, 11 Mar 2006 01:21:17 -0500
From: Bill Page
To: Ralf Hemmecke
Subject: re: BINGO,	Curiosities with Axiom mathematical structures
Cc: Stephen Watt

On March 10, 2006 7:30 AM Ralf Hemmecke wrote:
> ...
> extend MyInteger: MyMonoid(MyInteger, *$MyInteger) == add;
> ...
>    stdout << "1: " << (Z has MyMonoid(Z, *$Z)) << newline;
>    stdout << "2: " << (Z has MyMonoid(Z, +$Z)) << newline;
>    stdout << "3: " << (M has MyMonoid(M, *$M)) << newline;
>    stdout << "4: " << (M has MyMonoid(M, +$M)) << newline;
> ...
> and try to explain the output.
>
> 1: T
> 2: T
> 3: T
> 4: T
>
> ---------------------------------------------------
>
> OK, and now the explanation. One would like the output
> (T, F, T, F), rigth?
>
> Now look at MyInteger. It has type
>
> with {
>    ArithmeticType; -- includes +, *, 0, 1
>    MyMonoid(MyInteger, *$MyInteger);
> }
>
> Well, but MyMonoid is a **function**. So the type is (nearly)
> with {
>    ArithmeticType;
>    square: MyInteger -> MyInteger;
>    default {square(t: MyInteger): T == (*$MyInteger)(t, t)}
> }
>
> You see, the * is hidden behind the == sign. The actual exports
> are that of ArithmeticType together with "square". It should be
> clear that then 2 and 4 from above also return true.
>

Your explanation looks good but then I thought: What about those
categories in Axiom that take a member of some domain as a parameter.
If this parameter does not appear in any export of the category
then surely this same "error" would occur right?

Consider for example 'DirectProductCategory'

http://wiki.axiom-developer.org/axiom--test--1/src/algebra/VectorSpad/tan=
gle
?submit=tangle&chunk=category+DIRPCAT+DirectProductCategory

It's paramters are:

  DirectProductCategory(dim:NonNegativeInteger, R:Type)

but 'dim' does not appear in the signatures of the list of exports
as one can verify with:

  ')sh DIRPCAT

In fact 'dim' only to the right of the == some default functions
such as 'dimension' and 'size'.

One might predict using your analysis above that 'DIRPCAT(2,INT)'
and 'DIRPCAT(3,INT)' would be treated identically. But try this:

(1) -> DIRPROD(2,INT) has DIRPCAT(2,INT)

   (1)  true
   Type: Boolean

(2) -> DIRPROD(2,INT) has DIRPCAT(3,INT)

   (2)  false
   Type: Boolean

-------

How does Axiom know that (2) is false?

Could this have something to do with the way SPAD compiles categories
compared to Aldor?

\start
Date: 11 Mar 2006 09:33:52 +0100
From: Martin Rubey
To: Bill Page
Subject: re: BINGO, Curiosities with Axiom mathematical structures
Cc: Stephen Watt

Dear Bill, Ralf, *,

> Your explanation looks good but then I thought: What about those categories
> in Axiom that take a member of some domain as a parameter.  If this parameter
> does not appear in any export of the category then surely this same "error"
> would occur right?

Funny, I thought about the same thing just yesterday evening. So at *least*
this discussion was very educative!

I'd just like to restate what I'm looking for, since I have the feeling that we
might meanwhile talk about different purposes:

In the following "category" is reserved for the Axiom/Aldor meaning of the
word. I do not know much about the mathematical thing.

I'd like to have a category Monoid and a category Ring and say that Integer is
a Ring.

If I ask *something* like Integer has Monoid(+) I'd like to get true.
If I ask *something* like Integer has Monoid(*) I'd like to get true.
For other operations I'd like to get false.

I'd like that Integer has an operation double, that uses the monoidSquare from
Monoid(+), an operation square that uses the monoidSquare from Monoid(*). I
imagine that I would be able to define it somehow like

  double(a:%):% == monoidSquare(a)$Monoid(+)

I'd like that 

if X has Monoid(+) then op x := monoidSquare(x)$X

uses the operation monoidSquare from Monoid(+), if X inherits from
Monoid(+). Here it should use the implementation "just before there are two
identical signatures". For example, there could be a category derived from
Monoid called AbelianMonoid, with a default for "monoidSquare". Then the above
line should use the default from AbelianMonoid, if Integer is an AbelianMonoid.

Similarly for X has Monoid(*).

I think it would be best if monoidSquare would be unavailable in Integer, if
not qualified like monoidSquare(x)$Monoid(+) or as above. I would be happy also
if only the above form "if X has Monoid(+)"... would work.

\start
Date: Sun, 12 Mar 2006 14:55:41 -0500
From: Tim Daly
To: Bill Walster
Subject: Provisos generalize intervals.
Cc: list

Bill,

I've taken a step back and am reviewing Moore's book again in 
preparation for a deeper reading of your book.

It seems that the fundamental difference between the work that you and
Moore have pursued and the work I've been doing lies in the definition
of the endpoints of the intervals. Correct me if I'm wrong but it appears
that the endpoints of your intervals are all ordered numbers.

The endpoints of the intervals I'm looking at for provisos are not
numbers and, in most cases, are ordered by explicit constraints. My
work assumes that the endpoints can be pretty much anything, complex
numbers, vectors, symbols, polynomials, etc.

Thus I raise the question of intervals whose endpoints specify the 
inner and outer radius of two bounding surfaces. For example, the
inner and outer radius of two spheres or the upper and lower bounding
surfaces of a function during integration. This is useful symbolically
since if I can show that the two bounding surfaces tends to zero I can
conclude that the integral tends to zero even if the actual function
is too complex to compute.

Provisos generalize intervals.

\start
Date: 13 Mar 2006 03:45:25 +0100
From: Gabriel Dos Reis
To: list
Subject: Axiom build failure

  Before engaging another crazy week, I decided to build the latest
version of Axiom from CVS.  The build unfortunately failed with the
following: 


make[3]: *** No rule to make target `/home/gdr/src/axiom/int/algebra/ABELGRP.o', needed by `src'.  Stop.


rings bell to anyone?  What is the cure?


As an unrelated thing, I noticed the following warning

   fat_string.c: In function `fSprofile':
   fat_string.c:53: warning: null argument where non-null required (arg 1)

I have not investigated that portion of code yet.

PS: I'll answer all of you took time to send comments in the "curiosities" 
    thread. (probably not tonight) 

\start
Date: Sun, 12 Mar 2006 22:53:16 -0500
From: Tim Daly
To: Gabriel Dos Reis
Subject: Re: Axiom build failure

Gaby,

Did you stop and restart the build?
There is a bit of awk/sed hackage in the src/algebra Makefile
that fails under certain conditions if you stop and restart the build.
I'm not sure that's the problem but if you did do a restart then it's
a good guess.

\start
Date: 13 Mar 2006 04:21:55 +0100
From: Gabriel Dos Reis
To: Tim Daly
Subject: Re: Axiom build failure

Tim Daly writes:

| Gaby,
| 
| Did you stop and restart the build?

Ah yes.  I first started the build, then I instantly realized I forgot
to redirect the standard error stream to a file for post-build
analysis.  So I stopped the build and restarted it with the
appropriate redirection -- I did not anticipate that would cause a
problem later.

| There is a bit of awk/sed hackage in the src/algebra Makefile
| that fails under certain conditions if you stop and restart the build.
| I'm not sure that's the problem but if you did do a restart then it's
| a good guess.

I did a "make clean" but that did not solve it; is there a magic
formula to bring me back to buildville?

\start
Date: Mon, 13 Mar 2006 01:12:10 -0500
From: Tim Daly
To: Gabriel Dos Reis
Subject: Re: Axiom build failure

because of the awk-sed portion of the src/algebra/Makefile
(which make clean does not fix, though it should) you need
to remove the file by hand. there are 2 scripts, one is called
findSpadFiles and the other is called findBootstrapFiles.
these need to be removed after a make clean. the files 
are documented in the algebra Makefile.pamphlet file.

\start
Date: 13 Mar 2006 06:57:28 +0100
From: Gabriel Dos Reis
To: Tim Daly
Subject: Re: Axiom build failure

Tim Daly writes:

| because of the awk-sed portion of the src/algebra/Makefile
| (which make clean does not fix, though it should) you need
| to remove the file by hand. there are 2 scripts, one is called
| findSpadFiles and the other is called findBootstrapFiles.
| these need to be removed after a make clean. the files 
| are documented in the algebra Makefile.pamphlet file.

\start
Date: Mon, 13 Mar 2006 12:34:13 +0100
From: Ralf Hemmecke
To: Martin Rubey
Subject: Re: Curiosities with Axiom mathematical structures

Hi Martin,

a quick response to the following...

> There is a simple practical reason why I dislike the idea of asking just
> "Integer has Monoid".
> 
> Imagine I'm programming a package, and I need that a parameter domain M is a
> monoid, so that I can use the monoidal structure, for example for
> multiplying. Well, then simply asking M has Monoid doesn't buy me anything,
> since I won't be sure that M really is a Monoid with respect to "+".

Imagine you could ask "if M has Monoid(+)..." or "if M has 
Monoid(*)...". According to which returns true, you would then go on and 
call (m1 +$M m2) or (m1 *$M m2). Well, but M might have a monoid 
structure with respect to the operation ".". Do you really also want to 
ask "if M has Monoid(.)..."? That soon becomes impractical.

But here the question to our category theory experts:
Since Monoid is something like (*,1) would it make sense to speak of a 
category (in the mathematical sense) of

   monoids that have * and 1 as their operations                    (1)

? Morphisms would respect 1 not just the identity element with respect 
to *. And for each morphism f we would have f(a*b) = f(a)*f(b). Of 
course as operations the two * above are different but in that category 
they have to have the same name. (No idea whether this makes sense, but 
it seems that this is the way as "Category" it is implemented in 
Axiom/Aldor.)

Then, of course, (N, +, 0) is not an object in the category given by (1).

\start
Date: 13 Mar 2006 13:15:29 +0100
From: Martin Rubey
To: Ralf Hemmecke
Subject: Re: Curiosities with Axiom mathematical structures

Ralf Hemmecke writes:

> Hi Martin,
> 
> a quick response to the following...
> 
> > There is a simple practical reason why I dislike the idea of asking just
> > "Integer has Monoid".
> > Imagine I'm programming a package, and I need that a parameter domain M is a
> > monoid, so that I can use the monoidal structure, for example for
> > multiplying. Well, then simply asking M has Monoid doesn't buy me anything,
> > since I won't be sure that M really is a Monoid with respect to "+".
> 
> Imagine you could ask "if M has Monoid(+)..." or "if M has
> Monoid(*)...". According to which returns true, you would then go on and call
> (m1 +$M m2) or (m1 *$M m2). Well, but M might have a monoid structure with
> respect to the operation ".". Do you really also want to ask "if M has
> Monoid(.)..."? That soon becomes impractical.

No, this is not an issue about practicality.

Look at it this way: Suppose "M has Monoid" returns "true". How do you know
then with respect to which operation M is a monoid? What can you do with the
information that M is a monoid with respect to some operation?

\start
Date: Mon, 13 Mar 2006 14:24:28 +0100
From: Ralf Hemmecke
To: Martin Rubey
Subject: Re: Curiosities with Axiom mathematical structures

hi Martin,

On 03/13/2006 01:15 PM, Martin Rubey wrote:
> Ralf Hemmecke writes:
> 
>> Hi Martin,
>>
>> a quick response to the following...
>>
>>> There is a simple practical reason why I dislike the idea of asking just
>>> "Integer has Monoid".
>>> Imagine I'm programming a package, and I need that a parameter domain M is a
>>> monoid, so that I can use the monoidal structure, for example for
>>> multiplying. Well, then simply asking M has Monoid doesn't buy me anything,
>>> since I won't be sure that M really is a Monoid with respect to "+".
>> Imagine you could ask "if M has Monoid(+)..." or "if M has
>> Monoid(*)...". According to which returns true, you would then go on and call
>> (m1 +$M m2) or (m1 *$M m2). Well, but M might have a monoid structure with
>> respect to the operation ".". Do you really also want to ask "if M has
>> Monoid(.)..."? That soon becomes impractical.
> 
> No, this is not an issue about practicality.
> 
> Look at it this way: Suppose "M has Monoid" returns "true". How do you know
> then with respect to which operation M is a monoid? What can you do with the
> information that M is a monoid with respect to some operation?

If
   Monodid: Category == with{ 1:%; *:(%,%)->%; }
then "M has Monoid" means that M has a 1 and *.

By now, we all know that if "M has Monoid" returns false, it does NOT 
mean that M is not an object in the category of (mathematical) monoids.

It is as simple as this "Monoid" in Axiom does NOT stand for the 
category of all monoids.

\start
Date: Mon, 13 Mar 2006 14:33:34 +0100
From: Ralf Hemmecke
To: Bill Page
Subject: re: BINGO,Curiosities with Axiom mathematical
Cc: Stephen Watt

> Consider for example 'DirectProductCategory'
> 
> http://wiki.axiom-developer.org/axiom--test--1/src/algebra/VectorSpad/tangle
> ?submit=tangle&chunk=category+DIRPCAT+DirectProductCategory
> 
> It's paramters are:
> 
>   DirectProductCategory(dim:NonNegativeInteger, R:Type)
> 
> but 'dim' does not appear in the signatures of the list of exports
> as one can verify with:
> 
>   ')sh DIRPCAT
> 
> In fact 'dim' only to the right of the == some default functions
> such as 'dimension' and 'size'.
> 
> One might predict using your analysis above that 'DIRPCAT(2,INT)'
> and 'DIRPCAT(3,INT)' would be treated identically. But try this:
> 
> (1) -> DIRPROD(2,INT) has DIRPCAT(2,INT)
> 
>    (1)  true
>    Type: Boolean
> 
> (2) -> DIRPROD(2,INT) has DIRPCAT(3,INT)
> 
>    (2)  false
>    Type: Boolean
> 
> -------
> 
> How does Axiom know that (2) is false?

Because Axiom tries to be smart. It uses information it does not have.

And the behaviour above is not inherent to the interpreter. Otherwise 
the following function call "foo()" would not return "true+false".

Look further below and you find that dirprod.spad and dirprod.as are 
programs where the spad and the aldor compiler produce code with 
different semantics. TOO BAD!!!


-- begin dirprod.spad
)abbrev domain MYDOM MyDom
)abbrev category MYDPC DirProdCat
)abbrev domain MYDP DirProd

DirProdCat(n: Integer, R: Type): Category == with
   fst: % -> R


DirProd(n: Integer, R: Type): DirProdCat(n, R) == add
   Rep := List R -- dummy implementation
   fst(x: %): R == first(x pretend List(R))$List(R)

MyDom: with
   foo: () -> OutputForm
  == add
   foo(): OutputForm ==
     b2: Boolean := (DirProd(2, Integer) has _
       DirProdCat(2, Integer))
     b3: Boolean := (DirProd(2, Integer) has _
       DirProdCat(3, Integer))
     (b2::OutputForm) + (b3::OutputForm)
-- end dirprod.spad

Well, as I said at the bottom of my "explanation mail" 
http://lists.nongnu.org/archive/html/axiom-developer/2006-03/msg00097.html, 
  the information seems to be available also in a compiles Aldor 
library, but it is not used.

And in some way I would not really like it to be used, because then I 
would not understand the concept of a function application anymore.

So although the output of the following program might seem strange at 
first sight,

aldor -laldor -grun dirprod.as
2 has 2: T
2 has 3: T

it can be understood with my previous explanation.

If you look at DirProdCat as a function then clearly
   DirProdCat(2,Z) = DirProd(3,Z) = with{first:%->Z}
so why would one want another output?

----------- dirprod.as
#include "aldor"
#include "aldorio"

define DirProdCat(n: Integer, R: Type): Category == with {
   first: % -> R;
}

DirProd(n: Integer, R: Type): DirProdCat(n, R) == add {
   Rep == List R; -- dummy implementation
   import from Rep;
   first(x: %): R == first(rep x);
}

main(): () == {
   macro Z == Integer;
   macro DP == DirProd(2, Z);
   import from Z;
   stdout << "2 has 2: " << (DP has DirProdCat(2, Z)) << newline;
   stdout << "2 has 3: " << (DP has DirProdCat(3, Z)) << newline;
}

main();
--------end dirprod.as

\start
Date: Mon, 13 Mar 2006 10:50:23 -0500
From: Bill Page
To: Ralf Hemmecke
Subject: re: BINGO,	Curiosities with Axiom mathematical structures
Cc: Stephen Watt

On March 13, 2006 8:34 AM Ralf Hemmecke wrote:
> ...
> Bill Page wrote:
> >
> > (2) -> DIRPROD(2,INT) has DIRPCAT(3,INT)
> >
> >    (2)  false
> >    Type: Boolean
> >
> > -------
> >
> > How does Axiom know that (2) is false?
>
> Because Axiom tries to be smart. It uses information it does not
> have.

Perhaps you mean *should not have*. Obviously it does have this
information.

>
> And the behaviour above is not inherent to the interpreter.
> Otherwise the following function call "foo()" would not return
> "true+false".

Thanks for testing this.

>
> Look further below and you find that dirprod.spad and dirprod.as
> are programs where the spad and the aldor compiler produce code
> with different semantics. TOO BAD!!!
>

Hmmm... surely this must have been considered in the design of
Aldor. Are there no Aldor categories like DIRPCAT that take a
member of a domain as a parameter? This seems like a natural
mathematical construction to me.

> ...
> Well, as I said at the bottom of my "explanation mail"
http://lists.nongnu.org/archive/html/axiom-developer/2006-03/msg00097.htm=
l,
> the information seems to be available also in a compiles Aldor
> library, but it is not used.
>
> And in some way I would not really like it to be used, because
> then I would not understand the concept of a function application
> anymore.
>
> So although the output of the following program might seem strange
> at first sight,
>
>  aldor -laldor -grun dirprod.as
>  2 has 2: T
>  2 has 3: T
>
> it can be understood with my previous explanation.

I don't know what semantics to associate with the use of a member
of some domain on the right-hand side of 'has'. In Axiom I only
see

  if <domain> has <category>

In the Aldor documentation I have read a discussion of how a
domain is said to "satisfy" a category, but I do not know how
to apply this in your example above.

> If you look at DirProdCat as a function then clearly
>   DirProdCat(2,Z) = DirProd(3,Z) = with{first:%->Z}
> so why would one want another output?
>
> ----------- dirprod.as
> #include "aldor"
> #include "aldorio"
>
> define DirProdCat(n: Integer, R: Type): Category == with {
>    first: % -> R;
> }

Well, clearly the application of the category 'DIRPCAT(2,INT'
makes good sense in Axiom, don't you think? How else would you
propose to define this category? How could we do without it
in defining the domain 'DIRPROD(2,INT)'? To me this is the
reason why we want another output from your example Aldor
program. I would conclude that in fact internally (as you
already said above):

  DirProdCat(2,Z) ~= with{first:%->Z}

There must be something additional on the right-hand side
that is not reflected in the syntax of the category constant
'with' clause.

\start
Date: Mon, 13 Mar 2006 11:08:21 -0500
From: Bill Page
To: Ralf Hemmecke
Subject: RE: Curiosities with Axiom mathematical structures

On March 13, 2006 6:34 AM Ralf Hemmecke asked:
> ... 
> But here the question to our category theory experts:
> Since Monoid is something like (*,1) would it make sense
> to speak of a category (in the mathematical sense) of
> 
>    monoids that have * and 1 as their operations              
>       (1)
> 
> ? Morphisms would respect 1 not just the identity element 
> with respect to *. And for each morphism f we would have
> f(a*b) = f(a)*f(b). Of course as operations the two * above
> are different but in that category they have to have the same
> name. (No idea whether this makes sense, but it seems that
> this is the way as "Category" it is implemented in Axiom/Aldor.)
> 
> Then, of course, (N, +, 0) is not an object in the category 
> given by (1).
> 

I keep trying to answer these questions but I am not sure I
would like to classify myself as an "expert" in category theory.
:) But here goes ...

In category theory **Mon** (** means written in bold face font)
consists of all monoids (as objects) and all monoid homomorphisms
as morphisms. This does not say anything directly about what
operation are present "inside" the objects of the category. It
is one of the goals of category theory to define what we mean
by 'monoid' entirely in terms of the homomorphisms and perhaps
statements about the existence of "special" objects).

It turns out that an individual object of **Mon** is also a
category. It consists of a single object. The morphisms are words.
There is an identity morphism that we can denote '1'. Composition
is just the monoid operation. (N, +, 0) is such an object of
**Mon**.

To make a connection with categories in Axiom, I would want to
say that 'Monoid' represents the category **Mon** while
'Monoid(*$INT,1)' denotes an object of **Mon**. In fact both
of these are categories in their own right.

This brings up a design feature of Axiom and Aldor that I do
not really like. Axiom and Aldor implement a strict two-level
type class hierachy that distinquishes between categories and
domains. Just as in category theory, I think this distinction
is necessary in order to build mathematical constructs. But
categories and domains should not remain strictly separate.
There are many times when we might want to treat a category as
a domain in some other category. We sometimes need to be able
to "flatten" this hierachy and consider really only one kind
of type.

I think this is very closely related to the idea of "reflection"
as discussed some months ago by Peter Broadbery:

http://lists.nongnu.org/archive/html/axiom-developer/2005-09/msg00250.html

When we can treat categories as domains, then domains become
members and we can "ask questions" and manipulate domains (and
categories) as true "first-level" objects.

\start
Date: Mon, 13 Mar 2006 14:39:18 -0500
From: William Sit
To: Ralf Hemmecke
Subject: Re: Curiosities with Axiom mathematical structures

Ralf Hemmecke wrote:
> 
> hi Martin,
> 
> On 03/13/2006 01:15 PM, Martin Rubey wrote:
> > Ralf Hemmecke writes:
> >
> >> Hi Martin,
> >>
> >> a quick response to the following...
> >>
> >>> There is a simple practical reason why I dislike the idea of asking just
> >>> "Integer has Monoid".
> >>> Imagine I'm programming a package, and I need that a parameter domain M is a
> >>> monoid, so that I can use the monoidal structure, for example for
> >>> multiplying. Well, then simply asking M has Monoid doesn't buy me anything,
> >>> since I won't be sure that M really is a Monoid with respect to "+".
> >> Imagine you could ask "if M has Monoid(+)..." or "if M has
> >> Monoid(*)...". According to which returns true, you would then go on and call
> >> (m1 +$M m2) or (m1 *$M m2). Well, but M might have a monoid structure with
> >> respect to the operation ".". Do you really also want to ask "if M has
> >> Monoid(.)..."? That soon becomes impractical.
> >
> > No, this is not an issue about practicality.
> >
> > Look at it this way: Suppose "M has Monoid" returns "true". How do you know
> > then with respect to which operation M is a monoid? What can you do with the
> > information that M is a monoid with respect to some operation?
> 
> If
>    Monodid: Category == with{ 1:%; *:(%,%)->%; }
> then "M has Monoid" means that M has a 1 and *.
> 
> By now, we all know that if "M has Monoid" returns false, it does NOT
> mean that M is not an object in the category of (mathematical) monoids.
> 
> It is as simple as this "Monoid" in Axiom does NOT stand for the
> category of all monoids.
> 
> Ralf

Martin:

If we are allowed to change the notation for the monoid structure so that a set
can have multiple monoidal structures and we can inquire about it, then some
code like:

   If X has Monoid("*") then ...

would have no definite meaning since you will NOT know the operator in X that
makes it a monoid. Even if you happen to guess the correct **notation**, you
still would not know what the **definition** of the operator is without looking
at the code for "*", manually, of X. In other words, you have NO way to know
when you write that code that the operation "*" that is matched (when 'X has
Monoid("*")' returns 'true') that it is the operation you have in mind in the
code following 'then' since by your testing the predicate, you admit that you
don't know what X is at run time.

The way this need to be handled is to use accepted conventions for different
types of monoid operations (and of course, we can't have it all, but whatever we
have in the system, it would be documented and uniquely named. So we can write
code with no ambiguity. Examples would be AbelianMonoid (using "+"),
CompositionMonoid (using \circ), MaxMonoid (using 'max'), etc. But really, there
is really no need for such proliferation unless many descendents are
anticipated.

If you want to avoid duplicating code, like 'square', we can define 
'square(m:%->%, x:%)' for any X:Type in a package. (This example can be
generalized clearly).

\start
Date: Mon, 13 Mar 2006 16:29:03 -0500
From: Bill Page
To: William Sit
Subject: RE: Curiosities with Axiom mathematical structures

On Monday, March 13, 2006 2:39 PM William Sit wrote:
> ...
> If we are allowed to change the notation for the monoid
> structure so that a set can have multiple monoidal
> structures and we can inquire about it, then some
> code like:
>
>    If X has Monoid("*") then ...
>
> would have no definite meaning since you will NOT know
> the operator in X that makes it a monoid.

??? I thought that was precisely what Martin wants this
to mean. Obviously '*' is the operator in question. More
precisely one might write:

    If X has Monoid(*$X) then ...

> Even if you happen to guess the correct **notation**, you
> still would not know what the **definition** of the operator
> is without looking at the code for "*", manually, of X.

I don't think any "guessing" is involved.

> In other words, you have NO way to know when you write that
> code that the operation "*" that is matched (when 'X has
> Monoid("*")' returns 'true') that it is the operation you
> have in mind in the code following 'then' since by your
> testing the predicate, you admit that you don't know what
> X is at run time.

??? I don't think what you wrote above makes sense. Obviously
the program does "know" what X is. It has presumably been
passed from some other part of the program or from the user
via the interpreter. But the point is we do not want to write
code that is specific to X but rather code that will work
provided that X has a monoid structure with the binary
function *$X.

>
> The way this need to be handled is to use accepted conventions
> for different types of monoid operations (and of course, we
> can't have it all, but whatever we have in the system, it
> would be documented and uniquely named. So we can write
> code with no ambiguity. Examples would be AbelianMonoid
> (using "+"), CompositionMonoid (using \circ), MaxMonoid
> (using 'max'), etc.

No! This is exactly what Martin is trying to avoid.

> But really, there is really no need for such proliferation
> unless many descendents are anticipated.

I think Martin's point is not so much related to a specific
programming need, but rather to the desire to write code
that corresponds to common mathmatical usage.

>
> If you want to avoid duplicating code, like 'square', we
> can define 'square(m:%->%, x:%)' for any X:Type in a
> package. (This example can be generalized clearly).
>

In fact in Axiom with SPAD default implementations in
categories are implemented as a package with a special
name related to the name of the category.

\start
Date: 14 Mar 2006 00:41:46 +0100
From: Gabriel Dos Reis
To: William Sit
Subject: Re: Curiosities with Axiom mathematical structures

William Sit writes:

| Hi Gabe:
| 
| Gabriel Dos Reis wrote:
| > William Sit writes:
| > 
| > |  Bill Page writes:
| > |
| > | > | I don't think there is any essential reason why SemiGroup and
| > | > | Monoid could not be implemented in the way you suggest. For
| > | > | example:
| > | > |
| > | > | )abbrev category SGROUP SemiGroup
| > | > | SemiGroup(m:Symbol): Category == SetCategory with
| > | > |       m: (%,%) -> %    ++ returns the product of x and y.
| > | > |       associative(m)
| > | > |
| > | > | )abbrev category ABELSQ AbelianSemiGroup
| > | > | AbelianSemiGroup(m:Symbol): Category == SemiGroup(m) with
| > | > |       abelian(m)
| > | > |
| > |
| > | Yes, there are no theoretical reasons, but there are plenty of
| > | practical ones.
| 
| > In fact, practicality dictates that the implementations in Axiom/Aldor
| > closely follow the mathematical structures.  
| 
| You probably misread my response to Bill. 

After re-reading the long thread that followed, I do not believe so.

I think I correctly read your answer and I correctly deduced a fundamental
mismatch between your conception of what a monoid is and should be
written and the demand of writing a computer program to express
mathematical structure.

| I was saying there are plenty of practical reasons NOT to implement
| in the way suggested, but no theoretical reasons NOT to implement
| the goal you suggested, in some way. 

Sorry, none of the reasons you enumerated were "practical".
They look to me as a choice that "looked good a the time", but turned
out to be broken but a heartily desire to stick to it instead of
evolving.   It looks to me more ideological than practical.  

It negates practice.

| > For example, the only
| > assumption  I need to define the power of an element is that its domain
| > has a monoidal structure.  From software engineering point of view,
| > Practicality dictates that I should not have to write duplicate codes,
| > one for additive operation, one for multiplicative operation when the
| > underlying mathematical structure is the same.  That is
| > the least I expect from a non-mathematically-oriented system.
| 
| Agreed in theory, not in practice. 

Wrong; I'm talking of practical issues.

| We should distinguish two issues: (1)
| derived  operations that depend only on the defining operations should be
| generically implemented and inherited, and (2) how to handle the notations
| (equivalently, identifiers in computer science terminology) for the defining
| operations and derived operations.  Notations (resp. identifiers) are extremely
| important in mathematics(resp. computer programming). Mathematics can only
| progress and make strides when good notations are invented AND agreed to.

notation is important, and so is semantics.  When syntax takes precedence over
semantics, the result is empty sophism and boring rethorics.

| Examples are the notations for differentiation and integration. 

Sorry, they do not illustrate in a anyway why a AbelianMonoid is not a
Monoid. 

| A software system that deviates from the universally accepted
| mathematical notations, even if for the sake of valid ideals,  will
| not be usable and at best be hardly usable.

Is it more important to derive from alleged universal notation (when
in fact the notation is highly ambiguous, and the universality is just
mirage) than derive from universal semantics?  Which mathematical
authority do know and universally agreed on that do not recognize an
Abelian monoid as a monoid?

| Computer programs can work correctly only if identifiers are scoped 
| correctly and such scoping should be transparent when identifiers are
| overloaded.

That is what you claim, and yet we have no evidence that Axiom/Aldor
have "correctly scoped identifiers".  Furthermore, we have to see
evidence of why it is desired that such "scoping should be transparent
when identifiers are overloaded."  As a matter of fact, we have
examples (in this thread) that suggest that the transparency is far
from being what we need.

| The concept of a ring is almost omnipotent in all branches of
| mathematics, and the standard notations for the multiplication (*)
| and addition (+) are adopted. 

You are missing an important fact: most of the mathematical texts use
notation invented when computer programs were not the primary focus of
the discourse when where context helped *humans* to automatically
disambiguate when more operations are involved.

| You may almost forget about that a ring is a monoid wrt to * and an
| abelion monoid wrt + because what is important to a ring is the two
| together, how they interact via the distributive laws.

No, you're wrong: I did not forget that.

| A practical way to support the structure of a ring requires these
| two separate notations.

Wrong: a practical way to support them is not to prejudge of syntax in 
more general contexts, and stick to the *algebraic structure* being
modeled. 

| Even in the simple case of your example for repeated operation
| (which you called "power"), the two operations * and + will produce
| (and should produce) outputs in two different notations: x^n (power)
| and n*x (multiple). In this case, the repeated operations in fact
| occur both in an *abelian* submonoid setting even if multiplication is
| non-commutative.

Well, unless you're a proposing a new mathematics you reduction is
again wrong -- because you're prejudging semantics.  Again take

    f (x, y) = x * y + x + y

on integers with usual addition and multiplication, then (N, f, 0) is
another Abelian monoid structure.  Computing the repeated operation
does not yield n * x or x^n.  Please stop confusing syntax with the
*structure*. 

The medium is not the message.  


| So I hope we need not argue a third issue: (3) maintaining standard
| notations for the defining operations in common algebraic structures.

but standard notation of what?  Computer programs have very different
requirements from free mathematical discourse.

| I think your ideal of avoiding "duplicate codes" (much like the
| ideal of sharing dll libraries) is misplaced.

Please, if you want to discuss shared dll libraries, let's do that in
a different thread.  The issue at hand is too important to be left
diluted in questionable analogies. 

| In order to avoid duplicating code due to the dual use of * and + in
| the monoid structures, one will have to, as admitted throughout
| these discussions by everyone, ADD tons of code and in the end
| making writing software for a ring more difficult, not less. Not
| only that, I doubt if the experts here could agree to how that
| additional code should be written, even if everything were started
| from scratch. 

Please, what are you tlaking about?

| I think a proper way to "allow" the kind of identification of underlying
| mathematical structures that are the same is the concept of
| "isomorphism".

But not all structrures are isomorphic, even in the same
(mathematical) category.  We do not need to recover from yet another
set of misguided and misplaced isomorphims.

[...]

| Let's say in Monoid, I used & for the defining monoid operation. If I want to
| form a monoid domain with set Integer and operation #, (Integer, #), I would
| have to specify to the compiler an isomorphism.  The compiler would have to
| execute this isomorphism by replacing each occurrence of '&' by '#' in the
| category definition temporarily before matching the domain
| signatures with the category signatures. This necessitates that in
| the category definition of a monoid, and in the domain code of an
| actual monoid, we can identify and separate the defining operations
| from the derived operations -- which is currently not the
| case. Let's assume this is done nonetheless. 

You are using confusing terminologies to say exactly what I'm proposing.

| Then the generic code of derived operations (such as 'square' or
| 'power'), if available, will have to be translated, duplicated, and
| inserted in the domain for correct signatures and implementation.

I disagree.  There is no inherent reason why they should be
duplicated.  The operation '&' is a parameter!  Whether the
instantiation should be through copy-and-build or sharing is a
completely different issue.

[...]

| > If the system does not let one do that, then the system is practically
| > defective :-)
| 
| All systems have defects. Be realistic!

No kidding.  

I just release one last week.

[...]

| > |  Indeed, how is a user to know what symbol was used, say, for the
| > | operations? What if the user instantiates Integer with both * and +
| > | for the same operations in two instances?
| > 
| > When both will be in scope.  If the user uses * with Integer, the
| > system knows that (*, Int) is a monoidal structure.  Same if
| > (+, Int).
| 
| I meant using * for multiplication of integer in one instantiation,
| and using + for multiplication of integer in another instantiation,
| two notations for the same set and operation. (I am not advocating
| this! see original message for the context, please).
|  
| > | Can a compiler or interpreter catch this?
| > 
| > Yes, definitely.
| 
| Really? The two copies of the multiplicative monoid of integers are
| compiled at different times and instantiatiated in the SAME
| interpreter session. Can the interpreter execute something like
| 3*4+5 correctly and give 60 (without package calls)? What if we have
| two copies of the ring of integers where in one the notations for *
| and + are interchanged? When this sort of arbitrary notations is
| allowed, every function call need to be a package call or else it
| would be a nightmare to explain all the "strange" answers. (The
| isomorphism mechanism does not seem to solve this problem).

Well, programming languages have been dealing with such issues for
long time now.  Either, you permit nonsensical uses (because in
general you can't prevent all of them and yet remain useful); or you
do minimal checking when same operations should be defined
consistently (programming languages like C++ calls it the "One
Definition Rule", and do not require compilers to diagnose all of
them, but there are known systems in production use that have
implemented them for the vast majority part of it and can handle such
cases). 

| > | If not, it would be a nightmare of bug reports.
| > 
| > It would be a nightmare only if one takes the rules that a type has a
| > unique algebraic structure.  That is both theoretically and practically
| > false.  See the examples (+, NN), (*, NN), (NN, max) I gave earlier.
| 
| Quite the contrary. When a type has a unique algebraic structure (I
| presume you meant only default notations for its defining operators
| are allowed), 

No, please do take note that I'm distinguishing structure from syntax.

| there is no ambiguity possible like the 3*4+5 above.

Utimately, you have to agree that a symbol resolves to what it
implements -- even mroe so in your OO-centric view of mathematical structures.


| I don't disagree this state is non-optimal, but the proposed state
| has its problems. Your examples show three *different* binary
| operations with three *different* identifiers.

Again, identifiers are not algebraic structures.  

The proposed change certainly has its set of problems -- but nothing of
what you said above is about them.  To start with, the proposal is not
complete :-)

| If you want to inherit say the function 'square' for each, you need
| to, as explained above, establish three isomorphisms to the
| fictitious domain % in the categorical definition and translate,

Please do notice that 'square' implicitly depends on the monoid
operation passed as parameter to the monoid structure.  Consequently,
if I wanted to have different *instances* of it simultaneously in the
same scope, then I need to give different names to those *instances*
If I want to have them simultaneously in the *same scope*, then
obviously I need to give different names to their *instances*, e.g.

     doublePlus == Monoid(T, +).square
     doubleTime == Monoid(T, *).square

[...]

| It would be all the more of a problem when all the three monoid structures
| co-exist in the *same* domain (multiple inheritance).

it would be a problem only if one sticks to an ill-suited OO-centric
view.  Other models exist, and should be explored.


| Notice that while the domain (NN, +, *, max) exists, the domains
| (NN, +), (NN, *), and (NN, max) are transiently constructed during
| compilation only! There is no (NN, +).NRLIB for example. Besides,
| you can only have ONE signature 'square: % -> %' in the domain 
| (NN, +, *, max), not three.  This possibly is an important reasons why
| AbelianMonoid does not descend from Monoid.  

you're confusing the current ill-suited OO implementation with what
should happen.  If there is no theoretical reason why that should
happen, then you better off revise your implementation model.

| There seems to be no good way to solve this multiple inheritance problem.

Abandon, OO and that ill-suited multiple inheritance stuff, when not
helpful, -- e.g. here.

[...]

| Needless to add, such automated translation, duplication and insertion are
| simply not supported currently (see SandBoxMonoid).

No.  Please see above.

[...]

| > I wanted to use Axiom to teach generic programming here,
| > but I'm being forced to walk away from it :-((
| > How can I convince students of the value of the system when it does
| > not support their knowledge?
| 
| Your students should be able to learn the abstract concepts abstractly :-)

My students are better off not learning the abstraction at all, than
have their mind crippled with obfuscated ill-suited implementations.

| You can teach them about isomorphisms. Also, tell your students life
| is always a compromise.

my students are well aware that life is compromise -- do not of many
students that decide to take graduate courses and still believe
otherwise? 

| > | CAS to be practical, certain compromises are necessary.
| > 
| > 100% agreed.  However, uniformity and coherence should not be compromised.
| > The current approach does not even support the mathematical or
| > "categorial" approach we would like to recommend.  
| 
| The current approach does support, within the limits of the programming
| language. The Axiom designers are mathematicians and computer scientists and
| they must have thought about this before deciding on the
| compromise. Remember, that was in the 1970's and I think their
| compromise is quite reasonable and have served the community well
| for over 30 years.  

many systems were designed more than 30 years ago.  At the time, their
designers tried to do the best possible at their time.  Those who
refused to evolve died.  Since the 1970s advances have been made in
understanding type systems; it would be singular that Axiom refuses to
evolve and stick to OO-centric views we now know does not work well.
We can't require unreasonable degree of foresight from designers, but
it is unreasonable that the system refuses to evolve -- if it ever
wanted to survive.

[...]

| Coherence, if I understand what you meant by that, requires confluence in
| rewriting rules.

No, you misunderstood what I was saying.

[...]

| If you think now one can redo Axiom in a better way, we are all for
| it. What's your priorities? (in other words, when can you start? :-)

What about give me unrestricted access to Adlro compiler sources? ;-)
(and I'm serious)

[...]

| > | I do not question the theorectical advantage of rebuilding all
| > | algebra based on properties of operators (there is research in
| > | theory of operads which would support such a design) but I doubt
| > | their practicality, especially when the notation for the operators
| > | can only be known dynamically at run-time.
| > 
| > Well, I'm approaching the issue more from a *practical* point of view
| > than a theoretical point of view.  As the system currently stands, in
| > practice, I cannot simply and clearly write once a generic function
| > for monoidal structures and expect it to work for both for Abelian and
| > non Abelian monoids. 
| 
| This is not true. First, you don't mean non-Abelian monoids, you meant
| not-necessarily Abelian monoids (or simply monoids).

I meant what I said.

| An abelian monoid IS also a monoid and hence it will work!

Oh really?

| (You just need to redefine AbelianMonoid to use * instead of +,
| showing it is not an inherent weakness of the system but just a 
| matter of notations).  

You are displaying an incoherent attitude in this matter, and at this
pointI don't know how serious you're.

   f(x, y) = x * y + x + y

f uses both * and +.  Now, (N, f, 0) is an Abelian monoid, so you
propose that in the same session I rename f to *, * to + and + to ?
You're joking, right?

[...]

| > | As already well-known, with the current status, all properties of
| > | operators are declarative and not verified.
| > 
| > My problem is simpler than that.  I'm not asking for the definition of
| > the algebraic properties of operators.  I'm trying to have a way to
| > convince Axiom/Aldor to support sound software engineering practice.
| > Even better if I can take the standard library as an example.
| 
| No, you are not discussing "sound software engineering practice". You are
| arguing about how to inherit abstract algebraic properties.

No.  The ill-suited inheritance stuff is just one irritating
manifestation of "sound software engineering practice".  Don't shout
the messenger.

[...]

| I understand your points. There are many monoid structures in any algebraic
| object because monoid is a very simple structure.

No, the problem is not because it is a simple structure, it is because
it is a *structure* and the current system confuses structure with
syntax.  That is the root of the problem.

[...]

| Have you seen ANY paper which interchanges the * and + notations in
| a commutative ring?) 

That is beside the point.  The issue is not whether * should be
interchanged with +.  The issue is how to simply design the system so
that AbelianMonoid is indeed a Monoid.  

\start
Date: 14 Mar 2006 00:43:08 +0100
From: Gabriel Dos Reis
To: Ralf Hemmecke
Subject: Re: Curiosities with Axiom mathematical structures
Cc: list

Ralf Hemmecke writes:

| Dear William,
| 
| On 03/04/2006 05:31 PM, William Sit wrote:
| > Hi Gabe:
| > Gabriel Dos Reis wrote:
| >> William Sit writes:
| 
| > Agreed in theory, not in practice.  We should distinguish two issues: (1)
| > derived  operations that depend only on the defining operations should be
| > generically implemented and inherited, and (2) how to handle the notations
| > (equivalently, identifiers in computer science terminology) for the defining
| > operations and derived operations.
| 
| By (1) you probably mean to say something like
| 
| define PrimitiveType: Category == with {
| 	=: (%, %) -> Boolean;
| 	~=: (%, %) -> Boolean;
|      default { (a:%) ~= (b:%):Boolean == ~(a = b); }
| }
| 
| I must say that I liked this idea of "default implementations" when
| I've encountered it. But it also introduces all the complications with
| multiple inheritance.

Inheritance usually does not mary well with genericity, despite the
usual OO propaganda.  :-(

\start
Date: Mon, 13 Mar 2006 18:55:06 -0500
From: William Sit
To: Bill Page
Subject: Re: Curiosities with Axiom mathematical structures

Bill:

Rather than reply to your ??? point by point, what I was trying to say
is that in a set X equipped with several (let's say three) operations
each of which (with appropriate "unit" element that I ignore for
simplicity) makes the set into a monoid, these three operations can be
notated, say, *, +, o, and these are programmed in the domain
constructor X using three formulas (but without looking at the code,
you won't know which formulas are used or which matches with a
particular notation). Assume that these operators are not following
any particular convention (so if X is a set of real-valued functions
on a finite field, * could mean 'max', + could mean pointwise
multiplication, and o could mean pointwise addition). Of course, there
could also be some other set Y, say also a set of real-valued
functions defined on a (perhaps different) finite field, with the same
set of three monoid structures, but they may be notated differently!
Now if some domain, such as X or Y, has been passed to a subroutine we
are writing, but we don't know which, and let's say in the routine,
this is called Z. We know Z is going to be a set of real functions on
some finite field and we know there are three operations: adding
functions, multiplying, or taking the max. But Z could be either X or
Y and which one it is can only be known at run time. Say in the
routine, we want to do a pointwise multiplication, no matter what Z
is.

   If Z has Monoid(*$Z) then ...

Is there ANY definite meaning to the *$Z?  If you say you are writing generic
code, you would have to, as Ralf said, test every possible name for pointwise
multiplication. To avoid this, you need "*" be the ONLY (default) notation for
pointwise multiplication. This contradicts Martin's idea, which is specifically
to allow arbitrary notation (namely, operator).  So Z may be the tri-monoid X
with pointwise multiplication, but not use * for this operation, and use * for
max.  Or Z may be the tri-monoid Y. How would you know what operation is in the
definition of the monoid (Z, *) without knowing Z = X or Z = Y AND reading the
domain constructor code for *? The only way for such code testing to make sense
is to follow a convention that * in a monoid has only one meaning.

In Mathematics, we know what (Integer, *), (Integer, +), (Integer, max) mean
unambiguously because these notations *, +, max have their fixed usual meaning,
by convention. This convention avoids us having to look up the meaning of the
operations. Since you must unambiguously know the meaning of an operator when
you test, you must fix this convention. But once this convention is fixed, then 
'Monoid(+$Z)' just becomes another way of saying AbelianMonoid.

"Page, Bill" wrote:
> 
> On Monday, March 13, 2006 2:39 PM William Sit wrote:
> > ...
> > If we are allowed to change the notation for the monoid
> > structure so that a set can have multiple monoidal
> > structures and we can inquire about it, then some
> > code like:
> >
> >    If X has Monoid("*") then ...
> >
> > would have no definite meaning since you will NOT know
> > the operator in X that makes it a monoid.
> 
> ??? I thought that was precisely what Martin wants this
> to mean. Obviously '*' is the operator in question. More
> precisely one might write:
> 
>     If X has Monoid(*$X) then ...
> 
> > Even if you happen to guess the correct **notation**, you
> > still would not know what the **definition** of the operator
> > is without looking at the code for "*", manually, of X.
> 
> I don't think any "guessing" is involved.
> 
> > In other words, you have NO way to know when you write that
> > code that the operation "*" that is matched (when 'X has
> > Monoid("*")' returns 'true') that it is the operation you
> > have in mind in the code following 'then' since by your
> > testing the predicate, you admit that you don't know what
> > X is at run time.
> 
> ??? I don't think what you wrote above makes sense. Obviously
> the program does "know" what X is. It has presumably been
> passed from some other part of the program or from the user
> via the interpreter. But the point is we do not want to write
> code that is specific to X but rather code that will work
> provided that X has a monoid structure with the binary
> function *$X.
> 
> >
> > The way this need to be handled is to use accepted conventions
> > for different types of monoid operations (and of course, we
> > can't have it all, but whatever we have in the system, it
> > would be documented and uniquely named. So we can write
> > code with no ambiguity. Examples would be AbelianMonoid
> > (using "+"), CompositionMonoid (using \circ), MaxMonoid
> > (using 'max'), etc.
> 
> No! This is exactly what Martin is trying to avoid.
> 
> > But really, there is really no need for such proliferation
> > unless many descendents are anticipated.
> 
> I think Martin's point is not so much related to a specific
> programming need, but rather to the desire to write code
> that corresponds to common mathmatical usage.
> 
> >
> > If you want to avoid duplicating code, like 'square', we
> > can define 'square(m:%->%, x:%)' for any X:Type in a
> > package. (This example can be generalized clearly).
> >
> 
> In fact in Axiom with SPAD default implementations in
> categories are implemented as a package with a special
> name related to the name of the category.

\start
Date: 14 Mar 2006 01:03:32 +0100
From: Gabriel Dos Reis
To: Ralf Hemmecke
Subject: Re: Curiosities with Axiom mathematical structures

Ralf Hemmecke writes:

| On 03/02/2006 08:23 PM, Gabriel Dos Reis wrote:
| > Bill Page writes:
| > | On February 27, 2006 11:08 AM Gabriel Dos Reis wrote:
| > | > Ralf Hemmecke writes:
| > | > | Note that one would have to say something like
| > | > | | > | define Monoid(
| > | > |    *: (%, %) -> %;
| > | > |    1: %
| > | > | ): Category == ...
| > | > | | > | define Group(
| > | > |    *: (%, %) -> %,
| > | > |    inv: % -> %,
| > | > |    1: %
| > | > | ): Category == ...
| > | > | | > | define Ring(.....): Category == with {
| > | > |    Monoid(*, 1);
| > | > |    Group(+, -, 0);
| > | > | }
| > | > | > Ring should be both Monoid and Group, whether they shoud be
| > | > categories, I don't really know.
| 
| > The reason I previously said I did not see why Monoid should be a
| > category is that the operation is already passed in as a parameter, so
| > there would nothing to implement "inside" in the Monoid.
| 
| I had to read your statement several times until I got the point. I

Sorry about that.

| must admit that I probably have not thought clearly enough before I
| wrote down the code. But it's clear that als a (multisorted) universal
| algebra
| 
| define Monoid: Category == with {
|    1: %;
|    *: (%, %) -> %
| }
| 
| can mathematically be seen as
| 
|    a Monoid is a tuple (%, (f_1, f_2)) where % is the underlying set,
|    f_1 is the unit element and f_2 is multiplication.

Yes.

Furthermore, the monoid operation uniquely identifies the neutral
element; consequently  I think the syntax can be minimized to

   define Monoid(T: type, m: T x T -> T) : Category with {
          neutral : T;
   }

Here, I don't expect neutral to be exported to the "global scope".
Rather it should be visible only through the member access operator,
e.g. 

| (Unfortunately, nothing in the Aldor code above says anything about
| relations between 1 and *.)

I understand that, but I'm all for stepwise refinement.  First, get
rid of the syntax that stands in the way, then more on "semantics",
e.g. more interesting stuff :-)

| But although the operations are called 1 and * that should not
| matter. They should be just place holders for the actual name of the
| operation in the concrete monoid.

Exactly.  And they should not be exported to the "global scope".

[...]

| > Indeed, there would be a redundancy in the system.  The underlying type
| > and the operation suffice to uniquely define the structure.  So that
| > means, the other parameters are somehow "function" of the essential
| > parameters. That implies that indeed Monoid will be a category which
| > domains will implement by supplying the value for the neutral element.
| > Same reasoning for Group where the type and the operation suffice to
| > define the inverse and the neutral element.
| 
| Yes. The domain provides the value for the neutral element. And who
| provides the name for the neutral element? You know the domain Integer
| is both a Monoid with respect to addition and multiplication. You have
| just the identifier "1" in the category Monoid. How would I
| specify/name the additive unit element in Integer?

That problem is a non-problem if you observe the following.  The
neutral element is a function of the monoid operation.  Furthermore,
each *instance* of monoid structure gives rise a unique neutral
element (for example, accessible  through member access).  So there is
no conflict between the neutral element of Monoid(N, +) and that of
Monoid(N, *).  They are all (a priori) different.  They matter only
when using generic function, but then by the time such functions are
called the particular monoid instance is already sealed so there is no
possible confusion.


| 
|  > | However, there is no way in Axiom to express that a Ring is a Monoid
|  > | (SemiGroup if you like) "with respect to multiplication" and a Group
|  > | (which is also a Monoid) "with respect to addition".
|  >
|  > I understand there is no way.  My issue is *why*? E.g. is it
|  > fundamental or just implementation details that shrine into the
|  > interface?  My suspected answer is that it is an artifact of the
|  > used object-oriented technology.
| 
| I cannot belief that this issue is fundamental, but I am not an expert
| in this field. I you could help to come up with a nice syntax that
| would allow a compiler to translate
| 
|    [*] a Ring is a SemiGroup "with respect to multiplication"
|        and a Group (which is also a Monoid) "with respect to addition"
| 
| into reasonable binaries, I would highly appreciate it, since it would
| make Aldor even more "mathematical".

   define Magma(T: Type, m: T x T -> T) : Category;

   define SemiGroup(T: Type, m: T x T -> T) : Join(Magma(T, m)) with {
       Associative(T, m);
   }

   define Monoid(T: Type, m: T x T -> T) : Join(SemiGroup(T, m)) with {
        neutral : T;
   }

   define Group(T: Type, m: T x T -> T) : Join(Monoid(T, m)) with {
        inverse : T -> T;
   }

   define AbelianGroup(T: Type, m: T x T -> T) : Join(Group(T, m)) with {
        Commutative(T, m);
   }

   define Ring(T: Type, a : T x T -> T, m : T x T -> T) :
             Join(AbelianGroup(T, a), SemiGroup(T, m)) with {
       Distributive(T, a, m);
   }

the syntax is not right but I guess you get the idea.

\start
Date: 14 Mar 2006 01:26:09 +0100
From: Gabriel Dos Reis
To: Ralf Hemmecke
Subject: Re: Curiosities with Axiom mathematical structures

Ralf Hemmecke writes:

[...]

| Yes, one has to rethink that quite a lot. The problem with your
| suggestion is the following
| 
| 1) You cannot simply ask
| 
|    Integer has Monoid
| 
| because you have to give a parameter.

yes, that is alright.  The question

    Integer has Monoid

is an underspecified question.

| 2) If you say something like
| 
| MyMonoid(T: Type, m: (T, T) -> T): Category == with {
|    square: T-> T;
|    default {square(t: T): T == m(t, t)}
| }
| 
| then it is perfect Aldor.
| Then, however, you ask
| 
|    Integer has MyMonoid(Integer, *)
| 
| and it will return true only if you have said
| 
| extend Integer: MyMonoid(Integer, *) == add;
| 
| somewhere.

That is fine! -- I don't expect Aldor to read my mind :-)

| (But probably you had something else in mind.)
| 
| Although I don't really like that an AbelianMonoid is not a Monoid,
| and although I think that renaming during inheritance would be nearer
| to mathematics...

I still don't follow that path.  Please could you explain with more
examples?  The understanding of renaming I have causes more trouble
than it solves problem.

|  after all the discussion here, I somehow think that
| the design in Axiom is not really bad. The reason is that I have not
| seen a clear case where renaming would be over-advantageous.
| 
| I'd like to say
| 
|    Integer has Monoid
| 
| instead of
| 
|    Integer has Monoid(*, 1);
|    Integer has Monoid(+, 0);

I would not.  The question

     Integer has Monoid

gives me no clue about what is going on.  

In fact, in situations where when I ask the question

    Integer has Group(op)

I'm more interested interested in retrieving the inverse operation and
neutral element of op, than just the mere question is it a Group.

Consider computing the nth "power" of x (of type T).  First of, one
can have a general (helper) implementation of "power" for a monoid (or
even just a semigroup or a magma) see page 99 of

     http://www.stepanovpapers.com/notes.pdf

and onwards.  If n is negative and T is a group, then one can just
take the "positive" power of the inverse of x -- reuse known
abstraction. 

| Simply think of a category Foo with hundreds of exported function,
| would you like to write
| 
|    Dom has Foo(f1, f2, ..., f100)
| 
| ??? That is not really handy.

quite; but I believe my first idea can be refined (as I did):  I doubt
all of the hundreds parameters for Foo are independent.  In pratice,
the number of indenpendent parameters for the algebraic structure does
nto exceed 5 or six.  However, many of the "exported" functions are 
"functions" of those independent parameters.

\start
Date: 14 Mar 2006 01:30:45 +0100
From: Gabriel Dos Reis
To: William Sit
Subject: Re: BINGO, Curiosities with Axiom mathematical structures
Cc: Bill Page

William Sit writes:

| Martin:
| 
| Good work (I'm impressed :-). I think your solution is in fact the way
| mathematicians build up algebraic structures: first define the underlying set
| and the basic operations, then prove that the axioms of certain algebraic
| structure are satisfied. Here you declare (rather than prove) these using
| Aldor's 'extend' mechanism.

Yes, and remarkable they don't use OO-centric view that hinder
evolution and improvements.

| 
| The beauty of your solution is that the notation (naming of the operations) is
| defined in the domain itself and then the algebraic properties declared by
| extension.
| 
| The slight disadvantage is that these structural operations must be listed with
| each domain,

no, only the independent parameters necessary to define the algebraic
structure need to be passed as parameter.  The rest is function of
those and default defined (or just listed) in the interface.

| and there is no default way (yet). So perhaps in MyMonoid, with
| parameters, there can be a default syntax, such as:
| 
|   MyMonoid(T:Type, default{*:(T,T)->T)}):Category
|   MyDualMonoid(T:Type, default{*:(T,T)->T, o:(T,T)->T}):Category ==
|     with{MyMonoid(T); MyMonoid(T, o)};
|   MyAbelianMonoid(T:Type, default{+:(T,T)->T}):Category ==
|     with{commutative(+); MyMonoid(T, +), ...};
|   MyRing(T:Type, default{*:(T,T)->T, +:(T,T)->T}:Category ==
|     with{MyAbelianMonoid(T), MyMonoid(T), ...};
|   MyCommutativeRing(T:Type, default{*:(T,T)->T, +:(T,T)->T}:Category ==
|     with{MyAbelianMonoid(T), MyAbelianMonoid(T,*), ...};
| 
| (the above omits the units for the operations, which could be added easily) so
| that 
| 
|   extend MyInteger: MyRing(MyInteger) == add;
| 
| would make sense.


It suffers from the old OO-centric  view, which is causing the problem
I mentioned in the start of this thread.  The problem here is that
you're focusing on the carrier set (MyInteger), intead of focusing on the
operations that give structure to the set.  

\start
Date: 14 Mar 2006 01:32:04 +0100
From: Gabriel Dos Reis
To: Bill Page
Subject: Re: BINGO, Curiosities with Axiom mathematical structures

Bill Page writes:

| Martin,
| 
| I think you have a rather beautiful idea... but I see some
| problems.
| 
| On March 9, 2006 11:08 AM you wrote:
| > 
| > I am satisfied now:
| > -----------------
| > #include "axiom"
| > 
| > MyMonoid(T: Type, m: (T, T) -> T): Category == with {
| >    square: T-> T;
| >    default {square(t: T): T == m(t, t)}
| > }
| 
| This definition of the category MyMonoid looks quite strange
| because it does not export any binary operation!
| 
| Also, I think you should write:
| 
|    square: % -> %;
|    default {square(t: %): % == m(t pretend T, t pretend T) pretend %
| 
| although apparently the compiler does not worry about this since
| your representation of the domain MyWord below is the same as the
| operation that you pass to MyMonoid.

we should also probably find a way to minimize the "pretend"s :-)

\start
Date: 14 Mar 2006 01:37:13 +0100
From: Gabriel Dos Reis
To: Ralf Hemmecke
Subject: Re: Curiosities with Axiom mathematical structures

Ralf Hemmecke writes:

| On 03/09/2006 03:46 PM, Martin Rubey wrote:
| > I wouldn't want to ask "Integer has Monoid", since this doesn't make any sense
| > to me. I'd like to ask "Integer has Monoid(Integer, *)" or "Integer
| > has Monoid(*)"
| 
| Well, if one interprets Monoid as the category of monoids then
| 
|    Integer has Monoid
| 
| just say that the integers (now the question is whether you mean the
| integers with the additive or the multiplicative structure) are an
| object in the category of monoids.

That is too restrictive.  There are many monoid structures on
integers.  One should not design a computer algebra system restricted
only to + and *.  It would like decreeing that because square root is
expensive to compute, the Euclidean distance does not exist.

| Integer is a name for a structure with carrier set
| 
| {0, 1, -1, 2, -2, ...}
| 
| and operations {+, *, 0, 1, ...}.
| 
| Integer is certainly not the carrier set alone.

Indeed. It is a type, e.g. set equipped with minimal operations that
let us implement abstractions on top of it.  Just an abstract data
type can be implemented in terms of another one, an algebraic
structure cane be constructed in terms of another one.

| How would you mathematically express that the integers belong to the
| category of monoids? You would probably say that
| 
| F(Integer) is an object in the category of monoids

I would do it by assertion.  But I will refrain from needlessly
emphasizing on the the carrier set -- as F(Integer).  Rather, it is
the additional operation that gives new structure; that is where the
emphasis should be.

\start
Date: Mon, 13 Mar 2006 19:37:33 -0500
From: Bill Page
To: William Sit
Subject: RE: Curiosities with Axiom mathematical structures

William,

On Monday, March 13, 2006 6:55 PM you wrote:
> ...
> in a set X equipped with several (let's say three) operations
> each of which (with appropriate "unit" element that I ignore
> for simplicity) makes the set into a monoid, these three
> operations can be notated, say, *, +, o, ...
>

Ok, I think I understand your example.

> Now if some domain, such as X or Y, has been passed to a
> subroutine we are writing, but we don't know which, and
> let's say in the routine, this is called Z.
>
> ...
> Say in the routine, we want to do a pointwise multiplication,
> no matter what Z is.
>
>    If Z has Monoid(*$Z) then ...

No. I do not see the conditional above as implementing code
to do such specific things as pointwise multiplication.

>
> Is there ANY definite meaning to the *$Z?

No. There is no such definite meaning.

  If Z has Monoid(*$Z) then ...

only means that the operation *$Z is a monoid operation, i.e.
that it is associative and that there exists an identity in
Z. With this knowledge alone we can do only certain very
limited things mostly involving algebraic simplifications or
other manipulations, e.g. replace (a*(b*c)) with ((a*b)*c)
etc. which might be useful in some contexts. Of course it
might be more powerful when combined with other information
about '*$Z' and it's relation to other operations.

> If you say you are writing generic code, you would have to,
> as Ralf said, test every possible name for pointwise
> multiplication.

No. I presume that in the code where the above conditional is
used, we already know that we are interested in '*$Z' for other
reasons, e.g. it's occurrence in a particular sub-expression
or something like that.

> To avoid this, you need "*" be the ONLY (default) notation
> for pointwise multiplication. This contradicts Martin's idea,
> which is specifically to allow arbitrary notation (namely,
> operator).

I don't think that is Martin's idea. The point is first and
foremost to have a single implementation of the mathematical
concept of 'monoid' independent of any other possible
properties. In Axiom, as it exists now we could do this just
by using declarative axioms such as:

  associative(*)

which can also occur on the right-hand side of 'if ... has ...'
except that in this case we do not get to do nice things like
providing default implementations and we cannot relate
categorical structures like monoids and groups to rings etc.
and we cannot use this to specify algebraic signatures.
I see what Martin (originally based on Gaby's question) is
suggesting as an extension of Axiom's "axiom" and category
system to be more expressive of mathematical structure.

> ...
> In Mathematics, we know what (Integer, *), (Integer, +),
> (Integer, max) mean unambiguously because these notations
> *, +, max have their fixed usual meaning, by convention.
> This convention avoids us having to look up the meaning of
> the operations. Since you must unambiguously know the meaning
> of an operator when you test, you must fix this convention.
> But once this convention is fixed, then 'Monoid(+$Z)' just
> becomes another way of saying AbelianMonoid.
>

No. Convention is just that: a convention. We do not really
know anything by the use of a particular symbol alone; but
of course we might suspect that it has something to do with
addition in some ring since it is annoying if someone flaunts
a convention for no particular good reason.

Something is an AbelianMonoid if its monoid operation
(whatever it is) is commutative.

\start
Date: 14 Mar 2006 01:43:13 +0100
From: Gabriel Dos Reis
To: Bill Page
Subject: Re: Curiosities with Axiom mathematical structures

Bill Page writes:

| I agree with Martin. One should interpret:
| 
|   if Integer has Monoid(*,1)
| 
| as the question of whether F = (*,1) is a functor from the category
| containing Integer to Monoid, the category of monoids.

100% agreed.

| Axiom/Aldor language constraints require us to write
| 
|   Integer has Monoid(Integer,*,1)
| 
| Martin has suggested a method using 'extend' in Aldor to make
| such an assertion by:
| 
|   extend Integer: Monoid(Integer,+,1)

all that makes sense, except that -- upon reflection this a while --
not everythign should be explicit parameter.

Basically, the idea is this.  When have (T, op, e) as a monoid, it is
because the three elements together satisfy some relations.  If I may
borrow some loose analogy, it is like with implicit functions.  The
above means that there are some redundancy in the triple.  Here, e is
uniquely defined by op (maybe non-constructively, but when it exists
it is unique).  Consequently the neutral element is a function of op
and T.  So I would write

     Inetger has Monoid(Integer, *)

     extend Integer: Monoid(Integer, +) with {
         neutral == 0;
     }

\start
Date: 14 Mar 2006 01:44:19 +0100
From: Gabriel Dos Reis
To: Martin Rubey
Subject: re: BINGO, Curiosities with Axiom mathematical structures
Cc: Stephen Watt

Martin Rubey writes:

[...]

| If I ask *something* like Integer has Monoid(+) I'd like to get true.
| If I ask *something* like Integer has Monoid(*) I'd like to get true.
| For other operations I'd like to get false.

100% agreed.

\start
Date: 14 Mar 2006 01:46:21 +0100
From: Gabriel Dos Reis
To: Martin Rubey
Subject: Re: Curiosities with Axiom mathematical structures

Martin Rubey writes:

[...]

| > Imagine you could ask "if M has Monoid(+)..." or "if M has
| > Monoid(*)...". According to which returns true, you would then go on and call
| > (m1 +$M m2) or (m1 *$M m2). Well, but M might have a monoid structure with
| > respect to the operation ".". Do you really also want to ask "if M has
| > Monoid(.)..."? That soon becomes impractical.
| 
| No, this is not an issue about practicality.
| 
| Look at it this way: Suppose "M has Monoid" returns "true". How do you know
| then with respect to which operation M is a monoid? What can you do with the
| information that M is a monoid with respect to some operation?

Exactly!


If we had access to Aldor compiler sources, it would helpful to
experiment with these ideas.

\start
Date: 14 Mar 2006 01:49:00 +0100
From: Gabriel Dos Reis
To: Ralf Hemmecke
Subject: Re: Curiosities with Axiom mathematical structures

Ralf Hemmecke writes:

| hi Martin,
| 
| On 03/13/2006 01:15 PM, Martin Rubey wrote:
| > Ralf Hemmecke writes:
| >
| >> Hi Martin,
| >>
| >> a quick response to the following...
| >>
| >>> There is a simple practical reason why I dislike the idea of asking just
| >>> "Integer has Monoid".
| >>> Imagine I'm programming a package, and I need that a parameter domain M is a
| >>> monoid, so that I can use the monoidal structure, for example for
| >>> multiplying. Well, then simply asking M has Monoid doesn't buy me anything,
| >>> since I won't be sure that M really is a Monoid with respect to "+".
| >> Imagine you could ask "if M has Monoid(+)..." or "if M has
| >> Monoid(*)...". According to which returns true, you would then go on and call
| >> (m1 +$M m2) or (m1 *$M m2). Well, but M might have a monoid structure with
| >> respect to the operation ".". Do you really also want to ask "if M has
| >> Monoid(.)..."? That soon becomes impractical.
| > No, this is not an issue about practicality.
| > Look at it this way: Suppose "M has Monoid" returns "true". How do
| > you know
| > then with respect to which operation M is a monoid? What can you do with the
| > information that M is a monoid with respect to some operation?
| 
| If
|    Monodid: Category == with{ 1:%; *:(%,%)->%; }
| then "M has Monoid" means that M has a 1 and *.

I note the predicate.  Notice that what you say does not contradict
what Martin said.  You're showing a non-parameterez structure --
where the exported constants are not parameterized.  Martin is
interested in case the structure is parameterized.  Consequently the
proper course of action is that the question is asked for specific
arguments. 

\start
Date: 14 Mar 2006 01:50:58 +0100
From: Gabriel Dos Reis
To: William Sit
Subject: Re: Curiosities with Axiom mathematical structures

William Sit writes:

[...]

| Martin:
| 
| If we are allowed to change the notation for the monoid structure so that a set
| can have multiple monoidal structures and we can inquire about it, then some
| code like:
| 
|    If X has Monoid("*") then ...
| 
| would have no definite meaning since you will NOT know the operator in X that
| makes it a monoid.

Huh?

\start
Date: 14 Mar 2006 01:54:40 +0100
From: Gabriel Dos Reis
To: Bill Page
Subject: Re: Curiosities with Axiom mathematical structures

Bill Page writes:

| On March 13, 2006 6:34 AM Ralf Hemmecke asked:
| > ... 
| > But here the question to our category theory experts:
| > Since Monoid is something like (*,1) would it make sense
| > to speak of a category (in the mathematical sense) of
| > 
| >    monoids that have * and 1 as their operations              
| >       (1)
| > 
| > ? Morphisms would respect 1 not just the identity element 
| > with respect to *. And for each morphism f we would have
| > f(a*b) = f(a)*f(b). Of course as operations the two * above
| > are different but in that category they have to have the same
| > name. (No idea whether this makes sense, but it seems that
| > this is the way as "Category" it is implemented in Axiom/Aldor.)
| > 
| > Then, of course, (N, +, 0) is not an object in the category 
| > given by (1).
| > 
| 
| I keep trying to answer these questions but I am not sure I
| would like to classify myself as an "expert" in category theory.
| :) But here goes ...
| 
| In category theory **Mon** (** means written in bold face font)
| consists of all monoids (as objects) and all monoid homomorphisms
| as morphisms. This does not say anything directly about what
| operation are present "inside" the objects of the category. 

Agreed.

| It is one of the goals of category theory to define what we mean
| by 'monoid' entirely in terms of the homomorphisms and perhaps
| statements about the existence of "special" objects).
| 
| It turns out that an individual object of **Mon** is also a
| category. It consists of a single object. The morphisms are words.
| There is an identity morphism that we can denote '1'. Composition
| is just the monoid operation. (N, +, 0) is such an object of
| **Mon**.

yes, but there are not very interesting categories :-)

| To make a connection with categories in Axiom, I would want to
| say that 'Monoid' represents the category **Mon** while
| 'Monoid(*$INT,1)' denotes an object of **Mon**. In fact both
| of these are categories in their own right.

Indeed.

| This brings up a design feature of Axiom and Aldor that I do
| not really like. Axiom and Aldor implement a strict two-level
| type class hierachy that distinquishes between categories and
| domains. Just as in category theory, I think this distinction
| is necessary in order to build mathematical constructs. But
| categories and domains should not remain strictly separate.
| There are many times when we might want to treat a category as
| a domain in some other category. We sometimes need to be able
| to "flatten" this hierachy and consider really only one kind
| of type.

I guess it depends on where we want to go.  But, you're right that
since Aldor already has Type:Type, the distinction between category
and domain becomes very artificial.

\start
Date: 14 Mar 2006 02:00:34 +0100
From: Gabriel Dos Reis
To: William Sit
Subject: Re: Curiosities with Axiom mathematical structures

William Sit writes:

| Bill:
| 
| Rather than reply to your ??? point by point, what I was trying to say is that
| in a set X equipped with several (let's say three) operations each of which
| (with appropriate "unit" element that I ignore for simplicity) makes the set
| into a monoid, these three operations can be notated, say, *, +, o, and these
| are programmed in the domain constructor X using three formulas (but without
| looking at the code, you won't know which formulas are used or which matches
| with a particular notation). Assume that these operators are not following any
| particular convention (so if X is a set of real-valued functions on a finite
| field, * could mean 'max', + could mean pointwise multiplication, and o could
| mean pointwise addition).

Membership is by assertion, so I don't think your objection has with
respect to Martin's idea has anyting fundamental -- the compiler is
not guessing. 

\start
Date: Mon, 13 Mar 2006 21:39:19 -0500
From: Bill Page
To: Gabriel Dos Reis
Subject: RE: BINGO, Curiosities with Axiom mathematical structures

On Monday, March 13, 2006 7:32 PM Gaby wrote:

> ...
> Bill Page writes:
>
> >
> > Also, I think you should write:
> >
> >    square: % -> %;
> >    default {square(t: %): % == m(t pretend T, t pretend T)
> >      pretend %
> >
> > although apparently the compiler does not worry about this
> > since your representation of the domain MyWord below is the
> > same as the operation that you pass to MyMonoid.
>
> we should also probably find a way to minimize the "pretend"s :-)
>

The use of 'pretend' has to do with the issue of representation.
I suppose it would be better to write:

   default {
     Rep == T;
     square(t: %): % == per(m(rep(t), rep(t))
   }

Really this is mostly sugar since we know that rep and per
are just implemented as macros involve Rep, %, and pretend.
But I suppose that a more type-safe implementation might
be possible.

It seems to me that both SPAD and Aldor are more specific about
representation than most other languages (at least those that
I know sufficiently well). I think the semantics are motivated
by the mathematical example of an abstract group and it's
underlying representation, e.g. as a matrix with a particular
structure. But I am still rather unsure about how best to
understand this construct. And further 'Rep', 'rep' and 'per'
do not seem to be "properly distinquished" syntactically
given the important role they play in the construction of
domains.

I would be very interested in your thoughts about this.

-------

Probably what we really want to write here is:

  MyMonoid(m: (%, %) -> %): Category == with {
     square: %-> %;
     default {square(t: %): % == m(t, t)}
  }

In which case

  extend MyWord: MyMonoid(c)

can only make sense if c is defined in MyWord (% in this
context means the domain). This is kind of an "inner"
extension of the domain.

Unfortunately neigther Aldor nor SPAD can compile something
quite this generic.

\start
Date: Mon, 13 Mar 2006 22:17:45 -0500
From: Bill Page
To: Gabriel Dos Reis
Subject: RE: Curiosities with Axiom mathematical structures

On Monday, March 13, 2006 7:43 PM Gaby wrote:

> ...
> Bill Page writes:
>
> > Axiom/Aldor language constraints require us to write
> >
> >   Integer has Monoid(Integer,*,1)
> >
> > Martin has suggested a method using 'extend' in Aldor to make
> > such an assertion by:
> >
> >   extend Integer: Monoid(Integer,+,1)
>
> all that makes sense, except that -- upon reflection this a
> while -- not everything should be explicit parameter.
>
> Basically, the idea is this.  When have (T, op, e) as a monoid,
> it is because the three elements together satisfy some relations.
> If I may borrow some loose analogy, it is like with implicit
> functions.  The above means that there are some redundancy in
> the triple.  Here, e is uniquely defined by op (maybe non-
> constructively, but when it exists it is unique).  Consequently
> the neutral element is a function of op and T.

No. This is an additional assumption that is not part of the
mathematical definition of a monoid. Normally in mathematics we
would say:

  Let 'M(T,op,e)' be an monoid.

Nowhere do we imply that 'op' uniquely determines 'e'. In addition
to the associativity of 'op', we only require that op(e,x)=op(x,e)
for all x in T.

At most we can say that 'M(T,op,e)' uniquely determines 'e',
but that is trivial.

In Axiom we would like to interpret such a declaration as a
specification of the substructure of some domain (e.g. Integer)
as being isomorphic to some monoid, e.g. M(Integer,+,0). As such
it inherits a binary operation '+' and a constant '0' plus some
(implicit) axioms about their relationship. Martin's construct
turns this around a little since for the sake of Aldor '+' and
'0' must be pre-defined in Integer. The 'extend' is merely adding
the implicit axioms and additional default (ie. monoid-dependent)
operations (if any).

> So I would write
>
>      Integer has Monoid(Integer, *)
>
>      extend Integer: Monoid(Integer, +) with {
>          neutral == 0;
>      }
>

No.

The Axiom/Aldor "language constraints" that I was referring to
above prevent us from writing more simply:

   Integer has Monoid(*,1)
   extend Integer: Monoid(+,1)

where the domain % of '*' and '1' is to be understood from
context. See also my previous message re:

  Monoid(m:(%,%)->%, id:%): Category == with { }

\start
Date: Tue, 14 Mar 2006 00:30:24 -0500
From: Bill Page
To: Ralf Hemmecke
Subject: aldor type satisfacton
Cc: Stephen Watt

Ralf,

>
> On March 13, 2006 8:34 AM Ralf Hemmecke wrote:
> ...
> >
> >  aldor -laldor -grun dirprod.as
> >  2 has 2: T
> >  2 has 3: T
> >
> > it can be understood with my previous explanation.
>

On Monday, March 13, 2006 10:50 AM I wrote:
> I don't know what semantics to associate with the use of a
> member of some domain on the right-hand side of 'has'. In
> Axiom I only see
>
>   if <domain> has <category>
>
> In the Aldor documentation I have read a discussion of how a
> domain is said to "satisfy" a category, but I do not know how
> to apply this in your example above.
>

I am sorry, please ignore the above comment. I was confused by
the fact that you did not provide the code for "dirprod.as" in
your email. I presume that it was meant to be analogous to the
output ""true+false" of "dirprod.spad":

  foo(): OutputForm ==
     b2: Boolean := (DirProd(2, Integer) has _
       DirProdCat(2, Integer))
     b3: Boolean := (DirProd(2, Integer) has _
       DirProdCat(3, Integer))
     (b2::OutputForm) + (b3::OutputForm)

Section 7.7 of the Aldor User's Guide defines how type satisfaction
is supposed to work. In fact Axiom seems to implement most of this.
The only exception I found was the use of ().

Reviewing 7.7, I think the result from the current implementation
of Aldor is wrong according to it's own documentation. :(

> > If you look at DirProdCat as a function then clearly
> >   DirProdCat(2,Z) = DirProd(3,Z) = with{first:%->Z}
> > so why would one want another output?
> >
> > ----------- dirprod.as
> > #include "aldor"
> > #include "aldorio"
> >
> > define DirProdCat(n: Integer, R: Type): Category == with {
> >    first: % -> R;
> > }
>
> Well, clearly the application of the category 'DIRPCAT(2,INT'
> makes good sense in Axiom, don't you think? How else would you
> propose to define this category? How could we do without it
> in defining the domain 'DIRPROD(2,INT)'? To me this is the
> reason why we want another output from your example Aldor
> program. I would conclude that in fact internally (as you
> already said above):
>
>   DirProdCat(2,Z) ~= with{first:%->Z}
>
> There must be something additional on the right-hand side
> that is not reflected in the syntax of the category constant
> 'with' clause.
>

Refer specifically to section "7.5 Subtypes" of the Axiom Users
Guide:

"Note that Aldor is constructed so that a domain is only a
member of a named category if it explicitly inherits from the
category -- not if it merely exports the same collection of
(explicit) declarations."

-------------

So it seems clear to me that the fact that:

MyMonoid(T: Type, m: (T, T) -> T): Category == with {
    square: %-> %;
    default {
      Rep == T;
      square(t: %): % == per m(rep t, rep t)
    }
}

MyInteger1: Join(ArithmeticType,MyMonoid(Integer, *$Integer)) == =
Integer
add;
MyInteger2: ArithmeticType == Integer add;
extend MyInteger2: MyMonoid(MyInteger2, *$MyInteger2) == add;
...

macro {
     Z == Integer;
     M1 == MyInteger1;
     M2 == MyInteger2;
}
main(): () == {
   stdout << "1: " << (M1 has MyMonoid(Z, *$Z)) << newline;
   stdout << "2: " << (M1 has MyMonoid(Z, +$Z)) << newline;
   stdout << "3: " << (M2 has MyMonoid(M2, *$M2)) << newline;
   stdout << "4: " << (M2 has MyMonoid(M2, +$M2)) << newline;
}
main();
Returns:

1: T
2: T
3: T
4: T

------

is certainly incorrect. I expect:

1: T
2: F
3: T
4: F

\start
Date: Tue, 14 Mar 2006 08:35:56 +0100 (CET)
From: Bertfried Fauser
To: list
Subject: xpoly

Hi *,

currently I qm on a conference at CIRM where Prof Petitot, the author of
xpoly, is also present. I asked him about the package and further
documentation. His problem seems to be the language, so he porobably could
be helpful if contacted in french. If any question about xpoly arose
recently I can deliver it to him.

\start
Date: Tue, 14 Mar 2006 03:05:42 -0500
From: William Sit
To: Gabriel Dos Reis
Subject: Re: Curiosities with Axiom mathematical structures

Gabriel Dos Reis wrote:
> 
> William Sit writes:
> 
> | Hi Gabe:
> |
> | Gabriel Dos Reis wrote:
> | > William Sit writes:
> | >
> | > |  Bill Page writes:
> | > |
> | > | > | I don't think there is any essential reason why SemiGroup and
> | > | > | Monoid could not be implemented in the way you suggest. For
> | > | > | example:
> | > | > |
> | > | > | )abbrev category SGROUP SemiGroup
> | > | > | SemiGroup(m:Symbol): Category == SetCategory with
> | > | > |       m: (%,%) -> %    ++ returns the product of x and y.
> | > | > |       associative(m)
> | > | > |
> | > | > | )abbrev category ABELSQ AbelianSemiGroup
> | > | > | AbelianSemiGroup(m:Symbol): Category == SemiGroup(m) with
> | > | > |       abelian(m)
> | > | > |
> | > |
> | > | Yes, there are no theoretical reasons, but there are plenty of
> | > | practical ones.
> |
> | > In fact, practicality dictates that the implementations in Axiom/Aldor
> | > closely follow the mathematical structures.
> |
> | You probably misread my response to Bill.
> 
> After re-reading the long thread that followed, I do not believe so.
> 
> I think I correctly read your answer and I correctly deduced a fundamental
> mismatch between your conception of what a monoid is and should be
> written and the demand of writing a computer program to express
> mathematical structure.
> 
> | I was saying there are plenty of practical reasons NOT to implement
> | in the way suggested, but no theoretical reasons NOT to implement
> | the goal you suggested, in some way.
> 
> Sorry, none of the reasons you enumerated were "practical".
> They look to me as a choice that "looked good a the time", but turned
> out to be broken but a heartily desire to stick to it instead of
> evolving.   It looks to me more ideological than practical.
> 
> It negates practice.
> 
> | > For example, the only
> | > assumption  I need to define the power of an element is that its domain
> | > has a monoidal structure.  From software engineering point of view,
> | > Practicality dictates that I should not have to write duplicate codes,
> | > one for additive operation, one for multiplicative operation when the
> | > underlying mathematical structure is the same.  That is
> | > the least I expect from a non-mathematically-oriented system.
> |
> | Agreed in theory, not in practice.
> 
> Wrong; I'm talking of practical issues.

I think we have different notions about what "practical" means. 
 


> | We should distinguish two issues: (1)
> | derived  operations that depend only on the defining operations should be
> | generically implemented and inherited, and (2) how to handle the notations
> | (equivalently, identifiers in computer science terminology) for the defining
> | operations and derived operations.  Notations (resp. identifiers) are extremely
> | important in mathematics(resp. computer programming). Mathematics can only
> | progress and make strides when good notations are invented AND agreed to.
> 
> notation is important, and so is semantics.  When syntax takes precedence over
> semantics, the result is empty sophism and boring rethorics.

> | Examples are the notations for differentiation and integration.
> 
> Sorry, they do not illustrate in a anyway why a AbelianMonoid is not a
> Monoid.

They weren't meant to.
 


> | A software system that deviates from the universally accepted
> | mathematical notations, even if for the sake of valid ideals,  will
> | not be usable and at best be hardly usable.
> 
> Is it more important to derive from alleged universal notation (when
> in fact the notation is highly ambiguous, and the universality is just
> mirage) than derive from universal semantics?  Which mathematical
> authority do know and universally agreed on that do not recognize an
> Abelian monoid as a monoid?

I was referring to the notation for addition in a ring. This does not mean every
abelian monoid must use + for its operation! I understand you point for
detaching the notation for the operation from the operation itself in regard to
its role in the algebraic structure,  but can you really compute using the
operation without a notation (or function name)?



> | Computer programs can work correctly only if identifiers are scoped
> | correctly and such scoping should be transparent when identifiers are
> | overloaded.
> 
> That is what you claim, and yet we have no evidence that Axiom/Aldor
> have "correctly scoped identifiers".  Furthermore, we have to see
> evidence of why it is desired that such "scoping should be transparent
> when identifiers are overloaded."  As a matter of fact, we have
> examples (in this thread) that suggest that the transparency is far
> from being what we need.

'we have no evidence that Axiom/Aldor have "correctly scoped identifiers"' does
not mean there is evidence that Axiom/Aldor incorrectly scope identifiers, and
does not contradict what I claim, which is not specific to Axiom/Aldor.  And
"having examples that suggest the  transparency is far from being what we need"
is in itself an admission that tranparency is desirable. 




> | The concept of a ring is almost omnipotent in all branches of
> | mathematics, and the standard notations for the multiplication (*)
> | and addition (+) are adopted.
> 
> You are missing an important fact: most of the mathematical texts use
> notation invented when computer programs were not the primary focus of
> the discourse when where context helped *humans* to automatically
> disambiguate when more operations are involved.

Historic use is not the reason. We are quite capable of using any other
substituted notations. But a commonly accepted notation and distinguishing
different operations by different names or notations facilitate communication.
This ease of communication should have a high priority and design goal, whether
it is between humans, between programs, or between humans and programs.  




> | You may almost forget about that a ring is a monoid wrt to * and an
> | abelion monoid wrt + because what is important to a ring is the two
> | together, how they interact via the distributive laws.
> 
> No, you're wrong: I did not forget that.

Sorry. Don't take things personally. Here "You may" meant "One may as well".



> | A practical way to support the structure of a ring requires these
> | two separate notations.
> 
> Wrong: a practical way to support them is not to prejudge of syntax in
> more general contexts, and stick to the *algebraic structure* being
> modeled.

My "practical" is not the same as your "practical". You meant "general" and I
meant "common", "easy to use and understand". Neither is wrong. It's just a
different perspective. If you can support a ring structure by sticking to the
algebraic structure only, fine, as long as you don't make programming more
difficult for those who want to use * and +.




> | Even in the simple case of your example for repeated operation
> | (which you called "power"), the two operations * and + will produce
> | (and should produce) outputs in two different notations: x^n (power)
> | and n*x (multiple). In this case, the repeated operations in fact
> | occur both in an *abelian* submonoid setting even if multiplication is
> | non-commutative.
> 
> Well, unless you're a proposing a new mathematics you reduction is
> again wrong -- because you're prejudging semantics.  Again take
> 
>     f (x, y) = x * y + x + y
> 
> on integers with usual addition and multiplication, then (N, f, 0) is
> another Abelian monoid structure.  Computing the repeated operation
> does not yield n * x or x^n.  Please stop confusing syntax with the
> *structure*.

Good, let's just talk mathematics :-).  Please do not confuse notation with
semantics. I was only stating that the mathematical convention is to denote the
n-fold self multiplication by using an exponential notation, whereas the n-fold
self addition uses a scalar multiplication notation. I place no meaning
whatsoever on the multiplication * or addition + operations. In your example (N,
f, 0), if one uses * to stand for f, one would still use x^n for the n-fold
operation. But of course, that would be confusing because * is already used to
mean the usual multiplication. So one has to use a different notation. Since
*you* are creating this new operation, *you* can use any notation you like (I am
talking about notation as a shorthand for the n-fold product, not what the
result should be, as a polynomial function in x).

Back to computing: the question is how are you going to make Axiom understand
that (N,f,0) is an AbelianMonoid? (Never mind that it is also a Monoid). This is
a technical problem that so far no one has offered a solution. In fact, there is
no need to bring the derived function 'power' into the structure of a monoid.
The function 'power' can be implemented in a package, and parametrized with any
binary operation with a calling sequence like power(f, n, x).




> [...]
> 
> | So I hope we need not argue a third issue: (3) maintaining standard
> | notations for the defining operations in common algebraic structures.
> 
> but standard notation of what?  

Didn't I say: "standard notations for the defining operations in common
algebraic structures"? But clearly, you would take issue.




> Computer programs have very different
> requirements from free mathematical discourse.

I agree (but I would prefer using "limitations" for "requirements"), but what's
your point?




> | I think your ideal of avoiding "duplicate codes" (much like the
> | ideal of sharing dll libraries) is misplaced.
> 
> Please, if you want to discuss shared dll libraries, let's do that in
> a different thread.  The issue at hand is too important to be left
> diluted in questionable analogies.

Do you have to be so picky? (Below, you raised the OO issues.)
 



> | In order to avoid duplicating code due to the dual use of * and + in
> | the monoid structures, one will have to, as admitted throughout
> | these discussions by everyone, ADD tons of code and in the end
> | making writing software for a ring more difficult, not less. Not
> | only that, I doubt if the experts here could agree to how that
> | additional code should be written, even if everything were started
> | from scratch.
> 
> Please, what are you tlaking about?

Read earlier posts, or just these quotes from below:

  > The proposed change certainly has its set of problems [...] 
  > To start with, the proposal is not
  > complete :-)

  > | If you think now one can redo Axiom in a better way, we are all for
  > | it. What's your priorities? (in other words, when can you start? :-)
  > 
  > What about give me unrestricted access to Adlro compiler sources? ;-)
  > (and I'm serious)




> | I think a proper way to "allow" the kind of identification of underlying
> | mathematical structures that are the same is the concept of
> | "isomorphism".
> 
> But not all structrures are isomorphic, even in the same
> (mathematical) category.  We do not need to recover from yet another
> set of misguided and misplaced isomorphims.

Did I say or imply that any two monoids are isomorphic? 




> [...]
> 
> | Let's say in Monoid, I used & for the defining monoid operation. If I want to
> | form a monoid domain with set Integer and operation #, (Integer, #), I would
> | have to specify to the compiler an isomorphism.  The compiler would have to
> | execute this isomorphism by replacing each occurrence of '&' by '#' in the
> | category definition temporarily before matching the domain
> | signatures with the category signatures. This necessitates that in
> | the category definition of a monoid, and in the domain code of an
> | actual monoid, we can identify and separate the defining operations
> | from the derived operations -- which is currently not the
> | case. Let's assume this is done nonetheless.
> 
> You are using confusing terminologies to say exactly what I'm proposing.

Unfortunately, English is such that what is confusing to one may be clear to
another. If my language is confusing, how can you deduce that I am saying
"exactly what I'm [you are] proposing"? (In fact, it looks like I was not).




> | Then the generic code of derived operations (such as 'square' or
> | 'power'), if available, will have to be translated, duplicated, and
> | inserted in the domain for correct signatures and implementation.
> 
> I disagree.  There is no inherent reason why they should be
> duplicated.  The operation '&' is a parameter! 

If you read more carefully, you will note that I did not say '&' is a parameter.




>  Whether the
> instantiation should be through copy-and-build or sharing is a
> completely different issue.

Do you mean "compilation" instead of "instantiation"? Anyway, don't you agree
that a discussion of the mechanisms would be helpful?
 



> [...]
> 
> | > If the system does not let one do that, then the system is practically
> | > defective :-)
> |
> | All systems have defects. Be realistic!
> 
> No kidding.
> 
> I just release one last week.

You meant you just released a system with no defects? Provably?




> [...]
> 
> | > |  Indeed, how is a user to know what symbol was used, say, for the
> | > | operations? What if the user instantiates Integer with both * and +
> | > | for the same operations in two instances?
> | >
> | > When both will be in scope.  If the user uses * with Integer, the
> | > system knows that (*, Int) is a monoidal structure.  Same if
> | > (+, Int).
> |
> | I meant using * for multiplication of integer in one instantiation,
> | and using + for multiplication of integer in another instantiation,
> | two notations for the same set and operation. (I am not advocating
> | this! see original message for the context, please).
> |
> | > | Can a compiler or interpreter catch this?
> | >
> | > Yes, definitely.
> |
> | Really? The two copies of the multiplicative monoid of integers are
> | compiled at different times and instantiatiated in the SAME
> | interpreter session. Can the interpreter execute something like
> | 3*4+5 correctly and give 60 (without package calls)? What if we have
> | two copies of the ring of integers where in one the notations for *
> | and + are interchanged? When this sort of arbitrary notations is
> | allowed, every function call need to be a package call or else it
> | would be a nightmare to explain all the "strange" answers. (The
> | isomorphism mechanism does not seem to solve this problem).
> 
> Well, programming languages have been dealing with such issues for
> long time now.  Either, you permit nonsensical uses (because in
> general you can't prevent all of them and yet remain useful); 

Why is that considered "nonsensical"? If I package call each operation, it still
makes perfect sense. But it would be clumsy, that's all. The compiler is not the
culprit here. In the scenario when arbitrary notations are allowed, the compiler
behaves correctly and need not flag any errors or even warning (because the two
domains are compiled at different times). I won't prejudge such constructions as
not useful (for example, it could have a pedagogical value).




> or you
> do minimal checking when same operations should be defined
> consistently (programming languages like C++ calls it the "One
> Definition Rule", and do not require compilers to diagnose all of
> them, but there are known systems in production use that have
> implemented them for the vast majority part of it and can handle such
> cases).

Note that you brought up C++ (an OO language). I don't see how "One Definition
Rule" is related to this. In the above scenario, each operation has one
definition only per domain,  and the two copies of the ring of integers are
different domains.





> | > | If not, it would be a nightmare of bug reports.
> | >
> | > It would be a nightmare only if one takes the rules that a type has a
> | > unique algebraic structure.  That is both theoretically and practically
> | > false.  See the examples (+, NN), (*, NN), (NN, max) I gave earlier.
> |
> | Quite the contrary. When a type has a unique algebraic structure (I
> | presume you meant only default notations for its defining operators
> | are allowed),
> 
> No, please do take note that I'm distinguishing structure from syntax.

You mean using package calls? I agree that would let the compiler parse the
expression unambiguously.
 



> | there is no ambiguity possible like the 3*4+5 above.
> 
> Utimately, you have to agree that a symbol resolves to what it
> implements -- even mroe so in your OO-centric view of mathematical structures.

Only when the compiler is given all the information. BTW, I don't understand why
you label my view as OO-centric. You are the one who brought up C++, and use C++
syntax below. So your non OO-centric view is to detach any object from a
mathematical structure? (no the underlying set, no the operations? an
isomorphism class?)
 



> | I don't disagree this state is non-optimal, but the proposed state
> | has its problems. Your examples show three *different* binary
> | operations with three *different* identifiers.
> 
> Again, identifiers are not algebraic structures.

Identifiers are needed to name or notate the operations in an algebraic
structure. Would you care to give a non OO-centeric view definition of
"algebraic structure"?
 



> The proposed change certainly has its set of problems -- but nothing of
> what you said above is about them.  To start with, the proposal is not
> complete :-)

I thought we are all exploring the issues here. 
 



> | If you want to inherit say the function 'square' for each, you need
> | to, as explained above, establish three isomorphisms to the
> | fictitious domain % in the categorical definition and translate,
> 
> Please do notice that 'square' implicitly depends on the monoid
> operation passed as parameter to the monoid structure.  Consequently,
> if I wanted to have different *instances* of it simultaneously in the
> same scope, then I need to give different names to those *instances*
> If I want to have them simultaneously in the *same scope*, then
> obviously I need to give different names to their *instances*, e.g.
> 
>      doublePlus == Monoid(T, +).square
>      doubleTime == Monoid(T, *).square

In your OO-syntax, why would you need to rename the operations? The right hand
sides are already different (so your OO-syntax actually provides the correct
scope). In Axiom's case, the type of the operands dictiate the selection of the
operation. It is not enough to say x:T to apply square(x), you must have
x:Monoid(T,+) or x:Monoid(T,*). Once this is declared correctly, then x.square
(in OO-syntax) has no ambiguity.




> [...]
> 
> | It would be all the more of a problem when all the three monoid structures
> | co-exist in the *same* domain (multiple inheritance).
> 
> it would be a problem only if one sticks to an ill-suited OO-centric
> view.  Other models exist, and should be explored.

I wasn't the one who used OO-syntax. I was discussing only the Axiom model.
 



> | Notice that while the domain (NN, +, *, max) exists, the domains
> | (NN, +), (NN, *), and (NN, max) are transiently constructed during
> | compilation only! There is no (NN, +).NRLIB for example. Besides,
> | you can only have ONE signature 'square: % -> %' in the domain
> | (NN, +, *, max), not three.  This possibly is an important reasons why
> | AbelianMonoid does not descend from Monoid.
> 
> you're confusing the current ill-suited OO implementation with what
> should happen.  If there is no theoretical reason why that should
> happen, then you better off revise your implementation model.

What "ill-suited OO implementation"? and of what? I see, to you, there are only
algebraic structures, no domains. Sorry, that is not the Axiom I know.




> | There seems to be no good way to solve this multiple inheritance problem.
> 
> Abandon, OO and that ill-suited multiple inheritance stuff, when not
> helpful, -- e.g. here.

What has the problem to do with OO? What is "here"?




> [...]
> 
> | Needless to add, such automated translation, duplication and insertion are
> | simply not supported currently (see SandBoxMonoid).
> 
> No.  Please see above.

Here?





> [...]

> many systems were designed more than 30 years ago.  At the time, their
> designers tried to do the best possible at their time.  Those who
> refused to evolve died.  Since the 1970s advances have been made in
> understanding type systems; it would be singular that Axiom refuses to
> evolve and stick to OO-centric views we now know does not work well.
> We can't require unreasonable degree of foresight from designers, but
> it is unreasonable that the system refuses to evolve -- if it ever
> wanted to survive.

I don't dispute that wisdom. But survival (for software) depends on far too many
aspects than just a good design. Maple and Mathematica both survive.  
 



> [...]
> 
> | Coherence, if I understand what you meant by that, requires confluence in
> | rewriting rules.
> 
> No, you misunderstood what I was saying.

I'm listening ...




> [...]
> 
> | If you think now one can redo Axiom in a better way, we are all for
> | it. What's your priorities? (in other words, when can you start? :-)
> 
> What about give me unrestricted access to Adlro compiler sources? ;-)
> (and I'm serious)
> 
> [...]
> 
> | > | I do not question the theorectical advantage of rebuilding all
> | > | algebra based on properties of operators (there is research in
> | > | theory of operads which would support such a design) but I doubt
> | > | their practicality, especially when the notation for the operators
> | > | can only be known dynamically at run-time.
> | >
> | > Well, I'm approaching the issue more from a *practical* point of view
> | > than a theoretical point of view.  As the system currently stands, in
> | > practice, I cannot simply and clearly write once a generic function
> | > for monoidal structures and expect it to work for both for Abelian and
> | > non Abelian monoids.
> |
> | This is not true. First, you don't mean non-Abelian monoids, you meant
> | not-necessarily Abelian monoids (or simply monoids).
> 
> I meant what I said.

A non-Abelian monoid means a monoid that has at least a pair of elements that do
not commute with respect to the monoid operation. But you sure can write a
package and your function with the monoid operation as a parameter. You do not
need to recognize an AbelianMonoid as a Monoid to do that. 




> | An abelian monoid IS also a monoid and hence it will work!
> 
> Oh really?
> 
> | (You just need to redefine AbelianMonoid to use * instead of +,
> | showing it is not an inherent weakness of the system but just a
> | matter of notations).
> 
> You are displaying an incoherent attitude in this matter, and at this
> pointI don't know how serious you're.

I am as serious as you are. The only reason why currently AbelianMonoid is not
descending from Monoid is because of notation! If you use * for all monoid
(abelian or not) operations, you can have an AbelianMonoid descend from Monoid.
(You can't do this multiple times in one domain, but that is a totally different
problem, one of multiple inheritance).




> 
>    f(x, y) = x * y + x + y
> 
> f uses both * and +.  Now, (N, f, 0) is an Abelian monoid, so you
> propose that in the same session I rename f to *, * to + and + to ?
> You're joking, right?

You just made my point. You already used * and + as Axiom convention now
dictates. And renaming them (which is an allowed consequence if you allow
passing the operation to Monoid as a parameter) would allow this type of crazy
twisting of notations. This is my objection of passing operators as parameters:
it can be abused.
 



> [...]
> 
> | > | As already well-known, with the current status, all properties of
> | > | operators are declarative and not verified.
> | >
> | > My problem is simpler than that.  I'm not asking for the definition of
> | > the algebraic properties of operators.  I'm trying to have a way to
> | > convince Axiom/Aldor to support sound software engineering practice.
> | > Even better if I can take the standard library as an example.
> |
> | No, you are not discussing "sound software engineering practice". You are
> | arguing about how to inherit abstract algebraic properties.
> 
> No.  The ill-suited inheritance stuff is just one irritating
> manifestation of "sound software engineering practice".  Don't shout
> the messenger.


Did I shout? Inheritance is a mathematical concept: to build a more advanced
algebraic structure based on a simpler one. It is not just an OO-concept. 




> [...]
> 
> | I understand your points. There are many monoid structures in any algebraic
> | object because monoid is a very simple structure.
> 
> No, the problem is not because it is a simple structure, it is because
> it is a *structure* and the current system confuses structure with
> syntax.  That is the root of the problem.

Wait a minute. Are you saying you can say X is a monoid without saying what
binary operation defined on X makes it a monoid? That operation IS part of the
structure. It has nothing to do with syntax if you only talk mathematically, You
still need to notate the operation if you want to do any computation. 




> [...]
> 
> | Have you seen ANY paper which interchanges the * and + notations in
> | a commutative ring?)
> 
> That is beside the point.  The issue is not whether * should be
> interchanged with +.  

Sorry, that is the whole point! I don't see, even in mathematics, how you can
talk about an abelian monoid and monoid without the operations. Sure, it does
not matter how you call the operation, but you cannot talk about it without
referring to it by some name. Even if you think about a monoid as a set with an
unnamed operation (much like a univariate polynomial does not need a name for
its main variable), when you have multiple monoid structures for the same
underlying set, you will need to refer to them by different names (again, much
like in multivariate polynomials, you need a set of variable names).




> The issue is how to simply design the system so
> that AbelianMonoid is indeed a Monoid.

Without worrying about notation, and just purely on the mathematics, that is
easy.
Unfortunately, that causes more problems than it solves. And, the problem and
design will be anything but simple. Its complexity lies not in the concept,
which is simple, and not even in a straight forward implementation, but is
because of the tangle with notation, inheritance, multiplie inheritance, etc.

\start
Date: Tue, 14 Mar 2006 03:56:20 -0500
From: Bill Page
To: list
Subject: Aldor %% bindings

Ralf, and other Aldor experts;

Section "7.5 Subtypes" of the Aldor Users Guide says:

  Note that Aldor is constructed so that a domain is only a
  member of a named category if it explicitly inherits from
  the category -- not if it merely exports the same collection
  of (explicit) declarations\1.

Footnote \1 says:

  In the current implementation, each named category C
  implicitly exports a symbol named \%%" with type C (see
  Section 8.12), whose presence is tested for in checking
  category membership.

Note: 8.12 is a typo. It should say 8.11.

Section "8.11 With" says::

  A 'with' expression also defines a constant named "%%" for
  each category from which the 'with' expression inherits.
  The type of %% is the inherited category, and the value
  is the domain viewed as a member of that category...
  The %% bindings are generally most useful for checking
  conditions.

-------

Can anyone explain the usage of %% and give some examples
where it is used to "check conditions"?

What does it mean to be a "domain viewed as a member of
a specific category"?

Apparently %% can have multiple bindings. About the
example in section 8.11 we read that:

  In the example, %% bindings are in scope for the
  following categories:
  BinaryAggregate, BooleanArithmeticType,
  BoundedFiniteLinearStructureType Boolean,
  BoundedFiniteDataStructureType Boolean,
  FiniteLinearStructureType Boolean, PrimitiveType,
  and so on.

How can I access the value (associated domain?) of a
particular binding?

Any hints about how to understand this would be greatly
appreciated.

\start
Date: Tue, 14 Mar 2006 12:24:48 +0100
From: Ralf Hemmecke
To: Bill Page
Subject: re: BINGO,Curiosities with Axiom mathematical structures
Cc: Stephen Watt

Hi Bill,

> Hmmm... surely this must have been considered in the design of
> Aldor. Are there no Aldor categories like DIRPCAT that take a
> member of a domain as a parameter?

All categories in libaldor either take no parameter or just domain 
parameters.

In libalgebra, I could only find

define ResidueClassRing(R: CommutativeRing, p: R): Category
define DirectProductCategory(dim: MachineInteger, T: ExpressionType):

So it the same problem occurs.

 > This seems like a natural mathematical construction to me.

I somehow agree, but unfortunately, we have no clear statement from the 
original designers about how Aldor's "Category" relates to mathematical 
categories or order-sorted algebras. There is only the PhD thesis of 
Doye. Maybe we should try to contact and ask people that appear in the 
original Axiom book personally about it. A bit of history would 
certainly be of value for Axiom.

>> If you look at DirProdCat as a function then clearly
>>   DirProdCat(2,Z) = DirProd(3,Z) = with{first:%->Z}
>> so why would one want another output?
>>
>> ----------- dirprod.as
>> #include "aldor"
>> #include "aldorio"
>>
>> define DirProdCat(n: Integer, R: Type): Category == with {
>>    first: % -> R;
>> }
> 
> Well, clearly the application of the category 'DIRPCAT(2,INT'
> makes good sense in Axiom, don't you think?

Well, since (I think) the category of pairs of rings makes sense, it 
should also make sense in Axiom.

> How else would you propose to define this category?

I have no idea, how to define this category in Axiom in another way.
But obviously, there is a problem if one wants to check whether a domain 
satisfies that category.


> How could we do without it  in defining the domain 'DIRPROD(2,INT)'?

Hmm, I guess you would not like

   define DirectProductCategory(T: Ring): Category == ...

since that bears less information.

> To me this is the
> reason why we want another output from your example Aldor
> program. I would conclude that in fact internally (as you
> already said above):
> 
>   DirProdCat(2,Z) ~= with{first:%->Z}
> 
> There must be something additional on the right-hand side
> that is not reflected in the syntax of the category constant
> 'with' clause.

Well, you are in some sense right. As defined in the Aldor User Guide 
Section 7.5 if you define

define CatA: Category == with {foo: % -> %}
DomA: with {foo: % -> %} == add {foo(x:%): % == x}

then "DomA has CatA" returns false, because DomA is not explicityly 
declared to be of type CatA. There is this invisible symbol %% for each 
category from which a domain inherits. So in that sense

   CatA ~= with{foo: %->%}

Ralf

PS: Enjoy the output

aldor -grun -laldor cattest.as
A has CatA        : F
A has CatA 3      : F
A has CatA 3      : F
A has CatA Integer: T
A has CatA Boolean: F
-----------------
B has CatA        : F
B has CatA 2      : T
B has CatA 3      : T
B has CatA Integer: F
B has CatA Boolean: F

of the following program... ;-)

It seems that domains as parameters are treated differently than 
elements. Look especially at

define CatA(R: Type): Category == with {bar: () -> ()}

the "with" does not involve R in any way.

---- cattest.as ------------------
#include "aldor"
#include "aldorio"

define CatA: Category == with {foo: %->%}
define CatA(R: Type): Category == with {bar: () -> ()}
define CatA(n: Integer): Category == with {baz: () -> ()}

DomA(R: Type): CatA(R) == add {	
   bar(): () == {}
}

DomA(n: Integer): CatA(n) == add {	
   baz(): () == {}
}

main(): () == {
   macro A == DomA Integer;
   macro B == DomA 2;
   import from Integer;
   stdout << "A has CatA        : " << (A has CatA) << newline;
   stdout << "A has CatA 3      : " << (A has CatA 2) << newline;
   stdout << "A has CatA 3      : " << (A has CatA 3) << newline;
   stdout << "A has CatA Integer: " << (A has CatA(Integer)) << newline;
   stdout << "A has CatA Boolean: " << (A has CatA(Boolean)) << newline;
   stdout << "-----------------" << newline;
   stdout << "B has CatA        : " << (B has CatA) << newline;
   stdout << "B has CatA 2      : " << (B has CatA 2) << newline;
   stdout << "B has CatA 3      : " << (B has CatA 3) << newline;
   stdout << "B has CatA Integer: " << (B has CatA(Integer)) << newline;
   stdout << "B has CatA Boolean: " << (B has CatA(Boolean)) << newline;
}

main();



\start
Date: Tue, 14 Mar 2006 09:11:45 -0500
From: Bill Page
To: list
Subject: Domains and expressions

I highly recommend the paper:

http://portal.acm.org/citation.cfm?id=1073884.1073921

Domains and expressions: an interface between two approaches
to computer algebra

by

Cosmin E. Oancea, Stephen M. Watt
University of Western Ontario, London, ON, Canada

ABSTRACT

This paper describes a method to use compiled, strongly typed
Aldor domains in the interpreted, expression-oriented Maple
environment. This represents a non-traditional approach to
structuring computer algebra software: using an efficient,
compiled language, designed for writing large complex mathematical
libraries, together with a top-level system based on user-interface
priorities and ease of scripting. We examine what is required to
use Aldor libraries to extend Maple in an effective and natural
way. Since the computational models of Maple and Aldor differ
significantly, new run-time code must implement a non-trivial
semantic correspondence. Our solution allows Aldor functions to
run tightly coupled to the Maple environment, able to directly
and efficiently manipulate Maple data objects. We call the
overall system Alma.

--------

Although this kind of reminds me of a marriage between a
Hippopotamus and the Elephant's daughter :), I think this
paper is well worth reading and understanding. It presents a
brief but thorough introduction to Aldor domains and categories.
Then it demonstrates how these can be represented in terms of
Maple's object-oriented "modules" and vice-versa. Maple is
presented as an expression-oriented user interface with a
sophisticated scripting language. Aldor on the other hand
provides a high performance strongly-typed compiled language
for writing mathematical libraries. The overall result of this
"marriage" seems quite complex but the examples make it obvious
that it provides a way to fully exploit Aldor within Maple's
un-typed environment.

I think this paper is important from the point of view
of the uni-typed language B# that has been proposed as an
alternative to Axiom's current interpreter.

\start
Date: Tue, 14 Mar 2006 15:55:48 +0100
From: Ralf Hemmecke
To: Gabriel Dos Reis
Subject: Re: Curiosities with Axiom mathematical structures

On 03/14/2006 01:37 AM, Gabriel Dos Reis wrote:
> Ralf Hemmecke writes:

> | Integer is a name for a structure with carrier set
> | 
> | {0, 1, -1, 2, -2, ...}
> | 
> | and operations {+, *, 0, 1, ...}.
> | 
> | Integer is certainly not the carrier set alone.

Well, actually, it is a convention what Integer should stand for.
For some people it might just be enough to consider Integer as an 
abbreviation for the multiplicative structure ({0,1,-1,...}, (*, 1)}
for other people (ie in other contexts) it might be the ring structure.
And very common in algebra, the carrier set is often denoted by the same 
symbol as the whole algebraic structure. (I guess the latter it too 
ambiguous to be mapped to a programming language?)

> Indeed. It is a type, e.g. set equipped with minimal operations that
> let us implement abstractions on top of it.  Just an abstract data
> type can be implemented in terms of another one, an algebraic
> structure cane be constructed in terms of another one.

> | How would you mathematically express that the integers belong to the
> | category of monoids? You would probably say that
> | 
> | F(Integer) is an object in the category of monoids
> 
> I would do it by assertion.

What does that mean?

> But I will refrain from needlessly emphasizing on the the carrier set
 > -- as F(Integer).

Oh, I hope you understood that F was meant to be a (forgetful) functor 
in the categorial sense whose result would be an object in the category 
of monoids.

So, if you like you could say

define MyMonoid: Category == with {*:(%,%)->%;1:%}
   -- axioms still missing :-(
MonoidStructure(T: Type)(binop:(T,T)->T, unit:T): Monoid == T add {
   Rep == T; import from T;
   (x: %) * (y: %): % == per(binop(rep x, rep y);
   1: % == per unit;
}

That IS Aldor syntax and it would compile. So in Aldor term F from above 
would be something like

F = G(binop, unit)

for that to work it should be possible to write G as

MonoidStructure(binop:(T,T)->T, unit:T): (T: Type) -> Monoid ...

where the operations would have to be specified before the type is 
given. I don't think that is possible in a programming language.

HOWEVER, the above code would ALWAYS return something of type Monoid, 
since it is a type constructor in Aldor and not a forgetful functor in 
the mathematical sense. For me the question would be, how could one 
write forgetful functors in Aldor?

Oh, it just came to my mind, we can have forgetful functors.

Let's take Integer. According to what it has been extended it has a 
definite type (some Aldor category). Basically, if one says

MyInteger: with {+: (%, %)->%; 0: %;} == Integer add;

then MyInteger is like Integer (same carrier set) but everything 
forgotten except + and 0.

Well, then now it remains the question how one could match the names
+, 0 with *,1 in Monoid when asking "MyInteger has Monoid".

But there are 2 problems here.

1) How to match + and the binary operation from Monoid?

2) My specification above probably forgets to much. After all it also 
forgets the properties of + and 0. So it could never be a monoid. 
Unfortunately, Axiom/Aldor does not allow axioms (and I would like to 
see arbitrary predicate logic formulas not just declarative syntax).

\start
Date: Tue, 14 Mar 2006 15:56:05 +0100
From: Ralf Hemmecke
To: Gabriel Dos Reis
Subject: Re: Curiosities with Axiom mathematical structures

On 03/14/2006 01:43 AM, Gabriel Dos Reis wrote:
> Bill Page writes:
> 
> | I agree with Martin. One should interpret:
> | 
> |   if Integer has Monoid(*,1)
> | 
> | as the question of whether F = (*,1) is a functor from the category
> | containing Integer to Monoid, the category of monoids.
> 
> 100% agreed.

But that looks like strange syntax to me. If I want to ask

   F(Integer) \in Ob(Monoid)

and I have to write "Integer has Monoid(*,1)" that does not really look 
natural to me.

\start
Date: Tue, 14 Mar 2006 15:56:15 +0100
From: Ralf Hemmecke
To: Gabriel Dos Reis
Subject: Re: Curiosities with Axiom mathematical structures

On 03/14/2006 01:46 AM, Gabriel Dos Reis wrote:
> Martin Rubey writes:
> 
> [...]
> 
> | > Imagine you could ask "if M has Monoid(+)..." or "if M has
> | > Monoid(*)...". According to which returns true, you would then go on and call
> | > (m1 +$M m2) or (m1 *$M m2). Well, but M might have a monoid structure with
> | > respect to the operation ".". Do you really also want to ask "if M has
> | > Monoid(.)..."? That soon becomes impractical.
> | 
> | No, this is not an issue about practicality.
> | 
> | Look at it this way: Suppose "M has Monoid" returns "true". How do you know
> | then with respect to which operation M is a monoid? What can you do with the
> | information that M is a monoid with respect to some operation?
> 
> Exactly!
> 
> 
> If we had access to Aldor compiler sources, it would helpful to
> experiment with these ideas.

Gaby, although I don't like the syntax currently in discussion, you 
should write to Stephen Watt (Stephen Watt). Perhaps this even 
helps to speed up the process of getting the compiler generally under an 
open source license.

\start
Date: Tue, 14 Mar 2006 15:57:22 +0100
From: Ralf Hemmecke
To: Gabriel Dos Reis
Subject: Re: Curiosities with Axiom mathematical structures

On 03/14/2006 01:54 AM, Gabriel Dos Reis wrote:
> Bill Page writes:
> 
> | On March 13, 2006 6:34 AM Ralf Hemmecke asked:
> | > ... 
> | > But here the question to our category theory experts:
> | > Since Monoid is something like (*,1) would it make sense
> | > to speak of a category (in the mathematical sense) of
> | > 
> | >    monoids that have * and 1 as their operations              
> | >       (1)
> | > 
> | > ? Morphisms would respect 1 not just the identity element 
> | > with respect to *. And for each morphism f we would have
> | > f(a*b) = f(a)*f(b). Of course as operations the two * above
> | > are different but in that category they have to have the same
> | > name. (No idea whether this makes sense, but it seems that
> | > this is the way as "Category" it is implemented in Axiom/Aldor.)
> | > 
> | > Then, of course, (N, +, 0) is not an object in the category 
> | > given by (1).
> | > 
> | 
> | I keep trying to answer these questions but I am not sure I
> | would like to classify myself as an "expert" in category theory.
> | :) But here goes ...
> | 
> | In category theory **Mon** (** means written in bold face font)
> | consists of all monoids (as objects) and all monoid homomorphisms
> | as morphisms. This does not say anything directly about what
> | operation are present "inside" the objects of the category. 
> 
> Agreed.

Well, Bill, are saying that I cannot have (1) as a category? That a 
monoid itself is a category is true, but distracts from my question.

A category is a collection of objects and morphisms. Let's define MYMON. 
Let an object be as follows:
   A set M together with to operations *: (M, M) -> M and 1: M such that
   the monoid axioms are satisfied.
   (I am lazy and don't specify them here explicitly.)
The morphisms in MYMON are the usual monoid-homomorphisms.

And yes, if something wants to be an object in MYMON, it has to have * 
as its binary operation and not +.

Who wouldn't one consider MYMON as a category?

And yes, I consider (N, +, 0) not an object in MYMON. What I try to say 
is that Aldor has currently this view for the "Monoid" category.

\start
Date: Tue, 14 Mar 2006 15:57:33 +0100
From: Ralf Hemmecke
To: Bill Page
Subject: Re: BINGO, Curiosities with Axiom mathematical structures

On 03/14/2006 03:39 AM, Page, Bill wrote:
> On Monday, March 13, 2006 7:32 PM Gaby wrote:
> 
>> ...
>> Bill Page writes:
>>
>>> Also, I think you should write:
>>>
>>>    square: % -> %;
>>>    default {square(t: %): % == m(t pretend T, t pretend T)
>>>      pretend %
>>>
>>> although apparently the compiler does not worry about this
>>> since your representation of the domain MyWord below is the
>>> same as the operation that you pass to MyMonoid.
>> we should also probably find a way to minimize the "pretend"s :-)
>>
> 
> The use of 'pretend' has to do with the issue of representation.
> I suppose it would be better to write:
> 
>    default {
>      Rep == T;
>      square(t: %): % == per(m(rep(t), rep(t))
>    }

NOOOO.... PLEASE DONT USE ANY REPRESENTATION IN A CATEGORY.

Suppose someone later implements your category and just uses some other 
representation than T.

\start
Date: Tue, 14 Mar 2006 11:28:46 -0500
From: Bill Page
To: Ralf Hemmecke, Gabriel Dos Reis
Subject: RE: Curiosities with Axiom mathematical structures

Ralf,

On Tuesday, March 14, 2006 9:56 AM you wrote:
>
> On 03/14/2006 01:43 AM, Gabriel Dos Reis wrote:
> > Bill Page writes:
> >
> > | I agree with Martin. One should interpret:
> > |
> > |   if Integer has Monoid(*,1)
> > |
> > | as the question of whether F = (*,1) is a functor from
> > | the category containing Integer to Monoid, the category
> > | of monoids.
> >
> > 100% agreed.
>
> But that looks like strange syntax to me. If I want to ask
>
>    F(Integer) \in Ob(Monoid)
>
> and I have to write "Integer has Monoid(*,1)" that does not
> really look natural to me.
>

Category theorists purist do not like to write set membership
because it implies that categories are always sets. They
prefer to posit the existence of a functor. But you are right,
describing the functor this way does not seem very "natural"
in Aldor syntax.

What if we say:

  Monoid(Integer,*,1)

denotes the particular object in Monoid (since this is what
we have to write in Aldor anyway). Then the functor F maps
Integer into Monoid(Integer,*,1):

    Integer |-> Monoid(Integer,*,1)

The objects in Monoid are categories both in the sense of
Aldor and in the sense of category theory. Then:

  Integer has Monoid(Integer,*,1)

Looks "natural" since this depends a the Aldor category
containment relation rather than an element-of relation. I.e.
the Aldor category 'Monoid(Integer,*,1)' is a sub-category
of the Aldor category containing Integer. This is just the
concept of type satisfaction in Aldor.

\start
Date: Tue, 14 Mar 2006 18:30:11 +0100
From: Ralf Hemmecke
To: Bill Page
Subject: Re: Curiosities with Axiom mathematical structures

On 03/14/2006 05:28 PM, Page, Bill wrote:
> Ralf, 
> 
> On Tuesday, March 14, 2006 9:56 AM you wrote:
>> On 03/14/2006 01:43 AM, Gabriel Dos Reis wrote:
>>> Bill Page writes:
>>>
>>> | I agree with Martin. One should interpret:
>>> | 
>>> |   if Integer has Monoid(*,1)
>>> | 
>>> | as the question of whether F = (*,1) is a functor from 
>>> | the category containing Integer to Monoid, the category
>>> | of monoids.
>>>
>>> 100% agreed.
>> But that looks like strange syntax to me. If I want to ask
>>
>>    F(Integer) \in Ob(Monoid)
>>
>> and I have to write "Integer has Monoid(*,1)" that does not 
>> really look natural to me.

> Category theorists purist do not like to write set membership
> because it implies that categories are always sets.

OK. Monoid is a category, but I must be able to tell whether something 
is an object of that category. I never said that Ob(Monoid) is a set. I 
did not even claim that it is a class. My "\in" notation just tried to 
be "intuitive". I know that some people found mathematics on category 
theory an not set theory.

> They prefer to posit the existence of a functor.

Could you be more precise?

> But you are right, describing the functor this way does not seem
 > very "natural" in Aldor syntax.
> 
> What if we say:
> 
>   Monoid(Integer,*,1)
> 
> denotes the particular object in Monoid (since this is what
> we have to write in Aldor anyway).

He? If you say "Monoid(Integer,*,1)" is "the particular object in 
Monoid" then why would I have to write

   Integer has Monoid(Integer, *, 1) ?

That also looks unnatural. What would be the meaning of "has" and what 
should be the types of its first and second argument?

 > Then the functor F maps
> Integer into Monoid(Integer,*,1):
> 
>     Integer |-> Monoid(Integer,*,1)

It's hard to follow you. Let me tell you what I understood.

1) There is a category Monoid whose objects are categories. (In that 
sense Monoid would be on the same type level as "Category" in Aldor.) I 
order to avoid confusion, lets call it MONOID.

2) Monoid(Integer, *, 1) would be a category.
   I hope you _don't_ mean the category structure that comes from
   the fact that any monoid can be considered as a category.
   But than I cannot interpret what the objects and arrows in that
   category would be.

3) For me "Monoid(Integer,*,1)" looks more like the universal algebra 
given by the carrier set {0,1,-1,...} and operations * and 1 together 
with the monoid axioms. The axioms are hidden in your notation by the 
"tag" or predicate (well, it's not a predicate since you want the result 
type to be a category) "Monoid".

4) If "Monoid(Integer,*,1)" just means: take the (aldor) category that 
Integer is currently in and forget anything except * and 1, than that 
looks similar to one of my previous mails where I tried to model F by 
"MonoidStructure". It is only that I work on the left hand side of "has" 
and you on the right hand side. But also my suggestion would be "type 
satisfaction in the sense of Aldor" (if it worked).

 > Then:
> 
>   Integer has Monoid(Integer,*,1)
> 
> Looks "natural" since this depends a the Aldor category
> containment relation rather than an element-of relation. I.e.
> the Aldor category 'Monoid(Integer,*,1)' is a sub-category
> of the Aldor category containing Integer. This is just the
> concept of type satisfaction in Aldor.

What would be different to

   Integer has with {*:(%,%)->%;1:%}

?? Only that "Monoid" appears?

\start
Date: Tue, 14 Mar 2006 12:56:29 -0500
From: Bill Page
To: Ralf Hemmecke, Gabriel Dos Reis
Subject: RE: Curiosities with Axiom mathematical structures

Ralf,

On Tuesday, March 14, 2006 9:57 AM you wrote:
> > Bill Page writes:
> >
> > | On March 13, 2006 6:34 AM Ralf Hemmecke asked:
> > | > ...
> > | > But here the question to our category theory experts:
> > | > Since Monoid is something like (*,1) would it make sense
> > | > to speak of a category (in the mathematical sense) of
> > | >
> > | >    monoids that have * and 1 as their operations   (1)
> > | >
> > | > ? Morphisms would respect 1 not just the identity element
> > | > with respect to *. And for each morphism f we would have
> > | > f(a*b) = f(a)*f(b). Of course as operations the two * above
> > | > are different but in that category they have to have the same
> > | > name. (No idea whether this makes sense, but it seems that
> > | > this is the way as "Category" it is implemented in Axiom/Aldor.)
> > | >
> > | > Then, of course, (N, +, 0) is not an object in the category
> > | > given by (1).
> > | >
> > |
> ...
> Well, Bill, are saying that I cannot have (1) as a category?

Let me try to answer again: No. :)

I think your definition (1) is not a category in the usual sense
of category theory.

> That a monoid itself is a category is true, but distracts from
> my question.
>
> A category is a collection of objects and morphisms. Let's
> define MYMON. Let an object be as follows:
>    A set M together with to operations *: (M, M) -> M
>    and 1: M such that the monoid axioms are satisfied.
>    (I am lazy and don't specify them here explicitly.)
> The morphisms in MYMON are the usual monoid-homomorphisms.
>

Ok.

> And yes, if something wants to be an object in MYMON, it
> has to have * as its binary operation and not +.

This does not make much sense to me. That is the same thing
as trying to say that if some set "wants to be" an object
in MYMON it must be named M and not N. This is irrelevant
when defining a category. Both M and * are "formal parameters"
that do not have any more meaning than we wish to assign to
them.

>
> Who wouldn't one consider MYMON as a category?
>

I think MYMON is a category. I just think your conclusion
about the role of the parameters is wrong.

> And yes, I consider (N, +, 0) not an object in MYMON. What
> I try to say is that Aldor has currently this view for the
> "Monoid" category.
>

Do you mean you think the distinction is a "syntactic" one
and not a semantic one? If so, then I think I agree with
you. Aldor categories are not categories in the sense of
category theory. Nonetheless it is the nature of symbolic
calculation on a computer that we are always in the position
of trying to express semantic ideas in terms of syntax. In
the same way the series of digits:

   3 1 4 1 9 5

is not an "integer" in the mathematical sense. Nonetheless
we do use this symbolic representation of an integer to
perform calculations by hand and a similar (usually binary)
notation to do calculations inside the computer.

But I do not see how recognizing this fact gets us any
further along the path to understanding how to represent
the mathematical notion of a monoid in Axiom.

\start
Date: Tue, 14 Mar 2006 13:09:43 -0500
From: Bill Page
To: Ralf Hemmecke, Bill Page
Subject: categories with parameters and defaults

Ralf,

On Tuesday, March 14, 2006 9:58 AM you wrote:
> I wrote:
> > I suppose it would be better to write:
> >
> >    default {
> >      Rep == T;
> >      square(t: %): % == per(m(rep(t), rep(t))
> >    }
>
> NOOOO.... PLEASE DONT USE ANY REPRESENTATION IN A CATEGORY.

The 'Rep' is not a representation in a category. It is in
the default implementation of 'square' which is implemented
in some domain which satisfies this category.

Perhaps you might object that such defaults are best thought
of as virtual packages. I agree that in SPAD that that is how
they are implemented. But we still need to worry about
representation since ultimately they are used in the context
of some domain which satisfies the corresponding category.

>
> Suppose someone later implements your category and just
> uses some other representation than T.

Say what? ;) This default clause is just part of the
definition of a category where T is a parameter of the category,
e.g. Martin's 'MyMonoid'. What type T represents depends on how
this category is "called", e.g. in

  MyMonoid(Integer, *$Integer)

T is Integer, so we have the representation

  Rep == Integer;

In other cases we have other representations

\start
Date: Tue, 14 Mar 2006 15:37:07 -0500
From: Bill Page
To: Ralf Hemmecke, Bill Page
Subject: RE: Curiosities with Axiom mathematical structures

Ralf,

I do hope that we are converging ... :)

On Tuesday, March 14, 2006 12:30 PM you wrote:
> ...
> I wrote:
> > Category theorists purist do not like to write set membership
> > because it implies that categories are always sets.
> ...
>
> > They prefer to posit the existence of a functor.
>
> Could you be more precise?

I think this is not so relevant to our goal -- this is all
just "categorical nonsense" ;) ... But "elements" in
category theory are usually abstracted as abstracted as
morphisms from the terminal object (source) to some other
object (target). Such morphisms are called elements of the
target object. The terminal object is abstracted from the
notion of a singleton set and can be defined generally as
a certain kind of "limit" etc. etc. In general the existence
of a morphism (or functor if the objects themselves are
categories) is equivalent to the existence of an element
of the target.

> ...
> He? If you say "Monoid(Integer,*,1)" is "the particular object
> in Monoid" then why would I have to write
>
>    Integer has Monoid(Integer, *, 1) ?

Because our objective is the say that Integer has a certain
relationship to this Monoid.

>
> That also looks unnatural. What would be the meaning of
> "has" and what should be the types of its first and second
> argument?

  Integer has Monoid(Integer, *, 1)

is equivalent to writing

  F(Integer) = Monoid(Integer, *, 1)

in your notation. The types associated with 'has' are

  domain has category

Integer is a member of some category and Monoid(Integer,*,1)
is a member of another category.

>
>  > Then the functor F maps Integer into Monoid(Integer,*,1):
> >
> >     Integer |-> Monoid(Integer,*,1)
>

This is just another way to write:

    F(Integer) = Monoid(Integer, *, 1)

> It's hard to follow you. Let me tell you what I understood.
>
> 1) There is a category Monoid whose objects are categories.
> (In that sense Monoid would be on the same type level as
> "Category" in Aldor.)

I don't think that is true. In Aldor we can not have categories
that are objects (elements or members) of other categories -
we can only have categories that are sub-categories of other
categories. Domains are objects of categories. This is
explained very well I think in the Aldor Users Guide, section
"7.5 Subtypes" and related chapters:

   Inheritance for domains from categories is analogous to
   class membership and inheritance between categories is
   analogous to class containment.

> I order to avoid confusion, lets call it MONOID.

I am not sure what to call it in Aldor except it syntactically
it looks like 'Monoid' in the expression

  Monoid(Integer, *, 1)

but we said this (whole thing) was a category, so 'Monoid'
is something else - I guess a "category constructor".

>
> 2) Monoid(Integer, *, 1) would be a category.
>    I hope you _don't_ mean the category structure that comes
>    from the fact that any monoid can be considered as a
>    category. But than I cannot interpret what the objects
>    and arrows in that category would be.

No, I mean

    Monoid(Integer, *$Integer, 1$Integer)

is a category with object 'Integer', composition '*$Integer' and
identity '1$Integer'.

>
> 3) For me "Monoid(Integer,*,1)" looks more like the universal
> algebra given by the carrier set {0,1,-1,...} and operations
> * and 1 together with the monoid axioms.
> ...

I think that is probably a good alternative to category theory
when trying to formally express the semantics of Aldor programs.
But maybe it is too general and I think therefore less interesting
mathematically. Category theory has been so successful at
capturing and unifying a very wide range of mathematical concepts.
I would like to have some assurance that my chosen computer
algebra system has a similar "power" to represent such a wide
range of mathematics.

> ...
> What would be different to
>
>    Integer has with {*:(%,%)->%;1:%}
>
> ?? Only that "Monoid" appears?
>

I think it is important to understand what the Aldor Users
Guide means when it says:

   Note that Aldor is constructed so that a domain is only
   a member of a named category if it explicitly inherits
   from the category -- not if it merely exports the same
   collection of (explicit) declarations1.

This is what we mean in Axiom when we say domains satisfy
named categories by *assertion*.

    Integer has with {*:(%,%)->%;1:%}

does not say anything about the relationship between the
operations * and constant 1 except that they occur in Integer.
This does not make Integer a monoid but the result is true.

On the other hand

    define Monoid:Category == with {*:(%,%)->%;1:%}
    ++ a*(b*c)=(a*b)*c and a*1 = 1*a = a

gives a "name" to the category and adds some comments. The
result of

    Integer has Monoid

is false. Note that the only difference is the 'Monoid' is
a named category instead of a category constant. 'Integer'
only satisfies such a category if we explicitly say that
it does like this:

   extend: Integer: Monoid == add;

Now

    Integer has Monoid

is true. We can use this fact in the program code to treat
(Integer,*,1) as a mathematical monoid. But this is only
a convention that we might or might not implement.

In fact we don't even need the 'with' clause if all we need
is an "axiom"

    define Monoid2:Category == with
    extend: Integer: Monoid2 == add;

The only thing that has been added to Integer is the assertion
that it satisfies Monoid2. This is just like in Axiom where
we can use this sort of category to represent some property.
(Axiom allows such axioms to be defined implicitly but Aldor
does not.) What we **do** with such a property is entirely up
to the programmer.

\start
Date: Tue, 14 Mar 2006 12:25:18 -0800
From: Bill Walster
To: Tim Daly
Subject: Re: Provisos generalize intervals.

Tim,

There are lots of possible generalizations of a real or extended
real interval.  For example: a vector of intervals, or a "box";
a complex interval consisting of a real and imaginary interval pair,
or an interval magnitude and phase; or a set of intervals, sometimes
called a list.  Another important interval construct is a Taylor Model
consisting of selected terms in a Taylor series and an interval error
bound.

In thinking about your question, it seems as if there is only one
important requirements that *must* be satisfied:  That is, the set of
possible results (what I call the containment set, or cset) must be
defined for all permitted operations on or functions of some interval 
construct.  When some operation or function is operationalized, the 
resulting "interval" must enclose the cset for the given operation 
or function.  We can never permit a containment failure.

Usually, but not always, one wants a closed system in which operations
or functions of an interval construct result in new members of the 
same interval construct.  For example basic arithmetic operations on
extended real intervals produce extended real intervals.  No exceptions.
However, intersections of exterior intervals can result in two disjoint
intervals.  This is a set of intervals.  

The pragmatic question to answer is whether the utility value of adding
a new interval construct and operations on it will add sufficient value
to justify the effort.  Value can be measured in terms of parsimonious
and transparent mathematics and code and overall resulting algorithm
speed.  I assume that narrow width contributes to speed.

So, the bottom line is that any operation or function of an interval
entity must have a defined cset.  Evaluation must never produce a 
containment failure.

Hope this helps to clarify what you need to do.

Cheers,

Bill


root wrote:

> Bill,
> 
> I've taken a step back and am reviewing Moore's book again in 
> preparation for a deeper reading of your book.
> 
> It seems that the fundamental difference between the work that you and
> Moore have pursued and the work I've been doing lies in the definition
> of the endpoints of the intervals. Correct me if I'm wrong but it appears
> that the endpoints of your intervals are all ordered numbers.
> 
> The endpoints of the intervals I'm looking at for provisos are not
> numbers and, in most cases, are ordered by explicit constraints. My
> work assumes that the endpoints can be pretty much anything, complex
> numbers, vectors, symbols, polynomials, etc.
> 
> Thus I raise the question of intervals whose endpoints specify the 
> inner and outer radius of two bounding surfaces. For example, the
> inner and outer radius of two spheres or the upper and lower bounding
> surfaces of a function during integration. This is useful symbolically
> since if I can show that the two bounding surfaces tends to zero I can
> conclude that the integral tends to zero even if the actual function
> is too complex to compute.
> 
> Provisos generalize intervals.
> 

\start
Date: 15 Mar 2006 00:42:26 +0100
From: Gabriel Dos Reis
To: Bill Page
Subject: Re: Domains and expressions

Thanks for the pointer.

Chasing links led me to this

    http://portal.acm.org/citation.cfm?id=190695&dl=GUIDE&coll=GUIDE&CFID=67330748&CFTOKEN=77193109

Do people know what happens to "Gauss"?

In their approach to mimic Axiom, they avoid been careful in making
AbelianMonoid "derive" from Monoid.  

\start
Date: Tue, 14 Mar 2006 21:24:13 +0100
From: Ralf Hemmecke
To: Bill Page
Subject: Re: categories with parameters and defaults

On 03/14/2006 07:09 PM, Page, Bill wrote:
> Ralf, 
> 
> On Tuesday, March 14, 2006 9:58 AM you wrote:
>> I wrote:
>>> I suppose it would be better to write:
>>>
>>>    default {
>>>      Rep == T;
>>>      square(t: %): % == per(m(rep(t), rep(t))
>>>    }
>> NOOOO.... PLEASE DONT USE ANY REPRESENTATION IN A CATEGORY.
> 
> The 'Rep' is not a representation in a category. It is in
> the default implementation of 'square' which is implemented
> in some domain which satisfies this category.
> 
> Perhaps you might object that such defaults are best thought
> of as virtual packages. I agree that in SPAD that that is how
> they are implemented. But we still need to worry about
> representation since ultimately they are used in the context
> of some domain which satisfies the corresponding category.
> 
>> Suppose someone later implements your category and just
>> uses some other representation than T.
> 
> Say what? ;) This default clause is just part of the
> definition of a category where T is a parameter of the category,
> e.g. Martin's 'MyMonoid'. What type T represents depends on how
> this category is "called", e.g. in
> 
>   MyMonoid(Integer, *$Integer)
> 
> T is Integer, so we have the representation
> 
>   Rep == Integer;
> 
> In other cases we have other representations

Let me give explicit code...

--- RepInCat.as
#include "aldor"
#include "aldorio"
define CatA(T: Type, foo: T->T): Category == OutputType with {
   foo: () -> %;
   bar: % -> %;
   default {
     Rep == T;
     bar(x: %): % == per foo rep x;
   }
}

DomA: CatA(Integer, -$Integer) == add {
   Rep == List Boolean; import from Rep;
   foo(): % == per [true, false];
   (p: TextWriter) << (x: %): TextWriter == p << rep x;
}

main(): () == {
   import from DomA;
   stdout <<     foo()  << newline; flush!(stdout);
   stdout << bar(foo()) << newline; flush!(stdout);
}
main();
---- end RepInCat.as

By fixing the "Rep" in the category, you require that the compiler has 
to reject the definition of DomA. Currently the Aldor compiler does not 
do that.

And so the above program compiles and yields as output...

aldor -laldor -fx RepInCat.as
RepInCat
[T,F]
Segmentation fault

As expected, right?

If you want the compiler to fix the representation in the category, we 
are back to the multiple inheritance problem.

\start
Date: Tue, 14 Mar 2006 22:39:20 +0100
From: Ralf Hemmecke
To: Bill Page
Subject: Re: Curiosities with Axiom mathematical structures

On 03/14/2006 06:56 PM, Page, Bill wrote:
> Ralf, 
> 
> On Tuesday, March 14, 2006 9:57 AM you wrote:
>>> Bill Page writes:
>>>
>>> | On March 13, 2006 6:34 AM Ralf Hemmecke asked:
>>> | > ... 
>>> | > But here the question to our category theory experts:
>>> | > Since Monoid is something like (*,1) would it make sense
>>> | > to speak of a category (in the mathematical sense) of
>>> | > 
>>> | >    monoids that have * and 1 as their operations   (1)
>>> | > 
>>> | > ? Morphisms would respect 1 not just the identity element 
>>> | > with respect to *. And for each morphism f we would have
>>> | > f(a*b) = f(a)*f(b). Of course as operations the two * above
>>> | > are different but in that category they have to have the same
>>> | > name. (No idea whether this makes sense, but it seems that
>>> | > this is the way as "Category" it is implemented in Axiom/Aldor.)
>>> | > 
>>> | > Then, of course, (N, +, 0) is not an object in the category 
>>> | > given by (1).

>> Well, Bill, are you saying that I cannot have (1) as a category?
> Let me try to answer again: No. :)

> I think your definition (1) is not a category in the usual sense
> of category theory.

>> A category is a collection of objects and morphisms. Let's 
>> define MYMON. Let an object be as follows:
>>    A set M together with to operations *: (M, M) -> M
>>    and 1: M such that the monoid axioms are satisfied.
>>    (I am lazy and don't specify them here explicitly.)
>> The morphisms in MYMON are the usual monoid-homomorphisms.

> Ok.

>> And yes, if something wants to be an object in MYMON, it
>> has to have * as its binary operation and not +.

> This does not make much sense to me.

OK, that would be the answer to my question above.

> That is the same thing as trying to say that if some set "wants to
> be" an object in MYMON it must be named M and not N. This is
> irrelevant when defining a category. Both M and * are "formal
> parameters" that do not have any more meaning than we wish to assign
> to them.

OK, it's in some sense similar to the signature as it appears in Doye's 
thesis. M is a sort and * and 1 are operator symbols.

>> And yes, I consider (N, +, 0) not an object in MYMON. What
>> I try to say is that Aldor has currently this view for the
>> "Monoid" category.

> Do you mean you think the distinction is a "syntactic" one
> and not a semantic one? If so, then I think I agree with
> you. 

I did not think about syntax and semantic, but it seems that is it.

 > Aldor categories are not categories in the sense of
> category theory.

By now, we should all know that. And anyway, if Aldor categories were 
true categories then the morphisms are missing.

But let's try to identify what the morphisms could be in the current 
view of Aldor.

OK, just an example that should be further formalised.

define CatA(A: Type): Category == with {foo: (A, %) -> %}
X: CatA(Boolean) == add {foo(a: A, x: %): % == ...}
Y: CatA(Boolean) == add {foo(a: A, x: %): % == ...}

Let h: X -> Y. It consists of several maps, namely
h_A: A_X -> A_Y (where A_X = A_Y = A)
h_%: %_X -> %_Y (where %_X and %_Y are the respective %'s)
Then h_A(a)=a for all a in A
and we require compatibility with the operations so:

   h_%(foo(a, x)) = foo(h_A(a), h_%(x))                 (C1)

All such h for any domains that are declared to be of type CatA(Boolean) 
are morphisms of CatA. By the way, since any Aldor program consists of a 
finite number of characters, doesn't that just mean that any Aldor 
category can have only finitely many objects.

And yes, (C1) seems to be syntactic, since there is foo on both sides of 
the equality and not foo_X and foo_Y.

 > Nonetheless it is the nature of symbolic
> calculation on a computer that we are always in the position
> of trying to express semantic ideas in terms of syntax. In
> the same way the series of digits:
> 
>    3 1 4 1 9 5
> 
> is not an "integer" in the mathematical sense. Nonetheless
> we do use this symbolic representation of an integer to
> perform calculations by hand and a similar (usually binary)
> notation to do calculations inside the computer.

Good point. We agree on some representation of Integer (or natural 
numbers) an never really question it, although there are more such 
things that satisfy the Peano axioms.

Maybe that is one reason why the Axiom designers did not try to 
distinguish between operator symbols and operator names (see Doye's 
thesis chapter 9) with the consequence that AbelianMonoid does not 
inherit from Monoid.

> But I do not see how recognizing this fact gets us any
> further along the path to understanding how to represent
> the mathematical notion of a monoid in Axiom.

Well, understanding the current situation is certainly one step to a 
solution. To me it seems that Aldor needs a way to distinguish operator 
symbols from operator names.

Maybe we could agree on a temporary syntax for such a distiction and 
then try to figure out what positive and negative consequences such a 
language feature would have.

What do you all think? The goal is to make Aldor more mathematical 
without introducing unhandy language constructs.

And maybe at the same time we should think about introducing axioms to 
Axiom that are not just declarative objects like "commutative(+)" but 
logical formulae.

\start
Date: Wed, 15 Mar 2006 11:13:19 +0100
From: Ralf Hemmecke
To: Bill Page
Subject: Re: Aldor %% bindings

On 03/14/2006 09:56 AM, Page, Bill wrote:
> Ralf, and other Aldor experts;
> 
> Section "7.5 Subtypes" of the Aldor Users Guide says:
> 
>   Note that Aldor is constructed so that a domain is only a
>   member of a named category if it explicitly inherits from
>   the category -- not if it merely exports the same collection
>   of (explicit) declarations\1.

> Footnote \1 says:
> 
>   In the current implementation, each named category C
>   implicitly exports a symbol named \%%" with type C (see
>   Section 8.12), whose presence is tested for in checking
>   category membership.
> 
> Note: 8.12 is a typo. It should say 8.11.
> 
> Section "8.11 With" says::
> 
>   A 'with' expression also defines a constant named "%%" for
>   each category from which the 'with' expression inherits.
>   The type of %% is the inherited category, and the value
>   is the domain viewed as a member of that category...
>   The %% bindings are generally most useful for checking
>   conditions.
> 
> -------
> 
> Can anyone explain the usage of %% and give some examples
> where it is used to "check conditions"?

For example "has" constructs, but I don't know if there is anything else.

#include "aldor"
define CatDummy: Category == PrimitiveType with {foo: () -> ()}

If you compile this with via "aldor -fasy aaa.as" then you get
something like that ...

((|Declare|
     |CatDummy|
     (|Define|
       (|Declare| (|Label| |CatDummy| ()) |Category|)
       (|With|
         |PrimitiveType|
         (|Declare|
           |foo|
           (|Apply| -> (|Comma|) (|Comma|))))))
     ((|catExports|
         (|Declare|
           =
           (|Apply| -> (|Comma| % %) |Boolean|))
         (|Declare|
           ~=
           (|Apply| -> (|Comma| % %) |Boolean|)
           ((|default| . 1))
         (|Declare|
           %%
           |PrimitiveType|)
         (|Declare|
           |foo|
           (|Apply| -> (|Comma|) (|Comma|)))
         (|Declare|
           %%
           |CatDummy|)))))

To make it shorter here, I have removed some
((|symeNameCode| . 243941740) (|symeTypeCode| . 83337439)) stuff.

What you see is that the Category CatDummy, not only exports %% for 
PrimitiveType but also %% for CatDummy.

As I understand this... apart from encoding the category hierarchy in 
that way it also could make the evaluation of "DOM has CatDummy" faster 
since the need only be a lookup whether there is some %% for CatDummy. 
No check for all the corresponding exported functions is necessary. (Am 
I wrong?)

> What does it mean to be a "domain viewed as a member of
> a specific category"?

I have only seen %% in places as above. So I have no idea what that 
could mean. Maybe it is used in conditional exports, I haven't checked that.

> Apparently %% can have multiple bindings. About the
> example in section 8.11 we read that:
> 
>   In the example, %% bindings are in scope for the
>   following categories:
>   BinaryAggregate, BooleanArithmeticType,
>   BoundedFiniteLinearStructureType Boolean,
>   BoundedFiniteDataStructureType Boolean,
>   FiniteLinearStructureType Boolean, PrimitiveType,
>   and so on.
> 
> How can I access the value (associated domain?) of a
> particular binding?
> 
> Any hints about how to understand this would be greatly
> appreciated.

Maybe Stephen Watt or Peter Broadbery could help.

\start
Date: 15 Mar 2006 17:56:23 +0100
From: Francois Maltey
To: Martin Rubey
Subject: expand sin (nx) and cos (nx)

Hello Martin, hello everybody !

I try to improve the expand function, 
I want to use it with my students in the chapter "trigonometric functions"

Today I don't change the package MANIP.spad, but I write *.input files.
I hope I can compile it without problem later inside the MANIP.spad

At the end of this input file you can try : 

expand1 (cos (3*x))+%i*expand1 (sin (3*x)) - (cos(x)+%i*sin(x))^3
expand1 (cos (a+b))
expand1 (sin (a-b))  -- doesn't work
expand1 (sin (b-a))  -- is right

So I have several problems :

// A //

My first function is a function which gives the name of the function :

With mupad I done :
op (3*x+5*y, 1)   -> _plus
op (3*x, 1)       -> _mult
op (x^3, 1)       -> _power
op (sin(3*x), 1)  -> sin
op (cos(3*x), 1)  -> cos

With axiom I try this function :

operator1 x == 
  (retractIfCan x)@Union(Kernel Expression Integer,"failed")

but it works only for Expression Integer, not Expression Complex Integer.

Is it possible to translate the mupad function : mainFct := x -> op (x, 1)


// B //

Why must I add some coerces  in this input file

// C //

What are the usual Expression ... type.

Can I be sure that coef in Integer, Fraction Integer, Complex Integer ?
Is it possible to have Float or DoubleFloat...

How can I test if variable coef in an Integer or not ? 

Thanks a lot if you can give me your advice !

Francois maltey. [I post at 17h UTC, 18h in France] 

------------------------------------------------------------------------

You can test it in an *.input file. 
error remains.
But I'd like to have information about dirty functions as operator1 
or silly coerce.

------------------------------------------------------------------------

operator1 x == 
  (retractIfCan x)@Union(Kernel Expression Integer,"failed")

expand1 (a : Expression Integer) : Expression Integer ==
  op := operator1 a
  op case "failed" => a 
  arg := first argument (op::Kernel Expression Integer) -- I must coerce
  is? (operator op, "cos"::Symbol) => expandcos arg
  is? (operator op, "sin"::Symbol) => expandsin arg
  a

sinnx (n,x) == eval (imag ((c + %i * s)^n), [c, s], [cos x, sin x])
cosnx (n,x) == eval (real ((c + %i * s)^n), [c, s], [cos x, sin x])

expandsin arg ==
  arg = 0 => 0
  num := numer arg
  den := denom arg 
  head := leadingMonomial num 
  coef := leadingCoefficient num
  a := head / coef / den
  tail := reductum num 
  b := (tail / den)::Expression Integer               -- I must coerce 
  sinnx (coef, a) * expand1 (cos b) + cosnx (coef, a) * expand1 (sin b)

expandcos arg ==
  arg = 0 => 1
  num := numer arg
  den := denom arg 
  head := leadingMonomial num 
  coef := leadingCoefficient num
  a := head / coef / den
  tail := reductum num 
  b := (tail / den)::Expression Integer                -- I must coerce 
  cosnx (coef, a) * expand1 (cos b) - sinnx (coef, a) * expand1 (sin b)


-- You can try : 
expand1 (cos (3*x))+%i*expand1 (sin (3*x)) - (cos(x)+%i*sin(x))^3
expand1 (sin (a-b))
expand1 (sin (a+b))
expand1 (cos (b-a))


\start
Date: Wed, 15 Mar 2006 18:30:38 +0100
From: Ralf Hemmecke
To: list
Subject: AldorForAxiom

Hello,

I work with axiom--main--1--patch-46 and recently compiled it on my 
debian sarge machine. Worked fine, except that there must have been a 
LaTeX error in the compilation of endpaper.pamphlet.

Anyway, on http://wiki.axiom-developer.org/AldorForAxiom I read that 
Peter Broadbery's patch has been included from patch-44 on. So I expect 
aldor to work. Well, it does. I can compile the file fact.as given on 
the above website, but when I type

(1) -> fact 4

I get the message

    >> System error:
    Cannot open the file 
/home/hemmecke/OTHER/Axiom/axiom--main--1/mnt/linux/aldor/lib/runtime.o.

There is no library runtime.o that I could find. (I even wonder why it 
should be .o and not .lsp.) My Axiom compilation did also not create the 
  directory
/home/hemmecke/OTHER/Axiom/axiom--main--1/mnt/linux/aldor
Anyway, even if I "ln -s" my Aldor compiler directory there, I still 
don't have runtime.o.

Any help is appreciated.

\start
Date: Wed, 15 Mar 2006 13:14:16 -0500
From: Bill Page
To: Ralf Hemmecke
Subject: RE: AldorForAxiom

On March 15, 2006 12:31 PM Ralf Hemmecke wrote:
> 
> I work with axiom--main--1--patch-46 and recently compiled it
> on my debian sarge machine. Worked fine, except that there must
> have been a LaTeX error in the compilation of endpaper.pamphlet.
> 
> Anyway, on http://wiki.axiom-developer.org/AldorForAxiom I read
> that Peter Broadbery's patch has been included from patch-44 on.

Sorry. The web site says:

"The Axiom/Aldor interface has been updated for the open source
version of Axiom (as of Patch-44) by Peter Broadbery."

What I should have said is that Peter Broadbery's patches and
the procedure that follows can be successfully applied to Axiom
Patch-44... but that it is *not* part of the current Axiom
distribution.

As of about Patch-46, I think, the 'aldor.diff' patches were
included, but the rest of the procedure still has to be done.
Tim only applied the patch 'aldor.diff'. That is just step 6.
You still have to do all other steps 1 to 13 not involving
'aldor.diff'.

> So I expect aldor to work. Well, it does.

I am quite surprized that it even gets that far.

> I can compile the file fact.as given on the above website,
> but when I type
> 
> (1) -> fact 4
> 
> I get the message
> 
>     >> System error:
>     Cannot open the file 
> /home/hemmecke/OTHER/Axiom/axiom--main--1/mnt/linux/aldor/lib/
> runtime.o.
> 
> There is no library runtime.o that I could find. (I even 
> wonder why it should be .o and not .lsp.)

That is created during step 9.

> My Axiom compilation did also not create the directory
> /home/hemmecke/OTHER/Axiom/axiom--main--1/mnt/linux/aldor

No. It is not currently part of the Axiom distribution. It
comes from step 8.

> Anyway, even if I "ln -s" my Aldor compiler directory there,
> I still don't have runtime.o.

No. The Aldor interface is not part of the Axiom distribution
because Aldor is not part of the Axiom distribution (yet).

> 
> Any help is appreciated.
> 

Start at step 1. :)

\start
Date: Wed, 15 Mar 2006 13:37:16 -0500
From: Bill Page
To: Ralf Hemmecke
Subject: RE: categories with parameters and defaults

Ralf,

On March 14, 2006 3:24 PM you wrote:
> 
> On 03/14/2006 07:09 PM, Bill Page wrote:
> > 
> > On Tuesday, March 14, 2006 9:58 AM Ralf wrote:
> >>> I suppose it would be better to write:
> >>>
> >>>    default {
> >>>      Rep == T;
> >>>      square(t: %): % == per(m(rep(t), rep(t))
> >>>    }
> >> NOOOO.... PLEASE DONT USE ANY REPRESENTATION IN A CATEGORY.
> > 
> > The 'Rep' is not a representation in a category. It is in
> > the default implementation of 'square' which is implemented
> > in some domain which satisfies this category.
> > 
> ...

You are right. I withdraw my comment. I believe that the way
Martin Rubey originally wrote it:

MyMonoid(T: Type, m: (T, T) -> T): Category == with {
   square: T-> T;
   default {square(t: T): T == m(t, t)}
}

MyWord: with { 
   coerce: String -> %;
   c:(%, %) -> %
}
   == add {
   Rep == String;
   import from String;
   coerce(a: String): % == per(a);
   c(a: %, b: %):%  == coerce(concat(rep(a), rep(b))$String) }

import from MyWord;
extend MyWord: MyMonoid(MyWord, c) == add;

---------

It is correct as it stands. I was confused about what effect
something like:

  extend MyWord: MyMonoid(Integer, +$Integer) == add;

might do. But on reviewing this, I see that although
the result is strange since MyWord then exports a
function square:Integer->Integer, it is not wrong.

\start
Date: Wed, 15 Mar 2006 22:05:43 -0500
From: Bill Page
To: Gabriel Dos Reis
Subject: RE: Domains and expressions

Gaby,

On March 14, 2006 6:42 PM you wrote:
>
> Chasing links led me to this
>
>
http://portal.acm.org/citation.cfm?id=190695&dl=GUIDE&coll=GUIDE&CF=
ID=673307
48&CFTOKEN=77193109

> Do people know what happens to "Gauss"?

Once long ago as a new user of Maple I remember trying Gauss.
I was distinctly unimpressed. That was with Maple release 4
which actually, I rather liked.

I believe that at the time Gauss was available from MapleSoft,
but I can't find it now on their website. If you are really
interested you might inquire at

http://www.maplesoft.com

Of course the idea of adding something as heavy as an object-
oriented strongly-typed extension to an untyped interpreted
language is pretty questionable anyway... I think B#, adding
an "untyped" interpreted user-level language to a strongly-typed
language like Aldor, makes more sense. Don't you think?

> In their approach to mimic Axiom, they avoid been careful in
> making AbelianMonoid "derive" from Monoid. 

Yes, that is interesting - nice diagram. I wonder how much
of that was actually implemented?

Here is the only other reference I could find:

Design and implementation of symbolic computation systems:
International Symposium, DISCO '93, Gmunden, Austria,
September 15-17, 1993 : proceedings
(Lecture notes in computer science)

http://books.google.com/books?id=NrpGnrVET_MC

You might want to check if your library has a copy.

Gauss: A Parameterized Domain of Computation System with
Support for Signature Functions, by M.B Monagan, page 81.

Notice also the article by Tony Hearn about order-sorted
algebras: "An Order-Sorted Approach to Algebraic Computation".
Page 134.

\start
Date: Wed, 15 Mar 2006 23:10:00 +0100
From: Ralf Hemmecke
To: Bill Page
Subject: Re: AldorForAxiom
Cc: Peter Broadbery

Thank you, Bill.

Now I've got runtime.o. Step 9 took about half an hour on a 1.6 GHz 
Centrino Laptop with 512 MB ;-).

But I still wonder why all these .o files are needed for the execution 
inside Axiom. I could understand .ao files, but .o files?

Interestingly, when I say ")co fact.as" Axiom prints:

    Compiling AXIOM source code from file /home/hemmecke/fact.as using
       AXIOM-XL compiler and options
-O -Fasy -Fao -Flsp -laxiom -Mno-AXL_W_WillObsolete -DAxiom -Y 
$AXIOM/algebra
       Use the system command )set compiler args to change these
       options.

And if I then look into my directory I see.

 >ls fact*
fact.ao  fact.as  fact.asy  fact.fn  fact.lsp  fact.o

Where did the .o file come from? So ")co fact.as" is not the same as 
calling "aldor ABOVE_COMPILER_OPTIONS fact.as". Where should I look to 
make ")compile" more transparent to me.

And someone tell what happens when I execute "fact 4" in Axiom after 
compiling ")co fact.as"? I always believed that Axiom executes LISP 
code. So why is there any need for a .o file?

Or are all these .o files just there so that I can produce standalone 
programs that run without AXIOM? That should in priciple be possible 
once I have libaxiom.al, I just haven't tried it yet.

Ralf

On 03/15/2006 07:14 PM, Bill Page wrote:
> On March 15, 2006 12:31 PM Ralf Hemmecke wrote:
>> I can compile the file fact.as given on the above website,
>> but when I type
>>
>> (1) -> fact 4
>>
>> I get the message
>>
>>     >> System error:
>>     Cannot open the file 
>> /home/hemmecke/OTHER/Axiom/axiom--main--1/mnt/linux/aldor/lib/
>> runtime.o.

\start
Date: Thu, 16 Mar 2006 10:38:22 -0500
From: Bill Page
To: Ralf Hemmecke
Subject: RE: AldorForAxiom
Cc: Peter Broadbery

Ralf,

On March 15, 2006 5:10 PM you wrote:
> ... 
> Now I've got runtime.o. Step 9 took about half an hour on a 1.6 GHz 
> Centrino Laptop with 512 MB ;-).
>

Yes, that is the main step. There is a nice little topological
sort of the dependencies done in Java that I think should really
be done in Aldor. In fact, Tim Daly **insists** that we should
not add Java to the list of prerequisits for building Axiom, so
when we begin distributing Aldor with the Axiom distribution we
will have some work to do. :)
 
> But I still wonder why all these .o files are needed for the 
> execution inside Axiom. I could understand .ao files, but .o
> files?

These are the compiled algebra files just like the ones
generated from SPAD.

> 
> Interestingly, when I say ")co fact.as" Axiom prints:
> 
>     Compiling AXIOM source code from file /home/hemmecke/fact.as
>     using AXIOM-XL compiler and options
> -O -Fasy -Fao -Flsp -laxiom -Mno-AXL_W_WillObsolete -DAxiom -Y 
> $AXIOM/algebra
>        Use the system command )set compiler args to change these
>        options.
> 
> And if I then look into my directory I see.
> 
>  >ls fact*
> fact.ao  fact.as  fact.asy  fact.fn  fact.lsp  fact.o
> 
> Where did the .o file come from?

It was compiled by GCL from the .lsp source which was generated
by Aldor. (Notice option '-Flsp' above.

> So ")co fact.as" is not the same as calling
> "aldor ABOVE_COMPILER_OPTIONS fact.as".

Almost, except you need to compile the generated lisp.

> Where should I look to make ")compile" more transparent to me.

Unfortunately I can only suggests the Axiom source code.

> 
> And someone tell what happens when I execute "fact 4" in
> Axiom after compiling ")co fact.as"? I always believed that
> Axiom executes LISP code. So why is there any need for a .o
> file?

Axiom executes *compiled* lisp code. The .o files are machine
code object files that are loaded dynamically by GCL.

> 
> Or are all these .o files just there so that I can produce
> standalone programs that run without AXIOM?

No.

> That should in priciple be possible once I have libaxiom.al,
> I just haven't tried it yet.
> 

Let me know if you succeed.

Peter: Please correct me if I have described any of this
incorrectly. Thanks.

\start
Date: Thu, 16 Mar 2006 17:05:27 +0100
From: Ralf Hemmecke
To: Bill Page
Subject: Re: AldorForAxiom

On 03/16/2006 04:38 PM, Bill Page wrote:
> Yes, that is the main step. There is a nice little topological
> sort of the dependencies done in Java that I think should really
> be done in Aldor. In fact, Tim Daly **insists** that we should
> not add Java to the list of prerequisits for building Axiom, so
> when we begin distributing Aldor with the Axiom distribution we
> will have some work to do. :)

I thought that it is quite a strange to install Java just for the sake 
of sorting, but now I looked to the java programm, well, it's a bit long 
and not too well documented. But perhaps I could try to port it to Aldor 
on an un-busy weekend. ;-)

>> But I still wonder why all these .o files are needed for the 
>> execution inside Axiom. I could understand .ao files, but .o
>> files?
> 
> These are the compiled algebra files just like the ones
> generated from SPAD.

Yes, clear, but if I just stay in Axiom, I don't need .o files. Am I wrong?

>> Interestingly, when I say ")co fact.as" Axiom prints:
>>
>>     Compiling AXIOM source code from file /home/hemmecke/fact.as
>>     using AXIOM-XL compiler and options
>> -O -Fasy -Fao -Flsp -laxiom -Mno-AXL_W_WillObsolete -DAxiom -Y 
>> $AXIOM/algebra
>>        Use the system command )set compiler args to change these
>>        options.
>>
>> And if I then look into my directory I see.
>>
>>  >ls fact*
>> fact.ao  fact.as  fact.asy  fact.fn  fact.lsp  fact.o
>>
>> Where did the .o file come from?
> 
> It was compiled by GCL from the .lsp source which was generated
> by Aldor. (Notice option '-Flsp' above.

Notice that there is no "-fo" on the command line. And if there were, I 
guess the aldor compiler would call a sequence .as -> .ao -> (hidden .c) 
-> .o.

>> So ")co fact.as" is not the same as calling
>> "aldor ABOVE_COMPILER_OPTIONS fact.as".

> Almost, except you need to compile the generated lisp.

Aha. And that is also .o? Is this the same object format that comes out 
if I compile a .c file?

>> Where should I look to make ")compile" more transparent to me.

> Unfortunately I can only suggests the Axiom source code.

I would not have expected anything else, but if someone could make my 
search space a bit smaller that would help.

>> And someone tell what happens when I execute "fact 4" in
>> Axiom after compiling ")co fact.as"? I always believed that
>> Axiom executes LISP code. So why is there any need for a .o
>> file?

> Axiom executes *compiled* lisp code. The .o files are machine
> code object files that are loaded dynamically by GCL.

Well, I simply removed fact.o and started a new Axiom. I said:

)lib fact
fact 3

and got 6 as result. Which code did I execute?

>> That should in priciple be possible once I have libaxiom.al,
>> I just haven't tried it yet.

> Let me know if you succeed.

I'll post my experience with that.

\start
Date: Thu, 16 Mar 2006 18:19:10 +0100
From: Gregory Vanuxem
To: Ralf Hemmecke
Subject: Re: AldorForAxiom

Hi,

Le jeudi 16 mars 2006 =E0 17:05 +0100, Ralf Hemmecke a =E9crit :

> Yes, clear, but if I just stay in Axiom, I don't need .o files. Am I wr=
ong?

Yes, you are wrong. The .o file is needed if you want to use compiled
lisp code.


> Aha. And that is also .o? Is this the same object format that comes out=

> if I compile a .c file?

Yes. GCL 'translates' lisp code to C and compiles it with gcc (if your
default compiler is gcc of course)


> I would not have expected anything else, but if someone could make my
> search space a bit smaller that would help.

You can begin with  src/interp/i-syscmd.boot.pamphlet (search for
compile)


> Well, I simply removed fact.o and started a new Axiom. I said:
>
> )lib fact
> fact 3
>
> and got 6 as result. Which code did I execute?

fact.lsp (the code is interpretated).

>
> >> That should in priciple be possible once I have libaxiom.al,
> >> I just haven't tried it yet.
>
> > Let me know if you succeed.
>
> I'll post my experience with that.
>

\start
Date: 16 Mar 2006 19:23:00 +0100
From: Gabriel Dos Reis
To: Bill Page
Subject: Re: Domains and expressions

Bill Page writes:

| Gaby,
| 
| On March 14, 2006 6:42 PM you wrote:
| > 
| > Chasing links led me to this
| > 
| >
| http://portal.acm.org/citation.cfm?id=190695&dl=GUIDE&coll=GUIDE&CFID=673307
| 48&CFTOKEN=77193109
| 
| > Do people know what happens to "Gauss"?
| 
| Once long ago as a new user of Maple I remember trying Gauss.
| I was distinctly unimpressed. That was with Maple release 4
| which actually, I rather liked.

Thanks for sharing your experience.  I was asking because I did not
seem to be successful in getting anything from web-searching.

| I believe that at the time Gauss was available from MapleSoft,
| but I can't find it now on their website. If you are really
| interested you might inquire at
| 
| http://www.maplesoft.com
| 
| Of course the idea of adding something as heavy as an object-
| oriented strongly-typed extension to an untyped interpreted
| language is pretty questionable anyway... I think B#, adding
| an "untyped" interpreted user-level language to a strongly-typed
| language like Aldor, makes more sense. Don't you think?

Yes; I was intrigued by the paper.

| > In their approach to mimic Axiom, they avoid been careful in
| > making AbelianMonoid "derive" from Monoid.  
| 
| Yes, that is interesting - nice diagram. I wonder how much
| of that was actually implemented?

Good question.

| Here is the only other reference I could find:
| 
| Design and implementation of symbolic computation systems:
| International Symposium, DISCO '93, Gmunden, Austria,
| September 15-17, 1993 : proceedings
| (Lecture notes in computer science)
| 
| http://books.google.com/books?id=NrpGnrVET_MC
| 
| You might want to check if your library has a copy.

Thanks, I'll try that.

| Gauss: A Parameterized Domain of Computation System with
| Support for Signature Functions, by M.B Monagan, page 81. 
| 
| Notice also the article by Tony Hearn about order-sorted
| algebras: "An Order-Sorted Approach to Algebraic Computation".
| Page 134.

\start
Date: Thu, 16 Mar 2006 21:17:31 -0500
From: Bill Page
To: Gabriel Dos Reis
Subject: RE: Domains and expressions

Gaby,

On Thursday, March 16, 2006 1:23 PM you wrote:
> | >
> | > Chasing links led me to this
> | >
http://portal.acm.org/citation.cfm?id=190695&dl=GUIDE&coll=GUIDE&CF=
ID=67
330748&CFTOKEN=77193109
> |
> | > Do people know what happens to "Gauss"?
> |
> ...
> | > In their approach to mimic Axiom, they avoid been careful
> | > in making AbelianMonoid "derive" from Monoid. 
> |
> | Yes, that is interesting - nice diagram. I wonder how much
> | of that was actually implemented?
>
> Good question.
>

It looks as if everything that was described above was indeed
implemented.

I can't believe I actually found this!

http://www.hrz.uni-oldenburg.de/software/maple/share/Das_Share-Verzeichn
is/gauss

It seems that Gauss may have been part of the Maple Share library
up to release 5.

http://www.hrz.uni-oldenburg.de/software/maple

Here is (as far as I can tell) the entire Maple source code for
Gauss:

http://page.axiom-developer.org/gauss.tgz

There is another (older?) version here:

ftp://ftp.inf.ethz.ch/pub/maple/5.0

I haven't it tried yet, but I doubt that this code would run
unmodified on any versions of Maple newer than release 5. It
looks like this code is designed to be "installed" by piping
it to the old command line Maple (not gui).

For some basic instructions take a look towards the end of the
file named 'gauss'.

\start
Date: Thu, 16 Mar 2006 22:23:51 -0500
From: Tim Daly
To: Ralf Hemmecke, Gregory Vanuxem, Peter Broadbery, Gary King, Bill Page, William Sit, Gabriel Dos Reis, Martin Rubey
Subject: re: category/domain/type discussion work product

suggestion.....

there's been a long running discussion that contains some fine points
about axiom and it's interpretetation of categories, domains, and types.

an effort to collect, review, and summarize this discussion in either
a tutorial form or as potential axiom/aldor compiler documentation 
would make for a very useful "work product". a pamphlet file with
runnable code would make it quite useful.

anybody interested?

\start
Date: 17 Mar 2006 15:47:07 +0100
From: Martin Rubey
To: Francois Maltey
Subject: Re: expand sin (nx) and cos (nx)

Dear Francois,

Francois Maltey writes:

> I hope I can compile it without problem later inside the MANIP.spad

yes.

> At the end of this input file you can try : 
> 
> expand1 (cos (3*x))+%i*expand1 (sin (3*x)) - (cos(x)+%i*sin(x))^3
> expand1 (cos (a+b))
> expand1 (sin (a-b))  -- doesn't work
> expand1 (sin (b-a))  -- is right
> 
> So I have several problems :
> 
> // A //
> 
> My first function is a function which gives the name of the function :
> 
> With mupad I done :
> op (3*x+5*y, 1)   -> _plus
> op (3*x, 1)       -> _mult
> op (x^3, 1)       -> _power
> op (sin(3*x), 1)  -> sin
> op (cos(3*x), 1)  -> cos

in axiom there are operations isPlus, isTimes and so on. Maybe this helps. In
fact, it seems to me that you only need to test whether your expression is of
the form sin(something) or cos(something). This can be easily done with the
domain PATTERN and the operation isOp

For example, try:

isOp(sin(x)::PATTERN INT)$PATTERN INT

or 

s := (isOp(sin(x)::PATTERN INT)$PATTERN INT).op

(I just forgot how to get the operator "sin")

isOp(sin(x+y)::PATTERN INT, s)$PATTERN INT

> // B //
> 
> Why must I add some coerces  in this input file

the coercions b := ... : EXPR INT are necessary, since "numer" returns a
SparseMultivariatePolynomial. If you want to get an Expression, try "numerator"
instead. However, in the EXPR domain there is no leadingMonomial. So the
coercion is necessary.

> // C //
> 
> What are the usual Expression ... type.
> 
> Can I be sure that coef in Integer, Fraction Integer, Complex Integer ?
> Is it possible to have Float or DoubleFloat...

No. There is no usual EXPR ... type. Well, Boolean does not work well. Float
does, though.

> How can I test if variable coef in an Integer or not ? 

Looking at your code, coef is of type R if arg is of type EXPR R. Thus if R is
INT, you are done. If R is something else you have to use 

(retractIfCan coef)@Union(Integer,"failed")

Sorry that I'm answering late, but I'm out of time currently...

\start
Date: 17 Mar 2006 19:11:21 +0100
From: Gabriel Dos Reis
To: Ralf Hemmecke
Subject: Re: Domains and expressions

Ralf Hemmecke writes:

| On 03/16/2006 07:23 PM, Gabriel Dos Reis wrote:
| > Bill Page writes:
| > | > In their approach to mimic Axiom, they avoid been careful in
| > | > making AbelianMonoid "derive" from Monoid.  | | Yes, that is
| > interesting - nice diagram. I wonder how much
| > | of that was actually implemented?
| > Good question.
| 
| No it is so simple. They actually suffer from the same problem that we
| have with Axiom/Aldor. However, if you look at the code you find the
| stuff below. It is simply that: Gauss-Monoid is written additively,
| and Gauss-AbelianMonoid, too. We could do that in Axiom, too. So, no
| surprise.
| 
| BTW, if you look at Gauss-Ring, you find that the multiplicative
| structure is not a derived from Gauss-Monoid.

Interesting, so "to see is to believe" is not true :-)

\start
Date: Sun, 19 Mar 2006 16:58:04 -0500
From: Bill Page
To: Gabriel Dos Reis
Subject: RE: Domains and expressions

Gaby,

On March 17, 2006 1:11 PM you wrote:
>
> Ralf Hemmecke writes:
>
> | On 03/16/2006 07:23 PM, Gabriel Dos Reis wrote:
> | > Bill Page writes:
> | > | > In their approach to mimic Axiom, they avoid been careful
> | > | > in making AbelianMonoid "derive" from Monoid.
> | > | Yes, that is interesting - nice diagram. I wonder how much
> | > | of that was actually implemented?
> | > Good question.
> |
> | No it is so simple. They actually suffer from the same
> | problem that we have with Axiom/Aldor. However, if you
> | look at the code you find the stuff below. It is simply
> | that: Gauss-Monoid is written additively, and Gauss-AbelianMonoid,
> | too. We could do that in Axiom, too. So, no surprise.
> |
> | BTW, if you look at Gauss-Ring, you find that the
> | multiplicative structure is not a derived from Gauss-Monoid.
>
> Interesting, so "to see is to believe" is not true :-)
> Thanks!
>

Someone more knowledgeable about Maple than I has pointed out
to me that "Gauss" became the package called "Domains". This
is distributed with the current Maple release 10. Here is the
introduction to Domains from the Maple documentation:

Domains Version 1.0

Description

Domains is a tool for developing code for complicated algorithms. The
computational facilities offered by Domains differ from Maple in that =
you
can parameterize a domain, for example, a polynomial or matrix ring, by =
the
coefficient ring. This means that the code is more general as it will =
work
in principle for any coefficient ring.

When computing in Domains, you first construct a domain of computation. =
For
example, if you want to compute univariate polynomials with rational
coefficients, first create the Q[x] domain as follows

> with(Domains):
> P := DenseUnivariatePolynomial(Q, x):

The value assigned to P is a Maple table of the operations, available =
for
computing with polynomials in Q[x]. For example, you can compute the
remainder of two polynomials a and b by doing

> P[Rem](a,b);

To use Domains interactively, you must first load it into Maple using
with(Domains);
This also assigns the variables Z and Q to the domain of integers and
rationals respectively, by executing

> Z := Integers():
> Q := Rationals():

and defines many standard abbreviations for the domains known to =
Domains.
For more information, see Domains/domain. Having defined the integers Z, =
you
can compute the remainder of two integers m and n by doing

> Z[Rem](m,n);

The principle advantage Domains offers over Maple is in allowing you to
parameterize domains (for example, polynomial, series, and matrix rings) =
by
a coefficient ring R. If you know how to compute in a coefficient ring =
R,
and you write code for polynomials, then that code should work for any =
ring
R. You should not have to rewrite the polynomial code for a new R.

Consider another example. Suppose you have implemented Gaussian =
elimination
to solve a linear system of equations over a field F. Domains allows you =
to
parameterize your subroutine by F so that your routine works for all =
fields,
not just the field of rational numbers that you may have envisioned when
writing the routine. This is accomplished by grouping all operations in =
a
ring or a field into a datastructure called a domain. In Domains, a =
domain
is a Maple table of operations. For more details on domains and a list =
of
known domains, see Domains/domain.

Coding

Coding with the Domains tool is quite straightforward, although you must
package-call every operation.(See Domains/example.) For an example of =
how to
code a simple function that computes with values of a domain, see
Domains/coding.

Coding domains is somewhat more difficult and also cumbersome because =
nested
lexical scopes and closures are not supported in Maple and must be
simulated. It is recommended that you study the code of existing =
domains.

Before using Domains, read the help file Domains/example to see a =
Domains
sample session.
Acknowledgements

Some of the main ideas behind Domains come from the AXIOM system, which =
was
formerly called Scratchpad II. AXIOM also has the notion of =
parameterized
types which it calls domains. The author of Domains would like to
acknowledge the use of the primary idea behind AXIOM, namely that of =
passing
as a parameter a collection of functions as a single unit, which the =
authors
of AXIOM have termed a domain.

See Also

Domains/coding, Domains/domain, Domains/evaldomains, Domains/example,
RealDomain

--------------

Here are two references to the use of the Maple Domains package:

http://www.cas.mcmaster.ca/~carette/publications/ge.pdf

Gaussian Elimination: a case study in efficient
genericity with MetaOCaml

Jacques Carette

Abstract

The Gaussian Elimination algorithm is in fact an algorithm family -
common implementations contain at least 6 (mostly independent)
design choices. A generic implementation can easily be parametrized
by all these design choices, but this usually leads to slow and
bloated code. Using MetaOCaml's staging facilities, we show how
we can produce a natural and type-safe implementation of Gaussian
Elimination which exposes its design choices at code-generation
time, so that these choices can effectively be specialized away,
and where the resulting code is quite efficient.

---------

http://www4.ncsu.edu/~kaltofen/bibliography/99/KaMo99.pdf

On the Genericity of the Modular Polynomial GCD Algorithm*
(c) 1999 ACM

Erich Kaltofen
North Carolina State University
Mathematics Department, Box 8205
Raleigh, N.C. 27695-8205 USA.
E-mail: kaltofen@math.ncsu.edu
URL: www.math.ncsu.edu/~kaltofen

Michael Monagan
Centre for Experimental and Constructive Mathematics
Simon Fraser University
Burnaby, British Columbia, V5A 1S6 Canada.
E-mail: monagan@cecm.sfu.ca

Abstract
In this paper we study the generic setting of the modular
GCD algorithm. We develop the algorithm for multivariate
polynomials over Euclidean domains which have a special
kind of remainder function. Details for the parameterization
and generic Maple code are given. Applying this generic
algorithm to a GCD problem in Z=(p)[t][x] where p is small
yields an improved asymptotic performance over the usual
approach, and a very practical algorithm for polynomials
over small finite fields.

\start
Date: 17 Mar 2006 06:46:00 +0100
From: Gabriel Dos Reis
To: Tim Daly
Subject: Re: category/domain/type discussion work product
Cc: Gary King

Tim Daly writes:

| suggestion.....
| 
| there's been a long running discussion that contains some fine points
| about axiom and it's interpretetation of categories, domains, and types.
| 
| an effort to collect, review, and summarize this discussion in either
| a tutorial form or as potential axiom/aldor compiler documentation 
| would make for a very useful "work product". a pamphlet file with
| runnable code would make it quite useful.
| 
| anybody interested?

Funny you had to ask :-)
As a consequence of the discussion, I started writing something called
"Is the Riemann's Zeta Function Object-Oriented?" that discusses many
points raised in the discussion -- but the current version is still
preliminary.  I'll post it here for feedback.  Right now, I'm a middle
of "grand debate" about "concepts for C++" for two or three days --
which has points in common with the the discussion on this list.  

However, my discussion is a bit biased so I would nto mind a
"balancing" mind :-)

\start
Date: Fri, 17 Mar 2006 11:02:44 +0100
From: Ralf Hemmecke
To: Gabriel Dos Reis
Subject: Re: Domains and expressions

On 03/16/2006 07:23 PM, Gabriel Dos Reis wrote:
> Bill Page writes:
> | > In their approach to mimic Axiom, they avoid been careful in
> | > making AbelianMonoid "derive" from Monoid.  
> | 
> | Yes, that is interesting - nice diagram. I wonder how much
> | of that was actually implemented?
> 
> Good question.

No it is so simple. They actually suffer from the same problem that we 
have with Axiom/Aldor. However, if you look at the code you find the 
stuff below. It is simply that: Gauss-Monoid is written additively, and 
Gauss-AbelianMonoid, too. We could do that in Axiom, too. So, no surprise.

BTW, if you look at Gauss-Ring, you find that the multiplicative 
structure is not a derived from Gauss-Monoid.

Ralf

Monoid := proc() local M;
     option `Copyright 1992 Wissenschaftliches Rechnen, ETH Zurich`;
     M := SemiGroup(args);
     if hasCategory(M,Monoid) then RETURN(op(M)) fi;
     addCategory(M,Monoid);
     defOperation( 0, M, M );    # the additive identity
     addProperty( M, NormalForm );    # must be a unique constant
     op(M)
end:

AbelianMonoid := proc() local M;
     option `Copyright 1992 Wissenschaftliches Rechnen, ETH Zurich`;
     M := Monoid(args);
     addCategory(M,AbelianMonoid);
     addProperty(M,Commutative(`+`));
     op(M)
end:

\start
Date: Tue, 21 Mar 2006 12:53:25 +0100
From: Ralf Hemmecke
To: Bill Page
Subject: Re: libaxiom.a

Hi Bill,

let me CC this to axiom-developer since there might be some more people 
who know how Axiom works internally.

A sort summary. Last night I tried to compile libaxiom.al -> libaxiom.a. 
That did not work because the Aldor compiler told me.

[...]
ar x libaxiom.al basecliq.ao;
/home/hemmecke/software/Aldor/aldor/linux/latest/bin/aldor -Y . -fo 
-csmax=0 -laxiom *.ao;
Compiler bug...Bug: Bad case 3 (line 4588 in file ../src/genc.c).
make: *** [libaxiom.a(basecliq.o)] Error 1

Why would someone want libaxiom.a in the first place?

Well, that is needed to produce stand alone programs. And I was and I am 
still not sure how library code is executed internally inside Axiom. Is 
it always interpreted LISP or does AXIOMsys contain object code from the 
  ALGEBRA libraries? (More below.)

...

> You mean stand alone Aldor programs that use Axiom domains?

Right.

> This is possible now in Aldor isn't it?  I haven't tried to
> do this, but there is a small section in the Aldor users guide
> about it.

Oh, which one? I've just searched through the .pdf and there does not 
appear the string

   "axiom"

(including quotes) and found nothing. :-(

But, hey, what is this?
http://www.aldor.org/docs/HTML/chap18.html#12

That simply means that the online version and the up-to-date 
cvs-repository-version of the userguide at aldor.org are not identical. 
The online version is older.

Under 18.13 it says...
   At present, code from the AXIOM library will only run inside an
   AXIOM  workspace. Consequentely Aldor programs extending the
   AXIOM library will only run inside AXIOM. For a later version,
   it is planned that the entire AXIOM library will be translated
   into Aldor, at which point it should be possible to call it
   from C, Fortran, or any other environment in which Aldor operates.

The reason is that currently there is no libaxiom.a. And I have no idea 
whether the .o files under mnt/linux/algebra/ can simply be packaged to 
libaxiom.a. I rather believe that they cannot, since the names differ 
from the names in libaxiom.al.

It means currently, there is no way to get a standalone program that 
uses libaxiom. So there is also no way to call Axiom routines from a C 
program. (That is possible if you just take libaldor and libalgebra.)

>> and I also guess, that they are a bit faster, since all this
>> is binary format and not interpreted by the LISP machine.
> 
> I had assumed that when compiled in stand alone mode, the
> necessary Axom domains would be compiled to binary if
> specified by the compiler options.
> 
>> But maybe, you tell me that inside Axiom the domains living
>> in libaxiom are executed in a binary fashion anyway and only
>> the domains etc. that are entered into the interpreter are
>> interpreted.
> 
> Even these are compiled and run as machine code if you use
> 
> )set functions compile on
> 
> however these are not saved permanently.

I have to trust you that this would be machine code and not some 
intermediate code which is approximately at the level of Java byte code.

> Axiom is quite different from Maple because it is based on
> Lisp. Whether the Lisp code is interpreted or compiled is
> (mostly) transparent to Axiom. In Axiom, both SPAD and Aldor
> generate Lisp code that is then (usually) compiled to machine
> object code and effectively become a dynamic extension of Axiom
> itself. There is no "Axiom kernel" as such except of course
> there is a lot of special purpose code that implements the
> Axiom interpreter and the SPAD compiler all of which is written
> in Lisp (plus Boot, which is a kind of high-level Lisp).
> Very few mathematical primitives are "built-in" at the Lisp/Boot
> level - almost all of the mathematics is compiled from SPAD
> code.

OK, I should have been more precise. By "Axiom kernel", of course, I 
meant the current Algebra stuff (basically everything that goes into 
libaxiom.al). I know that Axiom actually has NO kernel in the sense of 
Maple (except a very tiny little bit of built-in knowledge). But what 
you are saying sounds like: If I call a function from a domain that 
currently exists in Axiom (say, UnivariatePolynomial Integer), then that 
code is executed in object form (.o). So the .o files of all the Axiom 
domains should already be compiled into AXIOMsys, right?

Now if I compile a new function via

)set functions compile on

next time I use that function, the spad compiler and gcl should be 
invoked to get a (temporary) .o file. And more, that file should be 
loaded dynamically. Is that really the case?

\start
Date: Tue, 21 Mar 2006 15:04:02 +0100
From: Gregory Vanuxem
To: Ralf Hemmecke
Subject: re: libaxiom.a

Hi,

Le mardi 21 mars 2006 =E0 12:53 +0100, Ralf Hemmecke a =E9crit :

[...]

> OK, I should have been more precise. By "Axiom kernel", of course, I
> meant the current Algebra stuff (basically everything that goes into
> libaxiom.al). I know that Axiom actually has NO kernel in the sense of
> Maple (except a very tiny little bit of built-in knowledge). But what
> you are saying sounds like: If I call a function from a domain that
> currently exists in Axiom (say, UnivariatePolynomial Integer), then tha=
t
> code is executed in object form (.o). So the .o files of all the Axiom
> domains should already be compiled into AXIOMsys, right?


See http://lists.gnu.org/archive/html/gcl-devel/2005-10/msg00064.html
Here 'fasl' means .o file.

\start
Date: Tue, 21 Mar 2006 10:59:48 -0500
From: Tim Daly
To: Ralf Hemmecke
Subject: re: libaxiom.a

> Why would someone want libaxiom.a in the first place?
> 
> Well, that is needed to produce stand alone programs. And I was and I am 
> still not sure how library code is executed internally inside Axiom. Is 
> it always interpreted LISP or does AXIOMsys contain object code from the 
>   ALGEBRA libraries? (More below.)
> 
>    At present, code from the AXIOM library will only run inside an
>    AXIOM  workspace. Consequentely Aldor programs extending the
>    AXIOM library will only run inside AXIOM. For a later version,
>    it is planned that the entire AXIOM library will be translated
>    into Aldor, at which point it should be possible to call it
>    from C, Fortran, or any other environment in which Aldor operates.

Ralf,

In standard GCL when you compile a lisp program GCL outputs C code,
compiles it with GCC and dynamically links it with the GCL system.
Thus,

   GCL lisp code -> C code (gazonk.c) -> GCC -> dynamic link to lisp

In AXIOMsys, which is just lisp code running in GCL, the spad compiler
generates lisp code (see any .NRLIB/code.lsp file) and asks GCL to compile it.

  spad -> GCL lisp code -> C code -> GCC -> dynamic link to lisp

When you use aldor inside AXIOMsys the process is:

  aldor -> GCL lisp code -> C code -> GCC -> (libaldor + dynamic link to lisp)

thus all compiled GCL code actually executes machine code.



AXIOMsys has a large set of libraries. These libraries can't be compiled
and executed standalone because they assume the underlying lisp
(grep for $Lisp in the algebra sources).

There have been numerous attempts by many people to create a standalone
version of the AXIOMsys library. All have failed because the libraries
assume lisp. I suppose you could figure out a way to link GUILE into
the aldor libraries and succeed thru that path. 

You should notice that making the axiom library run standalone is not
as useful a goal as it seems. There are about 100 computer algebra
systems I've collected and about 90 of them are of the compiler + library
form. The key flaw is that they are very difficult to use. The interpreter
knows certain things, like which libraries to dynamically load, how
to parse input, and how to simplify output that make it much more user
affectionate.

The dream was to have a standalone version of the axiom compiler rather
than an embedded version. I didn't believe this was useful then and I
still don't believe it is useful now. A more effective path would be
to load and compile your computation in lisp and then generate a 
standalone image to do that computation, sort of a special version
of AXIOMsys. This IS standalone, machine-language code with an embedded
lisp that can use all of the axiom library. CLISP will actually let you
generate a .exe file if you need it.

\start
Date: Tue, 21 Mar 2006 10:55:46 -0500
From: Bill Page
To: Tim Daly
Subject: re: libaxiom.a

Tim,

On Tuesday, March 21, 2006 11:00 AM you wrote:
> ...
> AXIOMsys has a large set of libraries. These libraries
> can't be compiled and executed standalone because they
> assume the underlying lisp (grep for $Lisp in the algebra
> sources).
>

Very true.

> There have been numerous attempts by many people to create
> a standalone version of the AXIOMsys library. All have
> failed because the libraries assume lisp. I suppose you
> could figure out a way to link GUILE into the aldor
> libraries and succeed thru that path.

I cannot see any clear reason to prefer GUILE or even Scheme
over Lisp or even FOAM (the Aldor abstract machine). Also it
seems rather "narrow minded" to think that "standalone"
necessarily means the same thing as "without lisp"... ;)

>
> The dream was to have a standalone version of the axiom
> compiler rather than an embedded version. I didn't believe
> this was useful then and I still don't believe it is useful
> now.

That's like saying that "stand alone" Fortran doesn't make
sense without the IBM 360 or that "C" is of no value without
Unix. That is clearly incorrect. As leading-edge compilers,
both SPAD and Aldor represent a great deal of value on their
own - whether they are used to write Axiom library code or
not.

> A more effective path would be to load and compile your
> computation in lisp and then generate a standalone image to
> do that computation, sort of a special version of AXIOMsys.
> This IS standalone, machine-language code with an embedded
> lisp that can use all of the axiom library.

Yes, I agree completely. That is the right way to go.

What would you suggest might be the minimal GCL environment
required to run most of the Axiom library code? Assuming that
we do not want to keep any of the Axiom interpreter but just
the minimum support for SPAD and/or the Aldor interface,
would it be a good idea to start with BOOTSYS or something
earlier in the bootstrap cycle? How much work would it be
to determine exactly what modules are required? And
realistically, how much memory are we likely to save in
the resulting "standalone" executable but dropping all
the stuff that we don't need?

\start
Date: Tue, 21 Mar 2006 12:20:38 -0500
From: Tim Daly
To: Bill Page
Subject: re: libaxiom.a

> > There have been numerous attempts by many people to create
> > a standalone version of the AXIOMsys library. All have
> > failed because the libraries assume lisp. I suppose you
> > could figure out a way to link GUILE into the aldor
> > libraries and succeed thru that path.
> 
> I cannot see any clear reason to prefer GUILE or even Scheme
> over Lisp or even FOAM (the Aldor abstract machine). Also it
> seems rather "narrow minded" to think that "standalone"
> necessarily means the same thing as "without lisp"... ;)

Greenspun's Tenth Rule:

Any sufficiently complicated C or Fortran program contains an ad hoc,
informally specified, bug-ridden, slow implementation of half of
Common Lisp.

Here known as the motto of the narrow minded :-)

All of these algorithms assume underlying data structures. 
All of these data structures are efficiently coded in lisp
and optimized for the type of access. All of these data
structures use memory efficiently. 

Can you do this in C? Obviously since GCL is written in C.

Can you do this without implementing half of Common Lisp in an ad hoc,
informally specified, bug-ridden, slow implementation? Nope. Years of
research have gone into the internals of Common Lisp systems. It seems
a bit much to expect a single programmer to duplicate the task in a
single standalone program and get it right, let alone get it efficient
and bug free.

Further, you'll notice that can dynamically create and compile
functions which argues that the compiler must live within the
standalone image.

> That's like saying that "stand alone" Fortran doesn't make
> sense without the IBM 360 or that "C" is of no value without
> Unix. That is clearly incorrect. As leading-edge compilers,
> both SPAD and Aldor represent a great deal of value on their
> own - whether they are used to write Axiom library code or
> not.

No, you misinterpret what I wrote. Compilers are not libraries.
Compilers are only a small part of what you think of as "C".
It's the libraries that make C useful.

Aldor is a compiler and, without libraries, is only an interesting
demonstration of some techniques such as post-facto extensions.
My argument is that Aldor is not very interesting without a strong
library. The fundamental differences between spad and aldor are
quite small.

There are 90-some "library" computer algebra systems around.
Every one of them will do polynomial arithmetic, almost all of
them using a nice hierarchy with operator overloading, etc.
Few of them are used by anyone but their authors. 

The Axiom libraries took many, many years to build and they depend
on an underlying common lisp. To use them standalone you necessarily
have to duplicate the lisp functions.

If you really want to think about the world from the compiler viewpoint
then consider that GCL is just a large library of C code that gets
linked with your Aldor code and the Axiom library code. The AXIOMsys
image does all of this linking and saves a standalone image.

> What would you suggest might be the minimal GCL environment
> required to run most of the Axiom library code? Assuming that
> we do not want to keep any of the Axiom interpreter but just
> the minimum support for SPAD and/or the Aldor interface,
> would it be a good idea to start with BOOTSYS or something
> earlier in the bootstrap cycle? How much work would it be
> to determine exactly what modules are required? And
> realistically, how much memory are we likely to save in
> the resulting "standalone" executable but dropping all
> the stuff that we don't need?

Well, BOOTsys can clearly disappear :-)

You'll notice that I've already done this analysis. There are two 
indications. First, you'll notice that some domains are pre-loaded
into the AXIOMsys image. These are the most frequently referenced 
domains. Second, you'll see that certain lisp routines are autoloaded
only when asked (the autoload subdirectory). Any routine that is not
commonly referenced is already out of the image.

If you start up an AXIOMsys and "warm it up" by doing the kind of 
computations you want so that it won't have to load any more libraries
then you can just drop into lisp and do a (save-system) call and you
have "compiled, linked, and saved" a special purpose standalone program
to do your task. What could be easier?

\start
Date: Tue, 21 Mar 2006 12:36:11 -0500
From: Bill Page
To: Tim Daly
Subject: re: libaxiom.a

Tim,

On Tuesday, March 21, 2006 12:21 PM you wrote:
>
> Greenspun's Tenth Rule:
>
> Any sufficiently complicated C or Fortran program contains an
> ad hoc, informally specified, bug-ridden, slow implementation
> of half of Common Lisp.
>
> Here known as the motto of the narrow minded :-)

No.

I (more or less) agree with "Greenspun's Tenth Rule". I don't
think it is narrow-minded at all. What I said was that to
think that "standalone" means *without* lisp is narrow-minded.
I think we agree, no? I think it is open-minded (in fact almost
essential) to include lisp - or something very much like lisp.

> ...
> The dream was to have a standalone version of the axiom
> compiler rather than an embedded version. I didn't believe
> this was useful then and I still don't believe it is useful
> now.
> ...
> > That's like saying that "stand alone" Fortran doesn't make
> > sense without the IBM 360 or that "C" is of no value without
> > Unix. That is clearly incorrect. As leading-edge compilers,
> > both SPAD and Aldor represent a great deal of value on their
> > own - whether they are used to write Axiom library code or
> > not.
>
> No, you misinterpret what I wrote. Compilers are not libraries.
> Compilers are only a small part of what you think of as "C".
> It's the libraries that make C useful.

I disagree. It is "C" that made the C libraries possible. I am
not claiming that the libraries are irrelevant - far from it.
Almost all modern languages aim at providing a fundamental,
simple and minimal formalism with which to express algorithms
and they depend to a very great degree on the functionality
contained in the libraries that are written in the language
itself. But not all languages are created equal.

There is a huge discipline (I suppose I cannot say science)
of programming language design. Some languages are clearly
successful and others falter even though in theory they are
all formally equivalent in power when it comes to computation.
Not all of these failures are due to "political" or "personal"
reasons. Some have technical explanations based on credible
theories.

SPAD and Aldor were (and still are) great experiments in
programming language design. Even they were motivated primarily
by the need to solve the particular problems encountered in
symbolic mathematics, all computation is symbolic in the final
analysis so the design of SPAD and Aldor really applies directly
to general computation.

I think the relative inaccessibility of SPAD and Aldor to the
rest of the programming community, outside of the much smaller
subset of computer algebra programmers, has resulted in a
significant duplication of intellectual effort in "modern"
programming languages like Python, Ruby, Haskell, and even C++.
I expect that SPAD and Aldor still have a few "tricks" perhaps
not yet re-discovered by the mainstream, but the longer they
remain dormant, the less relevant they become. Axiom is
dependent on the continued support and development of SPAD
and/or Aldor, so the more widely accessible they are to the
programming language community as a whole, the better it is
for us Axiom users/developers. Otherwise before the "30 year
horizon" is up we (or those who come after us :) are likely
to find ourselves re-implementing the Axiom library in some
descendent of Python or Haskell...

>
> Aldor is a compiler and, without libraries, is only an
> interesting demonstration of some techniques such as post-
> facto extensions. My argument is that Aldor is not very
> interesting without a strong library. The fundamental
> differences between spad and aldor are quite small.

I agree that the differences between SPAD and Aldor are quite
small. But disagree that they are not interesting without a
strong library. The point of programming language design is to
make it possible to efficiently create such "strong libraries"
in the first place.

Of course to apply SPAD and Aldor to computer algebra problems
does require a very "strong library" and of course the enormous
effort invested in the creation of Axiom's library is still
the strongest part of *Axiom*. But that is a separate issue
from the choice of language that we use to implement that
library.

> ...
> The Axiom libraries took many, many years to build and they
> depend on an underlying common lisp. To use them standalone
> you necessarily have to duplicate the lisp functions.

Yes, I agree. But really that is not such a "big deal" since
as you already said: all programming languages (to a greater or
lesser degree) tend to implement at least some minimal subset
of lisp. Languages such as Python, Haskell and the even the
"stand alone", i.e. C-runtime environment, of Aldor all provide
the kind of basic functionality that is required implement the
Axiom library. For example, they all have an infinite precision
Integer data type, list data structures, product and union data
types etc.

>
> If you really want to think about the world from the compiler
> viewpoint then consider that GCL is just a large library of
> C code that gets linked with your Aldor code and the Axiom
> library code. The AXIOMsys image does all of this linking and
> saves a standalone image.

Yes.

>
> > What would you suggest might be the minimal GCL environment
> > required to run most of the Axiom library code? Assuming that
> > we do not want to keep any of the Axiom interpreter but just
> > the minimum support for SPAD and/or the Aldor interface,
> > would it be a good idea to start with BOOTSYS or something
> > earlier in the bootstrap cycle? How much work would it be
> > to determine exactly what modules are required? And
> > realistically, how much memory are we likely to save in
> > the resulting "standalone" executable but dropping all
> > the stuff that we don't need?
>
> Well, BOOTsys can clearly disappear :-)
>

I presume you mean the BOOT to Lisp compiler part of BOOTSYS?
Aren't there other modules compiled into the BOOTSYS image
that are required for the Axiom library? How can we get just
the "deep level" support environment necessary to run the
already previously compiled BOOT code?

> You'll notice that I've already done this analysis.
> There are two indications. First, you'll notice that
> some domains are pre-loaded into the AXIOMsys image. These
> are the most frequently referenced domains. Second, you'll
> see that certain lisp routines are autoloaded only when
> asked (the autoload subdirectory). Any routine that is not
> commonly referenced is already out of the image.

Yes, but aren't these domains loaded into a previously
saved Lisp image that already includes BOOTSYS and all
the other stuff that allowed us to get to that point in
the build cycle?

>
> If you start up an AXIOMsys and "warm it up" by doing the
> kind of computations you want so that it won't have to
> load any more libraries then you can just drop into lisp
> and do a (save-system) call and you have "compiled,
> linked, and saved" a special purpose standalone program
> to do your task. What could be easier?
>

Sure, but that is not what I would call a "minimal run-time
environment"! We still have all the Axiom interpreter, the
BOOT compiler and a lot of other stuff that we never intend
to use in our "stand alone" program.

\start
Date: Tue, 21 Mar 2006 12:34:07 -0800
From: Antoine Hersen
To: list
Subject: Minimal Algebra

Hello,

While reading the Axiom in the class room message I got this idea.

What about starting with an almost blank Axiom, and re building up
everything in a naive and minimal but instructive way ?

How should one do it ?

What will be the very minimum to keep ?

Will it have any learning value ?

\start
Date: 21 Mar 2006 21:47:50 +0100
From: Francois Maltey
To: list,Francois Maltey
Subject: I can't translate from the interpreter to the compiler 

Hello,

In the interpreter I have this single line :

fct (n, x) == eval (real ((c + %i * s)^n), [c, s], [cos x, sin x])

I want to add this function in manip.spad... :-(

So I add theses macros :

  CI      ==> Complex Integer
  LV      ==> OrderedVariableList [c,s]
  PCI     ==> SparseMultivariatePolynomial(Complex Integer, LV)
  PI      ==> SparseMultivariatePolynomial(Integer, LV)

I add theses variables :

  v1c := ((variable (c))@Union (OrderedVariableList [c,s], "failed"))::LV
  v1s := ((variable (s))@Union (OrderedVariableList [c,s], "failed"))::LV
  vc := v1c :: PCI
  vs := v1s :: PCI
  ve : PCI := vc + (imaginary()::CI) * vs             -- the (c + %i * s)

The interpreter is fine : 8 caracters for the Moivre formula.
I become stupid in front of the compiler : I must type theses 5 lines.

And now after hours, axiom reject both

  real (ve^n)
  map (t +-> real t, ve^n)

How can I coerce this SMP Complex Integer to SMP Integer ?

How can I use eval from SMP (Integer, [c,s]) to SMP (R, K) ?
where R is the basis Ring of the Expression
  and K are the kernels? functions of Expression.

I hope the end of my program is easier to translate in *.spad.

If someone can help me, again...

the Mupad code for this is :

    if t = DOM_INT then
      y := y / n;
      S:= genident("S");
      C:= genident("C");
      return(subs(expand(((C+I*S)^n-(C-I*S)^n)/2/I),[C=cos(y),S=sin(y)]=
))
    end_if

If possible I prefer use real and imag, and no C+I*S and C-I*S.
But today I can't get any results.

And thanks a lot for your reponses about cartesian product, types, etc.

\start
Date: Tue, 21 Mar 2006 21:09:54 -0800
From: Antoine Hersen
To: list
Subject: Convert and Coerce

Hello,

I did not find much information about the difference betwen "convert"
and "coerce".

Coerce is the "::" operator. But I did not find much more.

Thanks in advance.

\start
Date: 22 Mar 2006 09:15:04 +0100
From: Martin Rubey
To: list
Subject: Axiom on Macintosh

A student just asked me whether Axiom will run on Macintosh.

So, did you succeed, Tim?

\start
Date: Wed, 22 Mar 2006 12:17:46 +0100
From: Ralf Hemmecke
To: Bill Page
Subject: re: libaxiom.a

Hi Tim,

On 03/21/2006 04:55 PM, Page, Bill wrote:
[snip]
>> A more effective path would be to load and compile your
>> computation in lisp and then generate a standalone image to
>> do that computation, sort of a special version of AXIOMsys.
>> This IS standalone, machine-language code with an embedded
>> lisp that can use all of the axiom library.
> 
> Yes, I agree completely. That is the right way to go.

I don't. Suppose, I am a Fortran or C programmer and for some reason I 
need as a subpart of all my numerical computations some symbolic stuff. 
As I understand Tim, I should consider my program as a subpart of a 
customized AXIOMsys. Do you think you could convince me to do that?

I would certainly rather look for a library that I just link to my 
program and be happy. Only the minimal part of Axiom which is relevant 
to my problem should go into my final executable.

I somehow think that providing (symbolic) libraries (besides the Axiom 
we have) is just another way to bring symbolic computation to a broader 
public. Is that such a bad idea?

Even Maple does now provide an interface to let external programs call 
Maple functions. However, you need to buy Maple. We could just provide 
appropriate libraries. Why should we forget about that potential?

\start
Date: Wed, 22 Mar 2006 10:03:54 -0500
From: Tim Daly
To: Martin Rubey
Subject: Re: Axiom on Macintosh

nope. not yet. --t

\start
Date: Wed, 22 Mar 2006 10:18:18 -0500
From: Bill Page
To: Ralf Hemmecke
Subject: re: libaxiom.a

Ralf,

On March 22, 2006 6:18 AM you wrote:
> 
> On 03/21/2006 04:55 PM, Page, Bill wrote:
> [snip]
> >> A more effective path would be to load and compile your
> >> computation in lisp and then generate a standalone image to
> >> do that computation, sort of a special version of AXIOMsys.
> >> This IS standalone, machine-language code with an embedded
> >> lisp that can use all of the axiom library.
> > 
> > Yes, I agree completely. That is the right way to go.
> 
> I don't. Suppose, I am a Fortran or C programmer and for some 
> reason I need as a subpart of all my numerical computations
> some symbolic stuff. As I understand Tim, I should consider
> my program as a subpart of a customized AXIOMsys. Do you
> think you could convince me to do that?

No. You should think of AXIOMsys as the subroutine library.

> 
> I would certainly rather look for a library that I just
> link to my program and be happy.

Yes. In fact GCL, on which Axiom is based is licensed as
if it were a library (LGPL). This is a common situation
for Lisp environments where there is no clear separation
between compiled code and the run time environment.

> Only the minimal part of Axiom which is relevant 
> to my problem should go into my final executable.

That is the hard part. There is an enormous overhead
necessary to do even simple symbolic computation. It is
possible to eliminate unnecessary code but the resulting
executable is like to still be quite huge. It would be
interesting to take a look for example the size of Aldor
executables compared to a similar (not symbolic) program
in "C". I expect there is also a large overhead to support
the Aldor FOAM run-time environment.

> 
> I somehow think that providing (symbolic) libraries (besides 
> the Axiom we have) is just another way to bring symbolic
> computation to a broader public. Is that such a bad idea?

That is a good idea. It should be made easier to use Axiom
in this way, i.e. via an application programmer interface
(API). Right now it is possible to do this via socket calls.
This is how Hyperdoc communicates with Axiom. A library that
makes this transparent or which eliminates the sockets and
calls GCL directly would be very nice. GCL has a foreign
function interface and I think it should be possible to use
this in reverse.

> 
> Even Maple does now provide an interface to let external 
> programs call Maple functions. However, you need to buy
> Maple.

Yes, I have used Maple's interface. Maple runs as a separate
kernel process just like the Axiom socket interface but this
is hidden by the API.

> We could just provide appropriate libraries. Why should we
> forget about that potential?
> 

I don't think we should forget about this potential but I
think there is more involved than "just providing appropriate
libraries"

\start
Date: 22 Mar 2006 17:02:21 +0100
From: Gabriel Dos Reis
To: Bill Page
Subject: Re: Domains and expressions

Bill Page writes:

| Gaby, 
| 
| On Thursday, March 16, 2006 1:23 PM you wrote:
| > | > 
| > | > Chasing links led me to this
| > | > 
| http://portal.acm.org/citation.cfm?id=190695&dl=GUIDE&coll=GUIDE&CFID=67
| 330748&CFTOKEN=77193109
| > | 
| > | > Do people know what happens to "Gauss"?
| > | 
| > ... 
| > | > In their approach to mimic Axiom, they avoid been careful
| > | > in making AbelianMonoid "derive" from Monoid.  
| > | 
| > | Yes, that is interesting - nice diagram. I wonder how much
| > | of that was actually implemented?
| > 
| > Good question.
| >
| 
| It looks as if everything that was described above was indeed
| implemented. 

That is great!

| I can't believe I actually found this!
| 
| http://www.hrz.uni-oldenburg.de/software/maple/share/Das_Share-Verzeichn
| is/gauss
| 
| It seems that Gauss may have been part of the Maple Share library
| up to release 5.
| 
| http://www.hrz.uni-oldenburg.de/software/maple
| 
| Here is (as far as I can tell) the entire Maple source code for
| Gauss:
| 
| http://page.axiom-developer.org/gauss.tgz

OK; many thanks.  I'll download it.

| There is another (older?) version here:
| 
| ftp://ftp.inf.ethz.ch/pub/maple/5.0
| 
| I haven't it tried yet, but I doubt that this code would run
| unmodified on any versions of Maple newer than release 5. It
| looks like this code is designed to be "installed" by piping
| it to the old command line Maple (not gui).
| 
| For some basic instructions take a look towards the end of the
| file named 'gauss'.

OK; thanks!

\start
Date: 22 Mar 2006 19:33:24 +0100
From: Martin Rubey
To: Tim Daly
Subject: Re: Axiom on Macintosh

Tim Daly writes:

> nope. not yet. --t

Is it going to happen any time soon?

\start
Date: Wed, 22 Mar 2006 15:13:58 -0500
From: Tim Daly
To: Martin Rubey
Subject: Re: Axiom on Macintosh

the key issue is GCL, actually.
i suspect once that is fixed then the build should go smoothly.
i'll check out the lastest gcl and see if the bug is fixed.

\start
Date: 22 Mar 2006 15:41:24 -0500
From: Camm Maguire
To: Tim Daly
Subject: re: Axiom on Macintosh

Greetings!  2.6.8pre should be ready here -- if not please let me
know.

Take care,

Tim Daly writes:

> the key issue is GCL, actually.
> i suspect once that is fixed then the build should go smoothly.
> i'll check out the lastest gcl and see if the bug is fixed.
> 

\start
Date: 22 Mar 2006 15:43:31 -0500
From: Camm Maguire
To: Bill Page
Subject: re: libaxiom.a
Cc: Ralf Hemmecke

Greetings!

Bill Page writes:

> Ralf,
> 
> On March 22, 2006 6:18 AM you wrote:

> > I somehow think that providing (symbolic) libraries (besides 
> > the Axiom we have) is just another way to bring symbolic
> > computation to a broader public. Is that such a bad idea?
> 
> That is a good idea. It should be made easier to use Axiom
> in this way, i.e. via an application programmer interface
> (API). Right now it is possible to do this via socket calls.
> This is how Hyperdoc communicates with Axiom. A library that
> makes this transparent or which eliminates the sockets and
> calls GCL directly would be very nice. GCL has a foreign
> function interface and I think it should be possible to use
> this in reverse.

Where did that mini-webserver-in-lisp project wind up again?  Please
excuse my forgetfulness.

\start
Date: 22 Mar 2006 23:59:57 +0100
From: Gabriel Dos Reis
To: Tim Daly
Subject: Re: B#

Tim Daly writes:

| Bill's interest in B-natural could easily be grounded in BOOT code.

Tim,

  Where is BOOT documented?

I believe I can understand some BOOT codes; but, it is better to be sure
than to guess :-)

\start
Date: Wed, 22 Mar 2006 20:15:12 -0500
From: Tim Daly
To: Gabriel Dos Reis
Subject: Re: B#

mnt/linux/doc/src/boot.Makefile.dvi contains the only existing documentation
of BOOT.

BOOT is unrelated to B-natural.

BOOT is a syntactic sugar cover for common lisp.
B-natural is a typeless cover for Axiom's types.

\start
Date: 23 Mar 2006 02:41:03 +0100
From: Gabriel Dos Reis
To: Tim Daly
Subject: Re: B#

Tim Daly writes:

| mnt/linux/doc/src/boot.Makefile.dvi contains the only existing documentation
| of BOOT.

Thanks!

| BOOT is unrelated to B-natural.
| 
| BOOT is a syntactic sugar cover for common lisp.
| B-natural is a typeless cover for Axiom's types.

I went through the previous discussion (including BOOT, B#, Aldor,
Axiom) and  I decided to try your idea of implementing B# using
BOOT.  

\start
Date: Wed, 22 Mar 2006 21:09:03 -0500
From: Bill Page
To: Gabriel Dos Reis
Subject: RE: B#

On March 22, 2006 8:41 PM Gabriel Dos Reis wrote:
> 
> Tim Daly (root) writes:
> 
> | BOOT is unrelated to B-natural.
> | BOOT is a syntactic sugar cover for common lisp.

I think it tastes whole lot better that way! :)

But your view of what constitutes "syntactic sugar" goes
way beyond mine. It doesn't look much like sugar when you
see the Lisp that the BOOT compiler generates.

> | B-natural is a typeless cover for Axiom's types.
>

Actually the original design of B# specifies a "uni-typed"
extension of the Axiom type system. I think the distinction
between being single-typed versus "typeless" is probably quite
important. Specifically it implies to me that one should
implement B# on top of the Axiom library in a language like
SPAD, or preferrably Aldor.
 
> I went through the previous discussion (including BOOT, B#,
> Aldor, Axiom) and I decided to try your idea of implementing
> B# using BOOT.  
> 

Go Gaby!

I think it would be great to see some new code written using
BOOT... and some documentation. But it is not clear to me what
advantage BOOT might provide in implementing B#.

\start
Date: Wed, 22 Mar 2006 22:11:59 -0500
From: Tim Daly
To: Bill Page
Subject: Re: B#

ok, lets get the confusion out of the way before this gets too far along...

The "stack" of languages looks like:

   spad -- an algebra language using types 
     spad compiler -- defines the algebra language and types
       boot -- a non-parenthesized common lisp which is untyped
         common lisp -- a parenthesized common lisp which is untyped

in the interpreter

   interpreter language -- spad-like, uses types
     boot -- a non-parenthesized common lisp which is untyped
       common lisp -- a parenthesized common lisp which is untyped

the B-natural language sits here:

 b-natural -- single-type langauge
   interpreter language -- spad-like, uses types
     boot -- a non-parenthesized common lisp which is untyped
       common lisp -- a parenthesized common lisp which is untyped

since boot is syntactic sugar for common lisp and quite unnecessary
for anything the future stacks look like:

   spad -- an algebra language using types 
     spad compiler -- defines the algebra language and types
       common lisp -- a parenthesized common lisp which is untyped

   interpreter language -- spad-like, uses types
     common lisp -- a parenthesized common lisp which is untyped

and maybe

 b-natural -- single-type langauge
   interpreter language -- spad-like, uses types
     common lisp -- a parenthesized common lisp which is untyped

Note that Bill and I disagree about boot's future.

Note that B-natural and Boot are COMPLETELY unrelated.

\start
Date: Wed, 22 Mar 2006 21:44:42 -0500
From: Bill Page
To: Tim Daly
Subject: RE: B#

On March 22, 2006 10:12 PM Tim Daly (root) wrote:
> 
> ok, lets get the confusion out of the way before this gets 
> too far along...

:o)

> 
> The "stack" of languages looks like:
> 
>  spad -- an algebra language using types 
>    spad compiler -- defines the algebra language and types
>      boot -- a non-parenthesized common lisp which is untyped
>        common lisp -- a parenthesized common lisp which is untyped
> 

Right.

> in the interpreter
> 
>  interpreter language -- spad-like, uses types
>    boot -- a non-parenthesized common lisp which is untyped
>      common lisp -- a parenthesized common lisp which is untyped
>

I think this design is a historical accident and not the way
it should/would be done today. Historically both SPAD and the
Axiom interpreter were written at the same time. But if we
were to do it again today the "stack" would probably look like
this:

  interpreter language -- spad-like, uses types
    spad compiler -- defines the algebra language and types
      boot -- a non-parenthesized common lisp which is untyped
        common lisp -- a parenthesized common lisp which is untyped

And we would replace SPAD with Aldor if/when it is legally
possible.
 
> the B-natural language sits here:
> 
>  b-natural -- single-type langauge
>    interpreter language -- spad-like, uses types
>      boot -- a non-parenthesized common lisp which is untyped
>        common lisp -- a parenthesized common lisp which is untyped
>

I think it should sit here (at the same level as the existing
Axiom interpreter):

  b-natural -- single-type langauge
    spad compiler -- defines the algebra language and types
      boot -- a non-parenthesized common lisp which is untyped
        common lisp -- a parenthesized common lisp which is untyped

B# is an alternative to the Axiom interpreter, not an extension.

Or (in the best of all possible worlds :):

  b-natural -- single-type langauge
    Aldor compiler -- defines the algebra language and types
       common lisp -- a parenthesized common lisp which is untyped

If we get rid of SPAD and the old Axiom interpreter then BOOT
becomes irrelevant. But Common Lisp as the base of this "stack"
still makes good sense to me.

> 
> Note that Bill and I disagree about boot's future.

True.

> 
> Note that B-natural and Boot are COMPLETELY unrelated.
> 

I tend to agree.

\start
Date: Thu, 23 Mar 2006 07:14:12 -0800 (PST)
From: Cliff Yapp
To: Bill Page, Tim Daly
Subject: RE: B#

--- Bill Page wrote:

> Or (in the best of all possible worlds :):
> 
>   b-natural -- single-type langauge
>     Aldor compiler -- defines the algebra language and types
>        common lisp -- a parenthesized common lisp which is untyped
> 
> If we get rid of SPAD and the old Axiom interpreter then BOOT
> becomes irrelevant. But Common Lisp as the base of this "stack"
> still makes good sense to me.

Agreed!

Alright, it's now imperative - we MUST free Aldor somehow!  If it can
resolve/remove the old BOOT vs. Lisp code debate, clearly there is
nothing it can't do!

> > Note that Bill and I disagree about boot's future.
> 
> True.

Although it sounds like given the availability of both Aldor and
B-natural the argument becomes moot?

Break out the B-natural papers!

Has anybody heard anything new from the Aldor front?  Dr. Watt?  Would
it help to send the petition to NAG?

\start
Date: Thu, 23 Mar 2006 18:38:54 -0500
From: Bill Page
To: Camm Maguire
Subject: re: libaxiom.a
Cc: Ralf Hemmecke

Camm,

On Wednesday, March 22, 2006 3:44 PM you wrote:
>
> Bill Page writes:
> > ... It should be made easier to use Axiom
> > in this way, i.e. via an application programmer interface
> > (API). Right now it is possible to do this via socket calls.
> > This is how Hyperdoc communicates with Axiom. A library that
> > makes this transparent or which eliminates the sockets and
> > calls GCL directly would be very nice. GCL has a foreign
> > function interface and I think it should be possible to use
> > this in reverse.
>
> Where did that mini-webserver-in-lisp project wind up again?
>

The Lisp code that you suggested works fine but for his own
reasons Kai Kaminski opted not to use it as part of the AxiomUI
project.

Camm, can you suggest where I should look in the GCL docs
and/or mailing list for info about calling GCL from "C" code?
How difficult is this?

Suppose I have some large program written in "C", e.g. maybe
OpenOffice or something like that :), and I want to call something
written in GCL. Can I do that without resorting to sockets etc.?

\start
Date: Thu, 23 Mar 2006 21:00:42 -0500
From: Tim Daly
To: Bill Page
Subject: Re: B#

> Apparently Tim is not so convinced of the future of Aldor. :(
 
I'm not? News to me. --Tim

\start
Date: Thu, 23 Mar 2006 20:21:44 -0500
From: Bill Page
To: Tim Daly, Bill Page
Subject: RE: B#

On Thursday, March 23, 2006 9:01 PM Tim Daly (root) wrote:

> Bill Page wrote:
> > Apparently Tim is not so convinced of the future of
> > Aldor. :(
> 
> I'm not? News to me. --Tim
>

Oh, ok. Good.

Then does that mean you also agree with the larger
context of this quote: that we should only plan to
eliminate BOOT when we can also eliminate SPAD in
favour of Aldor and B# in favour of the current Axiom
intepreter? In other words: when we can eliminate those
components dependent on BOOT?

\start
Date: Thu, 23 Mar 2006 21:35:09 -0500
From: Tim Daly
To: Bill Page
Subject: Re: B#

re: quote

nope. i agree with this rather insightful quote though: BOOT is toast. :-)

re: the future of aldor

there are some sticky IP issues with aldor. Manuel was a major
contributor and he is no longer able to agree to donate his code.
i'm in discussion with people associated with INRIA about making
his code and research available but that, like everything else,
moves at a (pre-global-warming) glacial pace.

re: aldor replacing spad

aldor may or may not replace spad. that's a huge task. and it will
be made worse because it's unlikely that any one of us will be willing
to perform a straight spad to aldor conversion without generating 
numerous opinions regarding "better ways to do this" (witness the
ongoing Monoid/Ring discussion).

even without that level of issue it's tempting to try to break the
algebra cycles using post-facto extensions. this will generate more
very interesting but, to the actual implementors, painful discussion.

re: B-natural

B-natural won't replace the interpreter because the real semantics of
an expression is carried in the type. B-natural has the essential goal
of hand-waving away the type issues to make it easier for people who
don't care about the type. but i believe this raises some very hard
coercion/conversion questions which will turn out to be fundamental.

we would probably get further faster by working out the exact 
coercion/conversion graph and formalizing the mechanism. then we could
make the interpreter smarter as well as extend it to special domains
(e.g. to interval arithmetic which does not preserve the distributive
property).

\start
Date: Thu, 23 Mar 2006 22:25:47 -0500
From: Bill Page
To: Tim Daly
Subject: RE: B#

Tim,

On Thursday, March 23, 2006 9:35 PM you wrote:
>
> re: quote
>
> nope. i agree with this rather insightful quote though:
> BOOT is toast. :-)

I'll pass on that one.

>
> re: the future of aldor
>
> there are some sticky IP issues with aldor. Manuel was a
> major contributor and he is no longer able to agree to
> donate his code.

I thought this only applied to some of the Aldor libraries
and specific packages written for Aldor. Or did he also
"own" some of the source code to Aldor itself?

> i'm in discussion with people associated with INRIA about
> making his code and research available but that, like
> everything else, moves at a (pre-global-warming) glacial
> pace.

I am glad you are looking at this. Frankly I really don't
understand why any of this is an "issue" at all. I can not
see how limiting access to research benefits anyone and it
surprises me that some people apparently think that providing
free and open access could somehow diminish their own interest
in the work. Given the Internet, being the type of community
that it is today, it seems to me very remote the chance that
anyone might unduly exploit such work without giving full
and complete credit to the original authors.

>
> re: aldor replacing spad
>
> aldor may or may not replace spad. that's a huge task. and
> it will be made worse because it's unlikely that any one
> of us will be willing to perform a straight spad to aldor
> conversion without generating numerous opinions regarding
> "better ways to do this" (witness the ongoing Monoid/Ring
> discussion).

It is a big task, but investing time in this now makes more
sense than continuing to "patch up" the old stuff - just as
it did when IBM originally set out to develop Aldor as
version 2 of the Axiom library compiler. I think psychology
suggests that we can count on much more enthusiastic
support for continuing with this forward-looking plan
rather than the option of trying to correct past "mistakes".

I don't see a problem with people agreeing on a one-to-one
SPAD to Aldor conversion as the first phase of this task.
There are always going to be "better ways" to do something
and usually these apply equally well to both SPAD and Aldor.
We can make note of these and get on with the main task...
And this can be done in an incremental manner, converting
a few SPAD routines with each new release until there are
now SPAD modules left.

>
> even without that level of issue it's tempting to try to
> break the algebra cycles using post-facto extensions. this
> will generate more very interesting but, to the actual
> implementers, painful discussion.

That is a good example of what I mean. Post-facto extension
is not really a fundamentally new idea. One can easily do
the same thing in SPAD. It goes like this:

  1) Write a SPAD "stub" that includes incomplete function
     prototypes ignoring the dependencies.
  2) Write SPAD code that depends on these prototypes and
     defines new functions.
  3) Write the SPAD "extension" that replaces the prototypes
     with actual function definitions in terms of those
     functions defined in 2).

As I understand it, all that Aldor's post-facto extension
does is make this process a little "prettier" by providing
a syntax that explicitly references the code in step 1).
That this possible at all depends on the internal design
for dispatching functions calls that is basic to SPAD. We
could use this approach now in SPAD to break the algebra
cycles. But if we do a one-to-one conversion of SPAD to
Aldor then we can (at initially) keep the current bootstrap
process as is.

>
> re: B-natural
>
> B-natural won't replace the interpreter because the real
> semantics of an expression is carried in the type. B-natural
> has the essential goal of hand-waving away the type issues
> to make it easier for people who don't care about the type.

No. Have you read the actual B# paper? There is no "hand
waving". The user interacts with only one type - the UserType.
The UserType in turn has a well-defined relationship to the
underlying types defined in the Axiom library.

> but i believe this raises some very hard coercion/conversion
> questions which will turn out to be fundamental.

Could you give some examples of such coercions or conversions
that you think might be hard or impossible to resolve without
fundamental changes in the approach?

>
> we would probably get further faster by working out the exact
> coercion/conversion graph and formalizing the mechanism.

I agree that that is an essential part of the design of B# -
at least between the UserType and the Axiom library.

> then we could make the interpreter smarter as well as extend
> it to special domains (e.g. to interval arithmetic which does
> not preserve the distributive property).
>

Making the current Axiom interpreter "smarter" is a harder
problem then just implement B# which side-steps the general
problem by introducing the UserType.

BTW, isn't it true that Axiom's existing Float domains already
do not preserve the distributive property? Does interval
arithmetic really add anything new (besides intervals)?

\start
Date: 24 Mar 2006 10:23:56 +0100
From: Gabriel Dos Reis
To: Tim Daly
Subject: Re: B#

Tim Daly writes:

[...]

| we would probably get further faster by working out the exact 
| coercion/conversion graph and formalizing the mechanism. then we could
| make the interpreter smarter as well as extend it to special domains
| (e.g. to interval arithmetic which does not preserve the distributive
| property).

Thanks you pointed out this.  It is a very fundamental issue.  I have
been asking myself: "But this B# thingy smells much like ML/Haskell
and its descendent, but where are the type conversions formally
defined?"  I've read Weber's and Doye's contributions; I have the
distinct feeling I'm still missing the "big picture", i.e. the picture
is still incomplete.

\start
Date: Fri, 24 Mar 2006 04:44:50 -0500
From: Bill Page
To: Ralf Hemmecke
Subject: re: libaxiom.a

Ralf,

On Wednesday, March 22, 2006 5:26 AM you wrote:
> ...
> I grep'ped for $Lisp. Well, that makes 2568 occurrences and
> for my taste a very bad design. Wouldn't it be much better to
> concentrate all the Lisp dependencies in just a few modules
> and write the rest depending on that modules in Aldor?

Actually all of these occurrences are in only about 90 of
the 350 .spad.pamphlet files, so they are not spread as
badly as the total number suggests. I am not convinced
however that these lisp dependencies are necessarily bad
or that they need to be concentrated into only a few
modules. I need to think about this some more ...

One can think of $Lisp as a package that naturally
accompanies the SExpression domain. The SExpression is a
very important domain for Axiom. Maybe more of the commonly
used Lisp constructs could be implemented in SExpression,
but the change would be mostly cosmetic at the expense of
some function call overhead.

The total number occurrences of $Lisp is not really that
bad. There are other domains in Axiom that are nearly as
widely used such as Integer and Polynomial, etc. In general
Axiom's library is very strongly interconnected and
mutually dependent.

Your argument might be that $Lisp is "too powerful" as a
package since it implements a complete, albeit lower-level,
symbolic programming language in itself. As such it allows
programmers to abuse this flexibility and write programs
that are more difficult to maintain. But in fact Aldor also
allows this flexibility via the 'import {} from foreign lisp'
statement.

>
> For example, I see "NIL$Lisp" all over the place (153 times).
> Brrrhh. Wouldn't just "nil" do?

Well, no. NIL$Lisp is of type SExpression but nil is of
type List. Maybe NIL should really be a constant defined
in SExpression.

> And to be honest, I mostly wouldn't like to see NIL at
> all. Aldor/SPAD should deal with domains and their
> elements and mostly forget about a pointer view.

I am not sure I understand what you mean by a "pointer
view". SExpression is a domain within SPAD whose
representation is provided by Lisp. NIL is a name for
the empty SExpression just like 'nil' is a name for the
empty List. Or "by "forget about pointer" are you
suggesting that we should discourage the use of such
mutable data structures as lists? I think this would
have unfortunate consequences for representing "infinite"
objects such as sequences and graphs/networks with
loops, etc.

> There would be only rare reasons to use NIL and
> they should be abstracted through an Aldor Pointer domain
> (which then could be mapped to Lisp (or whatever)).

Could say a little more about the Aldor Pointer domain?
How is it used? I tend to think of NIL as equivalent
to emtpy() for a list. That seems to be how it is mainly
used in Axiom.

Perhaps you are saying that there really shouldn't be
two list-type structures in Axiom and that all of the
necessary SExpression functionality should be abstracted
as a List?

>
> Except that we now have this Lisp'ish SPAD code for
> historical reasons, I think it would be much cleaner
> to make a clear cut between the underlying Lisp
> infrastructure and the Algebra code.
>
> Is my view so wrong (except that it means lots of
> work)?

It seems to me that only thing really "Lisp'ish" about
this is the use of SExpression as one of the fundamental
data structures. But this seems to me to be a deliberate
design decision on the part of the Axiom developers.
After all, symbolic computation was one of the main reasons
why Lisp was invented and S-expressions are it's basic
data structure. The $Lisp notation just makes it convenient
(too convenient?) to manipulate these structures with
Lisp itself.

\start
Date: Fri, 24 Mar 2006 14:49:53 +0100
From: Ralf Hemmecke
To: Bill Page
Subject: re: libaxiom.a

On 03/24/2006 10:44 AM, Page, Bill wrote:
> On Wednesday, March 22, 2006 5:26 AM you wrote:

Maybe I should be quiet, but I have a vision for Axiom and that simply
says: Use higher level language constructs instead of lower level ones.
It also says that people contributing to Axiom should write in Aldor (or
any even higher level language). Lower level constructs would only be
accepted, if there is no way to do it in Aldor. I don't think that idea
is so bad.

And for the library to make it "cleaner", I think it's cleaner if all
the lowlevel stuff is concentrated in a few files. Don't you agree?

Think of it from the point of view of people who think that Axiom is in
some sense great and they now decide to contribute to it. If they delve
deeper and find that besides Aldor they have to learn SPAD, BOOT, LISP,
in order to understand existing code and in order to contribute, then I
am sure that many people simply look for something simpler and turn
their back to Axiom.

I don't say that Lisp is bad, but it should be mostly hidden from the
final user/contributer to the algebra library. People should not need to
care how the underlying things are implemented until they want to
contribute there, too. I just argue against Lisp (or C or Fortran or
...) in any **higher layer** of the Axiom library.

 > One can think of $Lisp as a package that naturally
> accompanies the SExpression domain.

Well, if I look at it from an Aldor point of view it IS a package call.
As you said, Aldor allows "import ... from Foreign Lisp" where "..."
list the functions that are to be imported.
(Unfortunately, I haven't seen an import from "Foreign Lisp", but

   import { osCpuTime: () -> MachineInteger } from Foreign C;

actually appears in libaldor). After that import, one can use osCpuTime
as if it were a function defined in Aldor. No package calling is
necessary, because of the import.

> The SExpression is a very important domain for Axiom.

Sorry, I cannot say much about it, but I just looked at it. It seems to
me that this should be the abstraction from the underlying Lisp that I
was talking about.

But $Lisp is something else. In SPAD it allows to access any Lisp
function. In Aldor that looks like a package call so it must be a
package call (not a foreign function call --- maybe it is possible to 
write "osCpuTime()$Foreign(C)"). In other words, if you want
that code to compile in Aldor, you have to make a package "Lisp" that
exports ALL the functions that are ever used in the Axiom library
(including NIL).

> Maybe more of the commonly
> used Lisp constructs could be implemented in SExpression,
> but the change would be mostly cosmetic at the expense of
> some function call overhead.

Well, shouldn't that "expense" depend on optimisations that the compiler
can perform?

> Your argument might be that $Lisp is "too powerful" as a
> package since it implements a complete, albeit lower-level,
> symbolic programming language in itself. As such it allows
> programmers to abuse this flexibility and write programs
> that are more difficult to maintain.

Why was Aldor invented then? Why do people invent something like BOOT or
RLISP (the Reduce Lisp without brackets?)? Code written in higher level
languages are easier to maintain, IMHO.

>> For example, I see "NIL$Lisp" all over the place (153 times).
>> Brrrhh. Wouldn't just "nil" do?

> Well, no. NIL$Lisp is of type SExpression but nil is of
> type List. Maybe NIL should really be a constant defined
> in SExpression.

For the latter, I would think so. The first is maybe true for the Axiom
library, but is false in general. "nil" is just an identifier, it could
denote anything. Let me quote from libaldor...

Pointer:  PrimitiveType with {
	coerce:	 % -> MachineInteger;
	coerce:	 MachineInteger -> %;
         nil:     %;
         nil?:    % -> Boolean;
} == add {
	macro Z == MachineInteger;
         Rep == Ptr;
	coerce(p:%):Z		== convert(rep p)@SInt ::MachineInteger;
	coerce(n:Z):%		== per convert(n::SInt);
         nil:%			== per nil;
         nil?(p:%):Boolean	== nil?(rep p)::Boolean;
	(a:%) = (b:%):Boolean	== (rep a = rep b)::Boolean;

	-- THOSE ARE BETTER THAN THE CORRESPONDING CATEGORY DEFAULTS
	(a:%) ~= (b:%):Boolean	== (rep a ~= rep b)::Boolean;
}

If you say "import from Pointer" then "nil" is of type "Pointer", not
"List". BTW, nil is never of type List in libaldor. There is no reason
for it.

>> And to be honest, I mostly wouldn't like to see NIL at
>> all. Aldor/SPAD should deal with domains and their 
>> elements and mostly forget about a pointer view.
> 
> I am not sure I understand what you mean by a "pointer
> view". SExpression is a domain within SPAD whose
> representation is provided by Lisp. NIL is a name for
> the empty SExpression just like 'nil' is a name for the
> empty List.

The constant for the empty list in libaldor is "empty". Isn't that more
intuitive? If you have never come across LISP in your career, would you
know what NIL stands for?

 > Or by "forget about pointer" are you
> suggesting that we should discourage the use of such
> mutable data structures as lists?

Of course not, but it's a difference between exports and implementation.
Nobody (except the implementor) needs to know about the internal 
representation of lists. Suppose I want to implement the List interface 
by an array? Should that be wrong? Do you have an idea what NIL could 
mean then? All that a user of LIST needs to know is in the interface 
(the category). The nasty details should be hidden.

> I think this would
> have unfortunate consequences for representing "infinite"
> objects such as sequences and graphs/networks with
> loops, etc.

I am not proposing to remove List. I am proposing to remove NIL (or at 
least to hide it in some low level library), since in my eyes that 
sounds not very mathematical. If I want an empty list, it is much better 
to say "empty$List(...)" than "NIL$Lisp". Don't you agree? BTW, there 
are several "empty" depending on the argument of "List".

>> There would be only rare reasons to use NIL and
>> they should be abstracted through an Aldor Pointer domain 
>> (which then could be mapped to Lisp (or whatever)).
> 
> Could say a little more about the Aldor Pointer domain?
> How is it used?

Grep the libaldor sources. It is mostly used to get some low level 
functionality, for example, I/O done be C routines.

And I know that Manuel Bronstein introduced "nil@Record" in order to 
avoid "nil$Pointer pretend Record(...)" in some places. Sometimes "nil" 
is good for efficiency reasons. But maybe even that should be re-thought.

 > I tend to think of NIL as equivalent to emtpy() for a list.

That is thinking in terms of implementation. But if I implement

MyList(T: Type): ListType T == add {
   Rep == Record(numEntries: Integer, l: List T);
   ...
   nil: % == per [0, empty$List(T)];
}

wouldn't that make a perfect list?

> Perhaps you are saying that there really shouldn't be
> two list-type structures in Axiom and that all of the
> necessary SExpression functionality should be abstracted
> as a List?

I am not at all saying that.

>> Except that we now have this Lisp'ish SPAD code for 
>> historical reasons, I think it would be much cleaner
>> to make a clear cut between the underlying Lisp
>> infrastructure and the Algebra code.
>>
>> Is my view so wrong (except that it means lots of
>> work)?
> 
> It seems to me that only thing really "Lisp'ish" about
> this is the use of SExpression as one of the fundamental
> data structures.

How can SExpression be so fundamental, if it doesn't even exist in the 
libalgebra library of Aldor and one could still do symbolic computation?
Are you saying SExpressoin is fundamental to the interpreter? Or 
fundamental to symbolic domains that are not yet in libalgebra? (I doubt 
the latter one.)

\start
Date: 24 Mar 2006 15:48:39 +0100
From: Gabriel Dos Reis
To: Bill Page
Subject: Re: B#

Bill Page writes:

[...]

| > re: B-natural
| >
| > B-natural won't replace the interpreter because the real
| > semantics of an expression is carried in the type. B-natural
| > has the essential goal of hand-waving away the type issues
| > to make it easier for people who don't care about the type.
|
| No. Have you read the actual B# paper? There is no "hand
| waving". The user interacts with only one type - the UserType.
| The UserType in turn has a well-defined relationship to the
| underlying types defined in the Axiom library.

Hi Bill,

  By now, I have some familiarity with the B# paper.  I do believe
there is a "hand waving" concerning how the B# interpreter works with
types.  The subsection "Types" in =A75.3 does not say much.  I also read
the paper

   "The Type Inference and Coercion Facilities in the Scracthpad II
   Interpreter" by the duo Sutor & Jenks.

The description there is informal, sufficient to convey the general
feeling of how the type system works.  However, it lacks the "essence"
that would make it acceptable to a compiler writer, or even at a
contemporary programming language conferences :-)
I suspect the meat must be the papers refered to as [1] [3] [4], [5],
[7] [8].  I currently have access to none of them, except [1].

\start
Date: Fri, 24 Mar 2006 12:54:24 -0500
From: Bill Page
To: Ralf Hemmecke
Subject: re: libaxiom.a

On Friday, March 24, 2006 8:50 AM Ralf Hemmecke wrote:
>
> On 03/24/2006 10:44 AM, Page, Bill wrote:
> > On Wednesday, March 22, 2006 5:26 AM you wrote:
>
> Maybe I should be quiet, but I have a vision for Axiom and
> that simply says: Use higher level language constructs
> instead of lower level ones.

No you should not be quiet! I think this is an important
subject - and not just because I happen to agree with you.
:) And I do agree. In fact I have argued exactly the same
thing in the past so it seems a little ironic to me that
I am now defending the use of Lisp (in this very specific
way).

> It also says that people contributing to Axiom should
> write in Aldor (or any even higher level language). Lower
> level constructs would only be accepted, if there is no
> way to do it in Aldor. I don't think that idea is so bad.

I think it is not bad but perhaps overly idealistic. I
think it is something that we can aim for but probably not
something that we can easily achieve. Axiom is a very large
system and we need a way to get from where we are today
to were we want to be in a more or less incremental fashion,
i.e. by taking a large number of small steps.

Also the idea of the "level" of language is a rather hard
thing to define rigourously. While I can agree informally
that it is reasonable to consider Aldor a higher-level
language than Lisp, I do not know of any metric that would
allow me to measure this in an unambiguously way and I am
sure that there are some people (e.g. experienced Lisp
programmers) who would disagree for a variety of reasons.

>
> And for the library to make it "cleaner", I think it's
> cleaner if all the lowlevel stuff is concentrated in a
> few files. Don't you agree?

First we have to agree on how to define low-level. ;)

>
> Think of it from the point of view of people who think
> that Axiom is in some sense great and they now decide
> to contribute to it. If they delve deeper and find that
> besides Aldor they have to learn SPAD, BOOT, LISP,
> in order to understand existing code and in order to
> contribute, then I am sure that many people simply look
> for something simpler and turn their back to Axiom.

I agree. :( I am proposing just Aldor and Lisp - just that
part of Lisp that is convenient for historical compatibility
and particular functionality. The Lisp package appears at
the *same* level as other domains in the library - as just
some abstract data structure (S-expressions) and operations
on that structure. It's primary application is as the
underlying representation of other domains. But of course
one can use any available domain or set of domains as a
representation of some new domain.

>
> I don't say that Lisp is bad, but it should be mostly
> hidden from the final user/contributer to the algebra
> library. People should not need to care how the underlying
> things are implemented until they want to contribute there,
> too. I just argue against Lisp (or C or Fortran or ...)
> in any **higher layer** of the Axiom library.

I think this is the same problem that one finds in the rest
of the library: Many domains seem complex and unnecessary
until we learn to appreciate how they can be used. For example
something as "mathematically obvious" as a the implementation
of a polynomial domain can have subtle and complex implications
when we consider how it interacts with other domains as some
of our early discussions here showed. S-expressions as an
abstract data structure are no different in principle.

>
> > One can think of $Lisp as a package that naturally
> > accompanies the SExpression domain.
>
> Well, if I look at it from an Aldor point of view it IS a
> package call. As you said, Aldor allows "import ... from
> Foreign Lisp" where "..." list the functions that are to be
> imported. (Unfortunately, I haven't seen an import from
> "Foreign Lisp",

Here is an example (unfortunately not a very good example):

http://wiki.axiom-developer.org/209TheFunctionDomainIsUndefined

...

      import {
              BOOT_:_:devaluate: SExpression -> SExpression;
      } from Foreign Lisp;
      local devaluate(s: SExpression): SExpression == {
              BOOT_:_:devaluate(s);
      }

Please don't be worried about the prefix BOOT here. That is
just the Lisp package name not the BOOT language.

>
> > The SExpression is a very important domain for Axiom.
>
> Sorry, I cannot say much about it, but I just looked at it.
> It seems to me that this should be the abstraction from the
> underlying Lisp that I was talking about.

Yes, it is - more or less. It is the domain whose memebers
are S-expressions and a limited number of operations of that
type.

>
> But $Lisp is something else. In SPAD it allows to access
> any Lisp function.

Yes. Lisp appears as one *big* package. But in Lisp all
functions operation on s-expressions. In fact, functions
themselves *are* s-expressions...

> In Aldor that looks like a package call so it must be a
> package call (not a foreign function call --- maybe it
> is possible to write "osCpuTime()$Foreign(C)"). In other
> words, if you want that code to compile in Aldor, you have
> to make a package "Lisp" that exports ALL the functions
> that are ever used in the Axiom library (including NIL).

That is one way to do it, but not the only way. One could
continue to simply declare those Lisp functions where and
when one need them. It is just that in SPAD you do not need
to declare them explicitly.

>
> > Maybe more of the commonly used Lisp constructs could
> > be implemented in SExpression, but the change would be
> > mostly cosmetic at the expense of some function call
> > overhead.
>
> Well, shouldn't that "expense" depend on optimisations that
> the compiler can perform?

Yes of course it does.

>
> > Your argument might be that $Lisp is "too powerful" as a
> > package since it implements a complete, albeit lower-level,
> > symbolic programming language in itself. As such it allows
> > programmers to abuse this flexibility and write programs
> > that are more difficult to maintain.
>
> Why was Aldor invented then? Why do people invent something
> like BOOT or RLISP (the Reduce Lisp without brackets?)? Code
> written in higher level languages are easier to maintain,
> IMHO.

I agree. But there are compromises to be made in any large
system design.

>
> >> For example, I see "NIL$Lisp" all over the place
> >> (153 times). Brrrhh. Wouldn't just "nil" do?
>
> > Well, no. NIL$Lisp is of type SExpression but nil is
> > of type List. Maybe NIL should really be a constant
> > defined in SExpression.
>
> For the latter, I would think so. The first is maybe true
> for the Axiom library, but is false in general. "nil" is
> just an identifier, it could denote anything.

Of course. My point was only that it has an associated
type so just "nil" is not enough you need to make a package
call or declare an import or something ... but you know
that.

> >
> > I am not sure I understand what you mean by a "pointer
> > view". SExpression is a domain within SPAD whose
> > representation is provided by Lisp. NIL is a name for
> > the empty SExpression just like 'nil' is a name for the
> > empty List.
>
> The constant for the empty list in libaldor is "empty".
> Isn't that more intuitive? If you have never come across
> LISP in your career, would you know what NIL stands for?

'empty()' is used in SPAD List domain. It happens to have
the same definition as 'nil'. These are just two names
for the same thing.

> ...
> Nobody (except the implementor) needs to know about the
> internal representation of lists. Suppose I want to
> implement the List interface by an array? Should that
> be wrong? Do you have an idea what NIL could mean then?
> All that a user of LIST needs to know is in the interface
> (the category). The nasty details should be hidden.

Yes I agree and that is how it is now in SPAD. NIL$Lisp
is only used in the context of SExpressions. In the case
of the 'List Integer' domain we have, for example:
'empty()$List Integer' or equivalently 'nil$List Integer'.

> ... I am proposing to remove NIL (or at least to hide it
> in some low level library), since in my eyes that sounds
> not very mathematical. If I want an empty list, it is
> much better to say "empty$List(...)" than "NIL$Lisp".
> Don't you agree?

Sure. It's only a name. Maybe the notation:

  []$List(...)

is even better? (We can hope the compiler optimizes this too.)

> >
> > Could say a little more about the Aldor Pointer domain?
> > How is it used?
>
> And I know that Manuel Bronstein introduced "nil@Record"
> in order to avoid "nil$Pointer pretend Record(...)" in
> some places. Sometimes "nil" is good for efficiency reasons.
> But maybe even that should be re-thought.

This sounds like the same kind of compromise to which I
referred above.

So 'nil$Ptr' is a member of some primitive type in Aldor -
probably not so different than NIL$Lisp except not connected
with S-expressions.

>
> > I tend to think of NIL as equivalent to emtpy() for
> > a list.
>
> That is thinking in terms of implementation.

No. My point is only that NIL has no intrinsic primitive
meaning. I guess I said that badly but I think we agree
on that.

> But if I implement
>
> MyList(T: Type): ListType T == add {
>    Rep == Record(numEntries: Integer, l: List T);
>    ...
>    nil: % == per [0, empty$List(T)];
> }
>
> wouldn't that make a perfect list?

Yes.

> > ...
> > It seems to me that only thing really "Lisp'ish" about
> > this is the use of SExpression as one of the fundamental
> > data structures.
>
> How can SExpression be so fundamental, if it doesn't even
> exist in the libalgebra library of Aldor and one could
> still do symbolic computation? Are you saying SExpression
> is fundamental to the interpreter? Or fundamental to
> symbolic domains that are not yet in libalgebra? (I doubt
> the latter one.)
>

No. I am only claiming that S-expressions are fundamental
to this particular design of Axiom. Yes they are certainly
used in the interpreter but also in many places in the Axiom
library (as your grep '$Lisp' showed). As Tim said earlier:
the design of the Axiom library *assumed Lisp*. Using S-
expressions is certainly not the only way to do symbolic
computations but it is one very well understood way. Axiom
also uses several other representations such as records,
arrays etc. for different purposes.

Maybe S-expression can be defined in Aldor without imports
from foreign lisp something like this (very roughly):

  SExpression: with {
        eq:        (%,%) -> Boolean;
          ++ eq(s, t) is true if s=t (in the sense of Lisp).
        atom?:     % -> Boolean;
          ++ atom?(s) is true if s is an atom.
        coerce:   List % -> %;
          ++ convert([a1,...,an]) returns the S-expression
\spad{(a1,...,an)}.
        coerce:   Symbol   -> %;
          ++ convert(x) returns the atom x.
        coerce:   Integer    -> %;
          ++ convert(x) returns the atom x.
        car:       % -> %;
          ++ car((a1,...,an)) returns a1.
        cdr:       % -> %;
          ++ cdr((a1,...,an)) returns \spad{(a2,...,an)}.
        "#":       % -> Integer;
          ++ #((a1,...,an)) returns n.
        nil: %;
        ... etc...
  } == add {
        REP == =
Record(first:Union(atom:Union(sym:Symbol,int:Integer)),
list:%), rest:%);

        nil == nil$Ptr pretend Record ... ;
        coerce(x:Symbol):% == per [x,nil];
        coerce(x:Integer):% == per [x,nil];
        coerce(x:List %):% == {
          #x=0 => nil;
          #x=1 => per [x,nil];
          per [x,coerce(rest x)];
        };
        atom?(x:%):Boolean == x case atom;
        car(x:%):% == per rep(%).first;
        cdr(x:%):% == per rep(%).rest;

  etc. etc.

-----------

But then you would just be re-inventing part of Lisp inside
Aldor and there doesn't seem to be much point since you can
get all this from Lisp for "free". Aldor is designed to
compile to Lisp as one option. It is natural to continue to
use this in Axiom.

\start
Date: Fri, 24 Mar 2006 13:29:13 -0500
From: Bill Page
To: Gabriel Dos Reis
Subject: RE: B#

Gaby,

On Friday, March 24, 2006 9:49 AM you wrote:
>
> Bill Page writes:
> ...
> | Have you read the actual B# paper? There is no "hand
> | waving". The user interacts with only one type - the
> | UserType. The UserType in turn has a well-defined
> | relationship to the underlying types defined in the
> | Axiom library.
>
> By now, I have some familiarity with the B# paper.  I do
> believe there is a "hand waving" concerning how the B#
> interpreter works with types.  The subsection "Types" in
> =A75.3 does not say much.

Can you give a couple of specific examples of the kind of
design issues where you think the authors are being too
vague and the problems might be difficult to solve?

> I also read the paper
>
>    "The Type Inference and Coercion Facilities in the
>    Scracthpad II Interpreter" by the duo Sutor & Jenks.
>
> The description there is informal, sufficient to convey the
> general feeling of how the type system works.  However,
> it lacks the "essence" that would make it acceptable to a
> compiler writer, or even at a contemporary programming
> language conferences :-)

Did I just see you gesture wildly with your hands? ;)

> I suspect the meat must be the papers refered to as [1] [3]
> [4], [5], [7] [8].  I currently have access to none of them,
> except [1].

Please let me know if you manage to get copies of some of
these. I am trying hard to pull together a complete reference
library of Axiom design papers and publications on the Axiom
Portal.

\start
Date: 24 Mar 2006 20:26:22 +0100
From: Gabriel Dos Reis
To: Bill Page
Subject: Re: B#

Bill Page writes:

| Gaby,
|
| On Friday, March 24, 2006 9:49 AM you wrote:
| >
| > Bill Page writes:
| > ...
| > | Have you read the actual B# paper? There is no "hand
| > | waving". The user interacts with only one type - the
| > | UserType. The UserType in turn has a well-defined
| > | relationship to the underlying types defined in the
| > | Axiom library.
| >
| > By now, I have some familiarity with the B# paper.  I do
| > believe there is a "hand waving" concerning how the B#
| > interpreter works with types.  The subsection "Types" in
| > =A75.3 does not say much.
|
| Can you give a couple of specific examples of the kind of
| design issues where you think the authors are being too
| vague and the problems might be difficult to solve?

Yes; take the example on page 39 undr subsection "Types".  What are
the rules that the type inferencer uses to infer the type
L_{&s &bullet; &n &bullet}?  The asnwer is I have to AXIOM's rules.
Now, where are the AXIOM's rules defined.  I turned over the paper I
mentioned earlier, but I can't fiind the real rules.

Currently, I'm just parsing B# -- so I don't get to translate yet.
[and the parser is a quick&dirty Perl script; I'll switch to BOOT
later and I'm more conformtable with it.]

| > I also read the paper
| >
| >    "The Type Inference and Coercion Facilities in the
| >    Scracthpad II Interpreter" by the duo Sutor & Jenks.
| >
| > The description there is informal, sufficient to convey the
| > general feeling of how the type system works.  However,
| > it lacks the "essence" that would make it acceptable to a
| > compiler writer, or even at a contemporary programming
| > language conferences :-)
|
| Did I just see you gesture wildly with your hands? ;)

:-)

| > I suspect the meat must be the papers refered to as [1] [3]
| > [4], [5], [7] [8].  I currently have access to none of them,
| > except [1].
|
| Please let me know if you manage to get copies of some of
| these. I am trying hard to pull together a complete reference
| library of Axiom design papers and publications on the Axiom
| Portal.

The copies I have are from the ACM portal, so I don't think I have
permission to put them on Axiom's portal.  The ones I'm missing are
IBM related; maybe Tim can help there?

\start
Date: Fri, 24 Mar 2006 13:18:20 -0800 (PST)
From: Cliff Yapp
To: Tim Daly, Bill Page
Subject: Re: B#

I'm in a bit over my head here but maybe these questions will be useful
in straightening me out...

--- Tim Daly wrote:

> re: the future of aldor
> 
> there are some sticky IP issues with aldor. Manuel was a major
> contributor and he is no longer able to agree to donate his code.
> i'm in discussion with people associated with INRIA about making
> his code and research available but that, like everything else,
> moves at a (pre-global-warming) glacial pace.

I thought NAG still had the rights to Aldor, with Aldor.org getting a
license?  Or was there post-NAG work done on the Aldor.org version we
would want to use?

I know Manuel wrote quite a lot of code we would definitely want to use
but I thought that was "over and above" the core Aldor compiler - did I
misunderstand how that worked?

> re: aldor replacing spad
> 
> aldor may or may not replace spad. that's a huge task. and it will
> be made worse because it's unlikely that any one of us will be
> willing to perform a straight spad to aldor conversion without
> generating numerous opinions regarding "better ways to do this" 
> (witness the ongoing Monoid/Ring discussion).

Heh - like you said, there's no such thing as a simple job.  I
personally would be willing to support a straight conversion as step
#1.  Eventually, no matter how we do this, virtually all of Axiom will
need to be revisited and properly understood/documented, so I think
compared to the magnitude of that task the language coversion becomes a
detail.  It will undoubtedly raise issues that will need revisiting
later, but I think those issues would likely would have (or should
have) been raised regardless so no harm done.

> even without that level of issue it's tempting to try to break the
> algebra cycles using post-facto extensions. this will generate more
> very interesting but, to the actual implementors, painful discussion.

Looking at it one way, this might be an indicator that we are actually
undertaking to do something truly worthwhile.  As I heard somewhere,
"Nothing worth doing is easy."  We're taking on problems that need to
be solved but are difficult to solve - always the sign of a good
research project :-).

> re: B-natural
> 
> B-natural won't replace the interpreter because the real semantics of
> an expression is carried in the type. B-natural has the essential
> goal of hand-waving away the type issues to make it easier for people
> who don't care about the type. but i believe this raises some very
> hard coercion/conversion questions which will turn out to be 
> fundamental.

I think that issue remains no matter what we do - do we really
understand what the current interpreter does either, for that matter?

In some larger sense, we seem to be asking the question "what is the
best way to merge the casual semantics of day to day mathematical
calculations and the full rigor of a system which places paramount
importance on correctness?"  Or, even more fundamentally, "what do we
ignore in day to day mathematical work and how can we sure it actually
is safe to ignore it?"

Take, for example, the use of noPole in an integration problem.  As I
understand it, this allows Axiom to proceed in applying algorithms to
an expression which it wouldn't normally accept, but also introduces
the risk that Axiom might "ignore" a problem with using those
techniques and produce an incorrect result.  I guess a logical
follow-up would be - if the answer proves useful - for the user to
request that Axiom attempt to generate a proof that in this specific
case the noPole option can be safely ignored.  This latter step is
probably ignored in most cases, if the answer "works", but really
shouldn't be if the answer is to be used in any "rigorous" application.
 Granted such a feature would be highly non-trivial, but I think this
is an example of the benefits which might result from combining proof
logic with a CAS.  (In concept, anyway - I have no idea if those
systems could actually do something like this.)

Clearly there is a useful middle ground between fully rigorous and
casual/risky, since tools like Mathematica, Maple, and Macsyma are
widely used.  Am I right in thinking that we, by the nature of what we
are trying to do, are faced with the task of actually defining that
middle ground?

Interesting work!

\start
Date: Fri, 24 Mar 2006 19:15:59 -0500
From: Bill Page
To: Gabriel Dos Reis
Subject: RE: B#

Gaby,

On Friday, March 24, 2006 2:26 PM you wrote:
>
> Bill Page writes:
> |
> | Can you give a couple of specific examples of the kind of
> | design issues where you think the authors are being too
> | vague and the problems might be difficult to solve?
>
> Yes; take the example on page 39 under subsection "Types".
> What are the rules that the type inference uses to infer
> the type L_{&s &bullet; &n &bullet}?  The answer is I have
> to apply AXIOM's rules. Now, where are the AXIOM's rules
> defined.  I turned over the paper I mentioned earlier, but
> I can't find the real rules.
>

In "How to Make Axiom into a ScratchPad" on page 39

http://portal.axiom-developer.org/refs/articles/axiom-scratchpad.pdf/vie
w

Jenks and Trager write:

> Types
>
> (AXIOM). This style refers to that used in current AXIOM.
> The simplest way of accessing other AXIOM or A# types is
> via B# "constructors". For example, matrix [[a, b], [c, d]]
> builds a 2 by 2 matrix of elements of type User. To break
> out of type User, a user simply makes type declarations.
> For example, the following is a display of a B# definition
> for Laguerre polynomials L:

\begin{axiom}

n:NNI
a:Fraction Integer
L(n,a,x) == ( n=0 => 1; _
              n=1 => -x+1+a; _
              (2*n+a-1-x)/n*L(n-1,a,x)-(n+a-1)/n*L(n-2,n,x))

\end{axiom}

> By omitting the type of x in the above definition, type
> inferencing is used to determine the full signature of the
> function L when the user asks for a value with given
> arguments. This may result in multiple compilations of
> L if the function is called with different types of
> arguments.

\begin{axiom}

)set message selection on
L(2,1/2,1.1)
L(2,1/2,1/4)

\end{axiom}

>
> Alternately, a user may declare the type of L: rather
> than that of its arguments n and a, e.g.
>

\begin{axiom}

RF ==> Fraction Polynomial Integer
L: (NNI, RF, RF) -> RF
L(2,1/2,1/4)

\end{axiom}

>
> where NNI and RF are used here to abbreviate the AXIOM
> types NonNegativeInteger and Fraction Polynomial
> Integer respectively.

-------

In this context I would not call it vague or hand waving.
They are simply referring to the behavior of the Axiom
interpreter as it is now defined. Unfortunately I am not
able to point you to any clear and complete system-level
documentation of the actual algorithms used :(. But in the
final analysis we do have the full source code for the
interpreter plus we can do some experiments to test our
understanding. For example, we can simply run the commands
above in the Axiom interpreter. The interpreter will
provide information about the function selections and
coercions that it makes as it interprets each of these
commands. As Jenks and Trager observe, the results depend
on what and how much type information is provided by the
user.

This is really a question about the old Axiom Interpreter,
not about the design of B#. There is some information in
the Axiom book. See:

  2.9 Package Calling and Target Types
  2.10 Resolving Types

--------

I have been thinking about possible representations for
the User type.

Jenks and Trager wrote the following about the User type:

> All domains in AXIOM accessible from type User export
> a coercion to convert objects of the domain into objects
> of type User, and coercions the other way that may fail.
> This simplifies the task of the interpreter that often
> has to find a coercion path between two given types.
>
> Type User has exported operations that allow the user to
> do general formula manipulation, to transform parse forms
> and results as symbolic formulae under rather complete user
> control. Transformations can be done by pattern-matching
> or direct manipulation. Expression trees provide a simple
> and intuitive model of a formula.

To me this sounds very much like the 'InputForm' domain that
is already part of the Axiom Interpreter. I have a feeling
that the Axiom developers were already incrementally moving
toward a B# implementation by a series of smaller steps
involving extensions to the Axiom library and to the Axiom
interpreter. 'InputForm' already almost satisfies the
requirement that "All domains in Axiom accessible from
type User export a coercion to convert objects of the
domain into objects of type User." This is true if you
substitute 'InputForm' for type User. E.g.

\begin{axiom}

E1:=sqrt(sin(x)^2+1)
e1:=E1::InputForm

\end{axiom}

An object of type 'InputForm' can be converted to
another type by the 'interpret' operation. The result
is of type 'Any' and may be coerced to other types,
however some conversion will fail.

\begin{axiom}

E2:=interpret(e1)
)di type E2
E2::Polynomial Integer

\end{axiom}

Expressions of type 'InputForm' can also be manipulated and
displayed in a fairly flexible manner

\begin{axiom}

)sh InputForm
e2:=e1=e1**2
map(expr,e2)

\end{axiom}

The internal representation of object of 'InputForm' are
of type SExpression - essentially a tree structure. So it
seems to me that 'InputForm' has almost everything we need
as a representation for the type User. In principle it
would not be a difficult job to implement parser for B#
in SPAD or Aldor that would generate InputForm expressions
directly from B# input and perform the type of coercions
that are now down by the Axiom interpreter.

\start
Date: 25 Mar 2006 01:54:45 +0100
From: Gabriel Dos Reis
To: Bill Page
Subject: Re: B#

Bill Page writes:

[...]

| In this context I would not call it vague or hand waving.
| They are simply referring to the behavior of the Axiom
| interpreter as it is now defined. Unfortunately I am not
| able to point you to any clear and complete system-level
| documentation of the actual algorithms used :(.

yes, that is what I have been saying :-).  I read the codes in
src/interp/i-*.spad.pamphlet; although I don't understand all of it,
it still is not a specification of the AXIOM type system rules.

| But in the
| final analysis we do have the full source code for the
| interpreter plus we can do some experiments to test our
| understanding.

yes; however that assumes the existing code base is correct AND we do
understand it sufficiently well.  I'm far from meeting those criteria
now.  I'm trying to being overly critical of the paper.  I find it
quite very useful and delightful by moment.  However, the formal type
system rules are not there, not in any other paper I can have access
to through ACM.  I hope Tim would be able to make some of the
technical reports available to us.

[...]

| > Type User has exported operations that allow the user to
| > do general formula manipulation, to transform parse forms
| > and results as symbolic formulae under rather complete user
| > control. Transformations can be done by pattern-matching
| > or direct manipulation. Expression trees provide a simple
| > and intuitive model of a formula.
| 
| To me this sounds very much like the 'InputForm' domain that
| is already part of the Axiom Interpreter.

and not SExpression? 

| I have a feeling
| that the Axiom developers were already incrementally moving
| toward a B# implementation by a series of smaller steps
| involving extensions to the Axiom library and to the Axiom
| interpreter.

My general feeling after reading the paper several times is that they 
beleive in two-level systems: one for library writer where the full
rigor or strongly typed language is there to assist the library
writer; and one level (top level?) to introduce novices to the
system.  This is to be contrasted (as they said in the paper) with the
approach taken by Maple (it is interesting to note their comparison
with the GAUSS system).  I believe they wanted to make the system more
accesible, but I don't think they wanted to move away from A#.

[...]

| as a representation for the type User. In principle it
| would not be a difficult job to implement parser for B#
| in SPAD or Aldor that would generate InputForm expressions
| directly from B# input and perform the type of coercions
| that are now down by the Axiom interpreter.

Implementing the parser is indeed not difficult at all.  The
interesting bit is connecting to the rest of the system.

\start
Date: 25 Mar 2006 12:47:41 -0500
From: Camm Maguire
To: Bill Page
Subject: re: libaxiom.a
Cc: Ralf Hemmecke

Greetings!

Bill Page writes:

> Camm,
> 
> On Wednesday, March 22, 2006 3:44 PM you wrote:
> > 
> > Bill Page writes:
> > > ... It should be made easier to use Axiom
> > > in this way, i.e. via an application programmer interface
> > > (API). Right now it is possible to do this via socket calls.
> > > This is how Hyperdoc communicates with Axiom. A library that
> > > makes this transparent or which eliminates the sockets and
> > > calls GCL directly would be very nice. GCL has a foreign
> > > function interface and I think it should be possible to use
> > > this in reverse.
> > 
> > Where did that mini-webserver-in-lisp project wind up again?
> >
> 
> The Lisp code that you suggested works fine but for his own
> reasons Kai Kaminski opted not to use it as part of the AxiomUI
> project.
> 
> Camm, can you suggest where I should look in the GCL docs
> and/or mailing list for info about calling GCL from "C" code?
> How difficult is this?
> 
> Suppose I have some large program written in "C", e.g. maybe
> OpenOffice or something like that :), and I want to call something
> written in GCL. Can I do that without resorting to sockets etc.?
> 

It clearly can be done, but it is not trivial at present.  No one has
yet done it to my knowledge.  The idea would be to remove main from
libgcl.a, and make sure to call the lisp initialization code from
within C, followed by super_funcall(...);

\start
Date: Sat, 25 Mar 2006 14:19:46 -0500
From: Tim Daly
To: Camm Maguire
Subject: re: Axiom on Macintosh

i've downloaded 2.6.8pre and will set up a build using it. -t

\start
Date: Sat, 25 Mar 2006 20:24:17 -0500
From: Tim Daly
To: Gerard Milmeister
Subject: patches

Gerard,

Generally the following procedure for patches is recommended:

The original file is called file.org
The changed file is called changed.org

diff -Naur file.org changed.org >file.org.patch

mail the file.org.patch to Tim Daly

It is STRONGLY suggested that any patch contains good documentation
for what the patch does as well as why it is needed. The whole thrust
of the open source version of Axiom is to build a well-documented
system and the author of a change is the best person to do that.

\start
Date: 25 Mar 2006 23:52:56 -0500
From: Camm Maguire
To: Tim Daly
Subject: re: Axiom on Macintosh

Greetings!  There may be an issue with the latest apple gcc and the
saveFP symbol in the binary -- am discussing with Aurelien, and would
appreciate any feedback you might have here.

Take care,

Tim Daly writes:

> i've downloaded 2.6.8pre and will set up a build using it. -t

\start
Date: Sun, 26 Mar 2006 05:16:37 -0500
From: William Sit
To: list, Tim Daly Tim Daly
Subject: NSF CI-TEAM

Hi Tim:

NSF is soliciting proposals called CI-TEAM:

http://www.nsf.gov/pubs/2006/nsf06548/nsf06548.htm

It seems the Axiom project fits the Implementation Projects criteria.
Deadline is June 05, 2006. Max dollars: $1M for 2 to 3 yrs. (sorry, not 30 yrs).


"The CI-TEAM program supports projects that position the national science and
engineering community to engage in research and education activities promoting
and leveraging cyberinfrastructure. CI-TEAM awards will:

"    * Prepare current and future generations of scientists, engineers, and
educators to use, support, deploy, develop, and design cyberinfrastructure; and
"    * Foster inclusion in cyberinfrastructure activities of diverse groups of
people and organizations, with particular emphasis on traditionally
underrepresented groups."

It is an institutional proposal and each can only submit one such proposal. So
you should start investigating and letting your institution know, if you are
interested.

\start
Date: 26 Mar 2006 14:58:16 +0200
From: Francois Maltey
To: list
Subject: Re: Minimal Algebra

"Antoine Hersen" Antoine Hersen writes:

> While reading the Axiom in the class room message I got this idea.
>
> What about starting with an almost blank Axiom, and re building up
> everything in a naive and minimal but instructive way ?

> How should one do it ?

For this use of the interpreter :
1/ it must be possible to describe shortly a consistent minimal language.
2/ this kernel must be (almost) bug free
3/ this langage must contain pretty notions, even if they are news.
4/ the documentation must exist and be short.

---------------// 1 //

Of corse axiom kernel has very pretty concepts.
I love stream, typed object, category, etc.
I think that the first point is  possible, but might be better.

one example of what I'm waiting :

List are fine for studying cartesian product of set as E^n.

In math=C3=A9matics we use cartesian products of differents set.
The other cas aren't so typed, so List are fine for it.
But axiom is typed and
a- List of Any aren't so interressing.
b- for output result axiom seems to use record
   so it seem logical to use record for input data.
   but with record we must add the name of each field,
   and we can't easily coerce (E x F) x G and E x (F x G) in E x F x G.
   There is no function concat for record.
c- turple is only a syntaxic notion.
d- The product domain is a good idea but only work for 2 sets.

I don't see this problem with mupad or maple because theses CAS
aren't so typed.

So I'm waiting a constructor as [|x,y,z|] for E x F x G with functions as
P.1, P.2, first, rest, etc.
I don't like makeRecord because list have [....] and I expect
a similar syntax.
and neither makeRecord nor Product have hightlevel functions.

---------------// 2 //

I get bugs after some uses of anonymous functions.
So I can't do a course with a lot of map, select, etc.

I don't want to use axiom as a imperatif language as basic, C, Pascal...
For my students I prefer functional language.
The mathematical work is more efficient.

So this year I don't show to my students what axiom can do.
My main course must be done with maple, and I give some examples with mupad.

---------------// 3 //

Today it's possible to have more complete language in an interpretor.

axiom have not post-fixed operator. I prefer 4! to factorial 4.
It's possible to compose functions without composition operator, but
it's less interessing.
mupad and maple allows cos@@100 1.0 : the result is (cos (cos (cos... 1.0)))

optional parameter are very usefull.
mupad sort function on list works as the axiom one, but it's possible to
add a boolean function for sorting as an optional parameter.
I can't do this with axiom.

In mupad there is only ONE function rewrite with optional parameter
rewrite (..., exp), rewrite (..., sincos), rewrite (..., sinhcosh)
rewrite (..., ln)
The lot of such functions in axiom are more difficult to restrain.
mupad expand and combine have the same abilities.

maple and mupad construct this list with 100 elements.
[[i,j] $i=1..10 $j=1..10]
with axiom I can't do with ONE call :
I must? use concat and create List List List Integer before concat
concat [[[i,j] for i in 1..10] for j in 1..10].

---------------// 4 //

I try to write a minimal description of axiom for this use.
two or three years ago I done this for mupad.
If you want I can send a private mail with this short text in French.

So I see the difference with axiom,
and I see also that some notions are obviously missing in axiom.

Conclusion :
I believe it's possible to improve quickly axiom interpreter.
if a document describes main notions of axiom.
One time theses main notions are described it's easy to see how
to do one exercice or an other.

I hope I won't wait 30 years !

\start
Date: Sun, 26 Mar 2006 11:24:14 -0500
From: Tim Daly
To: William Sit
Subject: Re: NSF CI-TEAM

thanks. i'll pass it along. --t

\start
Date: Wed, 22 Mar 2006 11:26:01 +0100
From: Ralf Hemmecke
To: Bill Page
Subject: re: libaxiom.a

On 03/21/2006 04:55 PM, Page, Bill wrote:
> Tim, 
> 
> On Tuesday, March 21, 2006 11:00 AM you wrote:
>> ... 
>> AXIOMsys has a large set of libraries. These libraries
>> can't be compiled and executed standalone because they
>> assume the underlying lisp (grep for $Lisp in the algebra
>> sources).

> Very true.

I grep'ped for $Lisp. Well, that makes 2568 occurrences and for my 
tasted a very bad design. Wouldn't it be much better to concentrate all 
the Lisp dependencies in just a few modules and write the rest depending 
on that modules in Aldor?

For example, I see "NIL$Lisp" all over the place (153 times). Brrrhh. 
Wouldn't just "nil" do? And to be honest, I mostly wouldn't like to see 
NIL at all. Aldor/SPAD should deal with domains and their elements and 
mostly forget about a pointer view. There would be only rare reasons to 
use NIL and they should be abstracted through an Aldor Pointer domain 
(which then could be mapped to Lisp (or whatever)).

Except that we now have this Lisp'ish SPAD code for historical reasons, 
I think it would be much cleaner to make a clear cut between the 
underlying Lisp infrastructure and the Algebra code.

Is my view so wrong (except that it means lots of work)?

\start
Date: Thu, 23 Mar 2006 11:48:51 -0500
From: Bill Page
To: Cliff Yapp
Subject: RE: B#

On March 23, 2006 10:14 AM C Y asked:
> ... 
> Alright, it's now imperative - we MUST free Aldor somehow!
> If it can resolve/remove the old BOOT vs. Lisp code debate,
> clearly there is nothing it can't do!

I think that was always the intent of the design of Axiom/XL
(aka. Aldor). ;)

> 
> > > Note that Bill and I disagree about boot's future.
> > 
> > True.
> 
> Although it sounds like given the availability of both Aldor
> and B-natural the argument becomes moot?

Apparently Tim is not so convinced of the future of Aldor. :(

> 
> Break out the B-natural papers!
> 
> Has anybody heard anything new from the Aldor front?  Dr. Watt?
> Would it help to send the petition to NAG?
> 

I have not heard anything from Dr. Watt, but I did have some
communications with Mike Dewar of NAG that indicated that NAG is
in favour of making Aldor open source given "any reasonable
proposal" and "subject to certain basic safeguards". I am sure
that Mike is aware of the Free Aldor page on the Axiom Wiki.

I consider this a very positive sign. :)

\start
Date: Sun, 26 Mar 2006 15:30:57 -0800 (PST)
From: Cliff Yapp
To: list
Subject: Is the Larch/Aldor thesis still reachable?

I tried to download Larch/AldorA Larch BISL For AXIOM and Aldor at 

http://www.dcs.st-andrews.ac.uk/~mnd/publications/thesis/mnd-sep99-thesis.pdf

but I can't seem to get it to respond correctly.  Did St. Andrews take
these down?

\start
Date: Mon, 27 Mar 2006 12:26:31 +0200
From: Ralf Hemmecke
To: Francois Maltey, list
Subject: Re: Minimal Algebra

On 03/26/2006 02:58 PM, Francois Maltey wrote:
> "Antoine Hersen" Antoine Hersen writes:
>
>> While reading the Axiom in the class room message I got this idea.
>>
>> What about starting with an almost blank Axiom, and re building up
>> everything in a naive and minimal but instructive way ?
>
>> How should one do it ?

That's a good question. I think, at the moment you cannot have an
"almost blank Axiom". I guess the reason is that the interpreter assumes =

quite a lot of domains to exist.

> For this use of the interpreter :
> 1/ it must be possible to describe shortly a consistent minimal languag=
e.

Francois, Axiom is a community project. It is nice that you ask, but if
it is not there and nobody on the list volunteers then you are the
natural first candidate to figure out how one could write such a manual.

> 2/ this kernel must be (almost) bug free

If you (or your students) don't volunteer for implementing that kernel,
than I hope you at least volunteer to write a testsuite.

> 3/ this langage must contain pretty notions, even if they are news.

Be more specific and collect your wishes in a structured document that
you submit to the list or add what you mean by "pretty notions" on the
AxiomWiki (http://wiki.axiom-developer.org/CreatingNewPages).

> 4/ the documentation must exist and be short.

What would you suggest?

> ---------------// 1 //
>
> Of corse axiom kernel has very pretty concepts.
> I love stream, typed object, category, etc.
> I think that the first point is  possible, but might be better.
>
> one example of what I'm waiting :
>
> List are fine for studying cartesian product of set as E^n.

If you think so. I would take "Tuple E" instead.

> In math=C3=A9matics we use cartesian products of differents set.
> The other cas aren't so typed, so List are fine for it.

Well, if you look at the Aldor User Guide you would find "Cross" for
your purpose. (I haven't found it in Axiom, though.)

> But axiom is typed and
> a- List of Any aren't so interressing.
> b- for output result axiom seems to use record
>    so it seem logical to use record for input data.
>    but with record we must add the name of each field,
>    and we can't easily coerce (E x F) x G and E x (F x G) in E x F x G.=

>    There is no function concat for record.

All though isomorphic the three sets are not identical. If you want a
function from Cross(Cross(E, F), G) -> Cross(E, F, G) then you have to
write one. Not everything comes for free.

> c- turple is only a syntaxic notion.

> d- The product domain is a good idea but only work for 2 sets.

> I don't see this problem with mupad or maple because theses CAS
> aren't so typed.

> So I'm waiting a constructor as [|x,y,z|] for E x F x G with functions =
as
> P.1, P.2, first, rest, etc.
> I don't like makeRecord because list have [....] and I expect
> a similar syntax.
> and neither makeRecord nor Product have hightlevel functions.

What comes to my mind here is a domain that comes with the old axllib
library.

--begin object.as
-------------------------------------------------------------------------=
----
----
---- object.as: Dynamic objects (OO).
----
-------------------------------------------------------------------------=
----
---- Copyright The Numerical Algorithms Group Limited 1991, 1992, 1993,
1994.
-------------------------------------------------------------------------=
----

--#include "axllib"

+++ Object implements dynamic objects, pairing data values with
+++ associated domains.
+++
+++ Author: AXIOM-XL library
+++ Date Created: 1992-94
+++ Keywords: object

Object(C: Category): with {
	object:		(T: C, T) -> %;
	avail:		% -> (T: C, T);
}
== add {
	Rep == Record(T: C, val: T);
	import from Rep;

	object	(T: C, t: T) : %	== per [T, t];
	avail	(ob: %) : (T: C, T)	== explode rep ob;
}
--end object.as

If you replace "axllib" by "aldor" that works, too. I think, even
"axiom" should work.

If you want to see, how this is used, then look at

http://www.aldor.org/docs/HTML/chap23.html#10

I somehow have the suspicion that Objects is just another way of putting =

different types together.

Of course, then now you can have "Array Object SetCategory", But you
have to give the types explicitly as something like,

[object(Integer, 2), object(String, "abc")]$Array(Object SetCategory)

That is probably not what you want... but some other code I tried does
not yet work, since I have not yet figured out how to access a tuple.

Write a file "Cross.as" with the above object.as (where you replace
axllib by aldor) in it and the following code ...

MyCross(T: Tuple OutputType): with {
	bracket: T -> %;
	apply: (%, n: MachineInteger) -> Object OutputType;
} == add {
	Rep == Array Object OutputType;
	import from Rep, Object OutputType;
	len: MachineInteger == length T;

	[t: T]: % == {
		r: Rep := new(len);
		for i:MachineInteger in 1..len repeat {
			Ti == element(T,i);
			ti := element(t pretend Tuple OutputType,i) pretend Ti;
			r.i := object(Ti, ti);
		}
		per r;
	}
=09
	apply(x: %, n: MachineInteger): Object OutputType == rep(x).n;
}

printThing(tw: TextWriter)(T: OutputType, t: T): TextWriter == tw << =
t;
printObject(tw: TextWriter, o: Object OutputType): TextWriter == {
	printThing(tw)(avail o);
}

main(): () == {
	import from TextWriter, String, Character;
	import from Integer, String;
	CIS ==> MyCross(Integer, String);
	import from CIS;
	cis: CIS := [2, "str"];
	import from MachineInteger;
	oi := cis.1;
	os := cis.2;
	printObject(stdout << "INT: ", oi) << newline;
	printObject(stdout << "STR: ", os) << newline;
}

main();

=2E.. then it compiles, but for me it says...
% aldor -Mno-mactext -fx -laldor Cross.as
% Cross
woodpecker:~/scratch/FRAC>Cross
Looking in MyCross((AldorInteger, String)) for bracket with code 34237761=
5
Unhandled Exception: RuntimeError()
Export not found

Since I used some dangerous "pretend"s that might have been expected.
Unfortunately, I don't yet know how to do it the right way. But as you
see, there is no real reason why you couldn't writ

[2, "str"]

and get an element of  "Integer x String".

> Today it's possible to have more complete language in an interpretor.
>
> axiom have not post-fixed operator. I prefer 4! to factorial 4.

For that you have to extend the language. And especially "!" is a bit
dangerous as a postfix operator, since there is the convention that
names of functions end in ! if they work destructively on their arguments=
=2E

> It's possible to compose functions without composition operator, but
> it's less interessing.
> mupad and maple allows cos@@100 1.0 : the result is (cos (cos (cos... 1=
=2E0)))

Come on, you can define that yourself, can't you?

#include "axiom"

FunctionIteration(T: Type): with {
   ^: (T -> T, Integer) -> (T -> T);
} == add {
   (f: T -> T) ^ (n: Integer): T -> T == {
     import from Integer;
     n < 0 => throw error("only non-negative powers allowed");
     n = 0 => return((t: T): T +-> t);
     n = 1 => f;
     (t: T): T +-> (f^(n-1)) (f t);
   }
}

Put that into a file "FunctionIteration.as". Then open Axiom and say

)co FunctionIteration.as
f(n:Integer): Integer == 2*n
(f^3)(1)

The result is 8. Isn't that more beautiful than f@@3(1)?

I am sure you are by now able to write a package that implements a functi=
on

*: ((T -> T), (T -> T)) -> (T -> T)

that implements the composition of two functions so that you could say,
for example:

myfun := cos * sin
r: Float := myfun(1.0)

and which would be the same as "cos(sin(1.0))".


> maple and mupad construct this list with 100 elements.
> [[i,j] $i=1..10 $j=1..10]
> with axiom I can't do with ONE call :
> I must? use concat and create List List List Integer before concat
> concat [[[i,j] for i in 1..10] for j in 1..10].

But could you do a parallel iteration in mupad or maple? Like

[[i,j] for i in [2,3,5,7,11] for j in 4..]

BTW...have you tried to take the following...

--begin LList.as
#include "axiom"

LList(T: Type): with {
	bracket: Generator List T -> List T;
} == add {
	import from List List T;
	bracket(g: Generator List T): List T == concat [g];
}
--end LList.as
Then say

)co LList.as
[[[i,j] for i in 1..10] for j in 1..10]

Don't always give up so easily. There is more beauty in the Aldor
language than you think.

Hope that helps a bit.

\start
Date: Mon, 27 Mar 2006 13:20:37 -0500
From: William Sit
To: Francois Maltey
Subject: Re: I can't translate from the interpreter to the compiler

Francois:

> How can I coerce this SMP Complex Integer to SMP Integer ?
> 
> How can I use eval from SMP (Integer, [c,s]) to SMP (R, K) ?
> where R is the basis Ring of the Expression
>   and K are the kernels? functions of Expression.

Try map$POLYLIFT(...) (which maps polynomial rings to polynomial rings)

)show POLYLIFT

\start
Date: Mon, 27 Mar 2006 14:52:14 -0500
From: Tim Daly
To: Bill Walster
Subject: Re: Provisos generalize intervals.

Bill,

I've been continuing the proviso research.
I notice from your book bibliography that Hansen has quite a few papers
published and referenced. Are these online anywhere? I checked CMU's
library but they only have the Topics in Interval Analysis proceedings.

\start
Date: Mon, 27 Mar 2006 11:10:16 -0800
From: Bill Walster
To: Tim Daly
Subject: Re: Provisos generalize intervals.

Tim,

Any papers by anybody that are in Reliable Computing I can
get for you.  I'm on the editorial board.

Do you have a phone number I can call you at?  I'd like
to chat with you about possibly participating in an open
source project.

root wrote:

> Bill,
> 
> I've been continuing the proviso research.
> I notice from your book bibliography that Hansen has quite a few papers
> published and referenced. Are these online anywhere? I checked CMU's
> library but they only have the Topics in Interval Analysis proceedings.

\start
Date: Mon, 27 Mar 2006 21:38:06 +0200
From: David Mentre
To: Tim Daly
Subject: Re: patches

Hello Tim,

Tim Daly writes:

> mail the file.org.patch to Tim Daly

Shouldn't patches be sent to list for public
review?

\start
Date: Mon, 27 Mar 2006 16:34:32 -0500
From: Bill Page
To: Antoine Hersen
Subject: RE: Convert and Coerce

On Wednesday, March 22, 2006 12:10 AM Antoine Hersen asked:
>
> I did not find much information about the difference between
> "convert" and "coerce".
>
> Coerce is the "::" operator. But I did not find much more.
>

Actually "::" is the conversion operator (which may include
coercions). The difference is that the Axiom interpreter can
do coercions automatically but you have to specify conversions
explicitly. In the Axiom compiler (both SPAD and Aldor) all
conversions and coercions must be specified.

Here is a little practice reading from the Axiom book :)

Page 152:

"A coercion is a special kind of conversion that Axiom is allowed to do
automatically
when you enter an expression. Coercions are usually somewhat safer than
more general
conversions. The Axiom library contains operations called coerce and
convert. Only
the coerce operations can be used by the interpreter to change an object
into an object
of another type unless you explicitly use a ::."

---------

Does that help? If it isn't clear, please ask.

\start
Date: Mon, 27 Mar 2006 17:53:09 -0500
From: Tim Daly
To: David Mentre
Subject: Re: patches

David,

It's my expectation that everything related to Axiom (except personal
email) gets copied to the list. 

However, due to the volume of mail I get it may be the case that email
not sent directly to me gets missed.

\start
Date: Mon, 27 Mar 2006 17:58:53 -0500
From: Bill Page
To: Cliff Yapp
Subject: RE: Is the Larch/Aldor thesis still reachable?

On Sunday, March 26, 2006 6:31 PM C Y wrote:
>
> I tried to download Larch/Aldor-A Larch BISL For AXIOM and Aldor at
>
>
http://www.dcs.st-andrews.ac.uk/~mnd/publications/thesis/mnd-sep99-thesi
s.pdf
>
> but I can't seem to get it to respond correctly.  Did St. Andrews take
> these down?
>

It seems that the axiom-developer list on long delay again

:(

This works for me now. Do you want me to send a copy or upload
it to the Axiom Portal references?

\start
Date: Mon, 27 Mar 2006 18:55:36 -0500
From: Bill Page
To: Antoine Hersen
Subject: RE: Convert and Coerce

On Monday, March 27, 2006 6:36 PM Antoine Hersen wrote
> Just to be sure
>
> So coercion are done automatically both in a library code
> and in the interpreter.

No. coercion is not done automatically in the library code.
**Only** in the interpreter.

> But conversion need to be forced with "::" both in library
> code and interpreter ?

Yes. Coercion also needs to be forced in the library code,
i.e. in the library code (e.g. SPAD or Aldor) coercion is
treated the same way as conversion.

>
> So convert imply a lost of information and has to be called
> explicitely by :: ?
>

I do not think that in general conversion implies any loss of
information. (I am not sure how to define "loss of information".)
But conversion is often a partial function i.e. only defined for
some members of the domain. For example:

  2.0::Integer

If we only know

  x:Float

it is not "safe" to write:

  x::Integer

since

  2.1::Integer

will fail. Such conversions will not be done automatically.

On the other hand if we know

  y:Integer

then

  y::Float

is always safe and so it is coded as a coercion and done
automatically by the interpreter when needed.

\start
Date: Mon, 27 Mar 2006 16:06:00 -0800
From: Antoine Hersen
To: list
Subject: Currying and iteration

Hello,

2 questions :

On currying, is this a defect or it is normal ?

(31) -> i j +-> i + j

   (31)  i +-> j +-> i + j
                                                      Type: AnonymousFuncti=
on
(32) -> %(1)

   (32)  j +-> G93074 + j
                                                      Type: AnonymousFuncti=
on
(33) -> %(1)

   (33)  G93074 + 1
                                                     Type: Polynomial Integ=
er

On iteration

You can use the map operation on Vector and List but you can iterate(
[ i for i in List] ).
Is iteration built in a lower level of than spad, if not what should I
do to make Vector iteratable or is it not desirable ?

\start
Date: 28 Mar 2006 02:59:58 +0200
From: Gabriel Dos Reis
To: Tim Daly
Subject: Re: patches

Tim Daly writes:

| David,
| 
| It's my expectation that everything related to Axiom (except personal
| email) gets copied to the list. 
| 
| However, due to the volume of mail I get it may be the case that email
| not sent directly to me gets missed.

OK; in summary: patches should be sent to the list with a copy to you.
Is that correct?

\start
Date: Mon, 27 Mar 2006 20:56:58 -0500
From: Tim Daly
To: Gabriel Dos Reis
Subject: Re: patches

> OK; in summary: patches should be sent to the list with a copy to you.
> Is that correct?

yes.

\start
Date: Mon, 27 Mar 2006 17:12:34 -0800 (PST)
From: Cliff Yapp
To: Bill Page
Subject: RE: Is the Larch/Aldor thesis still reachable?

--- Bill Page wrote:

> It seems that the axiom-developer list on long delay again
> 
> :(
> 
> This works for me now. Do you want me to send a copy or upload
> it to the Axiom Portal references?

I dug a copy out of archive.org, after much pain and suffering ;-)

Maybe it would be a good idea just on general principles to add that
one and Formal Methods and Computer Algebra: A Larch Specification of
AXIOM Categories and Functors at
http://www.dcs.st-andrews.ac.uk/~tom/pub/papers.html to the portal
paper archive?  I dunno if that's allowed, unfortunately - I remember
being pointed to Tom Kelsey's thesis a while back, but I don't remember
what the legal status of copying it is.

\start
Date: Mon, 27 Mar 2006 21:21:51 -0500
From: Bill Page
To: Antoine Hersen
Subject: RE: Currying and iteration

On Monday, March 27, 2006 7:06 PM Antoine Hersen wrote:
>
> 2 questions :
>
> On currying, is this a defect or it is normal ?
>
> (31) -> i j +-> i + j
>
>    (31)  i +-> j +-> i + j
>    Type: AnonymousFunction
> (32) -> %(1)
>
>    (32)  j +-> G93074 + j
>    Type: AnonymousFunction
> (33) -> %(1)
>
>    (33)  G93074 + 1
>    Type: Polynomial Integer

I would say obviously it is a defect. (What is 'G93074'?) As
far as I know,

  i j +-> i + j

is not syntactically well-formed even though the interpreter
makes no complaint. Further:

  i +-> (j +-> i + j)

is well-formed but it gives the same error as above.

I think you should report this as an error at:

http://wiki.axiom-developer.org/IssueTracker

This works however if the function is not anonymous:

  )set function compile on

  P:INT->(INT->INT)
  P(i) == j +-> i + j
  (P 1) 1

>
> On iteration
>
> You can use the map operation on Vector and List but you can
> iterate( [ i for i in List] ).
> Is iteration built in a lower level of than spad, if not what
> should I do to make Vector iteratable or is it not desirable ?
>

As discussed in section "5.4.8 for Loops" of the Axiom book, you
may follow the keyword 'in' only by an integer segment, stream or
a list, but try this:

 V:=vector [1,2,3]
 [i for i in entries V]

The function 'entries' returns the elements of a vector as a
List.

\start
Date: 28 Mar 2006 04:56:48 +0200
From: Gabriel Dos Reis
To: Bill Page
Subject: Re: Currying and iteration

Bill Page writes:

[...]

| > You can use the map operation on Vector and List but you can
| > iterate( [ i for i in List] ).
| > Is iteration built in a lower level of than spad, if not what
| > should I do to make Vector iteratable or is it not desirable ?
| > 
| 
| As discussed in section "5.4.8 for Loops" of the Axiom book, you
| may follow the keyword 'in' only by an integer segment, stream or
| a list, but try this:
| 
|  V:=vector [1,2,3]
|  [i for i in entries V]
| 
| The function 'entries' returns the elements of a vector as a
| List.

That should be seen as a "defect".  forin should be made to work with
sequence (whether built-in list for vectors).l

\start
Date: Mon, 27 Mar 2006 22:35:58 -0500
From: Bill Page
To: Gabriel Dos Reis
Subject: RE: Currying and iteration

On Monday, March 27, 2006 9:57 PM Gaby wrote:
> ...
> |
> | As discussed in section "5.4.8 for Loops" of the Axiom book, you
> | may follow the keyword 'in' only by an integer segment, stream or
> | a list, but try this:
> |
> |  V:=vector [1,2,3]
> |  [i for i in entries V]
> |
> | The function 'entries' returns the elements of a vector as a
> | List.
>
> That should be seen as a "defect".  for...in should be made to
> work with sequence (whether built-in list or vectors).
>

What is a "sequence"? As far as I know this is not defined in
Axiom. Do mean that some types should be automatically coercible
to type List? Note that:

  V:=vector [1,2,3]
  [i for i in V::List Integer]

works in the Axiom interpreter but it is not clear to me exactly
where this conversion is defined.

\start
Date: 28 Mar 2006 07:36:08 +0200
From: Gabriel Dos Reis
To: Bill Page
Subject: Re: Currying and iteration

Bill Page writes:

| On Monday, March 27, 2006 9:57 PM Gaby wrote:
| > ...
| > | 
| > | As discussed in section "5.4.8 for Loops" of the Axiom book, you
| > | may follow the keyword 'in' only by an integer segment, stream or
| > | a list, but try this:
| > | 
| > |  V:=vector [1,2,3]
| > |  [i for i in entries V]
| > | 
| > | The function 'entries' returns the elements of a vector as a
| > | List.
| > 
| > That should be seen as a "defect".  for...in should be made to
| > work with sequence (whether built-in list or vectors).
| > 
| 
| What is a "sequence"?

Sequence is my general term for list, vector or any "thingy" walked
through by a generator.

| As far as I know this is not defined in Axiom.

yes, I know.  That is precisely why I said it "should be" seen as a
defect. 

| Do mean that some types should be automatically coercible
| to type List? 

No.  I'm saying that the "iterator constructor" should be made to
traverse vectors too, not just list; and no I don't consider
convolutions like "entries V" acceptable :-).

| Note that:
| 
|   V:=vector [1,2,3]
|   [i for i in V::List Integer]
| 
| works in the Axiom interpreter but it is not clear to me exactly
| where this conversion is defined.

coercion to List should not be needed, nor required.  Hey, have a look
at what you have around in Java, C#, Perl, etc. (admittely, Perl is
convoluted). 

\start
Date: 28 Mar 2006 08:57:27 +0200
From: Martin Rubey
To: Tim Daly
Subject: Re: patches
Cc: Gerard Milmeister

I believe that the following procedure for patches would be a *lot* better:

* if necessary, open an issue in IssueTracker
* upload the patch to MathAction


This automatically sends a mail to axiom-developer. In case you want to make
sure, you can additionally send a mail to Tim.

\start
Date: Tue, 28 Mar 2006 02:20:32 -0500
From: Bill Page
To: Gabriel Dos Reis
Subject: RE: Currying and iteration

On Tuesday, March 28, 2006 12:36 AM Gaby wrote:

> ...
> Bill Page writes:
> | What is a "sequence"?
>
> Sequence is my general term for list, vector or any "thingy"
> walked through by a generator.
>

Well, Aldor does have generators:

http://www.aldor.org/docs/HTML/chap9.html

  "In fact, this form of using generators is so common, that
  if the expression E in ``for v in E.'' does not belong to a
  generator type, then an implicit call is made to an appropriate
  generator function. This is equivalent to writing
  ``for v in generator E.'' "

The Aldor/Axiom interface provides such a generator for the
Axiom Vector type so in Aldor one can write:

  V:Vector Integer := [1,2,3];
  L:List Integer := [ i for i in V ];

Here is a simple example:

http://wiki.axiom-developer.org/SandBoxAldorGenerator

\start
Date: 28 Mar 2006 09:33:23 +0200
From: Gabriel Dos Reis
To: Bill Page
Subject: Re: Currying and iteration

Bill Page writes:

| On Tuesday, March 28, 2006 12:36 AM Gaby wrote:
| 
| > ...
| > Bill Page writes:
| > | What is a "sequence"?
| > 
| > Sequence is my general term for list, vector or any "thingy"
| > walked through by a generator.
| > 
| 
| Well, Aldor does have generators:

I know Aldor has generators, but I did not know it fixed the vector
bug; so that according to original report

# Is iteration built in a lower level of than spad, if not what should I
# do to make Vector iteratable or is it not desirable ?

we have a bug in Axiom, fixed in Aldor. :-)

\start
Date: Tue, 28 Mar 2006 12:33:43 +0200
From: Ralf Hemmecke
To: Bill Page
Subject: Re: Convert and Coerce

First, there is a difference of Axiom and Aldor here.

If you say

   a::B

than that means EXACTLY the same as

   coerce(a)@B

Aldor treats :: as syntactic sugar and nothing more.

That also says if you have a function

   convert: A -> B

but no function

   coerce: A -> B

then the Aldor compiler will complain about a::B.

Axiom is different (and I guess it is the same for SPAD) in that it 
translates a::B into either coerce(a)@B or convert(a)@B. (Hello Axiom 
gurus, correct me if I am wrong.)

But anyway, inside library code NOTHING will be converted or coerced 
automatically.


On 03/28/2006 01:55 AM, Page, Bill wrote:
> On Monday, March 27, 2006 6:36 PM Antoine Hersen wrote

> I do not think that in general conversion implies any loss of
> information. (I am not sure how to define "loss of information".)
> But conversion is often a partial function i.e. only defined for
> some members of the domain. For example:
> 
>   2.0::Integer
> 
> If we only know
> 
>   x:Float
> 
> it is not "safe" to write:
> 
>   x::Integer
> 
> since
> 
>   2.1::Integer
> 
> will fail. Such conversions will not be done automatically.

Actually, to be a bit more exact...

2.1::Integer

currently fails, but it only fails since there is not function

   coerce: Float -> Integer

that does not fail for that input.

But read the thesis of Doye

http://portal.axiom-developer.org/forum/public/973207537422/view?searchterm=Doye

that says why you should not add a function definition like

coerce(f: Float): Integer == truncate f

\start
Date: Tue, 28 Mar 2006 12:39:38 +0200
From: Ralf Hemmecke
To: Martin Rubey
Subject: Re: patches
Cc: Gerard Milmeister

On 03/28/2006 08:57 AM, Martin Rubey wrote:
> I believe that the following procedure for patches would be a *lot* better:
> 
> * if necessary, open an issue in IssueTracker
> * upload the patch to MathAction
> 
> 
> This automatically sends a mail to axiom-developer. In case you want to make
> sure, you can additionally send a mail to Tim.

Why don't you use tla?

Make a new branch from axiom--main--1, hack at the new branch and if it 
is finished, tell Tim that there is something new available ready for 
merge. Tim then could investigate that branch, test and check 
documentation, and if he finds that it is all fine just do a star-merge 
to axiom--main--1. Would that be bad?

\start
Date: 28 Mar 2006 13:15:03 +0200
From: Martin Rubey
To: Ralf Hemmecke
Subject: Re: patches
Cc: Gerard Milmeister

Ralf Hemmecke writes:

> On 03/28/2006 08:57 AM, Martin Rubey wrote:
> > I believe that the following procedure for patches would be a *lot* better:
> > * if necessary, open an issue in IssueTracker
> > * upload the patch to MathAction
> > This automatically sends a mail to axiom-developer. In case you want to make
> > sure, you can additionally send a mail to Tim.
> 
> Why don't you use tla?
> 
> Make a new branch from axiom--main--1, hack at the new branch and if it is
> finished, tell Tim that there is something new available ready for merge. Tim
> then could investigate that branch, test and check documentation, and if he
> finds that it is all fine just do a star-merge to axiom--main--1. Would that be
> bad?

Not too bad, but if the patches are available on IssueTracker, I have the
information immediately at hand. I find it easier to look up proposed patches
on IssueTracker than via the ChangeLog of tla.

Maybe I'm wrong here. It's not so important to me.

\start
Date: Tue, 28 Mar 2006 06:15:36 -0500
From: Bill Page
To: Ralf Hemmecke
Subject: RE: patches
Cc: Gerard Milmeister

On Tuesday, March 28, 2006 5:40 AM Ralf Hemmecke wrote:
> ...
> Why don't you use tla?
>
> Make a new branch from axiom--main--1, hack at the new branch
> and if it is finished, tell Tim that there is something new
> available ready for merge. Tim then could investigate that
> branch, test and check documentation, and if he finds that
> it is all fine just do a star-merge to axiom--main--1.
> Would that be bad?
>

As far as I am concerned that would be Excellent! :)

Unfortunately skill and confidence in these tools is lacking.
I think it needs someone (or a small group of Axiom developers)
to take the lead, write **simple** documentation and demonstrate
exactly how this works.

I have not used 'tla star-merge', but I have used the similar
function of 'darcs pull'. It seems to me that these commands
save an enormous amount of time and protect against the common
errors of less automated methods of handling patches. The
decentralized model based on pulling (merging) patches from
separate archives also seems like a good idea. This allows the
work of maintaining an archive to be shared in a flexible
manner. Plus the 'darcs send' command can be used to create
and send patches by email with very little effort.

\start
Date: 28 Mar 2006 14:22:15 +0200
From: Martin Rubey
To: Francois Maltey
Subject: Re: I can't translate from the interpreter to the compiler

Dear Francois,

I'd propose

)abbrev package TEST Test
Test(): Exports == Implementation where

  EXPR ==> Expression Integer
  CEXPR ==> Complex EXPR

  Exports == with
      fct: (Integer, EXPR) -> EXPR

  Implementation == add

      fct(n, x) ==
        vc := 'c::Symbol::EXPR
        vs := 's::Symbol::EXPR
        ve: EXPR := real((complex(vc,0)$CEXPR + complex(0,vs)$CEXPR)**n)
        eval(ve, [vs, vc], [sin(x)$EXPR, cos(x)$EXPR])


This will work for any FunctionSpace, since they all have
RetractableTo(Symbol).

Note that vc := 'c::EXPR would not work, although it would compile...

\start
Date: Tue, 28 Mar 2006 15:29:15 +0200
From: Ralf Hemmecke
To: Bill Page
Subject: Re: patches
Cc: Gerard Milmeister

On 03/28/2006 01:15 PM, Page, Bill wrote:
> On Tuesday, March 28, 2006 5:40 AM Ralf Hemmecke wrote:
>> Why don't you use tla?
>>
>> Make a new branch from axiom--main--1, hack at the new branch 
>> and if it is finished, tell Tim that there is something new
>> available ready for merge. Tim then could investigate that
>> branch, test and check documentation, and if he finds that
>> it is all fine just do a star-merge to axiom--main--1.
>> Would that be bad?

> As far as I am concerned that would be Excellent! :)

> Unfortunately skill and confidence in these tools is lacking.
> I think it needs someone (or a small group of Axiom developers)
> to take the lead, write **simple** documentation and demonstrate
> exactly how this works.

Well, it took me some time to figure out a way how that could be done.
Bill, you know that I am currently in the process of translating 
Broadbery's Java code to Aldor so that "Aldor for Axiom" could be built 
without the need to install Java.

I also volunteer to write the documentation on the wiki related to this 
tla stuff. Once one understands the basic things, it becomes easy. But I 
wanted to commit to a local archive (without internet access) and then 
merge with the one at axiom-developer.org. That was a bit trickier to 
find out. But I think I have an acceptable way (simply create a local 
personal archive).

> I have not used 'tla star-merge', but I have used the similar
> function of 'darcs pull'.

I have also quickly read through darcs. The idea that in darcs an 
archive is just a collection of patches, sounds rather simple. 
Star-merge in GNU arch is what it says. You branch from a certain 
revision. Then two development lines appear on two different branches 
(which have a common ancestor) where each of the branch maintainers can 
merge from the other branch. Star-merge keeps track of which patches 
have already been applied so that one patch is not applied several 
times. That is all.

 > It seems to me that these commands
> save an enormous amount of time and protect against the common
> errors of less automated methods of handling patches. The
> decentralized model based on pulling (merging) patches from
> separate archives also seems like a good idea. This allows the
> work of maintaining an archive to be shared in a flexible
> manner. Plus the 'darcs send' command can be used to create
> and send patches by email with very little effort.

I also think that we should use the version control tools more 
excessively, but unfortunately it takes a lot of time until one gets 
accustomed to their different principles.

If you are accustomed to centralised development like in CVS, then it's 
at first a bit hard to get the idea of how else development could be 
done. Nobody writes, for example, that it is perfect, if you create your 
one archive, JUST FOR YOURSELF, work on it and from time to time (if 
things are reasonably stable), merge back to the version you branched from.

So there is one suggestion from my side. The version axiom--main--1 
should be made read-only. That is declared to be THE stable branch and 
only Tim (or any person that he trusts) has write access to it.

For anything else, people should branch from that one, create there own 
private (or public on axiom-developer.org) archive, produce new code, 
tell Tim, so that Tim could decide whether the changes should go into 
axiom--main--1.

People (like me) feel more confident if they know that they don't 
destroy the work of others if they start hacking on a new idea.

You hear/read more of that probably soon.

\start
Date: Tue, 28 Mar 2006 15:42:21 +0200
From: Ralf Hemmecke
To: Martin Rubey
Subject: Re: patches
Cc: Gerard Milmeister

On 03/28/2006 01:15 PM, Martin Rubey wrote:
> Ralf Hemmecke writes:
>> Why don't you use tla?
>>
>> Make a new branch from axiom--main--1, hack at the new branch and if it is
>> finished, tell Tim that there is something new available ready for merge. Tim
>> then could investigate that branch, test and check documentation, and if he
>> finds that it is all fine just do a star-merge to axiom--main--1. Would that be
>> bad?
> 
> Not too bad, but if the patches are available on IssueTracker, I have the
> information immediately at hand. I find it easier to look up proposed patches
> on IssueTracker than via the ChangeLog of tla.

Can you point me to a **patch** on IssueTracker? Would they look like 
"diff" output.

I must say, last week I played a bit with xtla
http://wiki.gnuarch.org/xtla
in xemacs (I use the proposed debian package). It seems that xtla cannot 
do everything, but the feature to type ? in a buffer and get the 
available commands is very helpful. And I rather like to look at file 
differences using ediff in emacs.

I have nothing against keeping track of patches on IssueTracker. If you 
figure out how this could be done automatically.

\start
Date: Tue, 28 Mar 2006 16:00:55 +0200
From: Gregory Vanuxem
To: Bill Page
Subject: RE: Currying and iteration

> What is a "sequence"? As far as I know this is not defined in
> Axiom. Do mean that some types should be automatically coercible
> to type List? Note that:
>
>   V:=vector [1,2,3]
>   [i for i in V::List Integer]
>
> works in the Axiom interpreter but it is not clear to me exactly
> where this conversion is defined.

It's a coercion routine (VEC2LIST) coded in the interpreter.

\start
Date: 28 Mar 2006 16:03:41 +0200
From: Gabriel Dos Reis
To: Martin Rubey
Subject: Re: patches
Cc: Gerard Milmeister

Martin Rubey writes:

| Ralf Hemmecke writes:
| 
| > On 03/28/2006 08:57 AM, Martin Rubey wrote:
| > > I believe that the following procedure for patches would be a *lot* better:
| > > * if necessary, open an issue in IssueTracker
| > > * upload the patch to MathAction
| > > This automatically sends a mail to axiom-developer. In case you want to make
| > > sure, you can additionally send a mail to Tim.
| > 
| > Why don't you use tla?
| > 
| > Make a new branch from axiom--main--1, hack at the new branch and if it is
| > finished, tell Tim that there is something new available ready for merge. Tim
| > then could investigate that branch, test and check documentation, and if he
| > finds that it is all fine just do a star-merge to axiom--main--1. Would that be
| > bad?
| 
| Not too bad, but if the patches are available on IssueTracker, I have the
| information immediately at hand. I find it easier to look up proposed patches
| on IssueTracker than via the ChangeLog of tla.
| 
| Maybe I'm wrong here. It's not so important to me.

No, you're not alone.  Maybe I'm biased too, after a decade of working
on GCC -- where what you describe has been implemented and it works
pretty well. Also, a public review, comments helps other (potential)
contributors to gain understanding of the system.

\start
Date: Tue, 28 Mar 2006 10:48:20 -0500
From: Tim Daly
To: Gerard Milmeister
Subject: Re: GCL patch for Fedora Core 5

Thanks for the FC5 patches.
I'll download and build FC5, create an axiom FC5 makefile change,
and test it. --t

\start
Date: Tue, 28 Mar 2006 11:49:07 -0500
From: Bill Page
To: Francois Maltey
Subject: RE: I can't translate from the interpreter to

On Tuesday, March 21, 2006 3:48 PM Francois Maltey wrote:
>
> In the interpreter I have this single line :
>
> fct (n, x) == eval (real ((c + %i * s)^n), [c, s], [cos x, sin x])
>
> I want to add this function in manip.spad... :-(
> ...

On Tuesday, March 28, 2006 7:22 AM Martin Rubey wrote:
>
> I'd propose
>
> )abbrev package TEST Test
> Test(): Exports == Implementation where
>
>   EXPR ==> Expression Integer
>   CEXPR ==> Complex EXPR
>   Exports == with
>       fct: (Integer, EXPR) -> EXPR
>   Implementation == add
>       fct(n, x) ==
>         vc := 'c::Symbol::EXPR
>         vs := 's::Symbol::EXPR
>         ve: EXPR := real((complex(vc,0)$CEXPR +
>            complex(0,vs)$CEXPR)**n)
>         eval(ve, [vs, vc], [sin(x)$EXPR, cos(x)$EXPR])
>

Here is another version of this package in SPAD that is a
little closer to the version that works in the interpreter:

--------

)abbrev package TEST Test
EXPR ==> Expression Integer

Test: with
    fct:(Integer,EXPR)->EXPR
  == add
    c ==> coerce("c")$Symbol::EXPR
    s ==> coerce("s")$Symbol::EXPR
    import Complex EXPR
    import List EXPR

    fct(n:Integer, x:EXPR):EXPR ==
        eval(real((complex(s,c))**n), [s, c], [sin(x), cos(x)])

---------

Using 'import' makes it shorter and easier to read.

Finally, here is the same thing in Aldor:

--------

#include "axiom"
#pile

EXPR ==> Expression Integer
c ==> coerce("c")$Symbol::EXPR
s ==> coerce("s")$Symbol::EXPR
import from Complex EXPR
import from List EXPR

fct(n:Integer, x:EXPR):EXPR ==
    eval(real((complex(s,c))**n), [s, c], [sin(x), cos(x)])

--------

\start
Date: Tue, 28 Mar 2006 12:19:54 -0500
From: Bill Page
To: Francois Maltey
Subject: RE: I can't translate from the interpreter

On Tuesday, March 28, 2006 11:49 AM I wrote:

>
> On Tuesday, March 21, 2006 3:48 PM Francois Maltey wrote:
> >
> > In the interpreter I have this single line :
> >
> > fct (n, x) == eval (real ((c + %i * s)^n), [c, s], [cos x, sin =
x])
> >
> > I want to add this function in manip.spad... :-(
> > ...
>
> Here is another version of this package in SPAD that is a
> little closer to the version that works in the interpreter:
>

And here is a still simpler version. At least in this
example, the call to 'eval' is no longer necessary.

-------

)abbrev package TEST Test
EXPR ==> Expression Integer

Test: with
    fct:(Integer,EXPR)->EXPR
  == add
    import Complex EXPR

    fct(n:Integer, x:EXPR):EXPR == real(complex(sin(x),cos(x))**n)

---------

\start
Date: Tue, 28 Mar 2006 13:13:28 -0500
From: Bill Page
To: Ralf Hemmecke,
Subject: RE: patches
Cc: Gerard Milmeister

Ralf,

On Tuesday, March 28, 2006 8:29 AM you wrote:
> ...
> I also volunteer to write the documentation on the wiki
> related to this tla stuff. Once one understands the basic
> things, it becomes easy. But I wanted to commit to a local
> archive (without internet access) and then merge with the
> one at axiom-developer.org. That was a bit trickier to
> find out. But I think I have an acceptable way (simply
> create a local personal archive).
>

I think you are right. Simple documentation on your
procedure would be great!

> ...
>
> So there is one suggestion from my side. The version
> axiom--main--1 should be made read-only. That is declared
> to be THE stable branch and only Tim (or any person that
> he trusts) has write access to it.

That is already how the Axiom tla archive works. HTTP access
is read-only. SFTP access allows commits but requires that
you register public keys with Tim Daly before the system
will allow you access to the archive.

>
> For anything else, people should branch from that one,
> create there own private (or public on axiom-developer.org)
> archive, produce new code, tell Tim, so that Tim could
> decide whether the changes should go into axiom--main--1.

There are of course a few necessary details to setup in order
to permit others to access your work. I think the web site
has a nice brief description of how to use tla:

http://rhythmbox.sourceforge.net/development.html

and how to setup a mirror to distribute your changes to others.
Just change 'http://web.rhythmbox.org/arch/2004' to
'http://axiom-developer.org/archive/axiom' and I think that
is probably pretty close to how we will want to use tla for
Axiom. I am sure there are probably other short and simple
descriptions on the web of how to use 'tla' for distributed
open source development.

'tla' has lots of different options and ways of doing things -
That is what has always scared me away from using it full-time.
In contrast 'darcs' is much simpler and (usually) has only
one way to do things. But if we can document just the right
combination of basic commands (such as described at the
website above) and if we have someone who is very familiar
with the process to act as a tutor, then I think 'tla' should
be no problem.

I think it is also possible to use tla (or darcs) in
combination with the Axiom Wiki IssueTracker. Instead of
uploading the patch file to the Wiki and attaching it to
the Issue page, one could just add a link to the archive
were the patch is stored which will retrieve the related
patch in diff -au format.

>
> People (like me) feel more confident if they know that
> they don't destroy the work of others if they start
> hacking on a new idea.
>
> You hear/read more of that probably soon.
>

Thanks. I am very glad that you offered to do this. :)

\start
Date: Tue, 28 Mar 2006 22:00:50 +0200
From: Gregory Vanuxem
To: Ralf Hemmecke
Subject: #196 ')set functions compile on' and lastest axiom

Hi Ralf,


I know that you have recently compiled Axiom and i want to know if you
can execute these commands in an Axiom interpreter and give me the
output. I'm working on issue #196 ( )set functions compile on )

-- beware axiom can crash
)set func comp off
f(xl: LIST FRAC INT): LIST FRAC INT == map(x +-> x, xl)
f([1,2,3])
f([1,2,3])


In my version of Axiom (the last i think) these commands
return:

===================================================================
1) -> )set func comp off
(1) -> f(xl: LIST FRAC INT): LIST FRAC INT == map(x +-> x, xl)
   Function declaration f : List Fraction Integer -> List Fraction
Integer has been added to workspace.

Type: Void
(2) -> f([1,2,3])
   Compiling function f with type List Fraction Integer -> List Fraction
Integer
(2) -> f([1,2,3])

   >> System error:
   The function |*1;f;1;initial| is undefined.
===================================================================

The command (1) segfaults on old versions of Axiom and returns nothing
on mine.

\start
Date: 28 Mar 2006 15:48:30 -0500
From: Camm Maguire
To: Jiri Palecek
Subject: Re: Bug#349877: axiom: internal error while executing user function

forwarded 349877 list
thanks

Greetings, and thanks for your report!  Forwarding to axiom upstream.

Take care,


Ji=C5=99=C3=AD Pale=C4=8Dek Jiri Palecek writes:

> X-Debbugs-CC: Jiri Palecek
> Package: axiom
> Version: 20050901-4
> Severity: normal
>
> When I enter in axiom
>
> > p:(NonNegativeInteger)->Polynomial AlgebraicNumber
> > p i==if i=0 then 1 else x^i-reduce(+,[integrate(x^i*p k,x=0..1)=
*p k
> > for  k in 0..i-1])
>
> and then
>
> > p 1
>
> I get this error:
>
>     Internal Error
>     Interpreter code generation failed for expression
>        (IF (= |#1| 0) 1
>            (- (^ |x| |#1|)
>               (|reduce| +
>                   (|construct|
>                       (COLLECT (STEP |k| 0 1 (- |#1| 1))
>                                (* (|integrate|
>                                       (* (^ |x| |#1|) (|p| |k|))
>                                       (= |x| (SEGMENT 0 1)))
>                                   (|p| |k|)))))))
>
>
>
> -- System Information:
> Debian Release: testing/unstable
>    APT prefers testing
>    APT policy: (500, 'testing'), (500, 'stable')
> Architecture: i386 (i686)
> Shell:  /bin/sh linked to /bin/dash
> Kernel: Linux 2.6.15
> Locale: LANG=C, LC_CTYPE=C (charmap=ISO-8859-2) (ignored: LC_ALL set
> to  cs_CZ)
>
> Versions of packages axiom depends on:
> ii  axiom-databases               20050901-4 A general purpose
> computer  algebra
> ii  libc6                         2.3.5-8    GNU C Library: Shared
> libraries an
> ii  libgmp3c2                     4.1.4-10   Multiprecision arithmetic
> library
> ii  libncurses5                   5.5-1      Shared libraries for
> terminal  hand
> ii  libreadline5                  5.1-5      GNU readline and history
> libraries
>
> Versions of packages axiom recommends:
> ii  axiom-doc                     20050901-4 A general purpose
> computer  algebra
> ii  axiom-graphics                20050901-4 A general purpose
> computer  algebra
> ii  axiom-hypertex                20050901-4 A general purpose
> computer  algebra
> pn  axiom-source                  <none>     (no description available)
>
> -- no debconf information
> --
> Using Opera's revolutionary e-mail client: http://www.opera.com/mail/

\start
Date: Tue, 28 Mar 2006 23:50:05 +0200
From: Ralf Hemmecke
To: Gregory Vanuxem
Subject: Re: #196 ')set functions compile on' and lastest axiom

Hi Greg,

I compiled axiom--main--1--patch-47.

Output comes below. I hope that helps...
My Axiom does not crash on that.

Ralf

woodpecker:~>axiom
                         AXIOM Computer Algebra System
                        Version: Axiom (December 2005)
                 Timestamp: Monday March 13, 2006 at 17:28:16
-----------------------------------------------------------------------------
    Issue )copyright to view copyright notices.
    Issue )summary for a summary of useful system commands.
    Issue )quit to leave AXIOM and return to shell.
-----------------------------------------------------------------------------

    Re-reading compress.daase   Re-reading interp.daase
    Re-reading operation.daase
    Re-reading category.daase
    Re-reading browse.daase
(1) ->
(1) -> )set func comp off
(1) -> f(xl: LIST FRAC INT): LIST FRAC INT == map(x +-> x, xl)
    Function declaration f : List Fraction Integer -> List Fraction
       Integer has been added to workspace.
 
Type: Void
(2) -> f([1,2,3])
    Loading /home/hemmecke/software/Axiom/mnt/linux/algebra/INT.o for
       domain Integer
    Loading /home/hemmecke/software/Axiom/mnt/linux/algebra/FRAC.o for
       domain Fraction
    Loading /home/hemmecke/software/Axiom/mnt/linux/algebra/LIST.o for
       domain List
    Loading /home/hemmecke/software/Axiom/mnt/linux/algebra/ILIST.o for
       domain IndexedList
    Loading /home/hemmecke/software/Axiom/mnt/linux/algebra/LSAGG-.o for
       domain ListAggregate&
    Loading /home/hemmecke/software/Axiom/mnt/linux/algebra/STAGG-.o for
       domain StreamAggregate&
    Loading /home/hemmecke/software/Axiom/mnt/linux/algebra/ELAGG-.o for
       domain ExtensibleLinearAggregate&
    Loading /home/hemmecke/software/Axiom/mnt/linux/algebra/FLAGG-.o for
       domain FiniteLinearAggregate&
    Loading /home/hemmecke/software/Axiom/mnt/linux/algebra/URAGG-.o for
       domain UnaryRecursiveAggregate&
    Loading /home/hemmecke/software/Axiom/mnt/linux/algebra/LNAGG-.o for
       domain LinearAggregate&
    Loading /home/hemmecke/software/Axiom/mnt/linux/algebra/RCAGG-.o for
       domain RecursiveAggregate&
    Loading /home/hemmecke/software/Axiom/mnt/linux/algebra/IXAGG-.o for
       domain IndexedAggregate&
    Compiling function f with type List Fraction Integer -> List
       Fraction Integer
(2) -> f([1,2,3])

    >> System error:
    The function |*1;f;1;frame0| is undefined.

\start
Date: 28 Mar 2006 17:28:44 -0500
From: Camm Maguire
To: Tim Daly
Subject: re: GCL patch for Fedora Core 5
Cc: Gerard Milmeister

Greetings!  Could someone please point these out to me?  

Take care,

Tim Daly writes:

> Thanks for the FC5 patches.
> I'll download and build FC5, create an axiom FC5 makefile change,
> and test it. --t

\start
Date: Tue, 28 Mar 2006 18:27:35 -0500
From: Tim Daly
To: Camm Maguire
Subject: [Gerard Milmeister: GCL patch for Fedora Core 5]
Cc: Gerard Milmeister

------- Start of forwarded message -------

Here are the patches I use for compiling GCL on FC5:
gcl-bash.patch: configure contains a bug concering quotes
  and parentheses that has only been triggered by newer bash
gcl-pers.patch: this concerns the personality switch
  because of randomized linking etc ... There has been
  some code in GCL, but this doesn't work anymore.


- --=-0BwGir19qmPpuYENcGhB

- --- gcl-2.6.7/configure.bash	2006-03-08 20:50:04.000000000 +0100
+++ gcl-2.6.7/configure	2006-03-08 20:52:25.000000000 +0100
@@ -1711,7 +1711,7 @@
 	# results, and the version is kept in special file).
     
 	if test -r /etc/.relid -a "X`uname -n`" = "X`uname -s`" ; then
- -	    system=MP-RAS-`${AWK} '{print $3}' /etc/.relid'`
+	    system=MP-RAS-`${AWK} '{print $3}' '/etc/.relid'`
 	fi
 	if test "`uname -s`" = "AIX" ; then
 	    system=AIX-`uname -v`.`uname -r`
@@ -2409,7 +2409,7 @@
     X_LIBS="$X_LIBS -L$x_libraries"
     # For Solaris; some versions of Sun CC require a space after -R and
     # others require no space.  Words are not sufficient . . . .
- -    case "`(uname -sr) 2>/dev/null`" in
+    case "`uname -sr 2>/dev/null`" in
     "SunOS 5"*)
       echo $ac_n "checking whether -R must be followed by a space""... $ac_c" 1>&6
 echo "configure:2416: checking whether -R must be followed by a space" >&5

- --=-0BwGir19qmPpuYENcGhB

- --- gcl-2.6.7/o/main.c.pers	2005-09-09 20:36:46.000000000 +0200
+++ gcl-2.6.7/o/main.c	2005-09-09 21:07:51.000000000 +0200
@@ -117,11 +117,9 @@
 #endif
 #endif
 
- -#ifdef NEED_NONRANDOM_SBRK
 #include <syscall.h>
- -#include <linux/personality.h>
+#include <sys/personality.h>
 #include <unistd.h>
- -#endif
 
 int
 main(int argc, char **argv, char **envp) {
@@ -131,14 +129,25 @@
 #endif
 #endif
 
- -#ifdef NEED_NONRANDOM_SBRK
- -#if SIZEOF_LONG == 4
- -	if (!syscall(SYS_personality,PER_LINUX32))
- -#else
- -        if (!syscall(SYS_personality,PER_LINUX))
- -#endif
- -	  execvp(argv[0],argv);
- -#endif
+	long pers = personality(-1);
+	/* 0x40000 aka. ADDR_NO_RANDOMIZE */
+	if (!(pers & 0x40000)) {
+	  if (personality(pers | 0x40000) != -1) {
+	    /* Use /proc/self/exe instead of trying to figure out the
+	     * executable path from PATH and argv[0], since that's reliable.
+	     */
+	    char buf[PATH_MAX+1];
+	    int rc = readlink("/proc/self/exe", buf, PATH_MAX);
+	    if ( rc > 0 ) {
+	      buf[rc]=0;
+	      execve(buf, argv, envp);
+	    }
+	  }
+	  /* Either changing the personality or execve() failed. Either
+	   * way we might as well continue, and hope that the random
+	   * memory maps are ok this time around.
+	   */
+	}
 
 #if defined(DARWIN)
     extern void init_darwin_zone_compat ();
- --- gcl-2.6.7/configure.pers	2005-09-09 20:51:26.000000000 +0200
+++ gcl-2.6.7/configure	2005-09-09 21:06:56.000000000 +0200
@@ -3887,17 +3887,18 @@
 #line 3888 "configure"
 #include "confdefs.h"
 #include <syscall.h>
- -			    #include <linux/personality.h>
+			    #include <sys/personality.h>
 	         	    #include <stdio.h>
 			    #include <unistd.h>
 			    int main(int argc,char * argv[]) {
 				FILE *f;
- -				#if SIZEOF_LONG == 4
- -				if (!syscall(SYS_personality,PER_LINUX32))
- -				#else
- -				if (!syscall(SYS_personality,PER_LINUX))
- -				#endif
- -					execvp(argv[0],argv);
+                                long pers = personality(-1);
+                                if (!(pers & 0x40000)) {
+                                  if (personality(pers | 0x40000) != -1) {
+                                    execvp(argv[0],argv);
+                                   }
+                                }
+
 				if (!(f=fopen("conftest1","w")))
 					return -1;
 				fprintf(f,"%u",sbrk(0));
@@ -3927,17 +3928,17 @@
 #line 3928 "configure"
 #include "confdefs.h"
 #include <syscall.h>
- -			    #include <linux/personality.h>
+			    #include <sys/personality.h>
 			    #include <stdio.h>
 			    #include <unistd.h>
 			    int main(int argc,char * argv[]) {
 				FILE *f;
- -				#if SIZEOF_LONG == 4
- -				if (!syscall(SYS_personality,PER_LINUX32))
- -				#else
- -				if (!syscall(SYS_personality,PER_LINUX))
- -				#endif
- -					execvp(argv[0],argv);
+                                long pers = personality(-1);
+                                if (!(pers & 0x40000)) {
+                                  if (personality(pers | 0x40000) != -1) {
+                                    execvp(argv[0],argv);
+                                   }
+                                }
 				if (!(f=fopen("conftest1","w")))
 					return -1;
 				fprintf(f,"%u",sbrk(0));
@@ -3989,25 +3990,22 @@
 #include "confdefs.h"
 #include <stdio.h>
             #include <stdlib.h>
- -	    #ifdef NEED_NONRANDOM_SBRK
 		   #include <syscall.h>
- -		   #include <linux/personality.h>
+		   #include <sys/personality.h>
 		   #include <unistd.h>
- -	   #endif
 int
 main(int argc,char * argv[])
 {
   char *b;
   FILE *fp;
 
- -#ifdef NEED_NONRANDOM_SBRK
- -#if SIZEOF_LONG == 4
- -if (!syscall(SYS_personality,PER_LINUX32))
- -#else
- -if (!syscall(SYS_personality,PER_LINUX))
- -#endif
- -     execvp(argv[0],argv);
- -#endif  
+  long pers = personality(-1);
+  if (!(pers & 0x40000)) {
+    if (personality(pers | 0x40000) != -1) {
+      execvp(argv[0],argv);
+    }
+  }
+
   b = (void *) malloc(1000);
   fp = fopen("conftest1","w");
 

\start
Date: Wed, 29 Mar 2006 14:47:25 +1000
From: Mike Thomas
To: Ralf Hemmecke, Martin Rubey
Subject: GNU Arch - was patches
Cc: Gerard Milmeister

Hi all.

> Why don't you use tla?

See the section "Criticisms" on:

    http://en.wikipedia.org/wiki/GNU_Arch

and then the amount of work going on at:

    http://arch.sv.gnu.org/archives/gnu-arch/

\start
Date: 29 Mar 2006 08:54:27 +0200
To: Francois Maltey
From: Francois Maltey
Subject: Re: choose the better expand 

Dear Bill, Martin, William, and other... thanks a lot !

Yesterday I finish a first version of expand sin_cos,
expand sinh_cosh, expand tan_tanh, ...

Now I will improve it thanks to your previous reponses.

And I have theses other questions. This time every one is very short :

1/ what is the << import >> command in a *.spad file.
Martin and Bill give me exemples with import complex or import list.

2/ I can extract an integer from EXPR INTEGER by
   fct (x:R) == if R is Integer then x::Integer else -999
but this doesn't work for Expression Complex Integer
or Expression Fraction Integer.
Can I test in an unknow Ring R if x is a (n:Integer) * 1$R or not.
No one of my tries with a lot of
retractIfCan(x)@Union(Integer, "failed") compile.

3/ I find pretty to expand cos (a+%i*b) with sin/sinh/cos/cosh
but I don't find how to detect a ring as R = Complex S, use real
and imag, and make conversion back as cos a + %i*sinh b,...

4/ Do you want [for Martin I believe] a
expand (factorial (n+1)) and an expand (factorial (n-1)) to
(n+1)*factorial n and factorial n / n.

5/ Do you prefer :
a-expand (sin (2*x+y)) gives an Expression in sin x, sin y, cos x... of cor=
se.
b-expand (sin (3)) remains sin (3) [or do you prefer with sin 1 and cos 1]
c-expand (sin (3*expressions without variables)) remains the same.

I believe that everybody agree to a and b.
But what do I choose for c ?
must I transform sin (sqrt (2) + sqrt (3)) or not ?

6/ Do you see other usefull expand ?

7/ Do you prefer only one expand as above, or do I make a
expand (..., "sincos"), expand (..., "sinhcosh"),
expand (..., "tantanh") or expand (..., "exp").
In this case what is the second argument in others functions of axiom :
a String, a Symbol, a list of ...

8/ In the package TRMANIP, I divide an expression with an Integer by :
  n := c::Integer
  a1 := (a::F)/(n::R::F)
is it the shortest way in use or not ?

9/ at every call of expand there is a
  num := numer arg
  den := denom arg
  b := reductum num / den
  b ^= 0 =>
Is the computation of b at each call is short (1 single machine operation)=

or long (with a factor or a gcd call) ?
Perhaps it's maybe possible to compute with leadingMonomial num, reductum n=
um
without quotient. Do you have any advise ?

\start
Date: Wed, 29 Mar 2006 00:46:02 -0800
From: Antoine Hersen
To: list
Subject: Developing domain

Hello,

Is there a nice iterative process to develop domain, I am getting
tired of quiting axiom deleting the directories and restarting axiom.

And is there a way to get axiom to execute some script as an argument ?

"axiom < some_files" does not work for me.

Also do someone know the intedent of the operator package op.spad ?
I have a lot of difficulty understanding Manuel Bronstein works.

\start
Date: Wed, 29 Mar 2006 07:58:44 -0500
From: Bill Page
To: Antoine Hersen
Subject: RE: Developing domain

On March 29, 2006 3:46 AM Antoine Hersen wrote:
> 
> Is there a nice iterative process to develop domain, I am
> getting tired of quiting axiom deleting the directories and
> restarting axiom.

???

I use just:

  while unhappy repeat
    )sys vi file.spad
    ... code ...
    )co file.spad
    ... test ...

Or increasingly these days I just use the Axiom Wiki SandBox.

[SandBox My Test]

  Some explanations etc.
  \begin{spad}
   ... code ...
  \end{spad}

  \begin{axiom}
  ... test ...
  end{axiom}

  Preview/Save

Or are you one of those people that has an Axiom installation
that does not properly cleanup the NRLIB directories? This does
not happen on any of my Axiom systems (3 different flavours of
Linux plus Windows). If so, any more documentation you can
provide about this would be appreciated.

> 
> And is there a way to get axiom to execute some script as
> an argument ?
> 
> "axiom < some_files" does not work for me.
>

Try

      AXIOMsys < some_file

'AXIOMsys' is the name of the main Axiom executable. 'axiom'
is a script that runs all kinds of other stuff like sman,
hyperdoc and graphics processes.
 
> Also do someone know the intedent of the operator package
> op.spad ? I have a lot of difficulty understanding Manuel
> Bronstein works.
> 

Check out section 9.58 of the Axiom book:

9.58 Operator
Given any ring R, the ring of the Integer-linear operators
over R is called Operator(R). To create an operator over R,
first create a basic operator using the operation operator,
and then convert it to Operator(R) for the R you want.

\start
Date: Wed, 29 Mar 2006 10:23:38 -0500
From: Tim Daly
To: Antoine Hersen
Subject: Re: Developing domain

)sys rm -rf FOO.erlib FOO.NRLIB

\start
Date: Wed, 29 Mar 2006 18:52:10 +0200
From: Gregory Vanuxem
To: Tim Daly
Subject: PATCH: #248 Bug#347199: axiom-doc: Book is

Hi,


Attached is a patch that has to be applied on src/doc/boot.pamphlet.
For information see:

http://wiki.axiom-developer.org/248Bug347199AxiomDocBookIsAllMonospaceafterPage1019


The author is Matijs van Zuijlen

--- ../axiom-old/src/doc/book.pamphlet	2005-08-14 14:05:13.002428312 +0200
+++ src/doc/book.pamphlet	2006-03-29 18:41:59.040346128 +0200
@@ -62233,7 +62233,7 @@
 These commands return the state of the interactive
 environment to that immediately after step {\tt n}.
 If {\tt n} is a positive number, then {\tt n} refers to step nummber
-{\tt n}. If {\tt n} is a negative number, it refers to the \tt n-th
+{\tt n}. If {\tt n} is a negative number, it refers to the {\tt n}-th
 previous command (that is, undoes the effects of the last $-n$
 commands).
 

\start
Date: Wed, 29 Mar 2006 12:48:21 -0500
From: Tim Daly
To: Gregory Vanuxem
Subject: Re: PATCH: #248 Bug#347199: axiom-doc: Book is	all-monospaceafter page 1019

applied. fixed in the next release --t

--- ../axiom-old/src/doc/book.pamphlet	2005-08-14 14:05:13.002428312 +0200
+++ src/doc/book.pamphlet	2006-03-29 18:41:59.040346128 +0200
@@ -62233,7 +62233,7 @@
 These commands return the state of the interactive
 environment to that immediately after step {\tt n}.
 If {\tt n} is a positive number, then {\tt n} refers to step nummber
-{\tt n}. If {\tt n} is a negative number, it refers to the \tt n-th
+{\tt n}. If {\tt n} is a negative number, it refers to the {\tt n}-th
 previous command (that is, undoes the effects of the last $-n$
 commands).

\start
Date: Wed, 29 Mar 2006 23:04:03 +0200
From: Ralf Hemmecke
To: Bill Page
Subject: re: libaxiom.a

Hi Bill,

>> ... I am proposing to remove NIL (or at least to hide it
>> in some low level library), since in my eyes that sounds
>> not very mathematical. If I want an empty list, it is 
>> much better to say "empty$List(...)" than "NIL$Lisp".
>> Don't you agree?
> 
> Sure. It's only a name. Maybe the notation:
> 
>   []$List(...)
> 
> is even better? (We can hope the compiler optimizes this too.)

Maybe someone knows better than me, but I am very much thinking that the 
compiler has no chance to optimize that.

The reason is very simple.

"[]" is the same as "bracket()" and there is no **program code** that 
says that "bracket()" should be equal to the constant "empty". That 
equality is currently a reasonable convention, but it is a **convention**.

In order to optimize, the compiler would have to analyze "List" very 
carefully. I think that is impossible. Am I wrong?

\start
Date: Thu, 30 Mar 2006 00:09:06 +0200
From: Ralf Hemmecke
To: Bill Page
Subject: re: libaxiom.a

On 03/24/2006 06:54 PM, Page, Bill wrote:
> Maybe S-expression can be defined in Aldor without imports
> from foreign lisp something like this (very roughly):
[snip]
> But then you would just be re-inventing part of Lisp inside
> Aldor and there doesn't seem to be much point since you can
> get all this from Lisp for "free".

Maybe some people are very accustomed to SExpressions, I am not. I am 
perfectly happy with Lists whose elements have a particular type, for 
example, "List(Boolean)". SExpressions are already a bit more 
complicated. And I cannot belief that they are the most natural thing 
that a mathematician can think of.

 > Aldor is designed to compile to Lisp as one option.
> It is natural to continue to use this in Axiom.

I am not against LISP. If code can be re-used then it's fine.
But there was already someone on the list who said that it would not be 
so easy to build a (symbolic-algebra) object library that could be 
linked to Fortran or C (or any other language) programs.

Anyway, that Lisp discussion is quite useful for me. In Axiom I am 
sometimes missing the "Rep" of a domain.

   src/algebra/boolean.spad.pamphlet

Now I belief, that in such a case the representation is an SExpression. 
Wrong?

\start
Date: Thu, 30 Mar 2006 00:12:03 +0200
From: Ralf Hemmecke
To:  Mike Thomas
Subject: Re: GNU Arch - was patches

Mike,

what do you want to say by your comment?

Ralf

On 03/29/2006 06:47 AM, Mike Thomas wrote:
> Hi all.
>  
>> Why don't you use tla?
> 
> See the section "Criticisms" on:
> 
>     http://en.wikipedia.org/wiki/GNU_Arch
> 
> and then the amount of work going on at:
> 
>     http://arch.sv.gnu.org/archives/gnu-arch/

\start
Date: Thu, 30 Mar 2006 00:16:02 +0200
From: Ralf Hemmecke
To: Antoine Hersen
Subject: Re: Developing domain

Antoine,

I hope you are not writing SPAD, but Aldor code.
In the latter case, you can simply develop without starting Axiom at 
all. All you need is libaxiom.al and axiom.as.

I hope I can show you some setup at the Axiom workshop.

Ralf

On 03/29/2006 10:46 AM, Antoine Hersen wrote:
> Is there a nice iterative process to develop domain, I am getting
> tired of quiting axiom deleting the directories and restarting axiom.

\start
Date: Thu, 30 Mar 2006 09:50:39 +1000
From: Mike Thomas
To: Ralf Hemmecke
Subject: RE: GNU Arch - was patches

Hi Ralf.

> what do you want to say by your comment?

I want to say that tla/GNU arch is not at all looking good as a source
control system (it's problematic on Windows and looks like it is barely
alive as an on-going project) and I would suggest dropping it as a tool
for the Axiom project.

I am perturbed by the splitting of the Axiom effort into separate Arch
source trees/sub-projects which seem not to be able to remerge (due
apparently to lack of developer time and/or interest) and which are
presumably becoming more divergent from the core CVS source repository
due to ongoing bitrot.

I realise that you were writing with respect to a more specific issue,
but your recommendation prompted me to write in respect of the more
general issue of the Axiom source code control system.

For that reason I changed the topic of the thread.

I further say that the multiplicity of unresolved source control systems
and sub-projects in the Axiom project is just one sign of what is
looking more and more like an overgrown and somewhat choked garden to
me.

I'm actually rather a fan of overgrown gardens, but I do like to feel
that I can walk through them to get at the flowers without falling into
a well.

\start
Date: Wed, 29 Mar 2006 20:05:49 -0500
From: Tim Daly
To: Mike Thomas
Subject: re: GNU Arch - was patches

Mike,

> I want to say that tla/GNU arch is not at all looking good as a source
> control system (it's problematic on Windows and looks like it is barely
> alive as an on-going project) and I would suggest dropping it as a tool
> for the Axiom project.

I'm currently working on projects that use CVS (doyen), SVN (magnus/work),
Arch (axiom), and git (personal stuff). I don't like any of the systems.
All of them seem baroque and broken. I do admit that arch is a challenge
to use.

Complaining, however, is different from advocating.
What exactly do you advocate and why?

> 
> I am perturbed by the splitting of the Axiom effort into separate Arch
> source trees/sub-projects which seem not to be able to remerge (due
> apparently to lack of developer time and/or interest) and which are
> presumably becoming more divergent from the core CVS source repository
> due to ongoing bitrot.

Except for the control files (.arch vs .cvs) the code repository on
axiom-developer.org, savannah.nongnu.org, and sourceforge.net are all
bit-for-bit identical. Every change I push to one of those I push to
all of those. Where do you see bitrot?

> 
> I realise that you were writing with respect to a more specific issue,
> but your recommendation prompted me to write in respect of the more
> general issue of the Axiom source code control system.
> 
> For that reason I changed the topic of the thread.
> 
> I further say that the multiplicity of unresolved source control systems
> and sub-projects in the Axiom project is just one sign of what is
> looking more and more like an overgrown and somewhat choked garden to
> me.

The only "subprojects" in the axiom project are specific branches that
have been created to separate various developers who planned to work
on separate threads. These do not impact the main branch in any way
until the work is complete and I merge the two branches. For example,
Bill Page has a windows branch.

What developers do with their separate subprojects is entirely up to
them. I have no opinion on how/when/if they maintain them until the
time comes to merge the systems.

All changes and merges to the "golden sources" on the main branch at
the 3 primary sites are done by hand, hand checked, and hand tested so
it matters not at all which repository system we use. I don't trust
the golden sources to automated tools. For me, it's a matter of quality.

> 
> I'm actually rather a fan of overgrown gardens, but I do like to feel
> that I can walk through them to get at the flowers without falling into
> a well.

The current local count (on my disks and various machines) shows that I
have upwards of 20 different branches working on separate problems like
the mac port, the FC5 port, the ansi port, the X-on-windows effort,
the provisos effort, the maple-integration-bugs effort, the next book, etc.

While it's a rather overgrown garden (more like a swamp) none of these
branches are visible to the outside world.

I make every effort to make sure that the code that appears in all
of the repositories is clean, tested, round-trip retested, and is
the latest version available at the time of the update. They are
all identical by design.

If you find that is NOT the case please bring it to my attention
and I'll fix it and the process that caused it.

\start
Date: Thu, 30 Mar 2006 10:33:22 +1000
From: Mike Thomas
To: Tim Daly
Subject: re: GNU Arch - was patches

Hi Tim.

> The only "subprojects" in the axiom project are specific
> branches that have been created to separate various
> developers who planned to work on separate threads. These do
> not impact the main branch in any way until the work is
> complete and I merge the two branches. For example, Bill Page
> has a windows branch.

Am I right in believing that changes in the main "golden sources are
_not_ being fed into those subprojects?

That is the bitrot to which I refer.

\start
Date: Wed, 29 Mar 2006 20:38:53 -0500
From: Tim Daly
To: Mike Thomas
Subject: re: GNU Arch - was patches

> > The only "subprojects" in the axiom project are specific 
> > branches that have been created to separate various 
> > developers who planned to work on separate threads. These do 
> > not impact the main branch in any way until the work is 
> > complete and I merge the two branches. For example, Bill Page 
> > has a windows branch.
> 
> Am I right in believing that changes in the main "golden sources are
> _not_ being fed into those subprojects?
> 
> That is the bitrot to which I refer.

That depends entirely on the people listed for the subprojects.
Their local copy may be up to date and not reflected on the host.
For instance, I'm not sure what policy Bill Page uses to maintain
the windows branch.

The lack of upkeep on the server copy of a branch seems to be
completely independent of the issue of which maintenance system
to use. I doubt that people who don't update their server copy
would be motivated to do it under any other scheme. After all,
a commit in Arch is only one command.

\start
Date: Thu, 30 Mar 2006 10:54:17 +1000
From: Mike Thomas
To: Tim Daly
Subject: re: GNU Arch - was patches

PS.

> the X-on-windows effort,

Just as a friendly suggestion over the back garden fence, rather than
trying to fit a square peg into a round hole by making Axiom X based on
Windows, wouldn't your time (as a well regarded highly productive and
uncommonly competent lisp programmer) be better spent either:

   i) picking up on the LTK GUI project which stands a very good chance
of being portable across many platforma and CL compilers with very
little effort from someone like yourself, or

   ii) for much more work but in the long term probably more rewarding,
porting CFFI to GCL and thence an industrial strength GUI binding like
wxCL based on the highly portable wxWidgets library.

\start
Date: Thu, 30 Mar 2006 11:10:00 +1000
From: Mike Thomas
To: Tim Daly
Subject: re: GNU Arch - was patches

> The lack of upkeep on the server copy of a branch seems to be
> completely independent of the issue of which maintenance
> system to use.

I'm arguing precisely against the shunting aside of separate subprojects
to which Arch's alleged capabilities contributed. I see both processes
as therefore being dependent.

I doubt whether many of the changes being made in, for example, the spad
parts of Axiom are relevant to the purely system related issues of the
Windows sub-project and therefore it is an unnecessary step to have to
back port into the sub-project only to have to merge later on into the
main arch tree and then further merge into CVS, otherwise facing the
possibility of being out-of-date with important bug fixes.

I am also saying that Arch is useless on Windows.

Believe me, if you don't like tla on Unix platforms, you would abhor it
under Windows.  The only way I was able to undo the mess it made of my
file system under Cygwin (exacerbated I admit by a network domain change
which stuffed up) was to spend hours changing file permissions and
renaming directories to Windows acceptable file name lengths on two
different computers. 

Furthermore I was never able to get ssh commits working with Arch.

It will take a very good reason for me ever to use Arch again.

\start
Date: Wed, 29 Mar 2006 21:04:00 -0500
From: Tim Daly
To: Mike Thomas
Subject: re: GNU Arch - was patches

> Just as a friendly suggestion over the back garden fence, rather than
> trying to fit a square peg into a round hole by making Axiom X based on
> Windows, wouldn't your time (as a well regarded highly productive and
> uncommonly competent lisp programmer) be better spent either:
> 
>    i) picking up on the LTK GUI project which stands a very good chance
> of being portable across many platforma and CL compilers with very
> little effort from someone like yourself, or

I did some work with LTK. In fact, my son maintained a branch of that
effort for a while. I spent some time trying to get it to work without
success. (This was reported on the mailing list somewhere).

I also recently tried xgcl-2 which is packaged with GCL. It failed.
But it appears that Camm has recently put some work into it and I
might try again.

> 
>    ii) for much more work but in the long term probably more rewarding,
> porting CFFI to GCL and thence an industrial strength GUI binding like
> wxCL based on the highly portable wxWidgets library.

I'm a member of the lisp-gardener's project and have been pursuing this
strategy. Unfortunately UFFI isn't universal. CFFI also isn't. FFI
works in clisp thus:

(use-package "FFI")
(def-call-out clip-open
          (:name "OpenClipboard") (:library "user32.dll")
	      (:arguments (hwnd uint))
	      (:return-type int)
	      (:language :stdc))
		  
but clisp is ansi and I can't get there yet. (Ansi lisp is another
subproject that is not yet ready for prime time.)

I've also spent time trying to get McClim to run. And an effort to use
the browser as a front-end (AJAX-based). And a side-effort thru Ron
Avitzur to consider using his graphing tool instead.

So far I have succeeded in making the X-based browser run standalone
on a windows platform. I'm looking at getting the graphics to work
but so far no luck. If those two can be made to run then I just have
to get sman to talk to all of the parts and a full axiom will be
available on windows.

These are hard problems (at least for me) and it all takes time.

\start
Date: Wed, 29 Mar 2006 21:10:12 -0500
From: Tim Daly
To: Mike Thomas
Subject: re: GNU Arch - was patches

> I am also saying that Arch is useless on Windows.
> 
> Believe me, if you don't like tla on Unix platforms, you would abhor it
> under Windows.  The only way I was able to undo the mess it made of my
> file system under Cygwin (exacerbated I admit by a network domain change
> which stuffed up) was to spend hours changing file permissions and
> renaming directories to Windows acceptable file name lengths on two
> different computers.  
> 
> Furthermore I was never able to get ssh commits working with Arch.
> 
> It will take a very good reason for me ever to use Arch again.

You have a problem with an open source tool.
You have the source.
You have the skill.
Fix the code and send the patches to arch.
It is, after all, exactly what you suggested I do with LTK and GCL.

In the alternate you can use CVS to access sourceforge or savannah
which are up to date sources for Axiom. Thus you really don't need
Arch.

\start
Date: Thu, 30 Mar 2006 11:24:03 +1000
From: Mike Thomas
To: Tim Daly
Subject: re: GNU Arch - was patches

> These are hard problems (at least for me) and it all takes time.

You're a hard worker!  I recently ran LTK 0.78 on Windows with GCL 2.7.0
but the latest 0.8x defeated the GCL compiler.

One other interesting note is that following a lead in a message on
C.L.L I recently tried running Debian with Axiom (browser and graphics)
under VMPlayer hosted on Windows and it worked beautifully.

\start
Date: Thu, 30 Mar 2006 11:31:29 +1000
From: Mike Thomas
To: Tim Daly
Subject: re: GNU Arch - was patches

>
> You have a problem with an open source tool.
> You have the source.
> You have the skill.
> Fix the code and send the patches to arch.

Why waste my time on something that goes against what I think is the
best policy and that I believe doesn't need to be done?

> It is, after all, exactly what you suggested I do with LTK and GCL.

As a possible way of saving you some time and furthering the progress of
Axiom.

> In the alternate you can use CVS to access sourceforge or
> savannah which are up to date sources for Axiom. Thus you
> really don't need Arch.

Thanks - that would definitely bypass the problem when next I get the
time to work on Axiom.  Would it be possible for you to merge all the
Windows work back into CVS?

\start
Date: Wed, 29 Mar 2006 21:23:26 -0500
From: Tim Daly
To: Mike Thomas
Subject: re: GNU Arch - was patches

cool. I'll look into the vmplayer solution. --t

\start
Date: Wed, 29 Mar 2006 21:28:28 -0500
From: Tim Daly
To: list
Subject: OSDL Fellowship Fund

Perhaps some of us could create a proposal for Axiom funding of students?


OSDL Fellowship Fund

The Open Source Development Labs (OSDL) has established the OSDL
Fellowship Fund to provide financial support to software developers
working on Linux and open source community projects. Under the 
auspices of this fund, OSDL works with users, vendors, and developers
to identify where and how additional work or resources could 
accelerate development efforts and spur the adoption of Linux
and open source software.

http://www.osdl.org/lab_activiies/fellowship_fund

\start
Date: Wed, 29 Mar 2006 21:32:13 -0500
From: Tim Daly
To: Mike Thomas
Subject: re: GNU Arch - was patches

> Thanks - that would definitely bypass the problem when next I get the
> time to work on Axiom.  Would it be possible for you to merge all the
> Windows work back into CVS?

I'll bring it up with Bill who maintains that branch. --t

\start
Date: Wed, 29 Mar 2006 21:16:27 -0500
From: Bill Page
To: Ralf Hemmecke
Subject: re: libaxiom.a

On March 29, 2006 5:09 PM Ralf Hemmecke wrote:
> 
> Maybe some people are very accustomed to SExpressions, I am
> not. I am perfectly happy with Lists whose elements have a
> particular type, for example, "List(Boolean)". Sexpressions
> are already a bit more complicated. And I cannot belief that
> they are the most natural thing that a mathematician can
> think of.
>

I am not sure how to define "natural" but the concept of an
S-expression was certainly invented by a mathematician. If you
haven't already read, it I think John McCarthy's paper original
1960 paper:

http://www-formal.stanford.edu/jmc/recursive.html

"RECURSIVE FUNCTIONS OF SYMBOLIC EXPRESSIONS AND THEIR
COMPUTATION BY MACHINE"

See also

http://www-formal.stanford.edu/jmc/index.html
http://www.paulgraham.com/rootsoflisp.html
 
>  > Aldor is designed to compile to Lisp as one option.
> > It is natural to continue to use this in Axiom.
> 
> I am not against LISP. If code can be re-used then it's fine.
> But there was already someone on the list who said that it 
> would not be so easy to build a (symbolic-algebra) object
> library that could be linked to Fortran or C (or any other
> language) programs.

Why?

> 
> Anyway, that Lisp discussion is quite useful for me. In Axiom
> I am sometimes missing the "Rep" of a domain.
> 
>    src/algebra/boolean.spad.pamphlet
> 
> Now I belief, that in such a case the representation is an 
> SExpression.  Wrong?
> 

Exactly right! The representation is inherited from Lisp.
I think that it should be acceptible to write:

  Rep == Lisp

just like we can write $Lisp In other words from the point
of view of SPAD and Aldor Lisp should appear just like a
pre-defined domain.

\start
Date: 30 Mar 2006 04:24:11 +0200
From: Gabriel Dos Reis
To: Tim Daly
Subject: re: GNU Arch - was patches

Tim Daly writes:

[...]

| What exactly do you advocate and why?

SVN.

In many aspects that I care about directly for working on Axiom, I
find it a better tool than tla.

\start
Date: Wed, 29 Mar 2006 21:48:10 -0500
From: Bill Page
To: Gabriel Dos Reis
Subject: re: GNU Arch - was patches

On March 29, 2006 9:24 PM Gabriel Dos Reis wrote:
> 
> Tim Daly writes:
> 
> [...]
> 
> | What exactly do you advocate and why?
> 
> SVN.
> 
> In many aspects that I care about directly for working on Axiom,
> I find it a better tool than tla.
> 

darcs.

I find it a better tool than tla and SVN... :)

http://mark.stosberg.com/Tech/darcs/cvs_switch/
http://osdir.com/Article2571.phtml
http://blog.ianbicking.org/distributed-vs-centralized-scm.html

The only reason I can think of to use SVN would be if you
already have CVS burned into your brain. ;)

\start
Date: Wed, 29 Mar 2006 22:09:00 -0800
From: Antoine Hersen
To: list
Subject: Re: Developing domain

Hello

> > Is there a nice iterative process to develop domain, I am
> > getting tired of quiting axiom deleting the directories and
> > restarting axiom.
>
> ???
>
> I use just:
>
>   while unhappy repeat
>     )sys vi file.spad
>     ... code ...
>     )co file.spad
>     ... test ...

vi !!!! (just kidding)

> Or increasingly these days I just use the Axiom Wiki SandBox.
>
> [SandBox My Test]
>
>   Some explanations etc.
>   \begin{spad}
>    ... code ...
>   \end{spad}
>
>   \begin{axiom}
>   ... test ...
>   end{axiom}
>
>   Preview/Save
>
> Or are you one of those people that has an Axiom installation
> that does not properly cleanup the NRLIB directories? This does
> not happen on any of my Axiom systems (3 different flavours of
> Linux plus Windows). If so, any more documentation you can
> provide about this would be appreciated.

Debian Stable, with the last arch version of axiom hand compiled,
anything I can do to give more useful info ?

> >
> > And is there a way to get axiom to execute some script as
> > an argument ?
> >
> > "axiom < some_files" does not work for me.
> >
>
> Try
>
>       AXIOMsys < some_file
It works but quit as soon as it is done, I guess AXIOMsys is coded in
C and I could fix that myself

> > Also do someone know the intedent of the operator package
> > op.spad ? I have a lot of difficulty understanding Manuel
> > Bronstein works.
> >
>
> Check out section 9.58 of the Axiom book:
>
> 9.58 Operator
> Given any ring R, the ring of the Integer-linear operators
> over R is called Operator(R). To create an operator over R,
> first create a basic operator using the operation operator,
> and then convert it to Operator(R) for the R you want.

Yes I had read that, I just do not see the big picture.

\start
Date: Wed, 29 Mar 2006 22:28:25 -0800
From: Antoine Hersen
To: list
Subject: re: GNU Arch - was patches

Hello,

What about SVK(  http://svk.elixus.org/ ), it seem to be based on
Subversion plus distributed a la Arch
It is based on PERL a more reasonable dependency that Haskell.

I have never used it( RCS cover most of my need), so it is just
presenting another option.

\start
Date: Thu, 30 Mar 2006 09:38:27 +0200
From: David Mentre
To: Antoine Hersen
Subject: re: GNU Arch - was patches

Hello,

2006/3/30, Antoine Hersen:
> What about SVK(  http://svk.elixus.org/ ), it seem to be based on
> Subversion plus distributed a la Arch
> It is based on PERL a more reasonable dependency that Haskell.

I am on SVK's mailing list for several months now. SVK is interesting
but seems a bit unstable (judging from bug report on the list). I have
never used it thought (because it failed to compile on my Debian
system, probably due to a Debian peculiarity).

It appears that we have about 10 Axiom developers, with 10 different
SCM (Bill: Darcs; Tim: Arch, CVS; Gabriel: SVN; me: patch, Arch (never
again, Mercurial/SVN/SVK under study), Antoine: SVK; Ralf: Arch; Mike:
CVS?, ...).

That's why I suggest :
 - stop discussing tool issues and focus on real *Axiom* code;

 - use the plain old patch (that any SCM of your choice can generate)
submitted to this mailing list and to Tim for peer review and possible
integration ;

 - use the CVS trees (sourceforge, savannah) as reference.

Those who feed the most patches and code will impose their tools on
the others (and Tim have last word as our benevolent dictator).

Well, I might have fed yet another troll. :-)

\start
Date: 30 Mar 2006 10:51:11 +0200
From: Gabriel Dos Reis
To: David Mentre
Subject: re: GNU Arch - was patches

David Mentre writes:

| Hello,
| 
| 2006/3/30, Antoine Hersen:
| > What about SVK(  http://svk.elixus.org/ ), it seem to be based on
| > Subversion plus distributed a la Arch
| > It is based on PERL a more reasonable dependency that Haskell.
| 
| I am on SVK's mailing list for several months now. SVK is interesting
| but seems a bit unstable (judging from bug report on the list). I have
| never used it thought (because it failed to compile on my Debian
| system, probably due to a Debian peculiarity).

SVK is a handy tool over SVN.  Axiom needs not switch to SVK;
switching to SVN is sufficient.  

As a matter of fact, it is what I use for most of GCC related work
even when GCC is officially under SVN (other parts of GCC, mostly
"administrative" things are still under CVS, but the bulk is under
SVN).  I released two versions of GCC with actual work done with SVK,
while the releasing script operates with SVN.

My main complaint with SVK (main memory hungry) was fixed ages ago.   I'm
using SVK 1.05 (which is old by many criteria).  I'm using SVK as a
tool over SVN because of its storage efficiency -- at the minimum, I
must have 3 GCC active releasing branches, plus 3 other "experimental"
branches; so it is crucial to save space (even when Dell offers tera
bytes disks at ridiculuous costs, because I'm not lucky enough to
change laptops even six months).

I was reluctant to see GCC switch from CVS to SVN (my concerns are
archived on the GCC list) because of all the instability and
dependency issues that arose at the time with SVN (october 2005) and
was impressed by how respsonsive SVN people were to resolve them.  I
don't think Axiom's sources are as "big" as GCC's -- build might be
comparable though. 

I don't really care what the version tool is, as long as it is not
tal, nor patch, nors darcs :-)  CVS is good enough, as long as one does
not need to work offline (which is a very limiting constraint these
days when laptop have to spend lot of time on the go).

\start
Date: Thu, 30 Mar 2006 12:24:26 +0200
From: Frederic Lehobey
To: list
Subject: re: GNU Arch - was patches

Hi,

On Thu, Mar 30, 2006 at 09:38:27AM +0200, David MENTRE wrote:

> It appears that we have about 10 Axiom developers, with 10 different
> SCM (Bill: Darcs; Tim: Arch, CVS; Gabriel: SVN; me: patch, Arch (never
> again, Mercurial/SVN/SVK under study), Antoine: SVK; Ralf: Arch; Mike:
> CVS?, ...).

One more to make everybody (most?) happy :
http://www.darcs.net/DarcsWiki/Tailor
(see http://darcs.arstecnica.it/tailor/README).

> That's why I suggest :
>  - stop discussing tool issues and focus on real *Axiom* code;
> 
>  - use the plain old patch (that any SCM of your choice can generate)
> submitted to this mailing list and to Tim for peer review and possible
> integration ;

Well said, David...  And then patches flew to the list (instead of
neverending threads).  :-)

\start
Date: Thu, 30 Mar 2006 06:39:58 -0500
From: Bill Page
To: Antoine Hersen
Subject: RE: Developing domain

On March 30, 2006 1:09 AM Antoine Hersen wrote:
> Bill Page wrote:
> >
> > I use just:
> >
> >   while unhappy repeat
> >     )sys vi file.spad
> >     ... code ...
> >     )co file.spad
> >     ... test ...
> 
> vi !!!! (just kidding)

I only use vi when I am unhappy... a kind of self-punishment. ;)

> >
> > Or are you one of those people that has an Axiom installation
> > that does not properly cleanup the NRLIB directories? This does
> > not happen on any of my Axiom systems (3 different flavours of
> > Linux plus Windows). If so, any more documentation you can
> > provide about this would be appreciated.
> 
> Debian Stable, with the last arch version of axiom hand compiled,
> anything I can do to give more useful info ?

Using an earlier (September source distributioin) I can not reproduce
your problem on Debian stable. Either this is due to a recent change
in Axiom sources or (perhaps) you have some different file permissions
than me.

Does the same thing happen if you run and compile as 'root'?

> 
> >
> >       AXIOMsys < some_file
> It works but quit as soon as it is done, I guess AXIOMsys is coded
> in C and I could fix that myself

??? What else did you expect it to do? What is there to fix?

No, AXIOMsys is **not** written in C. It is written in Lisp. It is
a saved GCL image.

> >
> > Check out section 9.58 of the Axiom book:
> >
> > 9.58 Operator
> > Given any ring R, the ring of the Integer-linear operators
> > over R is called Operator(R). To create an operator over R,
> > first create a basic operator using the operation operator,
> > and then convert it to Operator(R) for the R you want.
> 
> Yes I had read that, I just do not see the big picture.
> 

When you see the big picture please send a sketch of it to the
rest of us. ;)

\start
Date: Fri, 31 Mar 2006 01:10:42 +1100 (EST)
From: Qiaoyan Liang
To: list
Subject: Error running Axiom on NetBSD

Hi there,

I got this error while running ./configure

"Your system name is NetBSD
We do not know how to build for this kind of system
Send a note to list about it"

Is there anyway to install Axiom on NetBSD? Or do you know anyone who has
successfully install Axiom on such a system. Looking forward to your
reply.

Regards,
Corine

\start
Date: Thu, 30 Mar 2006 10:42:23 -0500
From: Tim Daly
To: Qiaoyan Liang
Subject: Re: Error running Axiom on NetBSD

Corine,

assuming you put Axiom somewhere, say /tmp, then try:

export AXIOM=/tmp/axiom/mnt/linux
export PATH=$AXIOM/bin:$PATH
make

save the console output and post it if it fails.

\start
Date: 30 Mar 2006 17:39:59 +0200
From: Martin Rubey
To: Antoine Hersen
Subject: op.spad

"Antoine Hersen" Antoine Hersen writes:

> > > Also do someone know the intedent of the operator package
> > > op.spad ? I have a lot of difficulty understanding Manuel
> > > Bronstein works.
> > >
> >
> > Check out section 9.58 of the Axiom book:
> >
> > 9.58 Operator
> > Given any ring R, the ring of the Integer-linear operators
> > over R is called Operator(R). To create an operator over R,
> > first create a basic operator using the operation operator,
> > and then convert it to Operator(R) for the R you want.
> 
> Yes I had read that, I just do not see the big picture.

The idea is the following: There is a wide variety of mathematical operations
one cannot always completely "evaluate", or "simplify", but nevertheless, one
needs them in a domain like Expression Integer. These are called
"CommonOperators" in axiom and are listed in the file op.spad, in the package
CommonOperators. Some examples are rootOf, sin, pi, BesselJ, sum, product,
factorial, ...

Note that they do not share much structure, they even take a different number
of arguments.

Still, as much structure they have is described in the domain BasicOperator.

Of course, you can create your own operators. For example, suppose that you
have a recurrence together with the initial values. In some cases you will be
able to find a "closed form" for the n-th term of the recurrence. Then it is
easy to use it in Expression Integer.

However, more often than not, you won't know a closed form, but still you want
to use your recurrence as an expression. Maybe you want to state

Take the n-th term of the recurrence and square it.

To be able to do so, you introduce a new operator, for example, like I did on

http://wiki.axiom-developer.org/RecurrenceRelationOperator

In short (more documentation if you follow the link), you say

oprecur := operator("rootOfRec"::Symbol)$BasicOperator

to create a new operator called "rootOfRec". Then

setProperty(oprecur, "%specialDisp", 
                ddrec@(List F -> OutputForm) pretend None)

to tell axiom how it should be displayed -- ddrec is the operation that does
the display given the arguments of the operator. Finally,

evaluate(oprecur, irecur)$BasicOperatorFunctions1(F)

tells axiom which function to invoke when the operator should be
"evaluated". Here, the function invoked is "irecur".


I hope this helps, at least a little.

\start
Date: Thu, 30 Mar 2006 09:07:55 -0800
From: Antoine Hersen
To: Bill Page
Subject: Re: Developing domain

Hello

On 3/30/06, Bill Page wrote:
> On March 30, 2006 1:09 AM Antoine Hersen wrote:
> > Bill Page wrote:
> > >
> > > I use just:
> > >
> > >   while unhappy repeat
> > >     )sys vi file.spad
> > >     ... code ...
> > >     )co file.spad
> > >     ... test ...
> >
> > vi !!!! (just kidding)
>
> I only use vi when I am unhappy... a kind of self-punishment. ;)

Don't be so arch with yourself.

> > > Or are you one of those people that has an Axiom installation
> > > that does not properly cleanup the NRLIB directories? This does
> > > not happen on any of my Axiom systems (3 different flavours of
> > > Linux plus Windows). If so, any more documentation you can
> > > provide about this would be appreciated.
> >
> > Debian Stable, with the last arch version of axiom hand compiled,
> > anything I can do to give more useful info ?
>
> Using an earlier (September source distributioin) I can not reproduce
> your problem on Debian stable. Either this is due to a recent change
> in Axiom sources or (perhaps) you have some different file permissions
> than me.
>
> Does the same thing happen if you run and compile as 'root'?

If I run as root :

drwxr-xr-x   2 root    root    4096 2006-03-30 09:40 DPOLY.erlib
drwxr-xr-x   2 antoine antoine 4096 2006-03-30 09:40 DPOLY.NRLIB

it was in a new directory, and I compiled axiom on my user account so
I guess it explain why the NRLIB is under this user. Still that look
kind of worrisome.


> > >       AXIOMsys < some_file
> > It works but quit as soon as it is done, I guess AXIOMsys is coded
> > in C and I could fix that myself
>
> ??? What else did you expect it to do? What is there to fix?

Like (wish full thinking )

AXIOMsys -l some_file
it will just load the file and then give you the prompt :)
or
AXIOMsys -l < some_file
and will not quit at EOF

\start
Date: Fri, 31 Mar 2006 02:48:25 +0200
From: Gregory Vanuxem
To: Tim Daly
Subject: #196 ')set functions compile on'

Hi Tim,


I'm working on the issue #196 and i have found the code responsible of
this bug. The problem is the expansion of macro. The code is (in
src/inter/macros.lisp.pamphlet):

====================================================================
(defun eval-defun (name body) (eval (macroexpandall body)))

(defun macroexpandall (sexpr)
(cond
  ((atom sexpr) sexpr)
  ((eq (car sexpr) 'quote) sexpr)
  ((eq (car sexpr) 'defun)
   (cons (car sexpr) (cons (cadr sexpr)
       (mapcar #'macroexpandall (cddr sexpr)))))
  ((and (symbolp (car sexpr)) (macro-function (car sexpr)))
   (do ()
       ((not (and (consp sexpr) (symbolp (car sexpr))
  (macro-function (car sexpr)))))
     (setq sexpr (macroexpand sexpr)))
   (if (consp sexpr)
       ; infinite loop generated on lambda expression
       (mapcar #'macroexpandall sexpr)
       sexpr))
  ('else 
    (mapcar #'macroexpandall sexpr))))
=====================================================================

The problem is apparently the expansion of lambda expression.
macroexpandall expands (lambda *) to (function (lambda) *) and reexpands
it causing an infinite loop and therefore a value stack overflow and on
older version of Axiom a segmentation fault.

I use the following dirty hack but since i'm not a good lisp programmer
and you are, as you said, a lisp programmer maybe you can find a better
solution:

=====================================================================
(defun macroexpandall (sexpr)
(cond
  ((atom sexpr) sexpr)
  ((eq (car sexpr) 'quote) sexpr)
  ((eq (car sexpr) 'defun)
   (cons (car sexpr) (cons (cadr sexpr)
       (mapcar #'macroexpandall (cddr sexpr)))))
  ((and (symbolp (car sexpr)) (macro-function (car sexpr)))
   (do ()
       ((not (and (consp sexpr) (symbolp (car sexpr))
                  (macro-function (car sexpr)))))
     (setq sexpr (macroexpand sexpr)))
   (if (consp sexpr)
       (let ((a (car sexpr)) (b (caadr sexpr))) 
         (if (and (eq a 'function) (eq b 'lambda))
           (cons a (list (cons b (mapcar #'macroexpandall (cdadr
sexpr)))))
           (mapcar #'macroexpandall sexpr)))
       sexpr))
  ('else        
    (mapcar #'macroexpandall sexpr))))
======================================================================


If you can loot at this, when time permits of course.


PS: If you write a patch, can you send me the new code ?
    If this bug is fixed we can close issues #196 and #114 




Some notes:

=================================================================
Environment:

)tr  genMapCode 
)tr mkInterpFun
)tr compileDeclaredMap
)tr reportFunctionCompilation 
)tr compileInteractive 
)tr COMP
)tr COMP_-1
)tr COMP_-2 
--)tr COMP_-SPADSLAM 
--)tr COMP_-ILAM 
--)tr compClam 
--)tr MOAN 
--)tr COMP_-SLAM 
)tr COMP370 
--)tr COMPILE


-- standard-output redirection and 
-- *comp370-apply* affectation ('eval-defun')
)tr compQuietly  

-- funcall *comp370-apply*
)lisp (trace VMLISP::COMPILE1)

=================================================================


Some code that triggers this bug and the corresponded macroexpandall
argument:

------------------------------------------------------

)set func comp off
f(xl: LIST FRAC INT): LIST FRAC INT == map(x +-> x, xl)
f [1,2,3]

(DEFUN |*1;f;1;initial| (|#1| |envArg|) (PROG (#:G1420) (RETURN (PROGN
(LETT #:G1420 (QUOTE UNINITIALIZED_VARIABLE) |f| |*1;f;1;initial|)
(SPADCALL (CONS (|function| (LAMBDA (#:G1420 |envArg|) #:G1420))
(VECTOR)) |#1| (QREFELT |*1;f;1;initial;MV| 0))))))

------------------------------------------------------

)set func comp off
CurryR(f:(INT,INT)->INT):INT->(INT->INT) ==
(x:INT):(INT->INT)+->curryRight(f,x)
p:=CurryR(+)

(DEFUN |*1;CurryR;1;initial| (|#1| |envArg|) (PROG (#:G1420) (RETURN
(PROGN (LETT #:G1420 (QUOTE UNINITIALIZED_VARIABLE) |CurryR| |
*1;CurryR;1;initial|) (CONS (|function| (LAMBDA (#:G1420 |envArg|)
(SPADCALL (ELT |envArg| 0) #:G1420 (QREFELT |
*1;anonymousFunction;0;initial;internal;MV| 0)))) (VECTOR |#1|))))))


------------------------------------------------------

)set func comp off
j:=120
nume(a) == cons(1 :: Float,[((a-i)*i) :: Float for i in 1..]);
dene(a,x) == [(x+2*i+1-a) :: Float for i in 0..];
cfe(a,x) == continuedFraction(0,nume(a),dene(a,x));
ccfe(a,x) == convergents cfe(a,x);
gamcfe(a,x) == exp(-x)*x^a*ccfe(a,x).j;
gamcfe(2,3)

(DEFUN |*1;nume;1;initial| (|#1| |envArg|) (PROG (|i|) (RETURN (PROGN
(LETT |i| (QUOTE UNINITIALIZED_VARIABLE) |nume| |*1;nume;1;initial|)
(SPADCALL (QUOTE (1 . 0)) (SPADCALL (CONS (|function| (LAMBDA (|i| |
envArg|) (|failCheck| (SPADCALL (SPADCALL (SPADCALL (ELT |envArg| 0) |i|
(QREFELT |*1;nume;1;initial;MV| 5)) |i| (QREFELT |*1;nume;1;initial;MV|
6)) (QREFELT |*1;nume;1;initial;MV| 7))))) (VECTOR |#1|)) (SPADCALL
(SPADCALL (SPADCALL (SPADCALL 1 (QREFELT |*1;nume;1;initial;MV| 0))
(QREFELT |*1;nume;1;initial;MV| 2)) (QREFELT |*1;nume;1;initial;MV| 3))
(SPADCALL (SPADCALL 1 (QREFELT |*1;nume;1;initial;MV| 0)) (QREFELT |
*1;nume;1;initial;MV| 1)) (QREFELT |*1;nume;1;initial;MV| 4)) (QREFELT |
*1;nume;1;initial;MV| 8)) (QREFELT |*1;nume;1;initial;MV| 9))))))


\start
Date: 31 Mar 2006 08:54:35 +0200
From: Martin Rubey
To: Gregory Vanuxem
Subject: Re: #196 ')set functions compile on'

Dear Greg,

> I'm working on the issue #196 and i have found the code responsible of this
> bug.

I just wanted to say that I highly appreciate your work. This is just great -
things get better and better!

\start
Date: Fri, 31 Mar 2006 16:46:47 +0700 (NOVST)
From: Andrey G. Grozin
To: list
Subject: problems with accessing wiki.axiom-developer.org

Hello,

Today I cannot access wiki.axiom-developer.org (and www.axiom-developer.org,
etc.). Packets reach r-1.core04.stl.rosehosting.com, and then 100% package
loss.

Is this only me? Or others have problems too?

\start
Date: Fri, 31 Mar 2006 09:07:50 -0500
From: Bill Page
To: Andrey G. Grozin
Subject: RE: problems with accessing wiki.axiom-developer.org

On March 31, 2006 4:47 AM Andrey G. Grozin wrote:
> 
> Today I cannot access wiki.axiom-developer.org (and 
> www.axiom-developer.org,
> etc.). Packets reach r-1.core04.stl.rosehosting.com,
> and then 100% package loss.
> 
> Is this only me? Or others have problems too?
> 

The problem started about 16:00 h EST yesterday. I have not
been able to connect to the axiom-developer.org server
in the usual way via ssh and I have not been able to contact
Tim Daly, who pays the bills and has root access to that
machine, so I don't know what is wrong. I know, however that
RoseHosting, the company that provides the shared virtual
server, was planning to upgrade the operting system on this
machine. Perhaps something went wrong with the upgrade?

I will let you know when I find out more.

\start
Date: Fri, 31 Mar 2006 16:58:58 +0200
From: Frederic Lehobey
To: list
Subject: Debian sarge unofficial backports of axiom
Cc: Camm Maguire

Hi,

Thanks to the great packaging work of Camm Maguire on Axiom
(http://packages.qa.debian.org/a/axiom.html) I have been able to
provide sarge backports of his latest packages.

If people are interested in this, they can find the instructions
there:
http://lehobey-rennes.dyndns.org/dokuwiki/doku.php?id=doc:abonde

Note that :
 * as the packages are not official, I have diverted the bug reports
from Debian towards me.  Please do not bother Camm for problems *I*
might be responsible for (always check which packages you are using,
official Debian ones or unofficial backports).
 * the server is on my own DSL line, so expect it to be *very* slow (I
have limited upload).
 * much care has been made to build them in a clean sarge environment
(pbuilder) and their version number is chosen such that as (hopefully)
not to mix up with futur (official) upgrades.

\start
Date: Fri, 31 Mar 2006 10:58:05 -0500
From: Bill Page
To: list
Subject: RE: problems with accessing wiki.axiom-developer.org

Here is short update on the status of the axiom-developer.org
server.

I just talked to Tim Daly by telephone. Note: Tim's email is
also inaccessible because it is hosted at the same server.
Apparently RoseHosting called him to explain that there had
been a RAID controller failure on this server. It will take
2 or 3 hours to get the system operational again. Although in
principle a RAID configuration should be fairly fault tolerant,
RoseHosting was not able to re-assure Tim that they would be
able to restore the full contents of the virtual disk on which
the Axiom Wiki and Axiom Portal reside. At this point we can
only wait and see if it comes back or not.

Now the bad news: As many of you are aware, we do not have
current backups or a full mirror of the Axiom web site
although there are some older copies of the Zope database that
have been copied to other sites. If RoseHosting cannot restore
the virtual disk to the state it was in when the hardware failed
we will likely be in a position of having to piece the content
together again from incomplete sources.

This is a consequence of both inadequate resources and minimal
funding. (Tim has personally paid for the entire cost for the
axiom-developer.org site for the last 2 1/2 years.) So, this
problem brings up the question again about how to best to support
this sort of service for Axiom. If we (collectively) are convinced
that this sort of web site is important for Axiom, I think we
need to make a plan to prevent this sort of problem in the future.

The Axiom Wiki and Axiom Portal web sites were originally only an
experimental prototype that grew into a "production" system without
any proper planning. So this might also be an opportunity to plan
to re-implement the server in more up to date software and in a
properly documented fashion.

I will let you know more as/when I hear it.

Thank you for your patience and understanding. :)

Regards,
Bill Page.

On March 31, 2006 9:08 AM Bill Page wrote:
> 
> On March 31, 2006 4:47 AM Andrey G. Grozin wrote:
> > 
> > Today I cannot access wiki.axiom-developer.org (and 
> > www.axiom-developer.org,
> > etc.). Packets reach r-1.core04.stl.rosehosting.com,
> > and then 100% package loss.
> > 
> > Is this only me? Or others have problems too?
> > 
> 
> The problem started about 16:00 h EST yesterday. I have not
> been able to connect to the axiom-developer.org server
> in the usual way via ssh and I have not been able to contact
> Tim Daly, who pays the bills and has root access to that
> machine, so I don't know what is wrong. I know, however that
> RoseHosting, the company that provides the shared virtual
> server, was planning to upgrade the operating system on this
> machine. Perhaps something went wrong with the upgrade?
> 
> I will let you know when I find out more.

\start
Date: Fri, 31 Mar 2006 08:13:58 -0800
From: Bob McElrath
To: Bill Page
Subject: Re: problems with accessing wiki.axiom-developer.org


--d9ADC0YsG2v16Js0

As you know I wrote a script and cron job to backup mathaction's zodb
some months ago.  However, it seems to not be working.  (aargh!)

The most recent backup I have is from 11/27.  :(

Bill Page [Bill Page] wrote:
> Here is short update on the status of the axiom-developer.org
> server.
> 
> I just talked to Tim Daly by telephone. Note: Tim's email is
> also inaccessible because it is hosted at the same server.
> Apparently RoseHosting called him to explain that there had
> been a RAID controller failure on this server. It will take
> 2 or 3 hours to get the system operational again. Although in
> principle a RAID configuration should be fairly fault tolerant,
> RoseHosting was not able to re-assure Tim that they would be
> able to restore the full contents of the virtual disk on which
> the Axiom Wiki and Axiom Portal reside. At this point we can
> only wait and see if it comes back or not.
> 
> Now the bad news: As many of you are aware, we do not have
> current backups or a full mirror of the Axiom web site
> although there are some older copies of the Zope database that
> have been copied to other sites. If RoseHosting cannot restore
> the virtual disk to the state it was in when the hardware failed
> we will likely be in a position of having to piece the content
> together again from incomplete sources.
> 
> This is a consequence of both inadequate resources and minimal
> funding. (Tim has personally paid for the entire cost for the
> axiom-developer.org site for the last 2 1/2 years.) So, this
> problem brings up the question again about how to best to support
> this sort of service for Axiom. If we (collectively) are convinced
> that this sort of web site is important for Axiom, I think we
> need to make a plan to prevent this sort of problem in the future.
> 
> The Axiom Wiki and Axiom Portal web sites were originally only an
> experimental prototype that grew into a "production" system without
> any proper planning. So this might also be an opportunity to plan
> to re-implement the server in more up to date software and in a
> properly documented fashion.
> 
> I will let you know more as/when I hear it.
> 
> Thank you for your patience and understanding. :)

\start
Date: 31 Mar 2006 21:22:08 +0200
From: Francois Maltey
To: list
Subject: Re: choose the better expand

Re-hello,

I find how to use retractIfCan(x)@Union(Integer, "failed"), 

But I can't detect if the basis ring R is a complex one :
real and imag work in any *.input files, but can't compile even
if I add :
  
  CTM ==> ComplexTrigonometricManipulations _
             (Integer, Expression Complex Integer)
  ...
  R is Complex Integer => 
    imag arg::Expression Complex Integer)@CTM
  ...

The type of the variable arg is F inside the manip.spad file, 
and I believe that << F = Expression Complex Integer >>
because << R is Complex Integer >> in this case.
But I can't coerce from F to Expression Complex Integer even if they are
equal.

The function imag is in ComplexTrigonometricManipulations...
I see it with )sh... but I can't use it in the *.spad file.

I continue to discover axiom...

\start
Date: Fri, 31 Mar 2006 11:51:00 -0800
From: Antoine Hersen
To: Bill Page
Subject: Re: problems with accessing wiki.axiom-developer.org

Hello,

I went trying to set up aldor/axiom and found out that MathAction is
down( anybody know how ?)

That does not look good if we can not recover the data.

I can not provide funding but I can provide cron backup if desired.

I know I delete most of them but we get notification of page update on
the mailing list so maybe we will be able to reconstruct everything ?

Good luck,
Antoine Hersen

On 3/31/06, Bob McElrath wrote:
> As you know I wrote a script and cron job to backup mathaction's zodb
> some months ago.  However, it seems to not be working.  (aargh!)
>
> The most recent backup I have is from 11/27.  :(
>
> Bill Page [Bill Page] wrote:
> > Here is short update on the status of the axiom-developer.org
> > server.
> >
> > I just talked to Tim Daly by telephone. Note: Tim's email is
> > also inaccessible because it is hosted at the same server.
> > Apparently RoseHosting called him to explain that there had
> > been a RAID controller failure on this server. It will take
> > 2 or 3 hours to get the system operational again. Although in
> > principle a RAID configuration should be fairly fault tolerant,
> > RoseHosting was not able to re-assure Tim that they would be
> > able to restore the full contents of the virtual disk on which
> > the Axiom Wiki and Axiom Portal reside. At this point we can
> > only wait and see if it comes back or not.
> >
> > Now the bad news: As many of you are aware, we do not have
> > current backups or a full mirror of the Axiom web site
> > although there are some older copies of the Zope database that
> > have been copied to other sites. If RoseHosting cannot restore
> > the virtual disk to the state it was in when the hardware failed
> > we will likely be in a position of having to piece the content
> > together again from incomplete sources.
> >
> > This is a consequence of both inadequate resources and minimal
> > funding. (Tim has personally paid for the entire cost for the
> > axiom-developer.org site for the last 2 1/2 years.) So, this
> > problem brings up the question again about how to best to support
> > this sort of service for Axiom. If we (collectively) are convinced
> > that this sort of web site is important for Axiom, I think we
> > need to make a plan to prevent this sort of problem in the future.
> >
> > The Axiom Wiki and Axiom Portal web sites were originally only an
> > experimental prototype that grew into a "production" system without
> > any proper planning. So this might also be an opportunity to plan
> > to re-implement the server in more up to date software and in a
> > properly documented fashion.
> >
> > I will let you know more as/when I hear it.
> >
> > Thank you for your patience and understanding. :)

\start
Date: Thu, 30 Mar 2006 23:53:16 -0500
From: Tim Daly
To: Gregory Vanuxem
Subject: Re: #196 ')set functions compile on'

great job. thanks.
i'll check it and probably clean it up a bit and then post the patch. --t

\start
Date: 31 Mar 2006 22:30:45 +0200
From: Martin Rubey
To: Tim Daly
Subject: Re: problems with accessing wiki.axiom-developer.org

Tim Daly writes:

...

Oh what a relief to hear from you! And it seems that MathAction is quite
complete! I was truly worried.

Wouldn't it be sensible to put the wiki itself under version control? As far as
I know, tla/arch has a method to easily create a mirror. This way we also would
be able to keep a complete history of the changes.

Of course, I would only put the "sources" of the pages under version control,
i.e., the text you get when you click on the edit button.

\start
Date: 31 Mar 2006 22:23:48 +0200
From: Martin Rubey
To: Francois Maltey
Subject: Re: choose the better expand

Francois Maltey writes:

> The type of the variable arg is F inside the manip.spad file, 
> and I believe that << F = Expression Complex Integer >>
> because << R is Complex Integer >> in this case.

no:   

F : Join(FunctionSpace R, TranscendentalFunctionCategory)

only tells you that F has FunctionSpace R.

Expression Complex Integer is a domain in FunctionSpace R, but there might be
others...


  CTM ==> ComplexTrigonometricManipulations _
             (Integer, Expression Complex Integer)
  ...
  R is Complex Integer => 
    imag(arg::Expression Complex Integer)@CTM
  ...

this doesn't make sense: CTM is not a domain, f(arg)@D uses an f such that the
result is in the domain D. You probably meant to type f(arg)$D, which uses f
from package or domain D. 


I guess that you want to use imag: F -> FR from

ComplexTrigonometricManipulations(R, F): Exports == Implementation where
  R : Join(IntegralDomain, OrderedSet, RetractableTo Integer)
  F : Join(AlgebraicallyClosedField, TranscendentalFunctionCategory,
           FunctionSpace Complex R)

  FR  ==> Expression R


from within 

)abbrev package TRMANIP TranscendentalManipulations
TranscendentalManipulations(R, F): Exports == Implementation where
  R : Join(OrderedSet, GcdDomain)
  F : Join(FunctionSpace R, TranscendentalFunctionCategory)


What type has arg really? Please provide code that illustrates what you would
like to do.

\start
Date: Fri, 31 Mar 2006 23:57:40 +0200
From: Ralf Hemmecke
To: Bill Page
Subject: Re: problems with accessing wiki.axiom-developer.org

> Now the bad news: As many of you are aware, we do not have
> current backups or a full mirror of the Axiom web site
> although there are some older copies of the Zope database that
> have been copied to other sites.

I guess my Zope data.fs is approximatly from end of january.

\start
Date: Fri, 31 Mar 2006 18:06:14 -0500
From: Tim Daly
To: Bill Page
Subject: Re: problems with accessing wiki.axiom-developer.org

The axiom-developer.org server is back online.
I've signed up for a nightly backup service in the unlikely event
of a server crash :-)

\start
Date: Fri, 31 Mar 2006 17:26:00 -0500
From: Bill Page
To: Ralf Hemmecke, Bob McElrath
Subject: RE: problems with accessing wiki.axiom-developer.org

Axiom Developers,

Well, it looks like RoseHosting came through and was able to
restore the axiom-developer.org server... Hurray!

http://wiki.axiom-developer.org

Hmmm... for those people have an old copy of the web site, now
might be a good time for you to update you copies of the Zope
database (and the other contents var directory and the products
directory if possible).

The current production version on axiom-developer.org is at:

  /var/zope/var/Data.fs          <==== Zope DB
  /var/zope/var/LatexWiki        <==== image and NRLIBS cache
  /var/zope/Products             <==== source code

And we still need to talk about how to better handle this
situation in the future, including what to do about future
development of the website.

One thing that I would really like to do is to have a live
mirror site. This would require that someone be willing to
donate space on a Internet connected machine that can be
configured to run the same software as on axiom-developer.org.

Regards,
Bill Page.

On March 31, 2006 4:58 PM Ralf Hemmecke wrote:
> Bill Page wrote: 
> > Now the bad news: As many of you are aware, we do not have
> > current backups or a full mirror of the Axiom web site
> > although there are some older copies of the Zope database that
> > have been copied to other sites.
> 
> I guess my Zope data.fs is approximatly from end of january.
> 

On March 31, 2006 11:14 AM Bob McElrath wrote:
> 
> As you know I wrote a script and cron job to backup mathaction's
> zodb some months ago.  However, it seems to not be working.
>  (aargh!)

\start
Date: Fri, 31 Mar 2006 18:10:08 -0500
From: Bill Page
To: Tim Daly
Subject: RE: problems with accessing wiki.axiom-developer.org

On March 31, 2006 6:06 PM Tim Daly (root) wrote:
> 
> The axiom-developer.org server is back online.
> I've signed up for a nightly backup service in the unlikely
> event of a server crash :-)
> 

Great. Thanks, Tim!

   Do you feel a little like being held hostage? ;)

Anyway, local backup makes very good sense. But I still think
we should have a live mirror for this site - one with the same
content but in a different physical location (Europe?). There
is software available for Zope that would allow us to keep the
two site in synch with each other.

Also, I remain very concerned about how the Axiom Community
should be sharing the cost for this server. I think it would
be great if we could find a corporate/institutional sponsor
who would be willing to contribute to the cost.

\start
Date: Fri, 31 Mar 2006 18:26:04 -0500
From: Bill Page
To: Martin Rubey
Subject: RE: problems with accessing wiki.axiom-developer.org

On March 31, 2006 3:31 PM Martin Rubey wrote:
> ... 
> Wouldn't it be sensible to put the wiki itself under version 
> control? As far as I know, tla/arch has a method to easily
> create a mirror. This way we also would be able to keep a
> complete history of the changes.
> 
> Of course, I would only put the "sources" of the pages under 
> version control, i.e., the text you get when you click on the
> edit button.
> 

The difficulty here is that the sources of the pages on MathAction
are actually all stored in a single file called 'Data.fs'. This
file contains the "Zope database". All of the persistent objects
(pages and scripts), their properties and history that is managed
by Zope is stored in this one file. Zope already provides a form
of version control.

tla on the other hand is oriented to maintaining the history of
a large group of files. It can not very usefully manage the
contents of a single file.

There are other intelligent ways of creating a complete and
up to date mirror of the MathAction site. One approach would be
to use 'rsync'. There is also a tool designed specifically for
Zope to synchronize two remote Zope-based web sites.

http://www.contentmanagementsoftware.info/zope/ZSyncer

\start
Date: Fri, 31 Mar 2006 18:12:17 -0800
From: Antoine Hersen
To: axiom-developer <list>
Subject: Map

Hello,

I am having some trouble with the function map applied to  List.

When using it in input files axiom complains but oblige but in a spad
files I am always running to disaster.

I end up using a [my_function i for i in my_list ]

I guess I am not using $ and @ correctly, can anybody give me some advices ?

\start
Date: Fri, 31 Mar 2006 21:50:42 -0500
From: Bill Page
To: Antoine Hersen
Subject: RE: Map

On March 31, 2006 9:12 PM Antoine Hersen wrote:
> 
> I am having some trouble with the function map applied to List.
> 
> When using it in input files axiom complains but oblige but in
> a spad files I am always running to disaster.
> 
> I end up using a [my_function i for i in my_list ]
> 
> I guess I am not using $ and @ correctly, can anybody give me 
> some advices ?
> 

To get some useful advice please be specific and give some
examples. Even better: Create a page in the Axiom Wiki SandBox
that shows what you are trying to do. Then someone can help you.

How to use of $ and @ is explained in the Axiom book.

If an expression X is converted using one of the three operators
to type T the interpretations are:

:: means explicitly convert X to type T if possible.
$ means use the available operators for type T to compute X.
@ means choose operators to compute X so that the result is of
  type T.

e.g.

  f(x)$A  means to call the function f from package/domain A
  f(x)@B  means to call some function f that returns a result of
          type B

See:

0.4.5 Control of Result Types

Regards,
Bill Page.





